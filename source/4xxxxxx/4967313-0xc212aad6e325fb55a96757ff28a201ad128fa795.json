{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\nContract interface:\r\n- Standars ERC20 methods: balanceOf, totalSupply, transfer, transferFrom, approve, allowance\r\n- Function issue, argument amount\r\n    issue new amount coins to totalSupply\r\n- Function destroy, argument amount\r\n    remove amount coins from totalSupply if available in contract\r\n    used only by contract owner\r\n- Function sell - argument amount, to\r\n    Used only by contract owner\r\n    Send amount coins to address to\r\n- Function kill\r\n    Used only by contract owner\r\n    destroy cantract\r\n    Contract can be destroyed if totalSupply is empty and all wallets are empty\r\n- Function setTransferFee arguments numinator, denuminator\r\n    Used only by contract owner\r\n    set transfer fee to numinator/denuminator\r\n- Function changeTransferFeeOwner, argument address \r\n    Used only by contract owner\r\n    change transfer fees recipient to address\r\n- Function sendDividends, arguments address, amount\r\n    Used only by contract owner\r\n    address - ERC20 address\r\n    issue dividends to investors - amount is tokens\r\n- Function sendDividendsEthers\r\n    Used only by contract owner\r\n    issue ether dividends to investors\r\n- Function addInvestor, argument - address\r\n    Used only by contract owner\r\n    add address to investors list (to paying dividends in future)\r\n- Function removeInvestor, argument - address\r\n    Used only by contract owner\r\n    remove address from investors list (to not pay dividends in future)\r\n- Function getDividends\r\n    Used by investor to actual receive dividend coins\r\n- Function changeRate, argument new_rate\r\n    Change coin/eth rate for autosell\r\n- Function changeMinimalWei, argument new_wei\r\n    Used only by contract owner\r\n    Change minimal wei amount to sell coins wit autosell\r\n*/\r\n\r\npragma solidity ^0.4.11;\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n//contract PDT is PDT {\r\ncontract PDT {\r\n    using SafeMath for uint256;\r\n\r\n    // totalSupply is zero by default, owner can issue and destroy coins any amount any time\r\n    uint constant totalSupplyDefault = 0;\r\n\r\n    string public constant symbol = \"PDT\";\r\n    string public constant name = \"Prime Donor Token\";\r\n    uint8 public constant decimals = 5;\r\n\r\n    uint public totalSupply = 0;\r\n\r\n    // minimum fee is 0.00001\r\n    uint32 public constant minFee = 1;\r\n    // transfer fee default = 0.17% (0.0017)\r\n    uint32 public transferFeeNum = 17;\r\n    uint32 public transferFeeDenum = 10000;\r\n\r\n    uint32 public constant minTransfer = 10;\r\n\r\n    // coin exchange rate to eth for automatic sell\r\n    uint256 public rate = 1000;\r\n\r\n    // minimum ether amount to buy\r\n    uint256 public minimalWei = 1 finney;\r\n\r\n    // wei raised in automatic sale\r\n    uint256 public weiRaised;\r\n\r\n    //uint256 public payedDividends;\r\n    //uint256 public dividends;\r\n    address[] tokens;\r\n\r\n    // Owner of this contract\r\n    address public owner;\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n    address public transferFeeOwner;\r\n\r\n    function notOwner(address addr) internal view returns (bool) {\r\n        return addr != address(this) && addr != owner && addr != transferFeeOwner;\r\n    }\r\n\r\n\r\n    // ---------------------------- dividends related definitions --------------------\r\n    // investors white list\r\n    // dividends can be send only investors from list\r\n    mapping(address => bool) public investors;\r\n\r\n    // minimal coin balance to pay dividends\r\n    uint256 public constant investorMinimalBalance = uint256(10000)*(uint256(10)**decimals);\r\n\r\n    uint256 public investorsTotalSupply;\r\n\r\n    uint constant MULTIPLIER = 10e18;\r\n\r\n    // dividends for custom coins\r\n    mapping(address=>mapping(address=>uint256)) lastDividends;\r\n    mapping(address=>uint256) totalDividendsPerCoin;\r\n\r\n    // dividends for custom ethers\r\n    mapping(address=>uint256) lastEthers;\r\n    uint256 divEthers;\r\n\r\n/*\r\n    function balanceEnough(uint256 amount) internal view returns (bool) {\r\n        return balances[this] >= dividends && balances[this] - dividends >= amount;\r\n    }\r\n    */\r\n\r\n    function activateDividendsCoins(address account) internal {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address addr = tokens[i];\r\n            if (totalDividendsPerCoin[addr] != 0 && totalDividendsPerCoin[addr] > lastDividends[addr][account]) {\r\n                if (investors[account] && balances[account] >= investorMinimalBalance) {\r\n                    var actual = totalDividendsPerCoin[addr] - lastDividends[addr][account];\r\n                    var divs = (balances[account] * actual) / MULTIPLIER;\r\n                    Debug(divs, account, \"divs\");\r\n\r\n                    ERC20 token = ERC20(addr);\r\n                    if (divs > 0 && token.balanceOf(this) >= divs) {\r\n                        token.transfer(account, divs);\r\n                        lastDividends[addr][account] = totalDividendsPerCoin[addr];\r\n                    }\r\n                }\r\n                lastDividends[addr][account] = totalDividendsPerCoin[addr];\r\n            }\r\n        }\r\n    }\r\n\r\n    function activateDividendsEthers(address account) internal {\r\n        if (divEthers != 0 && divEthers > lastEthers[account]) {\r\n            if (investors[account] && balances[account] >= investorMinimalBalance) {\r\n                var actual = divEthers - lastEthers[account];\r\n                var divs = (balances[account] * actual) / MULTIPLIER;\r\n                Debug(divs, account, \"divsEthers\");\r\n\r\n                require(divs > 0 && this.balance >= divs);\r\n                account.transfer(divs);\r\n                lastEthers[account] = divEthers;\r\n            }\r\n            lastEthers[account] = divEthers;\r\n        }\r\n    }\r\n\r\n    function activateDividends(address account) internal {\r\n        activateDividendsCoins(account);\r\n        activateDividendsEthers(account);\r\n    }\r\n\r\n    function activateDividends(address account1, address account2) internal {\r\n        activateDividends(account1);\r\n        activateDividends(account2);\r\n    }\r\n\r\n    function addInvestor(address investor) public onlyOwner {\r\n        activateDividends(investor);\r\n        investors[investor] = true;\r\n        if (balances[investor] >= investorMinimalBalance) {\r\n            investorsTotalSupply = investorsTotalSupply.add(balances[investor]);\r\n        }\r\n    }\r\n    function removeInvestor(address investor) public onlyOwner {\r\n        activateDividends(investor);\r\n        investors[investor] = false;\r\n        if (balances[investor] >= investorMinimalBalance) {\r\n            investorsTotalSupply = investorsTotalSupply.sub(balances[investor]);\r\n        }\r\n    }\r\n\r\n    function sendDividends(address token_address, uint256 amount) public onlyOwner {\r\n        require (token_address != address(this)); // do not send this contract for dividends\r\n        require(investorsTotalSupply > 0); // investor capital must exists to pay dividends\r\n        ERC20 token = ERC20(token_address);\r\n        require(token.balanceOf(this) > amount);\r\n\r\n        totalDividendsPerCoin[token_address] = totalDividendsPerCoin[token_address].add(amount.mul(MULTIPLIER).div(investorsTotalSupply));\r\n\r\n        // add tokens to the set\r\n        uint idx = tokens.length;\r\n        for(uint i = 0; i < tokens.length; i++) {\r\n            if (tokens[i] == token_address || tokens[i] == address(0x0)) {\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n        if (idx == tokens.length) {\r\n            tokens.length += 1;\r\n        }\r\n        tokens[idx] = token_address;\r\n    }\r\n\r\n    function sendDividendsEthers() public payable onlyOwner {\r\n        require(investorsTotalSupply > 0); // investor capital must exists to pay dividends\r\n        divEthers = divEthers.add((msg.value).mul(MULTIPLIER).div(investorsTotalSupply));\r\n    }\r\n\r\n    function getDividends() public {\r\n        // Any investor can call this function in a transaction to receive dividends\r\n        activateDividends(msg.sender);\r\n    }\r\n    // -------------------------------------------------------------------------------\r\n \r\n    // Balances for each account\r\n    mapping(address => uint) balances;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint)) allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from , address indexed to , uint256 value);\r\n    event TransferFee(address indexed to , uint256 value);\r\n    event TokenPurchase(address indexed from, address indexed to, uint256 value, uint256 amount);\r\n    event Debug(uint256 from, address to, string value);\r\n\r\n    function transferBalance(address from, address to, uint256 amount) internal {\r\n        if (from != address(0x0)) {\r\n            require(balances[from] >= amount);\r\n            if (notOwner(from) && investors[from] && balances[from] >= investorMinimalBalance) {\r\n                if (balances[from] - amount >= investorMinimalBalance) {\r\n                    investorsTotalSupply = investorsTotalSupply.sub(amount);\r\n                } else {\r\n                    investorsTotalSupply = investorsTotalSupply.sub(balances[from]);\r\n                }\r\n            }\r\n            balances[from] = balances[from].sub(amount);\r\n        }\r\n        if (to != address(0x0)) {\r\n            balances[to] = balances[to].add(amount);\r\n            if (notOwner(to) && investors[to] && balances[to] >= investorMinimalBalance) {\r\n                if (balances[to] - amount >= investorMinimalBalance) {\r\n                    investorsTotalSupply = investorsTotalSupply.add(amount);\r\n                } else {\r\n                    investorsTotalSupply = investorsTotalSupply.add(balances[to]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // if supply provided is 0, then default assigned\r\n    function PDT(uint supply) public {\r\n        if (supply > 0) {\r\n            totalSupply = supply;\r\n        } else {\r\n            totalSupply = totalSupplyDefault;\r\n        }\r\n        owner = msg.sender;\r\n        transferFeeOwner = owner;\r\n        balances[this] = totalSupply;\r\n    }\r\n\r\n    function changeTransferFeeOwner(address addr) onlyOwner public {\r\n        transferFeeOwner = addr;\r\n    }\r\n \r\n    function balanceOf(address addr) constant public returns (uint) {\r\n        return balances[addr];\r\n    }\r\n\r\n    // fee is not applied to owner and transferFeeOwner\r\n    function chargeTransferFee(address addr, uint amount)\r\n        internal returns (uint) {\r\n        activateDividends(addr);\r\n        if (notOwner(addr) && balances[addr] > 0) {\r\n            var fee = amount * transferFeeNum / transferFeeDenum;\r\n            if (fee < minFee) {\r\n                fee = minFee;\r\n            } else if (fee > balances[addr]) {\r\n                fee = balances[addr];\r\n            }\r\n            amount = amount - fee;\r\n\r\n            transferBalance(addr, transferFeeOwner, fee);\r\n            Transfer(addr, transferFeeOwner, fee);\r\n            TransferFee(addr, fee);\r\n        }\r\n        return amount;\r\n    }\r\n \r\n    function transfer(address to, uint amount)\r\n        public returns (bool) {\r\n        activateDividends(msg.sender, to);\r\n        //activateDividendsFunc(to);\r\n        if (amount >= minTransfer\r\n            && balances[msg.sender] >= amount\r\n            && balances[to] + amount > balances[to]\r\n            ) {\r\n                if (balances[msg.sender] >= amount) {\r\n                    amount = chargeTransferFee(msg.sender, amount);\r\n\r\n                    transferBalance(msg.sender, to, amount);\r\n                    Transfer(msg.sender, to, amount);\r\n                }\r\n                return true;\r\n          } else {\r\n              return false;\r\n          }\r\n    }\r\n \r\n    function transferFrom(address from, address to, uint amount)\r\n        public returns (bool) {\r\n        activateDividends(from, to);\r\n        //activateDividendsFunc(to);\r\n        if ( amount >= minTransfer\r\n            && allowed[from][msg.sender] >= amount\r\n            && balances[from] >= amount\r\n            && balances[to] + amount > balances[to]\r\n            ) {\r\n                allowed[from][msg.sender] -= amount;\r\n\r\n                if (balances[from] >= amount) {\r\n                    amount = chargeTransferFee(from, amount);\r\n\r\n                    transferBalance(from, to, amount);\r\n                    Transfer(from, to, amount);\r\n                }\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function approve(address spender, uint amount) public returns (bool) {\r\n        allowed[msg.sender][spender] = amount;\r\n        Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address addr, address spender) constant public returns (uint) {\r\n        return allowed[addr][spender];\r\n    }\r\n\r\n    function setTransferFee(uint32 numinator, uint32 denuminator) onlyOwner public {\r\n        require(denuminator > 0 && numinator < denuminator);\r\n        transferFeeNum = numinator;\r\n        transferFeeDenum = denuminator;\r\n    }\r\n\r\n    // Manual sell\r\n    function sell(address to, uint amount) onlyOwner public {\r\n        activateDividends(to);\r\n        //require(amount >= minTransfer && balanceEnough(amount));\r\n        require(amount >= minTransfer);\r\n\r\n        transferBalance(this, to, amount);\r\n        Transfer(this, to, amount);\r\n    }\r\n\r\n    // issue new coins\r\n    function issue(uint amount) onlyOwner public {\r\n        totalSupply = totalSupply.add(amount);\r\n        balances[this] = balances[this].add(amount);\r\n    }\r\n\r\n    function changeRate(uint256 new_rate) public onlyOwner {\r\n        require(new_rate > 0);\r\n        rate = new_rate;\r\n    }\r\n\r\n    function changeMinimalWei(uint256 new_wei) public onlyOwner {\r\n        minimalWei = new_wei;\r\n    }\r\n\r\n    // buy for ethereum\r\n    function buyTokens(address addr)\r\n        public payable {\r\n        activateDividends(msg.sender);\r\n        uint256 weiAmount = msg.value;\r\n        require(weiAmount >= minimalWei);\r\n        //uint256 tkns = weiAmount.mul(rate) / 1 ether * (uint256(10)**decimals);\r\n        uint256 tkns = weiAmount.mul(rate).div(1 ether).mul(uint256(10)**decimals);\r\n        require(tkns > 0);\r\n\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        transferBalance(this, addr, tkns);\r\n        TokenPurchase(this, addr, weiAmount, tkns);\r\n        owner.transfer(msg.value);\r\n    }\r\n\r\n    // destroy existing coins\r\n    // TOD: not destroy dividends tokens\r\n    function destroy(uint amount) onlyOwner public {\r\n          //require(amount > 0 && balanceEnough(amount));\r\n          require(amount > 0);\r\n          transferBalance(this, address(0x0), amount);\r\n          totalSupply -= amount;\r\n    }\r\n\r\n    function () payable public {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    // kill contract only if all wallets are empty\r\n    function kill() onlyOwner public {\r\n        require (totalSupply == 0);\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"investorMinimalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_address\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"removeInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_rate\",\"type\":\"uint256\"}],\"name\":\"changeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeTransferFeeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendDividendsEthers\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numinator\",\"type\":\"uint32\"},{\"name\":\"denuminator\",\"type\":\"uint32\"}],\"name\":\"setTransferFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_wei\",\"type\":\"uint256\"}],\"name\":\"changeMinimalWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"addInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeDenum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"string\"}],\"name\":\"Debug\",\"type\":\"event\"}]","ContractName":"PDT","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000003b9aca00","Library":"","SwarmSource":"bzzr://f4dfb71c3a9bba8ab48cf6cf2a20afc587d49b9f23b5f033324bb9ce7f4f84f5"}]}