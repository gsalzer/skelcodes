{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ncontract ERC20 {\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract MintableToken is ERC20, SafeMath, Owned{\r\n\tmapping(address => uint) public balances;\r\n\taddress[] mintingFactories;\r\n\tuint numFactories;\r\n\t\r\n\tfunction addMintingFactory(address _factory) onlyOwner{\r\n\t    mintingFactories.push(_factory);\r\n\t    numFactories += 1;\r\n\t}\r\n\t\r\n\tmodifier onlyFactory{\r\n\t    bool isFactory = false;\r\n\t    for (uint i = 0; i < numFactories; i++){\r\n\t        if (msg.sender == mintingFactories[i])\r\n\t        {\r\n\t            isFactory = true;\r\n\t        }\r\n\t    }\r\n\t    if (!isFactory) throw;\r\n\t    _;\r\n\t}\r\n\tfunction exchangeTransfer(address _to, uint _value);\r\n}\r\n\r\ncontract CollectibleFeeToken is MintableToken{\r\n\tuint8 public decimals;\r\n\tmapping(uint => uint) public roundFees;\r\n\tmapping(uint => uint) public recordedCoinSupplyForRound;\r\n\tmapping(uint => mapping (address => uint)) claimedFees;\r\n\tmapping(address => uint) lastClaimedRound;\r\n\tuint256 public reserves;\r\n\tuint public latestRound = 0;\r\n\tuint public initialRound = 1;\r\n\t\r\n\tmodifier onlyPayloadSize(uint size) {\r\n\t\tif(msg.data.length != size + 4) {\r\n\t\tthrow;\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\t\r\n\tfunction reduceReserves(uint value) onlyPayloadSize(1 * 32) onlyOwner{\r\n\t    reserves = safeSub(reserves, value);\r\n\t}\r\n\t\r\n\tfunction addReserves(uint value) onlyPayloadSize(1 * 32) onlyOwner{\r\n\t    reserves = safeAdd(reserves, value);\r\n\t}\r\n\t\r\n\tfunction depositFees(uint value) onlyPayloadSize(1 * 32) onlyOwner {\r\n\t\tlatestRound += 1;\r\n\t\trecordedCoinSupplyForRound[latestRound] = totalSupply;\r\n\t\troundFees[latestRound] = value;\r\n\t}\r\n\tfunction claimFees(address _owner) onlyPayloadSize(1 * 32) onlyOwner returns (uint totalFees) {\r\n\t\ttotalFees = 0;\r\n\t\tfor (uint i = lastClaimedRound[_owner] + 1; i <= latestRound; i++){\r\n\t\t\tuint feeForRound = balances[_owner] * feePerUnitOfCoin(i);\r\n\t\t\tif (feeForRound > claimedFees[i][_owner]){\r\n\t\t\t\tfeeForRound = safeSub(feeForRound,claimedFees[i][_owner]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfeeForRound = 0;\r\n\t\t\t}\r\n\t\t\tclaimedFees[i][_owner] = safeAdd(claimedFees[i][_owner], feeForRound);\r\n\t\t\ttotalFees = safeAdd(totalFees, feeForRound);\r\n\t\t}\r\n\t\tlastClaimedRound[_owner] = latestRound;\r\n\t\treturn totalFees;\r\n\t}\r\n\r\n\tfunction claimFeesForRound(address _owner, uint round) onlyPayloadSize(2 * 32) onlyOwner returns (uint feeForRound) {\r\n\t\tfeeForRound = balances[_owner] * feePerUnitOfCoin(round);\r\n\t\tif (feeForRound > claimedFees[round][_owner]){\r\n\t\t\tfeeForRound = safeSub(feeForRound,claimedFees[round][_owner]);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfeeForRound = 0;\r\n\t\t}\r\n\t\tclaimedFees[round][_owner] = safeAdd(claimedFees[round][_owner], feeForRound);\r\n\t\treturn feeForRound;\r\n\t}\r\n\r\n\tfunction _resetTransferredCoinFees(address _owner, address _receipient, uint numCoins) internal{\r\n\t\tfor (uint i = lastClaimedRound[_owner] + 1; i <= latestRound; i++){\r\n\t\t\tuint feeForRound = balances[_owner] * feePerUnitOfCoin(i);\r\n\t\t\tif (feeForRound > claimedFees[i][_owner]) {\r\n\t\t\t\t//Add unclaimed fees to reserves\r\n\t\t\t\tuint unclaimedFees = min256(numCoins * feePerUnitOfCoin(i), safeSub(feeForRound, claimedFees[i][_owner]));\r\n\t\t\t\treserves = safeAdd(reserves, unclaimedFees);\r\n\t\t\t\tclaimedFees[i][_owner] = safeAdd(claimedFees[i][_owner], unclaimedFees);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (uint x = lastClaimedRound[_receipient] + 1; x <= latestRound; x++){\r\n\t\t\t//Empty fees for new receipient\r\n\t\t\tclaimedFees[x][_receipient] = safeAdd(claimedFees[x][_receipient], numCoins * feePerUnitOfCoin(x));\r\n\t\t}\r\n\t}\r\n\tfunction feePerUnitOfCoin(uint round) public constant returns (uint fee){\r\n\t\treturn safeDiv(roundFees[round], recordedCoinSupplyForRound[round]);\r\n\t}\r\n\t\r\n   function mintTokens(address _owner, uint amount) onlyFactory{\r\n       //Upon factory transfer, fees will be redistributed into reserves\r\n       lastClaimedRound[msg.sender] = latestRound;\r\n       totalSupply = safeAdd(totalSupply, amount);\r\n       balances[_owner] += amount;\r\n   }\r\n}\r\ncontract SphereTokenFactory is Owned{\r\n\tCollectibleFeeToken sphereToken;\r\n\taddress public exchangeAddress;\r\n\taddress public daoAddress;\r\n\tmodifier onlyExchange{\r\n\t    if (msg.sender != exchangeAddress && msg.sender != daoAddress){\r\n\t        throw;\r\n\t    }\r\n\t    _;\r\n\t}\r\n\tfunction SphereTokenFactory(){\r\n\t\tsphereToken = CollectibleFeeToken(0xe18e9ce082B1609ebFAE090c6e5Cbb65eDaC5855);\r\n\t}\r\n\tfunction mint(address target, uint amount) onlyExchange{\r\n\t\tsphereToken.mintTokens(address(this), amount);\r\n\t\tsphereToken.exchangeTransfer(target, amount);\r\n\t}\r\n    function setExchange(address exchange) onlyOwner{\r\n        exchangeAddress = exchange;\r\n    }\r\n    function setDAO(address dao) onlyOwner{\r\n        daoAddress = dao;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"daoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange\",\"type\":\"address\"}],\"name\":\"setExchange\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"setDAO\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"SphereTokenFactory","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://eb4ddfe64d99cb644af7ac72c125a585470323be24682f3f042b41d239a17763"}]}