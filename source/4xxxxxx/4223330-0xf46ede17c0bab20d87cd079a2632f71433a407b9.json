{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract PreICO {\r\n  function balanceOf(address _owner) constant returns (uint256);\r\n  function burnTokens(address _owner);\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value);\r\n  function approve(address spender, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint;\r\n\r\n  mapping(address => uint) balances;\r\n\r\n  /*\r\n   * Fix for the ERC20 short address attack  \r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n  \r\n}\r\n\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transferFrom(address _from, address _to, uint _value) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint _value) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract ATL is StandardToken {\r\n\r\n  string public name = \"ATLANT Token\";\r\n  string public symbol = \"ATL\";\r\n  uint public decimals = 18;\r\n  uint constant TOKEN_LIMIT = 150 * 1e6 * 1e18;\r\n\r\n  address public ico;\r\n\r\n  bool public tokensAreFrozen = true;\r\n\r\n  function ATL(address _ico) {\r\n    ico = _ico;\r\n  }\r\n\r\n  function mint(address _holder, uint _value) external {\r\n    require(msg.sender == ico);\r\n    require(_value != 0);\r\n    require(totalSupply + _value <= TOKEN_LIMIT);\r\n\r\n    balances[_holder] += _value;\r\n    totalSupply += _value;\r\n    Transfer(0x0, _holder, _value);\r\n  }\r\n\r\n  function unfreeze() external {\r\n    require(msg.sender == ico);\r\n    tokensAreFrozen = false;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) public {\r\n    require(!tokensAreFrozen);\r\n    super.transfer(_to, _value);\r\n  }\r\n\r\n\r\n  function transferFrom(address _from, address _to, uint _value) public {\r\n    require(!tokensAreFrozen);\r\n    super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n\r\n  function approve(address _spender, uint _value) public {\r\n    require(!tokensAreFrozen);\r\n    super.approve(_spender, _value);\r\n  }\r\n}\r\n\r\ncontract ICO {\r\n\r\n  uint public constant MIN_TOKEN_PRICE = 425; // min atl per ETH\r\n  uint public constant TOKENS_FOR_SALE = 103548812 * 1e18;\r\n  uint public constant ATL_PER_ATP = 2; // Migration rate\r\n\r\n  event Buy(address holder, uint atlValue);\r\n  event ForeignBuy(address holder, uint atlValue, string txHash);\r\n  event Migrate(address holder, uint atlValue);\r\n  event RunIco();\r\n  event PauseIco();\r\n  event FinishIco(address teamFund, address bountyFund);\r\n\r\n  PreICO preICO;\r\n  ATL public atl;\r\n\r\n  address public team;\r\n  address public tradeRobot;\r\n  modifier teamOnly { require(msg.sender == team); _; }\r\n  modifier robotOnly { require(msg.sender == tradeRobot); _; }\r\n\r\n  uint public tokensSold = 0;\r\n\r\n  enum IcoState { Created, Running, Paused, Finished }\r\n  IcoState icoState = IcoState.Created;\r\n\r\n\r\n  function ICO(address _team, address _preICO, address _tradeRobot) {\r\n    atl = new ATL(this);\r\n    preICO = PreICO(_preICO);\r\n    team = _team;\r\n    tradeRobot = _tradeRobot;\r\n  }\r\n\r\n\r\n  function() external payable {\r\n    buyFor(msg.sender);\r\n  }\r\n\r\n\r\n  function buyFor(address _investor) public payable {\r\n    require(icoState == IcoState.Running);\r\n    require(msg.value > 0);\r\n    uint _total = buy(_investor, msg.value * MIN_TOKEN_PRICE);\r\n    Buy(_investor, _total);\r\n  }\r\n\r\n\r\n  function getBonus(uint _value, uint _sold)\r\n    public constant returns (uint)\r\n  {\r\n    uint[8] memory _bonusPricePattern = [ 505, 495, 485, 475, 465, 455, 445, uint(435) ];\r\n    uint _step = TOKENS_FOR_SALE / 10;\r\n    uint _bonus = 0;\r\n\r\n    for (uint8 i = 0; _value > 0 && i < _bonusPricePattern.length; ++i) {\r\n      uint _min = _step * i;\r\n      uint _max = _step * (i+1);\r\n\r\n      if (_sold >= _min && _sold < _max) {\r\n        uint bonusedPart = min(_value, _max - _sold);\r\n        _bonus += bonusedPart * _bonusPricePattern[i] / MIN_TOKEN_PRICE - bonusedPart;\r\n        _value -= bonusedPart;\r\n        _sold += bonusedPart;\r\n      }\r\n    }\r\n\r\n    return _bonus;\r\n  }\r\n\r\n  function foreignBuy(address _investor, uint _atlValue, string _txHash)\r\n    external robotOnly\r\n  {\r\n    require(icoState == IcoState.Running);\r\n    require(_atlValue > 0);\r\n    uint _total = buy(_investor, _atlValue);\r\n    ForeignBuy(_investor, _total, _txHash);\r\n  }\r\n\r\n\r\n  function setRobot(address _robot) external teamOnly {\r\n    tradeRobot = _robot;\r\n  }\r\n\r\n\r\n  function migrateSome(address[] _investors) external robotOnly {\r\n    for (uint i = 0; i < _investors.length; i++)\r\n      doMigration(_investors[i]);\r\n  }\r\n\r\n\r\n  function startIco() external teamOnly {\r\n    require(icoState == IcoState.Created || icoState == IcoState.Paused);\r\n    icoState = IcoState.Running;\r\n    RunIco();\r\n  }\r\n\r\n\r\n  function pauseIco() external teamOnly {\r\n    require(icoState == IcoState.Running);\r\n    icoState = IcoState.Paused;\r\n    PauseIco();\r\n  }\r\n\r\n\r\n  function finishIco(\r\n    address _teamFund,\r\n    address _bountyFund\r\n  )\r\n    external teamOnly\r\n  {\r\n    require(icoState == IcoState.Running || icoState == IcoState.Paused);\r\n\r\n    atl.mint(_teamFund, 22500000 * 1e18);\r\n    atl.mint(_bountyFund, 18750000 * 1e18);\r\n    atl.unfreeze();\r\n\r\n    icoState = IcoState.Finished;\r\n    FinishIco(_teamFund, _bountyFund);\r\n  }\r\n\r\n\r\n  function withdrawEther(uint _value) external teamOnly {\r\n    team.transfer(_value);\r\n  }\r\n\r\n\r\n  function withdrawToken(address _tokenContract, uint _val) external teamOnly\r\n  {\r\n    ERC20 _tok = ERC20(_tokenContract);\r\n    _tok.transfer(team, _val);\r\n  }\r\n\r\n\r\n  function min(uint a, uint b) internal constant returns (uint) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n\r\n  function buy(address _investor, uint _atlValue) internal returns (uint) {\r\n    uint _bonus = getBonus(_atlValue, tokensSold);\r\n    uint _total = _atlValue + _bonus;\r\n\r\n    require(tokensSold + _total <= TOKENS_FOR_SALE);\r\n\r\n    atl.mint(_investor, _total);\r\n    tokensSold += _total;\r\n    return _total;\r\n  }\r\n\r\n\r\n  function doMigration(address _investor) internal {\r\n    uint _atpBalance = preICO.balanceOf(_investor);\r\n    require(_atpBalance > 0);\r\n\r\n    preICO.burnTokens(_investor);\r\n\r\n    uint _atlValue = _atpBalance * ATL_PER_ATP;\r\n    atl.mint(_investor, _atlValue);\r\n\r\n    Migrate(_investor, _atlValue);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_teamFund\",\"type\":\"address\"},{\"name\":\"_bountyFund\",\"type\":\"address\"}],\"name\":\"finishIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_TOKEN_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_atlValue\",\"type\":\"uint256\"},{\"name\":\"_txHash\",\"type\":\"string\"}],\"name\":\"foreignBuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"migrateSome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_robot\",\"type\":\"address\"}],\"name\":\"setRobot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"atl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"buyFor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeRobot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_sold\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_FOR_SALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ATL_PER_ATP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_team\",\"type\":\"address\"},{\"name\":\"_preICO\",\"type\":\"address\"},{\"name\":\"_tradeRobot\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"atlValue\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"atlValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txHash\",\"type\":\"string\"}],\"name\":\"ForeignBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"atlValue\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RunIco\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseIco\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"teamFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bountyFund\",\"type\":\"address\"}],\"name\":\"FinishIco\",\"type\":\"event\"}]","ContractName":"ICO","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000082127de2f739f4b02630cd93929a71a093c9d72d0000000000000000000000006d85320c086aee2ecd2693855fb2164c494fd25100000000000000000000000080e4568c84678367c30efa125bdd9ab6d65f2216","Library":"","SwarmSource":"bzzr://f320e6eedbf2c2e62f7e11260f0241d7ecb85a567e6cb5fb90dabf7052699ad1"}]}