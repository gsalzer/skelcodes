{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title METTA platform token & preICO crowdsale implementasion\r\n * @author Maxim Akimov - <devstylesoftware@gmail.com>\r\n * @author Dmitrii Bykov - <bykoffdn@gmail.com>\r\n */\r\n\r\npragma solidity ^0.4.15;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n\tfunction mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n\t\tuint256 c = a * b;\r\n\t\tassert(a == 0 || c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n  \r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n\tuint256 public totalSupply;\r\n\tfunction balanceOf(address who) constant returns (uint256);\r\n\tfunction transfer(address to, uint256 value) returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) constant returns (uint256);\r\n\tfunction transferFrom(address from, address to, uint256 value) returns (bool);\r\n\tfunction approve(address spender, uint256 value) returns (bool);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    \r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) balances;\r\n\r\n\t/**\r\n\t* @dev transfer token for a specified address\r\n\t* @param _to The address to transfer to.\r\n\t* @param _value The amount to be transferred.\r\n\t*/\r\n\tfunction transfer(address _to, uint256 _value) returns (bool) {\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tTransfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param _owner The address to query the the balance of. \r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t*/\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n\tmapping (address => mapping (address => uint256)) allowed;\r\n\r\n\t/**\r\n\t* @dev Transfer tokens from one address to another\r\n\t* @param _from address The address which you want to send tokens from\r\n\t* @param _to address The address which you want to transfer to\r\n\t* @param _value uint256 the amout of tokens to be transfered\r\n\t*/\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n\t  \r\n\t\tvar _allowance = allowed[_from][msg.sender];\r\n\r\n\t\t// Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n\t\t// require (_value <= _allowance);\r\n\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\t* @param _spender The address which will spend the funds.\r\n\t* @param _value The amount of tokens to be spent.\r\n\t*/\r\n\tfunction approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n\t\t// To change the approve amount you first have to reduce the addresses`\r\n\t\t//  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n\t\t//  already 0 to mitigate the race condition described here:\r\n\t\t//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t* @param _owner address The address which owns the funds.\r\n\t* @param _spender address The address which will spend the funds.\r\n\t* @return A uint256 specifing the amount of tokens still available for the spender.\r\n\t*/\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    \r\n\taddress public owner;\r\n\taddress public ownerCandidat;\r\n\r\n\t/**\r\n\t* @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t* account.\r\n\t*/\r\n\tfunction Ownable() {\r\n\t\towner = msg.sender;\r\n\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if called by any account other than the owner.\r\n\t*/\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t* @param newOwner The address to transfer ownership to.\r\n\t*/\r\n\tfunction transferOwnership(address newOwner) onlyOwner {\r\n\t\trequire(newOwner != address(0));      \r\n\t\townerCandidat = newOwner;\r\n\t}\r\n\t/**\r\n\t* @dev Allows safe change current owner to a newOwner.\r\n\t*/\r\n\tfunction confirmOwnership() onlyOwner {\r\n\t\trequire(msg.sender == ownerCandidat);      \r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is StandardToken, Ownable {\r\n \r\n\t/**\r\n\t* @dev Burns a specific amount of tokens.\r\n\t* @param _value The amount of token to be burned.\r\n\t*/\r\n\tfunction burn(uint256 _value) public onlyOwner {\r\n\t\trequire(_value > 0);\r\n\r\n\t\taddress burner = msg.sender;    \r\n\t\t\t\t\t\t\t\t\t\t\r\n\r\n\t\tbalances[burner] = balances[burner].sub(_value);\r\n\t\ttotalSupply = totalSupply.sub(_value);\r\n\t\tBurn(burner, _value);\r\n\t}\r\n\r\n\tevent Burn(address indexed burner, uint indexed value);\r\n \r\n}\r\n \r\ncontract MettaCoin is BurnableToken {\r\n \r\n\tstring public constant name = \"TOKEN METTACOIN\";   \r\n\tstring public constant symbol = \"METTACOIN\";   \r\n\tuint32 public constant decimals = 18;    \r\n\tuint256 public constant initialSupply = 300000000 * 1 ether;\r\n\r\n\tfunction MettaCoin() {\r\n\t\ttotalSupply = initialSupply;\r\n\t\tbalances[msg.sender] = initialSupply;\r\n\t}    \r\n  \r\n}\r\n\r\n\r\ncontract Crowdsale is Ownable {\r\n    \r\n    using SafeMath for uint;\r\n\t//\r\n    MettaCoin public token = new MettaCoin();\r\n\t//\r\n    uint public start;    \r\n    //\r\n\tuint public period;\r\n\t//\r\n    uint public rate;\r\n\t//  \r\n    uint public softcap;\r\n    //\r\n    uint public availableTokensforPreICO;\r\n    //\r\n    uint public countOfSaleTokens;\r\n    //    \r\n    uint public currentPreICObalance;\r\n    //\r\n    uint public refererPercent;\r\n    //\r\n\tmapping(address => uint) public balances;\r\n    \r\n    // preICO manager data//////////////\r\n     address public managerETHaddress;\r\n     address public managerETHcandidatAddress;\r\n     uint public managerETHbonus;\r\n    \r\n    /////////////////////////////////\r\n   \r\n    function Crowdsale() {\r\n     \r\n\t\t// 1 METTACOIN = 0.00022 ETH\r\n\t\trate = 220000000000000; \r\n\t\t//Mon, 10 Nov 2017 00:00:00 GMT\r\n\t\tstart = 1510272000;\r\n\t\t// preICO period is 20 of november - 19 of december\r\n\t\tperiod = 1; // 29  \r\n\t\t// minimum attracted ETH during preICO - 409\r\n\t\tsoftcap = 440000000000000;//409 * 1 ether; //0.00044 for test\r\n\t\t// maximum number mettacoins for preICO\r\n\t\tavailableTokensforPreICO = 8895539 * 1 ether;\r\n\t\t// current ETH balance of preICO\r\n\t\tcurrentPreICObalance = 0; \r\n\t\t// how much mettacoins are sold\r\n\t\tcountOfSaleTokens = 0; \r\n\t\t//percent for referer bonus program\r\n\t\trefererPercent = 15;\r\n\t\t\r\n\t\t//data of manager of company\r\n\t\tmanagerETHaddress = 0x0;   \r\n\t\tmanagerETHbonus = 220000000000000; //35 ETH ~ 1,4 BTC // 35 * 1 ether;\r\n\r\n    }\r\n    /**\r\n\t * @dev Initially safe sets preICO manager address\r\n\t */\r\n    function setPreIcoManager(address _addr) public onlyOwner {   \r\n        require(managerETHaddress == 0x0) ;//ony once\r\n\t\t\tmanagerETHcandidatAddress = _addr;\r\n        \r\n    }\r\n\t/**\r\n\t * @dev Allows safe confirm of manager address\r\n\t */\r\n    function confirmManager() public {\r\n        require(msg.sender == managerETHcandidatAddress); \r\n\t\t\tmanagerETHaddress = managerETHcandidatAddress;\r\n    }\r\n    \r\n    \t/**\r\n\t * @dev Allows safe changing of manager address\r\n\t */\r\n    function changeManager(address _addr) public {\r\n        require(msg.sender == managerETHaddress); \r\n\t\t\tmanagerETHcandidatAddress = _addr;\r\n    }\r\n\t/**\r\n\t * @dev Indicates that preICO starts and not finishes\r\n\t */\r\n    modifier saleIsOn() {\r\n\t\trequire(now > start && now < start + period * 1 days);\r\n\t\t_;\r\n    }\r\n\t\r\n\t/**\r\n\t * @dev Indicates that we have available tokens for sale\r\n\t */\r\n    modifier issetTokensForSale() {\r\n\t\trequire(countOfSaleTokens < availableTokensforPreICO); \r\n\t\t_;\r\n    }\r\n    \r\n    //test\r\n    function getEndDate1() returns (uint){\r\n        return start + period * 1 days;\r\n    }\r\n      function getENow() returns (uint){\r\n        return now;\r\n    }\r\n    ///\r\n    \r\n  \r\n\t/**\r\n\t * @dev Tokens ans ownership will be transfered from preICO contract to ICO contract after preICO period.\r\n\t */\r\n    function TransferTokenToIcoContract(address ICOcontract) public onlyOwner {\r\n\t\trequire(now > start + period * 1 days);\r\n\t\ttoken.transfer(ICOcontract, token.balanceOf(this));\r\n\t\ttoken.transferOwnership(ICOcontract);\r\n    }\r\n\t/**\r\n\t * @dev Investments will be refunded if preICO not hits the softcap.\r\n\t */\r\n    function refund() public {\r\n\t\trequire(currentPreICObalance < softcap && now > start + period * 1 days);\r\n\t\tmsg.sender.transfer(balances[msg.sender]);\r\n\t\tbalances[msg.sender] = 0;\r\n    }\r\n\t/**\r\n\t * @dev Manager can get his/shes bonus after preICO reaches it's softcap\r\n\t */\r\n    function withdrawManagerBonus() public {    \r\n        if(currentPreICObalance > softcap && managerETHbonus > 0){\r\n            managerETHaddress.transfer(managerETHbonus);\r\n            managerETHbonus = 0;\r\n        }\r\n    }\r\n\t/**\r\n\t * @dev If ICO reached owner can withdrow ETH for ICO comping managment\r\n\t */\r\n    function withdrawPreIcoFounds() public onlyOwner {  \r\n\t\tif(currentPreICObalance > softcap) {\r\n\t\t\t// send all current ETH from contract to owner\r\n\t\t\tuint availableToTranser = this.balance-managerETHbonus;\r\n\t\t\towner.transfer(availableToTranser);\r\n\t\t}\r\n    }\r\n\t/**\r\n\t * @dev convert bytes to address\r\n\t */\r\n    function bytesToAddress(bytes source) internal returns(address) {\r\n        uint result;\r\n        uint mul = 1;\r\n        for(uint i = 20; i > 0; i--) {\r\n          result += uint8(source[i-1])*mul;\r\n          mul = mul*256;\r\n        }\r\n        return address(result);\r\n    }\r\n   function buyTokens() issetTokensForSale saleIsOn payable {   \r\n        uint tokens = msg.value.mul(1 ether).div(rate);\r\n        if(tokens > 0)   {\r\n             address referer = 0x0;\r\n            //-------------BONUSES-------------//\r\n             uint bonusTokens = 0;\r\n            if(now < start.add(7* 1 days)) {// 1st week\r\n    \t\t\tbonusTokens = tokens.mul(45).div(100); //+45%\r\n            } else if(now >= start.add(7 * 1 days) && now < start.add(14 * 1 days)) { // 2nd week\r\n    \t\t\tbonusTokens = tokens.mul(40).div(100); //+40%\r\n            } else if(now >= start.add(14* 1 days) && now < start.add(21 * 1 days)) { // 3th week\r\n    \t\t\tbonusTokens = tokens.mul(35).div(100); //+35%\r\n            } else if(now >= start.add(21* 1 days) && now < start.add(28 * 1 days)) { // 4th week\r\n    \t\t\tbonusTokens = tokens.mul(30).div(100); //+30% \r\n            } \r\n            tokens = tokens.add(bonusTokens);\r\n            //---------END-BONUSES-------------//\r\n    \t\t\r\n    \t\t//---------referal program--------- //abailable after 3th week onli\r\n    \t//\tif(now >= start.add(14* 1 days) && now < start.add(28 * 1 days)) {\r\n                if(msg.data.length == 20) {\r\n                  referer = bytesToAddress(bytes(msg.data));\r\n                  require(referer != msg.sender);\r\n                  uint refererTokens = tokens.mul(refererPercent).div(100);\r\n                }\r\n    \t//\t}\r\n    \t\t//---------end referal program---------//\r\n    \t\t\r\n    \t\tif(availableTokensforPreICO > countOfSaleTokens.add(tokens)) {  \r\n    \t\t\ttoken.transfer(msg.sender, tokens);\r\n    \t\t\tcurrentPreICObalance = currentPreICObalance.add(msg.value); \r\n    \t\t\tcountOfSaleTokens = countOfSaleTokens.add(tokens); \r\n    \t\t\tbalances[msg.sender] = balances[msg.sender].add(msg.value);\r\n    \t\t\tif(availableTokensforPreICO > countOfSaleTokens.add(tokens).add(refererTokens)){\r\n    \t\t\t     // send token to referrer\r\n    \t\t\t     if(referer !=0x0 && refererTokens >0){\r\n    \t\t\t        token.transfer(referer, refererTokens);\r\n    \t\t\t        \tcountOfSaleTokens = countOfSaleTokens.add(refererTokens); \r\n    \t\t\t     }\r\n    \t\t\t}\r\n    \t\t} else {\r\n    \t\t\t// there are not sufficient number of tokens - return of ETH\r\n    \t\t\tmsg.sender.transfer(msg.value);\r\n    \t\t}\r\n        }else{\r\n            // retun to buyer if tokens == 0\r\n           msg.sender.transfer(msg.value);\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n\t\tbuyTokens();  \r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"managerETHbonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableTokensforPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ICOcontract\",\"type\":\"address\"}],\"name\":\"TransferTokenToIcoContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawManagerBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCandidat\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerETHaddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerETHcandidatAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refererPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPreIcoManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countOfSaleTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getEndDate1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getENow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPreIcoFounds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPreICObalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d77ecc433f4e7240bcddf2bc32cdbe20ced7f4fc2e52fec8a12011c73dc8351f"}]}