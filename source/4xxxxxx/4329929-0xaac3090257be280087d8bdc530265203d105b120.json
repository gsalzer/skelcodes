{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n///  later changed\r\ncontract Owned {\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Protocol {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint supply);\r\n    is replaced with:\r\n    uint public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ncontract StandardToken is ERC20Protocol {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n    * @dev Fix for the ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n}\r\n\r\n/// @title Wanchain Token Contract\r\n/// For more information about this token sale, please visit https://wanchain.org\r\n/// @author Cathy - <cathy@wanchain.org>\r\ncontract WanToken is StandardToken {\r\n    using SafeMath for uint;\r\n\r\n    /// Constant token specific fields\r\n    string public constant name = \"WanCoin\";\r\n    string public constant symbol = \"WAN\";\r\n    uint public constant decimals = 18;\r\n\r\n    /// Wanchain total tokens supply\r\n    uint public constant MAX_TOTAL_TOKEN_AMOUNT = 210000000 ether;\r\n\r\n    /// Fields that are only changed in constructor\r\n    /// Wanchain contribution contract\r\n    address public minter; \r\n    /// ICO start time\r\n    uint public startTime;\r\n    /// ICO end time\r\n    uint public endTime;\r\n\r\n    /// Fields that can be changed by functions\r\n    mapping (address => uint) public lockedBalances;\r\n    /*\r\n     * MODIFIERS\r\n     */\r\n\r\n    modifier onlyMinter {\r\n        assert(msg.sender == minter);\r\n        _;\r\n    }\r\n\r\n    modifier isLaterThan (uint x){\r\n        assert(now > x);\r\n        _;\r\n    }\r\n\r\n    modifier maxWanTokenAmountNotReached (uint amount){\r\n        assert(totalSupply.add(amount) <= MAX_TOTAL_TOKEN_AMOUNT);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * CONSTRUCTOR \r\n     * \r\n     * @dev Initialize the Wanchain Token\r\n     * @param _minter The Wanchain Contribution Contract     \r\n     * @param _startTime ICO start time\r\n     * @param _endTime ICO End Time\r\n     */\r\n    function WanToken(address _minter, uint _startTime, uint _endTime){\r\n        minter = _minter;\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n    /**\r\n     * EXTERNAL FUNCTION \r\n     * \r\n     * @dev Contribution contract instance mint token\r\n     * @param receipent The destination account owned mint tokens    \r\n     * @param amount The amount of mint token\r\n     * be sent to this address.\r\n     */    \r\n    function mintToken(address receipent, uint amount)\r\n        external\r\n        onlyMinter\r\n        maxWanTokenAmountNotReached(amount)\r\n        returns (bool)\r\n    {\r\n        require(now <= endTime);\r\n        lockedBalances[receipent] = lockedBalances[receipent].add(amount);\r\n        totalSupply = totalSupply.add(amount);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * PUBLIC FUNCTIONS\r\n     */\r\n\r\n    /// @dev Locking period has passed - Locked tokens have turned into tradeable\r\n    ///      All tokens owned by receipent will be tradeable\r\n    function claimTokens(address receipent)\r\n        public\r\n        onlyMinter\r\n    {\r\n        balances[receipent] = balances[receipent].add(lockedBalances[receipent]);\r\n        lockedBalances[receipent] = 0;\r\n    }\r\n\r\n    /*\r\n     * CONSTANT METHODS\r\n     */\r\n    function lockedBalanceOf(address _owner) constant returns (uint balance) {\r\n        return lockedBalances[_owner];\r\n    }\r\n}\r\n\r\n/// @title Wanchain Contribution Contract\r\n/// ICO Rules according: https://www.wanchain.org/crowdsale\r\n/// For more information about this token sale, please visit https://wanchain.org\r\n/// @author Zane Liang - <zaneliang@wanchain.org>\r\ncontract WanchainContribution is Owned {\r\n    using SafeMath for uint;\r\n\r\n    /// Constant fields\r\n    /// Wanchain total tokens supply\r\n    uint public constant WAN_TOTAL_SUPPLY = 210000000 ether;\r\n    uint public constant EARLY_CONTRIBUTION_DURATION = 24 hours;\r\n    uint public constant MAX_CONTRIBUTION_DURATION = 3 weeks;\r\n\r\n    /// Exchange rates for first phase\r\n    uint public constant PRICE_RATE_FIRST = 880;\r\n    /// Exchange rates for second phase\r\n    uint public constant PRICE_RATE_SECOND = 790;\r\n    /// Exchange rates for last phase\r\n    uint public constant PRICE_RATE_LAST = 750;\r\n\r\n    /// ----------------------------------------------------------------------------------------------------\r\n    /// |                                                  |                    |                 |        |\r\n    /// |        PUBLIC SALE (PRESALE + OPEN SALE)         |      DEV TEAM      |    FOUNDATION   |  MINER |\r\n    /// |                       51%                        |         20%        |       19%       |   10%  |    \r\n    /// ----------------------------------------------------------------------------------------------------\r\n      /// OPEN_SALE_STAKE + PRESALE_STAKE = 51; 51% sale for public\r\n    uint public constant OPEN_SALE_STAKE = 510;  // 51% for open sale\r\n\r\n    // Reserved stakes\r\n    uint public constant DEV_TEAM_STAKE = 200;   // 20%\r\n    uint public constant FOUNDATION_STAKE = 190; // 19%\r\n    uint public constant MINERS_STAKE = 100;     // 10%\r\n\r\n    uint public constant DIVISOR_STAKE = 1000;\r\n\r\n    uint public constant PRESALE_RESERVERED_AMOUNT = 41506655 ether; //presale prize amount(40000*880)\r\n  \r\n    /// Holder address for presale and reserved tokens\r\n    /// TODO: change addressed before deployed to main net\r\n\r\n    // Addresses of Patrons\r\n    address public constant DEV_TEAM_HOLDER = 0x0001cdC69b1eb8bCCE29311C01092Bdcc92f8f8F;\r\n    address public constant FOUNDATION_HOLDER = 0x00dB4023b32008C45E62Add57De256a9399752D4;\r\n    address public constant MINERS_HOLDER = 0x00f870D11eA43AA1c4C715c61dC045E32d232787;\r\n    address public constant PRESALE_HOLDER = 0x00577c25A81fA2401C5246F4a7D5ebaFfA4b00Aa;\r\n  \r\n    uint public MAX_OPEN_SOLD = WAN_TOTAL_SUPPLY * OPEN_SALE_STAKE / DIVISOR_STAKE - PRESALE_RESERVERED_AMOUNT;\r\n\r\n    /// Fields that are only changed in constructor    \r\n    /// All deposited ETH will be instantly forwarded to this address.\r\n    address public wanport;\r\n    /// Early Adopters reserved start time\r\n    uint public earlyReserveBeginTime;\r\n    /// Contribution start time\r\n    uint public startTime;\r\n    /// Contribution end time\r\n    uint public endTime;\r\n\r\n    /// Fields that can be changed by functions\r\n    /// Accumulator for open sold tokens\r\n    uint public openSoldTokens;\r\n    /// Due to an emergency, set this to true to halt the contribution\r\n    bool public halted; \r\n    /// ERC20 compilant wanchain token contact instance\r\n    WanToken public wanToken; \r\n\r\n    /// Quota for early adopters sale, Quota\r\n    mapping (address => uint256) public earlyUserQuotas;\r\n    /// tags show address can join in open sale\r\n    mapping (address => uint256) public fullWhiteList;\r\n\r\n    uint256 public normalBuyLimit = 65 ether;\r\n\r\n    /*\r\n     * EVENTS\r\n     */\r\n\r\n    event NewSale(address indexed destAddress, uint ethCost, uint gotTokens);\r\n    //event PartnerAddressQuota(address indexed partnerAddress, uint quota);\r\n\r\n    /*\r\n     * MODIFIERS\r\n     */\r\n\r\n    modifier onlyWallet {\r\n        require(msg.sender == wanport);\r\n        _;\r\n    }\r\n\r\n    modifier notHalted() {\r\n        require(!halted);\r\n        _;\r\n    }\r\n\r\n    modifier initialized() {\r\n        require(address(wanport) != 0x0);\r\n        _;\r\n    }    \r\n\r\n    modifier notEarlierThan(uint x) {\r\n        require(now >= x);\r\n        _;\r\n    }\r\n\r\n    modifier earlierThan(uint x) {\r\n        require(now < x);\r\n        _;\r\n    }\r\n\r\n    modifier ceilingNotReached() {\r\n        require(openSoldTokens < MAX_OPEN_SOLD);\r\n        _;\r\n    }  \r\n\r\n    modifier isSaleEnded() {\r\n        require(now > endTime || openSoldTokens >= MAX_OPEN_SOLD);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * CONSTRUCTOR \r\n     * \r\n     * @dev Initialize the Wanchain contribution contract\r\n     * @param _wanport The escrow account address, all ethers will be sent to this address.\r\n     * @param _bootTime ICO boot time\r\n     */\r\n    function WanchainContribution(address _wanport, uint _bootTime){\r\n      require(_wanport != 0x0);\r\n\r\n        halted = false;\r\n      wanport = _wanport;\r\n        earlyReserveBeginTime = _bootTime;\r\n      startTime = earlyReserveBeginTime + EARLY_CONTRIBUTION_DURATION;\r\n      endTime = startTime + MAX_CONTRIBUTION_DURATION;\r\n        openSoldTokens = 0;\r\n        /// Create wanchain token contract instance\r\n      wanToken = new WanToken(this,startTime, endTime);\r\n\r\n        /// Reserve tokens according wanchain ICO rules\r\n      uint stakeMultiplier = WAN_TOTAL_SUPPLY / DIVISOR_STAKE;\r\n    \r\n        wanToken.mintToken(DEV_TEAM_HOLDER, DEV_TEAM_STAKE * stakeMultiplier);\r\n        wanToken.mintToken(FOUNDATION_HOLDER, FOUNDATION_STAKE * stakeMultiplier);\r\n        wanToken.mintToken(MINERS_HOLDER, MINERS_STAKE * stakeMultiplier);\r\n    \r\n        wanToken.mintToken(PRESALE_HOLDER, PRESALE_RESERVERED_AMOUNT);    \r\n    \r\n    }\r\n\r\n    /**\r\n     * Fallback function \r\n     * \r\n     * @dev If anybody sends Ether directly to this  contract, consider he is getting wan token\r\n     */\r\n    function () public payable {\r\n      buyWanCoin(msg.sender);\r\n    }\r\n\r\n    /*\r\n     * PUBLIC FUNCTIONS\r\n     */\r\n\r\n    /// @dev Exchange msg.value ether to WAN for account recepient\r\n    /// @param receipient WAN tokens receiver\r\n    function buyWanCoin(address receipient) \r\n        public \r\n        payable \r\n        notHalted \r\n        initialized \r\n        ceilingNotReached \r\n        notEarlierThan(earlyReserveBeginTime)\r\n        earlierThan(endTime)\r\n        returns (bool) \r\n    {\r\n        require(receipient != 0x0);\r\n        require(msg.value >= 0.1 ether);\r\n\r\n        // Do not allow contracts to game the system\r\n        require(!isContract(msg.sender));        \r\n\r\n        if( now < startTime && now >= earlyReserveBeginTime)\r\n            buyEarlyAdopters(receipient);\r\n        else {\r\n            require( tx.gasprice <= 50000000000 wei );\r\n            require(msg.value <= normalBuyLimit);\r\n            buyNormal(receipient);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function setNormalBuyLimit(uint256 limit)\r\n        public\r\n        initialized\r\n        onlyOwner\r\n        earlierThan(endTime)\r\n    {\r\n        normalBuyLimit = limit;\r\n    }\r\n\r\n\r\n    /// @dev batch set quota for early user quota\r\n    function setEarlyWhitelistQuotas(address[] users, uint earlyCap, uint openTag)\r\n        public\r\n        onlyOwner\r\n        earlierThan(earlyReserveBeginTime)\r\n    {\r\n        for( uint i = 0; i < users.length; i++) {\r\n            earlyUserQuotas[users[i]] = earlyCap;\r\n            fullWhiteList[users[i]] = openTag;\r\n        }\r\n    }\r\n\r\n    /// @dev batch set quota for early user quota\r\n    function setLaterWhiteList(address[] users, uint openTag)\r\n        public\r\n        onlyOwner\r\n        earlierThan(endTime)\r\n    {\r\n        require(saleNotEnd());\r\n        for( uint i = 0; i < users.length; i++) {\r\n            fullWhiteList[users[i]] = openTag;\r\n        }\r\n    }\r\n\r\n    /// @dev Emergency situation that requires contribution period to stop.\r\n    /// Contributing not possible anymore.\r\n    function halt() public onlyWallet{\r\n        halted = true;\r\n    }\r\n\r\n    /// @dev Emergency situation resolved.\r\n    /// Contributing becomes possible again withing the outlined restrictions.\r\n    function unHalt() public onlyWallet{\r\n        halted = false;\r\n    }\r\n\r\n    /// @dev Emergency situation\r\n    function changeWalletAddress(address newAddress) onlyWallet { \r\n        wanport = newAddress; \r\n    }\r\n\r\n    /// @return true if sale not ended, false otherwise.\r\n    function saleNotEnd() constant returns (bool) {\r\n        return now < endTime && openSoldTokens < MAX_OPEN_SOLD;\r\n    }\r\n\r\n    /// CONSTANT METHODS\r\n    /// @dev Get current exchange rate\r\n    function priceRate() public constant returns (uint) {\r\n        // Three price tiers\r\n        if (earlyReserveBeginTime <= now && now < startTime + 1 weeks)\r\n            return PRICE_RATE_FIRST;\r\n        if (startTime + 1 weeks <= now && now < startTime + 2 weeks)\r\n            return PRICE_RATE_SECOND;\r\n        if (startTime + 2 weeks <= now && now < endTime)\r\n            return PRICE_RATE_LAST;\r\n        // Should not be called before or after contribution period\r\n        assert(false);\r\n    }\r\n\r\n    function claimTokens(address receipent)\r\n        public\r\n        isSaleEnded\r\n    {\r\n        wanToken.claimTokens(receipent);\r\n    }\r\n\r\n    /*\r\n     * INTERNAL FUNCTIONS\r\n     */\r\n\r\n    /// @dev Buy wanchain tokens for early adopters\r\n    function buyEarlyAdopters(address receipient) internal {\r\n      uint quotaAvailable = earlyUserQuotas[receipient];\r\n      require(quotaAvailable > 0);\r\n\r\n        uint toFund = quotaAvailable.min256(msg.value);\r\n        uint tokenAvailable4Adopter = toFund.mul(PRICE_RATE_FIRST);\r\n\r\n      earlyUserQuotas[receipient] = earlyUserQuotas[receipient].sub(toFund);\r\n      buyCommon(receipient, toFund, tokenAvailable4Adopter);\r\n    }\r\n\r\n    /// @dev Buy wanchain token normally\r\n    function buyNormal(address receipient) internal {\r\n        uint inWhiteListTag = fullWhiteList[receipient];\r\n        require(inWhiteListTag > 0);\r\n\r\n        // protect partner quota in stage one\r\n        uint tokenAvailable = MAX_OPEN_SOLD.sub(openSoldTokens);\r\n        require(tokenAvailable > 0);\r\n\r\n      uint toFund;\r\n      uint toCollect;\r\n      (toFund, toCollect) = costAndBuyTokens(tokenAvailable);\r\n        buyCommon(receipient, toFund, toCollect);\r\n    }\r\n\r\n    /// @dev Utility function for bug wanchain token\r\n    function buyCommon(address receipient, uint toFund, uint wanTokenCollect) internal {\r\n        require(msg.value >= toFund); // double check\r\n\r\n        if(toFund > 0) {\r\n            require(wanToken.mintToken(receipient, wanTokenCollect));         \r\n            wanport.transfer(toFund);\r\n            openSoldTokens = openSoldTokens.add(wanTokenCollect);\r\n            NewSale(receipient, toFund, wanTokenCollect);            \r\n        }\r\n\r\n        uint toReturn = msg.value.sub(toFund);\r\n        if(toReturn > 0) {\r\n            msg.sender.transfer(toReturn);\r\n        }\r\n    }\r\n\r\n    /// @dev Utility function for calculate available tokens and cost ethers\r\n    function costAndBuyTokens(uint availableToken) constant internal returns (uint costValue, uint getTokens){\r\n      // all conditions has checked in the caller functions\r\n      uint exchangeRate = priceRate();\r\n      getTokens = exchangeRate * msg.value;\r\n\r\n      if(availableToken >= getTokens){\r\n        costValue = msg.value;\r\n      } else {\r\n        costValue = availableToken / exchangeRate;\r\n        getTokens = availableToken;\r\n      }\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"DEV_TEAM_STAKE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"earlyCap\",\"type\":\"uint256\"},{\"name\":\"openTag\",\"type\":\"uint256\"}],\"name\":\"setEarlyWhitelistQuotas\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_RATE_LAST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"normalBuyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEV_TEAM_HOLDER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDATION_HOLDER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OPEN_SOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyUserQuotas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVISOR_STAKE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setNormalBuyLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleNotEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EARLY_CONTRIBUTION_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_RESERVERED_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unHalt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_RATE_SECOND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wanport\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINERS_HOLDER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wanToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"openTag\",\"type\":\"uint256\"}],\"name\":\"setLaterWhiteList\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDATION_STAKE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPEN_SALE_STAKE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openSoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAN_TOTAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_RATE_FIRST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_HOLDER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receipient\",\"type\":\"address\"}],\"name\":\"buyWanCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receipent\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CONTRIBUTION_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeWalletAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINERS_STAKE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyReserveBeginTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fullWhiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wanport\",\"type\":\"address\"},{\"name\":\"_bootTime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethCost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gotTokens\",\"type\":\"uint256\"}],\"name\":\"NewSale\",\"type\":\"event\"}]","ContractName":"WanchainContribution","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000010242590b52545afdc82fe44b064ce055479eb0000000000000000000000000000000000000000000000000000000059d3b400","Library":"","SwarmSource":"bzzr://cf354415565dbcba55ca7d803241ed623e9875b86e7d49619e734c70d0b4d0bf"}]}