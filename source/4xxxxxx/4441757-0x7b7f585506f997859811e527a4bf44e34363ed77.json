{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n//\r\n// Ann.sol - A smart contract for managing announcements cryptographically.\r\n// Licensed under MIT\r\n// See https://github.com/secure-vote/ann.sol/ for the readme and license\r\n// \r\n// This contract allows publishers to push out announcements cryptographically.\r\n// Before the contract recognizes them, they must be \"thumbs up\"ed by one or\r\n// more third parties. Those third parties can also raise the alarm if they\r\n// believe the announcement was made illegitimately.\r\n//\r\n// See https://ann-sol.com for a frontend and more info.\r\n// See https://github.com/secure-vote/ann.sol/ for the contract source code.\r\n//\r\n\r\ncontract Announcement {\r\n\r\n    struct Message {\r\n        string ipfsHash;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct MessageAwaitingAudit {\r\n        uint256 nAudits;\r\n        uint256 nAlarms;\r\n        Message msg;\r\n        mapping (address => bool) auditedBy;\r\n        mapping (address => bool) alarmedBy;\r\n    }\r\n\r\n    address public owner;\r\n    mapping(address => bool) public auditors;\r\n    address[] public auditorsList;\r\n    uint256 public nAuditors;\r\n    uint256 public nAuditorsRequired = 1;\r\n    uint256 public nAuditorsAlarm = 1;\r\n    uint256 public nAlarms = 0;\r\n    uint256[] public alarms;\r\n    mapping(uint256 => bool) public alarmRaised;\r\n\r\n    uint256 public nMsg = 0;\r\n    mapping(uint256 => Message) public msgMap;\r\n\r\n    uint256 public nMsgsWaiting = 0;\r\n    mapping(uint256 => MessageAwaitingAudit) msgsWaiting;\r\n    mapping(uint256 => bool) public msgsWaitingDone;\r\n\r\n\r\n    modifier isOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier isAuditor() {\r\n        require(auditors[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n\r\n    function Announcement(address[] _auditors, uint256 _nAuditorsRequired, uint256 _nAuditorsAlarm) {\r\n        require(_nAuditorsRequired >= 1);\r\n        require(_nAuditorsAlarm >= 1);\r\n\r\n        for (uint256 i = 0; i < _auditors.length; i++) {\r\n            auditors[_auditors[i]] = true;\r\n            auditorsList.push(_auditors[i]);\r\n        }\r\n        nAuditors = _auditors.length;\r\n\r\n        owner = msg.sender;\r\n        nAuditorsRequired = _nAuditorsRequired;\r\n        nAuditorsAlarm = _nAuditorsAlarm;\r\n    }\r\n\r\n    function addAnn (string ipfsHash) isOwner external {\r\n        require(bytes(ipfsHash).length > 0);\r\n        msgQPut(ipfsHash);\r\n    }\r\n\r\n    function msgQPut (string ipfsHash) private {\r\n        createNewMsgAwaitingAudit(ipfsHash, block.timestamp);\r\n    }\r\n\r\n    function addAudit (uint256 msgWaitingN, bool msgGood) isAuditor external {\r\n        // ensure the msgWaiting is not done, and that this auditor has not submitted an audit previously\r\n        require(msgsWaitingDone[msgWaitingN] == false);\r\n        MessageAwaitingAudit msgWaiting = msgsWaiting[msgWaitingN];\r\n        require(msgWaiting.auditedBy[msg.sender] == false);\r\n        require(msgWaiting.alarmedBy[msg.sender] == false);\r\n        require(alarmRaised[msgWaitingN] == false);\r\n\r\n        // check if the auditor is giving a thumbs up or a thumbs down and adjust things appropriately\r\n        if (msgGood == true) {\r\n            msgWaiting.nAudits += 1;\r\n            msgWaiting.auditedBy[msg.sender] = true;\r\n        } else {\r\n            msgWaiting.nAlarms += 1;\r\n            msgWaiting.alarmedBy[msg.sender] = true;\r\n        }\r\n\r\n        // have we reached the right number of auditors and not triggered an alarm?\r\n        if (msgWaiting.nAudits >= nAuditorsRequired && msgWaiting.nAlarms < nAuditorsAlarm) {\r\n            // then remove msg from queue and add to messages\r\n            addMsgFinal(msgWaiting.msg, msgWaitingN);\r\n        } else if (msgWaiting.nAlarms >= nAuditorsAlarm) {\r\n            msgsWaitingDone[msgWaitingN] = true;\r\n            alarmRaised[msgWaitingN] = true;\r\n            alarms.push(msgWaitingN);\r\n            nAlarms += 1;\r\n        }\r\n    }\r\n\r\n    function createNewMsgAwaitingAudit(string ipfsHash, uint256 timestamp) private {\r\n        msgsWaiting[nMsgsWaiting] = MessageAwaitingAudit(0, 0, Message(ipfsHash, timestamp));\r\n        nMsgsWaiting += 1;\r\n    }\r\n\r\n    function addMsgFinal(Message msg, uint256 msgWaitingN) private {\r\n        // ensure we store the message first\r\n        msgMap[nMsg] = msg;\r\n        nMsg += 1;\r\n\r\n        // finally note that this has been processed and clean up\r\n        msgsWaitingDone[msgWaitingN] = true;\r\n        delete msgsWaiting[msgWaitingN];\r\n    }\r\n\r\n    function getMsgWaiting(uint256 msgWaitingN) constant external returns (uint256, uint256, string, uint256, bool) {\r\n        MessageAwaitingAudit maa = msgsWaiting[msgWaitingN];\r\n        return (\r\n            maa.nAudits,\r\n            maa.nAlarms,\r\n            maa.msg.ipfsHash,\r\n            maa.msg.timestamp,\r\n            alarmRaised[msgWaitingN]\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"msgsWaitingDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auditorsList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msgWaitingN\",\"type\":\"uint256\"},{\"name\":\"msgGood\",\"type\":\"bool\"}],\"name\":\"addAudit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nMsg\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"auditors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nAuditorsRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nAuditors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"alarmRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nAuditorsAlarm\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ipfsHash\",\"type\":\"string\"}],\"name\":\"addAnn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"msgWaitingN\",\"type\":\"uint256\"}],\"name\":\"getMsgWaiting\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"alarms\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nMsgsWaiting\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"msgMap\",\"outputs\":[{\"name\":\"ipfsHash\",\"type\":\"string\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nAlarms\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_auditors\",\"type\":\"address[]\"},{\"name\":\"_nAuditorsRequired\",\"type\":\"uint256\"},{\"name\":\"_nAuditorsAlarm\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Announcement","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000e8193bc3d5f3f482406706f843a5f161563f37bf00000000000000000000000067a970d8499eac3602f4f5424878eb6e939dd705","Library":"","SwarmSource":"bzzr://5a07c8e0ce77fcac46f44784474a666de0fd9b6988021c222dfe5455eaf3fc35"}]}