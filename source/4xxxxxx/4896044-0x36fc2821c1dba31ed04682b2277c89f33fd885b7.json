{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/land/LANDStorage.sol\r\n\r\ncontract LANDStorage {\r\n\r\n  mapping (address => uint) latestPing;\r\n\r\n  uint256 constant clearLow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;\r\n  uint256 constant clearHigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n  uint256 constant factor = 0x100000000000000000000000000000000;\r\n\r\n}\r\n\r\n// File: contracts/registry/AssetRegistryStorage.sol\r\n\r\ncontract AssetRegistryStorage {\r\n\r\n  string internal _name;\r\n  string internal _symbol;\r\n  string internal _description;\r\n\r\n  /**\r\n   * Stores the total count of assets managed by this registry\r\n   */\r\n  uint256 internal _count;\r\n\r\n  /**\r\n   * Stores an array of assets owned by a given account\r\n   */\r\n  mapping(address => uint256[]) internal _assetsOf;\r\n\r\n  /**\r\n   * Stores the current holder of an asset\r\n   */\r\n  mapping(uint256 => address) internal _holderOf;\r\n\r\n  /**\r\n   * Stores the index of an asset in the `_assetsOf` array of its holder\r\n   */\r\n  mapping(uint256 => uint256) internal _indexOfAsset;\r\n\r\n  /**\r\n   * Stores the data associated with an asset\r\n   */\r\n  mapping(uint256 => string) internal _assetData;\r\n\r\n  /**\r\n   * For a given account, for a given opperator, store whether that operator is\r\n   * allowed to transfer and modify assets on behalf of them.\r\n   */\r\n  mapping(address => mapping(address => bool)) internal _operators;\r\n\r\n  /**\r\n   * Simple reentrancy lock\r\n   */\r\n  bool internal _reentrancy;\r\n}\r\n\r\n// File: contracts/upgradable/OwnableStorage.sol\r\n\r\ncontract OwnableStorage {\r\n\r\n  address public owner;\r\n\r\n  function OwnableStorage() internal {\r\n    owner = msg.sender;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/upgradable/ProxyStorage.sol\r\n\r\ncontract ProxyStorage {\r\n\r\n  /**\r\n   * Current contract to which we are proxing\r\n   */\r\n  address currentContract;\r\n\r\n}\r\n\r\n// File: contracts/Storage.sol\r\n\r\ncontract Storage is ProxyStorage, OwnableStorage, AssetRegistryStorage, LANDStorage {\r\n}\r\n\r\n// File: contracts/upgradable/DelegateProxy.sol\r\n\r\ncontract DelegateProxy {\r\n  /**\r\n   * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\r\n   * @param _dst Destination address to perform the delegatecall\r\n   * @param _calldata Calldata for the delegatecall\r\n   */\r\n  function delegatedFwd(address _dst, bytes _calldata) internal {\r\n    require(isContract(_dst));\r\n    assembly {\r\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\r\n      let size := returndatasize\r\n\r\n      let ptr := mload(0x40)\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n      // if the call returned error data, forward it\r\n      switch result case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n\r\n  function isContract(address _target) constant internal returns (bool) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(_target) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n// File: contracts/upgradable/IApplication.sol\r\n\r\ncontract IApplication {\r\n  function initialize(bytes data) public;\r\n}\r\n\r\n// File: contracts/upgradable/Proxy.sol\r\n\r\ncontract Proxy is ProxyStorage, DelegateProxy {\r\n\r\n  event Upgrade(address indexed newContract, bytes initializedWith);\r\n\r\n  function upgrade(IApplication newContract, bytes data) public {\r\n    currentContract = newContract;\r\n    newContract.initialize(data);\r\n\r\n    Upgrade(newContract, data);\r\n  }\r\n\r\n  function () payable public {\r\n    require(currentContract != 0); // if app code hasn't been set yet, don't call\r\n    delegatedFwd(currentContract, msg.data);\r\n  }\r\n}\r\n\r\n// File: contracts/upgradable/LANDProxy.sol\r\n\r\ncontract LANDProxy is Storage, Proxy {\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContract\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"initializedWith\",\"type\":\"bytes\"}],\"name\":\"Upgrade\",\"type\":\"event\"}]","ContractName":"LANDProxy","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://77d80c354131d5812d54015651d6e4132c03ad9382d43757c5ccc288bf20af79"}]}