{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Manageable\r\n * @dev Contract that allows to grant permissions to any address\r\n * @dev In real life we are no able to perform all actions with just one Ethereum address\r\n * @dev because risks are too high.\r\n * @dev Instead owner delegates rights to manage an contract to the different addresses and\r\n * @dev stay able to revoke permissions at any time.\r\n */\r\ncontract Manageable is Ownable {\r\n\r\n  /* Storage */\r\n\r\n  mapping (address => bool) managerEnabled;  // hard switch for a manager - on/off\r\n  mapping (address => mapping (string => bool)) managerPermissions;  // detailed info about manager`s permissions\r\n\r\n\r\n  /* Events */\r\n\r\n  event ManagerEnabledEvent(address indexed manager);\r\n  event ManagerDisabledEvent(address indexed manager);\r\n  event ManagerPermissionGrantedEvent(address indexed manager, string permission);\r\n  event ManagerPermissionRevokedEvent(address indexed manager, string permission);\r\n\r\n\r\n  /* Configure contract */\r\n\r\n  /**\r\n   * @dev Function to add new manager\r\n   * @param _manager address New manager\r\n   */\r\n  function enableManager(address _manager) external onlyOwner onlyValidAddress(_manager) {\r\n    require(managerEnabled[_manager] == false);\r\n\r\n    managerEnabled[_manager] = true;\r\n    ManagerEnabledEvent(_manager);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to remove existing manager\r\n   * @param _manager address Existing manager\r\n   */\r\n  function disableManager(address _manager) external onlyOwner onlyValidAddress(_manager) {\r\n    require(managerEnabled[_manager] == true);\r\n\r\n    managerEnabled[_manager] = false;\r\n    ManagerDisabledEvent(_manager);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to grant new permission to the manager\r\n   * @param _manager        address Existing manager\r\n   * @param _permissionName string  Granted permission name\r\n   */\r\n  function grantManagerPermission(\r\n    address _manager, string _permissionName\r\n  )\r\n    external\r\n    onlyOwner\r\n    onlyValidAddress(_manager)\r\n    onlyValidPermissionName(_permissionName)\r\n  {\r\n    require(managerPermissions[_manager][_permissionName] == false);\r\n\r\n    managerPermissions[_manager][_permissionName] = true;\r\n    ManagerPermissionGrantedEvent(_manager, _permissionName);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to revoke permission of the manager\r\n   * @param _manager        address Existing manager\r\n   * @param _permissionName string  Revoked permission name\r\n   */\r\n  function revokeManagerPermission(\r\n    address _manager, string _permissionName\r\n  )\r\n    external\r\n    onlyOwner\r\n    onlyValidAddress(_manager)\r\n    onlyValidPermissionName(_permissionName)\r\n  {\r\n    require(managerPermissions[_manager][_permissionName] == true);\r\n\r\n    managerPermissions[_manager][_permissionName] = false;\r\n    ManagerPermissionRevokedEvent(_manager, _permissionName);\r\n  }\r\n\r\n\r\n  /* Getters */\r\n\r\n  /**\r\n   * @dev Function to check manager status\r\n   * @param _manager address Manager`s address\r\n   * @return True if manager is enabled\r\n   */\r\n  function isManagerEnabled(address _manager) public constant onlyValidAddress(_manager) returns (bool) {\r\n    return managerEnabled[_manager];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check permissions of a manager\r\n   * @param _manager        address Manager`s address\r\n   * @param _permissionName string  Permission name\r\n   * @return True if manager has been granted needed permission\r\n   */\r\n  function isPermissionGranted(\r\n    address _manager, string _permissionName\r\n  )\r\n    public\r\n    constant\r\n    onlyValidAddress(_manager)\r\n    onlyValidPermissionName(_permissionName)\r\n    returns (bool)\r\n  {\r\n    return managerPermissions[_manager][_permissionName];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check if the manager can perform the action or not\r\n   * @param _manager        address Manager`s address\r\n   * @param _permissionName string  Permission name\r\n   * @return True if manager is enabled and has been granted needed permission\r\n   */\r\n  function isManagerAllowed(\r\n    address _manager, string _permissionName\r\n  )\r\n    public\r\n    constant\r\n    onlyValidAddress(_manager)\r\n    onlyValidPermissionName(_permissionName)\r\n    returns (bool)\r\n  {\r\n    return (managerEnabled[_manager] && managerPermissions[_manager][_permissionName]);\r\n  }\r\n\r\n\r\n  /* Helpers */\r\n\r\n  /**\r\n   * @dev Modifier to check manager address\r\n   */\r\n  modifier onlyValidAddress(address _manager) {\r\n    require(_manager != address(0x0));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to check name of manager permission\r\n   */\r\n  modifier onlyValidPermissionName(string _permissionName) {\r\n    require(bytes(_permissionName).length != 0);\r\n    _;\r\n  }\r\n\r\n\r\n  /* Outcome */\r\n\r\n  /**\r\n   * @dev Modifier to use in derived contracts\r\n   */\r\n  modifier onlyAllowedManager(string _permissionName) {\r\n    require(isManagerAllowed(msg.sender, _permissionName) == true);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n * @dev Based on zeppelin's Pausable, but integrated with Manageable\r\n * @dev Contract is in paused state by default and should be explicitly unlocked\r\n */\r\ncontract Pausable is Manageable {\r\n\r\n  /**\r\n   * Events\r\n   */\r\n\r\n  event PauseEvent();\r\n  event UnpauseEvent();\r\n\r\n\r\n  /**\r\n   * Storage\r\n   */\r\n\r\n  bool paused = true;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenContractNotPaused() {\r\n    require(paused == false);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenContractPaused {\r\n    require(paused == true);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the manager to pause, triggers stopped state\r\n   */\r\n  function pauseContract() external onlyAllowedManager('pause_contract') whenContractNotPaused {\r\n    paused = true;\r\n    PauseEvent();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the manager to unpause, returns to normal state\r\n   */\r\n  function unpauseContract() external onlyAllowedManager('unpause_contract') whenContractPaused {\r\n    paused = false;\r\n    UnpauseEvent();\r\n  }\r\n\r\n  /**\r\n   * @dev The getter for \"paused\" contract variable\r\n   */\r\n  function getPaused() external constant returns (bool) {\r\n    return paused;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title NamedToken\r\n */\r\ncontract NamedToken {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  function NamedToken(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to calculate hash of the token`s name.\r\n   * @dev Function needed because we can not just return name of the token to another contract - strings have variable length\r\n   * @return Hash of the token`s name\r\n   */\r\n  function getNameHash() external constant returns (bytes32 result){\r\n    return keccak256(name);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to calculate hash of the token`s symbol.\r\n   * @dev Function needed because we can not just return symbol of the token to another contract - strings have variable length\r\n   * @return Hash of the token`s symbol\r\n   */\r\n  function getSymbolHash() external constant returns (bytes32 result){\r\n    return keccak256(symbol);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AngelToken\r\n */\r\ncontract AngelToken is StandardToken, NamedToken, Pausable {\r\n\r\n  /* Events */\r\n\r\n  event MintEvent(address indexed account, uint value);\r\n  event BurnEvent(address indexed account, uint value);\r\n  event SpendingBlockedEvent(address indexed account);\r\n  event SpendingUnblockedEvent(address indexed account);\r\n\r\n\r\n  /* Storage */\r\n\r\n  address public centralBankAddress = 0x0;\r\n  mapping (address => uint) spendingBlocksNumber;\r\n\r\n\r\n  /* Constructor */\r\n\r\n  function AngelToken() public NamedToken('Angel Token', 'ANGL', 18) {\r\n    centralBankAddress = msg.sender;\r\n  }\r\n\r\n\r\n  /* Methods */\r\n\r\n  function transfer(address _to, uint _value) public returns (bool) {\r\n    if (_to != centralBankAddress) {\r\n      require(!paused);\r\n    }\r\n    require(spendingBlocksNumber[msg.sender] == 0);\r\n\r\n    bool result = super.transfer(_to, _value);\r\n    if (result == true && _to == centralBankAddress) {\r\n      AngelCentralBank(centralBankAddress).angelBurn(msg.sender, _value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function approve(address _spender, uint _value) public whenContractNotPaused returns (bool){\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) public whenContractNotPaused returns (bool){\r\n    require(spendingBlocksNumber[_from] == 0);\r\n\r\n    bool result = super.transferFrom(_from, _to, _value);\r\n    if (result == true && _to == centralBankAddress) {\r\n      AngelCentralBank(centralBankAddress).angelBurn(_from, _value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n\r\n  function mint(address _account, uint _value) external onlyAllowedManager('mint_tokens') {\r\n    balances[_account] = balances[_account].add(_value);\r\n    totalSupply = totalSupply.add(_value);\r\n    MintEvent(_account, _value);\r\n    Transfer(address(0x0), _account, _value); // required for blockexplorers\r\n  }\r\n\r\n  function burn(uint _value) external onlyAllowedManager('burn_tokens') {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    totalSupply = totalSupply.sub(_value);\r\n    BurnEvent(msg.sender, _value);\r\n  }\r\n\r\n  function blockSpending(address _account) external onlyAllowedManager('block_spending') {\r\n    spendingBlocksNumber[_account] = spendingBlocksNumber[_account].add(1);\r\n    SpendingBlockedEvent(_account);\r\n  }\r\n\r\n  function unblockSpending(address _account) external onlyAllowedManager('unblock_spending') {\r\n    spendingBlocksNumber[_account] = spendingBlocksNumber[_account].sub(1);\r\n    SpendingUnblockedEvent(_account);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AngelCentralBank\r\n *\r\n * @dev Crowdsale and escrow contract\r\n */\r\ncontract AngelCentralBank {\r\n\r\n  /* Data structures */\r\n\r\n  struct InvestmentRecord {\r\n    uint tokensSoldBeforeWei;\r\n    uint investedEthWei;\r\n    uint purchasedTokensWei;\r\n    uint refundedEthWei;\r\n    uint returnedTokensWei;\r\n  }\r\n\r\n\r\n  /* Storage - config */\r\n\r\n  uint public constant icoCap = 70000000 * (10 ** 18);\r\n\r\n  uint public initialTokenPrice = 1 * (10 ** 18) / (10 ** 4); // means 0.0001 ETH for one token\r\n\r\n  uint public constant landmarkSize = 1000000 * (10 ** 18);\r\n  uint public constant landmarkPriceStepNumerator = 10;\r\n  uint public constant landmarkPriceStepDenominator = 100;\r\n\r\n  uint public constant firstRefundRoundRateNumerator = 80;\r\n  uint public constant firstRefundRoundRateDenominator = 100;\r\n  uint public constant secondRefundRoundRateNumerator = 40;\r\n  uint public constant secondRefundRoundRateDenominator = 100;\r\n\r\n  uint public constant initialFundsReleaseNumerator = 20; // part of investment\r\n  uint public constant initialFundsReleaseDenominator = 100;\r\n  uint public constant afterFirstRefundRoundFundsReleaseNumerator = 50; // part of remaining funds\r\n  uint public constant afterFirstRefundRoundFundsReleaseDenominator = 100;\r\n\r\n  uint public constant angelFoundationShareNumerator = 30;\r\n  uint public constant angelFoundationShareDenominator = 100;\r\n\r\n  /* Storage - state */\r\n\r\n  address public angelFoundationAddress = address(0x2b0556a6298eA3D35E90F1df32cc126b31F59770);\r\n  uint public icoLaunchTimestamp = 1511784000;  // November 27th 12:00 GMT\r\n  uint public icoFinishTimestamp = 1514376000;  // December 27th 12:00 GMT\r\n  uint public firstRefundRoundFinishTimestamp = 1520424000;  // March 7th 2018 12:00 GMT\r\n  uint public secondRefundRoundFinishTimestamp = 1524744000;  // April 26th 2018 12:00 GMT\r\n\r\n\r\n  AngelToken public angelToken;\r\n\r\n  mapping (address => InvestmentRecord[]) public investments; // investorAddress => list of investments\r\n  mapping (address => bool) public investors;\r\n  uint public totalInvestors = 0;\r\n  uint public totalTokensSold = 0;\r\n\r\n  bool isIcoFinished = false;\r\n  bool firstRefundRoundFundsWithdrawal = false;\r\n\r\n\r\n  /* Events */\r\n\r\n  event InvestmentEvent(address indexed investor, uint eth, uint angel);\r\n  event RefundEvent(address indexed investor, uint eth, uint angel);\r\n\r\n\r\n  /* Constructor and config */\r\n\r\n  function AngelCentralBank() public {\r\n    angelToken = new AngelToken();\r\n    angelToken.enableManager(address(this));\r\n    angelToken.grantManagerPermission(address(this), 'mint_tokens');\r\n    angelToken.grantManagerPermission(address(this), 'burn_tokens');\r\n    angelToken.grantManagerPermission(address(this), 'unpause_contract');\r\n    angelToken.transferOwnership(angelFoundationAddress);\r\n  }\r\n\r\n  /* Investments */\r\n\r\n  /**\r\n   * @dev Fallback function receives ETH and sends tokens back\r\n   */\r\n  function () public payable {\r\n    angelRaise();\r\n  }\r\n\r\n  /**\r\n   * @dev Process new ETH investment and sends tokens back\r\n   */\r\n  function angelRaise() internal {\r\n    require(msg.value > 0);\r\n    require(now >= icoLaunchTimestamp && now < icoFinishTimestamp);\r\n\r\n    // calculate amount of tokens for received ETH\r\n    uint _purchasedTokensWei = 0;\r\n    uint _notProcessedEthWei = 0;\r\n    (_purchasedTokensWei, _notProcessedEthWei) = calculatePurchasedTokens(totalTokensSold, msg.value);\r\n    uint _actualInvestment = (msg.value - _notProcessedEthWei);\r\n\r\n    // create record for the investment\r\n    uint _newRecordIndex = investments[msg.sender].length;\r\n    investments[msg.sender].length += 1;\r\n    investments[msg.sender][_newRecordIndex].tokensSoldBeforeWei = totalTokensSold;\r\n    investments[msg.sender][_newRecordIndex].investedEthWei = _actualInvestment;\r\n    investments[msg.sender][_newRecordIndex].purchasedTokensWei = _purchasedTokensWei;\r\n    investments[msg.sender][_newRecordIndex].refundedEthWei = 0;\r\n    investments[msg.sender][_newRecordIndex].returnedTokensWei = 0;\r\n\r\n    // calculate stats\r\n    if (investors[msg.sender] == false) {\r\n      totalInvestors += 1;\r\n    }\r\n    investors[msg.sender] = true;\r\n    totalTokensSold += _purchasedTokensWei;\r\n\r\n    // transfer tokens and ETH\r\n    angelToken.mint(msg.sender, _purchasedTokensWei);\r\n    angelToken.mint(angelFoundationAddress,\r\n                    _purchasedTokensWei * angelFoundationShareNumerator / (angelFoundationShareDenominator - angelFoundationShareNumerator));\r\n    angelFoundationAddress.transfer(_actualInvestment * initialFundsReleaseNumerator / initialFundsReleaseDenominator);\r\n    if (_notProcessedEthWei > 0) {\r\n      msg.sender.transfer(_notProcessedEthWei);\r\n    }\r\n\r\n    // finish ICO if cap reached\r\n    if (totalTokensSold >= icoCap) {\r\n      icoFinishTimestamp = now;\r\n\r\n      finishIco();\r\n    }\r\n\r\n    // fire event\r\n    InvestmentEvent(msg.sender, _actualInvestment, _purchasedTokensWei);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate amount of tokens for received ETH\r\n   * @param _totalTokensSoldBefore uint Amount of tokens sold before this investment [token wei]\r\n   * @param _investedEthWei        uint Investment amount [ETH wei]\r\n   * @return Purchased amount of tokens [token wei]\r\n   */\r\n  function calculatePurchasedTokens(\r\n    uint _totalTokensSoldBefore,\r\n    uint _investedEthWei)\r\n    constant public returns (uint _purchasedTokensWei, uint _notProcessedEthWei)\r\n  {\r\n    _purchasedTokensWei = 0;\r\n    _notProcessedEthWei = _investedEthWei;\r\n\r\n    uint _landmarkPrice;\r\n    uint _maxLandmarkTokensWei;\r\n    uint _maxLandmarkEthWei;\r\n    bool _isCapReached = false;\r\n    do {\r\n      // get landmark values\r\n      _landmarkPrice = calculateLandmarkPrice(_totalTokensSoldBefore + _purchasedTokensWei);\r\n      _maxLandmarkTokensWei = landmarkSize - ((_totalTokensSoldBefore + _purchasedTokensWei) % landmarkSize);\r\n      if (_totalTokensSoldBefore + _purchasedTokensWei + _maxLandmarkTokensWei >= icoCap) {\r\n        _maxLandmarkTokensWei = icoCap - _totalTokensSoldBefore - _purchasedTokensWei;\r\n        _isCapReached = true;\r\n      }\r\n      _maxLandmarkEthWei = _maxLandmarkTokensWei * _landmarkPrice / (10 ** 18);\r\n\r\n      // check investment against landmark values\r\n      if (_notProcessedEthWei >= _maxLandmarkEthWei) {\r\n        _purchasedTokensWei += _maxLandmarkTokensWei;\r\n        _notProcessedEthWei -= _maxLandmarkEthWei;\r\n      }\r\n      else {\r\n        _purchasedTokensWei += _notProcessedEthWei * (10 ** 18) / _landmarkPrice;\r\n        _notProcessedEthWei = 0;\r\n      }\r\n    }\r\n    while ((_notProcessedEthWei > 0) && (_isCapReached == false));\r\n\r\n    assert(_purchasedTokensWei > 0);\r\n\r\n    return (_purchasedTokensWei, _notProcessedEthWei);\r\n  }\r\n\r\n\r\n  /* Refunds */\r\n\r\n  function angelBurn(\r\n    address _investor,\r\n    uint _returnedTokensWei\r\n  )\r\n    external returns (uint)\r\n  {\r\n    require(msg.sender == address(angelToken));\r\n    require(now >= icoLaunchTimestamp && now < secondRefundRoundFinishTimestamp);\r\n\r\n    uint _notProcessedTokensWei = _returnedTokensWei;\r\n    uint _refundedEthWei = 0;\r\n\r\n    uint _allRecordsNumber = investments[_investor].length;\r\n    uint _recordMaxReturnedTokensWei = 0;\r\n    uint _recordTokensWeiToProcess = 0;\r\n    uint _tokensSoldWei = 0;\r\n    uint _recordRefundedEthWei = 0;\r\n    uint _recordNotProcessedTokensWei = 0;\r\n    for (uint _recordID = 0; _recordID < _allRecordsNumber; _recordID += 1) {\r\n      if (investments[_investor][_recordID].purchasedTokensWei <= investments[_investor][_recordID].returnedTokensWei ||\r\n          investments[_investor][_recordID].investedEthWei <= investments[_investor][_recordID].refundedEthWei) {\r\n        // tokens already refunded\r\n        continue;\r\n      }\r\n\r\n      // calculate amount of tokens to refund with this record\r\n      _recordMaxReturnedTokensWei = investments[_investor][_recordID].purchasedTokensWei -\r\n                                    investments[_investor][_recordID].returnedTokensWei;\r\n      _recordTokensWeiToProcess = (_notProcessedTokensWei < _recordMaxReturnedTokensWei) ? _notProcessedTokensWei :\r\n                                                                                           _recordMaxReturnedTokensWei;\r\n      assert(_recordTokensWeiToProcess > 0);\r\n\r\n      // calculate amount of ETH to send back\r\n      _tokensSoldWei = investments[_investor][_recordID].tokensSoldBeforeWei + investments[_investor][_recordID].returnedTokensWei;\r\n      (_recordRefundedEthWei, _recordNotProcessedTokensWei) = calculateRefundedEth(_tokensSoldWei, _recordTokensWeiToProcess);\r\n      if (_recordRefundedEthWei > (investments[_investor][_recordID].investedEthWei - investments[_investor][_recordID].refundedEthWei)) {\r\n        // this can happen due to rounding error\r\n        _recordRefundedEthWei = (investments[_investor][_recordID].investedEthWei - investments[_investor][_recordID].refundedEthWei);\r\n      }\r\n      assert(_recordRefundedEthWei > 0);\r\n      assert(_recordNotProcessedTokensWei == 0);\r\n\r\n      // persist changes to the storage\r\n      _refundedEthWei += _recordRefundedEthWei;\r\n      _notProcessedTokensWei -= _recordTokensWeiToProcess;\r\n\r\n      investments[_investor][_recordID].refundedEthWei += _recordRefundedEthWei;\r\n      investments[_investor][_recordID].returnedTokensWei += _recordTokensWeiToProcess;\r\n      assert(investments[_investor][_recordID].refundedEthWei <= investments[_investor][_recordID].investedEthWei);\r\n      assert(investments[_investor][_recordID].returnedTokensWei <= investments[_investor][_recordID].purchasedTokensWei);\r\n\r\n      // stop if we already refunded all tokens\r\n      if (_notProcessedTokensWei == 0) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // throw if we do not have tokens to refund\r\n    require(_notProcessedTokensWei < _returnedTokensWei);\r\n    require(_refundedEthWei > 0);\r\n\r\n    // calculate refund discount\r\n    uint _refundedEthWeiWithDiscount = calculateRefundedEthWithDiscount(_refundedEthWei);\r\n\r\n    // transfer ETH and remaining tokens\r\n    angelToken.burn(_returnedTokensWei - _notProcessedTokensWei);\r\n    if (_notProcessedTokensWei > 0) {\r\n      angelToken.transfer(_investor, _notProcessedTokensWei);\r\n    }\r\n    _investor.transfer(_refundedEthWeiWithDiscount);\r\n\r\n    // fire event\r\n    RefundEvent(_investor, _refundedEthWeiWithDiscount, _returnedTokensWei - _notProcessedTokensWei);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate discounted amount of ETH for refunded tokens\r\n   * @param _refundedEthWei uint Calculated amount of ETH to refund [ETH wei]\r\n   * @return Discounted amount of ETH for refunded [ETH wei]\r\n   */\r\n  function calculateRefundedEthWithDiscount(\r\n    uint _refundedEthWei\r\n  )\r\n    public constant returns (uint)\r\n  {\r\n    if (now <= firstRefundRoundFinishTimestamp) {\r\n      return (_refundedEthWei * firstRefundRoundRateNumerator / firstRefundRoundRateDenominator);\r\n    }\r\n    else {\r\n      return (_refundedEthWei * secondRefundRoundRateNumerator / secondRefundRoundRateDenominator);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate amount of ETH for refunded tokens. Just abstract price ladder\r\n   * @param _totalTokensSoldBefore     uint Amount of tokens that have been sold (starting point) [token wei]\r\n   * @param _returnedTokensWei uint Amount of tokens to refund [token wei]\r\n   * @return Refunded amount of ETH [ETH wei] (without discounts)\r\n   */\r\n  function calculateRefundedEth(\r\n    uint _totalTokensSoldBefore,\r\n    uint _returnedTokensWei\r\n  )\r\n    public constant returns (uint _refundedEthWei, uint _notProcessedTokensWei)\r\n  {\r\n    _refundedEthWei = 0;\r\n    uint _refundedTokensWei = 0;\r\n    _notProcessedTokensWei = _returnedTokensWei;\r\n\r\n    uint _landmarkPrice = 0;\r\n    uint _maxLandmarkTokensWei = 0;\r\n    uint _maxLandmarkEthWei = 0;\r\n    bool _isCapReached = false;\r\n    do {\r\n      // get landmark values\r\n      _landmarkPrice = calculateLandmarkPrice(_totalTokensSoldBefore + _refundedTokensWei);\r\n      _maxLandmarkTokensWei = landmarkSize - ((_totalTokensSoldBefore + _refundedTokensWei) % landmarkSize);\r\n      if (_totalTokensSoldBefore + _refundedTokensWei + _maxLandmarkTokensWei >= icoCap) {\r\n        _maxLandmarkTokensWei = icoCap - _totalTokensSoldBefore - _refundedTokensWei;\r\n        _isCapReached = true;\r\n      }\r\n      _maxLandmarkEthWei = _maxLandmarkTokensWei * _landmarkPrice / (10 ** 18);\r\n\r\n      // check investment against landmark values\r\n      if (_notProcessedTokensWei > _maxLandmarkTokensWei) {\r\n        _refundedEthWei += _maxLandmarkEthWei;\r\n        _refundedTokensWei += _maxLandmarkTokensWei;\r\n        _notProcessedTokensWei -= _maxLandmarkTokensWei;\r\n      }\r\n      else {\r\n        _refundedEthWei += _notProcessedTokensWei * _landmarkPrice / (10 ** 18);\r\n        _refundedTokensWei += _notProcessedTokensWei;\r\n        _notProcessedTokensWei = 0;\r\n      }\r\n    }\r\n    while ((_notProcessedTokensWei > 0) && (_isCapReached == false));\r\n\r\n    assert(_refundedEthWei > 0);\r\n\r\n    return (_refundedEthWei, _notProcessedTokensWei);\r\n  }\r\n\r\n\r\n  /* Calculation of the price */\r\n\r\n  /**\r\n   * @dev Calculate price for tokens\r\n   * @param _totalTokensSoldBefore uint Amount of tokens sold before [token wei]\r\n   * @return Calculated price\r\n   */\r\n  function calculateLandmarkPrice(uint _totalTokensSoldBefore) public constant returns (uint) {\r\n    return initialTokenPrice + initialTokenPrice\r\n                               * landmarkPriceStepNumerator / landmarkPriceStepDenominator\r\n                               * (_totalTokensSoldBefore / landmarkSize);\r\n  }\r\n\r\n\r\n  /* Lifecycle */\r\n\r\n  function finishIco() public {\r\n    require(now >= icoFinishTimestamp);\r\n    require(isIcoFinished == false);\r\n\r\n    isIcoFinished = true;\r\n\r\n    angelToken.unpauseContract();\r\n  }\r\n\r\n  function withdrawFoundationFunds() external {\r\n    require(now > firstRefundRoundFinishTimestamp);\r\n\r\n    if (now > firstRefundRoundFinishTimestamp && now <= secondRefundRoundFinishTimestamp) {\r\n      require(firstRefundRoundFundsWithdrawal == false);\r\n\r\n      firstRefundRoundFundsWithdrawal = true;\r\n      angelFoundationAddress.transfer(this.balance * afterFirstRefundRoundFundsReleaseNumerator / afterFirstRefundRoundFundsReleaseDenominator);\r\n    } else {\r\n      angelFoundationAddress.transfer(this.balance);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"firstRefundRoundRateNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstRefundRoundRateDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"angelFoundationShareNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"afterFirstRefundRoundFundsReleaseNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondRefundRoundRateDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondRefundRoundRateNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialFundsReleaseNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investments\",\"outputs\":[{\"name\":\"tokensSoldBeforeWei\",\"type\":\"uint256\"},{\"name\":\"investedEthWei\",\"type\":\"uint256\"},{\"name\":\"purchasedTokensWei\",\"type\":\"uint256\"},{\"name\":\"refundedEthWei\",\"type\":\"uint256\"},{\"name\":\"returnedTokensWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalTokensSoldBefore\",\"type\":\"uint256\"},{\"name\":\"_investedEthWei\",\"type\":\"uint256\"}],\"name\":\"calculatePurchasedTokens\",\"outputs\":[{\"name\":\"_purchasedTokensWei\",\"type\":\"uint256\"},{\"name\":\"_notProcessedEthWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalTokensSoldBefore\",\"type\":\"uint256\"},{\"name\":\"_returnedTokensWei\",\"type\":\"uint256\"}],\"name\":\"calculateRefundedEth\",\"outputs\":[{\"name\":\"_refundedEthWei\",\"type\":\"uint256\"},{\"name\":\"_notProcessedTokensWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"angelFoundationAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFoundationFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"landmarkPriceStepDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"afterFirstRefundRoundFundsReleaseDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoFinishTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"landmarkSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_refundedEthWei\",\"type\":\"uint256\"}],\"name\":\"calculateRefundedEthWithDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"angelToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondRefundRoundFinishTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_returnedTokensWei\",\"type\":\"uint256\"}],\"name\":\"angelBurn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialFundsReleaseDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstRefundRoundFinishTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalTokensSoldBefore\",\"type\":\"uint256\"}],\"name\":\"calculateLandmarkPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"landmarkPriceStepNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"angelFoundationShareDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoLaunchTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"angel\",\"type\":\"uint256\"}],\"name\":\"InvestmentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"angel\",\"type\":\"uint256\"}],\"name\":\"RefundEvent\",\"type\":\"event\"}]","ContractName":"AngelCentralBank","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9cfbe6a75c8c57bae56a9ea58ceb1a3eb59e6a8e31f877279953872a7c4486fb"}]}