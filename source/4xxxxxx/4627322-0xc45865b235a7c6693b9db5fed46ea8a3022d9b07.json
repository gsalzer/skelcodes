{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * IOwnership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IOwnership {\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public view returns (address);\r\n}\r\n\r\n\r\n/**\r\n * Ownership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract Ownership is IOwnership {\r\n\r\n    // Owner\r\n    address internal owner;\r\n\r\n\r\n    /**\r\n     * Access is restricted to the current owner\r\n     */\r\n    modifier only_owner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * The publisher is the inital owner\r\n     */\r\n    function Ownership() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool) {\r\n        return _account == owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ERC20 compatible token interface\r\n *\r\n * - Implements ERC 20 Token standard\r\n * - Implements short address attack fix\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IToken { \r\n\r\n    /** \r\n     * Get the total supply of tokens\r\n     * \r\n     * @return The total supply\r\n     */\r\n    function totalSupply() public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * ITokenObserver\r\n *\r\n * Allows a token smart-contract to notify observers \r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ITokenObserver {\r\n\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value) public;\r\n}\r\n\r\n\r\n/**\r\n * TokenObserver\r\n *\r\n * Allows observers to be notified by an observed token smart-contract\r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenObserver is ITokenObserver {\r\n\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value) public {\r\n        onTokensReceived(msg.sender, _from, _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler\r\n     * \r\n     * Called by `_token` when a token amount is received\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal;\r\n}\r\n\r\n\r\n/**\r\n * ITokenRetriever\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public;\r\n}\r\n\r\n\r\n/**\r\n * TokenRetriever\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 18/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenRetriever is ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public {\r\n        IToken tokenInstance = IToken(_tokenContract);\r\n        uint tokenBalance = tokenInstance.balanceOf(this);\r\n        if (tokenBalance > 0) {\r\n            tokenInstance.transfer(msg.sender, tokenBalance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * IDcorpCrowdsaleAdapter\r\n *\r\n * Interface that allows collective contributions from DCORP members\r\n * \r\n * DCORP DAO VC & Promotion https://www.dcorp.it\r\n *\r\n * #created 10/11/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IDcorpCrowdsaleAdapter {\r\n\r\n    /**\r\n     * Receive Eth and issue tokens to the sender\r\n     */\r\n    function isEnded() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     */\r\n    function withdrawTokens() public;\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     */\r\n    function withdrawEther() public;\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     */\r\n    function refund() public;\r\n}\r\n\r\n\r\n/**\r\n * IDcorpPersonalCrowdsaleProxy\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IDcorpPersonalCrowdsaleProxy {\r\n\r\n    /**\r\n     * Receive ether and issue tokens\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n}\r\n\r\n\r\n/**\r\n * DcorpPersonalCrowdsaleProxy\r\n *\r\n * Proxy that allows collective contributions from DCORP members using \r\n * a unique address\r\n * \r\n * DCORP DAO VC & Promotion https://www.dcorp.it\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract DcorpPersonalCrowdsaleProxy is IDcorpPersonalCrowdsaleProxy {\r\n\r\n    address public member;\r\n    IDcorpCrowdsaleAdapter public target;\r\n    \r\n\r\n    /**\r\n     * Deploy proxy\r\n     *\r\n     * @param _member Owner of the proxy\r\n     * @param _target Target crowdsale\r\n     */\r\n    function DcorpPersonalCrowdsaleProxy(address _member, address _target) public {\r\n        target = IDcorpCrowdsaleAdapter(_target);\r\n        member = _member;\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive contribution and forward to the target crowdsale\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     */\r\n    function () public payable {\r\n        target.contributeFor.value(msg.value)(member);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * IDcorpCrowdsaleProxy\r\n *\r\n * #created 23/11/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IDcorpCrowdsaleProxy {\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * DcorpCrowdsaleProxy\r\n *\r\n * Proxy that allows collective contributions from DCORP members\r\n * \r\n * DCORP DAO VC & Promotion https://www.dcorp.it\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract DcorpCrowdsaleProxy is IDcorpCrowdsaleProxy, Ownership, TokenObserver, TokenRetriever {\r\n\r\n    enum Stages {\r\n        Deploying,\r\n        Attached,\r\n        Deployed\r\n    }\r\n\r\n    struct Record {\r\n        uint weight;\r\n        uint contributed;\r\n        uint withdrawnTokens;\r\n        uint index;\r\n    }\r\n\r\n    Stages public stage;\r\n    bool private updating;\r\n\r\n    // Member records\r\n    mapping (address => Record) private records;\r\n    address[] private recordIndex;\r\n\r\n    uint public totalContributed;\r\n    uint public totalTokensReceived;\r\n    uint public totalTokensWithdrawn;\r\n    uint public totalWeight;\r\n\r\n    // Weight calculation\r\n    uint public factorWeight;\r\n    uint public factorContributed;\r\n\r\n    // Target crowdsale\r\n    IDcorpCrowdsaleAdapter public crowdsale;\r\n    IToken public token;\r\n\r\n    // Dcorp tokens\r\n    IToken public drpsToken;\r\n    IToken public drpuToken;\r\n\r\n\r\n    /**\r\n     * Throw if at stage other than current stage\r\n     * \r\n     * @param _stage expected stage to test for\r\n     */\r\n    modifier at_stage(Stages _stage) {\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Throw if crowdsale not ended yet\r\n     */\r\n    modifier only_when_ended() {\r\n        require(crowdsale.isEnded());\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Prevent reentry\r\n     */\r\n    modifier only_when_not_updating() {\r\n        require(!updating);\r\n        _;\r\n    }\r\n\r\n\r\n    // Events\r\n    event DcorpProxyCreated(address proxy, address beneficiary);\r\n\r\n\r\n    /**\r\n     * Deploy the proxy\r\n     */\r\n    function DcorpCrowdsaleProxy() public {\r\n        stage = Stages.Deploying;\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup the proxy\r\n     *\r\n     * Share calcuation is based on the drpu and drps token balances and the \r\n     * contributed amount of ether. The weight factor and contributed factor \r\n     * determin the weight of each factor\r\n     *\r\n     * @param _drpsToken 1/2 tokens used for weight calculation\r\n     * @param _drpuToken 2/2 tokens used for weight calculation\r\n     * @param _factorWeight Weight of the token balance factor\r\n     * @param _factorContributed Weight of the contributed amount factor\r\n     */\r\n    function setup(address _drpsToken, address _drpuToken, uint _factorWeight, uint _factorContributed) public only_owner at_stage(Stages.Deploying) {\r\n        drpsToken = IToken(_drpsToken);\r\n        drpuToken = IToken(_drpuToken);\r\n        factorWeight = _factorWeight;\r\n        factorContributed = _factorContributed;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Attach a crowdsale and corresponding token to the proxy. Contributions are \r\n     * forwarded to `_crowdsale` and rewards are denoted in tokens located at `_token`\r\n     *\r\n     * @param _crowdsale The crowdsale to forward contributions to\r\n     * @param _token The reward token\r\n     */\r\n    function attachCrowdsale(address _crowdsale, address _token) public only_owner at_stage(Stages.Deploying) {\r\n        stage = Stages.Attached;\r\n        crowdsale = IDcorpCrowdsaleAdapter(_crowdsale);\r\n        token = IToken(_token);\r\n    }\r\n\r\n\r\n    /**\r\n     * After calling the deploy function the proxy's\r\n     * rules become immutable \r\n     */\r\n    function deploy() public only_owner at_stage(Stages.Attached) {\r\n        stage = Stages.Deployed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Deploy a contract that serves as a proxy to \r\n     * the crowdsale\r\n     *\r\n     * Contributions through this address will be made \r\n     * for msg.sender\r\n     *\r\n     * @return The address of the deposit address\r\n     */\r\n    function createPersonalDepositAddress() public returns (address) {\r\n        address proxy = new DcorpPersonalCrowdsaleProxy(msg.sender, this);\r\n        DcorpProxyCreated(proxy, msg.sender);\r\n        return proxy;\r\n    }\r\n\r\n\r\n    /**\r\n     * Deploy a contract that serves as a proxy to \r\n     * the crowdsale\r\n     *\r\n     * Contributions through this address will be made \r\n     * for `_beneficiary`\r\n     *\r\n     * @param _beneficiary The owner of the proxy\r\n     * @return The address of the deposit address\r\n     */\r\n    function createPersonalDepositAddressFor(address _beneficiary) public returns (address) {\r\n        address proxy = new DcorpPersonalCrowdsaleProxy(_beneficiary, this);\r\n        DcorpProxyCreated(proxy, _beneficiary);\r\n        return proxy;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_member` has a record\r\n     *\r\n     * @param _member The account that has contributed\r\n     * @return True if there is a record that belongs to `_member`\r\n     */\r\n    function hasRecord(address _member) public view returns (bool) {\r\n        return records[_member].index < recordIndex.length && _member == recordIndex[records[_member].index];\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the recorded amount of ether that is contributed by `_member`\r\n     * \r\n     * @param _member The address from which the contributed amount will be retrieved\r\n     * @return The contributed amount\r\n     */\r\n    function contributedAmountOf(address _member) public view returns (uint) {\r\n        return records[_member].contributed;\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the allocated token balance of `_member`\r\n     * \r\n     * @param _member The address from which the allocated token balance will be retrieved\r\n     * @return The allocated token balance\r\n     */\r\n    function balanceOf(address _member) public view returns (uint) {\r\n        Record storage r = records[_member];\r\n        uint balance = 0;\r\n        uint share = shareOf(_member);\r\n        if (share > 0 && r.withdrawnTokens < share) {\r\n            balance = share - r.withdrawnTokens;\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the total share of the received tokens of `_member`\r\n     *\r\n     * Share calcuation is based on the drpu and drps token balances and the \r\n     * contributed amount of ether. The weight factor and contributed factor \r\n     * determin the weight of each factor\r\n     * \r\n     * @param _member The address from which the share will be retrieved\r\n     * @return The total share\r\n     */\r\n    function shareOf(address _member) public view returns (uint) {\r\n        Record storage r = records[_member];\r\n\r\n        // Factored totals\r\n        uint factoredTotalWeight = totalWeight * factorWeight;\r\n        uint factoredTotalContributed = totalContributed * factorContributed;\r\n\r\n        // Factored member\r\n        uint factoredWeight = r.weight * factorWeight;\r\n        uint factoredContributed = r.contributed * factorContributed;\r\n\r\n        // Calculate share (member / total * tokens)\r\n        return (factoredWeight + factoredContributed) * totalTokensReceived / (factoredTotalWeight + factoredTotalContributed);\r\n    }\r\n\r\n\r\n    /**\r\n     * Request tokens from the target crowdsale by calling \r\n     * it's withdraw token function\r\n     */\r\n    function requestTokensFromCrowdsale() public only_when_not_updating {\r\n        crowdsale.withdrawTokens();\r\n    }\r\n\r\n\r\n    /**\r\n     * Update internal token balance\r\n     * \r\n     * Tokens that are received at the proxies address are \r\n     * recorded internally\r\n     */\r\n    function updateBalances() public only_when_not_updating {\r\n        updating = true;\r\n\r\n        uint recordedBalance = totalTokensReceived - totalTokensWithdrawn;\r\n        uint actualBalance = token.balanceOf(this);\r\n        \r\n        // Update balance intrnally\r\n        if (actualBalance > recordedBalance) {\r\n            totalTokensReceived += actualBalance - recordedBalance;\r\n        }\r\n\r\n        updating = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     */\r\n    function withdrawTokens() public only_when_ended only_when_not_updating {\r\n        address member = msg.sender;\r\n        uint balance = balanceOf(member);\r\n\r\n        // Record internally\r\n        records[member].withdrawnTokens += balance;\r\n        totalTokensWithdrawn += balance;\r\n\r\n        // Transfer share\r\n        if (!token.transfer(member, balance)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive Eth and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable {\r\n        require(msg.sender == tx.origin);\r\n        _handleTransaction(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint) {\r\n        return _handleTransaction(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint) {\r\n        return _handleTransaction(_beneficiary);\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe mechanism\r\n     * \r\n     * Allows the owner to retrieve tokens from the contract that \r\n     * might have been send there by accident\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public only_owner {\r\n        require(_tokenContract != address(token));\r\n        super.retrieveTokens(_tokenContract);\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler that processes the token received event\r\n     * \r\n     * Called by `_token` when a token amount is received on \r\n     * the address of this proxy\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal {\r\n        require(_token == msg.sender);\r\n        require(_token == address(token));\r\n        require(_from == address(0));\r\n        \r\n        // Record deposit\r\n        totalTokensReceived += _value;\r\n    }\r\n\r\n\r\n    /**\r\n     * Handle incoming transactions\r\n     * \r\n     * @param _beneficiary Tokens are issued to this account\r\n     * @return Accepted ether amount\r\n     */\r\n    function _handleTransaction(address _beneficiary) private only_when_not_updating at_stage(Stages.Deployed) returns (uint) {\r\n        uint weight = _getWeight(_beneficiary);\r\n        uint received = msg.value;\r\n\r\n        // Contribute for beneficiary\r\n        uint acceptedAmount = crowdsale.contributeFor.value(received)(_beneficiary);\r\n\r\n        // Record transaction\r\n        if (!hasRecord(_beneficiary)) {\r\n            records[_beneficiary] = Record(\r\n                weight, acceptedAmount, 0, recordIndex.push(_beneficiary) - 1);\r\n            totalWeight += weight;\r\n        } else {\r\n            Record storage r = records[_beneficiary];\r\n            r.contributed += acceptedAmount;\r\n            if (weight < r.weight) {\r\n                // Adjust weight\r\n                r.weight = weight;\r\n                totalWeight -= r.weight - weight;\r\n            }\r\n        }\r\n\r\n        // Record conribution\r\n        totalContributed += acceptedAmount;\r\n        return acceptedAmount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Retrieve the combined drp balances from the drpu and drps tokens\r\n     *\r\n     * @param _account Token owner\r\n     * @return Weight, drp balance\r\n     */\r\n    function _getWeight(address _account) private view returns (uint) {\r\n        return drpsToken.balanceOf(_account) + drpuToken.balanceOf(_account);\r\n    }\r\n}\r\n\r\n\r\ncontract KATXDcorpMemberProxy is DcorpCrowdsaleProxy {\r\n    function KATXDcorpMemberProxy() public DcorpCrowdsaleProxy() {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"contributeFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_drpsToken\",\"type\":\"address\"},{\"name\":\"_drpuToken\",\"type\":\"address\"},{\"name\":\"_factorWeight\",\"type\":\"uint256\"},{\"name\":\"_factorContributed\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"attachCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"shareOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factorWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drpsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"createPersonalDepositAddressFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"notifyTokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createPersonalDepositAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestTokensFromCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drpuToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factorContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"contributedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"hasRecord\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"DcorpProxyCreated\",\"type\":\"event\"}]","ContractName":"KATXDcorpMemberProxy","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3ac714943a56f0d7c212c789d88461983caed1157d601a1bb1d0e23ee30d1c8b"}]}