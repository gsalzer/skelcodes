{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  bool transferAllowed = false;\r\n\r\n  function setTransferAllowed(bool _transferAllowed) public onlyOwner {\r\n    transferAllowed = _transferAllowed;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n    require(transferAllowed);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n//StandardToken.sol\r\ncontract StandardToken is ERC20, BasicToken {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(transferAllowed);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\ncontract MatToken is Ownable, StandardToken {\r\n  string public constant name = \"MiniApps Token\";\r\n  string public constant symbol = \"MAT\";\r\n  uint   public constant decimals = 18;\r\n  \r\n  // token units\r\n  uint256 public constant MAT_UNIT = 10**uint256(decimals);\r\n  uint256 constant MILLION_MAT = 10**6 * MAT_UNIT;\r\n  uint256 constant THOUSAND_MAT = 10**3 * MAT_UNIT;\r\n\r\n  // Token distribution: crowdsale - 50%, partners - 35%, team - 15%, total 20M  \r\n  uint256 public constant MAT_CROWDSALE_SUPPLY_LIMIT = 10 * MILLION_MAT;\r\n  uint256 public constant MAT_TEAM_SUPPLY_LIMIT = 7 * MILLION_MAT;\r\n  uint256 public constant MAT_PARTNERS_SUPPLY_LIMIT = 3 * MILLION_MAT;\r\n  uint256 public constant MAT_TOTAL_SUPPLY_LIMIT = MAT_CROWDSALE_SUPPLY_LIMIT + MAT_TEAM_SUPPLY_LIMIT + MAT_PARTNERS_SUPPLY_LIMIT;\r\n}\r\n\r\ncontract MatBonus is MatToken {\r\n  uint256 public constant TOTAL_SUPPLY_UPPER_BOUND = 14000 * THOUSAND_MAT;\r\n  uint256 public constant TOTAL_SUPPLY_BOTTOM_BOUND = 11600 * THOUSAND_MAT;\r\n\r\n  function calcBonus(uint256 tokens) internal returns (uint256){\r\n    if (totalSupply <= TOTAL_SUPPLY_BOTTOM_BOUND)\r\n      return tokens.mul(8).div(100);\r\n    else if (totalSupply > TOTAL_SUPPLY_BOTTOM_BOUND && totalSupply <= TOTAL_SUPPLY_UPPER_BOUND)\r\n      return tokens.mul(5).div(100);\r\n    else\r\n      return 0;\r\n  }\r\n}\r\n\r\ncontract MatBase is Ownable, MatToken, MatBonus {\r\n using SafeMath for uint256;\r\n  \r\n  uint256 public constant _START_DATE = 1508284800; //  Wednesday, 18-Oct-17 00:00:00 UTC in RFC 2822\r\n  uint256 public constant _END_DATE = 1513641600; // Tuesday, 19-Dec-17 00:00:00 UTC in RFC 2822\r\n  uint256 public constant CROWDSALE_PRICE = 100; // 100 MAT per ETH\r\n  address public constant ICO_ADDRESS = 0x6075a5A0620861cfeF593a51A01aF0fF179168C7;\r\n  address public constant PARTNERS_WALLET =  0x39467d5B39F1d24BC8479212CEd151ad469B0D7E;\r\n  address public constant TEAM_WALLET = 0xe1d32147b08b2a7808026D4A94707E321ccc7150;\r\n\r\n  // start and end timestamps where investments are allowed (both inclusive)\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  function setStartTime(uint256 _startTime) onlyOwner\r\n  {\r\n    startTime = _startTime;\r\n  }\r\n  function setEndTime(uint256 _endTime) onlyOwner\r\n  {\r\n    endTime = _endTime;\r\n  }\r\n\r\n  // address  where funds are collected\r\n  address public wallet;\r\n  address public p_wallet;\r\n  address public t_wallet;\r\n\r\n  // total amount of raised money in wei\r\n  uint256 public totalCollected;\r\n  // how many token units a buyer gets per wei\r\n  uint256 public rate;\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public constant returns (bool) {\r\n    return now > endTime;\r\n  }\r\n  event Mint(address indexed purchaser, uint256 amount);\r\n  event Bonus(address indexed purchaser,uint256 amount);\r\n  function mint(address _to, uint256 _tokens) internal returns (bool) {\r\n    totalSupply = totalSupply.add(_tokens);\r\n    require(totalSupply <= whiteListLimit);\r\n    require(totalSupply <= MAT_TOTAL_SUPPLY_LIMIT);\r\n\r\n    balances[_to] = balances[_to].add(_tokens);\r\n    Mint(_to, _tokens);\r\n    Transfer(0x0, _to, _tokens);\r\n    return true;\r\n  }\r\n  // send ether to the fund collection wallet\r\n  // override to create custom fund forwarding mechanisms\r\n  function forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n\r\n  // @return true if the transaction can buy tokens\r\n  function validPurchase() internal constant returns (bool) {\r\n    bool withinPeriod = now >= startTime && now <= endTime;\r\n    bool nonZeroPurchase = msg.value != 0;\r\n    return withinPeriod && nonZeroPurchase;\r\n  }\r\n  /**\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amountTokens amount of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amountTokens,\r\n    string referral);\r\n\r\n  // fallback function can be used to buy tokens\r\n  function () payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  // low level token purchase function\r\n  function buyTokens(address beneficiary) public payable {\r\n    buyTokensReferral(beneficiary, \"\");\r\n  }\r\n\r\n  // low level token purchase function\r\n  function buyTokensReferral(address beneficiary, string referral) public payable {\r\n    require(msg.value > 0);\r\n    require(beneficiary != 0x0);\r\n    require(validPurchase());\r\n\r\n    uint256 weiAmount = msg.value;\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = weiAmount.mul(rate);\r\n    uint256 bonus = calcBonus(tokens);\r\n\r\n    // update state\r\n    totalCollected = totalCollected.add(weiAmount);\r\n\r\n    if (!buyTokenWL(tokens)) mint(beneficiary, bonus);\r\n    mint(beneficiary, tokens);\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, referral);\r\n    forwardFunds();\r\n  }\r\n\r\n//whitelist\r\n  bool isWhitelistOn;\r\n  uint256 public whiteListLimit;\r\n\r\n  enum WLS {notlisted,listed,fulfilled}\r\n  struct FundReservation {\r\n    WLS status;\r\n    uint256  reserved;\r\n  }\r\n  mapping ( address => FundReservation ) whitelist;\r\n\r\n  function stopWhitelistReservetion() onlyOwner public { \r\n    whiteListLimit = MAT_TOTAL_SUPPLY_LIMIT; \r\n  }\r\n\r\n  function setWhiteListStatus(bool _isWhitelistOn) onlyOwner public {\r\n    isWhitelistOn = _isWhitelistOn;\r\n  }\r\n\r\n  function buyTokenWL(uint256 tokens) internal returns (bool)\r\n  { \r\n    require(isWhitelistOn);\r\n    require(now >= startTime);\r\n    if (whitelist[msg.sender].status == WLS.listed) {\r\n      uint256 reservation = whitelist[msg.sender].reserved;\r\n      uint256 low = reservation.mul(9).div(10);\r\n      uint256 upper = reservation.mul(11).div(10);\r\n      \r\n      if( low <= msg.value && msg.value <= upper) {\r\n        whitelist[msg.sender].status == WLS.fulfilled;\r\n        uint256 bonus = tokens / 10;\r\n        mint(msg.sender, bonus);\r\n        Bonus(msg.sender,bonus);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  event White(address indexed to, uint256 reservation);\r\n  function regWL(address wlmember, uint256 reservation) onlyOwner public returns (bool status)\r\n  {\r\n    require(now < endTime);\r\n    require(whitelist[wlmember].status == WLS.notlisted);\r\n    \r\n    whitelist[wlmember].status = WLS.listed;\r\n    whitelist[wlmember].reserved = reservation;\r\n    \r\n    whiteListLimit = whiteListLimit.sub(reservation.mul(CROWDSALE_PRICE).mul(11).div(10));\r\n    White(wlmember,reservation);\r\n    return true;\r\n  }\r\n  address public constant PRESALE_CONTRACT = 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd;\r\n    /**\r\n   * @dev presale token conversion \r\n   *\r\n   * @param _to holder of presale tokens\r\n   * @param _pretokens The amount of presale tokens to be spent.\r\n   * @param _tokens The amount of presale tokens to be minted on crowdsale, the rest transfer from partners pool\r\n   */\r\n  function convert(address _to, uint256 _pretokens, uint256 _tokens) onlyOwner public returns (bool){\r\n    require(now <= endTime);\r\n    require(_to != address(0));\r\n    require(_pretokens >=  _tokens);\r\n    \r\n    mint(_to, _tokens); //implicit transfer event\r\n    \r\n    uint256 theRest = _pretokens.sub(_tokens);\r\n    require(balances[PARTNERS_WALLET] >= theRest);\r\n    \r\n    if (theRest > 0) {\r\n      balances[PARTNERS_WALLET] = balances[PARTNERS_WALLET].sub(theRest);\r\n      balances[_to] = balances[_to].add(theRest);\r\n      Transfer(PARTNERS_WALLET, _to, theRest); //explicit transfer event\r\n    }\r\n    uint256 amount = _pretokens.div(rate);\r\n    totalCollected = totalCollected.add(amount);\r\n    return true;\r\n  }\r\n  function MatBase() {\r\n    startTime = _START_DATE;\r\n    endTime = _END_DATE;\r\n    wallet = ICO_ADDRESS;\r\n    rate = CROWDSALE_PRICE;\r\n    p_wallet = PARTNERS_WALLET;\r\n    t_wallet = TEAM_WALLET;\r\n    balances[p_wallet] =  MAT_PARTNERS_SUPPLY_LIMIT;\r\n    balances[t_wallet] = MAT_TEAM_SUPPLY_LIMIT;\r\n    totalSupply = MAT_PARTNERS_SUPPLY_LIMIT + MAT_TEAM_SUPPLY_LIMIT;\r\n    whiteListLimit = MAT_TOTAL_SUPPLY_LIMIT;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stopWhitelistReservetion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAT_TEAM_SUPPLY_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAT_UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SUPPLY_UPPER_BOUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_pretokens\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_END_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAT_PARTNERS_SUPPLY_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SUPPLY_BOTTOM_BOUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isWhitelistOn\",\"type\":\"bool\"}],\"name\":\"setWhiteListStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAT_CROWDSALE_SUPPLY_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CROWDSALE_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_START_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferAllowed\",\"type\":\"bool\"}],\"name\":\"setTransferAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"p_wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"referral\",\"type\":\"string\"}],\"name\":\"buyTokensReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PARTNERS_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAT_TOTAL_SUPPLY_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wlmember\",\"type\":\"address\"},{\"name\":\"reservation\",\"type\":\"uint256\"}],\"name\":\"regWL\",\"outputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Bonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referral\",\"type\":\"string\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reservation\",\"type\":\"uint256\"}],\"name\":\"White\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MatBase","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://05bd84fb419cd6b5d2c61ae851e1580b024a41e193134ec826189c6bd804b7da"}]}