{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/**\r\n* assert(2 + 2 is 4 - 1 thats 3) Quick Mafs \r\n*/\r\nlibrary QuickMafs {\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a * _b;\r\n        assert(_a == 0 || c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = _a / _b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_b <= _a);\r\n        return _a - _b;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/** \r\n* The ownable contract contains an owner address. This give us simple ownership privledges and can allow ownship transfer. \r\n*/\r\ncontract Ownable {\r\n\r\n     /** \r\n     * The owner/admin of the contract\r\n     */ \r\n     address public owner;\r\n    \r\n     /**\r\n     * Constructor for contract. Sets The contract creator to the default owner.\r\n     */\r\n     function Ownable() public {\r\n         owner = msg.sender;\r\n     }\r\n    \r\n    /**\r\n    * Modifier to apply to methods to restrict access to the owner\r\n    */\r\n     modifier onlyOwner(){\r\n         require(msg.sender == owner);\r\n         _; //Placeholder for method content\r\n     }\r\n    \r\n    /**\r\n    * Transfer the ownership to a new owner can only be done by the current owner. \r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n    \r\n        //Only make the change if required\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n*  ERC Token Standard #20 Interface\r\n*/\r\ncontract ERC20 {\r\n    \r\n    /**\r\n    * Get the total token supply\r\n    */\r\n    function totalSupply() public constant returns (uint256 _totalSupply);\r\n    \r\n    /**\r\n    * Get the account balance of another account with address _owner\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    \r\n    /**\r\n    * Send _amount of tokens to address _to\r\n    */\r\n    function transfer(address _to, uint256 _amount) public returns (bool success);\r\n    \r\n    /**\r\n    * Send _amount of tokens from address _from to address _to\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\r\n    \r\n    /**\r\n    * Allow _spender to withdraw from your account, multiple times, up to the _amount.\r\n    * If this function is called again it overwrites the current allowance with _amount.\r\n    * this function is required for some DEX functionality\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns (bool success);\r\n    \r\n    /**\r\n    * Returns the amount which _spender is still allowed to withdraw from _owner\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n    \r\n    /**\r\n    * Triggered when tokens are transferred.\r\n    */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    \r\n    /**\r\n    * Triggered whenever approve(address _spender, uint256 _amount) is called.\r\n    */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n}\r\n\r\n\r\n/**\r\n* The CTN Token\r\n*/\r\ncontract Token is ERC20, Ownable {\r\n\r\n    using QuickMafs for uint256;\r\n    \r\n    string public constant SYMBOL = \"CTN\";\r\n    string public constant NAME = \"Crypto Trust Network\";\r\n    uint8 public constant DECIMALS = 18;\r\n    \r\n    /**\r\n    * Total supply of tokens\r\n    */\r\n    uint256 totalTokens;\r\n    \r\n    /**\r\n    * The initial supply of coins before minting\r\n     */\r\n    uint256 initialSupply;\r\n    \r\n    /**\r\n    * Balances for each account\r\n    */\r\n    mapping(address => uint256) balances;\r\n    \r\n    /**\r\n    * Whos allowed to withdrawl funds from which accounts\r\n    */\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    \r\n    /**\r\n     * If the token is tradable\r\n     */ \r\n     bool tradable;\r\n     \r\n    /**\r\n    * The address to store the initialSupply\r\n    */\r\n    address public vault;\r\n    \r\n    /**\r\n    * If the coin can be minted\r\n    */\r\n    bool public mintingFinished = false;\r\n    \r\n    /**\r\n     * Event for when new coins are created \r\n     */\r\n    event Mint(address indexed _to, uint256 _value);\r\n    \r\n    /**\r\n    * Event that is fired when token sale is over\r\n    */\r\n    event MintFinished();\r\n    \r\n    /**\r\n     * Tokens can now be traded\r\n     */ \r\n    event TradableTokens(); \r\n    \r\n    /**\r\n     * Allows this coin to be traded between users\r\n     */ \r\n    modifier isTradable(){\r\n        require(tradable);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * If this coin can be minted modifier\r\n     */\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * Initializing the token, setting the owner, initial supply & vault\r\n    */\r\n    function Token() public {\r\n        initialSupply = 4500000 * 1 ether;\r\n        totalTokens = initialSupply;\r\n        tradable = false;\r\n        vault = 0x6e794AAA2db51fC246b1979FB9A9849f53919D1E; \r\n        balances[vault] = balances[vault].add(initialSupply); //Set initial supply to the vault\r\n    }\r\n    \r\n    /**\r\n    * Obtain current total supply of CTN tokens \r\n    */\r\n    function totalSupply() public constant returns (uint256 totalAmount) {\r\n          totalAmount = totalTokens;\r\n    }\r\n    \r\n    /**\r\n    * Get the initial supply of CTN coins \r\n    */\r\n    function baseSupply() public constant returns (uint256 initialAmount) {\r\n          initialAmount = initialSupply;\r\n    }\r\n    \r\n    /**\r\n    * Returns the balance of a wallet\r\n    */ \r\n    function balanceOf(address _address) public constant returns (uint256 balance) {\r\n        return balances[_address];\r\n    }\r\n    \r\n    /**\r\n    * Transfer CTN between wallets\r\n    */ \r\n    function transfer(address _to, uint256 _amount) public isTradable returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Send _amount of tokens from address _from to address _to\r\n    * The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    * fees in sub-currencies; the command should fail unless the _from account has\r\n    * deliberately authorized the sender of the message via some mechanism; we propose\r\n    * these standardized APIs for approval:\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public isTradable returns (bool success) \r\n    {\r\n        var _allowance = allowed[_from][msg.sender];\r\n    \r\n        /** \r\n        *   QuickMaf will roll back any changes so no need to check before these operations\r\n        */\r\n        balances[_to] = balances[_to].add(_amount);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = _allowance.sub(_amount);\r\n        Transfer(_from, _to, _amount);\r\n        return true;  \r\n    }\r\n\r\n    /**\r\n    * Allows an address to transfer money out this is administered by the contract owner who can specify how many coins an account can take.\r\n    * Needs to be called to feault the amount to 0 first -> https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns (bool) {\r\n        /**\r\n        *Set the amount they are able to spend to 0 first so that transaction ordering cannot allow multiple withdrawls asyncly\r\n        *This function always requires to calls if a user has an amount they can withdrawl.\r\n        */\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n    \r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Check the amount of tokens the owner has allowed to a spender\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n         return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * Makes the coin tradable between users cannot be undone\r\n     */\r\n    function makeTradable() public onlyOwner {\r\n        tradable = true;\r\n        TradableTokens();\r\n    }\r\n    \r\n    /**\r\n    * Mint tokens to users\r\n    */\r\n    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\r\n        totalTokens = totalTokens.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Mint(_to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Function to stop minting tokens irreversable\r\n    */\r\n    function finishMinting() public onlyOwner returns (bool) {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* The initial crowdsale of the token\r\n*/\r\ncontract Sale is Ownable {\r\n\r\n\r\n    using QuickMafs for uint256;\r\n    \r\n    /**\r\n     * The hard cap of the token sale\r\n     */\r\n    uint256 hardCap;\r\n    \r\n    /**\r\n     * The soft cap of the token sale\r\n     */\r\n    uint256 softCap;\r\n    \r\n    /**\r\n     * The bonus cap for the token sale\r\n     */\r\n    uint256 bonusCap;\r\n    \r\n    /**\r\n     * How many tokens you get per ETH\r\n     */\r\n    uint256 tokensPerETH;\r\n    \r\n    /** \r\n    * //the start time of the sale (new Date(\"Jan 22 2018 18:00:00 GMT\").getTime() / 1000)\r\n    */\r\n    uint256 public start = 1516644000;\r\n                \r\n    \r\n    /**\r\n     * The end time of the sale (new Date(\"Feb 22 2018 18:00:00 GMT\").getTime() / 1000)\r\n     */ \r\n    uint256 public end = 1519322400;\r\n    \r\n    /**\r\n     * Two months after the sale ends used to retrieve unclaimed refunds (new Date(\"Apr 22 2018 18:00:00 GMT\").getTime() / 1000)\r\n     */\r\n    uint256 public twoMonthsLater = 1524420000;\r\n    \r\n    /**\r\n    * Token for minting purposes\r\n    */\r\n    Token public token;\r\n    \r\n    /**\r\n    * The address to store eth in during sale \r\n    */\r\n    address public vault;\r\n    \r\n    \r\n    /**\r\n    * How much ETH each user has sent to this contract. For softcap unmet refunds\r\n    */\r\n    mapping(address => uint256) investments;\r\n    \r\n    \r\n    /**\r\n    * Every purchase during the sale\r\n    */\r\n    event TokenSold(address recipient, uint256 etherAmount, uint256 ctnAmount, bool preSale, bool bonus);\r\n    \r\n    \r\n    /**\r\n    * Triggered when tokens are transferred.\r\n    */\r\n    event PriceUpdated(uint256 amount);\r\n    \r\n    /**\r\n    * Only make certain changes before the sale starts\r\n    */\r\n    modifier isPreSale(){\r\n         require(now < start);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * Is the sale still on\r\n    */\r\n    modifier isSaleOn() {\r\n        require(now >= start && now <= end);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * Has the sale completed\r\n    */\r\n    modifier isSaleFinished() {\r\n        \r\n        bool hitHardCap = token.totalSupply().sub(token.baseSupply()) >= hardCap;\r\n        require(now > end || hitHardCap);\r\n        \r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * Has the sale completed\r\n    */\r\n    modifier isTwoMonthsLater() {\r\n        require(now > twoMonthsLater);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * Make sure we are under the hardcap\r\n    */\r\n    modifier isUnderHardCap() {\r\n    \r\n        bool underHard = token.totalSupply().sub(token.baseSupply()) <= hardCap;\r\n        require(underHard);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * Make sure we are over the soft cap\r\n    */\r\n    modifier isOverSoftCap() {\r\n        bool overSoft = token.totalSupply().sub(token.baseSupply()) >= softCap;\r\n        require(overSoft);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * Make sure we are over the soft cap\r\n    */\r\n    modifier isUnderSoftCap() {\r\n        bool underSoft = token.totalSupply().sub(token.baseSupply()) < softCap;\r\n        require(underSoft);\r\n        _;\r\n    }\r\n    \r\n    /** \r\n    *   The token sale constructor\r\n    */\r\n    function Sale() public {\r\n        hardCap = 10500000 * 1 ether;\r\n        softCap = 500000 * 1 ether;\r\n        bonusCap = 2000000 * 1 ether;\r\n        tokensPerETH = 630; //Tokens per 1 ETH\r\n        token = new Token();\r\n        vault = 0x6e794AAA2db51fC246b1979FB9A9849f53919D1E; \r\n    }\r\n    \r\n    /**\r\n    * Fallback function which receives ether and created the appropriate number of tokens for the \r\n    * msg.sender.\r\n    */\r\n    function() external payable {\r\n        //If we can not purchase tokens presale then try purchase them normally\r\n        if ( now < start ) {\r\n            purchaseTokensPreSale(msg.sender);\r\n        } else {\r\n            purchaseTokens(msg.sender);\r\n        }\r\n    }\r\n       \r\n    /**\r\n    * If the soft cap has not been reached and the sale is over investors can reclaim their funds\r\n    */ \r\n    function refund() public isSaleFinished isUnderSoftCap {\r\n        uint256 amount = investments[msg.sender];\r\n        investments[msg.sender] = investments[msg.sender].sub(amount);\r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    /**\r\n    * Withdrawl the funds from the contract.\r\n    * Make the token tradeable and finish minting\r\n    */ \r\n    function withdrawl() public isSaleFinished isOverSoftCap {\r\n        vault.transfer(this.balance);\r\n        \r\n        //Stop minting of the token and make the token tradeable\r\n        token.finishMinting();\r\n        token.makeTradable();\r\n    }\r\n    \r\n    /**\r\n    * Update the ETH price for the token sale\r\n    */\r\n    function updatePrice(uint256 _newPrice) public onlyOwner isPreSale {\r\n        tokensPerETH = _newPrice;\r\n        PriceUpdated(_newPrice);\r\n    }\r\n\r\n    /**\r\n    * Temp function for change start times for debuging\r\n     */\r\n    function updateStart(uint256 _newStart) public onlyOwner {\r\n        start = _newStart;\r\n    }\r\n    \r\n    /**\r\n    * The pre sale purchase of tokens. Is avaliable up until the soft cap is hit.\r\n     */\r\n    function purchaseTokensPreSale(address recipient) public isUnderSoftCap isPreSale payable {    \r\n        uint256 amount = msg.value;\r\n        uint256 tokens = tokensPerETH.mul(amount);\r\n\r\n        //Tokens purchased pre sale get an additional 25% CTN\r\n        tokens = tokens.add(tokens.div(4));\r\n     \r\n        //Add the amount to a users investment total\r\n        investments[msg.sender] = investments[msg.sender].add(msg.value);\r\n        \r\n        token.mint(recipient, tokens);\r\n        \r\n        TokenSold(recipient, amount, tokens, true, true);\r\n    }\r\n    \r\n    /**\r\n    * Allows user to buy coins if we are under the hardcap also adds a bonus if under the bonus amount\r\n    */\r\n    function purchaseTokens(address recipient) public isUnderHardCap isSaleOn payable {\r\n        uint256 amount = msg.value;\r\n        uint256 tokens = tokensPerETH.mul(amount);\r\n        bool bonus = false;\r\n        \r\n        if (token.totalSupply().sub(token.baseSupply()) < bonusCap) {          \r\n            bonus = true;\r\n\r\n            //Tokens purchased before the bonus cap get an additional 20% CTN\r\n            tokens = tokens.add(tokens.div(5));\r\n        }\r\n\r\n        //Add the amount to user investment total\r\n        investments[msg.sender] = investments[msg.sender].add(msg.value);\r\n        \r\n        token.mint(recipient, tokens);\r\n        \r\n        TokenSold(recipient, amount, tokens, false, bonus);\r\n    }\r\n    \r\n    /**\r\n     * Withdrawl the funds from the contract.\r\n     * Make the token tradeable and finish minting\r\n     */ \r\n    function cleanup() public isTwoMonthsLater {\r\n        vault.transfer(this.balance);\r\n        token.finishMinting();\r\n        token.makeTradable();\r\n    }\r\n    \r\n    function destroy() public onlyOwner isTwoMonthsLater {\r\n         token.finishMinting();\r\n         token.makeTradable();\r\n         token.transferOwnership(owner);\r\n         selfdestruct(vault);\r\n    }\r\n    \r\n    /**\r\n     * Get the ETH balance of this contract\r\n     */ \r\n    function getBalance() public constant returns (uint256 totalAmount) {\r\n          totalAmount = this.balance;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cleanup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"twoMonthsLater\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"purchaseTokensPreSale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"purchaseTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStart\",\"type\":\"uint256\"}],\"name\":\"updateStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ctnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"preSale\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"bonus\",\"type\":\"bool\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"}]","ContractName":"Sale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8727d2ce0e56aa049de4c1e77753d077daa74755a2a7cba4914ffa1dd73d29d4"}]}