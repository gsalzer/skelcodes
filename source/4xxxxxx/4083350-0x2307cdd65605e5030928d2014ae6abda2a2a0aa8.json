{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/// @title Splitter\r\n/// @author 0xcaff (Martin Charles)\r\n/// @notice An ethereum smart contract to split received funds between a number\r\n/// of outputs.\r\ncontract Splitter {\r\n    // Mapping between addresses and how much money they have withdrawn. This is\r\n    // used to calculate the balance of each account. The public keyword allows\r\n    // reading from the map but not writing to the map using the\r\n    // amountsWithdrew(address) method of the contract. It's public mainly for\r\n    // testing.\r\n    mapping(address => uint) public amountsWithdrew;\r\n\r\n    // A set of parties to split the funds between. They are initialized in the\r\n    // constructor.\r\n    mapping(address => bool) public between;\r\n\r\n    // The number of ways incoming funds will we split.\r\n    uint public count;\r\n\r\n    // The total amount of funds which has been deposited into the contract.\r\n    uint public totalInput;\r\n\r\n    // This is the constructor of the contract. It is called at deploy time.\r\n\r\n    /// @param addrs The address received funds will be split between.\r\n    function Splitter(address[] addrs) {\r\n        count = addrs.length;\r\n\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            // loop over addrs and update set of included accounts\r\n            address included = addrs[i];\r\n            between[included] = true;\r\n        }\r\n    }\r\n\r\n    // To save on transaction fees, it's beneficial to withdraw in one big\r\n    // transaction instead of many little ones. That's why a withdrawl flow is\r\n    // being used.\r\n\r\n    /// @notice Withdraws from the sender's share of funds and deposits into the\r\n    /// sender's account. If there are insufficient funds in the contract, or\r\n    /// more than the share is being withdrawn, throws, canceling the\r\n    /// transaction.\r\n    /// @param amount The amount of funds in wei to withdraw from the contract.\r\n    function withdraw(uint amount) {\r\n        Splitter.withdrawInternal(amount, false);\r\n    }\r\n\r\n    /// @notice Withdraws all funds available to the sender and deposits them\r\n    /// into the sender's account.\r\n    function withdrawAll() {\r\n        Splitter.withdrawInternal(0, true);\r\n    }\r\n\r\n    // Since `withdrawInternal` is internal, it isn't in the ABI and can't be\r\n    // called from outside of the contract.\r\n\r\n    /// @notice Checks whether the sender is allowed to withdraw and has\r\n    /// sufficient funds, then withdraws.\r\n    /// @param requested The amount of funds in wei to withdraw from the\r\n    /// contract. If the `all` parameter is true, the `amount` parameter is\r\n    /// ignored. If funds are insufficient, throws.\r\n    /// @param all If true, withdraws all funds the sender has access to from\r\n    /// this contract.\r\n    function withdrawInternal(uint requested, bool all) internal {\r\n        // Require the withdrawer to be included in `between` at contract\r\n        // creation time.\r\n        require(between[msg.sender]);\r\n\r\n        // Decide the amount to withdraw based on the `all` parameter.\r\n        uint available = Splitter.balance();\r\n        uint transferring = 0;\r\n\r\n        if (all) { transferring = available; }\r\n        else { available = requested; }\r\n\r\n        // Ensures the funds are available to make the transfer, otherwise\r\n        // throws.\r\n        require(transferring <= available);\r\n\r\n        // Updates the internal state, this is done before the transfer to\r\n        // prevent re-entrancy bugs.\r\n        amountsWithdrew[msg.sender] += transferring;\r\n\r\n        // Transfer funds from the contract to the sender. The gas for this\r\n        // transaction is paid for by msg.sender.\r\n        msg.sender.transfer(transferring);\r\n    }\r\n\r\n    // We do integer division (floor(a / b)) when calculating each share, because\r\n    // solidity doesn't have a decimal number type. This means there will be a\r\n    // maximum remainder of count - 1 wei locked in the contract. We ignore this\r\n    // because it is such a small amount of ethereum (1 Wei = 10^(-18)\r\n    // Ethereum). The extra Wei can be extracted by depositing an amount to make\r\n    // totalInput evenly divisable between count parties.\r\n\r\n    /// @notice Gets the amount of funds in Wei available to the sender.\r\n    function balance() constant returns (uint) {\r\n        if (!between[msg.sender]) {\r\n            // The sender of the message isn't part of the split. Ignore them.\r\n            return 0;\r\n        }\r\n\r\n        // `share` is the amount of funds which are available to each of the\r\n        // accounts specified in the constructor.\r\n        uint share = totalInput / count;\r\n        uint withdrew = amountsWithdrew[msg.sender];\r\n        uint available = share - withdrew;\r\n\r\n        assert(available >= 0 && available <= share);\r\n\r\n        return available;\r\n    }\r\n\r\n    // This function will be run when a transaction is sent to the contract\r\n    // without any data. It is minimal to save on gas costs.\r\n    function() payable {\r\n        totalInput += msg.value;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInput\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountsWithdrew\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"between\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"Splitter","CompilerVersion":"v0.4.13-nightly.2017.7.3+commit.6e4e627b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000888f49561552bccc319d74e5cca65e057b5633060000000000000000000000001360c4dc33b524cd7303df5e9e66d430c6e6290e","Library":"","SwarmSource":"bzzr://4e7b08e0bbc4208f1ff0851a385d92c99f73c44e4b416a7fdbfef36a5851cc64"}]}