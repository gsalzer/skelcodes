{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n/*\r\n    Copyright 2017, Arthur Lunn\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n/**\r\n * @title ERC20\r\n * @dev A standard interface for tokens.\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n  \r\n    /// @dev Returns the total token supply.\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @dev Returns the account balance of another account with address _owner.\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @dev Transfers _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Transfers _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Allows _spender to withdraw from your account multiple times, up to the _value amount\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner.\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n/// @title Owned\r\n/// @author Adrià Massanet <adria@codecontext.io>\r\n/// @notice The Owned contract has an owner address, and provides basic \r\n///  authorization control functions, this simplifies & the implementation of\r\n///  \"user permissions\"\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed by, address indexed to);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event OwnershipRemoved();\r\n\r\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner.\r\n    function changeOwnership(address _newOwner) onlyOwner {\r\n        require(_newOwner != 0x0);\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\r\n    ///  new owner\r\n    /// @param _newOwnerCandidate The address being proposed as the new owner\r\n    function proposeOwnership(address _newOwnerCandidate) onlyOwner {\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\r\n    ///  transfer of ownership\r\n    function acceptOwnership() {\r\n        require(msg.sender == newOwnerCandidate);\r\n\r\n        address oldOwner = owner;\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @notice Decentralizes the contract, this operation cannot be undone \r\n    /// @param _dece `0xdece` has to be entered for this function to work\r\n    function removeOwnership(address _dece) onlyOwner {\r\n        require(_dece == 0xdece);\r\n        owner = 0x0;\r\n        newOwnerCandidate = 0x0;\r\n        OwnershipRemoved();     \r\n    }\r\n\r\n} \r\n\r\n/// @dev `Escapable` is a base level contract built off of the `Owned`\r\n///  contract that creates an escape hatch function to send its ether to\r\n///  `escapeHatchDestination` when called by the `escapeHatchCaller` in the case that\r\n///  something unexpected happens\r\ncontract Escapable is Owned {\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n    mapping (address=>bool) private escapeBlacklist;\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\r\n    ///  `escapeHatchCaller`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot move\r\n    ///  funds out of `escapeHatchDestination`\r\n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) {\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    modifier onlyEscapeHatchCallerOrOwner {\r\n        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\r\n        _;\r\n    }\r\n\r\n    /// @notice The `blacklistEscapeTokens()` marks a token in a whitelist to be\r\n    ///   escaped. The proupose is to be done at construction time.\r\n    /// @param _token the be bloacklisted for escape\r\n    function blacklistEscapeToken(address _token) internal {\r\n        escapeBlacklist[_token] = true;\r\n        EscapeHatchBlackistedToken(_token);\r\n    }\r\n\r\n    function isTokenEscapable(address _token) constant public returns (bool) {\r\n        return !escapeBlacklist[_token];\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    /// @param _token to transfer, use 0x0 for ethers\r\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \r\n        require(escapeBlacklist[_token]==false);\r\n\r\n        uint256 balance;\r\n\r\n        if (_token == 0x0) {\r\n            balance = this.balance;\r\n            escapeHatchDestination.transfer(balance);\r\n            EscapeHatchCalled(_token, balance);\r\n            return;\r\n        }\r\n\r\n        ERC20 token = ERC20(_token);\r\n        balance = token.balanceOf(this);\r\n        token.transfer(escapeHatchDestination, balance);\r\n        EscapeHatchCalled(_token, balance);\r\n    }\r\n\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot\r\n    ///  move funds out of `escapeHatchDestination`\r\n    function changeEscapeCaller(address _newEscapeHatchCaller) onlyEscapeHatchCallerOrOwner {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n    }\r\n\r\n    event EscapeHatchBlackistedToken(address token);\r\n    event EscapeHatchCalled(address token, uint amount);\r\n}\r\n\r\n\r\n/// @dev This is an empty contract to declare `proxyPayment()` to comply with\r\n///  Giveth Campaigns so that tokens will be generated when donations are sent\r\ncontract Campaign {\r\n    /// @notice `proxyPayment()` allows the caller to send ether to the Campaign and\r\n    /// have the tokens created in an address of their choosing\r\n    /// @param _owner The address that will hold the newly created tokens\r\n    function proxyPayment(address _owner) payable returns(bool);\r\n}\r\n\r\n\r\n/// @title Fund Forwarder\r\n/// @authors Vojtech Simetka, Jordi Baylina, Dani Philia, Arthur Lunn (hardly)\r\n/// @notice This contract is used to forward funds to a Giveth Campaign \r\n///  with an escapeHatch.The fund value is sent directly to designated Campaign.\r\n///  The escapeHatch allows removal of any other tokens deposited by accident.\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    Contributor: Adrià Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/// @dev The main contract which forwards funds sent to contract.\r\ncontract FundForwarder is Escapable {\r\n    Campaign public beneficiary; // expected to be a Giveth campaign\r\n\r\n    /// @notice The Constructor assigns the `beneficiary`, the\r\n    ///  `escapeHatchDestination` and the `escapeHatchCaller` as well as deploys\r\n    ///  the contract to the blockchain (obviously)\r\n    /// @param _beneficiary The address of the CAMPAIGN CONTROLLER for the Campaign\r\n    ///  that is to receive donations\r\n    /// @param _escapeHatchDestination The address of a safe location (usually a\r\n    ///  Multisig) to send the ether held in this contract\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract\r\n    ///  to call `escapeHatch()` to send the ether in this contract to the \r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    function FundForwarder(\r\n            Campaign _beneficiary, // address that receives ether\r\n            address _escapeHatchCaller,\r\n            address _escapeHatchDestination\r\n        )\r\n        // Set the escape hatch to accept ether (0x0)\r\n        Escapable(_escapeHatchCaller, _escapeHatchDestination)\r\n    {\r\n        beneficiary = _beneficiary;\r\n    }\r\n\r\n    /// @notice Directly forward Eth to `beneficiary`. The `msg.sender` is rewarded with Campaign tokens.\r\n    ///  This contract may have a high gasLimit requirement dependent on beneficiary.\r\n    function () payable {\r\n        uint amount;\r\n        amount = msg.value;\r\n        // Send the ETH to the beneficiary so that they receive Campaign tokens\r\n        require (beneficiary.proxyPayment.value(amount)\r\n        (msg.sender)\r\n        );\r\n        FundsSent(msg.sender, amount);\r\n    }\r\n    event FundsSent(address indexed sender, uint amount);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dece\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenEscapable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EscapeHatchBlackistedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRemoved\",\"type\":\"event\"}]","ContractName":"FundForwarder","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f7e983781609012307f2514f63d526d83d24f466000000000000000000000000839395e20bbb182fa440d08f850e6c7a8f6f07800000000000000000000000008ff920020c8ad673661c8117f2855c384758c572","Library":"","SwarmSource":"bzzr://d9238d9fa960c609487cb259195ff582a20a5277a20e542fce8464e6c4f8a41e"}]}