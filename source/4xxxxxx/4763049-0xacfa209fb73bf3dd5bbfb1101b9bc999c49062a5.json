{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title VestedToken\r\n * @dev The VestedToken contract implements ERC20 standard basics function and \r\n * - vesting for an address\r\n * - token tradability delay\r\n */\r\ncontract VestedToken {\r\n    using SafeMath for uint256;\r\n    \r\n    // Vested wallet address\r\n    address public vestedAddress;\r\n    // Vesting time\r\n    uint private constant VESTING_DELAY = 1 years;  \r\n    // Token will be tradable TOKEN_TRADABLE_DELAY after \r\n    uint private constant TOKEN_TRADABLE_DELAY = 12 days;\r\n\r\n    // True if aside tokens have already been minted after second round\r\n    bool public asideTokensHaveBeenMinted = false;\r\n    // When aside tokens have been minted ?\r\n    uint public asideTokensMintDate;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    \r\n    modifier transferAllowed { require(asideTokensHaveBeenMinted && now > asideTokensMintDate + TOKEN_TRADABLE_DELAY); _; }\r\n    \r\n    // Get the balance from an address\r\n    function balanceOf(address _owner) public constant returns (uint256) { return balances[_owner]; }  \r\n\r\n    // transfer ERC20 function\r\n    function transfer(address _to, uint256 _value) transferAllowed public returns (bool success) {\r\n        require(_to != 0x0);\r\n        \r\n        // founders wallets is blocked 1 year\r\n        if (msg.sender == vestedAddress && (now < (asideTokensMintDate + VESTING_DELAY))) { revert(); }\r\n\r\n        return privateTransfer(_to, _value);\r\n    }\r\n\r\n    // transferFrom ERC20 function\r\n    function transferFrom(address _from, address _to, uint256 _value) transferAllowed public returns (bool success) {\r\n        require(_from != 0x0);\r\n        require(_to != 0x0);\r\n        \r\n        // founders wallet is blocked 1 year\r\n        if (_from == vestedAddress && (now < (asideTokensMintDate + VESTING_DELAY))) { revert(); }\r\n\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // approve ERC20 function\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // allowance ERC20 function\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function privateTransfer (address _to, uint256 _value) private returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    // Events ERC20\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * @title WhitelistsRegistration\r\n * @dev This is an extension to add 2 levels whitelists to the crowdsale\r\n */\r\ncontract WhitelistsRegistration is Ownable {\r\n    // List of whitelisted addresses for KYC under 10 ETH\r\n    mapping(address => bool) silverWhiteList;\r\n    \r\n    // List of whitelisted addresses for KYC over 10 ETH\r\n    mapping(address => bool) goldWhiteList;\r\n    \r\n    // Different stage from the ICO\r\n    enum WhiteListState {\r\n        // This address is not whitelisted\r\n        None,\r\n        // this address is on the silver whitelist\r\n        Silver,\r\n        // this address is on the gold whitelist\r\n        Gold\r\n    }\r\n    \r\n    address public whiteLister;\r\n\r\n    event SilverWhitelist(address indexed _address, bool _isRegistered);\r\n    event GoldWhitelist(address indexed _address, bool _isRegistered);  \r\n    event SetWhitelister(address indexed newWhiteLister);\r\n    \r\n    /**\r\n    * @dev Throws if called by any account other than the owner or the whitelister.\r\n    */\r\n    modifier onlyOwnerOrWhiteLister() {\r\n        require((msg.sender == owner) || (msg.sender == whiteLister));\r\n    _;\r\n    }\r\n    \r\n    // Return registration status of an specified address\r\n    function checkRegistrationStatus(address _address) public constant returns (WhiteListState) {\r\n        if (goldWhiteList[_address]) { return WhiteListState.Gold; }\r\n        if (silverWhiteList[_address]) { return WhiteListState.Silver; }\r\n        return WhiteListState.None;\r\n    }\r\n    \r\n    // Change registration status for an address in the whitelist for KYC under 10 ETH\r\n    function changeRegistrationStatusForSilverWhiteList(address _address, bool _isRegistered) public onlyOwnerOrWhiteLister {\r\n        silverWhiteList[_address] = _isRegistered;\r\n        SilverWhitelist(_address, _isRegistered);\r\n    }\r\n    \r\n    // Change registration status for an address in the whitelist for KYC over 10 ETH\r\n    function changeRegistrationStatusForGoldWhiteList(address _address, bool _isRegistered) public onlyOwnerOrWhiteLister {\r\n        goldWhiteList[_address] = _isRegistered;\r\n        GoldWhitelist(_address, _isRegistered);\r\n    }\r\n    \r\n    // Change registration status for several addresses in the whitelist for KYC under 10 ETH\r\n    function massChangeRegistrationStatusForSilverWhiteList(address[] _targets, bool _isRegistered) public onlyOwnerOrWhiteLister {\r\n        for (uint i = 0; i < _targets.length; i++) {\r\n            changeRegistrationStatusForSilverWhiteList(_targets[i], _isRegistered);\r\n        }\r\n    } \r\n    \r\n    // Change registration status for several addresses in the whitelist for KYC over 10 ETH\r\n    function massChangeRegistrationStatusForGoldWhiteList(address[] _targets, bool _isRegistered) public onlyOwnerOrWhiteLister {\r\n        for (uint i = 0; i < _targets.length; i++) {\r\n            changeRegistrationStatusForGoldWhiteList(_targets[i], _isRegistered);\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Allows the current owner or whiteLister to transfer control of the whitelist to a newWhitelister.\r\n    * @param _newWhiteLister The address to transfer whitelist to.\r\n    */\r\n    function setWhitelister(address _newWhiteLister) public onlyOwnerOrWhiteLister {\r\n      require(_newWhiteLister != address(0));\r\n      SetWhitelister(_newWhiteLister);\r\n      whiteLister = _newWhiteLister;\r\n    }\r\n}\r\n\r\n/**\r\n * @title BCDToken\r\n * @dev The BCDT crowdsale\r\n */\r\ncontract BCDToken is VestedToken, WhitelistsRegistration {\r\n    \r\n    string public constant name = \"Blockchain Certified Data Token\";\r\n    string public constant symbol = \"BCDT\";\r\n    uint public constant decimals = 18;\r\n\r\n    // Maximum contribution in ETH for silver whitelist \r\n    uint private constant MAX_ETHER_FOR_SILVER_WHITELIST = 10 ether;\r\n    \r\n    // ETH/BCDT rate\r\n    uint public rateETH_BCDT = 13000;\r\n\r\n    // Soft cap, if not reached contributors can withdraw their ethers\r\n    uint public softCap = 1800 ether;\r\n\r\n    // Cap in ether of presale\r\n    uint public presaleCap = 1800 ether;\r\n    \r\n    // Cap in ether of Round 1 (presale cap + 1800 ETH)\r\n    uint public round1Cap = 3600 ether;    \r\n    \r\n    // BCD Reserve/Community Wallets\r\n    address public reserveAddress;\r\n    address public communityAddress;\r\n\r\n    // Different stage from the ICO\r\n    enum State {\r\n        // ICO isn't started yet, initial state\r\n        Init,\r\n        // Presale has started\r\n        PresaleRunning,\r\n        // Presale has ended\r\n        PresaleFinished,\r\n        // Round 1 has started\r\n        Round1Running,\r\n        // Round 1 has ended\r\n        Round1Finished,\r\n        // Round 2 has started\r\n        Round2Running,\r\n        // Round 2 has ended\r\n        Round2Finished\r\n    }\r\n    \r\n    // Initial state is Init\r\n    State public currentState = State.Init;\r\n    \r\n    // BCDT total supply\r\n    uint256 public totalSupply = MAX_TOTAL_BCDT_TO_SELL;\r\n\r\n    // How much tokens have been sold\r\n    uint256 public tokensSold;\r\n    \r\n    // Amount of ETH raised during ICO\r\n    uint256 private etherRaisedDuringICO;\r\n    \r\n    // Maximum total of BCDT Token sold during ITS\r\n    uint private constant MAX_TOTAL_BCDT_TO_SELL = 100000000 * 1 ether;\r\n\r\n    // Token allocation per mille for reserve/community/founders\r\n    uint private constant RESERVE_ALLOCATION_PER_MILLE_RATIO =  200;\r\n    uint private constant COMMUNITY_ALLOCATION_PER_MILLE_RATIO =  103;\r\n    uint private constant FOUNDERS_ALLOCATION_PER_MILLE_RATIO =  30;\r\n    \r\n    // List of contributors/contribution in ETH\r\n    mapping(address => uint256) contributors;\r\n\r\n    // Use to allow function call only if currentState is the one specified\r\n    modifier inStateInit()\r\n    {\r\n        require(currentState == State.Init); \r\n        _; \r\n    }\r\n\t\r\n    modifier inStateRound2Finished()\r\n    {\r\n        require(currentState == State.Round2Finished); \r\n        _; \r\n    }\r\n    \r\n    // Event call when aside tokens are minted\r\n    event AsideTokensHaveBeenAllocated(address indexed to, uint256 amount);\r\n    // Event call when a contributor withdraw his ethers\r\n    event Withdraw(address indexed to, uint256 amount);\r\n    // Event call when ICO state change\r\n    event StateChanged(uint256 timestamp, State currentState);\r\n\r\n    // Constructor\r\n    function BCDToken() public {\r\n    }\r\n\r\n    function() public payable {\r\n        require(currentState == State.PresaleRunning || currentState == State.Round1Running || currentState == State.Round2Running);\r\n\r\n        // min transaction is 0.1 ETH\r\n        if (msg.value < 100 finney) { revert(); }\r\n\r\n        // If you're not in any whitelist, you cannot continue\r\n        if (!silverWhiteList[msg.sender] && !goldWhiteList[msg.sender]) {\r\n            revert();\r\n        }\r\n\r\n        // ETH sent by contributor\r\n        uint256 ethSent = msg.value;\r\n        \r\n        // how much ETH will be used for contribution\r\n        uint256 ethToUse = ethSent;\r\n\r\n        // Address is only in the silver whitelist: contribution is capped\r\n        if (!goldWhiteList[msg.sender]) {\r\n            // Check if address has already contributed for maximum allowance\r\n            if (contributors[msg.sender] >= MAX_ETHER_FOR_SILVER_WHITELIST) {\r\n                revert();\r\n            }\r\n            // limit the total contribution to MAX_ETHER_FOR_SILVER_WHITELIST\r\n            if (contributors[msg.sender].add(ethToUse) > MAX_ETHER_FOR_SILVER_WHITELIST) {\r\n                ethToUse = MAX_ETHER_FOR_SILVER_WHITELIST.sub(contributors[msg.sender]);\r\n            }\r\n        }\r\n        \r\n         // Calculate how much ETH are available for this stage\r\n        uint256 ethAvailable = getRemainingEthersForCurrentRound();\r\n        uint rate = getBCDTRateForCurrentRound();\r\n\r\n        // If cap of the round has been reached\r\n        if (ethAvailable <= ethToUse) {\r\n            // End the round\r\n            privateSetState(getEndedStateForCurrentRound());\r\n            // Only available ethers will be used to reach the cap\r\n            ethToUse = ethAvailable;\r\n        }\r\n        \r\n        // Calculate token amount to send in accordance to rate\r\n        uint256 tokenToSend = ethToUse.mul(rate);\r\n        \r\n        // Amount of tokens sold to the current contributors is added to total sold\r\n        tokensSold = tokensSold.add(tokenToSend);\r\n        // Amount of ethers used for the current contribution is added the total raised\r\n        etherRaisedDuringICO = etherRaisedDuringICO.add(ethToUse);\r\n        // Token balance updated for current contributor\r\n        balances[msg.sender] = balances[msg.sender].add(tokenToSend);\r\n        // Contribution is stored for an potential withdraw\r\n        contributors[msg.sender] = contributors[msg.sender].add(ethToUse);\r\n        \r\n        // Send back the unused ethers        \r\n        if (ethToUse < ethSent) {\r\n            msg.sender.transfer(ethSent.sub(ethToUse));\r\n        }\r\n        // Log token transfer operation\r\n        Transfer(0x0, msg.sender, tokenToSend); \r\n    }\r\n\r\n    // Allow contributors to withdraw after the end of the ICO if the softcap hasn't been reached\r\n    function withdraw() public inStateRound2Finished {\r\n        // Only contributors with positive ETH balance could Withdraw\r\n        if(contributors[msg.sender] == 0) { revert(); }\r\n        \r\n        // Withdraw is possible only if softcap has not been reached\r\n        require(etherRaisedDuringICO < softCap);\r\n        \r\n        // Get how much ethers sender has contribute\r\n        uint256 ethToSendBack = contributors[msg.sender];\r\n        \r\n        // Set contribution to 0 for the contributor\r\n        contributors[msg.sender] = 0;\r\n        \r\n        // Send back ethers\r\n        msg.sender.transfer(ethToSendBack);\r\n        \r\n        // Log withdraw operation\r\n        Withdraw(msg.sender, ethToSendBack);\r\n    }\r\n\r\n    // At the end of the sale, mint the aside tokens for the reserve, community and founders\r\n    function mintAsideTokens() public onlyOwner inStateRound2Finished {\r\n\r\n        // Reserve, community and founders address have to be set before mint aside tokens\r\n        require((reserveAddress != 0x0) && (communityAddress != 0x0) && (vestedAddress != 0x0));\r\n\r\n        // Aside tokens can be minted only if softcap is reached\r\n        require(this.balance >= softCap);\r\n\r\n        // Revert if aside tokens have already been minted \r\n        if (asideTokensHaveBeenMinted) { revert(); }\r\n\r\n        // Set minted flag and date\r\n        asideTokensHaveBeenMinted = true;\r\n        asideTokensMintDate = now;\r\n\r\n        // If 100M sold, 50M more have to be mint (15 / 10 = * 1.5 = +50%)\r\n        totalSupply = tokensSold.mul(15).div(10);\r\n\r\n        // 20% of total supply is allocated to reserve\r\n        uint256 _amountMinted = setAllocation(reserveAddress, RESERVE_ALLOCATION_PER_MILLE_RATIO);\r\n\r\n        // 10.3% of total supply is allocated to community\r\n        _amountMinted = _amountMinted.add(setAllocation(communityAddress, COMMUNITY_ALLOCATION_PER_MILLE_RATIO));\r\n\r\n        // 3% of total supply is allocated to founders\r\n        _amountMinted = _amountMinted.add(setAllocation(vestedAddress, FOUNDERS_ALLOCATION_PER_MILLE_RATIO));\r\n        \r\n        // the allocation is only 33.3%*150/100 = 49.95% of the token solds. It is therefore slightly higher than it should.\r\n        // to avoid that, we correct the real total number of tokens\r\n        totalSupply = tokensSold.add(_amountMinted);\r\n        // Send the eth to the owner of the contract\r\n        owner.transfer(this.balance);\r\n    }\r\n    \r\n    function setTokenAsideAddresses(address _reserveAddress, address _communityAddress, address _founderAddress) public onlyOwner {\r\n        require(_reserveAddress != 0x0 && _communityAddress != 0x0 && _founderAddress != 0x0);\r\n\r\n        // Revert when aside tokens have already been minted \r\n        if (asideTokensHaveBeenMinted) { revert(); }\r\n\r\n        reserveAddress = _reserveAddress;\r\n        communityAddress = _communityAddress;\r\n        vestedAddress = _founderAddress;\r\n    }\r\n    \r\n    function updateCapsAndRate(uint _presaleCapInETH, uint _round1CapInETH, uint _softCapInETH, uint _rateETH_BCDT) public onlyOwner inStateInit {\r\n            \r\n        // Caps and rate are updatable until ICO starts\r\n        require(_round1CapInETH > _presaleCapInETH);\r\n        require(_rateETH_BCDT != 0);\r\n        \r\n        presaleCap = _presaleCapInETH * 1 ether;\r\n        round1Cap = _round1CapInETH * 1 ether;\r\n        softCap = _softCapInETH * 1 ether;\r\n        rateETH_BCDT = _rateETH_BCDT;\r\n    }\r\n    \r\n    function getRemainingEthersForCurrentRound() public constant returns (uint) {\r\n        require(currentState != State.Init); \r\n        require(!asideTokensHaveBeenMinted);\r\n        \r\n        if((currentState == State.PresaleRunning) || (currentState == State.PresaleFinished)) {\r\n            // Presale cap is fixed in ETH\r\n            return presaleCap.sub(etherRaisedDuringICO);\r\n        }\r\n        if((currentState == State.Round1Running) || (currentState == State.Round1Finished)) {\r\n            // Round 1 cap is fixed in ETH\r\n            return round1Cap.sub(etherRaisedDuringICO);\r\n        }\r\n        if((currentState == State.Round2Running) || (currentState == State.Round2Finished)) {\r\n            // Round 2 cap is limited in tokens, \r\n            uint256 remainingTokens = totalSupply.sub(tokensSold);\r\n            // ETH available is calculated from the number of remaining tokens regarding the rate\r\n            return remainingTokens.div(rateETH_BCDT);\r\n        }        \r\n    }   \r\n\r\n    function getBCDTRateForCurrentRound() public constant returns (uint) {\r\n        require(currentState == State.PresaleRunning || currentState == State.Round1Running || currentState == State.Round2Running);              \r\n        \r\n        // ETH/BCDT rate during presale: 20% bonus\r\n        if(currentState == State.PresaleRunning) {\r\n            return rateETH_BCDT + rateETH_BCDT * 20 / 100;\r\n        }\r\n        // ETH/BCDT rate during presale: 10% bonus\r\n        if(currentState == State.Round1Running) {\r\n            return rateETH_BCDT + rateETH_BCDT * 10 / 100;\r\n        }\r\n        if(currentState == State.Round2Running) {\r\n            return rateETH_BCDT;\r\n        }        \r\n    }  \r\n\r\n    function setState(State _newState) public onlyOwner {\r\n        privateSetState(_newState);\r\n    }\r\n    \r\n    function privateSetState(State _newState) private {\r\n        // no way to go back    \r\n        if(_newState <= currentState) { revert(); }\r\n        \r\n        currentState = _newState;\r\n        StateChanged(now, currentState);\r\n    }\r\n    \r\n    \r\n    function getEndedStateForCurrentRound() private constant returns (State) {\r\n        require(currentState == State.PresaleRunning || currentState == State.Round1Running || currentState == State.Round2Running);\r\n        \r\n        if(currentState == State.PresaleRunning) {\r\n            return State.PresaleFinished;\r\n        }\r\n        if(currentState == State.Round1Running) {\r\n            return State.Round1Finished;\r\n        }\r\n        if(currentState == State.Round2Running) {\r\n            return State.Round2Finished;\r\n        }        \r\n    }   \r\n\r\n    function setAllocation(address _to, uint _ratio) private onlyOwner returns (uint256) {\r\n        // Aside token is a percentage of totalSupply\r\n        uint256 tokenAmountToTransfert = totalSupply.mul(_ratio).div(1000);\r\n        balances[_to] = balances[_to].add(tokenAmountToTransfert);\r\n        AsideTokensHaveBeenAllocated(_to, tokenAmountToTransfert);\r\n        Transfer(0x0, _to, tokenAmountToTransfert);\r\n        return tokenAmountToTransfert;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintAsideTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingEthersForCurrentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateETH_BCDT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleCapInETH\",\"type\":\"uint256\"},{\"name\":\"_round1CapInETH\",\"type\":\"uint256\"},{\"name\":\"_softCapInETH\",\"type\":\"uint256\"},{\"name\":\"_rateETH_BCDT\",\"type\":\"uint256\"}],\"name\":\"updateCapsAndRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newState\",\"type\":\"uint8\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkRegistrationStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asideTokensHaveBeenMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveAddress\",\"type\":\"address\"},{\"name\":\"_communityAddress\",\"type\":\"address\"},{\"name\":\"_founderAddress\",\"type\":\"address\"}],\"name\":\"setTokenAsideAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asideTokensMintDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_isRegistered\",\"type\":\"bool\"}],\"name\":\"changeRegistrationStatusForGoldWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targets\",\"type\":\"address[]\"},{\"name\":\"_isRegistered\",\"type\":\"bool\"}],\"name\":\"massChangeRegistrationStatusForGoldWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round1Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestedAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteLister\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targets\",\"type\":\"address[]\"},{\"name\":\"_isRegistered\",\"type\":\"bool\"}],\"name\":\"massChangeRegistrationStatusForSilverWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_isRegistered\",\"type\":\"bool\"}],\"name\":\"changeRegistrationStatusForSilverWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWhiteLister\",\"type\":\"address\"}],\"name\":\"setWhitelister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBCDTRateForCurrentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AsideTokensHaveBeenAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentState\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_isRegistered\",\"type\":\"bool\"}],\"name\":\"SilverWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_isRegistered\",\"type\":\"bool\"}],\"name\":\"GoldWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newWhiteLister\",\"type\":\"address\"}],\"name\":\"SetWhitelister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BCDToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6084ab8464bccc3e3b2a5a94680df1aa89bb0c7328342ab3a10f136df3b92dff"}]}