{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\nlibrary ECVerify {\r\n\r\n    function ecverify(bytes32 hash, bytes signature) internal pure returns (address signature_address) {\r\n        require(signature.length == 65);\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n\r\n            // Here we are loading the last 32 bytes, including 31 bytes of 's'.\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n\r\n        signature_address = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(signature_address != 0x0);\r\n\r\n        return signature_address;\r\n    }\r\n}\r\n\r\n/// @title Base Token contract - Functions to be implemented by token contracts.\r\ncontract Token {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    /*\r\n     * This is a slight change to the ERC20 base standard.\r\n     * function totalSupply() constant returns (uint256 supply);\r\n     * is replaced with:\r\n     * uint256 public totalSupply;\r\n     * This automatically creates a getter function for the totalSupply.\r\n     * This is moved to the base contract since public getter functions are not\r\n     * currently recognised as an implementation of the matching abstract\r\n     * function by the compiler.\r\n     */\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n     * NOTE:\r\n     * The following variables were optional. Now, they are included in ERC 223 interface.\r\n     * They allow one to customise the token contract & in no way influences the core functionality.\r\n     */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n\r\n\r\n    /// @param _owner The address from which the balance will be retrieved.\r\n    /// @return The balance.\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The amount of token to be transferred.\r\n    /// @param _data Data to be sent to `tokenFallback.\r\n    /// @return Returns success of function call.\r\n    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The amount of token to be transferred.\r\n    /// @return Whether the transfer was successful or not.\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`.\r\n    /// @param _from The address of the sender.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The amount of token to be transferred.\r\n    /// @return Whether the transfer was successful or not.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens.\r\n    /// @param _spender The address of the account able to transfer the tokens.\r\n    /// @param _value The amount of tokens to be approved for transfer.\r\n    /// @return Whether the approval was successful or not.\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens.\r\n    /// @param _spender The address of the account able to transfer the tokens.\r\n    /// @return Amount of remaining tokens allowed to spent.\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    /*\r\n     * Events\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n}\r\n\r\n\r\n/// @title Raiden MicroTransfer Channels Contract.\r\ncontract RaidenMicroTransferChannels {\r\n\r\n    /*\r\n     *  Data structures\r\n     */\r\n\r\n    // The only role of the owner_address is to add or remove trusted contracts\r\n    address public owner_address;\r\n\r\n    // Number of blocks to wait from an uncooperativeClose initiated by the sender\r\n    // in order to give the receiver a chance to respond with a balance proof\r\n    // in case the sender cheats. After the challenge period, the sender can settle\r\n    // and delete the channel.\r\n    uint32 public challenge_period;\r\n\r\n    // Contract semantic version\r\n    string public constant version = '0.2.0';\r\n\r\n    // We temporarily limit total token deposits in a channel to 100 tokens with 18 decimals.\r\n    // This was calculated just for RDN with its current (as of 30/11/2017) price and should\r\n    // not be considered to be the same for other tokens.\r\n    // This is just for the bug bounty release, as a safety measure.\r\n    uint256 public constant channel_deposit_bugbounty_limit = 10 ** 18 * 100;\r\n\r\n    Token public token;\r\n\r\n    mapping (bytes32 => Channel) public channels;\r\n    mapping (bytes32 => ClosingRequest) public closing_requests;\r\n    mapping (address => bool) public trusted_contracts;\r\n    mapping (bytes32 => uint192) public withdrawn_balances;\r\n\r\n    // 24 bytes (deposit) + 4 bytes (block number)\r\n    struct Channel {\r\n        // uint192 is the maximum uint size needed for deposit based on a\r\n        // 10^8 * 10^18 token totalSupply.\r\n        uint192 deposit;\r\n\r\n        // Block number at which the channel was opened. Used in creating\r\n        // a unique identifier for the channel between a sender and receiver.\r\n        // Supports creation of multiple channels between the 2 parties and prevents\r\n        // replay of messages in later channels.\r\n        uint32 open_block_number;\r\n    }\r\n\r\n    // 24 bytes (deposit) + 4 bytes (block number)\r\n    struct ClosingRequest {\r\n        // Number of tokens owed by the sender when closing the channel.\r\n        uint192 closing_balance;\r\n\r\n        // Block number at which the challenge period ends, in case it has been initiated.\r\n        uint32 settle_block_number;\r\n    }\r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n\r\n    modifier isOwner() {\r\n        require(msg.sender == owner_address);\r\n        _;\r\n    }\r\n\r\n    modifier isTrustedContract() {\r\n        require(trusted_contracts[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n\r\n    event ChannelCreated(\r\n        address indexed _sender_address,\r\n        address indexed _receiver_address,\r\n        uint192 _deposit);\r\n    event ChannelToppedUp (\r\n        address indexed _sender_address,\r\n        address indexed _receiver_address,\r\n        uint32 indexed _open_block_number,\r\n        uint192 _added_deposit);\r\n    event ChannelCloseRequested(\r\n        address indexed _sender_address,\r\n        address indexed _receiver_address,\r\n        uint32 indexed _open_block_number,\r\n        uint192 _balance);\r\n    event ChannelSettled(\r\n        address indexed _sender_address,\r\n        address indexed _receiver_address,\r\n        uint32 indexed _open_block_number,\r\n        uint192 _balance,\r\n        uint192 _receiver_tokens);\r\n    event ChannelWithdraw(\r\n        address indexed _sender_address,\r\n        address indexed _receiver_address,\r\n        uint32 indexed _open_block_number,\r\n        uint192 _withdrawn_balance);\r\n    event TrustedContract(\r\n        address indexed _trusted_contract_address,\r\n        bool _trusted_status);\r\n\r\n\r\n    /*\r\n     *  Constructor\r\n     */\r\n\r\n    /// @notice Constructor for creating the uRaiden microtransfer channels contract.\r\n    /// @param _token_address The address of the Token used by the uRaiden contract.\r\n    /// @param _challenge_period A fixed number of blocks representing the challenge period.\r\n    /// We enforce a minimum of 500 blocks waiting period.\r\n    /// after a sender requests the closing of the channel without the receiver's signature.\r\n    /// @param _trusted_contracts Array of contract addresses that can be trusted to\r\n    /// open and top up channels on behalf of a sender.\r\n    function RaidenMicroTransferChannels(\r\n        address _token_address,\r\n        uint32 _challenge_period,\r\n        address[] _trusted_contracts)\r\n        public\r\n    {\r\n        require(_token_address != 0x0);\r\n        require(addressHasCode(_token_address));\r\n        require(_challenge_period >= 500);\r\n\r\n        token = Token(_token_address);\r\n\r\n        // Check if the contract is indeed a token contract\r\n        require(token.totalSupply() > 0);\r\n\r\n        challenge_period = _challenge_period;\r\n        owner_address = msg.sender;\r\n        addTrustedContracts(_trusted_contracts);\r\n    }\r\n\r\n    /*\r\n     *  External functions\r\n     */\r\n\r\n    /// @notice Opens a new channel or tops up an existing one, compatibility with ERC 223.\r\n    /// @dev Can only be called from the trusted Token contract.\r\n    /// @param _sender_address The address that sent the tokens to this contract.\r\n    /// @param _deposit The amount of tokens that the sender escrows.\r\n    /// @param _data Data needed for either creating a channel or topping it up.\r\n    /// It always contains the sender and receiver addresses +/- a block number.\r\n    function tokenFallback(address _sender_address, uint256 _deposit, bytes _data) external {\r\n        // Make sure we trust the token\r\n        require(msg.sender == address(token));\r\n\r\n        uint192 deposit = uint192(_deposit);\r\n        require(deposit == _deposit);\r\n\r\n        // Create channel - sender address + receiver address = 2 * 20 bytes\r\n        // Top up channel - sender address + receiver address + block number = 2 * 20 + 4 bytes\r\n        uint length = _data.length;\r\n        require(length == 40 || length == 44);\r\n\r\n        // Offset of 32 bytes, representing _data.length\r\n        address channel_sender_address = address(addressFromBytes(_data, 0x20));\r\n\r\n        // The channel can be opened by the sender or by a trusted contract\r\n        require(_sender_address == channel_sender_address || trusted_contracts[_sender_address]);\r\n\r\n        // Offset of 32 bytes (data.length) + 20 bytes (sender address)\r\n        address channel_receiver_address = address(addressFromBytes(_data, 0x34));\r\n\r\n        if (length == 40) {\r\n            createChannelPrivate(channel_sender_address, channel_receiver_address, deposit);\r\n        } else {\r\n            // Offset of: 32 bytes (_data.length) + 20 bytes (sender address)\r\n            // + 20 bytes (receiver address)\r\n            uint32 open_block_number = uint32(blockNumberFromBytes(_data, 0x48));\r\n            updateInternalBalanceStructs(\r\n                channel_sender_address,\r\n                channel_receiver_address,\r\n                open_block_number,\r\n                deposit\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Creates a new channel between `msg.sender` and `_receiver_address` and transfers\r\n    /// the `_deposit` token deposit to this contract. Compatibility with ERC20 tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _deposit The amount of tokens that the sender escrows.\r\n    function createChannel(address _receiver_address, uint192 _deposit) external {\r\n        createChannelPrivate(msg.sender, _receiver_address, _deposit);\r\n\r\n        // transferFrom deposit from msg.sender to contract\r\n        // ! needs prior approval from msg.sender\r\n        require(token.transferFrom(msg.sender, address(this), _deposit));\r\n    }\r\n\r\n    /// @notice Function that allows a delegate contract to create a new channel between\r\n    /// `_sender_address` and `_receiver_address` and transfers the token deposit to this contract.\r\n    /// Can only be called by a trusted contract. Compatibility with ERC20 tokens.\r\n    /// @param _sender_address The sender's address in behalf of whom the delegate sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _deposit The amount of tokens that the sender escrows.\r\n    function createChannelDelegate(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint192 _deposit)\r\n        isTrustedContract\r\n        external\r\n    {\r\n        createChannelPrivate(_sender_address, _receiver_address, _deposit);\r\n\r\n        // transferFrom deposit from msg.sender to contract\r\n        // ! needs prior approval from msg.sender\r\n        require(token.transferFrom(msg.sender, address(this), _deposit));\r\n    }\r\n\r\n    /// @notice Increase the channel deposit with `_added_deposit`.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _added_deposit The added token deposit with which the current deposit is increased.\r\n    function topUp(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _added_deposit)\r\n        external\r\n    {\r\n        updateInternalBalanceStructs(\r\n            msg.sender,\r\n            _receiver_address,\r\n            _open_block_number,\r\n            _added_deposit\r\n        );\r\n\r\n        // transferFrom deposit from msg.sender to contract\r\n        // ! needs prior approval from msg.sender\r\n        // Do transfer after any state change\r\n        require(token.transferFrom(msg.sender, address(this), _added_deposit));\r\n    }\r\n\r\n    /// @notice Function that allows a delegate contract to increase the channel deposit\r\n    /// with `_added_deposit`. Can only be called by a trusted contract. Compatibility with ERC20 tokens.\r\n    /// @param _sender_address The sender's address in behalf of whom the delegate sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _added_deposit The added token deposit with which the current deposit is increased.\r\n    function topUpDelegate(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _added_deposit)\r\n        isTrustedContract\r\n        external\r\n    {\r\n        updateInternalBalanceStructs(\r\n            _sender_address,\r\n            _receiver_address,\r\n            _open_block_number,\r\n            _added_deposit\r\n        );\r\n\r\n        // transferFrom deposit from msg.sender to contract\r\n        // ! needs prior approval from the trusted contract\r\n        // Do transfer after any state change\r\n        require(token.transferFrom(msg.sender, address(this), _added_deposit));\r\n    }\r\n\r\n    /// @notice Allows channel receiver to withdraw tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance Partial or total amount of tokens owed by the sender to the receiver.\r\n    /// Has to be smaller or equal to the channel deposit. Has to match the balance value from\r\n    /// `_balance_msg_sig` - the balance message signed by the sender.\r\n    /// Has to be smaller or equal to the channel deposit.\r\n    /// @param _balance_msg_sig The balance message signed by the sender.\r\n    function withdraw(\r\n        uint32 _open_block_number,\r\n        uint192 _balance,\r\n        bytes _balance_msg_sig)\r\n        external\r\n    {\r\n        require(_balance > 0);\r\n\r\n        // Derive sender address from signed balance proof\r\n        address sender_address = extractBalanceProofSignature(\r\n            msg.sender,\r\n            _open_block_number,\r\n            _balance,\r\n            _balance_msg_sig\r\n        );\r\n\r\n        bytes32 key = getKey(sender_address, msg.sender, _open_block_number);\r\n\r\n        // Make sure the channel exists\r\n        require(channels[key].open_block_number > 0);\r\n\r\n        // Make sure the channel is not in the challenge period\r\n        require(closing_requests[key].settle_block_number == 0);\r\n\r\n        require(_balance <= channels[key].deposit);\r\n        require(withdrawn_balances[key] < _balance);\r\n\r\n        uint192 remaining_balance = _balance - withdrawn_balances[key];\r\n        withdrawn_balances[key] = _balance;\r\n\r\n        // Send the remaining balance to the receiver\r\n        require(token.transfer(msg.sender, remaining_balance));\r\n\r\n        ChannelWithdraw(sender_address, msg.sender, _open_block_number, remaining_balance);\r\n    }\r\n\r\n    /// @notice Function called by the sender, receiver or a delegate, with all the needed\r\n    /// signatures to close the channel and settle immediately.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    /// @param _balance_msg_sig The balance message signed by the sender.\r\n    /// @param _closing_sig The receiver's signed balance message, containing the sender's address.\r\n    function cooperativeClose(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance,\r\n        bytes _balance_msg_sig,\r\n        bytes _closing_sig)\r\n        external\r\n    {\r\n        // Derive sender address from signed balance proof\r\n        address sender = extractBalanceProofSignature(\r\n            _receiver_address,\r\n            _open_block_number,\r\n            _balance,\r\n            _balance_msg_sig\r\n        );\r\n\r\n        // Derive receiver address from closing signature\r\n        address receiver = extractClosingSignature(\r\n            sender,\r\n            _open_block_number,\r\n            _balance,\r\n            _closing_sig\r\n        );\r\n        require(receiver == _receiver_address);\r\n\r\n        // Both signatures have been verified and the channel can be settled.\r\n        settleChannel(sender, receiver, _open_block_number, _balance);\r\n    }\r\n\r\n    /// @notice Sender requests the closing of the channel and starts the challenge period.\r\n    /// This can only happen once.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between\r\n    /// the sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    function uncooperativeClose(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance)\r\n        external\r\n    {\r\n        bytes32 key = getKey(msg.sender, _receiver_address, _open_block_number);\r\n\r\n        require(channels[key].open_block_number > 0);\r\n        require(closing_requests[key].settle_block_number == 0);\r\n        require(_balance <= channels[key].deposit);\r\n\r\n        // Mark channel as closed\r\n        closing_requests[key].settle_block_number = uint32(block.number) + challenge_period;\r\n        require(closing_requests[key].settle_block_number > block.number);\r\n        closing_requests[key].closing_balance = _balance;\r\n        ChannelCloseRequested(msg.sender, _receiver_address, _open_block_number, _balance);\r\n    }\r\n\r\n\r\n    /// @notice Function called by the sender after the challenge period has ended, in order to\r\n    /// settle and delete the channel, in case the receiver has not closed the channel himself.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between\r\n    /// the sender and receiver was created.\r\n    function settle(address _receiver_address, uint32 _open_block_number) external {\r\n        bytes32 key = getKey(msg.sender, _receiver_address, _open_block_number);\r\n\r\n        // Make sure an uncooperativeClose has been initiated\r\n        require(closing_requests[key].settle_block_number > 0);\r\n\r\n        // Make sure the challenge_period has ended\r\n\t    require(block.number > closing_requests[key].settle_block_number);\r\n\r\n        settleChannel(msg.sender, _receiver_address, _open_block_number,\r\n            closing_requests[key].closing_balance\r\n        );\r\n    }\r\n\r\n    /// @notice Function for retrieving information about a channel.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @return Channel information: unique_identifier, deposit, settle_block_number,\r\n    /// closing_balance, withdrawn balance).\r\n    function getChannelInfo(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number)\r\n        external\r\n        view\r\n        returns (bytes32, uint192, uint32, uint192, uint192)\r\n    {\r\n        bytes32 key = getKey(_sender_address, _receiver_address, _open_block_number);\r\n        require(channels[key].open_block_number > 0);\r\n\r\n        return (\r\n            key,\r\n            channels[key].deposit,\r\n            closing_requests[key].settle_block_number,\r\n            closing_requests[key].closing_balance,\r\n            withdrawn_balances[key]\r\n        );\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n\r\n    /// @notice Function for adding trusted contracts. Can only be called by owner_address.\r\n    /// @param _trusted_contracts Array of contract addresses that can be trusted to\r\n    /// open and top up channels on behalf of a sender.\r\n    function addTrustedContracts(address[] _trusted_contracts) isOwner public {\r\n        for (uint256 i = 0; i < _trusted_contracts.length; i++) {\r\n            if (addressHasCode(_trusted_contracts[i])) {\r\n                trusted_contracts[_trusted_contracts[i]] = true;\r\n                TrustedContract(_trusted_contracts[i], true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Function for removing trusted contracts. Can only be called by owner_address.\r\n    /// @param _trusted_contracts Array of contract addresses to be removed from\r\n    /// the trusted_contracts mapping.\r\n    function removeTrustedContracts(address[] _trusted_contracts) isOwner public {\r\n        for (uint256 i = 0; i < _trusted_contracts.length; i++) {\r\n            if (trusted_contracts[_trusted_contracts[i]]) {\r\n                trusted_contracts[_trusted_contracts[i]] = false;\r\n                TrustedContract(_trusted_contracts[i], false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the sender address extracted from the balance proof.\r\n    /// dev Works with eth_signTypedData https://github.com/ethereum/EIPs/pull/712.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    /// @param _balance_msg_sig The balance message signed by the sender.\r\n    /// @return Address of the balance proof signer.\r\n    function extractBalanceProofSignature(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance,\r\n        bytes _balance_msg_sig)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        // The variable names from below will be shown to the sender when signing\r\n        // the balance proof, so they have to be kept in sync with the Dapp client.\r\n        // The hashed strings should be kept in sync with this function's parameters\r\n        // (variable names and types).\r\n        // ! Note that EIP712 might change how hashing is done, triggering a\r\n        // new contract deployment with updated code.\r\n        bytes32 message_hash = keccak256(\r\n            keccak256(\r\n                'string message_id',\r\n                'address receiver',\r\n                'uint32 block_created',\r\n                'uint192 balance',\r\n                'address contract'\r\n            ),\r\n            keccak256(\r\n                'Sender balance proof signature',\r\n                _receiver_address,\r\n                _open_block_number,\r\n                _balance,\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        // Derive address from signature\r\n        address signer = ECVerify.ecverify(message_hash, _balance_msg_sig);\r\n        return signer;\r\n    }\r\n\r\n    /// @dev Returns the receiver address extracted from the closing signature.\r\n    /// Works with eth_signTypedData https://github.com/ethereum/EIPs/pull/712.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    /// @param _closing_sig The receiver's signed balance message, containing the sender's address.\r\n    /// @return Address of the closing signature signer.\r\n    function extractClosingSignature(\r\n        address _sender_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance,\r\n        bytes _closing_sig)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        // The variable names from below will be shown to the sender when signing\r\n        // the balance proof, so they have to be kept in sync with the Dapp client.\r\n        // The hashed strings should be kept in sync with this function's parameters\r\n        // (variable names and types).\r\n        // ! Note that EIP712 might change how hashing is done, triggering a\r\n        // new contract deployment with updated code.\r\n        bytes32 message_hash = keccak256(\r\n            keccak256(\r\n                'string message_id',\r\n                'address sender',\r\n                'uint32 block_created',\r\n                'uint192 balance',\r\n                'address contract'\r\n            ),\r\n            keccak256(\r\n                'Receiver closing signature',\r\n                _sender_address,\r\n                _open_block_number,\r\n                _balance,\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        // Derive address from signature\r\n        address signer = ECVerify.ecverify(message_hash, _closing_sig);\r\n        return signer;\r\n    }\r\n\r\n    /// @notice Returns the unique channel identifier used in the contract.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @return Unique channel identifier.\r\n    function getKey(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number)\r\n        public\r\n        pure\r\n        returns (bytes32 data)\r\n    {\r\n        return keccak256(_sender_address, _receiver_address, _open_block_number);\r\n    }\r\n\r\n    /*\r\n     *  Private functions\r\n     */\r\n\r\n    /// @dev Creates a new channel between a sender and a receiver.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _deposit The amount of tokens that the sender escrows.\r\n    function createChannelPrivate(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint192 _deposit)\r\n        private\r\n    {\r\n        require(_deposit <= channel_deposit_bugbounty_limit);\r\n\r\n        uint32 open_block_number = uint32(block.number);\r\n\r\n        // Create unique identifier from sender, receiver and current block number\r\n        bytes32 key = getKey(_sender_address, _receiver_address, open_block_number);\r\n\r\n        require(channels[key].deposit == 0);\r\n        require(channels[key].open_block_number == 0);\r\n        require(closing_requests[key].settle_block_number == 0);\r\n\r\n        // Store channel information\r\n        channels[key] = Channel({deposit: _deposit, open_block_number: open_block_number});\r\n        ChannelCreated(_sender_address, _receiver_address, _deposit);\r\n    }\r\n\r\n    /// @dev Updates internal balance Structures when the sender adds tokens to the channel.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _added_deposit The added token deposit with which the current deposit is increased.\r\n    function updateInternalBalanceStructs(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _added_deposit)\r\n        private\r\n    {\r\n        require(_added_deposit > 0);\r\n        require(_open_block_number > 0);\r\n\r\n        bytes32 key = getKey(_sender_address, _receiver_address, _open_block_number);\r\n\r\n        require(channels[key].open_block_number > 0);\r\n        require(closing_requests[key].settle_block_number == 0);\r\n        require(channels[key].deposit + _added_deposit <= channel_deposit_bugbounty_limit);\r\n\r\n        channels[key].deposit += _added_deposit;\r\n        assert(channels[key].deposit >= _added_deposit);\r\n        ChannelToppedUp(_sender_address, _receiver_address, _open_block_number, _added_deposit);\r\n    }\r\n\r\n    /// @dev Deletes the channel and settles by transfering the balance to the receiver\r\n    /// and the rest of the deposit back to the sender.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    function settleChannel(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance)\r\n        private\r\n    {\r\n        bytes32 key = getKey(_sender_address, _receiver_address, _open_block_number);\r\n        Channel memory channel = channels[key];\r\n\r\n        require(channel.open_block_number > 0);\r\n        require(_balance <= channel.deposit);\r\n        require(withdrawn_balances[key] <= _balance);\r\n\r\n        // Remove closed channel structures\r\n        // channel.open_block_number will become 0\r\n        // Change state before transfer call\r\n        delete channels[key];\r\n        delete closing_requests[key];\r\n\r\n        // Send the unwithdrawn _balance to the receiver\r\n        uint192 receiver_remaining_tokens = _balance - withdrawn_balances[key];\r\n        require(token.transfer(_receiver_address, receiver_remaining_tokens));\r\n\r\n        // Send deposit - balance back to sender\r\n        require(token.transfer(_sender_address, channel.deposit - _balance));\r\n\r\n        ChannelSettled(\r\n            _sender_address,\r\n            _receiver_address,\r\n            _open_block_number,\r\n            _balance,\r\n            receiver_remaining_tokens\r\n        );\r\n    }\r\n\r\n    /*\r\n     *  Internal functions\r\n     */\r\n\r\n    /// @dev Internal function for getting an address from tokenFallback data bytes.\r\n    /// @param data Bytes received.\r\n    /// @param offset Number of bytes to offset.\r\n    /// @return Extracted address.\r\n    function addressFromBytes (bytes data, uint256 offset) internal pure returns (address) {\r\n        bytes20 extracted_address;\r\n        assembly {\r\n            extracted_address := mload(add(data, offset))\r\n        }\r\n        return address(extracted_address);\r\n    }\r\n\r\n    /// @dev Internal function for getting the block number from tokenFallback data bytes.\r\n    /// @param data Bytes received.\r\n    /// @param offset Number of bytes to offset.\r\n    /// @return Block number.\r\n    function blockNumberFromBytes(bytes data, uint256 offset) internal pure returns (uint32) {\r\n        bytes4 block_number;\r\n        assembly {\r\n            block_number := mload(add(data, offset))\r\n        }\r\n        return uint32(block_number);\r\n    }\r\n\r\n    /// @dev Check if a contract exists.\r\n    /// @param _contract The address of the contract to check for.\r\n    /// @return True if a contract exists, false otherwise.\r\n    function addressHasCode(address _contract) internal view returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(_contract)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_added_deposit\",\"type\":\"uint192\"}],\"name\":\"topUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challenge_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"}],\"name\":\"getChannelInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint192\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint192\"},{\"name\":\"\",\"type\":\"uint192\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"uint192\"},{\"name\":\"_balance_msg_sig\",\"type\":\"bytes\"}],\"name\":\"extractBalanceProofSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"uint192\"},{\"name\":\"_balance_msg_sig\",\"type\":\"bytes\"},{\"name\":\"_closing_sig\",\"type\":\"bytes\"}],\"name\":\"cooperativeClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"uint192\"},{\"name\":\"_closing_sig\",\"type\":\"bytes\"}],\"name\":\"extractClosingSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trusted_contracts\",\"type\":\"address[]\"}],\"name\":\"removeTrustedContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawn_balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint192\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"uint192\"}],\"name\":\"uncooperativeClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"channel_deposit_bugbounty_limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"closing_requests\",\"outputs\":[{\"name\":\"closing_balance\",\"type\":\"uint192\"},{\"name\":\"settle_block_number\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_added_deposit\",\"type\":\"uint192\"}],\"name\":\"topUpDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"channels\",\"outputs\":[{\"name\":\"deposit\",\"type\":\"uint192\"},{\"name\":\"open_block_number\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"}],\"name\":\"getKey\",\"outputs\":[{\"name\":\"data\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trusted_contracts\",\"type\":\"address[]\"}],\"name\":\"addTrustedContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"trusted_contracts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"uint192\"},{\"name\":\"_balance_msg_sig\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_deposit\",\"type\":\"uint192\"}],\"name\":\"createChannel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_deposit\",\"type\":\"uint192\"}],\"name\":\"createChannelDelegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token_address\",\"type\":\"address\"},{\"name\":\"_challenge_period\",\"type\":\"uint32\"},{\"name\":\"_trusted_contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_deposit\",\"type\":\"uint192\"}],\"name\":\"ChannelCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_added_deposit\",\"type\":\"uint192\"}],\"name\":\"ChannelToppedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint192\"}],\"name\":\"ChannelCloseRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint192\"},{\"indexed\":false,\"name\":\"_receiver_tokens\",\"type\":\"uint192\"}],\"name\":\"ChannelSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_withdrawn_balance\",\"type\":\"uint192\"}],\"name\":\"ChannelWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_trusted_contract_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_trusted_status\",\"type\":\"bool\"}],\"name\":\"TrustedContract\",\"type\":\"event\"}]","ContractName":"RaidenMicroTransferChannels","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000255aa6df07540cb5d3d297f0d0d4d84cb52bc8e600000000000000000000000000000000000000000000000000000000000021c000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://e070624cdc8cf91295dfc490388f1f74244f0009535a3da5d1cb9cb285ea47bc"}]}