{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isMultiSigWallet = false;\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (ownerCount > MAX_OWNER_COUNT) throw;\r\n        if (_required > ownerCount) throw;\r\n        if (_required == 0) throw;\r\n        if (ownerCount == 0) throw;\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0) throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        isMultiSigWallet = true;\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param owner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n       internal\r\n       notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if ((pending && !transactions[i].executed) ||\r\n                (executed && transactions[i].executed))\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n          if ((pending && !transactions[i].executed) ||\r\n              (executed && transactions[i].executed))\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\ncontract UpgradeAgent is SafeMath {\r\n  address public owner;\r\n  bool public isUpgradeAgent;\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n  function setOriginalSupply() public;\r\n}\r\n\r\n// @title BCDC Token vault, locked tokens for 1 month (Dev Team) and 1 year for Founders\r\ncontract BCDCVault is SafeMath {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isBCDCVault = false;\r\n\r\n    BCDCToken bcdcToken;\r\n\r\n    // address of our private MultiSigWallet contract\r\n    address bcdcMultisig;\r\n    // number of block unlock for developers\r\n    uint256 public unlockedBlockForDev;\r\n    // number of block unlock for founders\r\n    uint256 public unlockedBlockForFounders;\r\n    // It should be 1 * 30 days * 24 hours * 60 minutes * 60 seconds / 17\r\n    // We can set small for testing purpose\r\n    uint256 public numBlocksLockedDev;\r\n    // It should be 12 months * 30 days * 24 hours * 60 minutes * 60 seconds / 17\r\n    // We can set small for testing purpose\r\n    uint256 public numBlocksLockedFounders;\r\n\r\n    // flag to determine all the token for developers already unlocked or not\r\n    bool public unlockedAllTokensForDev = false;\r\n    // flag to determine all the token for founders already unlocked or not\r\n    bool public unlockedAllTokensForFounders = false;\r\n\r\n    // Constructor function sets the BCDC Multisig address and\r\n    // total number of locked tokens to transfer\r\n    function BCDCVault(address _bcdcMultisig,uint256 _numBlocksLockedForDev,uint256 _numBlocksLockedForFounders) {\r\n        // If it's not bcdcMultisig address then throw\r\n        if (_bcdcMultisig == 0x0) throw;\r\n        // Initalized bcdcToken\r\n        bcdcToken = BCDCToken(msg.sender);\r\n        // Initalized bcdcMultisig address\r\n        bcdcMultisig = _bcdcMultisig;\r\n        // Mark it as BCDCVault\r\n        isBCDCVault = true;\r\n        //Initalized numBlocksLockedDev and numBlocksLockedFounders with block number\r\n        numBlocksLockedDev = _numBlocksLockedForDev;\r\n        numBlocksLockedFounders = _numBlocksLockedForFounders;\r\n        // Initalized unlockedBlockForDev with block number\r\n        // according to current block\r\n        unlockedBlockForDev = safeAdd(block.number, numBlocksLockedDev); // 30 days of blocks later\r\n        // Initalized unlockedBlockForFounders with block number\r\n        // according to current block\r\n        unlockedBlockForFounders = safeAdd(block.number, numBlocksLockedFounders); // 365 days of blocks later\r\n    }\r\n\r\n    // Transfer Development Team Tokens To MultiSigWallet - 30 Days Locked\r\n    function unlockForDevelopment() external {\r\n        // If it has not reached 30 days mark do not transfer\r\n        if (block.number < unlockedBlockForDev) throw;\r\n        // If it is already unlocked then do not allowed\r\n        if (unlockedAllTokensForDev) throw;\r\n        // Mark it as unlocked\r\n        unlockedAllTokensForDev = true;\r\n        // Will fail if allocation (and therefore toTransfer) is 0.\r\n        uint256 totalBalance = bcdcToken.balanceOf(this);\r\n        // transfer half of token to development team\r\n        uint256 developmentTokens = safeDiv(safeMul(totalBalance, 50), 100);\r\n        if (!bcdcToken.transfer(bcdcMultisig, developmentTokens)) throw;\r\n    }\r\n\r\n    //  Transfer Founders Team Tokens To MultiSigWallet - 365 Days Locked\r\n    function unlockForFounders() external {\r\n        // If it has not reached 365 days mark do not transfer\r\n        if (block.number < unlockedBlockForFounders) throw;\r\n        // If it is already unlocked then do not allowed\r\n        if (unlockedAllTokensForFounders) throw;\r\n        // Mark it as unlocked\r\n        unlockedAllTokensForFounders = true;\r\n        // Will fail if allocation (and therefore toTransfer) is 0.\r\n        if (!bcdcToken.transfer(bcdcMultisig, bcdcToken.balanceOf(this))) throw;\r\n        // So that ether will not be trapped here.\r\n        if (!bcdcMultisig.send(this.balance)) throw;\r\n    }\r\n\r\n    // disallow payment after unlock block\r\n    function () payable {\r\n        if (block.number >= unlockedBlockForFounders) throw;\r\n    }\r\n\r\n}\r\n\r\n// @title BCDC Token Contract with Token Sale Functionality as well\r\ncontract BCDCToken is SafeMath, ERC20 {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isBCDCToken = false;\r\n    bool public upgradeAgentStatus = false;\r\n    // Address of Owner for this Contract\r\n    address public owner;\r\n\r\n    // Define the current state of crowdsale\r\n    enum State{PreFunding, Funding, Success, Failure}\r\n\r\n    // Token related information\r\n    string public constant name = \"BCDC Token\";\r\n    string public constant symbol = \"BCDC\";\r\n    uint256 public constant decimals = 18;  // decimal places\r\n\r\n    // Mapping of token balance and allowed address for each address with transfer limit\r\n    mapping (address => uint256) balances;\r\n    // This is only for refund purpose, as we have price range during different weeks of Crowdfunding,\r\n    //  need to maintain total investment done so refund would be exactly same.\r\n    mapping (address => uint256) investment;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Crowdsale information\r\n    bool public finalizedCrowdfunding = false;\r\n    // flag to determine is perallocation done or not\r\n    bool public preallocated = false;\r\n    uint256 public fundingStartBlock; // crowdsale start block\r\n    uint256 public fundingEndBlock; // crowdsale end block\r\n    // change price of token when current block reached\r\n\r\n    // Maximum Token Sale (Crowdsale + Early Sale + Supporters)\r\n    // Approximate 250 millions ITS + 125 millions for early investors + 75 Millions to Supports\r\n    uint256 public tokenSaleMax;\r\n    // Min tokens needs to be sold out for success\r\n    // Approximate 1/4 of 250 millions\r\n    uint256 public tokenSaleMin;\r\n    //1 Billion BCDC Tokens\r\n    uint256 public constant maxTokenSupply = 1000000000 ether;\r\n    // Team token percentages to store in time vault\r\n    uint256 public constant vaultPercentOfTotal = 5;\r\n    // Project Reserved Fund Token %\r\n    uint256 public constant reservedPercentTotal = 25;\r\n\r\n    // Multisig Wallet Address\r\n    address public bcdcMultisig;\r\n    // Project Reserve Fund address\r\n    address bcdcReserveFund;\r\n    // BCDC's time-locked vault\r\n    BCDCVault public timeVault;\r\n\r\n    // Events for refund process\r\n    event Refund(address indexed _from, uint256 _value);\r\n    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n    event UpgradeFinalized(address sender, address upgradeAgent);\r\n    event UpgradeAgentSet(address agent);\r\n    // BCDC:ETH exchange rate\r\n    uint256 tokensPerEther;\r\n\r\n    // @dev To Halt in Emergency Condition\r\n    bool public halted;\r\n\r\n    bool public finalizedUpgrade = false;\r\n    address public upgradeMaster;\r\n    UpgradeAgent public upgradeAgent;\r\n    uint256 public totalUpgraded;\r\n\r\n\r\n    // Constructor function sets following\r\n    // @param bcdcMultisig address of bcdcMultisigWallet\r\n    // @param fundingStartBlock block number at which funding will start\r\n    // @param fundingEndBlock block number at which funding will end\r\n    // @param tokenSaleMax maximum number of token to sale\r\n    // @param tokenSaleMin minimum number of token to sale\r\n    // @param tokensPerEther number of token to sale per ether\r\n    function BCDCToken(address _bcdcMultiSig,\r\n                      address _upgradeMaster,\r\n                      uint256 _fundingStartBlock,\r\n                      uint256 _fundingEndBlock,\r\n                      uint256 _tokenSaleMax,\r\n                      uint256 _tokenSaleMin,\r\n                      uint256 _tokensPerEther,\r\n                      uint256 _numBlocksLockedForDev,\r\n                      uint256 _numBlocksLockedForFounders) {\r\n        // Is not bcdcMultisig address correct then throw\r\n        if (_bcdcMultiSig == 0) throw;\r\n        // Is funding already started then throw\r\n        if (_upgradeMaster == 0) throw;\r\n\r\n        if (_fundingStartBlock <= block.number) throw;\r\n        // If fundingEndBlock or fundingStartBlock value is not correct then throw\r\n        if (_fundingEndBlock   <= _fundingStartBlock) throw;\r\n        // If tokenSaleMax or tokenSaleMin value is not correct then throw\r\n        if (_tokenSaleMax <= _tokenSaleMin) throw;\r\n        // If tokensPerEther value is 0 then throw\r\n        if (_tokensPerEther == 0) throw;\r\n        // Mark it is BCDCToken\r\n        isBCDCToken = true;\r\n        // Initalized all param\r\n        upgradeMaster = _upgradeMaster;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n        tokenSaleMax = _tokenSaleMax;\r\n        tokenSaleMin = _tokenSaleMin;\r\n        tokensPerEther = _tokensPerEther;\r\n        // Initalized timeVault as BCDCVault\r\n        timeVault = new BCDCVault(_bcdcMultiSig,_numBlocksLockedForDev,_numBlocksLockedForFounders);\r\n        // If timeVault is not BCDCVault then throw\r\n        if (!timeVault.isBCDCVault()) throw;\r\n        // Initalized bcdcMultisig address\r\n        bcdcMultisig = _bcdcMultiSig;\r\n        // Initalized owner\r\n        owner = msg.sender;\r\n        // MultiSigWallet is not bcdcMultisig then throw\r\n        if (!MultiSigWallet(bcdcMultisig).isMultiSigWallet()) throw;\r\n    }\r\n    // Ownership related modifer and functions\r\n    // @dev Throws if called by any account other than the owner\r\n    modifier onlyOwner() {\r\n      if (msg.sender != owner) {\r\n        throw;\r\n      }\r\n      _;\r\n    }\r\n\r\n    // @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    // @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n      if (newOwner != address(0)) {\r\n        owner = newOwner;\r\n      }\r\n    }\r\n\r\n    // @param _bcdcReserveFund Ether Address for Project Reserve Fund\r\n    // This has to be called before preAllocation\r\n    // Only to be called by Owner of this contract\r\n    function setBcdcReserveFund(address _bcdcReserveFund) onlyOwner{\r\n        if (getState() != State.PreFunding) throw;\r\n        if (preallocated) throw; // Has to be done before preallocation\r\n        if (_bcdcReserveFund == 0x0) throw;\r\n        bcdcReserveFund = _bcdcReserveFund;\r\n    }\r\n\r\n    // @param who The address of the investor to check balance\r\n    // @return balance tokens of investor address\r\n    function balanceOf(address who) constant returns (uint) {\r\n        return balances[who];\r\n    }\r\n\r\n    // @param who The address of the investor to check investment amount\r\n    // @return total investment done by ethereum address\r\n    // This method is only usable up to Crowdfunding ends (Success or Fail)\r\n    // So if tokens are transfered post crowdsale investment will not change.\r\n    function checkInvestment(address who) constant returns (uint) {\r\n        return investment[who];\r\n    }\r\n\r\n    // @param owner The address of the account owning tokens\r\n    // @param spender The address of the account able to transfer the tokens\r\n    // @return Amount of remaining tokens allowed to spent\r\n    function allowance(address owner, address spender) constant returns (uint) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    //  Transfer `value` BCDC tokens from sender's account\r\n    // `msg.sender` to provided account address `to`.\r\n    // @dev Required state: Success\r\n    // @param to The address of the recipient\r\n    // @param value The number of BCDC tokens to transfer\r\n    // @return Whether the transfer was successful or not\r\n    function transfer(address to, uint value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; // Abort if crowdfunding was not a success.\r\n        uint256 senderBalance = balances[msg.sender];\r\n        if ( senderBalance >= value && value > 0) {\r\n            senderBalance = safeSub(senderBalance, value);\r\n            balances[msg.sender] = senderBalance;\r\n            balances[to] = safeAdd(balances[to], value);\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //  Transfer `value` BCDC tokens from sender 'from'\r\n    // to provided account address `to`.\r\n    // @dev Required state: Success\r\n    // @param from The address of the sender\r\n    // @param to The address of the recipient\r\n    // @param value The number of BCDC to transfer\r\n    // @return Whether the transfer was successful or not\r\n    function transferFrom(address from, address to, uint value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; // Abort if crowdfunding was not a success.\r\n        if (balances[from] >= value &&\r\n            allowed[from][msg.sender] >= value &&\r\n            value > 0)\r\n        {\r\n            balances[to] = safeAdd(balances[to], value);\r\n            balances[from] = safeSub(balances[from], value);\r\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], value);\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    //  `msg.sender` approves `spender` to spend `value` tokens\r\n    // @param spender The address of the account able to transfer the tokens\r\n    // @param value The amount of wei to be approved for transfer\r\n    // @return Whether the approval was successful or not\r\n    function approve(address spender, uint value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; // Abort if not in Success state.\r\n        allowed[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    // Sale of the tokens. Investors can call this method to invest into BCDC Tokens\r\n    // Only when it's in funding mode. In case of emergecy it will be halted.\r\n    function() payable stopIfHalted external {\r\n        // Allow only to invest in funding state\r\n        if (getState() != State.Funding) throw;\r\n\r\n        // Sorry !! We do not allow to invest with 0 as value\r\n        if (msg.value == 0) throw;\r\n\r\n        // multiply by exchange rate to get newly created token amount\r\n        uint256 createdTokens = safeMul(msg.value, tokensPerEther);\r\n\r\n        // Wait we crossed maximum token sale goal. It's successful token sale !!\r\n        if (safeAdd(createdTokens, totalSupply) > tokenSaleMax) throw;\r\n\r\n        // Call to Internal function to assign tokens\r\n        assignTokens(msg.sender, createdTokens);\r\n\r\n        // Track the investment for each address till crowdsale ends\r\n        investment[msg.sender] = safeAdd(investment[msg.sender], msg.value);\r\n    }\r\n\r\n    // To allocate tokens to Project Fund - eg. RecycleToCoin before Token Sale\r\n    // Tokens allocated to these will not be count in totalSupply till the Token Sale Success and Finalized in finalizeCrowdfunding()\r\n    function preAllocation() onlyOwner stopIfHalted external {\r\n        // Allow only in Pre Funding Mode\r\n        if (getState() != State.PreFunding) throw;\r\n        // Check if BCDC Reserve Fund is set or not\r\n        if (bcdcReserveFund == 0x0) throw;\r\n        // To prevent multiple call by mistake\r\n        if (preallocated) throw;\r\n        preallocated = true;\r\n        // 25% of overall Token Supply to project reseve fund\r\n        uint256 projectTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100);\r\n        // At this time we will not add to totalSupply because these are not part of Sale\r\n        // It will be added in totalSupply once the Token Sale is Finalized\r\n        balances[bcdcReserveFund] = projectTokens;\r\n        // Log the event\r\n        Transfer(0, bcdcReserveFund, projectTokens);\r\n    }\r\n\r\n    // BCDC accepts Early Investment through manual process in Fiat Currency\r\n    // BCDC Team will assign the tokens to investors manually through this function\r\n    function earlyInvestment(address earlyInvestor, uint256 assignedTokens) onlyOwner stopIfHalted external {\r\n        // Allow only in Pre Funding Mode And Funding Mode\r\n        if (getState() != State.PreFunding && getState() != State.Funding) throw;\r\n        // Check if earlyInvestor address is set or not\r\n        if (earlyInvestor == 0x0) throw;\r\n        // By mistake tokens mentioned as 0, save the cost of assigning tokens.\r\n        if (assignedTokens == 0 ) throw;\r\n\r\n        // Call to Internal function to assign tokens\r\n        assignTokens(earlyInvestor, assignedTokens);\r\n\r\n        // Track the investment for each address\r\n        // Refund for this investor is taken care by out side the contract.because they are investing in their fiat currency\r\n        //investment[earlyInvestor] = safeAdd(investment[earlyInvestor], etherValue);\r\n    }\r\n\r\n    // Function will transfer the tokens to investor's address\r\n    // Common function code for Early Investor and Crowdsale Investor\r\n    function assignTokens(address investor, uint256 tokens) internal {\r\n        // Creating tokens and  increasing the totalSupply\r\n        totalSupply = safeAdd(totalSupply, tokens);\r\n\r\n        // Assign new tokens to the sender\r\n        balances[investor] = safeAdd(balances[investor], tokens);\r\n\r\n        // Finally token created for sender, log the creation event\r\n        Transfer(0, investor, tokens);\r\n    }\r\n\r\n    // Finalize crowdfunding\r\n    // Finally - Transfer the Ether to Multisig Wallet\r\n    function finalizeCrowdfunding() stopIfHalted external {\r\n        // Abort if not in Funding Success state.\r\n        if (getState() != State.Success) throw; // don't finalize unless we won\r\n        if (finalizedCrowdfunding) throw; // can't finalize twice (so sneaky!)\r\n\r\n        // prevent more creation of tokens\r\n        finalizedCrowdfunding = true;\r\n\r\n        // Check if Unsold tokens out 450 millions\r\n        // 250 Millions Sale + 125 Millions for Early Investors + 75 Millions for Supporters\r\n        uint256 unsoldTokens = safeSub(tokenSaleMax, totalSupply);\r\n\r\n        // Founders and Tech Team Tokens Goes to Vault, Locked for 1 month (Tech) and 1 year(Team)\r\n        uint256 vaultTokens = safeDiv(safeMul(maxTokenSupply, vaultPercentOfTotal), 100);\r\n        totalSupply = safeAdd(totalSupply, vaultTokens);\r\n        balances[timeVault] = safeAdd(balances[timeVault], vaultTokens);\r\n        Transfer(0, timeVault, vaultTokens);\r\n\r\n        // Only transact if there are any unsold tokens\r\n        if(unsoldTokens > 0) {\r\n            totalSupply = safeAdd(totalSupply, unsoldTokens);\r\n            // Remaining unsold tokens assign to multisig wallet\r\n            balances[bcdcMultisig] = safeAdd(balances[bcdcMultisig], unsoldTokens);// Assign Reward Tokens to Multisig wallet\r\n            Transfer(0, bcdcMultisig, unsoldTokens);\r\n        }\r\n\r\n        // Add pre allocated tokens to project reserve fund to totalSupply\r\n        uint256 preallocatedTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100);\r\n        // project tokens already counted, so only add preallcated tokens\r\n        totalSupply = safeAdd(totalSupply, preallocatedTokens);\r\n        // 250 millions reward tokens to multisig (equal to reservefund prellocation).\r\n        // Reward to token holders on their commitment with BCDC (25 % of 1 billion = 250 millions)\r\n        uint256 rewardTokens = safeDiv(safeMul(maxTokenSupply, reservedPercentTotal), 100);\r\n        balances[bcdcMultisig] = safeAdd(balances[bcdcMultisig], rewardTokens);// Assign Reward Tokens to Multisig wallet\r\n        totalSupply = safeAdd(totalSupply, rewardTokens);\r\n\r\n        // Total Supply Should not be greater than 1 Billion\r\n        if (totalSupply > maxTokenSupply) throw;\r\n        // Transfer ETH to the BCDC Multisig address.\r\n        if (!bcdcMultisig.send(this.balance)) throw;\r\n    }\r\n\r\n    // Call this function to get the refund of investment done during Crowdsale\r\n    // Refund can be done only when Min Goal has not reached and Crowdsale is over\r\n    function refund() external {\r\n        // Abort if not in Funding Failure state.\r\n        if (getState() != State.Failure) throw;\r\n\r\n        uint256 bcdcValue = balances[msg.sender];\r\n        if (bcdcValue == 0) throw;\r\n        balances[msg.sender] = 0;\r\n        totalSupply = safeSub(totalSupply, bcdcValue);\r\n\r\n        uint256 ethValue = investment[msg.sender];\r\n        investment[msg.sender] = 0;\r\n        Refund(msg.sender, ethValue);\r\n        if (!msg.sender.send(ethValue)) throw;\r\n    }\r\n\r\n    // This will return the current state of Token Sale\r\n    // Read only method so no transaction fees\r\n    function getState() public constant returns (State){\r\n      if (block.number < fundingStartBlock) return State.PreFunding;\r\n      else if (block.number <= fundingEndBlock && totalSupply < tokenSaleMax) return State.Funding;\r\n      else if (totalSupply >= tokenSaleMin || upgradeAgentStatus) return State.Success;\r\n      else return State.Failure;\r\n    }\r\n\r\n    // Token upgrade functionality\r\n\r\n    /// @notice Upgrade tokens to the new token contract.\r\n    /// @dev Required state: Success\r\n    /// @param value The number of tokens to upgrade\r\n    function upgrade(uint256 value) external {\r\n        if (!upgradeAgentStatus) throw;\r\n        /*if (getState() != State.Success) throw; // Abort if not in Success state.*/\r\n        if (upgradeAgent.owner() == 0x0) throw; // need a real upgradeAgent address\r\n        if (finalizedUpgrade) throw; // cannot upgrade if finalized\r\n\r\n        // Validate input value.\r\n        if (value == 0) throw;\r\n        if (value > balances[msg.sender]) throw;\r\n\r\n        // update the balances here first before calling out (reentrancy)\r\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n        totalSupply = safeSub(totalSupply, value);\r\n        totalUpgraded = safeAdd(totalUpgraded, value);\r\n        upgradeAgent.upgradeFrom(msg.sender, value);\r\n        Upgrade(msg.sender, upgradeAgent, value);\r\n    }\r\n\r\n    /// @notice Set address of upgrade target contract and enable upgrade\r\n    /// process.\r\n    /// @dev Required state: Success\r\n    /// @param agent The address of the UpgradeAgent contract\r\n    function setUpgradeAgent(address agent) external {\r\n        if (getState() != State.Success) throw; // Abort if not in Success state.\r\n        if (agent == 0x0) throw; // don't set agent to nothing\r\n        if (msg.sender != upgradeMaster) throw; // Only a master can designate the next agent\r\n        upgradeAgent = UpgradeAgent(agent);\r\n        if (!upgradeAgent.isUpgradeAgent()) throw;\r\n        // this needs to be called in success condition to guarantee the invariant is true\r\n        upgradeAgentStatus = true;\r\n        upgradeAgent.setOriginalSupply();\r\n        UpgradeAgentSet(upgradeAgent);\r\n    }\r\n\r\n    /// @notice Set address of upgrade target contract and enable upgrade\r\n    /// process.\r\n    /// @dev Required state: Success\r\n    /// @param master The address that will manage upgrades, not the upgradeAgent contract address\r\n    function setUpgradeMaster(address master) external {\r\n        if (getState() != State.Success) throw; // Abort if not in Success state.\r\n        if (master == 0x0) throw;\r\n        if (msg.sender != upgradeMaster) throw; // Only a master can designate the next master\r\n        upgradeMaster = master;\r\n    }\r\n\r\n    // These modifier and functions related to halt the sale in case of emergency\r\n\r\n    // @dev Use this as function modifier that should not execute if contract state Halted\r\n    modifier stopIfHalted {\r\n      if(halted) throw;\r\n      _;\r\n    }\r\n\r\n    // @dev Use this as function modifier that should execute only if contract state Halted\r\n    modifier runIfHalted{\r\n      if(!halted) throw;\r\n      _;\r\n    }\r\n\r\n    // @dev called by only owner in case of any emergecy situation\r\n    function halt() external onlyOwner{\r\n      halted = true;\r\n    }\r\n\r\n    // @dev called by only owner to stop the emergency situation\r\n    function unhalt() external onlyOwner{\r\n      halted = false;\r\n    }\r\n\r\n    // This method is only use for transfer bcdctoken from bcdcReserveFund\r\n    // @dev Required state: is bcdcReserveFund set\r\n    // @param to The address of the recipient\r\n    // @param value The number of BCDC tokens to transfer\r\n    // @return Whether the transfer was successful or not\r\n    function reserveTokenClaim(address claimAddress,uint256 token) onlyBcdcReserve returns (bool ok){\r\n      // Check if BCDC Reserve Fund is set or not\r\n      if ( bcdcReserveFund == 0x0) throw;\r\n      uint256 senderBalance = balances[msg.sender];\r\n      if(senderBalance >= token && token>0){\r\n        senderBalance = safeSub(senderBalance, token);\r\n        balances[msg.sender] = senderBalance;\r\n        balances[claimAddress] = safeAdd(balances[claimAddress], token);\r\n        Transfer(msg.sender, claimAddress, token);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // This method is for getting bcdctoken as rewards\r\n\t  // @param tokens The number of tokens back for rewards\r\n  \tfunction backTokenForRewards(uint256 tokens) external{\r\n  \t\t// Check that token available for transfer\r\n  \t\tif(balances[msg.sender] < tokens && tokens <= 0) throw;\r\n\r\n  \t\t// Debit tokens from msg.sender\r\n  \t\tbalances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n\r\n  \t\t// Credit tokens into bcdcReserveFund\r\n  \t\tbalances[bcdcReserveFund] = safeAdd(balances[bcdcReserveFund], tokens);\r\n  \t\tTransfer(msg.sender, bcdcReserveFund, tokens);\r\n  \t}\r\n\r\n    // bcdcReserveFund related modifer and functions\r\n    // @dev Throws if called by any account other than the bcdcReserveFund owner\r\n    modifier onlyBcdcReserve() {\r\n      if (msg.sender != bcdcReserveFund) {\r\n        throw;\r\n      }\r\n      _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultPercentOfTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgentStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdfunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preallocated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bcdcMultisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"earlyInvestor\",\"type\":\"address\"},{\"name\":\"assignedTokens\",\"type\":\"uint256\"}],\"name\":\"earlyInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedCrowdfunding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedPercentTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bcdcReserveFund\",\"type\":\"address\"}],\"name\":\"setBcdcReserveFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"backTokenForRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBCDCToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"preAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claimAddress\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"reserveTokenClaim\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"checkInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bcdcMultiSig\",\"type\":\"address\"},{\"name\":\"_upgradeMaster\",\"type\":\"address\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"},{\"name\":\"_tokenSaleMax\",\"type\":\"uint256\"},{\"name\":\"_tokenSaleMin\",\"type\":\"uint256\"},{\"name\":\"_tokensPerEther\",\"type\":\"uint256\"},{\"name\":\"_numBlocksLockedForDev\",\"type\":\"uint256\"},{\"name\":\"_numBlocksLockedForFounders\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"upgradeAgent\",\"type\":\"address\"}],\"name\":\"UpgradeFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BCDCToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000ec71c55893ee571d2eb8592f0b7b2816c115a4a20000000000000000000000005adc335afa4f6f97d5920996f0f0ff06ace3b998000000000000000000000000000000000000000000000000000000000046151d000000000000000000000000000000000000000000000000000000000046c21d000000000000000000000000000000000000000001743b34e18439b50200000000000000000000000000000000000000000000000001a784379d99db420000000000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000003c068000000000000000000000000000000000000000000000000000000000021197a","Library":"","SwarmSource":"bzzr://607ad7668db15fb233fe35276b9ccc9d7aee2b531a4511cf275e0580875e8801"}]}