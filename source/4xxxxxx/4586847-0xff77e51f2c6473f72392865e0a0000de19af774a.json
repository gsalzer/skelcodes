{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n// This contract provides the functions necessary to record (\"push\") & retrieve\r\n// public funding data to the Ethereum blockchain for the National Research\r\n// Council of Canada\r\n\r\ncontract DisclosureManager {\r\n\r\n\taddress public owner;\r\n\r\n\tstruct Disclosure {\r\n\t\tbytes32 organization;\r\n\t\tbytes32 recipient;\r\n\t\tbytes32 location;\r\n\t\tbytes16 amount;\r\n\t\tbytes1 fundingType;\r\n\t\tbytes16 date;\r\n\t\tbytes32 purpose;\r\n\t\tbytes32 comment;\r\n\t\tuint amended;    // if zero not amended, otherwise points to the rowNumber of the new record\r\n\t}\r\n\r\n\tDisclosure[] public disclosureList;\r\n\r\n\tevent disclosureAdded(\r\n    uint rowNumber,\r\n    bytes32 organization,\r\n    bytes32 recipient,\r\n    bytes32 location,\r\n    bytes16 amount,\r\n    bytes1 fundingType,\r\n    bytes16 date,\r\n    bytes32 purpose,\r\n    bytes32 comment);\r\n\r\n\tfunction DisclosureManager() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t// Make sure the caller of the contract is the owner\r\n\t// modifier isOwner() { if (msg.sender != owner) throw; _ ;}   // old way\r\n\tmodifier isOwner() { if (msg.sender != owner) revert(); _ ;}\r\n\r\n\t// getListCount() returns the number of records in disclosureList (not including the empty 0th record)\r\n\tfunction getListCount() public constant returns(uint listCount) {\r\n  \tif (disclosureList.length > 0) {\r\n\t\t\treturn disclosureList.length - 1;    // Returns the last rowNumber, reflecting number of records in list\r\n\t\t} else {\r\n\t\t\treturn 0;    // The case of an uninitialized list\r\n\t\t}\r\n\t}\r\n\t// Future idea: Another function to return total number of unamended Entries? (ie actual record count)\r\n\r\n\t// Create/push a new entry to our array, returns the new Entry's rowNumber\r\n\tfunction newEntry(bytes32 organization,\r\n\t\t\t\t\t  bytes32 recipient,\r\n\t\t\t\t\t  bytes32 location,\r\n\t\t\t\t\t  bytes16 amount,\r\n\t\t\t\t\t  bytes1 fundingType,\r\n\t\t\t\t\t  bytes16 date,\r\n\t\t\t\t\t  bytes32 purpose,\r\n\t\t\t\t\t  bytes32 comment) public isOwner() returns(uint rowNumber) {    // should this be public? yes, only needed isOwner()\r\n\r\n\t\t// Initialize disclosureList here as needed by putting an empty record at row 0\r\n\t\t// The first entry starts at 1 and getListCount will be in accordance with the record count\r\n\t\tif (disclosureList.length == 0) {\r\n\t\t\t// Push an empty Entry\r\n\t\t\tDisclosure memory nullEntry;\r\n\t\t\tdisclosureList.push(nullEntry);\r\n\t\t}\r\n\r\n\t\tDisclosure memory disclosure;\r\n\r\n\t\tdisclosure.organization = organization;\r\n\t\tdisclosure.recipient = recipient;\r\n\t\tdisclosure.location = location;\r\n\t\tdisclosure.amount = amount;\r\n\t\tdisclosure.fundingType = fundingType;\r\n\t\tdisclosure.date = date;\r\n\t\tdisclosure.purpose = purpose;\r\n\t\tdisclosure.comment = comment;\r\n\t\tdisclosure.amended = 0;\r\n\r\n\t\t// Push entry to the array\r\n\t\tuint index = disclosureList.push(disclosure);   // adds to end of array (of structs) and returns the new array length\r\n\t\tindex = index - 1;\r\n\r\n\t\t// Record the event\r\n\t\tdisclosureAdded(index, organization, recipient, location, amount, fundingType, date, purpose, comment);\r\n\r\n\t\treturn index;   // returning rowNumber of the record\r\n\t}\r\n\r\n\t// Amends/changes marks existing entry as amended and takes passed data to\r\n\t// create a new Entry to which the amended pointer (rowNumber) will point.\r\n\tfunction amendEntry(uint rowNumber,\r\n\t\t\t\t\t\tbytes32 organization,\r\n\t\t\t\t\t\tbytes32 recipient,\r\n\t\t\t\t\t\tbytes32 location,\r\n\t\t\t\t\t\tbytes16 amount,\r\n\t\t\t\t\t\tbytes1 fundingType,\r\n\t\t\t\t\t\tbytes16 date,\r\n\t\t\t\t\t\tbytes32 purpose,\r\n\t\t\t\t\t\tbytes32 comment) public isOwner() returns(uint newRowNumber) {    // returns the new rowNumber of amended record\r\n\r\n\t\t// Make sure passed rowNumber is in bounds\r\n\t\tif (rowNumber >= disclosureList.length) { revert(); }\r\n\t\tif (rowNumber < 1) { revert(); }\r\n\t\tif (disclosureList[rowNumber].amended > 0) { revert(); }    // This record is already amended\r\n\r\n\t\t// First create new entry\r\n\t\tDisclosure memory disclosure;\r\n\r\n\t\tdisclosure.organization = organization;\r\n\t\tdisclosure.recipient = recipient;\r\n\t\tdisclosure.location = location;\r\n\t\tdisclosure.amount = amount;\r\n\t\tdisclosure.fundingType = fundingType;\r\n\t\tdisclosure.date = date;\r\n\t\tdisclosure.purpose = purpose;\r\n\t\tdisclosure.comment = comment;\r\n\t\tdisclosure.amended = 0;\r\n\r\n\t\t// Push entry to the array\r\n\t\tuint index = disclosureList.push(disclosure);   // adds to end of array (of structs) and returns the new array length\r\n\t\tindex = index - 1;\r\n\r\n\t\t// Now that we have the newRowNumber (index), set the amended field on the old record\r\n\t\tdisclosureList[rowNumber].amended = index;\r\n\r\n\t\t// Record the event\r\n\t\tdisclosureAdded(index, organization, recipient, location, amount, fundingType, date, purpose, comment);   // a different event for amending?\r\n\r\n\t\treturn index;   // returning rowNumber of the new record\r\n\t}\r\n\r\n\t// Returns row regardless of whether or not it has been amended\r\n\tfunction pullRow(uint rowNumber) public constant returns(bytes32, bytes32, bytes32, bytes16, bytes1, bytes16, bytes32, bytes32, uint) {\r\n\t\t// First make sure rowNumber passed is within bounds\r\n\t\tif (rowNumber >= disclosureList.length) { revert(); }\r\n\t\tif (rowNumber < 1) { revert(); }\r\n\t\t// Should not use any gas:\r\n\t\tDisclosure memory entry = disclosureList[rowNumber];\r\n\t\treturn (entry.organization, entry.recipient, entry.location, entry.amount, entry.fundingType, entry.date, entry.purpose, entry.comment, entry.amended);\r\n\t}\r\n\r\n\t// Returns latest entry of record intended to pull\r\n\tfunction pullEntry(uint rowNumber) public constant returns(bytes32, bytes32, bytes32, bytes16, bytes1, bytes16, bytes32, bytes32) {\r\n\t\t// First make sure rowNumber passed is within bounds\r\n\t\tif (rowNumber >= disclosureList.length) { revert(); }\r\n\t\tif (rowNumber < 1) { revert(); }\r\n\t\t// If this entry has been amended, return amended entry instead (recursively)\r\n\t\t// just make sure there are never any cyclical lists (shouldn't be possible using these functions)\r\n\t\tif (disclosureList[rowNumber].amended > 0) return pullEntry(disclosureList[rowNumber].amended);\r\n\t\t// Should not require any gas to run:\r\n\t\tDisclosure memory entry = disclosureList[rowNumber];\r\n\t\treturn (entry.organization, entry.recipient, entry.location, entry.amount, entry.fundingType, entry.date, entry.purpose, entry.comment);\r\n\t\t// No event for pullEntry() since it shouldn't cost gas to call it\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getListCount\",\"outputs\":[{\"name\":\"listCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"organization\",\"type\":\"bytes32\"},{\"name\":\"recipient\",\"type\":\"bytes32\"},{\"name\":\"location\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"bytes16\"},{\"name\":\"fundingType\",\"type\":\"bytes1\"},{\"name\":\"date\",\"type\":\"bytes16\"},{\"name\":\"purpose\",\"type\":\"bytes32\"},{\"name\":\"comment\",\"type\":\"bytes32\"}],\"name\":\"newEntry\",\"outputs\":[{\"name\":\"rowNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rowNumber\",\"type\":\"uint256\"}],\"name\":\"pullRow\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes16\"},{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes16\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"disclosureList\",\"outputs\":[{\"name\":\"organization\",\"type\":\"bytes32\"},{\"name\":\"recipient\",\"type\":\"bytes32\"},{\"name\":\"location\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"bytes16\"},{\"name\":\"fundingType\",\"type\":\"bytes1\"},{\"name\":\"date\",\"type\":\"bytes16\"},{\"name\":\"purpose\",\"type\":\"bytes32\"},{\"name\":\"comment\",\"type\":\"bytes32\"},{\"name\":\"amended\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rowNumber\",\"type\":\"uint256\"}],\"name\":\"pullEntry\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes16\"},{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes16\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rowNumber\",\"type\":\"uint256\"},{\"name\":\"organization\",\"type\":\"bytes32\"},{\"name\":\"recipient\",\"type\":\"bytes32\"},{\"name\":\"location\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"bytes16\"},{\"name\":\"fundingType\",\"type\":\"bytes1\"},{\"name\":\"date\",\"type\":\"bytes16\"},{\"name\":\"purpose\",\"type\":\"bytes32\"},{\"name\":\"comment\",\"type\":\"bytes32\"}],\"name\":\"amendEntry\",\"outputs\":[{\"name\":\"newRowNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rowNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"organization\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"location\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"fundingType\",\"type\":\"bytes1\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"purpose\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"bytes32\"}],\"name\":\"disclosureAdded\",\"type\":\"event\"}]","ContractName":"DisclosureManager","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9f36ca007cca0b8d7446e7e900adf77829d917405fe94e4978a070fa347c404a"}]}