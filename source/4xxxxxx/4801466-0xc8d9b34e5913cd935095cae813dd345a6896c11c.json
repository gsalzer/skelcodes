{"status":"1","message":"OK","result":[{"SourceCode":"// Appics tokensale smart contract.\r\n// Developed by Phenom.Team <info@phenom.team>\r\n\r\npragma solidity ^ 0.4.15;\r\n\r\n/**\r\n *   @title SafeMath\r\n *   @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *   @title ERC20\r\n *   @dev Standart ERC20 token interface\r\n */\r\ncontract ERC20 {\r\n    uint256 public totalSupply = 0;\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    function balanceOf(address _owner) public constant returns(uint256);\r\n    function transfer(address _to, uint256 _value) public returns(bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\r\n    function approve(address _spender, uint256 _value) public returns(bool);\r\n    function allowance(address _owner, address _spender) public constant returns(uint256);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n*   @title AppicsICO contract  - takes funds from users and issues tokens\r\n*/\r\ncontract AppicsICO {\r\n    // XAP - Appics token contract\r\n    AppicsToken public XAP = new AppicsToken(this);\r\n    using SafeMath for uint256;\r\n    mapping (address => string) public  keys;\r\n\r\n    // Token price parameters\r\n    // These parametes can be changed only by manager of contract\r\n    uint256 public Rate_Eth = 700; // Rate USD per ETH\r\n    uint256 public Tokens_Per_Dollar_Numerator = 20;// Appics token = 0.15$\r\n    uint256 public Tokens_Per_Dollar_Denominator = 3;// Appics token = 0.15$\r\n    \r\n    // Crowdfunding parameters\r\n    uint256 constant AppicsPart = 20; // 20% of TotalSupply for Appics\r\n    uint256 constant EcosystemPart = 20; // 20% of TotalSupply for Ecosystem\r\n    uint256 constant SteemitPart = 5; // 5% of TotalSupply for Steemit\r\n    uint256 constant BountyPart = 5; // 5% of TotalSupply for Bounty\r\n    uint256 constant icoPart = 50; // 50% of TotalSupply for PublicICO and PrivateOffer\r\n    uint256 constant PreSaleHardCap = 12500000*1e18;\r\n    uint256 constant RoundAHardCap = 25000000*1e18;\r\n    uint256 constant RoundBHardCap = 30000000*1e18;\r\n    uint256 constant RoundCHardCap = 30000000*1e18;\r\n    uint256 constant RoundDHardCap = 22500000*1e18;\r\n    uint256 public PreSaleSold = 0;\r\n    uint256 public RoundASold = 0;\r\n    uint256 public RoundBSold = 0;\r\n    uint256 public RoundCSold = 0;\r\n    uint256 public RoundDSold = 0;        \r\n    uint256 constant TENTHOUSENDLIMIT = 66666666666666666666666;\r\n    // Output ethereum addresses\r\n    address public Company;\r\n    address public AppicsFund;\r\n    address public EcosystemFund;\r\n    address public SteemitFund;\r\n    address public BountyFund;\r\n    address public Manager; // Manager controls contract\r\n    address public Controller_Address1; // First address that is used to buy tokens for other cryptos\r\n    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos\r\n    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos\r\n    address public Oracle; // Oracle address\r\n\r\n    // Possible ICO statuses\r\n    enum StatusICO {\r\n        Created,\r\n        PreSaleStarted,\r\n        PreSalePaused,\r\n        PreSaleFinished,\r\n        RoundAStarted,\r\n        RoundAPaused,\r\n        RoundAFinished,\r\n        RoundBStarted,\r\n        RoundBPaused,\r\n        RoundBFinished,\r\n        RoundCStarted,\r\n        RoundCPaused,\r\n        RoundCFinished,\r\n        RoundDStarted,\r\n        RoundDPaused,\r\n        RoundDFinished\r\n    }\r\n\r\n    StatusICO statusICO = StatusICO.Created;\r\n\r\n    // Events Log\r\n    event LogStartPreSaleRound();\r\n    event LogPausePreSaleRound();\r\n    event LogFinishPreSaleRound(\r\n        address AppicsFund, \r\n        address EcosystemFund,\r\n        address SteemitFund,\r\n        address BountyFund\r\n    );\r\n    event LogStartRoundA();\r\n    event LogPauseRoundA();\r\n    event LogFinishRoundA(\r\n        address AppicsFund, \r\n        address EcosystemFund,\r\n        address SteemitFund,\r\n        address BountyFund\r\n    );\r\n    event LogStartRoundB();\r\n    event LogPauseRoundB();\r\n    event LogFinishRoundB(\r\n        address AppicsFund, \r\n        address EcosystemFund,\r\n        address SteemitFund,\r\n        address BountyFund\r\n    );\r\n    event LogStartRoundC();\r\n    event LogPauseRoundC();\r\n    event LogFinishRoundC(\r\n        address AppicsFund, \r\n        address EcosystemFund,\r\n        address SteemitFund,\r\n        address BountyFund\r\n    );\r\n    event LogStartRoundD();\r\n    event LogPauseRoundD();\r\n    event LogFinishRoundD(\r\n        address AppicsFund, \r\n        address EcosystemFund,\r\n        address SteemitFund,\r\n        address BountyFund\r\n    );\r\n    event LogBuyForInvestor(address investor, uint256 aidValue, string txHash);\r\n    event LogRegister(address investor, string key);\r\n\r\n    // Modifiers\r\n    // Allows execution by the oracle only\r\n    modifier oracleOnly {\r\n        require(msg.sender == Oracle);\r\n        _;\r\n    }\r\n    // Allows execution by the contract manager only\r\n    modifier managerOnly {\r\n        require(msg.sender == Manager);\r\n        _;\r\n    }\r\n    // Allows execution by the one of controllers only\r\n    modifier controllersOnly {\r\n        require(\r\n            (msg.sender == Controller_Address1) || \r\n            (msg.sender == Controller_Address2) || \r\n            (msg.sender == Controller_Address3)\r\n        );\r\n        _;\r\n    }\r\n    // Allows execution if the any round started only\r\n    modifier startedOnly {\r\n        require(\r\n            (statusICO == StatusICO.PreSaleStarted) || \r\n            (statusICO == StatusICO.RoundAStarted) || \r\n            (statusICO == StatusICO.RoundBStarted) ||\r\n            (statusICO == StatusICO.RoundCStarted) ||\r\n            (statusICO == StatusICO.RoundDStarted)\r\n        );\r\n        _;\r\n    }\r\n    // Allows execution if the any round finished only\r\n    modifier finishedOnly {\r\n        require(\r\n            (statusICO == StatusICO.PreSaleFinished) || \r\n            (statusICO == StatusICO.RoundAFinished) || \r\n            (statusICO == StatusICO.RoundBFinished) ||\r\n            (statusICO == StatusICO.RoundCFinished) ||\r\n            (statusICO == StatusICO.RoundDFinished)\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Contract constructor function\r\n    */\r\n    function AppicsICO(\r\n        address _Company,\r\n        address _AppicsFund,\r\n        address _EcosystemFund,\r\n        address _SteemitFund,\r\n        address _BountyFund,\r\n        address _Manager,\r\n        address _Controller_Address1,\r\n        address _Controller_Address2,\r\n        address _Controller_Address3,\r\n        address _Oracle\r\n    )\r\n        public {\r\n        Company = _Company;\r\n        AppicsFund = _AppicsFund;\r\n        EcosystemFund = _EcosystemFund;\r\n        SteemitFund = _SteemitFund;\r\n        BountyFund = _BountyFund;\r\n        Manager = _Manager;\r\n        Controller_Address1 = _Controller_Address1;\r\n        Controller_Address2 = _Controller_Address2;\r\n        Controller_Address3 = _Controller_Address3;\r\n        Oracle = _Oracle;\r\n    }\r\n\r\n   /**\r\n    *   @dev Set rate of ETH and update token price\r\n    *   @param _RateEth       current ETH rate\r\n    */\r\n    function setRate(uint256 _RateEth) external oracleOnly {\r\n        Rate_Eth = _RateEth;\r\n    }\r\n\r\n   /**\r\n    *   @dev Start Pre-Sale\r\n    *   Set ICO status to PreSaleStarted\r\n    */\r\n    function startPreSaleRound() external managerOnly {\r\n        require(statusICO == StatusICO.Created || statusICO == StatusICO.PreSalePaused);\r\n        statusICO = StatusICO.PreSaleStarted;\r\n        LogStartPreSaleRound();\r\n    }\r\n\r\n   /**\r\n    *   @dev Pause Pre-Sale\r\n    *   Set Ico status to PreSalePaused\r\n    */\r\n    function pausePreSaleRound() external managerOnly {\r\n        require(statusICO == StatusICO.PreSaleStarted);\r\n        statusICO = StatusICO.PreSalePaused;\r\n        LogPausePreSaleRound();\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Finish Pre-Sale and mint tokens for AppicsFund, EcosystemFund, SteemitFund,\r\n        RewardFund and ReferralFund\r\n    *   Set Ico status to PreSaleFinished\r\n    */\r\n    function finishPreSaleRound() external managerOnly {\r\n        require(statusICO == StatusICO.PreSaleStarted || statusICO == StatusICO.PreSalePaused);\r\n        uint256 totalAmount = PreSaleSold.mul(100).div(icoPart);\r\n        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));\r\n        statusICO = StatusICO.PreSaleFinished;\r\n        LogFinishPreSaleRound(AppicsFund, EcosystemFund, SteemitFund, BountyFund);\r\n\r\n    }\r\n   \r\n   /**\r\n    *   @dev Start Round A\r\n    *   Set ICO status to RoundAStarted\r\n    */\r\n    function startRoundA() external managerOnly {\r\n        require(statusICO == StatusICO.PreSaleFinished || statusICO == StatusICO.RoundAPaused);\r\n        statusICO = StatusICO.RoundAStarted;\r\n        LogStartRoundA();\r\n    }\r\n\r\n   /**\r\n    *   @dev Pause Round A\r\n    *   Set Ico status to RoundAPaused\r\n    */\r\n    function pauseRoundA() external managerOnly {\r\n        require(statusICO == StatusICO.RoundAStarted);\r\n        statusICO = StatusICO.RoundAPaused;\r\n        LogPauseRoundA();\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Finish Round A and mint tokens AppicsFund, EcosystemFund, SteemitFund,\r\n        RewardFund and ReferralFund\r\n    *   Set Ico status to RoundAFinished\r\n    */\r\n    function finishRoundA() external managerOnly {\r\n        require(statusICO == StatusICO.RoundAStarted || statusICO == StatusICO.RoundAPaused);\r\n        uint256 totalAmount = RoundASold.mul(100).div(icoPart);\r\n        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));\r\n        statusICO = StatusICO.RoundAFinished;\r\n        LogFinishRoundA(AppicsFund, EcosystemFund, SteemitFund, BountyFund);\r\n    }\r\n\r\n   /**\r\n    *   @dev Start Round B\r\n    *   Set ICO status to RoundBStarted\r\n    */\r\n    function startRoundB() external managerOnly {\r\n        require(statusICO == StatusICO.RoundAFinished || statusICO == StatusICO.RoundBPaused);\r\n        statusICO = StatusICO.RoundBStarted;\r\n        LogStartRoundB();\r\n    }\r\n\r\n   /**\r\n    *   @dev Pause Round B\r\n    *   Set Ico status to RoundBPaused\r\n    */\r\n    function pauseRoundB() external managerOnly {\r\n        require(statusICO == StatusICO.RoundBStarted);\r\n        statusICO = StatusICO.RoundBPaused;\r\n        LogPauseRoundB();\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Finish Round B and mint tokens AppicsFund, EcosystemFund, SteemitFund,\r\n        RewardFund and ReferralFund\r\n    *   Set Ico status to RoundBFinished\r\n    */\r\n    function finishRoundB() external managerOnly {\r\n        require(statusICO == StatusICO.RoundBStarted || statusICO == StatusICO.RoundBPaused);\r\n        uint256 totalAmount = RoundBSold.mul(100).div(icoPart);\r\n        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));\r\n        statusICO = StatusICO.RoundBFinished;\r\n        LogFinishRoundB(AppicsFund, EcosystemFund, SteemitFund, BountyFund);\r\n    }\r\n\r\n   /**\r\n    *   @dev Start Round C\r\n    *   Set ICO status to RoundCStarted\r\n    */\r\n    function startRoundC() external managerOnly {\r\n        require(statusICO == StatusICO.RoundBFinished || statusICO == StatusICO.RoundCPaused);\r\n        statusICO = StatusICO.RoundCStarted;\r\n        LogStartRoundC();\r\n    }\r\n\r\n   /**\r\n    *   @dev Pause Round C\r\n    *   Set Ico status to RoundCPaused\r\n    */\r\n    function pauseRoundC() external managerOnly {\r\n        require(statusICO == StatusICO.RoundCStarted);\r\n        statusICO = StatusICO.RoundCPaused;\r\n        LogPauseRoundC();\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Finish Round C and mint tokens AppicsFund, EcosystemFund, SteemitFund,\r\n        RewardFund and ReferralFund\r\n    *   Set Ico status to RoundCStarted\r\n    */\r\n    function finishRoundC() external managerOnly {\r\n        require(statusICO == StatusICO.RoundCStarted || statusICO == StatusICO.RoundCPaused);\r\n        uint256 totalAmount = RoundCSold.mul(100).div(icoPart);\r\n        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));\r\n        statusICO = StatusICO.RoundCFinished;\r\n        LogFinishRoundC(AppicsFund, EcosystemFund, SteemitFund, BountyFund);\r\n    }\r\n\r\n   /**\r\n    *   @dev Start Round D\r\n    *   Set ICO status to RoundDStarted\r\n    */\r\n    function startRoundD() external managerOnly {\r\n        require(statusICO == StatusICO.RoundCFinished || statusICO == StatusICO.RoundDPaused);\r\n        statusICO = StatusICO.RoundDStarted;\r\n        LogStartRoundD();\r\n    }\r\n\r\n   /**\r\n    *   @dev Pause Round D\r\n    *   Set Ico status to RoundDPaused\r\n    */\r\n    function pauseRoundD() external managerOnly {\r\n        require(statusICO == StatusICO.RoundDStarted);\r\n        statusICO = StatusICO.RoundDPaused;\r\n        LogPauseRoundD();\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Finish Round D and mint tokens AppicsFund, EcosystemFund, SteemitFund,\r\n        RewardFund and ReferralFund\r\n    *   Set Ico status to RoundDFinished\r\n    */\r\n    function finishRoundD() external managerOnly {\r\n        require(statusICO == StatusICO.RoundDStarted || statusICO == StatusICO.RoundDPaused);\r\n        uint256 totalAmount = RoundDSold.mul(100).div(icoPart);\r\n        XAP.mintTokens(AppicsFund, AppicsPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(EcosystemFund, EcosystemPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(SteemitFund, SteemitPart.mul(totalAmount).div(100));\r\n        XAP.mintTokens(BountyFund, BountyPart.mul(totalAmount).div(100));\r\n        statusICO = StatusICO.RoundDFinished;\r\n        LogFinishRoundD(AppicsFund, EcosystemFund, SteemitFund, BountyFund);\r\n    }    \r\n\r\n\r\n   /**\r\n    *   @dev Enable token transfers\r\n    */\r\n    function unfreeze() external managerOnly {\r\n        XAP.defrostTokens();\r\n    }\r\n\r\n   /**\r\n    *   @dev Disable token transfers\r\n    */\r\n    function freeze() external managerOnly {\r\n        XAP.frostTokens();\r\n    }\r\n\r\n   /**\r\n    *   @dev Fallback function calls buyTokens() function to buy tokens\r\n    *        when investor sends ETH to address of ICO contract\r\n    */\r\n    function() external payable {\r\n        uint256 tokens; \r\n        tokens = msg.value.mul(Tokens_Per_Dollar_Numerator).mul(Rate_Eth);\r\n        // rounding tokens amount:\r\n        tokens = tokens.div(Tokens_Per_Dollar_Denominator);\r\n        buyTokens(msg.sender, tokens);\r\n    }\r\n\r\n   /**\r\n    *   @dev Issues tokens for users who made purchases in other cryptocurrencies\r\n    *   @param _investor     address the tokens will be issued to\r\n    *   @param _xapValue     number of Appics tokens\r\n    *   @param _txHash       transaction hash of investor's payment\r\n    */\r\n    function buyForInvestor(\r\n        address _investor,\r\n        uint256 _xapValue,\r\n        string _txHash\r\n    )\r\n        external\r\n        controllersOnly\r\n        startedOnly {\r\n        buyTokens(_investor, _xapValue);        \r\n        LogBuyForInvestor(_investor, _xapValue, _txHash);\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Issue tokens for investors who paid in ether\r\n    *   @param _investor     address which the tokens will be issued to\r\n    *   @param _xapValue     number of Appics tokens\r\n    */\r\n    function buyTokens(address _investor, uint256 _xapValue) internal startedOnly {\r\n        require(_xapValue > 0);\r\n        uint256 bonus = getBonus(_xapValue);\r\n        uint256 total = _xapValue.add(bonus);\r\n        if (statusICO == StatusICO.PreSaleStarted) {\r\n            require (PreSaleSold.add(total) <= PreSaleHardCap);\r\n            require(_xapValue > TENTHOUSENDLIMIT);\r\n            PreSaleSold = PreSaleSold.add(total);\r\n        }\r\n        if (statusICO == StatusICO.RoundAStarted) {\r\n            require (RoundASold.add(total) <= RoundAHardCap);\r\n            RoundASold = RoundASold.add(total);\r\n        }\r\n        if (statusICO == StatusICO.RoundBStarted) {\r\n            require (RoundBSold.add(total) <= RoundBHardCap);\r\n            RoundBSold = RoundBSold.add(total);\r\n        }\r\n        if (statusICO == StatusICO.RoundCStarted) {\r\n            require (RoundCSold.add(total) <= RoundCHardCap);\r\n            RoundCSold = RoundCSold.add(total);\r\n        }\r\n        if (statusICO == StatusICO.RoundDStarted) {\r\n            require (RoundDSold.add(total) <= RoundDHardCap);\r\n            RoundDSold = RoundDSold.add(total);\r\n        }\r\n        XAP.mintTokens(_investor, total);\r\n    }\r\n\r\n   /**\r\n    *   @dev Calculates bonus\r\n    *   @param _value        amount of tokens\r\n    *   @return              bonus value\r\n    */\r\n    function getBonus(uint256 _value)\r\n        public\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        uint256 bonus = 0;\r\n        if (statusICO == StatusICO.PreSaleStarted) {\r\n            bonus = _value.mul(20).div(100);\r\n        }\r\n        if (statusICO == StatusICO.RoundAStarted) {\r\n            bonus = _value.mul(15).div(100); \r\n        }\r\n        if (statusICO == StatusICO.RoundBStarted) {\r\n            bonus = _value.mul(10).div(100); \r\n        }\r\n        if (statusICO == StatusICO.RoundCStarted) {\r\n            bonus = _value.mul(5).div(100); \r\n        }\r\n        return bonus;\r\n    }\r\n    \r\n    function register(string _key) public {\r\n        keys[msg.sender] = _key;\r\n        LogRegister(msg.sender, _key);\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Allows Company withdraw investments when round is over\r\n    */\r\n    function withdrawEther() external managerOnly finishedOnly{\r\n        Company.transfer(this.balance);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n *   @title \r\n *   @dev Appics token contract\r\n */\r\ncontract AppicsToken is ERC20 {\r\n    using SafeMath for uint256;\r\n    string public name = \"Appics\";\r\n    string public symbol = \"XAP\";\r\n    uint256 public decimals = 18;\r\n\r\n    // Ico contract address\r\n    address public ico;\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    // Disables/enables token transfers\r\n    bool public tokensAreFrozen = true;\r\n\r\n    // Allows execution by the ico only\r\n    modifier icoOnly {\r\n        require(msg.sender == ico);\r\n        _;\r\n    }\r\n\r\n   /**\r\n    *   @dev Contract constructor function sets Ico address\r\n    *   @param _ico          ico address\r\n    */\r\n    function AppicsToken(address _ico) public {\r\n        ico = _ico;\r\n    }\r\n\r\n   /**\r\n    *   @dev Mint tokens\r\n    *   @param _holder       beneficiary address the tokens will be issued to\r\n    *   @param _value        number of tokens to issue\r\n    */\r\n    function mintTokens(address _holder, uint256 _value) external icoOnly {\r\n        require(_value > 0);\r\n        balances[_holder] = balances[_holder].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        Transfer(0x0, _holder, _value);\r\n    }\r\n\r\n   /**\r\n    *   @dev Enables token transfers\r\n    */\r\n    function defrostTokens() external icoOnly {\r\n      tokensAreFrozen = false;\r\n    }\r\n\r\n    /**\r\n    *   @dev Disables token transfers\r\n    */\r\n    function frostTokens() external icoOnly {\r\n      tokensAreFrozen = true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Burn Tokens\r\n    *   @param _investor     token holder address which the tokens will be burnt\r\n    *   @param _value        number of tokens to burn\r\n    */\r\n    function burnTokens(address _investor, uint256 _value) external icoOnly {\r\n        require(balances[_investor] > 0);\r\n        totalSupply = totalSupply.sub(_value);\r\n        balances[_investor] = balances[_investor].sub(_value);\r\n        Burn(_investor, _value);\r\n    }\r\n\r\n   /**\r\n    *   @dev Get balance of investor\r\n    *   @param _owner        investor's address\r\n    *   @return              balance of investor\r\n    */\r\n    function balanceOf(address _owner) public constant returns(uint256) {\r\n      return balances[_owner];\r\n    }\r\n\r\n   /**\r\n    *   @dev Send coins\r\n    *   throws on any error rather then return a false flag to minimize\r\n    *   user errors\r\n    *   @param _to           target address\r\n    *   @param _amount       transfer amount\r\n    *\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transfer(address _to, uint256 _amount) public returns(bool) {\r\n        require(!tokensAreFrozen);\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev An account/contract attempts to get the coins\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   @param _from         source address\r\n    *   @param _to           target address\r\n    *   @param _amount       transfer amount\r\n    *\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {\r\n        require(!tokensAreFrozen);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows another account/contract to spend some tokens on its behalf\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   also, to minimize the risk of the approve/transferFrom attack vector\r\n    *   approve has to be called twice in 2 separate transactions - once to\r\n    *   change the allowance to 0 and secondly to change it to the new allowance\r\n    *   value\r\n    *\r\n    *   @param _spender      approved address\r\n    *   @param _amount       allowance amount\r\n    *\r\n    *   @return true if the approval was successful\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns(bool) {\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    *   @param _owner        the address which owns the funds\r\n    *   @param _spender      the address which will spend the funds\r\n    *\r\n    *   @return              the amount of tokens still avaible for the spender\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns(uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_xapValue\",\"type\":\"uint256\"},{\"name\":\"_txHash\",\"type\":\"string\"}],\"name\":\"buyForInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishRoundB\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SteemitFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RoundASold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishRoundC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishRoundA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startRoundB\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_RateEth\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startRoundD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RoundCSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startRoundC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BountyFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EcosystemFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Company\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Tokens_Per_Dollar_Numerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseRoundD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseRoundC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"keys\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishRoundD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseRoundA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseRoundB\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RoundDSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RoundBSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startRoundA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishPreSaleRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pausePreSaleRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PreSaleSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreSaleRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Controller_Address2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"XAP\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AppicsFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Rate_Eth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Tokens_Per_Dollar_Denominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"string\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_Company\",\"type\":\"address\"},{\"name\":\"_AppicsFund\",\"type\":\"address\"},{\"name\":\"_EcosystemFund\",\"type\":\"address\"},{\"name\":\"_SteemitFund\",\"type\":\"address\"},{\"name\":\"_BountyFund\",\"type\":\"address\"},{\"name\":\"_Manager\",\"type\":\"address\"},{\"name\":\"_Controller_Address1\",\"type\":\"address\"},{\"name\":\"_Controller_Address2\",\"type\":\"address\"},{\"name\":\"_Controller_Address3\",\"type\":\"address\"},{\"name\":\"_Oracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartPreSaleRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPausePreSaleRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"AppicsFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"EcosystemFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"SteemitFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"BountyFund\",\"type\":\"address\"}],\"name\":\"LogFinishPreSaleRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartRoundA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPauseRoundA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"AppicsFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"EcosystemFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"SteemitFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"BountyFund\",\"type\":\"address\"}],\"name\":\"LogFinishRoundA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartRoundB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPauseRoundB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"AppicsFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"EcosystemFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"SteemitFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"BountyFund\",\"type\":\"address\"}],\"name\":\"LogFinishRoundB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartRoundC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPauseRoundC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"AppicsFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"EcosystemFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"SteemitFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"BountyFund\",\"type\":\"address\"}],\"name\":\"LogFinishRoundC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartRoundD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPauseRoundD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"AppicsFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"EcosystemFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"SteemitFund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"BountyFund\",\"type\":\"address\"}],\"name\":\"LogFinishRoundD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"aidValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txHash\",\"type\":\"string\"}],\"name\":\"LogBuyForInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"string\"}],\"name\":\"LogRegister\",\"type\":\"event\"}]","ContractName":"AppicsICO","CompilerVersion":"v0.4.20-nightly.2017.12.20+commit.efc198d5","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004e147b34ff07cf024e47dea28493cf1f6a7181ed000000000000000000000000437c8f684e5641d6e3cfe2517423f5d360b55951000000000000000000000000017dbae4f84914257c5c9320ea8e661f346ab612000000000000000000000000eff1de66f55a13589c16578083f33a23ba9f88a900000000000000000000000008c8a63736fd20ddef22cc24663c9a6cf69e7aaf0000000000000000000000009077c9bd30b67dadfd477a85dad4787703e2c72b000000000000000000000000f4f4c92a02e222ab0402e813105a7c157932309a000000000000000000000000bd4289509352ee922bcfbbeda8e95b2879d2be350000000000000000000000006ca3b524441aa9c66a6d1e9f805fd56f3efede1d00000000000000000000000036276646de32e8ef43b1b457ed7ab61743035fc7","Library":"","SwarmSource":"bzzr://6f1b717ae5f336fb406bb767f520ae6eb7ce88a7b51a51e1097f91568ebf84d4"}]}