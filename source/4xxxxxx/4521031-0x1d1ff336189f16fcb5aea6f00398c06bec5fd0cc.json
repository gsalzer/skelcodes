{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Edgeless Casino Proxy Contract. Serves as a proxy for game functionality.\r\n * Allows the players to deposit and withdraw funds.\r\n * Allows authorized addresses to make game transactions.\r\n * author: Julia Altenried\r\n **/\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\ncontract token {\r\n\tfunction transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\r\n\t\r\n\tfunction transfer(address receiver, uint amount) public returns(bool success) {}\r\n\t\r\n\tfunction balanceOf(address holder) public constant returns(uint) {}\r\n}\r\n\r\ncontract owned {\r\n  address public owner;\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function owned() public{\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner(address newOwner) onlyOwner public{\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract safeMath {\r\n\t//internals\r\n\tfunction safeSub(uint a, uint b) constant internal returns(uint) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction safeAdd(uint a, uint b) constant internal returns(uint) {\r\n\t\tuint c = a + b;\r\n\t\tassert(c >= a && c >= b);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\tfunction safeMul(uint a, uint b) constant internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract casinoBank is owned, safeMath{\r\n\t/** the total balance of all players with 4 virtual decimals **/\r\n\tuint public playerBalance;\r\n\t/** the balance per player in edgeless tokens with 4 virtual decimals */\r\n  mapping(address=>uint) public balanceOf;\r\n\t/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */\r\n\tmapping(address=>uint) public withdrawAfter;\r\n\t/** the price per kgas in tokens (4 decimals) */\r\n\tuint public gasPrice = 20;\r\n\t/** the edgeless token contract */\r\n\ttoken edg;\r\n\t/** owner should be able to close the contract is nobody has been using it for at least 30 days */\r\n\tuint public closeAt;\r\n\t/** informs listeners how many tokens were deposited for a player */\r\n\tevent Deposit(address _player, uint _numTokens, bool _chargeGas);\r\n\t/** informs listeners how many tokens were withdrawn from the player to the receiver address */\r\n\tevent Withdrawal(address _player, address _receiver, uint _numTokens);\r\n\t\r\n\tfunction casinoBank(address tokenContract) public{\r\n\t\tedg = token(tokenContract);\r\n\t}\r\n\t\r\n\t/**\r\n\t* accepts deposits for an arbitrary address.\r\n\t* retrieves tokens from the message sender and adds them to the balance of the specified address.\r\n\t* edgeless tokens do not have any decimals, but are represented on this contract with 4 decimals.\r\n\t* @param receiver  address of the receiver\r\n\t*        numTokens number of tokens to deposit (0 decimals)\r\n\t*\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user's edgeless token balance\r\n\t**/\r\n\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive{\r\n\t\trequire(numTokens > 0);\r\n\t\tuint value = safeMul(numTokens,10000); \r\n\t\tif(chargeGas) value = safeSub(value, msg.gas/1000 * gasPrice);\r\n\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\r\n\t\tbalanceOf[receiver] = safeAdd(balanceOf[receiver], value);\r\n\t\tplayerBalance = safeAdd(playerBalance, value);\r\n\t\tDeposit(receiver, numTokens, chargeGas);\r\n  }\r\n\t\r\n\t/**\r\n\t* If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first.\r\n\t* This method sets the earliest possible withdrawal date to 7 minutes from now. \r\n\t* Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined.\r\n\t**/\r\n\tfunction requestWithdrawal() public{\r\n\t\twithdrawAfter[msg.sender] = now + 7 minutes;\r\n\t}\r\n\t\r\n\t/**\r\n\t* In case the user requested a withdrawal and changes his mind.\r\n\t* Necessary to be able to continue playing.\r\n\t**/\r\n\tfunction cancelWithdrawalRequest() public{\r\n\t\twithdrawAfter[msg.sender] = 0;\r\n\t}\r\n\t\r\n\t/**\r\n\t* withdraws an amount from the user balance if 7 minutes passed since the request.\r\n\t* @param amount the amount of tokens to withdraw\r\n\t**/\r\n\tfunction withdraw(uint amount) public keepAlive{\r\n\t\trequire(withdrawAfter[msg.sender]>0 && now>withdrawAfter[msg.sender]);\r\n\t\twithdrawAfter[msg.sender] = 0;\r\n\t\tuint value = safeMul(amount,10000);\r\n\t\tbalanceOf[msg.sender]=safeSub(balanceOf[msg.sender],value);\r\n\t\tplayerBalance = safeSub(playerBalance, value);\r\n\t\tassert(edg.transfer(msg.sender, amount));\r\n\t\tWithdrawal(msg.sender, msg.sender, amount);\r\n\t}\r\n\t\r\n\t/**\r\n\t* lets the owner withdraw from the bankroll\r\n\t* @param numTokens the number of tokens to withdraw (0 decimals)\r\n\t**/\r\n\tfunction withdrawBankroll(uint numTokens) public onlyOwner {\r\n\t\trequire(numTokens <= bankroll());\r\n\t\tassert(edg.transfer(owner, numTokens));\r\n\t}\r\n\t\r\n\t/**\r\n\t* returns the current bankroll in tokens with 0 decimals\r\n\t**/\r\n\tfunction bankroll() constant public returns(uint){\r\n\t\treturn safeSub(edg.balanceOf(address(this)), playerBalance/10000);\r\n\t}\r\n\t\r\n\t/** \r\n\t* lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days \r\n\t*/\r\n  function close() onlyOwner public{\r\n\t\tif(playerBalance == 0) selfdestruct(owner);\r\n\t\tif(closeAt == 0) closeAt = now + 30 days;\r\n\t\telse if(closeAt < now) selfdestruct(owner);\r\n  }\r\n\t\r\n\t/**\r\n\t* in case close has been called accidentally.\r\n\t**/\r\n\tfunction open() onlyOwner public{\r\n\t\tcloseAt = 0;\r\n\t}\r\n\t\r\n\t/**\r\n\t* make sure the contract is not in process of being closed.\r\n\t**/\r\n\tmodifier isAlive {\r\n\t\trequire(closeAt == 0);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t/**\r\n\t* delays the time of closing.\r\n\t**/\r\n\tmodifier keepAlive {\r\n\t\tif(closeAt > 0) closeAt = now + 30 days;\r\n\t\t_;\r\n\t}\r\n}\r\n\r\ncontract casinoProxy is casinoBank{\r\n\t/** indicates if an address is authorized to call game functions  */\r\n  mapping(address => bool) public authorized;\r\n  /** indicates if the user allowed a casino game address to move his/her funds **/\r\n  mapping(address => mapping(address => bool)) public authorizedByUser;\r\n  /** counts how often an address has been deauthorized by the user => make sure signatzures can't be reused**/\r\n  mapping(address => mapping(address => uint8)) public lockedByUser;\r\n\t/** list of casino game contract addresses */\r\n  address[] public casinoGames;\r\n\t/** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */\r\n\tmapping(address => uint) public count;\r\n\r\n\tmodifier onlyAuthorized {\r\n    require(authorized[msg.sender]);\r\n    _;\r\n  }\r\n\t\r\n\tmodifier onlyCasinoGames {\r\n\t\tbool isCasino;\r\n\t\tfor (uint i = 0; i < casinoGames.length; i++){\r\n\t\t\tif(msg.sender == casinoGames[i]){\r\n\t\t\t\tisCasino = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(isCasino);\r\n\t\t_;\r\n\t}\r\n  \r\n  /**\r\n  * creates a new casino wallet.\r\n  * @param authorizedAddress the address which may send transactions to the Edgeless Casino\r\n  *        blackjackAddress  the address of the Edgeless blackjack contract\r\n\t*\t\t\t\t tokenContract     the address of the Edgeless token contract\r\n  **/\r\n  function casinoProxy(address authorizedAddress, address blackjackAddress, address tokenContract) casinoBank(tokenContract) public{\r\n    authorized[authorizedAddress] = true;\r\n    casinoGames.push(blackjackAddress);\r\n  }\r\n\r\n\t/**\r\n\t* shifts tokens from the contract balance to the player or the other way round.\r\n\t* only callable from an edgeless casino contract. sender must have been approved by the user.\r\n\t* @param player the address of the player\r\n\t*        numTokens the amount of tokens to shift with 4 decimals\r\n\t*\t\t\t\t isReceiver tells if the player is receiving token or the other way round\r\n\t**/\r\n\tfunction shift(address player, uint numTokens, bool isReceiver) public onlyCasinoGames{\r\n\t\trequire(authorizedByUser[player][msg.sender]);\r\n\t\tvar gasCost = msg.gas/1000 * gasPrice;//at this point a good deal of the gas has already been consumend, maybe better to have fix price\r\n\t\tif(isReceiver){\r\n\t\t\tnumTokens = safeSub(numTokens, gasCost);\r\n\t\t\tbalanceOf[player] = safeAdd(balanceOf[player], numTokens);\r\n\t\t\tplayerBalance = safeAdd(playerBalance, numTokens);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tnumTokens = safeAdd(numTokens, gasCost);\r\n\t\t\tbalanceOf[player] = safeSub(balanceOf[player], numTokens);\r\n\t\t\tplayerBalance = safeSub(playerBalance, numTokens);\r\n\t\t}\r\n\t}\r\n  \r\n  /**\r\n  * transfers an amount from the contract balance to the owner's wallet.\r\n  * @param receiver the receiver address\r\n\t*\t\t\t\t amount   the amount of tokens to withdraw (0 decimals)\r\n\t*\t\t\t\t v,r,s \t\tthe signature of the player\r\n  **/\r\n  function withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive{\r\n\t\tuint gasCost =  msg.gas/1000 * gasPrice;\r\n\t\tvar player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s);\r\n\t\tcount[receiver]++;\r\n\t\tuint value = safeAdd(safeMul(amount,10000), gasCost);\r\n    balanceOf[player] = safeSub(balanceOf[player], value);\r\n\t\tplayerBalance = safeSub(playerBalance, value);\r\n    assert(edg.transfer(receiver, amount));\r\n\t\tWithdrawal(player, receiver, amount);\r\n  }\r\n  \r\n  /**\r\n  * update a casino game address in case of a new contract or a new casino game\r\n  * @param game       the index of the game \r\n  *        newAddress the new address of the game\r\n  **/\r\n  function setGameAddress(uint8 game, address newAddress) public onlyOwner{\r\n    if(game<casinoGames.length) casinoGames[game] = newAddress;\r\n    else casinoGames.push(newAddress);\r\n  }\r\n  \r\n  /**\r\n  * authorize a address to call game functions.\r\n  * @param addr the address to be authorized\r\n  **/\r\n  function authorize(address addr) public onlyOwner{\r\n    authorized[addr] = true;\r\n  }\r\n  \r\n  /**\r\n  * deauthorize a address to call game functions.\r\n  * @param addr the address to be deauthorized\r\n  **/\r\n  function deauthorize(address addr) public onlyOwner{\r\n    authorized[addr] = false;\r\n  }\r\n  \r\n  /**\r\n   * authorize a casino contract address to access the funds\r\n   * @param casinoAddress the address of the casino contract\r\n   *\t\t\t\tv, r, s the player's signature of the casino address, the number of times the address has already been locked \r\n   *\t\t\t\t\t\t\t\tand a bool stating if the signature is meant for authourization (true) or deauthorization (false)\r\n   * */\r\n  function authorizeCasino(address playerAddress, address casinoAddress, uint8 v, bytes32 r, bytes32 s) public{\r\n  \taddress player = ecrecover(keccak256(casinoAddress,lockedByUser[playerAddress][casinoAddress],true), v, r, s);\r\n  \trequire(player == playerAddress);\r\n  \tauthorizedByUser[player][casinoAddress] = true;\r\n  }\r\n \r\n  /**\r\n   * deauthorize a casino contract address to access the funds\r\n   * @param casinoAddress the address of the casino contract\r\n   *    \t\tv, r, s the player's signature of the casino address, the number of times the address has already been locked \r\n   *\t\t\t\t\t\t\t\tand a bool stating if the signature is meant for authourization (true) or deauthorization (false)\r\n   * */\r\n  function deauthorizeCasino(address playerAddress, address casinoAddress, uint8 v, bytes32 r, bytes32 s) public{\r\n  \taddress player = ecrecover(keccak256(casinoAddress,lockedByUser[playerAddress][casinoAddress],false), v, r, s);\r\n  \trequire(player == playerAddress);\r\n  \tauthorizedByUser[player][casinoAddress] = false;\r\n  \tlockedByUser[player][casinoAddress]++;//make it impossible to reuse old signature to authorize the address again\r\n  }\r\n\t\r\n\t/**\r\n\t* updates the price per 1000 gas in EDG.\r\n\t* @param price the new gas price (4 decimals, max 0.0256 EDG)\r\n\t**/\r\n\tfunction setGasPrice(uint8 price) public onlyOwner{\r\n\t\tgasPrice = price;\r\n\t}\r\n  \r\n  /**\r\n  * Forwards a move to the corresponding game contract if the data has been signed by the client.\r\n  * The casino contract ensures it is no duplicate move.\r\n  * @param game  specifies which game contract to call\r\n  *        data  the function call\r\n  *        v,r,s the player's signature of the data\r\n  **/\r\n  function move(uint8 game, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive{\r\n    require(game < casinoGames.length);\r\n    var player = ecrecover(keccak256(data), v, r, s);\r\n\t\trequire(withdrawAfter[player] == 0 || now<withdrawAfter[player]);\r\n\t\tassert(checkAddress(player, data));\r\n    assert(casinoGames[game].call(data));\r\n  }\r\n\r\n  /**\r\n   * checks if the given address is passed as first parameters in the bytes field\r\n   * @param player the player address\r\n   *\t\t\t\tdata the function call\r\n   * */\r\n  function checkAddress(address player, bytes data) constant internal returns(bool){\r\n  \tbytes memory ba;\r\n  \tassembly {\r\n      let m := mload(0x40)\r\n      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, player))\r\n      mstore(0x40, add(m, 52))\r\n      ba := m\r\n   }\r\n   for(uint8 i = 0; i < 20; i++){\r\n   \tif(data[16+i]!=ba[i]) return false;\r\n   }\r\n   return true;\r\n  }\r\n\t\r\n\t\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"casinoAddress\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"authorizeCasino\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedByUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedByUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"numTokens\",\"type\":\"uint256\"},{\"name\":\"isReceiver\",\"type\":\"bool\"}],\"name\":\"shift\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint8\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"numTokens\",\"type\":\"uint256\"},{\"name\":\"chargeGas\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawAfter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"casinoAddress\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"deauthorizeCasino\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"uint8\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"move\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"casinoGames\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelWithdrawalRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"uint8\"},{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setGameAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"authorizedAddress\",\"type\":\"address\"},{\"name\":\"blackjackAddress\",\"type\":\"address\"},{\"name\":\"tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_chargeGas\",\"type\":\"bool\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"casinoProxy","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007ab5dfc486af477c19055d0e34ba0436b32c5e54000000000000000000000000fc44094c53832e8a3cea0e97600950c11f14fe5f00000000000000000000000008711d3b02c8758f2fb3ab4e80228418a7f8e39c","Library":"","SwarmSource":"bzzr://2b453c58e9eec3e6b72217854d1935e55ac7cb0c071694c78ed619f264f457f8"}]}