{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n// NB: this is the newer ERC20 returning bool, need different book contract for older style tokens\r\ncontract ERC20 {\r\n  function totalSupply() constant returns (uint);\r\n  function balanceOf(address _owner) constant returns (uint balance);\r\n  function transfer(address _to, uint _value) returns (bool success);\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n  function approve(address _spender, uint _value) returns (bool success);\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n  event Transfer(address indexed _from, address indexed _to, uint _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// UbiTok.io limit order book with an \"nice\" ERC20 token as base, ETH as quoted, and standard fees.\r\n// Copyright (c) Bonnag Limited. All Rights Reserved.\r\n//\r\ncontract BookERC20EthV1 {\r\n\r\n  enum BookType {\r\n    ERC20EthV1\r\n  }\r\n\r\n  enum Direction {\r\n    Invalid,\r\n    Buy,\r\n    Sell\r\n  }\r\n\r\n  enum Status {\r\n    Unknown,\r\n    Rejected,\r\n    Open,\r\n    Done,\r\n    NeedsGas,\r\n    Sending, // not used by contract - web only\r\n    FailedSend, // not used by contract - web only\r\n    FailedTxn // not used by contract - web only\r\n  }\r\n\r\n  enum ReasonCode {\r\n    None,\r\n    InvalidPrice,\r\n    InvalidSize,\r\n    InvalidTerms,\r\n    InsufficientFunds,\r\n    WouldTake,\r\n    Unmatched,\r\n    TooManyMatches,\r\n    ClientCancel\r\n  }\r\n\r\n  enum Terms {\r\n    GTCNoGasTopup,\r\n    GTCWithGasTopup,\r\n    ImmediateOrCancel,\r\n    MakerOnly\r\n  }\r\n\r\n  struct Order {\r\n    // these are immutable once placed:\r\n\r\n    address client;\r\n    uint16 price;              // packed representation of side + price\r\n    uint sizeBase;\r\n    Terms terms;\r\n\r\n    // these are mutable until Done or Rejected:\r\n    \r\n    Status status;\r\n    ReasonCode reasonCode;\r\n    uint128 executedBase;      // gross amount executed in base currency (before fee deduction)\r\n    uint128 executedCntr;      // gross amount executed in counter currency (before fee deduction)\r\n    uint128 feesBaseOrCntr;    // base for buy, cntr for sell\r\n    uint128 feesRwrd;\r\n  }\r\n  \r\n  struct OrderChain {\r\n    uint128 firstOrderId;\r\n    uint128 lastOrderId;\r\n  }\r\n\r\n  struct OrderChainNode {\r\n    uint128 nextOrderId;\r\n    uint128 prevOrderId;\r\n  }\r\n  \r\n  enum ClientPaymentEventType {\r\n    Deposit,\r\n    Withdraw,\r\n    TransferFrom,\r\n    Transfer\r\n  }\r\n\r\n  enum BalanceType {\r\n    Base,\r\n    Cntr,\r\n    Rwrd\r\n  }\r\n\r\n  event ClientPaymentEvent(\r\n    address indexed client,\r\n    ClientPaymentEventType clientPaymentEventType,\r\n    BalanceType balanceType,\r\n    int clientBalanceDelta\r\n  );\r\n\r\n  enum ClientOrderEventType {\r\n    Create,\r\n    Continue,\r\n    Cancel\r\n  }\r\n\r\n  event ClientOrderEvent(\r\n    address indexed client,\r\n    ClientOrderEventType clientOrderEventType,\r\n    uint128 orderId\r\n  );\r\n\r\n  enum MarketOrderEventType {\r\n    // orderCount++, depth += depthBase\r\n    Add,\r\n    // orderCount--, depth -= depthBase\r\n    Remove,\r\n    // orderCount--, depth -= depthBase, traded += tradeBase\r\n    // (depth change and traded change differ when tiny remaining amount refunded)\r\n    CompleteFill,\r\n    // orderCount unchanged, depth -= depthBase, traded += tradeBase\r\n    PartialFill\r\n  }\r\n\r\n  // these events can be used to build an order book or watch for fills\r\n  // note that the orderId and price are those of the maker\r\n  event MarketOrderEvent(\r\n    uint256 indexed eventTimestamp,\r\n    uint128 indexed orderId,\r\n    MarketOrderEventType marketOrderEventType,\r\n    uint16 price,\r\n    uint depthBase,\r\n    uint tradeBase\r\n  );\r\n\r\n  // the base token (e.g. TEST)\r\n  \r\n  ERC20 baseToken;\r\n\r\n  // minimum order size (inclusive)\r\n  uint constant baseMinInitialSize = 100 finney;\r\n\r\n  // if following partial match, the remaning gets smaller than this, remove from book and refund:\r\n  // generally we make this 10% of baseMinInitialSize\r\n  uint constant baseMinRemainingSize = 10 finney;\r\n\r\n  // maximum order size (exclusive)\r\n  // chosen so that even multiplied by the max price (or divided by the min price),\r\n  // and then multiplied by ethRwrdRate, it still fits in 2^127, allowing us to save\r\n  // some gas by storing executed + fee fields as uint128.\r\n  // even with 18 decimals, this still allows order sizes up to 1,000,000,000.\r\n  // if we encounter a token with e.g. 36 decimals we'll have to revisit ...\r\n  uint constant baseMaxSize = 10 ** 30;\r\n\r\n  // the counter currency (ETH)\r\n  // (no address because it is ETH)\r\n\r\n  // avoid the book getting cluttered up with tiny amounts not worth the gas\r\n  uint constant cntrMinInitialSize = 10 finney;\r\n\r\n  // see comments for baseMaxSize\r\n  uint constant cntrMaxSize = 10 ** 30;\r\n\r\n  // the reward token that can be used to pay fees (UBI)\r\n\r\n  ERC20 rwrdToken;\r\n\r\n  // used to convert ETH amount to reward tokens when paying fee with reward tokens\r\n  uint constant ethRwrdRate = 1000;\r\n  \r\n  // funds that belong to clients (base, counter, and reward)\r\n\r\n  mapping (address => uint) balanceBaseForClient;\r\n  mapping (address => uint) balanceCntrForClient;\r\n  mapping (address => uint) balanceRwrdForClient;\r\n\r\n  // fee charged on liquidity taken, expressed as a divisor\r\n  // (e.g. 2000 means 1/2000, or 0.05%)\r\n\r\n  uint constant feeDivisor = 2000;\r\n  \r\n  // fees charged are given to:\r\n  \r\n  address feeCollector;\r\n\r\n  // all orders ever created\r\n  \r\n  mapping (uint128 => Order) orderForOrderId;\r\n  \r\n  // Effectively a compact mapping from price to whether there are any open orders at that price.\r\n  // See \"Price Calculation Constants\" below as to why 85.\r\n\r\n  uint256[85] occupiedPriceBitmaps;\r\n\r\n  // These allow us to walk over the orders in the book at a given price level (and add more).\r\n\r\n  mapping (uint16 => OrderChain) orderChainForOccupiedPrice;\r\n  mapping (uint128 => OrderChainNode) orderChainNodeForOpenOrderId;\r\n\r\n  // These allow a client to (reasonably) efficiently find their own orders\r\n  // without relying on events (which even indexed are a bit expensive to search\r\n  // and cannot be accessed from smart contracts). See walkOrders.\r\n\r\n  mapping (address => uint128) mostRecentOrderIdForClient;\r\n  mapping (uint128 => uint128) clientPreviousOrderIdBeforeOrderId;\r\n\r\n  // Price Calculation Constants.\r\n  //\r\n  // We pack direction and price into a crafty decimal floating point representation\r\n  // for efficient indexing by price, the main thing we lose by doing so is precision -\r\n  // we only have 3 significant figures in our prices.\r\n  //\r\n  // An unpacked price consists of:\r\n  //\r\n  //   direction - invalid / buy / sell\r\n  //   mantissa  - ranges from 100 to 999 representing 0.100 to 0.999\r\n  //   exponent  - ranges from minimumPriceExponent to minimumPriceExponent + 11\r\n  //               (e.g. -5 to +6 for a typical pair where minPriceExponent = -5)\r\n  //\r\n  // The packed representation has 21601 different price values:\r\n  //\r\n  //      0  = invalid (can be used as marker value)\r\n  //      1  = buy at maximum price (0.999 * 10 ** 6)\r\n  //    ...  = other buy prices in descending order\r\n  //   5401  = buy at 1.00\r\n  //    ...  = other buy prices in descending order\r\n  //  10800  = buy at minimum price (0.100 * 10 ** -5)\r\n  //  10801  = sell at minimum price (0.100 * 10 ** -5)\r\n  //    ...  = other sell prices in descending order\r\n  //  16201  = sell at 1.00\r\n  //    ...  = other sell prices in descending order\r\n  //  21600  = sell at maximum price (0.999 * 10 ** 6)\r\n  //  21601+ = do not use\r\n  //\r\n  // If we want to map each packed price to a boolean value (which we do),\r\n  // we require 85 256-bit words. Or 42.5 for each side of the book.\r\n  \r\n  int8 constant minPriceExponent = -5;\r\n\r\n  uint constant invalidPrice = 0;\r\n\r\n  // careful: max = largest unpacked value, not largest packed value\r\n  uint constant maxBuyPrice = 1; \r\n  uint constant minBuyPrice = 10800;\r\n  uint constant minSellPrice = 10801;\r\n  uint constant maxSellPrice = 21600;\r\n\r\n  // Constructor.\r\n  //\r\n  // Sets feeCollector to the creator. Creator needs to call init() to finish setup.\r\n  //\r\n  function BookERC20EthV1() {\r\n    address creator = msg.sender;\r\n    feeCollector = creator;\r\n  }\r\n\r\n  // \"Public\" Management - set address of base and reward tokens.\r\n  //\r\n  // Can only be done once (normally immediately after creation) by the fee collector.\r\n  //\r\n  // Used instead of a constructor to make deployment easier.\r\n  //\r\n  function init(ERC20 _baseToken, ERC20 _rwrdToken) public {\r\n    require(msg.sender == feeCollector);\r\n    require(address(baseToken) == 0);\r\n    require(address(_baseToken) != 0);\r\n    require(address(rwrdToken) == 0);\r\n    require(address(_rwrdToken) != 0);\r\n    // attempt to catch bad tokens:\r\n    require(_baseToken.totalSupply() > 0);\r\n    baseToken = _baseToken;\r\n    require(_rwrdToken.totalSupply() > 0);\r\n    rwrdToken = _rwrdToken;\r\n  }\r\n\r\n  // \"Public\" Management - change fee collector\r\n  //\r\n  // The new fee collector only gets fees charged after this point.\r\n  //\r\n  function changeFeeCollector(address newFeeCollector) public {\r\n    address oldFeeCollector = feeCollector;\r\n    require(msg.sender == oldFeeCollector);\r\n    require(newFeeCollector != oldFeeCollector);\r\n    feeCollector = newFeeCollector;\r\n  }\r\n  \r\n  // Public Info View - what is being traded here, what are the limits?\r\n  //\r\n  function getBookInfo() public constant returns (\r\n      BookType _bookType, address _baseToken, address _rwrdToken,\r\n      uint _baseMinInitialSize, uint _cntrMinInitialSize,\r\n      uint _feeDivisor, address _feeCollector\r\n    ) {\r\n    return (\r\n      BookType.ERC20EthV1,\r\n      address(baseToken),\r\n      address(rwrdToken),\r\n      baseMinInitialSize,\r\n      cntrMinInitialSize,\r\n      feeDivisor,\r\n      feeCollector\r\n    );\r\n  }\r\n\r\n  // Public Funds View - get balances held by contract on behalf of the client,\r\n  // or balances approved for deposit but not yet claimed by the contract.\r\n  //\r\n  // Excludes funds in open orders.\r\n  //\r\n  // Helps a web ui get a consistent snapshot of balances.\r\n  //\r\n  // It would be nice to return the off-exchange ETH balance too but there's a\r\n  // bizarre bug in geth (and apparently as a result via MetaMask) that leads\r\n  // to unpredictable behaviour when looking up client balances in constant\r\n  // functions - see e.g. https://github.com/ethereum/solidity/issues/2325 .\r\n  //\r\n  function getClientBalances(address client) public constant returns (\r\n      uint bookBalanceBase,\r\n      uint bookBalanceCntr,\r\n      uint bookBalanceRwrd,\r\n      uint approvedBalanceBase,\r\n      uint approvedBalanceRwrd,\r\n      uint ownBalanceBase,\r\n      uint ownBalanceRwrd\r\n    ) {\r\n    bookBalanceBase = balanceBaseForClient[client];\r\n    bookBalanceCntr = balanceCntrForClient[client];\r\n    bookBalanceRwrd = balanceRwrdForClient[client];\r\n    approvedBalanceBase = baseToken.allowance(client, address(this));\r\n    approvedBalanceRwrd = rwrdToken.allowance(client, address(this));\r\n    ownBalanceBase = baseToken.balanceOf(client);\r\n    ownBalanceRwrd = rwrdToken.balanceOf(client);\r\n  }\r\n\r\n  // Public Funds Manipulation - deposit previously-approved base tokens.\r\n  //\r\n  function transferFromBase() public {\r\n    address client = msg.sender;\r\n    address book = address(this);\r\n    // we trust the ERC20 token contract not to do nasty things like call back into us -\r\n    // if we cannot trust the token then why are we allowing it to be traded?\r\n    uint amountBase = baseToken.allowance(client, book);\r\n    require(amountBase > 0);\r\n    // NB: needs change for older ERC20 tokens that don't return bool\r\n    require(baseToken.transferFrom(client, book, amountBase));\r\n    // belt and braces\r\n    assert(baseToken.allowance(client, book) == 0);\r\n    balanceBaseForClient[client] += amountBase;\r\n    ClientPaymentEvent(client, ClientPaymentEventType.TransferFrom, BalanceType.Base, int(amountBase));\r\n  }\r\n\r\n  // Public Funds Manipulation - withdraw base tokens (as a transfer).\r\n  //\r\n  function transferBase(uint amountBase) public {\r\n    address client = msg.sender;\r\n    require(amountBase > 0);\r\n    require(amountBase <= balanceBaseForClient[client]);\r\n    // overflow safe since we checked less than balance above\r\n    balanceBaseForClient[client] -= amountBase;\r\n    // we trust the ERC20 token contract not to do nasty things like call back into us -\r\n    // if we cannot trust the token then why are we allowing it to be traded?\r\n    // NB: needs change for older ERC20 tokens that don't return bool\r\n    require(baseToken.transfer(client, amountBase));\r\n    ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Base, -int(amountBase));\r\n  }\r\n\r\n  // Public Funds Manipulation - deposit counter currency (ETH).\r\n  //\r\n  function depositCntr() public payable {\r\n    address client = msg.sender;\r\n    uint amountCntr = msg.value;\r\n    require(amountCntr > 0);\r\n    // overflow safe - if someone owns pow(2,255) ETH we have bigger problems\r\n    balanceCntrForClient[client] += amountCntr;\r\n    ClientPaymentEvent(client, ClientPaymentEventType.Deposit, BalanceType.Cntr, int(amountCntr));\r\n  }\r\n\r\n  // Public Funds Manipulation - withdraw counter currency (ETH).\r\n  //\r\n  function withdrawCntr(uint amountCntr) public {\r\n    address client = msg.sender;\r\n    require(amountCntr > 0);\r\n    require(amountCntr <= balanceCntrForClient[client]);\r\n    // overflow safe - checked less than balance above\r\n    balanceCntrForClient[client] -= amountCntr;\r\n    // safe - not enough gas to do anything interesting in fallback, already adjusted balance\r\n    client.transfer(amountCntr);\r\n    ClientPaymentEvent(client, ClientPaymentEventType.Withdraw, BalanceType.Cntr, -int(amountCntr));\r\n  }\r\n\r\n  // Public Funds Manipulation - deposit previously-approved reward tokens.\r\n  //\r\n  function transferFromRwrd() public {\r\n    address client = msg.sender;\r\n    address book = address(this);\r\n    uint amountRwrd = rwrdToken.allowance(client, book);\r\n    require(amountRwrd > 0);\r\n    // we wrote the reward token so we know it supports ERC20 properly and is not evil\r\n    require(rwrdToken.transferFrom(client, book, amountRwrd));\r\n    // belt and braces\r\n    assert(rwrdToken.allowance(client, book) == 0);\r\n    balanceRwrdForClient[client] += amountRwrd;\r\n    ClientPaymentEvent(client, ClientPaymentEventType.TransferFrom, BalanceType.Rwrd, int(amountRwrd));\r\n  }\r\n\r\n  // Public Funds Manipulation - withdraw base tokens (as a transfer).\r\n  //\r\n  function transferRwrd(uint amountRwrd) public {\r\n    address client = msg.sender;\r\n    require(amountRwrd > 0);\r\n    require(amountRwrd <= balanceRwrdForClient[client]);\r\n    // overflow safe - checked less than balance above\r\n    balanceRwrdForClient[client] -= amountRwrd;\r\n    // we wrote the reward token so we know it supports ERC20 properly and is not evil\r\n    require(rwrdToken.transfer(client, amountRwrd));\r\n    ClientPaymentEvent(client, ClientPaymentEventType.Transfer, BalanceType.Rwrd, -int(amountRwrd));\r\n  }\r\n\r\n  // Public Order View - get full details of an order.\r\n  //\r\n  // If the orderId does not exist, status will be Unknown.\r\n  //\r\n  function getOrder(uint128 orderId) public constant returns (\r\n    address client, uint16 price, uint sizeBase, Terms terms,\r\n    Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\r\n    uint feesBaseOrCntr, uint feesRwrd) {\r\n    Order storage order = orderForOrderId[orderId];\r\n    return (order.client, order.price, order.sizeBase, order.terms,\r\n            order.status, order.reasonCode, order.executedBase, order.executedCntr,\r\n            order.feesBaseOrCntr, order.feesRwrd);\r\n  }\r\n\r\n  // Public Order View - get mutable details of an order.\r\n  //\r\n  // If the orderId does not exist, status will be Unknown.\r\n  //\r\n  function getOrderState(uint128 orderId) public constant returns (\r\n    Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\r\n    uint feesBaseOrCntr, uint feesRwrd) {\r\n    Order storage order = orderForOrderId[orderId];\r\n    return (order.status, order.reasonCode, order.executedBase, order.executedCntr,\r\n            order.feesBaseOrCntr, order.feesRwrd);\r\n  }\r\n  \r\n  // Public Order View - enumerate all recent orders + all open orders for one client.\r\n  //\r\n  // Not really designed for use from a smart contract transaction.\r\n  //\r\n  // Idea is:\r\n  //  - client ensures order ids are generated so that most-signficant part is time-based;\r\n  //  - client decides they want all orders after a certain point-in-time,\r\n  //    and chooses minClosedOrderIdCutoff accordingly;\r\n  //  - before that point-in-time they just get open and needs gas orders\r\n  //  - client calls walkClientOrders with maybeLastOrderIdReturned = 0 initially;\r\n  //  - then repeats with the orderId returned by walkClientOrders;\r\n  //  - (and stops if it returns a zero orderId);\r\n  //\r\n  // Note that client is only used when maybeLastOrderIdReturned = 0.\r\n  //\r\n  function walkClientOrders(\r\n      address client, uint128 maybeLastOrderIdReturned, uint128 minClosedOrderIdCutoff\r\n    ) public constant returns (\r\n      uint128 orderId, uint16 price, uint sizeBase, Terms terms,\r\n      Status status, ReasonCode reasonCode, uint executedBase, uint executedCntr,\r\n      uint feesBaseOrCntr, uint feesRwrd) {\r\n    if (maybeLastOrderIdReturned == 0) {\r\n      orderId = mostRecentOrderIdForClient[client];\r\n    } else {\r\n      orderId = clientPreviousOrderIdBeforeOrderId[maybeLastOrderIdReturned];\r\n    }\r\n    while (true) {\r\n      if (orderId == 0) return;\r\n      Order storage order = orderForOrderId[orderId];\r\n      if (orderId >= minClosedOrderIdCutoff) break;\r\n      if (order.status == Status.Open || order.status == Status.NeedsGas) break;\r\n      orderId = clientPreviousOrderIdBeforeOrderId[orderId];\r\n    }\r\n    return (orderId, order.price, order.sizeBase, order.terms,\r\n            order.status, order.reasonCode, order.executedBase, order.executedCntr,\r\n            order.feesBaseOrCntr, order.feesRwrd);\r\n  }\r\n \r\n  // Internal Price Calculation - turn packed price into a friendlier unpacked price.\r\n  //\r\n  function unpackPrice(uint16 price) internal constant returns (\r\n      Direction direction, uint16 mantissa, int8 exponent\r\n    ) {\r\n    uint sidedPriceIndex = uint(price);\r\n    uint priceIndex;\r\n    if (sidedPriceIndex < 1 || sidedPriceIndex > maxSellPrice) {\r\n      direction = Direction.Invalid;\r\n      mantissa = 0;\r\n      exponent = 0;\r\n      return;\r\n    } else if (sidedPriceIndex <= minBuyPrice) {\r\n      direction = Direction.Buy;\r\n      priceIndex = minBuyPrice - sidedPriceIndex;\r\n    } else {\r\n      direction = Direction.Sell;\r\n      priceIndex = sidedPriceIndex - minSellPrice;\r\n    }\r\n    uint zeroBasedMantissa = priceIndex % 900;\r\n    uint zeroBasedExponent = priceIndex / 900;\r\n    mantissa = uint16(zeroBasedMantissa + 100);\r\n    exponent = int8(zeroBasedExponent) + minPriceExponent;\r\n    return;\r\n  }\r\n  \r\n  // Internal Price Calculation - is a packed price on the buy side?\r\n  //\r\n  // Throws an error if price is invalid.\r\n  //\r\n  function isBuyPrice(uint16 price) internal constant returns (bool isBuy) {\r\n    // yes, this looks odd, but max here is highest _unpacked_ price\r\n    return price >= maxBuyPrice && price <= minBuyPrice;\r\n  }\r\n  \r\n  // Internal Price Calculation - turn a packed buy price into a packed sell price.\r\n  //\r\n  // Invalid price remains invalid.\r\n  //\r\n  function computeOppositePrice(uint16 price) internal constant returns (uint16 opposite) {\r\n    if (price < maxBuyPrice || price > maxSellPrice) {\r\n      return uint16(invalidPrice);\r\n    } else if (price <= minBuyPrice) {\r\n      return uint16(maxSellPrice - (price - maxBuyPrice));\r\n    } else {\r\n      return uint16(maxBuyPrice + (maxSellPrice - price));\r\n    }\r\n  }\r\n  \r\n  // Internal Price Calculation - compute amount in counter currency that would\r\n  // be obtained by selling baseAmount at the given unpacked price (if no fees).\r\n  //\r\n  // Notes:\r\n  //  - Does not validate price - caller must ensure valid.\r\n  //  - Could overflow producing very unexpected results if baseAmount very\r\n  //    large - caller must check this.\r\n  //  - This rounds the amount towards zero.\r\n  //  - May truncate to zero if baseAmount very small - potentially allowing\r\n  //    zero-cost buys or pointless sales - caller must check this.\r\n  //\r\n  function computeCntrAmountUsingUnpacked(\r\n      uint baseAmount, uint16 mantissa, int8 exponent\r\n    ) internal constant returns (uint cntrAmount) {\r\n    if (exponent < 0) {\r\n      return baseAmount * uint(mantissa) / 1000 / 10 ** uint(-exponent);\r\n    } else {\r\n      return baseAmount * uint(mantissa) / 1000 * 10 ** uint(exponent);\r\n    }\r\n  }\r\n\r\n  // Internal Price Calculation - compute amount in counter currency that would\r\n  // be obtained by selling baseAmount at the given packed price (if no fees).\r\n  //\r\n  // Notes:\r\n  //  - Does not validate price - caller must ensure valid.\r\n  //  - Direction of the packed price is ignored.\r\n  //  - Could overflow producing very unexpected results if baseAmount very\r\n  //    large - caller must check this.\r\n  //  - This rounds the amount towards zero (regardless of Buy or Sell).\r\n  //  - May truncate to zero if baseAmount very small - potentially allowing\r\n  //    zero-cost buys or pointless sales - caller must check this.\r\n  //\r\n  function computeCntrAmountUsingPacked(\r\n      uint baseAmount, uint16 price\r\n    ) internal constant returns (uint) {\r\n    var (, mantissa, exponent) = unpackPrice(price);\r\n    return computeCntrAmountUsingUnpacked(baseAmount, mantissa, exponent);\r\n  }\r\n\r\n  // Public Order Placement - create order and try to match it and/or add it to the book.\r\n  //\r\n  function createOrder(\r\n      uint128 orderId, uint16 price, uint sizeBase, Terms terms, uint maxMatches\r\n    ) public {\r\n    address client = msg.sender;\r\n    require(client != 0 && orderId != 0 && orderForOrderId[orderId].client == 0);\r\n    ClientOrderEvent(client, ClientOrderEventType.Create, orderId);\r\n    orderForOrderId[orderId] =\r\n      Order(client, price, sizeBase, terms, Status.Unknown, ReasonCode.None, 0, 0, 0, 0);\r\n    uint128 previousMostRecentOrderIdForClient = mostRecentOrderIdForClient[client];\r\n    mostRecentOrderIdForClient[client] = orderId;\r\n    clientPreviousOrderIdBeforeOrderId[orderId] = previousMostRecentOrderIdForClient;\r\n    Order storage order = orderForOrderId[orderId];\r\n    var (direction, mantissa, exponent) = unpackPrice(price);\r\n    if (direction == Direction.Invalid) {\r\n      order.status = Status.Rejected;\r\n      order.reasonCode = ReasonCode.InvalidPrice;\r\n      return;\r\n    }\r\n    if (sizeBase < baseMinInitialSize || sizeBase > baseMaxSize) {\r\n      order.status = Status.Rejected;\r\n      order.reasonCode = ReasonCode.InvalidSize;\r\n      return;\r\n    }\r\n    uint sizeCntr = computeCntrAmountUsingUnpacked(sizeBase, mantissa, exponent);\r\n    if (sizeCntr < cntrMinInitialSize || sizeCntr > cntrMaxSize) {\r\n      order.status = Status.Rejected;\r\n      order.reasonCode = ReasonCode.InvalidSize;\r\n      return;\r\n    }\r\n    if (terms == Terms.MakerOnly && maxMatches != 0) {\r\n      order.status = Status.Rejected;\r\n      order.reasonCode = ReasonCode.InvalidTerms;\r\n      return;\r\n    }\r\n    if (!debitFunds(client, direction, sizeBase, sizeCntr)) {\r\n      order.status = Status.Rejected;\r\n      order.reasonCode = ReasonCode.InsufficientFunds;\r\n      return;\r\n    }\r\n    processOrder(orderId, maxMatches);\r\n  }\r\n\r\n  // Public Order Placement - cancel order\r\n  //\r\n  function cancelOrder(uint128 orderId) public {\r\n    address client = msg.sender;\r\n    Order storage order = orderForOrderId[orderId];\r\n    require(order.client == client);\r\n    Status status = order.status;\r\n    if (status != Status.Open && status != Status.NeedsGas) {\r\n      return;\r\n    }\r\n    if (status == Status.Open) {\r\n      removeOpenOrderFromBook(orderId);\r\n      MarketOrderEvent(block.timestamp, orderId, MarketOrderEventType.Remove, order.price,\r\n        order.sizeBase - order.executedBase, 0);\r\n    }\r\n    refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.ClientCancel);\r\n  }\r\n\r\n  // Public Order Placement - continue placing an order in 'NeedsGas' state\r\n  //\r\n  function continueOrder(uint128 orderId, uint maxMatches) public {\r\n    address client = msg.sender;\r\n    Order storage order = orderForOrderId[orderId];\r\n    require(order.client == client);\r\n    if (order.status != Status.NeedsGas) {\r\n      return;\r\n    }\r\n    order.status = Status.Unknown;\r\n    processOrder(orderId, maxMatches);\r\n  }\r\n\r\n  // Internal Order Placement - remove a still-open order from the book.\r\n  //\r\n  // Caller's job to update/refund the order + raise event, this just\r\n  // updates the order chain and bitmask.\r\n  //\r\n  // Too expensive to do on each resting order match - we only do this for an\r\n  // order being cancelled. See matchWithOccupiedPrice for similar logic.\r\n  //\r\n  function removeOpenOrderFromBook(uint128 orderId) internal {\r\n    Order storage order = orderForOrderId[orderId];\r\n    uint16 price = order.price;\r\n    OrderChain storage orderChain = orderChainForOccupiedPrice[price];\r\n    OrderChainNode storage orderChainNode = orderChainNodeForOpenOrderId[orderId];\r\n    uint128 nextOrderId = orderChainNode.nextOrderId;\r\n    uint128 prevOrderId = orderChainNode.prevOrderId;\r\n    if (nextOrderId != 0) {\r\n      OrderChainNode storage nextOrderChainNode = orderChainNodeForOpenOrderId[nextOrderId];\r\n      nextOrderChainNode.prevOrderId = prevOrderId;\r\n    } else {\r\n      orderChain.lastOrderId = prevOrderId;\r\n    }\r\n    if (prevOrderId != 0) {\r\n      OrderChainNode storage prevOrderChainNode = orderChainNodeForOpenOrderId[prevOrderId];\r\n      prevOrderChainNode.nextOrderId = nextOrderId;\r\n    } else {\r\n      orderChain.firstOrderId = nextOrderId;\r\n    }\r\n    if (nextOrderId == 0 && prevOrderId == 0) {\r\n      uint bmi = price / 256;  // index into array of bitmaps\r\n      uint bti = price % 256;  // bit position within bitmap\r\n      // we know was previously occupied so XOR clears\r\n      occupiedPriceBitmaps[bmi] ^= 2 ** bti;\r\n    }\r\n  }\r\n\r\n  // Internal Order Placement - credit funds received when taking liquidity from book\r\n  //\r\n  function creditExecutedFundsLessFees(uint128 orderId, uint originalExecutedBase, uint originalExecutedCntr) internal {\r\n    Order storage order = orderForOrderId[orderId];\r\n    uint liquidityTakenBase = order.executedBase - originalExecutedBase;\r\n    uint liquidityTakenCntr = order.executedCntr - originalExecutedCntr;\r\n    // Normally we deduct the fee from the currency bought (base for buy, cntr for sell),\r\n    // however we also accept reward tokens from the reward balance if it covers the fee,\r\n    // with the reward amount converted from the ETH amount (the counter currency here)\r\n    // at a fixed exchange rate.\r\n    // Overflow safe since we ensure order size < 10^30 in both currencies (see baseMaxSize).\r\n    // Can truncate to zero, which is fine.\r\n    uint feesRwrd = liquidityTakenCntr / feeDivisor * ethRwrdRate;\r\n    uint feesBaseOrCntr;\r\n    address client = order.client;\r\n    uint availRwrd = balanceRwrdForClient[client];\r\n    if (feesRwrd <= availRwrd) {\r\n      balanceRwrdForClient[client] = availRwrd - feesRwrd;\r\n      balanceRwrdForClient[feeCollector] = feesRwrd;\r\n      // Need += rather than = because could have paid some fees earlier in NeedsGas situation.\r\n      // Overflow safe since we ensure order size < 10^30 in both currencies (see baseMaxSize).\r\n      // Can truncate to zero, which is fine.\r\n      order.feesRwrd += uint128(feesRwrd);\r\n      if (isBuyPrice(order.price)) {\r\n        balanceBaseForClient[client] += liquidityTakenBase;\r\n      } else {\r\n        balanceCntrForClient[client] += liquidityTakenCntr;\r\n      }\r\n    } else if (isBuyPrice(order.price)) {\r\n      // See comments in branch above re: use of += and overflow safety.\r\n      feesBaseOrCntr = liquidityTakenBase / feeDivisor;\r\n      balanceBaseForClient[order.client] += (liquidityTakenBase - feesBaseOrCntr);\r\n      order.feesBaseOrCntr += uint128(feesBaseOrCntr);\r\n      balanceBaseForClient[feeCollector] += feesBaseOrCntr;\r\n    } else {\r\n      // See comments in branch above re: use of += and overflow safety.\r\n      feesBaseOrCntr = liquidityTakenCntr / feeDivisor;\r\n      balanceCntrForClient[order.client] += (liquidityTakenCntr - feesBaseOrCntr);\r\n      order.feesBaseOrCntr += uint128(feesBaseOrCntr);\r\n      balanceCntrForClient[feeCollector] += feesBaseOrCntr;\r\n    }\r\n  }\r\n\r\n  // Internal Order Placement - process a created and sanity checked order.\r\n  //\r\n  // Used both for new orders and for gas topup.\r\n  //\r\n  function processOrder(uint128 orderId, uint maxMatches) internal {\r\n    Order storage order = orderForOrderId[orderId];\r\n\r\n    uint ourOriginalExecutedBase = order.executedBase;\r\n    uint ourOriginalExecutedCntr = order.executedCntr;\r\n\r\n    var (ourDirection,) = unpackPrice(order.price);\r\n    uint theirPriceStart = (ourDirection == Direction.Buy) ? minSellPrice : maxBuyPrice;\r\n    uint theirPriceEnd = computeOppositePrice(order.price);\r\n   \r\n    MatchStopReason matchStopReason =\r\n      matchAgainstBook(orderId, theirPriceStart, theirPriceEnd, maxMatches);\r\n\r\n    creditExecutedFundsLessFees(orderId, ourOriginalExecutedBase, ourOriginalExecutedCntr);\r\n\r\n    if (order.terms == Terms.ImmediateOrCancel) {\r\n      if (matchStopReason == MatchStopReason.Satisfied) {\r\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\r\n        return;\r\n      } else if (matchStopReason == MatchStopReason.MaxMatches) {\r\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.TooManyMatches);\r\n        return;\r\n      } else if (matchStopReason == MatchStopReason.BookExhausted) {\r\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.Unmatched);\r\n        return;\r\n      }\r\n    } else if (order.terms == Terms.MakerOnly) {\r\n      if (matchStopReason == MatchStopReason.MaxMatches) {\r\n        refundUnmatchedAndFinish(orderId, Status.Rejected, ReasonCode.WouldTake);\r\n        return;\r\n      } else if (matchStopReason == MatchStopReason.BookExhausted) {\r\n        enterOrder(orderId);\r\n        return;\r\n      }\r\n    } else if (order.terms == Terms.GTCNoGasTopup) {\r\n      if (matchStopReason == MatchStopReason.Satisfied) {\r\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\r\n        return;\r\n      } else if (matchStopReason == MatchStopReason.MaxMatches) {\r\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.TooManyMatches);\r\n        return;\r\n      } else if (matchStopReason == MatchStopReason.BookExhausted) {\r\n        enterOrder(orderId);\r\n        return;\r\n      }\r\n    } else if (order.terms == Terms.GTCWithGasTopup) {\r\n      if (matchStopReason == MatchStopReason.Satisfied) {\r\n        refundUnmatchedAndFinish(orderId, Status.Done, ReasonCode.None);\r\n        return;\r\n      } else if (matchStopReason == MatchStopReason.MaxMatches) {\r\n        order.status = Status.NeedsGas;\r\n        return;\r\n      } else if (matchStopReason == MatchStopReason.BookExhausted) {\r\n        enterOrder(orderId);\r\n        return;\r\n      }\r\n    }\r\n    assert(false); // should not be possible to reach here\r\n  }\r\n \r\n  // Used internally to indicate why we stopped matching an order against the book.\r\n\r\n  enum MatchStopReason {\r\n    None,\r\n    MaxMatches,\r\n    Satisfied,\r\n    PriceExhausted,\r\n    BookExhausted\r\n  }\r\n \r\n  // Internal Order Placement - Match the given order against the book.\r\n  //\r\n  // Resting orders matched will be updated, removed from book and funds credited to their owners.\r\n  //\r\n  // Only updates the executedBase and executedCntr of the given order - caller is responsible\r\n  // for crediting matched funds, charging fees, marking order as done / entering it into the book.\r\n  //\r\n  // matchStopReason returned will be one of MaxMatches, Satisfied or BookExhausted.\r\n  //\r\n  function matchAgainstBook(\r\n      uint128 orderId, uint theirPriceStart, uint theirPriceEnd, uint maxMatches\r\n    ) internal returns (\r\n      MatchStopReason matchStopReason\r\n    ) {\r\n    Order storage order = orderForOrderId[orderId];\r\n    \r\n    uint bmi = theirPriceStart / 256;  // index into array of bitmaps\r\n    uint bti = theirPriceStart % 256;  // bit position within bitmap\r\n    uint bmiEnd = theirPriceEnd / 256; // last bitmap to search\r\n    uint btiEnd = theirPriceEnd % 256; // stop at this bit in the last bitmap\r\n\r\n    uint cbm = occupiedPriceBitmaps[bmi]; // original copy of current bitmap\r\n    uint dbm = cbm; // dirty version of current bitmap where we may have cleared bits\r\n    uint wbm = cbm >> bti; // working copy of current bitmap which we keep shifting\r\n    \r\n    // these loops are pretty ugly, and somewhat unpredicatable in terms of gas,\r\n    // ... but no-one else has come up with a better matching engine yet!\r\n\r\n    bool removedLastAtPrice;\r\n    matchStopReason = MatchStopReason.None;\r\n\r\n    while (bmi < bmiEnd) {\r\n      if (wbm == 0 || bti == 256) {\r\n        if (dbm != cbm) {\r\n          occupiedPriceBitmaps[bmi] = dbm;\r\n        }\r\n        bti = 0;\r\n        bmi++;\r\n        cbm = occupiedPriceBitmaps[bmi];\r\n        wbm = cbm;\r\n        dbm = cbm;\r\n      } else {\r\n        if ((wbm & 1) != 0) {\r\n          // careful - copy-and-pasted in loop below ...\r\n          (removedLastAtPrice, maxMatches, matchStopReason) =\r\n            matchWithOccupiedPrice(order, uint16(bmi * 256 + bti), maxMatches);\r\n          if (removedLastAtPrice) {\r\n            dbm ^= 2 ** bti;\r\n          }\r\n          if (matchStopReason == MatchStopReason.PriceExhausted) {\r\n            matchStopReason = MatchStopReason.None;\r\n          } else if (matchStopReason != MatchStopReason.None) {\r\n            break;\r\n          }\r\n        }\r\n        bti += 1;\r\n        wbm /= 2;\r\n      }\r\n    }\r\n    if (matchStopReason == MatchStopReason.None) {\r\n      // we've reached the last bitmap we need to search,\r\n      // we'll stop at btiEnd not 256 this time.\r\n      while (bti <= btiEnd && wbm != 0) {\r\n        if ((wbm & 1) != 0) {\r\n          // careful - copy-and-pasted in loop above ...\r\n          (removedLastAtPrice, maxMatches, matchStopReason) =\r\n            matchWithOccupiedPrice(order, uint16(bmi * 256 + bti), maxMatches);\r\n          if (removedLastAtPrice) {\r\n            dbm ^= 2 ** bti;\r\n          }\r\n          if (matchStopReason == MatchStopReason.PriceExhausted) {\r\n            matchStopReason = MatchStopReason.None;\r\n          } else if (matchStopReason != MatchStopReason.None) {\r\n            break;\r\n          }\r\n        }\r\n        bti += 1;\r\n        wbm /= 2;\r\n      }\r\n    }\r\n    // Careful - if we exited the first loop early, or we went into the second loop,\r\n    // (luckily can't both happen) then we haven't flushed the dirty bitmap back to\r\n    // storage - do that now if we need to.\r\n    if (dbm != cbm) {\r\n      occupiedPriceBitmaps[bmi] = dbm;\r\n    }\r\n    if (matchStopReason == MatchStopReason.None) {\r\n      matchStopReason = MatchStopReason.BookExhausted;\r\n    }\r\n  }\r\n\r\n  // Internal Order Placement.\r\n  //\r\n  // Match our order against up to maxMatches resting orders at the given price (which\r\n  // is known by the caller to have at least one resting order).\r\n  //\r\n  // The matches (partial or complete) of the resting orders are recorded, and their\r\n  // funds are credited.\r\n  //\r\n  // The order chain for the resting orders is updated, but the occupied price bitmap is NOT -\r\n  // the caller must clear the relevant bit if removedLastAtPrice = true is returned.\r\n  //\r\n  // Only updates the executedBase and executedCntr of our order - caller is responsible\r\n  // for e.g. crediting our matched funds, updating status.\r\n  //\r\n  // Calling with maxMatches == 0 is ok - and expected when the order is a maker-only order.\r\n  //\r\n  // Returns:\r\n  //   removedLastAtPrice:\r\n  //     true iff there are no longer any resting orders at this price - caller will need\r\n  //     to update the occupied price bitmap.\r\n  //\r\n  //   matchesLeft:\r\n  //     maxMatches passed in minus the number of matches made by this call\r\n  //\r\n  //   matchStopReason:\r\n  //     If our order is completely matched, matchStopReason will be Satisfied.\r\n  //     If our order is not completely matched, matchStopReason will be either:\r\n  //        MaxMatches (we are not allowed to match any more times)\r\n  //     or:\r\n  //        PriceExhausted (nothing left on the book at this exact price)\r\n  //\r\n  function matchWithOccupiedPrice(\r\n      Order storage ourOrder, uint16 theirPrice, uint maxMatches\r\n    ) internal returns (\r\n    bool removedLastAtPrice, uint matchesLeft, MatchStopReason matchStopReason) {\r\n    matchesLeft = maxMatches;\r\n    uint workingOurExecutedBase = ourOrder.executedBase;\r\n    uint workingOurExecutedCntr = ourOrder.executedCntr;\r\n    uint128 theirOrderId = orderChainForOccupiedPrice[theirPrice].firstOrderId;\r\n    matchStopReason = MatchStopReason.None;\r\n    while (true) {\r\n      if (matchesLeft == 0) {\r\n        matchStopReason = MatchStopReason.MaxMatches;\r\n        break;\r\n      }\r\n      uint matchBase;\r\n      uint matchCntr;\r\n      (theirOrderId, matchBase, matchCntr, matchStopReason) =\r\n        matchWithTheirs((ourOrder.sizeBase - workingOurExecutedBase), theirOrderId, theirPrice);\r\n      workingOurExecutedBase += matchBase;\r\n      workingOurExecutedCntr += matchCntr;\r\n      matchesLeft -= 1;\r\n      if (matchStopReason != MatchStopReason.None) {\r\n        break;\r\n      }\r\n    }\r\n    ourOrder.executedBase = uint128(workingOurExecutedBase);\r\n    ourOrder.executedCntr = uint128(workingOurExecutedCntr);\r\n    if (theirOrderId == 0) {\r\n      orderChainForOccupiedPrice[theirPrice].firstOrderId = 0;\r\n      orderChainForOccupiedPrice[theirPrice].lastOrderId = 0;\r\n      removedLastAtPrice = true;\r\n    } else {\r\n      // NB: in some cases (e.g. maxMatches == 0) this is a no-op.\r\n      orderChainForOccupiedPrice[theirPrice].firstOrderId = theirOrderId;\r\n      orderChainNodeForOpenOrderId[theirOrderId].prevOrderId = 0;\r\n      removedLastAtPrice = false;\r\n    }\r\n  }\r\n  \r\n  // Internal Order Placement.\r\n  //\r\n  // Match up to our remaining amount against a resting order in the book.\r\n  //\r\n  // The match (partial, complete or effectively-complete) of the resting order\r\n  // is recorded, and their funds are credited.\r\n  //\r\n  // Their order is NOT removed from the book by this call - the caller must do that\r\n  // if the nextTheirOrderId returned is not equal to the theirOrderId passed in.\r\n  //\r\n  // Returns:\r\n  //\r\n  //   nextTheirOrderId:\r\n  //     If we did not completely match their order, will be same as theirOrderId.\r\n  //     If we completely matched their order, will be orderId of next order at the\r\n  //     same price - or zero if this was the last order and we've now filled it.\r\n  //\r\n  //   matchStopReason:\r\n  //     If our order is completely matched, matchStopReason will be Satisfied.\r\n  //     If our order is not completely matched, matchStopReason will be either\r\n  //     PriceExhausted (if nothing left at this exact price) or None (if can continue).\r\n  // \r\n  function matchWithTheirs(\r\n    uint ourRemainingBase, uint128 theirOrderId, uint16 theirPrice) internal returns (\r\n    uint128 nextTheirOrderId, uint matchBase, uint matchCntr, MatchStopReason matchStopReason) {\r\n    Order storage theirOrder = orderForOrderId[theirOrderId];\r\n    uint theirRemainingBase = theirOrder.sizeBase - theirOrder.executedBase;\r\n    if (ourRemainingBase < theirRemainingBase) {\r\n      matchBase = ourRemainingBase;\r\n    } else {\r\n      matchBase = theirRemainingBase;\r\n    }\r\n    matchCntr = computeCntrAmountUsingPacked(matchBase, theirPrice);\r\n    // It may seem a bit odd to stop here if our remaining amount is very small -\r\n    // there could still be resting orders we can match it against. But the gas\r\n    // cost of matching each order is quite high - potentially high enough to\r\n    // wipe out the profit the taker hopes for from trading the tiny amount left.\r\n    if ((ourRemainingBase - matchBase) < baseMinRemainingSize) {\r\n      matchStopReason = MatchStopReason.Satisfied;\r\n    } else {\r\n      matchStopReason = MatchStopReason.None;\r\n    }\r\n    bool theirsDead = recordTheirMatch(theirOrder, theirOrderId, theirPrice, matchBase, matchCntr);\r\n    if (theirsDead) {\r\n      nextTheirOrderId = orderChainNodeForOpenOrderId[theirOrderId].nextOrderId;\r\n      if (matchStopReason == MatchStopReason.None && nextTheirOrderId == 0) {\r\n        matchStopReason = MatchStopReason.PriceExhausted;\r\n      }\r\n    } else {\r\n      nextTheirOrderId = theirOrderId;\r\n    }\r\n  }\r\n\r\n  // Internal Order Placement.\r\n  //\r\n  // Record match (partial or complete) of resting order, and credit them their funds.\r\n  //\r\n  // If their order is completely matched, the order is marked as done,\r\n  // and \"theirsDead\" is returned as true.\r\n  //\r\n  // The order is NOT removed from the book by this call - the caller\r\n  // must do that if theirsDead is true.\r\n  //\r\n  // No sanity checks are made - the caller must be sure the order is\r\n  // not already done and has sufficient remaining. (Yes, we'd like to\r\n  // check here too but we cannot afford the gas).\r\n  //\r\n  function recordTheirMatch(\r\n      Order storage theirOrder, uint128 theirOrderId, uint16 theirPrice, uint matchBase, uint matchCntr\r\n    ) internal returns (bool theirsDead) {\r\n    // they are a maker so no fees\r\n    // overflow safe - see comments about baseMaxSize\r\n    // executedBase cannot go > sizeBase due to logic in matchWithTheirs\r\n    theirOrder.executedBase += uint128(matchBase);\r\n    theirOrder.executedCntr += uint128(matchCntr);\r\n    if (isBuyPrice(theirPrice)) {\r\n      // they have bought base (using the counter they already paid when creating the order)\r\n      balanceBaseForClient[theirOrder.client] += matchBase;\r\n    } else {\r\n      // they have bought counter (using the base they already paid when creating the order)\r\n      balanceCntrForClient[theirOrder.client] += matchCntr;\r\n    }\r\n    uint stillRemainingBase = theirOrder.sizeBase - theirOrder.executedBase;\r\n    // avoid leaving tiny amounts in the book - refund remaining if too small\r\n    if (stillRemainingBase < baseMinRemainingSize) {\r\n      refundUnmatchedAndFinish(theirOrderId, Status.Done, ReasonCode.None);\r\n      // someone building an UI on top needs to know how much was match and how much was refund\r\n      MarketOrderEvent(block.timestamp, theirOrderId, MarketOrderEventType.CompleteFill,\r\n        theirPrice, matchBase + stillRemainingBase, matchBase);\r\n      return true;\r\n    } else {\r\n      MarketOrderEvent(block.timestamp, theirOrderId, MarketOrderEventType.PartialFill,\r\n        theirPrice, matchBase, matchBase);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Internal Order Placement.\r\n  //\r\n  // Refund any unmatched funds in an order (based on executed vs size) and move to a final state.\r\n  //\r\n  // The order is NOT removed from the book by this call and no event is raised.\r\n  //\r\n  // No sanity checks are made - the caller must be sure the order has not already been refunded.\r\n  //\r\n  function refundUnmatchedAndFinish(uint128 orderId, Status status, ReasonCode reasonCode) internal {\r\n    Order storage order = orderForOrderId[orderId];\r\n    uint16 price = order.price;\r\n    if (isBuyPrice(price)) {\r\n      uint sizeCntr = computeCntrAmountUsingPacked(order.sizeBase, price);\r\n      balanceCntrForClient[order.client] += sizeCntr - order.executedCntr;\r\n    } else {\r\n      balanceBaseForClient[order.client] += order.sizeBase - order.executedBase;\r\n    }\r\n    order.status = status;\r\n    order.reasonCode = reasonCode;\r\n  }\r\n\r\n  // Internal Order Placement.\r\n  //\r\n  // Enter a not completely matched order into the book, marking the order as open.\r\n  //\r\n  // This updates the occupied price bitmap and chain.\r\n  //\r\n  // No sanity checks are made - the caller must be sure the order\r\n  // has some unmatched amount and has been paid for!\r\n  //\r\n  function enterOrder(uint128 orderId) internal {\r\n    Order storage order = orderForOrderId[orderId];\r\n    uint16 price = order.price;\r\n    OrderChain storage orderChain = orderChainForOccupiedPrice[price];\r\n    OrderChainNode storage orderChainNode = orderChainNodeForOpenOrderId[orderId];\r\n    if (orderChain.firstOrderId == 0) {\r\n      orderChain.firstOrderId = orderId;\r\n      orderChain.lastOrderId = orderId;\r\n      orderChainNode.nextOrderId = 0;\r\n      orderChainNode.prevOrderId = 0;\r\n      uint bitmapIndex = price / 256;\r\n      uint bitIndex = price % 256;\r\n      occupiedPriceBitmaps[bitmapIndex] |= (2 ** bitIndex);\r\n    } else {\r\n      uint128 existingLastOrderId = orderChain.lastOrderId;\r\n      OrderChainNode storage existingLastOrderChainNode = orderChainNodeForOpenOrderId[existingLastOrderId];\r\n      orderChainNode.nextOrderId = 0;\r\n      orderChainNode.prevOrderId = existingLastOrderId;\r\n      existingLastOrderChainNode.nextOrderId = orderId;\r\n      orderChain.lastOrderId = orderId;\r\n    }\r\n    MarketOrderEvent(block.timestamp, orderId, MarketOrderEventType.Add,\r\n      price, order.sizeBase - order.executedBase, 0);\r\n    order.status = Status.Open;\r\n  }\r\n\r\n  // Internal Order Placement.\r\n  //\r\n  // Charge the client for the cost of placing an order in the given direction.\r\n  //\r\n  // Return true if successful, false otherwise.\r\n  //\r\n  function debitFunds(\r\n      address client, Direction direction, uint sizeBase, uint sizeCntr\r\n    ) internal returns (bool success) {\r\n    if (direction == Direction.Buy) {\r\n      uint availableCntr = balanceCntrForClient[client];\r\n      if (availableCntr < sizeCntr) {\r\n        return false;\r\n      }\r\n      balanceCntrForClient[client] = availableCntr - sizeCntr;\r\n      return true;\r\n    } else if (direction == Direction.Sell) {\r\n      uint availableBase = balanceBaseForClient[client];\r\n      if (availableBase < sizeBase) {\r\n        return false;\r\n      }\r\n      balanceBaseForClient[client] = availableBase - sizeBase;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Public Book View\r\n  // \r\n  // Intended for public book depth enumeration from web3 (or similar).\r\n  //\r\n  // Not suitable for use from a smart contract transaction - gas usage\r\n  // could be very high if we have many orders at the same price.\r\n  //\r\n  // Start at the given inclusive price (and side) and walk down the book\r\n  // (getting less aggressive) until we find some open orders or reach the\r\n  // least aggressive price.\r\n  //\r\n  // Returns the price where we found the order(s), the depth at that price\r\n  // (zero if none found), order count there, and the current blockNumber.\r\n  //\r\n  // (The blockNumber is handy if you're taking a snapshot which you intend\r\n  //  to keep up-to-date with the market order events).\r\n  //\r\n  // To walk the book, the caller should start by calling walkBook with the\r\n  // most aggressive buy price (Buy @ 999000).\r\n  // If the price returned is the least aggressive buy price (Buy @ 0.000001),\r\n  // the side is complete.\r\n  // Otherwise, call walkBook again with the (packed) price returned + 1.\r\n  // Then repeat for the sell side, starting with Sell @ 0.000001 and stopping\r\n  // when Sell @ 999000 is returned.\r\n  //\r\n  function walkBook(uint16 fromPrice) public constant returns (\r\n      uint16 price, uint depthBase, uint orderCount, uint blockNumber\r\n    ) {\r\n    uint priceStart = fromPrice;\r\n    uint priceEnd = (isBuyPrice(fromPrice)) ? minBuyPrice : maxSellPrice;\r\n    \r\n    // See comments in matchAgainstBook re: how these crazy loops work.\r\n    \r\n    uint bmi = priceStart / 256;\r\n    uint bti = priceStart % 256;\r\n    uint bmiEnd = priceEnd / 256;\r\n    uint btiEnd = priceEnd % 256;\r\n\r\n    uint wbm = occupiedPriceBitmaps[bmi] >> bti;\r\n    \r\n    while (bmi < bmiEnd) {\r\n      if (wbm == 0 || bti == 256) {\r\n        bti = 0;\r\n        bmi++;\r\n        wbm = occupiedPriceBitmaps[bmi];\r\n      } else {\r\n        if ((wbm & 1) != 0) {\r\n          // careful - copy-pasted in below loop\r\n          price = uint16(bmi * 256 + bti);\r\n          (depthBase, orderCount) = sumDepth(orderChainForOccupiedPrice[price].firstOrderId);\r\n          return (price, depthBase, orderCount, block.number);\r\n        }\r\n        bti += 1;\r\n        wbm /= 2;\r\n      }\r\n    }\r\n    // we've reached the last bitmap we need to search, stop at btiEnd not 256 this time.\r\n    while (bti <= btiEnd && wbm != 0) {\r\n      if ((wbm & 1) != 0) {\r\n        // careful - copy-pasted in above loop\r\n        price = uint16(bmi * 256 + bti);\r\n        (depthBase, orderCount) = sumDepth(orderChainForOccupiedPrice[price].firstOrderId);\r\n        return (price, depthBase, orderCount, block.number);\r\n      }\r\n      bti += 1;\r\n      wbm /= 2;\r\n    }\r\n    return (uint16(priceEnd), 0, 0, block.number);\r\n  }\r\n\r\n  // Internal Book View.\r\n  //\r\n  // See walkBook - adds up open depth at a price starting from an\r\n  // order which is assumed to be open. Careful - unlimited gas use.\r\n  //\r\n  function sumDepth(uint128 orderId) internal constant returns (uint depth, uint orderCount) {\r\n    while (true) {\r\n      Order storage order = orderForOrderId[orderId];\r\n      depth += order.sizeBase - order.executedBase;\r\n      orderCount++;\r\n      orderId = orderChainNodeForOpenOrderId[orderId].nextOrderId;\r\n      if (orderId == 0) {\r\n        return (depth, orderCount);\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"fromPrice\",\"type\":\"uint16\"}],\"name\":\"walkBook\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint16\"},{\"name\":\"depthBase\",\"type\":\"uint256\"},{\"name\":\"orderCount\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint16\"},{\"name\":\"sizeBase\",\"type\":\"uint256\"},{\"name\":\"terms\",\"type\":\"uint8\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"reasonCode\",\"type\":\"uint8\"},{\"name\":\"executedBase\",\"type\":\"uint256\"},{\"name\":\"executedCntr\",\"type\":\"uint256\"},{\"name\":\"feesBaseOrCntr\",\"type\":\"uint256\"},{\"name\":\"feesRwrd\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountCntr\",\"type\":\"uint256\"}],\"name\":\"withdrawCntr\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBookInfo\",\"outputs\":[{\"name\":\"_bookType\",\"type\":\"uint8\"},{\"name\":\"_baseToken\",\"type\":\"address\"},{\"name\":\"_rwrdToken\",\"type\":\"address\"},{\"name\":\"_baseMinInitialSize\",\"type\":\"uint256\"},{\"name\":\"_cntrMinInitialSize\",\"type\":\"uint256\"},{\"name\":\"_feeDivisor\",\"type\":\"uint256\"},{\"name\":\"_feeCollector\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"getOrderState\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"reasonCode\",\"type\":\"uint8\"},{\"name\":\"executedBase\",\"type\":\"uint256\"},{\"name\":\"executedCntr\",\"type\":\"uint256\"},{\"name\":\"feesBaseOrCntr\",\"type\":\"uint256\"},{\"name\":\"feesRwrd\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountBase\",\"type\":\"uint256\"}],\"name\":\"transferBase\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountRwrd\",\"type\":\"uint256\"}],\"name\":\"transferRwrd\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositCntr\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferFromBase\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"client\",\"type\":\"address\"}],\"name\":\"getClientBalances\",\"outputs\":[{\"name\":\"bookBalanceBase\",\"type\":\"uint256\"},{\"name\":\"bookBalanceCntr\",\"type\":\"uint256\"},{\"name\":\"bookBalanceRwrd\",\"type\":\"uint256\"},{\"name\":\"approvedBalanceBase\",\"type\":\"uint256\"},{\"name\":\"approvedBalanceRwrd\",\"type\":\"uint256\"},{\"name\":\"ownBalanceBase\",\"type\":\"uint256\"},{\"name\":\"ownBalanceRwrd\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"changeFeeCollector\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferFromRwrd\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"maybeLastOrderIdReturned\",\"type\":\"uint128\"},{\"name\":\"minClosedOrderIdCutoff\",\"type\":\"uint128\"}],\"name\":\"walkClientOrders\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint128\"},{\"name\":\"price\",\"type\":\"uint16\"},{\"name\":\"sizeBase\",\"type\":\"uint256\"},{\"name\":\"terms\",\"type\":\"uint8\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"reasonCode\",\"type\":\"uint8\"},{\"name\":\"executedBase\",\"type\":\"uint256\"},{\"name\":\"executedCntr\",\"type\":\"uint256\"},{\"name\":\"feesBaseOrCntr\",\"type\":\"uint256\"},{\"name\":\"feesRwrd\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint128\"},{\"name\":\"price\",\"type\":\"uint16\"},{\"name\":\"sizeBase\",\"type\":\"uint256\"},{\"name\":\"terms\",\"type\":\"uint8\"},{\"name\":\"maxMatches\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint128\"},{\"name\":\"maxMatches\",\"type\":\"uint256\"}],\"name\":\"continueOrder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseToken\",\"type\":\"address\"},{\"name\":\"_rwrdToken\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"clientPaymentEventType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"balanceType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"clientBalanceDelta\",\"type\":\"int256\"}],\"name\":\"ClientPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"clientOrderEventType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint128\"}],\"name\":\"ClientOrderEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"eventTimestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"orderId\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"marketOrderEventType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"depthBase\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tradeBase\",\"type\":\"uint256\"}],\"name\":\"MarketOrderEvent\",\"type\":\"event\"}]","ContractName":"BookERC20EthV1","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a1ec6996662f5487faa8dcc1e7acf6fc571cd16aebdd94ba875825a86a6e1865"}]}