{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract CryptoRushContract\r\n{\r\n\r\n  address owner;\r\n  address bot = 0x498f2B8129B153A3499E3812485C40178B6A5C48;\r\n  \r\n  uint fee;\r\n  bool registrationClosed;\r\n  uint registeredAccounts; // index\r\n  uint sharedBalanceID;\r\n  \r\n  struct Balance {\r\n      address user; // user address\r\n      uint lockedBalance; // how much funds are currently in the whole ecosystem\r\n      uint currBalance; // how much funds are currently available (to e.g. withdraw)\r\n      bool isInvestor; // special status in case user is investor\r\n      int investorCredit; // if this is > 0 then fees get deducted from this virtual balance\r\n      // This will be extended in the near future to allow for more diversity in calculations\r\n      \r\n  }\r\n  \r\n \r\n  \r\n\r\n  \r\n  mapping (address => Balance) balances;\r\n  \r\n \r\n  \r\n\r\n\r\n  event UpdateStatus(string _msg);\r\n  event UserStatus(string _msg, address user, uint amount);\r\n\r\n\r\n\r\n  function CryptoRushContract()\r\n  {\r\n    owner = msg.sender;\r\n    fee = 10; // 10% default fee\r\n    \r\n    \r\n   // uint _id = balances.length;\r\n    // add owner to the default balances\r\n    balances[owner].user = msg.sender;\r\n    balances[owner].lockedBalance = 0;\r\n    balances[owner].currBalance = 0;\r\n    balances[owner].isInvestor = true;\r\n    balances[owner].investorCredit = 0; // for now I am paying my own fees for proof of concept\r\n    registeredAccounts += 1;\r\n    \r\n  }\r\n\r\n  modifier ifOwner()\r\n  {\r\n    if (msg.sender != owner)\r\n    {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n  \r\n  modifier ifBot()\r\n  {\r\n    if (msg.sender != bot)\r\n    {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n  \r\n  // restricts access to approved users \r\n  modifier ifApproved()\r\n  {\r\n    if (msg.sender == balances[msg.sender].user)\r\n    {\r\n        _;\r\n    }\r\n    else\r\n    {\r\n        throw;\r\n    }\r\n  }\r\n  \r\n  \r\n  function closeContract() ifOwner\r\n  {\r\n      suicide(owner);\r\n  }\r\n  \r\n  // placeholder in case I manage to implement an auto-updater for V1\r\n  function updateContract() ifOwner\r\n  {\r\n      \r\n  }\r\n  \r\n  // only owner can approve new User and currently owner can't remove user once registered.\r\n  // Transparency and Trust yaaay!\r\n  function approveUser(address _user) ifOwner\r\n  {\r\n      balances[_user].user = _user;\r\n      balances[_user].lockedBalance = 0;\r\n      balances[_user].currBalance = 0;\r\n      balances[_user].isInvestor = false;\r\n      \r\n      registeredAccounts += 1;\r\n  }\r\n  \r\n  function approveAsInvestor(address _user, int _investorCredit) ifOwner\r\n  {\r\n      balances[_user].user = _user;\r\n      balances[_user].isInvestor = true;\r\n      balances[_user].investorCredit = _investorCredit;\r\n      \r\n  }\r\n  \r\n  \r\n  \r\n  // only allow call from owner of the address asking\r\n  function getCurrBalance() constant returns (uint _balance)\r\n  {\r\n      if(balances[msg.sender].user == msg.sender)\r\n      {\r\n        return balances[msg.sender].currBalance;    \r\n      }\r\n      else\r\n      {\r\n          throw;\r\n      }\r\n      \r\n  }\r\n  \r\n  // only allow call from owner of the address asking\r\n  function getLockedBalance() constant returns (uint _balance)\r\n  {\r\n      if(balances[msg.sender].user == msg.sender)\r\n      {\r\n        return balances[msg.sender].lockedBalance;    \r\n      }\r\n      else\r\n      {\r\n          throw;\r\n      }\r\n      \r\n  }\r\n  \r\n  // only allow call from owner of the address asking\r\n  function getInvestorCredit() constant returns (int _balance)\r\n  {\r\n      if(balances[msg.sender].user == msg.sender)\r\n      {\r\n        return balances[msg.sender].investorCredit;    \r\n      }\r\n      else\r\n      {\r\n          throw;\r\n      }\r\n      \r\n  }\r\n  \r\n\r\n  // default deposit function used by Users\r\n  function depositFunds() payable\r\n  {\r\n     \r\n     // if user is not approved then do not add it to the balances in order to stop overbloating the array thus sabotaging the platform\r\n     if (!(msg.sender == balances[msg.sender].user))\r\n     {\r\n        // user is not approved so add it to the owner's account balance\r\n        \r\n        balances[owner].currBalance += msg.value;\r\n        UserStatus('User is not approved thus donating ether to the contract', msg.sender, msg.value);\r\n     }\r\n     else\r\n     {  // user is approved so add it to their balance\r\n         \r\n        balances[msg.sender].currBalance += msg.value; // and current balance\r\n        UserStatus('User has deposited some funds', msg.sender, msg.value);\r\n     }\r\n      \r\n      \r\n      \r\n  }\r\n\r\n \r\n\r\n  function withdrawFunds (uint amount) ifApproved\r\n  {\r\n      if (balances[msg.sender].currBalance >= amount)\r\n      {\r\n          // user has enough funds, so pay him out!\r\n          \r\n          balances[msg.sender].currBalance -= amount;\r\n         \r\n          \r\n          // this function can be called multiple times so stop that from happening by\r\n          // removing the balances before the transaction is being sent!\r\n          \r\n          if (msg.sender.send(amount)) \r\n          {\r\n              // all okay!\r\n               UserStatus(\"User has withdrawn funds\", msg.sender, amount);\r\n          }\r\n          else\r\n          {\r\n              // if send failed, reset balances!\r\n              balances[msg.sender].currBalance += amount;\r\n             \r\n          }\r\n      }\r\n      else\r\n      {\r\n          throw;\r\n      }\r\n      \r\n  }\r\n  \r\n  \r\n  \r\n  // Bot grabs balance from user's account\r\n  function allocateBalance(uint amount, address user) ifBot\r\n  {\r\n      // has user enough funds? remember this is being called by Backend!\r\n      if (balances[user].currBalance >= amount)\r\n      {\r\n          balances[user].currBalance -= amount;\r\n          balances[user].lockedBalance += amount; \r\n          if (bot.send(amount))\r\n          {\r\n            UserStatus('Bot has allocated balances', user, msg.value);\r\n          }\r\n          else\r\n          {\r\n              // if fail then reset state\r\n              balances[user].currBalance += amount;\r\n              balances[user].lockedBalance -= amount;\r\n          }\r\n      }\r\n      \r\n  }\r\n  \r\n  \r\n  \r\n  // SHARED BOT STUFF START\r\n \r\n  \r\n  // SHARED BOT STUFF END\r\n  \r\n  \r\n  \r\n  function deallocateBalance(address target) payable ifBot \r\n  {\r\n      // check if everything fine with bot value\r\n      \r\n      \r\n      if (msg.value > balances[target].lockedBalance)\r\n      {\r\n          // profit has been made! Time to pay some fees!!11\r\n          uint profit = msg.value - balances[target].lockedBalance;\r\n          \r\n          uint newFee = profit * fee/100;\r\n          uint netProfit = profit - newFee;\r\n          uint newBalance = balances[target].lockedBalance + netProfit;\r\n          int vFee = int(newFee);\r\n          \r\n          if (balances[target].isInvestor == true)\r\n          {\r\n              \r\n              \r\n              // if user is investor and has credits left \r\n              if (balances[target].investorCredit > 0 )\r\n              {\r\n                  // deduct virtual balance\r\n                  \r\n                  balances[target].investorCredit -= vFee;\r\n                  \r\n                  if (balances[target].investorCredit < 0)\r\n                  {\r\n                      // credit is gone, recalculate profit\r\n                      int toCalc = balances[target].investorCredit * -1;\r\n                      uint newCalc = uint(toCalc);\r\n                      profit -= newCalc; // deduct remaining fees\r\n                      balances[target].currBalance += balances[target].lockedBalance + profit; // full profit gets added\r\n                      balances[target].lockedBalance = 0; \r\n                      \r\n                      balances[owner].currBalance += newCalc;\r\n                  }\r\n                  else\r\n                  {\r\n                    //UserStatus(\"investor credit deducted\", target, vFee);\r\n                     // add full profit \r\n                     balances[target].currBalance += balances[target].lockedBalance + profit; // full profit gets added\r\n                     balances[target].lockedBalance = 0;    \r\n                  }\r\n                  \r\n                  \r\n              }\r\n              else // if no credit left\r\n              {\r\n                  // get special fees ??\r\n                  balances[target].currBalance += newBalance;\r\n                  balances[target].lockedBalance = 0;\r\n                  balances[owner].currBalance += newFee; // add fee to owner account\r\n              }\r\n          }\r\n          else\r\n          {\r\n              balances[target].currBalance += newBalance;\r\n              balances[target].lockedBalance = 0;\r\n              balances[owner].currBalance += newFee;\r\n          }\r\n      }\r\n      else\r\n      {\r\n          // no profit detected so no fees to pay!\r\n          // platform looses some eth to gas though...!\r\n          balances[target].lockedBalance = 0;\r\n          balances[target].currBalance += msg.value;\r\n          \r\n      }\r\n      \r\n      \r\n      \r\n  }\r\n  \r\n  \r\n   \r\n\r\n  \r\n  \r\n  \r\n\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLockedBalance\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_investorCredit\",\"type\":\"int256\"}],\"name\":\"approveAsInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"allocateBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorCredit\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"deallocateBalance\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrBalance\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"approveUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositFunds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_msg\",\"type\":\"string\"}],\"name\":\"UpdateStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UserStatus\",\"type\":\"event\"}]","ContractName":"CryptoRushContract","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://eeb1abbea48fa081638f8239c220a16eb51776886d1b5df60feb6d1f50f0e288"}]}