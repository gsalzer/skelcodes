{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.17;\r\n\r\nlibrary IdeaUint {\r\n\r\n    function add(uint a, uint b) constant internal returns (uint result) {\r\n        uint c = a + b;\r\n\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) constant internal returns (uint result) {\r\n        uint c = a - b;\r\n\r\n        assert(b <= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint a, uint b) constant internal returns (uint result) {\r\n        uint c = a * b;\r\n\r\n        assert(a == 0 || c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) constant internal returns (uint result) {\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract IdeaBasicCoin {\r\n    using IdeaUint for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint public totalSupply;\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    address[] public accounts;\r\n    mapping(address => bool) internal accountsMap;\r\n    address public owner;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        tryCreateAccount(_to);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        tryCreateAccount(_to);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    function tryCreateAccount(address _account) internal {\r\n        if (!accountsMap[_account]) {\r\n            accounts.push(_account);\r\n            accountsMap[_account] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract IdeaCoin is IdeaBasicCoin {\r\n\r\n    uint public earnedEthWei;\r\n    uint public soldIdeaWei;\r\n    uint public soldIdeaWeiPreIco;\r\n    uint public soldIdeaWeiIco;\r\n    uint public soldIdeaWeiPostIco;\r\n    uint public icoStartTimestamp;\r\n    mapping(address => uint) public pieBalances;\r\n    address[] public pieAccounts;\r\n    mapping(address => bool) internal pieAccountsMap;\r\n    uint public nextRoundReserve;\r\n    address[] public projects;\r\n    address public projectAgent;\r\n    address public bank1;\r\n    address public bank2;\r\n    uint public bank1Val;\r\n    uint public bank2Val;\r\n    uint public bankValReserve;\r\n\r\n    enum IcoStates {\r\n    Coming,\r\n    PreIco,\r\n    Ico,\r\n    PostIco,\r\n    Done\r\n    }\r\n\r\n    IcoStates public icoState;\r\n\r\n    function IdeaCoin() {\r\n        name = 'IdeaCoin';\r\n        symbol = 'IDEA';\r\n        decimals = 18;\r\n        totalSupply = 100000000 ether;\r\n\r\n        owner = msg.sender;\r\n        tryCreateAccount(msg.sender);\r\n    }\r\n\r\n    function() payable {\r\n        uint tokens;\r\n        bool moreThenPreIcoMin = msg.value >= 20 ether;\r\n        uint totalVal = msg.value + bankValReserve;\r\n        uint halfVal = totalVal / 2;\r\n\r\n        if (icoState == IcoStates.PreIco && moreThenPreIcoMin && soldIdeaWeiPreIco <= 2500000 ether) {\r\n\r\n            tokens = msg.value * 1500;\r\n            balances[msg.sender] += tokens;\r\n            soldIdeaWeiPreIco += tokens;\r\n\r\n        } else if (icoState == IcoStates.Ico && soldIdeaWeiIco <= 35000000 ether) {\r\n            uint elapsed = now - icoStartTimestamp;\r\n\r\n            if (elapsed <= 1 days) {\r\n\r\n                tokens = msg.value * 1250;\r\n                balances[msg.sender] += tokens;\r\n\r\n            } else if (elapsed <= 6 days && elapsed > 1 days) {\r\n\r\n                tokens = msg.value * 1150;\r\n                balances[msg.sender] += tokens;\r\n\r\n            } else if (elapsed <= 11 days && elapsed > 6 days) {\r\n\r\n                tokens = msg.value * 1100;\r\n                balances[msg.sender] += tokens;\r\n\r\n            } else if (elapsed <= 16 days && elapsed > 11 days) {\r\n\r\n                tokens = msg.value * 1050;\r\n                balances[msg.sender] += tokens;\r\n\r\n            } else {\r\n\r\n                tokens = msg.value * 1000;\r\n                balances[msg.sender] += tokens;\r\n\r\n            }\r\n\r\n            soldIdeaWeiIco += tokens;\r\n\r\n        } else if (icoState == IcoStates.PostIco && soldIdeaWeiPostIco <= 12000000 ether) {\r\n\r\n            tokens = msg.value * 500;\r\n            balances[msg.sender] += tokens;\r\n            soldIdeaWeiPostIco += tokens;\r\n\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        earnedEthWei += msg.value;\r\n        soldIdeaWei += tokens;\r\n\r\n        bank1Val += halfVal;\r\n        bank2Val += halfVal;\r\n        bankValReserve = totalVal - (halfVal * 2);\r\n\r\n        tryCreateAccount(msg.sender);\r\n    }\r\n\r\n    function setBank(address _bank1, address _bank2) public onlyOwner {\r\n        require(bank1 == address(0x0));\r\n        require(bank2 == address(0x0));\r\n        require(_bank1 != address(0x0));\r\n        require(_bank2 != address(0x0));\r\n\r\n        bank1 = _bank1;\r\n        bank2 = _bank2;\r\n\r\n        balances[bank1] = 500000 ether;\r\n        balances[bank2] = 500000 ether;\r\n    }\r\n\r\n    function startPreIco() public onlyOwner {\r\n        icoState = IcoStates.PreIco;\r\n    }\r\n\r\n    function stopPreIcoAndBurn() public onlyOwner {\r\n        stopAnyIcoAndBurn(\r\n        (2500000 ether - soldIdeaWeiPreIco) * 2\r\n        );\r\n        balances[bank1] += soldIdeaWeiPreIco / 2;\r\n        balances[bank2] += soldIdeaWeiPreIco / 2;\r\n    }\r\n\r\n    function startIco() public onlyOwner {\r\n        icoState = IcoStates.Ico;\r\n        icoStartTimestamp = now;\r\n    }\r\n\r\n    function stopIcoAndBurn() public onlyOwner {\r\n        stopAnyIcoAndBurn(\r\n        (35000000 ether - soldIdeaWeiIco) * 2\r\n        );\r\n        balances[bank1] += soldIdeaWeiIco / 2;\r\n        balances[bank2] += soldIdeaWeiIco / 2;\r\n    }\r\n\r\n    function startPostIco() public onlyOwner {\r\n        icoState = IcoStates.PostIco;\r\n    }\r\n\r\n    function stopPostIcoAndBurn() public onlyOwner {\r\n        stopAnyIcoAndBurn(\r\n        (12000000 ether - soldIdeaWeiPostIco) * 2\r\n        );\r\n        balances[bank1] += soldIdeaWeiPostIco / 2;\r\n        balances[bank2] += soldIdeaWeiPostIco / 2;\r\n    }\r\n\r\n    function stopAnyIcoAndBurn(uint _burn) internal {\r\n        icoState = IcoStates.Coming;\r\n        totalSupply = totalSupply.sub(_burn);\r\n    }\r\n\r\n    function withdrawEther() public {\r\n        require(msg.sender == bank1 || msg.sender == bank2);\r\n\r\n        if (msg.sender == bank1) {\r\n            bank1.transfer(bank1Val);\r\n            bank1Val = 0;\r\n        }\r\n\r\n        if (msg.sender == bank2) {\r\n            bank2.transfer(bank2Val);\r\n            bank2Val = 0;\r\n        }\r\n\r\n        if (bank1Val == 0 && bank2Val == 0 && this.balance != 0) {\r\n            owner.transfer(this.balance);\r\n        }\r\n    }\r\n\r\n    function pieBalanceOf(address _owner) constant public returns (uint balance) {\r\n        return pieBalances[_owner];\r\n    }\r\n\r\n    function transferToPie(uint _amount) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        pieBalances[msg.sender] = pieBalances[msg.sender].add(_amount);\r\n        tryCreatePieAccount(msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFromPie(uint _amount) public returns (bool success) {\r\n        pieBalances[msg.sender] = pieBalances[msg.sender].sub(_amount);\r\n        balances[msg.sender] = balances[msg.sender].add(_amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function receiveDividends(uint _amount) internal {\r\n        uint minBalance = 10000 ether;\r\n        uint pieSize = calcPieSize(minBalance);\r\n        uint amount = nextRoundReserve + _amount;\r\n\r\n        accrueDividends(minBalance, pieSize, amount);\r\n    }\r\n\r\n    function calcPieSize(uint _minBalance) constant internal returns (uint _pieSize) {\r\n        for (uint i = 0; i < pieAccounts.length; i += 1) {\r\n            var balance = pieBalances[pieAccounts[i]];\r\n\r\n            if (balance >= _minBalance) {\r\n                _pieSize = _pieSize.add(balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    function accrueDividends(uint _minBalance, uint _pieSize, uint _amount) internal {\r\n        uint accrued;\r\n\r\n        for (uint i = 0; i < pieAccounts.length; i += 1) {\r\n            address account = pieAccounts[i];\r\n            uint balance = pieBalances[account];\r\n\r\n            if (balance >= _minBalance) {\r\n                uint dividends = (balance * _amount) / _pieSize;\r\n\r\n                accrued = accrued.add(dividends);\r\n                pieBalances[account] = balance.add(dividends);\r\n            }\r\n        }\r\n\r\n        nextRoundReserve = _amount.sub(accrued);\r\n    }\r\n\r\n    function tryCreatePieAccount(address _account) internal {\r\n        if (!pieAccountsMap[_account]) {\r\n            pieAccounts.push(_account);\r\n            pieAccountsMap[_account] = true;\r\n        }\r\n    }\r\n\r\n    function setProjectAgent(address _project) public onlyOwner {\r\n        projectAgent = _project;\r\n    }\r\n\r\n    function makeProject(string _name, uint _required, uint _requiredDays) public returns (address _address) {\r\n        _address = ProjectAgent(projectAgent).makeProject(msg.sender, _name, _required, _requiredDays);\r\n\r\n        projects.push(_address);\r\n    }\r\n\r\n    function withdrawFromProject(address _project, uint _stage) public returns (bool _success) {\r\n        uint _value;\r\n        (_success, _value) = ProjectAgent(projectAgent).withdrawFromProject(msg.sender, _project, _stage);\r\n\r\n        if (_success) {\r\n            receiveTrancheAndDividends(_value);\r\n        }\r\n    }\r\n\r\n    function cashBackFromProject(address _project) public returns (bool _success) {\r\n        uint _value;\r\n        (_success, _value) = ProjectAgent(projectAgent).cashBackFromProject(msg.sender, _project);\r\n\r\n        if (_success) {\r\n            balances[msg.sender] = balances[msg.sender].add(_value);\r\n        }\r\n    }\r\n\r\n    function receiveTrancheAndDividends(uint _sum) internal {\r\n        uint raw = _sum * 965;\r\n        uint reserve = raw % 1000;\r\n        uint tranche = (raw - reserve) / 1000;\r\n\r\n        balances[msg.sender] = balances[msg.sender].add(tranche);\r\n        receiveDividends(_sum - tranche);\r\n    }\r\n\r\n    function buyProduct(address _product, uint _amount) public {\r\n        ProjectAgent _agent = ProjectAgent(projectAgent);\r\n\r\n        uint _price = IdeaSubCoin(_product).price();\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_price * _amount);\r\n        _agent.buyProduct(_product, msg.sender, _amount);\r\n    }\r\n}\r\n\r\ncontract IdeaProject {\r\n    using IdeaUint for uint;\r\n\r\n    string public name;\r\n    address public engine;\r\n    address public owner;\r\n    uint public required;\r\n    uint public requiredDays;\r\n    uint public fundingEndTime;\r\n    uint public earned;\r\n    mapping(address => bool) public isCashBack;\r\n    uint public currentWorkStagePercent;\r\n    uint internal lastWorkStageStartTimestamp;\r\n    int8 public failStage = -1;\r\n    uint public failInvestPercents;\r\n    address[] public products;\r\n    uint public cashBackVotes;\r\n    mapping(address => uint) public cashBackWeight;\r\n\r\n    enum States {\r\n    Initial,\r\n    Coming,\r\n    Funding,\r\n    Workflow,\r\n    SuccessDone,\r\n    FundingFail,\r\n    WorkFail\r\n    }\r\n\r\n    States public state = States.Initial;\r\n\r\n    struct WorkStage {\r\n    uint percent;\r\n    uint stageDays;\r\n    uint sum;\r\n    uint withdrawTime;\r\n    }\r\n\r\n    WorkStage[] public workStages;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyEngine() {\r\n        require(msg.sender == engine);\r\n        _;\r\n    }\r\n\r\n    modifier onlyState(States _state) {\r\n        require(state == _state);\r\n        _;\r\n    }\r\n\r\n    modifier onlyProduct() {\r\n        bool permissionGranted;\r\n\r\n        for (uint8 i; i < products.length; i += 1) {\r\n            if (msg.sender == products[i]) {\r\n                permissionGranted = true;\r\n            }\r\n        }\r\n\r\n        if (permissionGranted) {\r\n            _;\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function IdeaProject(\r\n    address _owner,\r\n    string _name,\r\n    uint _required,\r\n    uint _requiredDays\r\n    ) {\r\n        require(bytes(_name).length > 0);\r\n        require(_required != 0);\r\n\r\n        require(_requiredDays >= 10);\r\n        require(_requiredDays <= 100);\r\n\r\n        engine = msg.sender;\r\n        owner = _owner;\r\n        name = _name;\r\n        required = _required;\r\n        requiredDays = _requiredDays;\r\n    }\r\n\r\n    function addEarned(uint _earned) public onlyEngine {\r\n        earned = earned.add(_earned);\r\n    }\r\n\r\n    function isFundingState() constant public returns (bool _result) {\r\n        return state == States.Funding;\r\n    }\r\n\r\n    function isWorkflowState() constant public returns (bool _result) {\r\n        return state == States.Workflow;\r\n    }\r\n\r\n    function isSuccessDoneState() constant public returns (bool _result) {\r\n        return state == States.SuccessDone;\r\n    }\r\n\r\n    function isFundingFailState() constant public returns (bool _result) {\r\n        return state == States.FundingFail;\r\n    }\r\n\r\n    function isWorkFailState() constant public returns (bool _result) {\r\n        return state == States.WorkFail;\r\n    }\r\n\r\n    function markAsComingAndFreeze() public onlyState(States.Initial) onlyOwner {\r\n        require(products.length > 0);\r\n        require(currentWorkStagePercent == 100);\r\n\r\n        state = States.Coming;\r\n    }\r\n\r\n    function startFunding() public onlyState(States.Coming) onlyOwner {\r\n        state = States.Funding;\r\n\r\n        fundingEndTime = uint64(now + requiredDays * 1 days);\r\n        calcLastWorkStageStart();\r\n        calcWithdrawTime();\r\n    }\r\n\r\n    function projectWorkStarted() public onlyState(States.Funding) onlyEngine {\r\n        startWorkflow();\r\n    }\r\n\r\n    function startWorkflow() internal {\r\n        uint used;\r\n        uint current;\r\n        uint len = workStages.length;\r\n\r\n        state = States.Workflow;\r\n\r\n        for (uint8 i; i < len; i += 1) {\r\n            current = earned.mul(workStages[i].percent).div(100);\r\n            workStages[i].sum = current;\r\n            used = used.add(current);\r\n        }\r\n\r\n        workStages[len - 1].sum = workStages[len - 1].sum.add(earned.sub(used));\r\n    }\r\n\r\n    function projectDone() public onlyState(States.Workflow) onlyOwner {\r\n        require(now > lastWorkStageStartTimestamp);\r\n\r\n        state = States.SuccessDone;\r\n    }\r\n\r\n    function projectFundingFail() public onlyState(States.Funding) onlyEngine {\r\n        state = States.FundingFail;\r\n    }\r\n\r\n    function projectWorkFail() internal {\r\n        state = States.WorkFail;\r\n\r\n        for (uint8 i = 1; i < workStages.length; i += 1) {\r\n            failInvestPercents += workStages[i - 1].percent;\r\n\r\n            if (workStages[i].withdrawTime > now) {\r\n                failStage = int8(i - 1);\r\n\r\n                i = uint8(workStages.length);\r\n            }\r\n        }\r\n\r\n        if (failStage == -1) {\r\n            failStage = int8(workStages.length - 1);\r\n            failInvestPercents = 100;\r\n        }\r\n    }\r\n\r\n    function makeWorkStage(\r\n    uint _percent,\r\n    uint _stageDays\r\n    ) public onlyState(States.Initial) {\r\n        require(workStages.length <= 10);\r\n        require(_stageDays >= 10);\r\n        require(_stageDays <= 100);\r\n\r\n        if (currentWorkStagePercent.add(_percent) > 100) {\r\n            revert();\r\n        } else {\r\n            currentWorkStagePercent = currentWorkStagePercent.add(_percent);\r\n        }\r\n\r\n        workStages.push(WorkStage(\r\n        _percent,\r\n        _stageDays,\r\n        0,\r\n        0\r\n        ));\r\n    }\r\n\r\n    function calcLastWorkStageStart() internal {\r\n        lastWorkStageStartTimestamp = fundingEndTime;\r\n\r\n        for (uint8 i; i < workStages.length - 1; i += 1) {\r\n            lastWorkStageStartTimestamp += workStages[i].stageDays * 1 days;\r\n        }\r\n    }\r\n\r\n    function calcWithdrawTime() internal {\r\n        for (uint8 i; i < workStages.length; i += 1) {\r\n            if (i == 0) {\r\n                workStages[i].withdrawTime = now + requiredDays * 1 days;\r\n            } else {\r\n                workStages[i].withdrawTime = workStages[i - 1].withdrawTime + workStages[i - 1].stageDays * 1 days;\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw(uint _stage) public onlyEngine returns (uint _sum) {\r\n        WorkStage memory stageStruct = workStages[_stage];\r\n\r\n        if (stageStruct.withdrawTime <= now) {\r\n            _sum = stageStruct.sum;\r\n\r\n            workStages[_stage].sum = 0;\r\n        }\r\n    }\r\n\r\n    function voteForCashBack() public {\r\n        voteForCashBackInPercentOfWeight(100);\r\n    }\r\n\r\n    function cancelVoteForCashBack() public {\r\n        voteForCashBackInPercentOfWeight(0);\r\n    }\r\n\r\n    function voteForCashBackInPercentOfWeight(uint _percent) public {\r\n        voteForCashBackInPercentOfWeightForAccount(msg.sender, _percent);\r\n    }\r\n\r\n    function voteForCashBackInPercentOfWeightForAccount(address _account, uint _percent) internal {\r\n        require(_percent <= 100);\r\n\r\n        updateFundingStateIfNeed();\r\n\r\n        if (state == States.Workflow) {\r\n            uint currentWeight = cashBackWeight[_account];\r\n            uint supply;\r\n            uint part;\r\n\r\n            for (uint8 i; i < products.length; i += 1) {\r\n                supply += IdeaSubCoin(products[i]).totalSupply();\r\n                part += IdeaSubCoin(products[i]).balanceOf(_account);\r\n            }\r\n\r\n            cashBackVotes += ((part * (10 ** 10)) / supply) * (_percent - currentWeight);\r\n            cashBackWeight[_account] = _percent;\r\n\r\n            if (cashBackVotes > 50 * (10 ** 10)) {\r\n                projectWorkFail();\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateVotesOnTransfer(address _from, address _to) public onlyProduct {\r\n        if (isWorkflowState()) {\r\n            voteForCashBackInPercentOfWeightForAccount(_from, 0);\r\n            voteForCashBackInPercentOfWeightForAccount(_to, 0);\r\n        }\r\n    }\r\n\r\n    function makeProduct(\r\n    string _name,\r\n    string _symbol,\r\n    uint _price,\r\n    uint _limit\r\n    ) public onlyState(States.Initial) onlyOwner returns (address _productAddress) {\r\n        require(products.length <= 25);\r\n\r\n        IdeaSubCoin product = new IdeaSubCoin(msg.sender, _name, _symbol, _price, _limit, engine);\r\n\r\n        products.push(address(product));\r\n\r\n        return address(product);\r\n    }\r\n\r\n    function calcInvesting(address _account) public onlyEngine returns (uint _sum) {\r\n        require(!isCashBack[_account]);\r\n\r\n        for (uint8 i = 0; i < products.length; i += 1) {\r\n            IdeaSubCoin product = IdeaSubCoin(products[i]);\r\n\r\n            _sum = _sum.add(product.balanceOf(_account) * product.price());\r\n        }\r\n\r\n        if (isWorkFailState()) {\r\n            _sum = _sum.mul(100 - failInvestPercents).div(100);\r\n        }\r\n\r\n        isCashBack[_account] = true;\r\n    }\r\n\r\n    function updateFundingStateIfNeed() internal {\r\n        if (isFundingState() && now > fundingEndTime) {\r\n            if (earned >= required) {\r\n                startWorkflow();\r\n            } else {\r\n                state = States.FundingFail;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ProjectAgent {\r\n\r\n    address public owner;\r\n    address public coin;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCoin() {\r\n        require(msg.sender == coin);\r\n        _;\r\n    }\r\n\r\n    function ProjectAgent() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function makeProject(\r\n    address _owner,\r\n    string _name,\r\n    uint _required,\r\n    uint _requiredDays\r\n    ) public returns (address _address) {\r\n        return address(\r\n        new IdeaProject(\r\n        _owner,\r\n        _name,\r\n        _required,\r\n        _requiredDays\r\n        )\r\n        );\r\n    }\r\n\r\n    function setCoin(address _coin) public onlyOwner {\r\n        coin = _coin;\r\n    }\r\n\r\n    function withdrawFromProject(\r\n    address _owner,\r\n    address _project,\r\n    uint _stage\r\n    ) public onlyCoin returns (bool _success, uint _value) {\r\n        require(_owner == IdeaProject(_project).owner());\r\n\r\n        IdeaProject project = IdeaProject(_project);\r\n        updateFundingStateIfNeed(_project);\r\n\r\n        if (project.isWorkflowState() || project.isSuccessDoneState()) {\r\n            _value = project.withdraw(_stage);\r\n\r\n            if (_value > 0) {\r\n                _success = true;\r\n            } else {\r\n                _success = false;\r\n            }\r\n        } else {\r\n            _success = false;\r\n        }\r\n    }\r\n\r\n    function cashBackFromProject(\r\n    address _owner,\r\n    address _project\r\n    ) public onlyCoin returns (bool _success, uint _value) {\r\n        IdeaProject project = IdeaProject(_project);\r\n\r\n        updateFundingStateIfNeed(_project);\r\n\r\n        if (\r\n        project.isFundingFailState() ||\r\n        project.isWorkFailState()\r\n        ) {\r\n            _value = project.calcInvesting(_owner);\r\n            _success = true;\r\n        } else {\r\n            _success = false;\r\n        }\r\n    }\r\n\r\n    function updateFundingStateIfNeed(address _project) internal {\r\n        IdeaProject project = IdeaProject(_project);\r\n\r\n        if (\r\n        project.isFundingState() &&\r\n        now > project.fundingEndTime()\r\n        ) {\r\n            if (project.earned() >= project.required()) {\r\n                project.projectWorkStarted();\r\n            } else {\r\n                project.projectFundingFail();\r\n            }\r\n        }\r\n    }\r\n\r\n    function buyProduct(address _product, address _account, uint _amount) public onlyCoin {\r\n        IdeaSubCoin _productContract = IdeaSubCoin(_product);\r\n        address _project = _productContract.project();\r\n        IdeaProject _projectContract = IdeaProject(_project);\r\n\r\n        updateFundingStateIfNeed(_project);\r\n        require(_projectContract.isFundingState());\r\n\r\n        _productContract.buy(_account, _amount);\r\n        _projectContract.addEarned(_amount * _productContract.price());\r\n    }\r\n}\r\n\r\ncontract IdeaSubCoin is IdeaBasicCoin {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 0;\r\n    uint public limit;\r\n    uint public price;\r\n    address public project;\r\n    address public engine;\r\n    mapping(address => string) public shipping;\r\n\r\n    modifier onlyProject() {\r\n        require(msg.sender == project);\r\n        _;\r\n    }\r\n\r\n    modifier onlyEngine() {\r\n        require(msg.sender == engine);\r\n        _;\r\n    }\r\n\r\n    function IdeaSubCoin(\r\n    address _owner,\r\n    string _name,\r\n    string _symbol,\r\n    uint _price,\r\n    uint _limit,\r\n    address _engine\r\n    ) {\r\n        require(_price != 0);\r\n\r\n        owner = _owner;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        price = _price;\r\n        limit = _limit;\r\n        project = msg.sender;\r\n        engine = _engine;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(!IdeaProject(project).isCashBack(msg.sender));\r\n        require(!IdeaProject(project).isCashBack(_to));\r\n\r\n        IdeaProject(project).updateVotesOnTransfer(msg.sender, _to);\r\n\r\n        bool result = super.transfer(_to, _value);\r\n\r\n        if (!result) {\r\n            revert();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(!IdeaProject(project).isCashBack(_from));\r\n        require(!IdeaProject(project).isCashBack(_to));\r\n\r\n        IdeaProject(project).updateVotesOnTransfer(_from, _to);\r\n\r\n        bool result = super.transferFrom(_from, _to, _value);\r\n\r\n        if (!result) {\r\n            revert();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function buy(address _account, uint _amount) public onlyEngine {\r\n        uint total = totalSupply.add(_amount);\r\n\r\n        if (limit != 0) {\r\n            require(total <= limit);\r\n        }\r\n\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_account] = balances[_account].add(_amount);\r\n        tryCreateAccount(_account);\r\n    }\r\n\r\n    function setShipping(string _shipping) public {\r\n        require(bytes(_shipping).length > 0);\r\n\r\n        shipping[msg.sender] = _shipping;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"projects\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pieBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopPostIcoAndBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"}],\"name\":\"setProjectAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankValReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank1Val\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"}],\"name\":\"cashBackFromProject\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pieAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldIdeaWeiPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopPreIcoAndBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_project\",\"type\":\"address\"},{\"name\":\"_stage\",\"type\":\"uint256\"}],\"name\":\"withdrawFromProject\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earnedEthWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFromPie\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldIdeaWeiIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldIdeaWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextRoundReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_product\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyProduct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldIdeaWeiPostIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopIcoAndBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferToPie\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank2Val\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPostIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_requiredDays\",\"type\":\"uint256\"}],\"name\":\"makeProject\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bank1\",\"type\":\"address\"},{\"name\":\"_bank2\",\"type\":\"address\"}],\"name\":\"setBank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"pieBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"IdeaCoin","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7611fa619659f397867191b2212e558f306758202d1aad7ddb8e225ba56fc057"}]}