{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n/* A small utility contract that sends ether to other addresses by means of \r\n * SUICIDE/SELFDESTRUCT. Unlike for a normal send/call, if the receiving address\r\n * belongs to a contract, the contract's code is never called; one can\r\n * forcibly increase a contract's balance!\r\n *\r\n * To send $x to y using this technique, simply call `suicideSend(y)` with a \r\n * value of $x.\r\n *\r\n *\r\n * If you're interested in the implications of this trick, I recommend\r\n * looking at Jo√£o Carvalho's and Richard Moore's entries to the first\r\n * Underhanded Solidity Contest [1]. Anybody writing smart ontracts should be \r\n * aware of forced balance increases lest their contracts be vulnerable.\r\n * \r\n * [1] https://medium.com/@weka/announcing-the-winners-of-the-first-underhanded-solidity-coding-contest-282563a87079\r\n */\r\ncontract SuicideSender {\r\n    function suicideSend(address to) payable {\r\n        address temp_addr;\r\n        assembly {\r\n            let free_ptr := mload(0x40)\r\n            /* Prepare initcode that immediately forwards any funds to address\r\n             * `to` by running [PUSH20 to, SUICIDE].\r\n             */\r\n            mstore(free_ptr, or(0x730000000000000000000000000000000000000000ff, mul(to, 0x100)))\r\n            // Run initcode we just prepared.\r\n            temp_addr := create(callvalue, add(free_ptr, 10), 22)\r\n        }\r\n        require(temp_addr != 0);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"suicideSend\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"SuicideSender","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e3cd6345357828ac44fda4e324c5f5d8334428d02b32873030a8aced3043ea64"}]}