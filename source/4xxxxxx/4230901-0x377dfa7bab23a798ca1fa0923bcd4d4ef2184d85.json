{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract AbstractStarbaseToken is ERC20 {\r\n    function isFundraiser(address fundraiserAddress) public returns (bool);\r\n    function company() public returns (address);\r\n    function allocateToCrowdsalePurchaser(address to, uint256 value) public returns (bool);\r\n    function allocateToMarketingSupporter(address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract AbstractStarbaseCrowdsale {\r\n    function workshop() constant returns (address) {}\r\n    function startDate() constant returns (uint256) {}\r\n    function endedAt() constant returns (uint256) {}\r\n    function isEnded() constant returns (bool);\r\n    function totalRaisedAmountInCny() constant returns (uint256);\r\n    function numOfPurchasedTokensOnCsBy(address purchaser) constant returns (uint256);\r\n    function numOfPurchasedTokensOnEpBy(address purchaser) constant returns (uint256);\r\n}\r\n\r\n// @title EarlyPurchase contract - Keep track of purchased amount by Early Purchasers\r\n/// @author Starbase PTE. LTD. - <info@starbase.co>\r\ncontract StarbaseEarlyPurchase {\r\n    /*\r\n     *  Constants\r\n     */\r\n    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';    // Chinese Yuan\r\n    string public constant PURCHASE_AMOUNT_RATE_REFERENCE = 'http://www.xe.com/currencytables/';\r\n    uint256 public constant PURCHASE_AMOUNT_CAP = 9000000;\r\n\r\n    /*\r\n     *  Types\r\n     */\r\n    struct EarlyPurchase {\r\n        address purchaser;\r\n        uint256 amount;        // CNY based amount\r\n        uint256 purchasedAt;   // timestamp\r\n    }\r\n\r\n    /*\r\n     *  External contracts\r\n     */\r\n    AbstractStarbaseCrowdsale public starbaseCrowdsale;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public owner;\r\n    EarlyPurchase[] public earlyPurchases;\r\n    uint256 public earlyPurchaseClosedAt;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier noEther() {\r\n        require(msg.value == 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBeforeCrowdsale() {\r\n        assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyEarlyPurchaseTerm() {\r\n        assert(earlyPurchaseClosedAt <= 0);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Contract functions\r\n     */\r\n\r\n    /**\r\n     * @dev Returns early purchased amount by purchaser's address\r\n     * @param purchaser Purchaser address\r\n     */\r\n    function purchasedAmountBy(address purchaser)\r\n        external\r\n        constant\r\n        noEther\r\n        returns (uint256 amount)\r\n    {\r\n        for (uint256 i; i < earlyPurchases.length; i++) {\r\n            if (earlyPurchases[i].purchaser == purchaser) {\r\n                amount += earlyPurchases[i].amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total amount of raised funds by Early Purchasers\r\n     */\r\n    function totalAmountOfEarlyPurchases()\r\n        constant\r\n        noEther\r\n        public\r\n        returns (uint256 totalAmount)\r\n    {\r\n        for (uint256 i; i < earlyPurchases.length; i++) {\r\n            totalAmount += earlyPurchases[i].amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of early purchases\r\n     */\r\n    function numberOfEarlyPurchases()\r\n        external\r\n        constant\r\n        noEther\r\n        returns (uint256)\r\n    {\r\n        return earlyPurchases.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Append an early purchase log\r\n     * @param purchaser Purchaser address\r\n     * @param amount Purchase amount\r\n     * @param purchasedAt Timestamp of purchased date\r\n     */\r\n    function appendEarlyPurchase(address purchaser, uint256 amount, uint256 purchasedAt)\r\n        external\r\n        noEther\r\n        onlyOwner\r\n        onlyBeforeCrowdsale\r\n        onlyEarlyPurchaseTerm\r\n        returns (bool)\r\n    {\r\n        if (amount == 0 ||\r\n            totalAmountOfEarlyPurchases() + amount > PURCHASE_AMOUNT_CAP)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        assert(purchasedAt != 0 || purchasedAt <= now);\r\n\r\n        earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Close early purchase term\r\n     */\r\n    function closeEarlyPurchase()\r\n        external\r\n        noEther\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        earlyPurchaseClosedAt = now;\r\n    }\r\n\r\n    /**\r\n     * @dev Setup function sets external contract's address\r\n     * @param starbaseCrowdsaleAddress Token address\r\n     */\r\n    function setup(address starbaseCrowdsaleAddress)\r\n        external\r\n        noEther\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        if (address(starbaseCrowdsale) == 0) {\r\n            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Contract constructor function\r\n     */\r\n    function StarbaseEarlyPurchase() noEther {\r\n        owner = msg.sender;\r\n    }\r\n}\r\n\r\n\r\n/// @title EarlyPurchaseAmendment contract - Amend early purchase records of the original contract\r\n/// @author Starbase PTE. LTD. - <support@starbase.co>\r\ncontract StarbaseEarlyPurchaseAmendment {\r\n    /*\r\n     *  Events\r\n     */\r\n    event EarlyPurchaseInvalidated(uint256 epIdx);\r\n    event EarlyPurchaseAmended(uint256 epIdx);\r\n\r\n    /*\r\n     *  External contracts\r\n     */\r\n    AbstractStarbaseCrowdsale public starbaseCrowdsale;\r\n    StarbaseEarlyPurchase public starbaseEarlyPurchase;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public owner;\r\n    uint256[] public invalidEarlyPurchaseIndexes;\r\n    uint256[] public amendedEarlyPurchaseIndexes;\r\n    mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier noEther() {\r\n        require(msg.value == 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBeforeCrowdsale() {\r\n        assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyEarlyPurchasesLoaded() {\r\n        assert(address(starbaseEarlyPurchase) != address(0));\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Functions below are compatible with starbaseEarlyPurchase contract\r\n     */\r\n\r\n    /**\r\n     * @dev Returns an early purchase record\r\n     * @param earlyPurchaseIndex Index number of an early purchase\r\n     */\r\n    function earlyPurchases(uint256 earlyPurchaseIndex)\r\n        external\r\n        constant\r\n        onlyEarlyPurchasesLoaded\r\n        returns (address purchaser, uint256 amount, uint256 purchasedAt)\r\n    {\r\n        return starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns early purchased amount by purchaser's address\r\n     * @param purchaser Purchaser address\r\n     */\r\n    function purchasedAmountBy(address purchaser)\r\n        external\r\n        constant\r\n        noEther\r\n        returns (uint256 amount)\r\n    {\r\n        StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP =\r\n            normalizedEarlyPurchases();\r\n        for (uint256 i; i < normalizedEP.length; i++) {\r\n            if (normalizedEP[i].purchaser == purchaser) {\r\n                amount += normalizedEP[i].amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total amount of raised funds by Early Purchasers\r\n     */\r\n    function totalAmountOfEarlyPurchases()\r\n        constant\r\n        noEther\r\n        public\r\n        returns (uint256 totalAmount)\r\n    {\r\n        StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP =\r\n            normalizedEarlyPurchases();\r\n        for (uint256 i; i < normalizedEP.length; i++) {\r\n            totalAmount += normalizedEP[i].amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of early purchases\r\n     */\r\n    function numberOfEarlyPurchases()\r\n        external\r\n        constant\r\n        noEther\r\n        returns (uint256)\r\n    {\r\n        return normalizedEarlyPurchases().length;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets up function sets external contract's address\r\n     * @param starbaseCrowdsaleAddress Token address\r\n     */\r\n    function setup(address starbaseCrowdsaleAddress)\r\n        external\r\n        noEther\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        if (address(starbaseCrowdsale) == 0) {\r\n            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     *  Contract functions unique to StarbaseEarlyPurchaseAmendment\r\n     */\r\n\r\n     /**\r\n      * @dev Invalidate early purchase\r\n      * @param earlyPurchaseIndex Index number of the purchase\r\n      */\r\n    function invalidateEarlyPurchase(uint256 earlyPurchaseIndex)\r\n        external\r\n        noEther\r\n        onlyOwner\r\n        onlyEarlyPurchasesLoaded\r\n        onlyBeforeCrowdsale\r\n        returns (bool)\r\n    {\r\n        assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); // Array Index Out of Bounds Exception\r\n\r\n        for (uint256 i; i < invalidEarlyPurchaseIndexes.length; i++) {\r\n            assert(invalidEarlyPurchaseIndexes[i] != earlyPurchaseIndex);\r\n        }\r\n\r\n        invalidEarlyPurchaseIndexes.push(earlyPurchaseIndex);\r\n        EarlyPurchaseInvalidated(earlyPurchaseIndex);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether early purchase is invalid\r\n     * @param earlyPurchaseIndex Index number of the purchase\r\n     */\r\n    function isInvalidEarlyPurchase(uint256 earlyPurchaseIndex)\r\n        constant\r\n        noEther\r\n        public\r\n        returns (bool)\r\n    {\r\n        assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); // Array Index Out of Bounds Exception\r\n\r\n\r\n        for (uint256 i; i < invalidEarlyPurchaseIndexes.length; i++) {\r\n            if (invalidEarlyPurchaseIndexes[i] == earlyPurchaseIndex) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Amends a given early purchase with data\r\n     * @param earlyPurchaseIndex Index number of the purchase\r\n     * @param purchaser Purchaser's address\r\n     * @param amount Value of purchase\r\n     * @param purchasedAt Purchase timestamp\r\n     */\r\n    function amendEarlyPurchase(uint256 earlyPurchaseIndex, address purchaser, uint256 amount, uint256 purchasedAt)\r\n        external\r\n        noEther\r\n        onlyOwner\r\n        onlyEarlyPurchasesLoaded\r\n        onlyBeforeCrowdsale\r\n        returns (bool)\r\n    {\r\n        assert(purchasedAt != 0 || purchasedAt <= now);\r\n\r\n        assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex);\r\n\r\n        assert(!isInvalidEarlyPurchase(earlyPurchaseIndex)); // Invalid early purchase cannot be amended\r\n\r\n        if (!isAmendedEarlyPurchase(earlyPurchaseIndex)) {\r\n            amendedEarlyPurchaseIndexes.push(earlyPurchaseIndex);\r\n        }\r\n\r\n        amendedEarlyPurchases[earlyPurchaseIndex] =\r\n            StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt);\r\n        EarlyPurchaseAmended(earlyPurchaseIndex);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether early purchase is amended\r\n     * @param earlyPurchaseIndex Index number of the purchase\r\n     */\r\n    function isAmendedEarlyPurchase(uint256 earlyPurchaseIndex)\r\n        constant\r\n        noEther\r\n        returns (bool)\r\n    {\r\n        assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); // Array Index Out of Bounds Exception\r\n\r\n        for (uint256 i; i < amendedEarlyPurchaseIndexes.length; i++) {\r\n            if (amendedEarlyPurchaseIndexes[i] == earlyPurchaseIndex) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Loads early purchases data to StarbaseEarlyPurchaseAmendment contract\r\n     * @param starbaseEarlyPurchaseAddress Address from starbase early purchase\r\n     */\r\n    function loadStarbaseEarlyPurchases(address starbaseEarlyPurchaseAddress)\r\n        external\r\n        noEther\r\n        onlyOwner\r\n        onlyBeforeCrowdsale\r\n        returns (bool)\r\n    {\r\n        assert(starbaseEarlyPurchaseAddress != 0 ||\r\n            address(starbaseEarlyPurchase) == 0);\r\n\r\n        starbaseEarlyPurchase = StarbaseEarlyPurchase(starbaseEarlyPurchaseAddress);\r\n        assert(starbaseEarlyPurchase.earlyPurchaseClosedAt() != 0); // the early purchase must be closed\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Contract constructor function. It sets owner\r\n     */\r\n    function StarbaseEarlyPurchaseAmendment() noEther {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Internal functions\r\n     */\r\n\r\n    /**\r\n     * @dev Normalizes early purchases data\r\n     */\r\n    function normalizedEarlyPurchases()\r\n        constant\r\n        internal\r\n        returns (StarbaseEarlyPurchase.EarlyPurchase[] normalizedEP)\r\n    {\r\n        uint256 rawEPCount = numberOfRawEarlyPurchases();\r\n        normalizedEP = new StarbaseEarlyPurchase.EarlyPurchase[](\r\n            rawEPCount - invalidEarlyPurchaseIndexes.length);\r\n\r\n        uint256 normalizedIdx;\r\n        for (uint256 i; i < rawEPCount; i++) {\r\n            if (isInvalidEarlyPurchase(i)) {\r\n                continue;   // invalid early purchase should be ignored\r\n            }\r\n\r\n            StarbaseEarlyPurchase.EarlyPurchase memory ep;\r\n            if (isAmendedEarlyPurchase(i)) {\r\n                ep = amendedEarlyPurchases[i];  // amended early purchase should take a priority\r\n            } else {\r\n                ep = getEarlyPurchase(i);\r\n            }\r\n\r\n            normalizedEP[normalizedIdx] = ep;\r\n            normalizedIdx++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches early purchases data\r\n     */\r\n    function getEarlyPurchase(uint256 earlyPurchaseIndex)\r\n        internal\r\n        constant\r\n        onlyEarlyPurchasesLoaded\r\n        returns (StarbaseEarlyPurchase.EarlyPurchase)\r\n    {\r\n        var (purchaser, amount, purchasedAt) =\r\n            starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex);\r\n        return StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns raw number of early purchases\r\n     */\r\n    function numberOfRawEarlyPurchases()\r\n        internal\r\n        constant\r\n        onlyEarlyPurchasesLoaded\r\n        returns (uint256)\r\n    {\r\n        return starbaseEarlyPurchase.numberOfEarlyPurchases();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale contract - Starbase crowdsale to create STAR.\r\n * @author Starbase PTE. LTD. - <info@starbase.co>\r\n */\r\ncontract StarbaseCrowdsale is Ownable {\r\n    /*\r\n     *  Events\r\n     */\r\n    event CrowdsaleEnded(uint256 endedAt);\r\n    event StarBasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate, uint256 bonusTokensPercentage);\r\n    event StarBasePurchasedOffChain(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyBtcRate, uint256 bonusTokensPercentage, string data);\r\n    event CnyEthRateUpdated(uint256 cnyEthRate);\r\n    event CnyBtcRateUpdated(uint256 cnyBtcRate);\r\n    event QualifiedPartnerAddress(address qualifiedPartner);\r\n    event PurchaseInvalidated(uint256 purchaseIdx);\r\n    event PurchaseAmended(uint256 purchaseIdx);\r\n\r\n    /**\r\n     *  External contracts\r\n     */\r\n    AbstractStarbaseToken public starbaseToken;\r\n    StarbaseEarlyPurchaseAmendment public starbaseEpAmendment;\r\n\r\n    /**\r\n     *  Constants\r\n     */\r\n    uint256 constant public crowdsaleTokenAmount = 125000000e18;\r\n    uint256 constant public earlyPurchaseTokenAmount = 50000000e18;\r\n    uint256 constant public MIN_INVESTMENT = 1; // min is 1 Wei\r\n    uint256 constant public MAX_CROWDSALE_CAP = 60000000; // approximately 9M USD for the crowdsale(CS). 1M (by EP) + 9M (by CS) = 10M (Total)\r\n    string public constant PURCHASE_AMOUNT_UNIT = 'CNY';  // Chinese Yuan\r\n\r\n    /**\r\n     * Types\r\n     */\r\n    struct CrowdsalePurchase {\r\n        address purchaser;\r\n        uint256 amount;        // CNY based amount with bonus\r\n        uint256 rawAmount;     // CNY based amount no bonus\r\n        uint256 purchasedAt;   // timestamp\r\n        string data;           // additional data (e.g. Tx ID of Bitcoin)\r\n        uint256 bonus;\r\n    }\r\n\r\n    struct QualifiedPartners {\r\n        uint256 amountCap;\r\n        uint256 amountRaised;\r\n        bool    bonaFide;\r\n        uint256 commissionFeePercentage; // example 5 will calculate the percentage as 5%\r\n    }\r\n\r\n    /**\r\n     *  Storage\r\n     */\r\n    address public workshop; // holds undelivered STARs\r\n\r\n    uint public numOfDeliveredCrowdsalePurchases = 0;  // index to keep the number of crowdsale purchases have already been processed by `deliverPurchasedTokens`\r\n    uint public numOfDeliveredEarlyPurchases = 0;  // index to keep the number of early purchases have already been processed by `deliverPurchasedTokens`\r\n    uint256 public numOfLoadedEarlyPurchases = 0; // index to keep the number of early purchases that have already been loaded by `loadEarlyPurchases`\r\n\r\n    address[] public earlyPurchasers;\r\n    mapping (address => QualifiedPartners) public qualifiedPartners;\r\n    mapping (address => uint256) public earlyPurchasedAmountBy; // early purchased amount in CNY per purchasers' address\r\n    bool public earlyPurchasesLoaded = false;  // returns whether all early purchases are loaded into this contract\r\n\r\n    // crowdsale\r\n    uint256 public purchaseStartBlock;  // crowdsale purchases can be accepted from this block number\r\n    uint256 public startDate;\r\n    uint256 public endedAt;\r\n    CrowdsalePurchase[] public crowdsalePurchases;\r\n    uint256 public cnyBtcRate; // this rate won't be used from a smart contract function but external system\r\n    uint256 public cnyEthRate;\r\n\r\n    // bonus milestones\r\n    uint256 public firstBonusSalesEnds;\r\n    uint256 public secondBonusSalesEnds;\r\n    uint256 public thirdBonusSalesEnds;\r\n    uint256 public fourthBonusSalesEnds;\r\n    uint256 public fifthBonusSalesEnds;\r\n    uint256 public firstExtendedBonusSalesEnds;\r\n    uint256 public secondExtendedBonusSalesEnds;\r\n    uint256 public thirdExtendedBonusSalesEnds;\r\n    uint256 public fourthExtendedBonusSalesEnds;\r\n    uint256 public fifthExtendedBonusSalesEnds;\r\n    uint256 public sixthExtendedBonusSalesEnds;\r\n\r\n    // after the crowdsale\r\n    mapping(uint256 => CrowdsalePurchase) public invalidatedOrigPurchases;  // Original purchase which was invalidated by owner\r\n    mapping(uint256 => CrowdsalePurchase) public amendedOrigPurchases;      // Original purchase which was amended by owner\r\n\r\n    mapping (address => uint256) public numOfPurchasedTokensOnCsBy;    // the number of tokens purchased on the crowdsale by a purchaser\r\n    mapping (address => uint256) public numOfPurchasedTokensOnEpBy;    // the number of tokens early purchased by a purchaser\r\n\r\n    /**\r\n     *  Modifiers\r\n     */\r\n    modifier minInvestment() {\r\n        // User has to send at least the ether value of one token.\r\n        assert(msg.value >= MIN_INVESTMENT);\r\n        _;\r\n    }\r\n\r\n    modifier whenEnded() {\r\n        assert(isEnded());\r\n        _;\r\n    }\r\n\r\n    modifier hasBalance() {\r\n        assert(this.balance > 0);\r\n        _;\r\n    }\r\n    modifier rateIsSet(uint256 _rate) {\r\n        assert(_rate != 0);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotEnded() {\r\n        assert(!isEnded());\r\n        _;\r\n    }\r\n\r\n    modifier tokensNotDelivered() {\r\n        assert(numOfDeliveredCrowdsalePurchases == 0);\r\n        assert(numOfDeliveredEarlyPurchases == 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyFundraiser() {\r\n      assert(address(starbaseToken) != 0);\r\n      assert(starbaseToken.isFundraiser(msg.sender));\r\n      _;\r\n    }\r\n\r\n    /**\r\n     * Contract functions\r\n     */\r\n\r\n    /**\r\n     * @dev Contract constructor function sets owner and start date.\r\n     * @param workshopAddr The address that will hold undelivered Star tokens\r\n     * @param starbaseEpAddr The address that holds the early purchasers Star tokens\r\n     */\r\n    function StarbaseCrowdsale(address workshopAddr, address starbaseEpAddr) {\r\n        require(workshopAddr != 0 && starbaseEpAddr != 0);\r\n\r\n        owner = msg.sender;\r\n        workshop = workshopAddr;\r\n        starbaseEpAmendment = StarbaseEarlyPurchaseAmendment(starbaseEpAddr);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback accepts payment for Star tokens with Eth\r\n     */\r\n    function() payable {\r\n        redirectToPurchase();\r\n    }\r\n\r\n    /**\r\n     * External functions\r\n     */\r\n\r\n    /**\r\n     * @dev Setup function sets external contracts' addresses.\r\n     * @param starbaseTokenAddress Token address.\r\n     * @param _purchaseStartBlock Block number to start crowdsale\r\n     */\r\n    function setup(address starbaseTokenAddress, uint256 _purchaseStartBlock)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        assert(address(starbaseToken) == 0);\r\n        starbaseToken = AbstractStarbaseToken(starbaseTokenAddress);\r\n        purchaseStartBlock = _purchaseStartBlock;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows owner to record a purchase made outside of Ethereum blockchain\r\n     * @param purchaser Address of a purchaser\r\n     * @param rawAmount Purchased amount in CNY\r\n     * @param purchasedAt Timestamp at the purchase made\r\n     * @param data Identifier as an evidence of the purchase (e.g. btc:1xyzxyz)\r\n     */\r\n    function recordOffchainPurchase(\r\n        address purchaser,\r\n        uint256 rawAmount,\r\n        uint256 purchasedAt,\r\n        string data\r\n    )\r\n        external\r\n        onlyFundraiser\r\n        whenNotEnded\r\n        rateIsSet(cnyBtcRate)\r\n        returns (bool)\r\n    {\r\n        require(purchaseStartBlock > 0 && block.number >= purchaseStartBlock);\r\n        if (startDate == 0) {\r\n            startCrowdsale(block.timestamp);\r\n        }\r\n\r\n        uint256 bonusTier = getBonusTier();\r\n        uint amount = recordPurchase(purchaser, rawAmount, purchasedAt, data, bonusTier);\r\n\r\n        StarBasePurchasedOffChain(purchaser, amount, rawAmount, cnyBtcRate, bonusTier, data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers raised funds to company's wallet address at any given time.\r\n     */\r\n    function withdrawForCompany()\r\n        external\r\n        onlyFundraiser\r\n        hasBalance\r\n    {\r\n        address company = starbaseToken.company();\r\n        require(company != address(0));\r\n        company.transfer(this.balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the CNY/ETH rate to record purchases in CNY\r\n     */\r\n    function updateCnyEthRate(uint256 rate)\r\n        external\r\n        onlyFundraiser\r\n        returns (bool)\r\n    {\r\n        cnyEthRate = rate;\r\n        CnyEthRateUpdated(cnyEthRate);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the CNY/BTC rate to record purchases in CNY\r\n     */\r\n    function updateCnyBtcRate(uint256 rate)\r\n        external\r\n        onlyFundraiser\r\n        returns (bool)\r\n    {\r\n        cnyBtcRate = rate;\r\n        CnyBtcRateUpdated(cnyBtcRate);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow for the possibilyt for contract owner to start crowdsale\r\n     */\r\n    function ownerStartsCrowdsale(uint256 timestamp)\r\n        external\r\n        onlyOwner\r\n    {\r\n        assert(startDate == 0 && block.number >= purchaseStartBlock);   // overwriting startDate is not permitted and it should be after the crowdsale start block\r\n        startCrowdsale(timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Ends crowdsale\r\n     * @param timestamp Timestamp at the crowdsale ended\r\n     */\r\n    function endCrowdsale(uint256 timestamp)\r\n        external\r\n        onlyOwner\r\n    {\r\n        assert(timestamp > 0 && timestamp <= now);\r\n        assert(endedAt == 0);   // overwriting time is not permitted\r\n        endedAt = timestamp;\r\n        CrowdsaleEnded(endedAt);\r\n    }\r\n\r\n    /**\r\n     * @dev Invalidate a crowdsale purchase if something is wrong with it\r\n     * @param purchaseIdx Index number of the crowdsalePurchases to invalidate\r\n     */\r\n    function invalidatePurchase(uint256 purchaseIdx)\r\n        external\r\n        onlyOwner\r\n        whenEnded\r\n        tokensNotDelivered\r\n        returns (bool)\r\n    {\r\n        CrowdsalePurchase memory purchase = crowdsalePurchases[purchaseIdx];\r\n        assert(purchase.purchaser != 0 && purchase.amount != 0);\r\n\r\n        crowdsalePurchases[purchaseIdx].amount = 0;\r\n        crowdsalePurchases[purchaseIdx].rawAmount = 0;\r\n        invalidatedOrigPurchases[purchaseIdx] = purchase;\r\n        PurchaseInvalidated(purchaseIdx);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Amend a crowdsale purchase if something is wrong with it\r\n     * @param purchaseIdx Index number of the crowdsalePurchases to invalidate\r\n     * @param purchaser Address of the buyer\r\n     * @param amount Purchased tokens as per the CNY rate used\r\n     * @param rawAmount Purchased tokens as per the CNY rate used without the bonus\r\n     * @param purchasedAt Timestamp at the purchase made\r\n     * @param data Identifier as an evidence of the purchase (e.g. btc:1xyzxyz)\r\n     * @param bonus bonus milestones of the purchase\r\n     */\r\n    function amendPurchase(\r\n        uint256 purchaseIdx,\r\n        address purchaser,\r\n        uint256 amount,\r\n        uint256 rawAmount,\r\n        uint256 purchasedAt,\r\n        string data,\r\n        uint256 bonus\r\n    )\r\n        external\r\n        onlyOwner\r\n        whenEnded\r\n        tokensNotDelivered\r\n        returns (bool)\r\n    {\r\n        CrowdsalePurchase memory purchase = crowdsalePurchases[purchaseIdx];\r\n        assert(purchase.purchaser != 0 && purchase.amount != 0);\r\n\r\n        amendedOrigPurchases[purchaseIdx] = purchase;\r\n        crowdsalePurchases[purchaseIdx] =\r\n            CrowdsalePurchase(purchaser, amount, rawAmount, purchasedAt, data, bonus);\r\n        PurchaseAmended(purchaseIdx);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Deliver tokens to purchasers according to their purchase amount in CNY\r\n     */\r\n    function deliverPurchasedTokens()\r\n        external\r\n        onlyOwner\r\n        whenEnded\r\n        returns (bool)\r\n    {\r\n        assert(earlyPurchasesLoaded);\r\n        assert(address(starbaseToken) != 0);\r\n\r\n        uint256 totalAmountOfPurchasesInCny = totalRaisedAmountInCny(); // totalPreSale + totalCrowdsale\r\n\r\n        for (uint256 i = numOfDeliveredCrowdsalePurchases; i < crowdsalePurchases.length && msg.gas > 200000; i++) {\r\n            CrowdsalePurchase memory purchase = crowdsalePurchases[i];\r\n            if (purchase.amount == 0) {\r\n                continue;   // skip invalidated purchase\r\n            }\r\n\r\n            /*\r\n             * “Value” refers to the contribution of the User:\r\n             *  {crowdsale_purchaser_token_amount} =\r\n             *  {crowdsale_token_amount} * {crowdsalePurchase_value} / {earlypurchase_value} + {crowdsale_value}.\r\n             *\r\n             * Example: If a User contributes during the Contribution Period 100 CNY (including applicable\r\n             * Bonus, if any) and the total amount early purchases amounts to 6’000’000 CNY\r\n             * and total amount raised during the Contribution Period is 30’000’000, then he will get\r\n             * 347.22 STAR = 125’000’000 STAR * 100 CNY / 30’000’000 CNY + 6’000’000 CNY.\r\n            */\r\n\r\n            uint256 crowdsalePurchaseValue = purchase.amount;\r\n            uint256 tokenCount = SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) / totalAmountOfPurchasesInCny;\r\n\r\n            numOfPurchasedTokensOnCsBy[purchase.purchaser] = SafeMath.add(numOfPurchasedTokensOnCsBy[purchase.purchaser], tokenCount);\r\n            starbaseToken.allocateToCrowdsalePurchaser(purchase.purchaser, tokenCount);\r\n            numOfDeliveredCrowdsalePurchases = SafeMath.add(i, 1);\r\n        }\r\n\r\n        for (uint256 j = numOfDeliveredEarlyPurchases; j < earlyPurchasers.length && msg.gas > 200000; j++) {\r\n            address earlyPurchaser = earlyPurchasers[j];\r\n\r\n            /*\r\n             * “Value” refers to the contribution of the User:\r\n             * {earlypurchaser_token_amount} =\r\n             * {earlypurchaser_token_amount} * ({earlypurchase_value} / {total_earlypurchase_value})\r\n             *  + {crowdsale_token_amount} * ({earlypurchase_value} / {earlypurchase_value} + {crowdsale_value}).\r\n             *\r\n             * Example: If an Early Purchaser contributes 100 CNY (including Bonus of 20%) and the\r\n             * total amount of early purchases amounts to 6’000’000 CNY and the total amount raised\r\n             * during the Contribution Period is 30’000’000 CNY, then he will get 1180.55 STAR =\r\n             * 50’000’000 STAR * 100 CNY / 6’000’000 CNY + 125’000’000 STAR * 100 CNY /\r\n             * 30’000’000 CNY + 6’000’000 CNY\r\n             */\r\n\r\n            uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[earlyPurchaser];\r\n\r\n            uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchases();\r\n\r\n            uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfPurchasesInCny;\r\n\r\n            uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount);\r\n\r\n            numOfPurchasedTokensOnEpBy[earlyPurchaser] = SafeMath.add(numOfPurchasedTokensOnEpBy[earlyPurchaser], epTokenCount);\r\n            starbaseToken.allocateToCrowdsalePurchaser(earlyPurchaser, epTokenCount);\r\n            numOfDeliveredEarlyPurchases = SafeMath.add(j, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Load early purchases from the contract keeps track of them\r\n     */\r\n    function loadEarlyPurchases() external onlyOwner returns (bool) {\r\n        if (earlyPurchasesLoaded) {\r\n            return false;    // all EPs have already been loaded\r\n        }\r\n\r\n        uint256 numOfOrigEp = starbaseEpAmendment\r\n            .starbaseEarlyPurchase()\r\n            .numberOfEarlyPurchases();\r\n\r\n        for (uint256 i = numOfLoadedEarlyPurchases; i < numOfOrigEp && msg.gas > 200000; i++) {\r\n            if (starbaseEpAmendment.isInvalidEarlyPurchase(i)) {\r\n                continue;\r\n            }\r\n            var (purchaser, amount,) =\r\n                starbaseEpAmendment.isAmendedEarlyPurchase(i)\r\n                ? starbaseEpAmendment.amendedEarlyPurchases(i)\r\n                : starbaseEpAmendment.earlyPurchases(i);\r\n            if (amount > 0) {\r\n                if (earlyPurchasedAmountBy[purchaser] == 0) {\r\n                    earlyPurchasers.push(purchaser);\r\n                }\r\n                // each early purchaser receives 20% bonus\r\n                uint256 bonus = SafeMath.mul(amount, 20) / 100;\r\n                uint256 amountWithBonus = SafeMath.add(amount, bonus);\r\n\r\n                earlyPurchasedAmountBy[purchaser] += amountWithBonus;\r\n            }\r\n        }\r\n\r\n        numOfLoadedEarlyPurchases += i;\r\n        assert(numOfLoadedEarlyPurchases <= numOfOrigEp);\r\n        if (numOfLoadedEarlyPurchases == numOfOrigEp) {\r\n            earlyPurchasesLoaded = true;    // enable the flag\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev Set qualified crowdsale partner i.e. Bitcoin Suisse address\r\n      * @param _qualifiedPartner Address of the qualified partner that can purchase during crowdsale\r\n      * @param _amountCap Ether value which partner is able to contribute\r\n      * @param _commissionFeePercentage Integer that represents the fee to pay qualified partner 5 is 5%\r\n      */\r\n    function setQualifiedPartner(address _qualifiedPartner, uint256 _amountCap, uint256 _commissionFeePercentage)\r\n        external\r\n        onlyOwner\r\n    {\r\n        assert(!qualifiedPartners[_qualifiedPartner].bonaFide);\r\n        qualifiedPartners[_qualifiedPartner].bonaFide = true;\r\n        qualifiedPartners[_qualifiedPartner].amountCap = _amountCap;\r\n        qualifiedPartners[_qualifiedPartner].commissionFeePercentage = _commissionFeePercentage;\r\n        QualifiedPartnerAddress(_qualifiedPartner);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove address from qualified partners list.\r\n     * @param _qualifiedPartner Address to be removed from the list.\r\n     */\r\n    function unlistQualifiedPartner(address _qualifiedPartner) external onlyOwner {\r\n        assert(qualifiedPartners[_qualifiedPartner].bonaFide);\r\n        qualifiedPartners[_qualifiedPartner].bonaFide = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Update whitelisted address amount allowed to raise during the presale.\r\n     * @param _qualifiedPartner Qualified Partner address to be updated.\r\n     * @param _amountCap Amount that the address is able to raise during the presale.\r\n     */\r\n    function updateQualifiedPartnerCapAmount(address _qualifiedPartner, uint256 _amountCap) external onlyOwner {\r\n        assert(qualifiedPartners[_qualifiedPartner].bonaFide);\r\n        qualifiedPartners[_qualifiedPartner].amountCap = _amountCap;\r\n    }\r\n\r\n    /**\r\n     * Public functions\r\n     */\r\n\r\n    /**\r\n     * @dev Returns boolean for whether crowdsale has ended\r\n     */\r\n    function isEnded() constant public returns (bool) {\r\n        return (endedAt > 0 && endedAt <= now);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of purchases to date.\r\n     */\r\n    function numOfPurchases() constant public returns (uint256) {\r\n        return crowdsalePurchases.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates total amount of tokens purchased includes bonus tokens.\r\n     */\r\n    function totalAmountOfCrowdsalePurchases() constant public returns (uint256 amount) {\r\n        for (uint256 i; i < crowdsalePurchases.length; i++) {\r\n            amount = SafeMath.add(amount, crowdsalePurchases[i].amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates total amount of tokens purchased without bonus conversion.\r\n     */\r\n    function totalAmountOfCrowdsalePurchasesWithoutBonus() constant public returns (uint256 amount) {\r\n        for (uint256 i; i < crowdsalePurchases.length; i++) {\r\n            amount = SafeMath.add(amount, crowdsalePurchases[i].rawAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total raised amount in CNY (includes EP) and bonuses\r\n     */\r\n    function totalRaisedAmountInCny() constant public returns (uint256) {\r\n        return SafeMath.add(totalAmountOfEarlyPurchases(), totalAmountOfCrowdsalePurchases());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total amount of early purchases in CNY\r\n     */\r\n    function totalAmountOfEarlyPurchases() constant public returns(uint256) {\r\n       return starbaseEpAmendment.totalAmountOfEarlyPurchases();\r\n    }\r\n\r\n    /**\r\n     * @dev Allows qualified crowdsale partner to purchase Star Tokens\r\n     */\r\n    function purchaseAsQualifiedPartner()\r\n        payable\r\n        public\r\n        rateIsSet(cnyEthRate)\r\n        returns (bool)\r\n    {\r\n        require(qualifiedPartners[msg.sender].bonaFide);\r\n        qualifiedPartners[msg.sender].amountRaised = SafeMath.add(msg.value, qualifiedPartners[msg.sender].amountRaised);\r\n\r\n        assert(qualifiedPartners[msg.sender].amountRaised <= qualifiedPartners[msg.sender].amountCap);\r\n\r\n        uint256 bonusTier = 30; // Pre sale purchasers get 30 percent bonus\r\n        uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18;\r\n        uint amount = recordPurchase(msg.sender, rawAmount, now, '', bonusTier);\r\n\r\n        if (qualifiedPartners[msg.sender].commissionFeePercentage > 0) {\r\n            sendQualifiedPartnerCommissionFee(msg.sender, msg.value);\r\n        }\r\n\r\n        StarBasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate, bonusTier);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows user to purchase STAR tokens with Ether\r\n     */\r\n    function purchaseWithEth()\r\n        payable\r\n        public\r\n        minInvestment\r\n        whenNotEnded\r\n        rateIsSet(cnyEthRate)\r\n        returns (bool)\r\n    {\r\n        require(purchaseStartBlock > 0 && block.number >= purchaseStartBlock);\r\n        if (startDate == 0) {\r\n            startCrowdsale(block.timestamp);\r\n        }\r\n\r\n        uint256 bonusTier = getBonusTier();\r\n\r\n        uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18;\r\n        uint amount = recordPurchase(msg.sender, rawAmount, now, '', bonusTier);\r\n\r\n        StarBasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate, bonusTier);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Internal functions\r\n     */\r\n\r\n    /**\r\n     * @dev Initializes Starbase crowdsale\r\n     */\r\n    function startCrowdsale(uint256 timestamp) internal {\r\n        startDate = timestamp;\r\n\r\n        // set token bonus milestones\r\n        firstBonusSalesEnds = startDate + 7 days;             // 1. 1st ~ 7th day\r\n        secondBonusSalesEnds = firstBonusSalesEnds + 14 days; // 2. 8th ~ 21st day\r\n        thirdBonusSalesEnds = secondBonusSalesEnds + 14 days; // 3. 22nd ~ 35th day\r\n        fourthBonusSalesEnds = thirdBonusSalesEnds + 7 days;  // 4. 36th ~ 42nd day\r\n        fifthBonusSalesEnds = fourthBonusSalesEnds + 3 days;  // 5. 43rd ~ 45th day\r\n\r\n        // extended sales bonus milestones\r\n        firstExtendedBonusSalesEnds = fifthBonusSalesEnds + 3 days;         // 1. 46th ~ 48th day\r\n        secondExtendedBonusSalesEnds = firstExtendedBonusSalesEnds + 3 days; // 2. 49th ~ 51st day\r\n        thirdExtendedBonusSalesEnds = secondExtendedBonusSalesEnds + 3 days; // 3. 52nd ~ 54th day\r\n        fourthExtendedBonusSalesEnds = thirdExtendedBonusSalesEnds + 3 days; // 4. 55th ~ 57th day\r\n        fifthExtendedBonusSalesEnds = fourthExtendedBonusSalesEnds + 3 days;  // 5. 58th ~ 60th day\r\n        sixthExtendedBonusSalesEnds = fifthExtendedBonusSalesEnds + 60 days; // 6. 61st ~ 120th day\r\n    }\r\n\r\n    /**\r\n     * @dev Abstract record of a purchase to Tokens\r\n     * @param purchaser Address of the buyer\r\n     * @param rawAmount Amount in CNY as per the CNY/ETH rate used\r\n     * @param timestamp Timestamp at the purchase made\r\n     * @param data Identifier as an evidence of the purchase (e.g. btc:1xyzxyz)\r\n     * @param bonusTier bonus milestones of the purchase\r\n     */\r\n    function recordPurchase(\r\n        address purchaser,\r\n        uint256 rawAmount,\r\n        uint256 timestamp,\r\n        string data,\r\n        uint256 bonusTier\r\n    )\r\n        internal\r\n        returns(uint256 amount)\r\n    {\r\n        amount = rawAmount; // amount to check reach of max cap. it does not care for bonus tokens here\r\n\r\n        // presale transfers which occurs before the crowdsale ignores the crowdsale hard cap\r\n        if (block.number >= purchaseStartBlock) {\r\n\r\n            assert(totalAmountOfCrowdsalePurchasesWithoutBonus() <= MAX_CROWDSALE_CAP);\r\n\r\n            uint256 crowdsaleTotalAmountAfterPurchase = SafeMath.add(totalAmountOfCrowdsalePurchasesWithoutBonus(), amount);\r\n\r\n            // check whether purchase goes over the cap and send the difference back to the purchaser.\r\n            if (crowdsaleTotalAmountAfterPurchase > MAX_CROWDSALE_CAP) {\r\n              uint256 difference = SafeMath.sub(crowdsaleTotalAmountAfterPurchase, MAX_CROWDSALE_CAP);\r\n              uint256 ethValueToReturn = SafeMath.mul(difference, 1e18) / cnyEthRate;\r\n              purchaser.transfer(ethValueToReturn);\r\n              amount = SafeMath.sub(amount, difference);\r\n              rawAmount = amount;\r\n            }\r\n\r\n        }\r\n\r\n        uint256 covertedAmountwWithBonus = SafeMath.mul(amount, bonusTier) / 100;\r\n        amount = SafeMath.add(amount, covertedAmountwWithBonus); // at this point amount bonus is calculated\r\n\r\n        CrowdsalePurchase memory purchase = CrowdsalePurchase(purchaser, amount, rawAmount, timestamp, data, bonusTier);\r\n        crowdsalePurchases.push(purchase);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Fetchs Bonus tier percentage per bonus milestones\r\n     */\r\n    function getBonusTier() internal returns (uint256) {\r\n        bool firstBonusSalesPeriod = now >= startDate && now <= firstBonusSalesEnds; // 1st ~ 7th day get 20% bonus\r\n        bool secondBonusSalesPeriod = now > firstBonusSalesEnds && now <= secondBonusSalesEnds; // 8th ~ 21st day get 15% bonus\r\n        bool thirdBonusSalesPeriod = now > secondBonusSalesEnds && now <= thirdBonusSalesEnds; // 22nd ~ 35th day get 10% bonus\r\n        bool fourthBonusSalesPeriod = now > thirdBonusSalesEnds && now <= fourthBonusSalesEnds; // 36th ~ 42nd day get 5% bonus\r\n        bool fifthBonusSalesPeriod = now > fourthBonusSalesEnds && now <= fifthBonusSalesEnds; // 43rd and 45th day get 0% bonus\r\n\r\n        // extended bonus sales\r\n        bool firstExtendedBonusSalesPeriod = now > fifthBonusSalesEnds && now <= firstExtendedBonusSalesEnds; // extended sales 46th ~ 48th day get 20% bonus\r\n        bool secondExtendedBonusSalesPeriod = now > firstExtendedBonusSalesEnds && now <= secondExtendedBonusSalesEnds; // 49th ~ 51st 15% bonus\r\n        bool thirdExtendedBonusSalesPeriod = now > secondExtendedBonusSalesEnds && now <= thirdExtendedBonusSalesEnds; // 52nd ~ 54th day get 10% bonus\r\n        bool fourthExtendedBonusSalesPeriod = now > thirdExtendedBonusSalesEnds && now <= fourthExtendedBonusSalesEnds; // 55th ~ 57th day day get 5% bonus\r\n        bool fifthExtendedBonusSalesPeriod = now > fourthExtendedBonusSalesEnds && now <= fifthExtendedBonusSalesEnds; // 58th ~ 60th day get 0% bonus\r\n        bool sixthExtendedBonusSalesPeriod = now > fifthExtendedBonusSalesEnds && now <= sixthExtendedBonusSalesEnds; // 61st ~ 120th day get {number_of_days} - 60 * 1% bonus\r\n\r\n        if (firstBonusSalesPeriod || firstExtendedBonusSalesPeriod) return 20;\r\n        if (secondBonusSalesPeriod || secondExtendedBonusSalesPeriod) return 15;\r\n        if (thirdBonusSalesPeriod || thirdExtendedBonusSalesPeriod) return 10;\r\n        if (fourthBonusSalesPeriod || fourthExtendedBonusSalesPeriod) return 5;\r\n        if (fifthBonusSalesPeriod || fifthExtendedBonusSalesPeriod) return 0;\r\n\r\n        if (sixthExtendedBonusSalesPeriod) {\r\n          uint256 DAY_IN_SECONDS = 86400;\r\n          uint256 secondsSinceStartDate = SafeMath.sub(now, startDate);\r\n          uint256 numberOfDays = secondsSinceStartDate / DAY_IN_SECONDS;\r\n\r\n          return SafeMath.sub(numberOfDays, 60);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Fetchs Bonus tier percentage per bonus milestones\r\n     * @dev qualifiedPartner Address of partners that participated in pre sale\r\n     * @dev amountSent Value sent by qualified partner\r\n     */\r\n    function sendQualifiedPartnerCommissionFee(address qualifiedPartner, uint256 amountSent) internal {\r\n        //calculate the commission fee to send to qualified partner\r\n        uint256 commissionFeePercentageCalculationAmount = SafeMath.mul(amountSent, qualifiedPartners[qualifiedPartner].commissionFeePercentage) / 100;\r\n\r\n        // send commission fee amount\r\n        qualifiedPartner.transfer(commissionFeePercentageCalculationAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev redirectToPurchase Redirect to adequate purchase function within the smart contract\r\n     */\r\n    function redirectToPurchase() internal {\r\n        if (block.number < purchaseStartBlock) {\r\n            purchaseAsQualifiedPartner();\r\n        } else {\r\n            purchaseWithEth();\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyPurchasedAmountBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_qualifiedPartner\",\"type\":\"address\"},{\"name\":\"_amountCap\",\"type\":\"uint256\"},{\"name\":\"_commissionFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setQualifiedPartner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyPurchasesLoaded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"purchaser\",\"type\":\"address\"},{\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"name\":\"purchasedAt\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"recordOffchainPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseAsQualifiedPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"updateCnyBtcRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fifthBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfLoadedEarlyPurchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaisedAmountInCny\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"numOfPurchasedTokensOnEpBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstExtendedBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_qualifiedPartner\",\"type\":\"address\"}],\"name\":\"unlistQualifiedPartner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fifthExtendedBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_qualifiedPartner\",\"type\":\"address\"},{\"name\":\"_amountCap\",\"type\":\"uint256\"}],\"name\":\"updateQualifiedPartnerCapAmount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyPurchaseTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawForCompany\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CROWDSALE_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"starbaseEpAmendment\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"workshop\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdExtendedBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"numOfPurchasedTokensOnCsBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sixthExtendedBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfPurchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fourthBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseWithEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"invalidatedOrigPurchases\",\"outputs\":[{\"name\":\"purchaser\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"name\":\"purchasedAt\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"},{\"name\":\"bonus\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cnyBtcRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"crowdsalePurchases\",\"outputs\":[{\"name\":\"purchaser\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"name\":\"purchasedAt\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"},{\"name\":\"bonus\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amendedOrigPurchases\",\"outputs\":[{\"name\":\"purchaser\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"name\":\"purchasedAt\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"},{\"name\":\"bonus\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfDeliveredCrowdsalePurchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"purchaseIdx\",\"type\":\"uint256\"},{\"name\":\"purchaser\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"name\":\"purchasedAt\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"},{\"name\":\"bonus\",\"type\":\"uint256\"}],\"name\":\"amendPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfDeliveredEarlyPurchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cnyEthRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"earlyPurchasers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"updateCnyEthRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deliverPurchasedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmountOfCrowdsalePurchases\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fourthExtendedBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"starbaseToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"purchaseStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"qualifiedPartners\",\"outputs\":[{\"name\":\"amountCap\",\"type\":\"uint256\"},{\"name\":\"amountRaised\",\"type\":\"uint256\"},{\"name\":\"bonaFide\",\"type\":\"bool\"},{\"name\":\"commissionFeePercentage\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmountOfEarlyPurchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmountOfCrowdsalePurchasesWithoutBonus\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"loadEarlyPurchases\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondExtendedBonusSalesEnds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"starbaseTokenAddress\",\"type\":\"address\"},{\"name\":\"_purchaseStartBlock\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ownerStartsCrowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"purchaseIdx\",\"type\":\"uint256\"}],\"name\":\"invalidatePurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PURCHASE_AMOUNT_UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"workshopAddr\",\"type\":\"address\"},{\"name\":\"starbaseEpAddr\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endedAt\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cnyEthRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusTokensPercentage\",\"type\":\"uint256\"}],\"name\":\"StarBasePurchasedWithEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cnyBtcRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusTokensPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"string\"}],\"name\":\"StarBasePurchasedOffChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cnyEthRate\",\"type\":\"uint256\"}],\"name\":\"CnyEthRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cnyBtcRate\",\"type\":\"uint256\"}],\"name\":\"CnyBtcRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"qualifiedPartner\",\"type\":\"address\"}],\"name\":\"QualifiedPartnerAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"purchaseIdx\",\"type\":\"uint256\"}],\"name\":\"PurchaseInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"purchaseIdx\",\"type\":\"uint256\"}],\"name\":\"PurchaseAmended\",\"type\":\"event\"}]","ContractName":"StarbaseCrowdsale","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000006f6252d7e576828c497c10eac44c892d3824b8d000000000000000000000000859e7e76caede3b642fc84862809f60c055cb731","Library":"","SwarmSource":"bzzr://79c85e984afae3c8cb84be27e5681fdd4b2e15f1aec3a0662bea7dca8294028a"}]}