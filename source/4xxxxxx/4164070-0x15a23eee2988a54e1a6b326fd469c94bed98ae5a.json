{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.4;\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ncontract MichCoin is ERC20 {\r\n\r\n    string public constant name = \"Mich Coin\";\r\n    string public constant symbol = \"MCH\";\r\n    uint public constant decimals = 8;\r\n\r\n    uint public tokenToEtherRate;\r\n\r\n    uint public startTime;\r\n    uint public endTime;\r\n    uint public bonusEndTime;\r\n\r\n    uint public minTokens;\r\n    uint public maxTokens;\r\n    bool public frozen;\r\n\r\n    address owner;\r\n    address reserve;\r\n    address main;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => uint256) incomes;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    uint public tokenSold;\r\n\r\n    function MichCoin(uint _tokenCount, uint _minTokenCount, uint _tokenToEtherRate,\r\n                      uint _beginDurationInSec, uint _durationInSec, uint _bonusDurationInSec,\r\n                      address _mainAddress, address _reserveAddress) {\r\n        require(_minTokenCount <= _tokenCount);\r\n        require(_bonusDurationInSec <= _durationInSec);\r\n        require(_mainAddress != _reserveAddress);\r\n\r\n        tokenToEtherRate = _tokenToEtherRate;\r\n        totalSupply = _tokenCount*(10**decimals);\r\n        minTokens = _minTokenCount*(10**decimals);\r\n        maxTokens = totalSupply*85/100;\r\n\r\n        owner = msg.sender;\r\n        balances[this] = totalSupply;\r\n\r\n        startTime = now + _beginDurationInSec;\r\n        bonusEndTime = startTime + _bonusDurationInSec;\r\n        endTime = startTime + _durationInSec;\r\n\r\n        reserve = _reserveAddress;\r\n        main = _mainAddress;\r\n        frozen = false;\r\n        tokenSold = 0;\r\n    }\r\n\r\n    //modifiers\r\n\r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier canFreeze {\r\n        require(frozen == false);\r\n        _;\r\n    }\r\n\r\n    modifier waitForICO {\r\n        require(now >= startTime);\r\n        _;\r\n    }\r\n\r\n    modifier afterICO {\r\n        //if ico period over or all token sold\r\n        require(now > endTime || balances[this] <= totalSupply - maxTokens);\r\n        _;\r\n    }\r\n\r\n    //owner functions\r\n\r\n    function freeze() ownerOnly {\r\n        frozen = true;\r\n    }\r\n\r\n    function unfreeze() ownerOnly {\r\n        frozen = false;\r\n    }\r\n\r\n    //erc20\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint _value) canFreeze returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value > balances[_to]);\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) canFreeze returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        require(allowed[_from][_to] >= _value);\r\n        require(balances[_to] + _value > balances[_to]);\r\n\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        allowed[_from][_to] -= _value;\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint _value) canFreeze returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    //ether operations\r\n\r\n    function () payable canFreeze waitForICO {\r\n        uint tokenAmount = weiToToken(msg.value);\r\n        uint bonusAmount = 0;\r\n        //add bonus token if bought on bonus period\r\n        if (now < bonusEndTime) {\r\n            bonusAmount = tokenAmount / 10;\r\n            tokenAmount += bonusAmount;\r\n        }\r\n\r\n        require(now < endTime);\r\n        require(balances[this] >= tokenAmount);\r\n        require(balances[this] - tokenAmount >= totalSupply - maxTokens);\r\n        require(balances[msg.sender] + tokenAmount > balances[msg.sender]);\r\n\r\n        balances[this] -= tokenAmount;\r\n        balances[msg.sender] += tokenAmount;\r\n        incomes[msg.sender] += msg.value;\r\n        tokenSold += tokenAmount;\r\n    }\r\n\r\n    function refund(address _sender) canFreeze afterICO {\r\n        require(balances[this] >= totalSupply - minTokens);\r\n        require(incomes[_sender] > 0);\r\n\r\n        balances[_sender] = 0;\r\n        _sender.transfer(incomes[_sender]);\r\n        incomes[_sender] = 0;\r\n    }\r\n\r\n    function withdraw() canFreeze afterICO {\r\n        require(balances[this] < totalSupply - minTokens);\r\n        require(this.balance > 0);\r\n\r\n        balances[reserve] = (totalSupply - balances[this]) * 15 / 85;\r\n        balances[this] = 0;\r\n        main.transfer(this.balance);\r\n    }\r\n\r\n    //utility\r\n\r\n    function tokenToWei(uint _tokens) constant returns (uint) {\r\n        return _tokens * (10**18) / tokenToEtherRate / (10**decimals);\r\n    }\r\n\r\n    function weiToToken(uint _weis) constant returns (uint) {\r\n        return tokenToEtherRate * _weis * (10**decimals) / (10**18);\r\n    }\r\n\r\n    function tokenAvailable() constant returns (uint) {\r\n        uint available = balances[this] - (totalSupply - maxTokens);\r\n        if (balances[this] < (totalSupply - maxTokens)) {\r\n            available = 0;\r\n        }\r\n        return available;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenToEtherRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weis\",\"type\":\"uint256\"}],\"name\":\"weiToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"tokenToWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenCount\",\"type\":\"uint256\"},{\"name\":\"_minTokenCount\",\"type\":\"uint256\"},{\"name\":\"_tokenToEtherRate\",\"type\":\"uint256\"},{\"name\":\"_beginDurationInSec\",\"type\":\"uint256\"},{\"name\":\"_durationInSec\",\"type\":\"uint256\"},{\"name\":\"_bonusDurationInSec\",\"type\":\"uint256\"},{\"name\":\"_mainAddress\",\"type\":\"address\"},{\"name\":\"_reserveAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MichCoin","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000030d400000000000000000000000000000000000000000000000000000000001b774000000000000000000000000000000000000000000000000000000000000013560000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000001c20000000000000000000000000475f9b22af5d8f7a1503d26841ba735cf26bf34f000000000000000000000000e1391eae3983a455fc3e54e71ba7db6f2997a5b0","Library":"","SwarmSource":"bzzr://0e727f448091484cb0d04aeeb912546a0c01fc54d09cd318bd818ffb78630501"}]}