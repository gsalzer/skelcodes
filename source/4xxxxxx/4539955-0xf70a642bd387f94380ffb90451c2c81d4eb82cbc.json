{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract AbstractStarbaseCrowdsale {\r\n    function startDate() constant returns (uint256) {}\r\n    function endedAt() constant returns (uint256) {}\r\n    function isEnded() constant returns (bool);\r\n    function totalRaisedAmountInCny() constant returns (uint256);\r\n    function numOfPurchasedTokensOnCsBy(address purchaser) constant returns (uint256);\r\n    function numOfPurchasedTokensOnEpBy(address purchaser) constant returns (uint256);\r\n}\r\n\r\ncontract AbstractStarbaseMarketingCampaign {}\r\n\r\n/// @title Token contract - ERC20 compatible Starbase token contract.\r\n/// @author Starbase PTE. LTD. - <info@starbase.co>\r\ncontract StarbaseToken is StandardToken {\r\n    /*\r\n     *  Events\r\n     */\r\n    event PublicOfferingPlanDeclared(uint256 tokenCount, uint256 unlockCompanysTokensAt);\r\n    event MvpLaunched(uint256 launchedAt);\r\n    event LogNewFundraiser (address indexed fundraiserAddress, bool isBonaFide);\r\n    event LogUpdateFundraiser(address indexed fundraiserAddress, bool isBonaFide);\r\n\r\n    /*\r\n     *  Types\r\n     */\r\n    struct PublicOfferingPlan {\r\n        uint256 tokenCount;\r\n        uint256 unlockCompanysTokensAt;\r\n        uint256 declaredAt;\r\n    }\r\n\r\n    /*\r\n     *  External contracts\r\n     */\r\n    AbstractStarbaseCrowdsale public starbaseCrowdsale;\r\n    AbstractStarbaseMarketingCampaign public starbaseMarketingCampaign;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public company;\r\n    PublicOfferingPlan[] public publicOfferingPlans;  // further crowdsales\r\n    mapping(address => uint256) public initialEcTokenAllocation;    // Initial token allocations for Early Contributors\r\n    uint256 public mvpLaunchedAt;  // 0 until a MVP of Starbase Platform launches\r\n    mapping(address => bool) private fundraisers; // Fundraisers are vetted addresses that are allowed to execute functions within the contract\r\n\r\n    /*\r\n     *  Constants / Token meta data\r\n     */\r\n    string constant public name = \"Starbase\";  // Token name\r\n    string constant public symbol = \"STAR\";  // Token symbol\r\n    uint8 constant public decimals = 18;\r\n    uint256 constant public initialSupply = 1000000000e18; // 1B STAR tokens\r\n    uint256 constant public initialCompanysTokenAllocation = 750000000e18;  // 750M\r\n    uint256 constant public initialBalanceForCrowdsale = 175000000e18;  // CS(125M)+EP(50M)\r\n    uint256 constant public initialBalanceForMarketingCampaign = 12500000e18;   // 12.5M\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyCrowdsaleContract() {\r\n        assert(msg.sender == address(starbaseCrowdsale));\r\n        _;\r\n    }\r\n\r\n    modifier onlyMarketingCampaignContract() {\r\n        assert(msg.sender == address(starbaseMarketingCampaign));\r\n        _;\r\n    }\r\n\r\n    modifier onlyFundraiser() {\r\n        // Only rightful fundraiser is permitted.\r\n        assert(isFundraiser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyBeforeCrowdsale() {\r\n        require(starbaseCrowdsale.startDate() == 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterCrowdsale() {\r\n        require(starbaseCrowdsale.isEnded());\r\n        _;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length == size + 4);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Contract functions\r\n     */\r\n\r\n    /**\r\n     * @dev Contract constructor function\r\n     * @param starbaseCompanyAddr The address that will holds untransferrable tokens\r\n     * @param starbaseCrowdsaleAddr Address of the crowdsale contract\r\n     * @param starbaseMarketingCampaignAddr The address of the marketing campaign contract\r\n     */\r\n\r\n    function StarbaseToken(\r\n        address starbaseCompanyAddr,\r\n        address starbaseCrowdsaleAddr,\r\n        address starbaseMarketingCampaignAddr\r\n    ) {\r\n        assert(\r\n            starbaseCompanyAddr != 0 &&\r\n            starbaseCrowdsaleAddr != 0 &&\r\n            starbaseMarketingCampaignAddr != 0);\r\n\r\n        starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddr);\r\n        starbaseMarketingCampaign = AbstractStarbaseMarketingCampaign(starbaseMarketingCampaignAddr);\r\n        company = starbaseCompanyAddr;\r\n\r\n        // msg.sender becomes first fundraiser\r\n        fundraisers[msg.sender] = true;\r\n        LogNewFundraiser(msg.sender, true);\r\n\r\n        // Tokens for crowdsale and early purchasers\r\n        balances[address(starbaseCrowdsale)] = initialBalanceForCrowdsale;\r\n        Transfer(0, address(starbaseCrowdsale), initialBalanceForCrowdsale);\r\n\r\n        // Tokens for marketing campaign supporters\r\n        balances[address(starbaseMarketingCampaign)] = initialBalanceForMarketingCampaign;\r\n        Transfer(0, address(starbaseMarketingCampaign), initialBalanceForMarketingCampaign);\r\n\r\n        // Tokens for early contributors, should be allocated by function\r\n        balances[0] = 62500000e18; // 62.5M\r\n\r\n        // Starbase company holds untransferrable tokens initially\r\n        balances[starbaseCompanyAddr] = initialCompanysTokenAllocation; // 750M\r\n        Transfer(0, starbaseCompanyAddr, initialCompanysTokenAllocation);\r\n\r\n        totalSupply = initialSupply;    // 1B\r\n    }\r\n\r\n    /**\r\n     * @dev Setup function sets external contracts' addresses\r\n     * @param starbaseCrowdsaleAddr Crowdsale contract address.\r\n     * @param starbaseMarketingCampaignAddr Marketing campaign contract address\r\n     */\r\n    function setup(address starbaseCrowdsaleAddr, address starbaseMarketingCampaignAddr)\r\n        external\r\n        onlyFundraiser\r\n        onlyBeforeCrowdsale\r\n        returns (bool)\r\n    {\r\n        require(starbaseCrowdsaleAddr != 0 && starbaseMarketingCampaignAddr != 0);\r\n        assert(balances[address(starbaseCrowdsale)] == initialBalanceForCrowdsale);\r\n        assert(balances[address(starbaseMarketingCampaign)] == initialBalanceForMarketingCampaign);\r\n\r\n        // Move the balances to the new ones\r\n        balances[address(starbaseCrowdsale)] = 0;\r\n        balances[address(starbaseMarketingCampaign)] = 0;\r\n        balances[starbaseCrowdsaleAddr] = initialBalanceForCrowdsale;\r\n        balances[starbaseMarketingCampaignAddr] = initialBalanceForMarketingCampaign;\r\n\r\n        // Update the references\r\n        starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddr);\r\n        starbaseMarketingCampaign = AbstractStarbaseMarketingCampaign(starbaseMarketingCampaignAddr);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     *  External functions\r\n     */\r\n\r\n    /**\r\n     * @dev Returns number of declared public offering plans\r\n     */\r\n    function numOfDeclaredPublicOfferingPlans()\r\n        external\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return publicOfferingPlans.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Declares a public offering plan to make company's tokens transferable\r\n     * @param tokenCount Number of tokens to transfer.\r\n     * @param unlockCompanysTokensAt Time of the tokens will be unlocked\r\n     */\r\n    function declarePublicOfferingPlan(uint256 tokenCount, uint256 unlockCompanysTokensAt)\r\n        external\r\n        onlyFundraiser\r\n        onlyAfterCrowdsale\r\n        returns (bool)\r\n    {\r\n        assert(tokenCount <= 100000000e18);    // shall not exceed 100M tokens\r\n        assert(SafeMath.sub(now, starbaseCrowdsale.endedAt()) >= 180 days);   // shall not be declared for 6 months after the crowdsale ended\r\n        assert(SafeMath.sub(unlockCompanysTokensAt, now) >= 60 days);   // tokens must be untransferable at least for 2 months\r\n\r\n        // check if last declaration was more than 6 months ago\r\n        if (publicOfferingPlans.length > 0) {\r\n            uint256 lastDeclaredAt =\r\n                publicOfferingPlans[publicOfferingPlans.length - 1].declaredAt;\r\n            assert(SafeMath.sub(now, lastDeclaredAt) >= 180 days);\r\n        }\r\n\r\n        uint256 totalDeclaredTokenCount = tokenCount;\r\n        for (uint8 i; i < publicOfferingPlans.length; i++) {\r\n            totalDeclaredTokenCount = SafeMath.add(totalDeclaredTokenCount, publicOfferingPlans[i].tokenCount);\r\n        }\r\n        assert(totalDeclaredTokenCount <= initialCompanysTokenAllocation);   // shall not exceed the initial token allocation\r\n\r\n        publicOfferingPlans.push(\r\n            PublicOfferingPlan(tokenCount, unlockCompanysTokensAt, now));\r\n\r\n        PublicOfferingPlanDeclared(tokenCount, unlockCompanysTokensAt);\r\n    }\r\n\r\n    /**\r\n     * @dev Allocate tokens to a marketing supporter from the marketing campaign share\r\n     * @param to Address to where tokens are allocated\r\n     * @param value Number of tokens to transfer\r\n     */\r\n    function allocateToMarketingSupporter(address to, uint256 value)\r\n        external\r\n        onlyMarketingCampaignContract\r\n        returns (bool)\r\n    {\r\n        require(to != address(0));\r\n        return allocateFrom(address(starbaseMarketingCampaign), to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Allocate tokens to an early contributor from the early contributor share\r\n     * @param to Address to where tokens are allocated\r\n     * @param value Number of tokens to transfer\r\n     */\r\n    function allocateToEarlyContributor(address to, uint256 value)\r\n        external\r\n        onlyFundraiser\r\n        returns (bool)\r\n    {\r\n        require(to != address(0));\r\n        initialEcTokenAllocation[to] =\r\n            SafeMath.add(initialEcTokenAllocation[to], value);\r\n        return allocateFrom(0, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Issue new tokens according to the STAR token inflation limits\r\n     * @param _for Address to where tokens are allocated\r\n     * @param value Number of tokens to issue\r\n     */\r\n    function issueTokens(address _for, uint256 value)\r\n        external\r\n        onlyFundraiser\r\n        onlyAfterCrowdsale\r\n        returns (bool)\r\n    {\r\n        require(_for != address(0));\r\n        // check if the value under the limits\r\n        assert(value <= numOfInflatableTokens());\r\n\r\n        totalSupply = SafeMath.add(totalSupply, value);\r\n        balances[_for] = SafeMath.add(balances[_for], value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Declares Starbase MVP has been launched\r\n     * @param launchedAt When the MVP launched (timestamp)\r\n     */\r\n    function declareMvpLaunched(uint256 launchedAt)\r\n        external\r\n        onlyFundraiser\r\n        onlyAfterCrowdsale\r\n        returns (bool)\r\n    {\r\n        require(mvpLaunchedAt == 0); // overwriting the launch date is not permitted\r\n        require(launchedAt <= now);\r\n        require(starbaseCrowdsale.isEnded());\r\n\r\n        mvpLaunchedAt = launchedAt;\r\n        MvpLaunched(launchedAt);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allocate tokens to a crowdsale or early purchaser from the crowdsale share\r\n     * @param to Address to where tokens are allocated\r\n     * @param value Number of tokens to transfer\r\n     */\r\n    function allocateToCrowdsalePurchaser(address to, uint256 value)\r\n        external\r\n        onlyCrowdsaleContract\r\n        onlyAfterCrowdsale\r\n        returns (bool)\r\n    {\r\n        require(to != address(0));\r\n        return allocateFrom(address(starbaseCrowdsale), to, value);\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n\r\n    /**\r\n     * @dev Transfers sender's tokens to a given address. Returns success.\r\n     * @param to Address of token receiver.\r\n     * @param value Number of tokens to transfer.\r\n     */\r\n    function transfer(address to, uint256 value) public onlyPayloadSize(2*32) returns (bool) {\r\n        assert(isTransferable(msg.sender, value));\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows third party to transfer tokens from one address to another. Returns success.\r\n     * @param from Address from where tokens are withdrawn.\r\n     * @param to Address to where tokens are sent.\r\n     * @param value Number of tokens to transfer.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public onlyPayloadSize(3*32) returns (bool) {\r\n        assert(isTransferable(from, value));\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds fundraiser. Only called by another fundraiser.\r\n     * @param fundraiserAddress The address in check\r\n     */\r\n    function addFundraiser(address fundraiserAddress) public onlyFundraiser {\r\n        require(fundraiserAddress != address(0));\r\n        assert(!isFundraiser(fundraiserAddress));\r\n\r\n        fundraisers[fundraiserAddress] = true;\r\n        LogNewFundraiser(fundraiserAddress, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Update fundraiser address rights.\r\n     * @param fundraiserAddress The address to update\r\n     * @param isBonaFide Boolean that denotes whether fundraiser is active or not.\r\n     */\r\n    function updateFundraiser(address fundraiserAddress, bool isBonaFide)\r\n       public\r\n       onlyFundraiser\r\n       returns(bool)\r\n    {\r\n        assert(isFundraiser(fundraiserAddress));\r\n\r\n        fundraisers[fundraiserAddress] = isBonaFide;\r\n        LogUpdateFundraiser(fundraiserAddress, isBonaFide);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether fundraiser address has rights.\r\n     * @param fundraiserAddress The address in check\r\n     */\r\n    function isFundraiser(address fundraiserAddress) constant public returns(bool) {\r\n        return fundraisers[fundraiserAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the transferring of tokens is available fundraiser.\r\n     * @param from Address of token sender\r\n     * @param tokenCount Number of tokens to transfer.\r\n     */\r\n    function isTransferable(address from, uint256 tokenCount)\r\n        constant\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (tokenCount == 0 || balances[from] < tokenCount) {\r\n            return false;\r\n        }\r\n\r\n        // company's tokens may be locked up\r\n        if (from == company) {\r\n            if (tokenCount > numOfTransferableCompanysTokens()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        uint256 untransferableTokenCount = 0;\r\n\r\n        // early contributor's tokens may be locked up\r\n        if (initialEcTokenAllocation[from] > 0) {\r\n            untransferableTokenCount = SafeMath.add(\r\n                untransferableTokenCount,\r\n                numOfUntransferableEcTokens(from));\r\n        }\r\n\r\n        // EP and CS purchasers' tokens should be untransferable initially\r\n        if (starbaseCrowdsale.isEnded()) {\r\n            uint256 passedDays =\r\n                SafeMath.sub(now, starbaseCrowdsale.endedAt()) / 86400; // 1d = 86400s\r\n            if (passedDays < 7) {  // within a week\r\n                // crowdsale purchasers cannot transfer their tokens for a week\r\n                untransferableTokenCount = SafeMath.add(\r\n                    untransferableTokenCount,\r\n                    starbaseCrowdsale.numOfPurchasedTokensOnCsBy(from));\r\n            }\r\n            if (passedDays < 14) {  // within two weeks\r\n                // early purchasers cannot transfer their tokens for two weeks\r\n                untransferableTokenCount = SafeMath.add(\r\n                    untransferableTokenCount,\r\n                    starbaseCrowdsale.numOfPurchasedTokensOnEpBy(from));\r\n            }\r\n        }\r\n\r\n        uint256 transferableTokenCount =\r\n            SafeMath.sub(balances[from], untransferableTokenCount);\r\n\r\n        if (transferableTokenCount < tokenCount) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of transferable company's tokens\r\n     */\r\n    function numOfTransferableCompanysTokens() constant public returns (uint256) {\r\n        uint256 unlockedTokens = 0;\r\n        for (uint8 i; i < publicOfferingPlans.length; i++) {\r\n            PublicOfferingPlan memory plan = publicOfferingPlans[i];\r\n            if (plan.unlockCompanysTokensAt <= now) {\r\n                unlockedTokens = SafeMath.add(unlockedTokens, plan.tokenCount);\r\n            }\r\n        }\r\n        return SafeMath.sub(\r\n            balances[company],\r\n            initialCompanysTokenAllocation - unlockedTokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of untransferable tokens of the early contributor\r\n     * @param _for Address of early contributor to check\r\n     */\r\n    function numOfUntransferableEcTokens(address _for) constant public returns (uint256) {\r\n        uint256 initialCount = initialEcTokenAllocation[_for];\r\n        if (mvpLaunchedAt == 0) {\r\n            return initialCount;\r\n        }\r\n\r\n        uint256 passedWeeks = SafeMath.sub(now, mvpLaunchedAt) / 7 days;\r\n        if (passedWeeks <= 52) {    // a year ≈ 52 weeks\r\n            // all tokens should be locked up for a year\r\n            return initialCount;\r\n        }\r\n\r\n        // unlock 1/52 tokens every weeks after a year\r\n        uint256 transferableTokenCount = initialCount / 52 * (passedWeeks - 52);\r\n        if (transferableTokenCount >= initialCount) {\r\n            return 0;\r\n        } else {\r\n            return SafeMath.sub(initialCount, transferableTokenCount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of tokens which can be issued according to the inflation rules\r\n     */\r\n    function numOfInflatableTokens() constant public returns (uint256) {\r\n        if (starbaseCrowdsale.endedAt() == 0) {\r\n            return 0;\r\n        }\r\n        uint256 passedDays = SafeMath.sub(now, starbaseCrowdsale.endedAt()) / 86400;  // 1d = 60s * 60m * 24h = 86400s\r\n        uint256 passedYears = passedDays * 100 / 36525;    // about 365.25 days in a year\r\n        uint256 inflatedSupply = initialSupply;\r\n        for (uint256 i; i < passedYears; i++) {\r\n            inflatedSupply = SafeMath.add(inflatedSupply, SafeMath.mul(inflatedSupply, 25) / 1000); // 2.5%/y = 0.025/y\r\n        }\r\n\r\n        uint256 remainderedDays = passedDays * 100 % 36525 / 100;\r\n        if (remainderedDays > 0) {\r\n            uint256 inflatableTokensOfNextYear =\r\n                SafeMath.mul(inflatedSupply, 25) / 1000;\r\n            inflatedSupply = SafeMath.add(inflatedSupply, SafeMath.mul(\r\n                inflatableTokensOfNextYear, remainderedDays * 100) / 36525);\r\n        }\r\n\r\n        return SafeMath.sub(inflatedSupply, totalSupply);\r\n    }\r\n\r\n    /*\r\n     *  Internal functions\r\n     */\r\n\r\n    /**\r\n     * @dev Allocate tokens value from an address to another one. This function is only called internally.\r\n     * @param from Address from where tokens come\r\n     * @param to Address to where tokens are allocated\r\n     * @param value Number of tokens to transfer\r\n     */\r\n    function allocateFrom(address from, address to, uint256 value) internal returns (bool) {\r\n        assert(value > 0 && balances[from] >= value);\r\n        balances[from] = SafeMath.sub(balances[from], value);\r\n        balances[to] = SafeMath.add(balances[to], value);\r\n        Transfer(from, to, value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"numOfInflatableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"allocateToCrowdsalePurchaser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfDeclaredPublicOfferingPlans\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"allocateToMarketingSupporter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"starbaseCrowdsaleAddr\",\"type\":\"address\"},{\"name\":\"starbaseMarketingCampaignAddr\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"starbaseMarketingCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"launchedAt\",\"type\":\"uint256\"}],\"name\":\"declareMvpLaunched\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"allocateToEarlyContributor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"initialEcTokenAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"issueTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfTransferableCompanysTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"company\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"publicOfferingPlans\",\"outputs\":[{\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"name\":\"unlockCompanysTokensAt\",\"type\":\"uint256\"},{\"name\":\"declaredAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fundraiserAddress\",\"type\":\"address\"}],\"name\":\"isFundraiser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokenCount\",\"type\":\"uint256\"}],\"name\":\"isTransferable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"starbaseCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBalanceForMarketingCampaign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBalanceForCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialCompanysTokenAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fundraiserAddress\",\"type\":\"address\"},{\"name\":\"isBonaFide\",\"type\":\"bool\"}],\"name\":\"updateFundraiser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"name\":\"unlockCompanysTokensAt\",\"type\":\"uint256\"}],\"name\":\"declarePublicOfferingPlan\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mvpLaunchedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"numOfUntransferableEcTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fundraiserAddress\",\"type\":\"address\"}],\"name\":\"addFundraiser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"starbaseCompanyAddr\",\"type\":\"address\"},{\"name\":\"starbaseCrowdsaleAddr\",\"type\":\"address\"},{\"name\":\"starbaseMarketingCampaignAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unlockCompanysTokensAt\",\"type\":\"uint256\"}],\"name\":\"PublicOfferingPlanDeclared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"launchedAt\",\"type\":\"uint256\"}],\"name\":\"MvpLaunched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fundraiserAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isBonaFide\",\"type\":\"bool\"}],\"name\":\"LogNewFundraiser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fundraiserAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isBonaFide\",\"type\":\"bool\"}],\"name\":\"LogUpdateFundraiser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"StarbaseToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006c9e70d6682ea36ff340153d574b2c523671b107000000000000000000000000c03ab1fc46c6d01238707426c929e9eed3e7f9b3000000000000000000000000ed9d813c4a82a9d76eba8ea666a7a0ab95f7bb29","Library":"","SwarmSource":"bzzr://80d59bed20a206aac3d8c04eef71a72c349854b90471633196e79ea1aca9f0e4"}]}