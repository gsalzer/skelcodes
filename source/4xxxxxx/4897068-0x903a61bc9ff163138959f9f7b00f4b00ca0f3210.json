{"status":"1","message":"OK","result":[{"SourceCode":"/* Simple token - simple token for PreICO and ICO\r\n   Copyright (C) 2017  Sergey Sherkunov <leinlawun@leinlawun.org>\r\n   Copyright (C) 2017  OOM.AG <info@oom.ag>\r\n\r\n   This file is part of simple token.\r\n\r\n   Token is free software: you can redistribute it and/or modify\r\n   it under the terms of the GNU General Public License as published by\r\n   the Free Software Foundation, either version 3 of the License, or\r\n   (at your option) any later version.\r\n\r\n   This program is distributed in the hope that it will be useful,\r\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n   GNU General Public License for more details.\r\n\r\n   You should have received a copy of the GNU General Public License\r\n   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */\r\n\r\npragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n\r\n        assert(c >= a);\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        assert(b <= a);\r\n\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a * b;\r\n\r\n        assert(c / a == b);\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a;\r\n\r\n        if(a > b)\r\n           c = b;\r\n    }\r\n}\r\n\r\ncontract ABXToken {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n\r\n    address public minter;\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public decimals;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed oldTokensHolder,\r\n                   address indexed newTokensHolder, uint256 tokensNumber);\r\n\r\n    //An Attack Vector on Approve/TransferFrom Methods:\r\n    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    event Transfer(address indexed tokensSpender,\r\n                   address indexed oldTokensHolder,\r\n                   address indexed newTokensHolder, uint256 tokensNumber);\r\n\r\n    event Approval(address indexed tokensHolder, address indexed tokensSpender,\r\n                   uint256 newTokensNumber);\r\n\r\n    //An Attack Vector on Approve/TransferFrom Methods:\r\n    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    event Approval(address indexed tokensHolder, address indexed tokensSpender,\r\n                   uint256 oldTokensNumber, uint256 newTokensNumber);\r\n\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n\r\n        _;\r\n    }\r\n\r\n    //ERC20 Short Address Attack:\r\n    //https://vessenes.com/the-erc20-short-address-attack-explained\r\n    //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95\r\n    //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack\r\n    modifier checkPayloadSize(uint256 size) {\r\n        require(msg.data.length == size + 4);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotNullTokenHolder(address tokenHolder) {\r\n        require(tokenHolder != address(0));\r\n\r\n        _;\r\n    }\r\n\r\n    function ABXToken(string _name, string _symbol, uint8 _decimals,\r\n                      uint256 _totalSupply) public {\r\n        owner = msg.sender;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply.mul(10 ** uint256(decimals));\r\n\r\n        require(decimals <= 77);\r\n\r\n        balanceOf[this] = totalSupply;\r\n    }\r\n\r\n    function setOwner(address _owner) public onlyOwner returns(bool) {\r\n        owner = _owner;\r\n\r\n        return true;\r\n    }\r\n\r\n    function setMinter(address _minter) public onlyOwner returns(bool) {\r\n        safeApprove(this, minter, 0);\r\n\r\n        minter = _minter;\r\n\r\n        safeApprove(this, minter, balanceOf[this]);\r\n\r\n        return true;\r\n    }\r\n\r\n    //ERC20 Short Address Attack:\r\n    //https://vessenes.com/the-erc20-short-address-attack-explained\r\n    //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95\r\n    //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack\r\n    function transfer(address newTokensHolder, uint256 tokensNumber) public\r\n                     checkPayloadSize(2 * 32) returns(bool) {\r\n        transfer(msg.sender, newTokensHolder, tokensNumber);\r\n\r\n        return true;\r\n    }\r\n\r\n    //An Attack Vector on Approve/TransferFrom Methods:\r\n    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    //\r\n    //ERC20 Short Address Attack:\r\n    //https://vessenes.com/the-erc20-short-address-attack-explained\r\n    //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95\r\n    //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack\r\n    function transferFrom(address oldTokensHolder, address newTokensHolder,\r\n                          uint256 tokensNumber) public checkPayloadSize(3 * 32)\r\n                         returns(bool) {\r\n        allowance[oldTokensHolder][msg.sender] =\r\n            allowance[oldTokensHolder][msg.sender].sub(tokensNumber);\r\n\r\n        transfer(oldTokensHolder, newTokensHolder, tokensNumber);\r\n\r\n        Transfer(msg.sender, oldTokensHolder, newTokensHolder, tokensNumber);\r\n\r\n        return true;\r\n    }\r\n\r\n    //ERC20 Short Address Attack:\r\n    //https://vessenes.com/the-erc20-short-address-attack-explained\r\n    //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95\r\n    //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack\r\n    function approve(address tokensSpender, uint256 newTokensNumber) public\r\n                    checkPayloadSize(2 * 32) returns(bool) {\r\n        safeApprove(msg.sender, tokensSpender, newTokensNumber);\r\n\r\n        return true;\r\n    }\r\n\r\n    //An Attack Vector on Approve/TransferFrom Methods:\r\n    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    //\r\n    //ERC20 Short Address Attack:\r\n    //https://vessenes.com/the-erc20-short-address-attack-explained\r\n    //https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95\r\n    //https://ericrafaloff.com/analyzing-the-erc20-short-address-attack\r\n    function approve(address tokensSpender, uint256 oldTokensNumber,\r\n                     uint256 newTokensNumber) public checkPayloadSize(3 * 32)\r\n                    returns(bool) {\r\n        require(allowance[msg.sender][tokensSpender] == oldTokensNumber);\r\n\r\n        unsafeApprove(msg.sender, tokensSpender, newTokensNumber);\r\n\r\n        Approval(msg.sender, tokensSpender, oldTokensNumber, newTokensNumber);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address oldTokensHolder, address newTokensHolder,\r\n                      uint256 tokensNumber) private\r\n                      onlyNotNullTokenHolder(oldTokensHolder) {\r\n        balanceOf[oldTokensHolder] =\r\n            balanceOf[oldTokensHolder].sub(tokensNumber);\r\n\r\n        balanceOf[newTokensHolder] =\r\n            balanceOf[newTokensHolder].add(tokensNumber);\r\n\r\n        Transfer(oldTokensHolder, newTokensHolder, tokensNumber);\r\n    }\r\n\r\n    //An Attack Vector on Approve/TransferFrom Methods:\r\n    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    function unsafeApprove(address tokensHolder, address tokensSpender,\r\n                           uint256 newTokensNumber) private\r\n                          onlyNotNullTokenHolder(tokensHolder) {\r\n        allowance[tokensHolder][tokensSpender] = newTokensNumber;\r\n\r\n        Approval(msg.sender, tokensSpender, newTokensNumber);\r\n    }\r\n    \r\n    //An Attack Vector on Approve/TransferFrom Methods:\r\n    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    function safeApprove(address tokensHolder, address tokensSpender,\r\n                         uint256 newTokensNumber) private {\r\n        require(allowance[tokensHolder][tokensSpender] == 0 ||\r\n                newTokensNumber == 0);\r\n\r\n        unsafeApprove(tokensHolder, tokensSpender, newTokensNumber);\r\n    }\r\n}\r\n\r\ncontract Minter {\r\n    using SafeMath for uint256;\r\n\r\n    enum MinterState {\r\n        tokenSaleWait,\r\n        tokenSaleStarted,\r\n        Over\r\n    }\r\n\r\n    struct Tokensale {\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 tokensMinimumNumberForBuy;\r\n        uint256 tokensCost;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    address public manager;\r\n\r\n    bool public paused = false;\r\n\r\n    mapping(address => bool) public whiteList;\r\n\r\n    ABXToken public token;\r\n\r\n    Tokensale public tokenSale;\r\n\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotPaused {\r\n        require(!paused);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyDuringTokensale {\r\n        require(minterState() == MinterState.tokenSaleStarted);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterTokensaleOver {\r\n        require(minterState() == MinterState.Over);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhiteList {\r\n        require(whiteList[msg.sender]);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier checkLimitsToBuyTokens {\r\n        require(tokenSale.tokensMinimumNumberForBuy <=\r\n                tokensNumberForBuy().div(10 ** uint256(token.decimals())));\r\n\r\n        _;\r\n    }\r\n\r\n    function Minter(address _manager, ABXToken _token,\r\n                    uint256 tokenSaleStartTime, uint256 tokenSaleEndTime,\r\n                    uint256 tokenSaleTokensMinimumNumberForBuy) public {\r\n        owner = msg.sender;\r\n        manager = _manager;\r\n        token = _token;\r\n        tokenSale.startTime = tokenSaleStartTime;\r\n        tokenSale.endTime = tokenSaleEndTime;\r\n        tokenSale.tokensMinimumNumberForBuy =\r\n            tokenSaleTokensMinimumNumberForBuy;\r\n    }\r\n\r\n    function setOwner(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    function setManager(address _manager) public onlyOwner {\r\n        manager = _manager;\r\n    }\r\n\r\n    function setPaused(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n    }\r\n\r\n    function addWhiteList(address tokensHolder) public onlyOwner {\r\n        whiteList[tokensHolder] = true;\r\n    }\r\n\r\n    function removeWhiteList(address tokensHolder) public onlyOwner {\r\n        whiteList[tokensHolder] = false;\r\n    }\r\n\r\n    function setTokenSaleStartTime(uint256 timestamp) public onlyOwner {\r\n        tokenSale.startTime = timestamp;\r\n    }\r\n\r\n    function setTokenSaleEndTime(uint256 timestamp) public onlyOwner {\r\n        tokenSale.endTime = timestamp;\r\n    }\r\n\r\n    function setTokenSaleTokensMinimumNumberForBuy(uint256 tokensNumber) public\r\n                                               onlyOwner {\r\n        tokenSale.tokensMinimumNumberForBuy = tokensNumber;\r\n    }\r\n\r\n    function setTokenSaleTokensCost(uint256 tokensCost) public onlyOwner {\r\n        tokenSale.tokensCost = tokensCost;\r\n    }\r\n\r\n    function transferRestTokensToOwner() public onlyOwner\r\n                                      onlyAfterTokensaleOver {\r\n        token.transferFrom(token, msg.sender, token.allowance(token, this));\r\n    }\r\n\r\n    function () public payable onlyDuringTokensale onlyNotPaused onlyWhiteList\r\n                checkLimitsToBuyTokens {\r\n        uint256 tokensNumber = tokensNumberForBuy();\r\n\r\n        uint256 aviableTokensNumber =\r\n            token.balanceOf(token).min(token.allowance(token, this));\r\n\r\n        uint256 restCoins = 0;\r\n\r\n        if(tokensNumber >= aviableTokensNumber) {\r\n            uint256 restTokensNumber = tokensNumber.sub(aviableTokensNumber);\r\n\r\n            restCoins =\r\n                restTokensNumber.mul(tokenSale.tokensCost)\r\n                                .div(10 ** uint256(token.decimals()));\r\n\r\n            tokensNumber = aviableTokensNumber;\r\n        }\r\n\r\n        token.transferFrom(token, msg.sender, tokensNumber);\r\n\r\n        msg.sender.transfer(restCoins);\r\n\r\n        manager.transfer(msg.value.sub(restCoins));\r\n    }\r\n\r\n    function minterState() private constant returns(MinterState) {\r\n        if(tokenSale.startTime > now) {\r\n            return MinterState.tokenSaleWait;\r\n        } else if(tokenSale.endTime > now) {\r\n            return MinterState.tokenSaleStarted;\r\n        } else {\r\n            return MinterState.Over;\r\n        }\r\n    }\r\n\r\n    function tokensNumberForBuy() private constant returns(uint256) {\r\n        return msg.value.mul(10 ** uint256(token.decimals()))\r\n                        .div(tokenSale.tokensCost);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setTokenSaleEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensHolder\",\"type\":\"address\"}],\"name\":\"removeWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferRestTokensToOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSale\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"tokensMinimumNumberForBuy\",\"type\":\"uint256\"},{\"name\":\"tokensCost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensHolder\",\"type\":\"address\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensNumber\",\"type\":\"uint256\"}],\"name\":\"setTokenSaleTokensMinimumNumberForBuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensCost\",\"type\":\"uint256\"}],\"name\":\"setTokenSaleTokensCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setTokenSaleStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"tokenSaleStartTime\",\"type\":\"uint256\"},{\"name\":\"tokenSaleEndTime\",\"type\":\"uint256\"},{\"name\":\"tokenSaleTokensMinimumNumberForBuy\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Minter","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000009a794dc1939f1d78fa48613b89b8f9d0a20da00e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://5ec35850d82274e2c517c4ba8ef90660503a988a64b5a47a28ed54218dd595f7"}]}