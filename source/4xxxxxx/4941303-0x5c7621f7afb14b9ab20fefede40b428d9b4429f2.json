{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Pausable is ERC20Basic {\r\n\r\n    uint public constant startPreICO = 1516525200;\r\n    uint public constant endPreICO = startPreICO + 30 days;\r\n    \r\n    uint public constant startICOStage1 = 1520931600;\r\n    uint public constant endICOStage1 = startICOStage1 + 15 days;\r\n    \r\n    uint public constant startICOStage2 = endICOStage1;\r\n    uint public constant endICOStage2 = startICOStage2 + 15 days;\r\n    \r\n    uint public constant startICOStage3 = endICOStage2;\r\n    uint public constant endICOStage3 = startICOStage3 + 15 days;\r\n    \r\n    uint public constant startICOStage4 = endICOStage3;\r\n    uint public constant endICOStage4 = startICOStage4 + 15 days;\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS not paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(now < startPreICO || now > endICOStage4);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n  \r\n}\r\n\r\ncontract Gelios is Ownable, StandardToken {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Gelios Token\";\r\n    string public constant symbol = \"GLS\";\r\n    uint256 public constant decimals = 18;\r\n\r\n    uint256 public constant INITIAL_SUPPLY = 16808824 ether;\r\n    address public tokenWallet;\r\n    address public multiSig;\r\n\r\n    uint256 public tokenRate = 1000; // tokens per 1 ether\r\n\r\n    function Gelios(address _tokenWallet, address _multiSig) {\r\n        tokenWallet = _tokenWallet;\r\n        multiSig = _multiSig;\r\n        totalSupply = INITIAL_SUPPLY;\r\n        balances[_tokenWallet] = INITIAL_SUPPLY;\r\n    }\r\n\r\n    function () payable public {\r\n        require(now >= startPreICO);\r\n        buyTokens(msg.value);\r\n    }\r\n\r\n    function buyTokensBonus(address bonusAddress) public payable {\r\n        require(now >= startPreICO && now < endICOStage4);\r\n        if (bonusAddress != 0x0 && msg.sender != bonusAddress) {\r\n            uint bonus = msg.value.mul(tokenRate).div(100).mul(5);\r\n            if(buyTokens(msg.value)) {\r\n               sendTokensRef(bonusAddress, bonus);\r\n            }\r\n        }\r\n    }\r\n\r\n    uint preIcoCap = 1300000 ether;\r\n    uint icoStage1Cap = 600000 ether;\r\n    uint icoStage2Cap = 862500 ether;\r\n    uint icoStage3Cap = 810000 ether;\r\n    uint icoStage4Cap = 5000000 ether;\r\n    \r\n    struct Stats {\r\n        uint preICO;\r\n        uint preICOETHRaised;\r\n        \r\n        uint ICOStage1;\r\n        uint ICOStage1ETHRaised;\r\n        \r\n        uint ICOStage2;\r\n        uint ICOStage2ETHRaised;\r\n        \r\n        uint ICOStage3;\r\n        uint ICOStage3ETHRaised;\r\n        \r\n        uint ICOStage4;\r\n        uint ICOStage4ETHRaised;\r\n        \r\n        uint RefBonusese;\r\n    }\r\n    \r\n    event Burn(address indexed burner, uint256 value);\r\n    \r\n    Stats public stats;\r\n    uint public burnAmount = preIcoCap;\r\n    bool[] public burnStage = [true, true, true, true];\r\n\r\n    function buyTokens(uint amount) private returns (bool){\r\n        // PreICO - 30% 1516525200 01/21/2018 @ 9:00am (UTC) 30 days 1300000\r\n        // Ico 1 - 20% 1520931600 03/13/2018 @ 9:00am (UTC) cap or 15 days 600000\r\n        // ico 2 - 15% cap or 15 days  862500\r\n        // ico 3 - 8% cap or 15 days 810000\r\n        // ico 4 - 0% cap or 15 days 5000000\r\n        \r\n        uint tokens = amount.mul(tokenRate);\r\n        if(now >= startPreICO && now < endPreICO && stats.preICO < preIcoCap) {\r\n            tokens = tokens.add(tokens.div(100).mul(30));\r\n            tokens = safeSend(tokens, preIcoCap.sub(stats.preICO));\r\n            stats.preICO = stats.preICO.add(tokens);\r\n            stats.preICOETHRaised = stats.preICOETHRaised.add(amount);\r\n            burnAmount = burnAmount.sub(tokens);\r\n            \r\n            return true;\r\n        } else if (now >= startICOStage1 && now < endICOStage1 && stats.ICOStage1 < icoStage1Cap) {\r\n            if (burnAmount > 0 && burnStage[0]) {\r\n                burnTokens();\r\n                burnStage[0] = false;\r\n                burnAmount = icoStage1Cap;\r\n            }\r\n            \r\n            tokens = tokens.add(tokens.div(100).mul(20));\r\n            tokens = safeSend(tokens, icoStage1Cap.sub(stats.ICOStage1));\r\n            stats.ICOStage1 = stats.ICOStage1.add(tokens);\r\n            stats.ICOStage1ETHRaised = stats.ICOStage1ETHRaised.add(amount);\r\n            burnAmount = burnAmount.sub(tokens);\r\n\r\n            return true;\r\n        } else if ( now < endICOStage2 && stats.ICOStage2 < icoStage2Cap ) {\r\n            if (burnAmount > 0 && burnStage[1]) {\r\n                burnTokens();\r\n                burnStage[1] = false;\r\n                burnAmount = icoStage2Cap;\r\n            }\r\n            \r\n            tokens = tokens.add(tokens.div(100).mul(15));\r\n            tokens = safeSend(tokens, icoStage2Cap.sub(stats.ICOStage2));\r\n            stats.ICOStage2 = stats.ICOStage2.add(tokens);\r\n            stats.ICOStage2ETHRaised = stats.ICOStage2ETHRaised.add(amount);\r\n            burnAmount = burnAmount.sub(tokens);\r\n            \r\n            return true;\r\n        } else if ( now < endICOStage3 && stats.ICOStage3 < icoStage3Cap ) {\r\n            if (burnAmount > 0 && burnStage[2]) {\r\n                burnTokens();\r\n                burnStage[2] = false;\r\n                burnAmount = icoStage3Cap;\r\n            }\r\n            \r\n            tokens = tokens.add(tokens.div(100).mul(8));\r\n            tokens = safeSend(tokens, icoStage3Cap.sub(stats.ICOStage3));\r\n            stats.ICOStage3 = stats.ICOStage3.add(tokens);\r\n            stats.ICOStage3ETHRaised = stats.ICOStage3ETHRaised.add(amount);\r\n            burnAmount = burnAmount.sub(tokens);\r\n            \r\n            return true;\r\n        } else if ( now < endICOStage4 && stats.ICOStage4 < icoStage4Cap ) {\r\n            if (burnAmount > 0 && burnStage[3]) {\r\n                burnTokens();\r\n                burnStage[3] = false;\r\n                burnAmount = icoStage4Cap;\r\n            }\r\n            \r\n            tokens = safeSend(tokens, icoStage4Cap.sub(stats.ICOStage4));\r\n            stats.ICOStage4 = stats.ICOStage4.add(tokens);\r\n            stats.ICOStage4ETHRaised = stats.ICOStage4ETHRaised.add(amount);\r\n            burnAmount = burnAmount.sub(tokens);\r\n            \r\n            return true;\r\n        } else if (now > endICOStage4 && burnAmount > 0) {\r\n            burnTokens();\r\n            msg.sender.transfer(msg.value);\r\n            burnAmount = 0;\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Burn tokens which are not sold on previous stage\r\n     **/\r\n    function burnTokens() private {\r\n        balances[tokenWallet] = balances[tokenWallet].sub(burnAmount);\r\n        totalSupply = totalSupply.sub(burnAmount);\r\n        Burn(tokenWallet, burnAmount);\r\n    }\r\n\r\n    /**\r\n     * Check last token on sale\r\n     **/\r\n    function safeSend(uint tokens, uint stageLimmit) private returns(uint) {\r\n        if (stageLimmit < tokens) {\r\n            uint toReturn = tokenRate.mul(tokens.sub(stageLimmit));\r\n            sendTokens(msg.sender, stageLimmit);\r\n            msg.sender.transfer(toReturn);\r\n            return stageLimmit;\r\n        } else {\r\n            sendTokens(msg.sender, tokens);\r\n            return tokens;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Low-level function for tokens transfer\r\n     **/\r\n    function sendTokens(address _to, uint tokens) private {\r\n        balances[tokenWallet] = balances[tokenWallet].sub(tokens);\r\n        balances[_to] += tokens;\r\n        Transfer(tokenWallet, _to, tokens);\r\n        multiSig.transfer(msg.value);\r\n    }\r\n    \r\n    /**\r\n     * Burn tokens which are not sold on previous stage\r\n     **/    \r\n    function sendTokensRef(address _to, uint tokens) private {\r\n        balances[tokenWallet] = balances[tokenWallet].sub(tokens);\r\n        balances[_to] += tokens;\r\n        Transfer(tokenWallet, _to, tokens);\r\n        stats.RefBonusese += tokens; \r\n    }\r\n    \r\n    /**\r\n     * Update token rate manually\r\n     **/\r\n    function updateTokenRate(uint newRate) onlyOwner public {\r\n        tokenRate = newRate;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startICOStage4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startICOStage2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startICOStage3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endICOStage1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnStage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiSig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endICOStage3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bonusAddress\",\"type\":\"address\"}],\"name\":\"buyTokensBonus\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startICOStage1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"updateTokenRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stats\",\"outputs\":[{\"name\":\"preICO\",\"type\":\"uint256\"},{\"name\":\"preICOETHRaised\",\"type\":\"uint256\"},{\"name\":\"ICOStage1\",\"type\":\"uint256\"},{\"name\":\"ICOStage1ETHRaised\",\"type\":\"uint256\"},{\"name\":\"ICOStage2\",\"type\":\"uint256\"},{\"name\":\"ICOStage2ETHRaised\",\"type\":\"uint256\"},{\"name\":\"ICOStage3\",\"type\":\"uint256\"},{\"name\":\"ICOStage3ETHRaised\",\"type\":\"uint256\"},{\"name\":\"ICOStage4\",\"type\":\"uint256\"},{\"name\":\"ICOStage4ETHRaised\",\"type\":\"uint256\"},{\"name\":\"RefBonusese\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endICOStage2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endICOStage4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenWallet\",\"type\":\"address\"},{\"name\":\"_multiSig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Gelios","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d603d342594775e296e4d14745ecc39097899f5800000000000000000000000043a518e559f2e818df84442a58470381c3684837","Library":"","SwarmSource":"bzzr://6d27058539f88d81618869b547cc4c8a40c73d5d00fedeb7c527029cfd975890"}]}