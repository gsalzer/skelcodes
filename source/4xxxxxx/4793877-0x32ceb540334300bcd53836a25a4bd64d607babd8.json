{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped;\r\n\r\n    modifier stoppable {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address who ) public view returns (uint value);\r\n    function allowance( address owner, address spender ) public view returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) public returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\ncontract BetGame is DSStop {\r\n    using SafeMath for uint256;\r\n\r\n    struct Bet {\r\n        // player\r\n        address player;\r\n        bytes32 secretHash;\r\n        uint256 amount;\r\n        uint roundId;\r\n\r\n        // secret and reveal\r\n        bool isRevealed;    // flag\r\n        uint nonce;\r\n        bool guessOdd;\r\n        bytes32 secret;\r\n    }\r\n\r\n    struct Round {\r\n        uint betCount;\r\n        uint[] betIds;\r\n\r\n        uint startBetBlock;\r\n        uint startRevealBlock;\r\n        uint maxBetBlockCount;      // Max Block Count for wating others to join betting, will return funds if no enough bets join in.\r\n        uint maxRevealBlockCount;   // Should have enough minimal blocks e.g. >100\r\n        uint finalizedBlock;\r\n    }\r\n\r\n    uint public betCount;\r\n    uint public roundCount;\r\n\r\n    mapping(uint => Bet) public bets;\r\n    mapping(uint => Round) public rounds;\r\n    mapping(address => uint) public balancesForWithdraw;\r\n\r\n    uint public poolAmount;\r\n    uint256 public initializeTime;\r\n    ERC20 public pls;\r\n\r\n    struct TokenMessage {\r\n        bool init;\r\n        address fallbackFrom;\r\n        uint256 fallbackValue;\r\n    }\r\n\r\n    TokenMessage public tokenMsg;\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0)\r\n            throw;\r\n        _;\r\n    }\r\n\r\n    modifier tokenPayable {\r\n        require(msg.sender == address(this));\r\n        require(tokenMsg.init);\r\n\r\n        _;\r\n    }\r\n\r\n    function BetGame(address _pls)\r\n    {\r\n        initializeTime = now;\r\n        roundCount = 1;\r\n\r\n        pls = ERC20(_pls);\r\n    }\r\n\r\n    function onTokenTransfer(address _from, address _to, uint _amount) public returns (bool) {\r\n        if (_to == address(this))\r\n        {\r\n            if (stopped) return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function receiveToken(address from, uint256 _amount, address _token) public\r\n    {\r\n        // do nothing.\r\n    }\r\n\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) public\r\n    {\r\n        require(msg.sender == address(pls));\r\n        require(!stopped);\r\n        tokenMsg.init = true;\r\n        tokenMsg.fallbackFrom = _from;\r\n        tokenMsg.fallbackValue = _value;\r\n\r\n        if(! this.call(_data)){\r\n            revert();\r\n        }\r\n\r\n        tokenMsg.init = false;\r\n        tokenMsg.fallbackFrom = 0x0;\r\n        tokenMsg.fallbackValue = 0;\r\n    }\r\n    \r\n    function startRoundWithFirstBet(uint _betCount, uint _maxBetBlockCount, uint _maxRevealBlockCount, bytes32 _secretHashForFirstBet) public tokenPayable returns (uint roundId)\r\n    {\r\n        require(_betCount >= 2);\r\n        require(_maxBetBlockCount >= 100);\r\n        require(_maxRevealBlockCount >= 100);\r\n\r\n        require(tokenMsg.fallbackValue > 0);\r\n\r\n        uint betId = addBet(tokenMsg.fallbackFrom, _secretHashForFirstBet, tokenMsg.fallbackValue);\r\n\r\n        roundId = addRound(_betCount, _maxBetBlockCount, _maxRevealBlockCount, betId);\r\n    }\r\n\r\n    function betWithRound(uint _roundId, bytes32 _secretHashForBet) public tokenPayable\r\n    {\r\n        require(tokenMsg.fallbackValue > 0);\r\n        require(rounds[_roundId].finalizedBlock == 0);\r\n        require(rounds[_roundId].betIds.length < rounds[_roundId].betCount);\r\n        require(!isPlayerInRound(_roundId, tokenMsg.fallbackFrom));\r\n\r\n        uint betId = addBet(tokenMsg.fallbackFrom, _secretHashForBet, tokenMsg.fallbackValue);\r\n        rounds[_roundId].betIds.push(betId);\r\n        bets[betId].roundId = _roundId;\r\n\r\n        if (rounds[_roundId].betIds.length == rounds[_roundId].betCount)\r\n        {\r\n            rounds[_roundId].startRevealBlock = getBlockNumber();\r\n\r\n            RoundRevealStarted(_roundId, rounds[_roundId].startRevealBlock);\r\n        }\r\n    }\r\n\r\n    // anyone can try to reveal the bet\r\n    function revealBet(uint betId, uint _nonce, bool _guessOdd, bytes32 _secret) public returns (bool)\r\n    {\r\n        Bet bet = bets[betId];\r\n        Round round = rounds[bet.roundId];\r\n        require(round.betIds.length == round.betCount);\r\n        require(round.finalizedBlock == 0);\r\n\r\n        if (bet.secretHash == keccak256(_nonce, _guessOdd, _secret) )\r\n        {\r\n            bet.isRevealed = true;\r\n            bet.nonce = _nonce;\r\n            bet.guessOdd = _guessOdd;\r\n            bet.secret = _secret;\r\n            \r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n\r\n    // anyone can try to finalize after the max block count or bets in the round are all revealed.\r\n    function finalizeRound(uint roundId) public\r\n    {\r\n        require(rounds[roundId].finalizedBlock == 0);\r\n        uint finalizedBlock = getBlockNumber();\r\n        \r\n        uint i = 0;\r\n        Bet bet;\r\n        if (rounds[roundId].betIds.length < rounds[roundId].betCount && finalizedBlock.sub(rounds[roundId].startBetBlock) > rounds[roundId].maxBetBlockCount)\r\n        {\r\n            // return funds to players if betting timeout\r\n            for (i=0; i<rounds[roundId].betIds.length; i++) {\r\n                bet = bets[rounds[roundId].betIds[i]];\r\n                balancesForWithdraw[bet.player] = balancesForWithdraw[bet.player].add(bet.amount);\r\n            }\r\n        } else if (rounds[roundId].betIds.length == rounds[roundId].betCount) {\r\n            bool betsRevealed = betRevealed(roundId);\r\n            if (!betsRevealed && finalizedBlock.sub(rounds[roundId].startRevealBlock) > rounds[roundId].maxRevealBlockCount)\r\n            {\r\n                // return funds to players who have already revealed\r\n                // but for those who didn't reveal, the funds go to pool\r\n                // revealing timeout\r\n                for (i = 0; i < rounds[roundId].betIds.length; i++) {\r\n                    if (bets[rounds[roundId].betIds[i]].isRevealed)\r\n                    {\r\n                        balancesForWithdraw[bets[rounds[roundId].betIds[i]].player] = balancesForWithdraw[bets[rounds[roundId].betIds[i]].player].add(bets[rounds[roundId].betIds[i]].amount);\r\n                    } else\r\n                    {\r\n                        // go to pool\r\n                        poolAmount = poolAmount.add(bets[rounds[roundId].betIds[i]].amount);\r\n                    }\r\n                }\r\n            } else if (betsRevealed)\r\n            {\r\n                uint dustLeft = finalizeRewardForRound(roundId);\r\n                poolAmount = poolAmount.add(dustLeft);\r\n            } else\r\n            {\r\n                throw;\r\n            }\r\n\r\n        } else\r\n        {\r\n            throw;\r\n        }\r\n\r\n        rounds[roundId].finalizedBlock = finalizedBlock;\r\n        RoundFinalized(roundId);\r\n    }\r\n\r\n    function withdraw() public returns (bool)\r\n    {\r\n        var amount = balancesForWithdraw[msg.sender];\r\n        if (amount > 0) {\r\n            balancesForWithdraw[msg.sender] = 0;\r\n\r\n            if (!pls.transfer(msg.sender, amount)) {\r\n                // No need to call throw here, just reset the amount owing\r\n                balancesForWithdraw[msg.sender] = amount;\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function claimFromPool() public auth\r\n    {\r\n        owner.transfer(poolAmount);\r\n        ClaimFromPool();\r\n    }\r\n\r\n    /*\r\n     * Constant functions\r\n     */\r\n    // For players to calculate hash of secret before start a bet.\r\n    function calculateSecretHash(uint _nonce, bool _guessOdd, bytes32 _secret) constant public returns (bytes32 secretHash)\r\n    {\r\n        secretHash = keccak256(_nonce, _guessOdd, _secret);\r\n    }\r\n\r\n    function isPlayerInRound(uint _roundId, address _player) public constant returns (bool isIn)\r\n    {\r\n        for (uint i=0; i < rounds[_roundId].betIds.length; i++) {\r\n            if (bets[rounds[_roundId].betIds[i]].player == _player)\r\n            {\r\n                isIn = true;\r\n                return;\r\n            }\r\n        }\r\n\r\n        isIn = false;\r\n    }\r\n    \r\n    function getBetIds(uint roundIndex) public constant returns (uint[] _betIds)\r\n    {\r\n        _betIds = new uint[](rounds[roundIndex].betIds.length);\r\n\r\n        for (uint i=0; i < rounds[roundIndex].betIds.length; i++)\r\n            _betIds[i] = rounds[roundIndex].betIds[i];\r\n    }\r\n\r\n    function getBetIdAtRound(uint roundIndex, uint innerIndex) constant public returns (uint) {\r\n        return rounds[roundIndex].betIds[innerIndex];\r\n    }\r\n\r\n    function getBetSizeAtRound(uint roundIndex) constant public returns (uint) {\r\n        return rounds[roundIndex].betIds.length;\r\n    }\r\n\r\n    function betRevealed(uint roundId) constant public returns(bool)\r\n    {\r\n        bool betsRevealed = true;\r\n        uint i = 0;\r\n        Bet bet;\r\n        for (i=0; i<rounds[roundId].betIds.length; i++) {\r\n            bet = bets[rounds[roundId].betIds[i]];\r\n            if (!bet.isRevealed)\r\n            {\r\n                betsRevealed = false;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        return betsRevealed;\r\n    }\r\n    \r\n    function getJackpotResults(uint roundId) constant public returns(uint, uint, bool)\r\n    {\r\n        uint jackpotSum;\r\n        uint jackpotSecret;\r\n        uint oddSum;\r\n\r\n        uint i = 0;\r\n        for (i=0; i<rounds[roundId].betIds.length; i++) {\r\n            jackpotSum = jackpotSum.add(bets[rounds[roundId].betIds[i]].amount);\r\n            jackpotSecret = jackpotSecret.add(uint(bets[rounds[roundId].betIds[i]].secret));\r\n            \r\n            if( bets[rounds[roundId].betIds[i]].guessOdd ){\r\n                oddSum = oddSum.add(bets[rounds[roundId].betIds[i]].amount);\r\n            }\r\n        }\r\n        \r\n        bool isOddWin = (jackpotSecret % 2 == 1);\r\n\r\n        // all is odd, or all is not odd\r\n        if (oddSum == 0 || oddSum == jackpotSum)\r\n        {\r\n            isOddWin = oddSum > 0 ? true : false;\r\n        }\r\n        \r\n        return (jackpotSum, oddSum, isOddWin);\r\n    }\r\n\r\n    /// @notice This function is overridden by the test Mocks.\r\n    function getBlockNumber() internal constant returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new bet to the bet mapping, if bet does not exist yet.\r\n    /// @param _player The player of the bet.\r\n    /// @param _secretHash The hash of the nonce, guessOdd, and secret for the bet, hash ＝ keccak256(_num, _guessOdd, _secret) \r\n    /// @param _amount The amount of the bet.\r\n    /// @return Returns bet ID.\r\n    function addBet(address _player, bytes32 _secretHash, uint256 _amount)\r\n        internal\r\n        notNull(_player)\r\n        returns (uint betId)\r\n    {\r\n        betId = betCount;\r\n        bets[betId] = Bet({\r\n            player: _player,\r\n            secretHash: _secretHash,\r\n            amount: _amount,\r\n            roundId: 0,\r\n            isRevealed: false,\r\n            nonce:0,\r\n            guessOdd:false,\r\n            secret: \"\"\r\n        });\r\n        betCount += 1;\r\n        BetSubmission(betId);\r\n    }\r\n\r\n    function addRound(uint _betCount, uint _maxBetBlockCount, uint _maxRevealBlockCount, uint _betId)\r\n        internal\r\n        returns (uint roundId)\r\n    {\r\n        roundId = roundCount;\r\n        rounds[roundId].betCount = _betCount;\r\n        rounds[roundId].maxBetBlockCount = _maxBetBlockCount;\r\n        rounds[roundId].maxRevealBlockCount = _maxRevealBlockCount;\r\n        rounds[roundId].betIds.push(_betId);\r\n        rounds[roundId].startBetBlock = getBlockNumber();\r\n        rounds[roundId].startRevealBlock = 0;\r\n        rounds[roundId].finalizedBlock = 0;\r\n\r\n        bets[_betId].roundId = roundId;\r\n\r\n        roundCount += 1;\r\n        RoundSubmission(roundId);\r\n        RoundBetStarted(roundId, rounds[roundId].startBetBlock);\r\n    }\r\n    \r\n    function finalizeRewardForBet(uint betId, bool isOddWin, uint jackpotSum, uint oddSum, uint evenSum, uint dustLeft) internal returns(uint)\r\n    {\r\n        uint reward = 0;\r\n        if (isOddWin && bets[betId].guessOdd)\r\n        {\r\n            reward = bets[betId].amount.mul(jackpotSum).div(oddSum);\r\n            balancesForWithdraw[bets[betId].player] = balancesForWithdraw[bets[betId].player].add(reward);\r\n            dustLeft = dustLeft.sub(reward);\r\n        } else if (!isOddWin && !bets[betId].guessOdd)\r\n        {\r\n            reward = bets[betId].amount.mul(jackpotSum).div(evenSum);\r\n            balancesForWithdraw[bets[betId].player] = balancesForWithdraw[bets[betId].player].add(reward);\r\n            dustLeft = dustLeft.sub(reward);\r\n        }\r\n        \r\n        return dustLeft;\r\n    }\r\n    \r\n    function finalizeRewardForRound(uint roundId) internal returns (uint dustLeft)\r\n    {\r\n        var (jackpotSum, oddSum, isOddWin) = getJackpotResults(roundId);\r\n\r\n        dustLeft = jackpotSum;\r\n\r\n        uint i = 0;\r\n        for (i=0; i<rounds[roundId].betIds.length; i++) {\r\n            dustLeft = finalizeRewardForBet(rounds[roundId].betIds[i], isOddWin, jackpotSum, oddSum, jackpotSum - oddSum, dustLeft);\r\n        }\r\n    }\r\n    \r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public auth {\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n        \r\n        ERC20 token = ERC20(_token);\r\n        \r\n        uint256 balance = token.balanceOf(this);\r\n        \r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n    event BetSubmission(uint indexed _betId);\r\n    event RoundSubmission(uint indexed _roundId);\r\n    event ClaimFromPool();\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n    event RoundFinalized(uint indexed _roundId);\r\n    event RoundBetStarted(uint indexed _roundId, uint startBetBlock);\r\n    event RoundRevealStarted(uint indexed _roundId, uint startRevealBlock);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_betCount\",\"type\":\"uint256\"},{\"name\":\"_maxBetBlockCount\",\"type\":\"uint256\"},{\"name\":\"_maxRevealBlockCount\",\"type\":\"uint256\"},{\"name\":\"_secretHashForFirstBet\",\"type\":\"bytes32\"}],\"name\":\"startRoundWithFirstBet\",\"outputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pls\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"isRevealed\",\"type\":\"bool\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"guessOdd\",\"type\":\"bool\"},{\"name\":\"secret\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundIndex\",\"type\":\"uint256\"}],\"name\":\"getBetSizeAtRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"finalizeRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"_secretHashForBet\",\"type\":\"bytes32\"}],\"name\":\"betWithRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initializeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"betRevealed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMsg\",\"outputs\":[{\"name\":\"init\",\"type\":\"bool\"},{\"name\":\"fallbackFrom\",\"type\":\"address\"},{\"name\":\"fallbackValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"betCount\",\"type\":\"uint256\"},{\"name\":\"startBetBlock\",\"type\":\"uint256\"},{\"name\":\"startRevealBlock\",\"type\":\"uint256\"},{\"name\":\"maxBetBlockCount\",\"type\":\"uint256\"},{\"name\":\"maxRevealBlockCount\",\"type\":\"uint256\"},{\"name\":\"finalizedBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimFromPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_guessOdd\",\"type\":\"bool\"},{\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"calculateSecretHash\",\"outputs\":[{\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getJackpotResults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundIndex\",\"type\":\"uint256\"}],\"name\":\"getBetIds\",\"outputs\":[{\"name\":\"_betIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundIndex\",\"type\":\"uint256\"},{\"name\":\"innerIndex\",\"type\":\"uint256\"}],\"name\":\"getBetIdAtRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"receiveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_guessOdd\",\"type\":\"bool\"},{\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"revealBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"isPlayerInRound\",\"outputs\":[{\"name\":\"isIn\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balancesForWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pls\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_betId\",\"type\":\"uint256\"}],\"name\":\"BetSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"RoundSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ClaimFromPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"RoundFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startBetBlock\",\"type\":\"uint256\"}],\"name\":\"RoundBetStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startRevealBlock\",\"type\":\"uint256\"}],\"name\":\"RoundRevealStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"}]","ContractName":"BetGame","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e43ac1714f7394173b15e7cff31a63d523ce4fb9","Library":"","SwarmSource":"bzzr://7016e68afb82e1c4da1d4e64c8f7aded4c820c8bd4d33585aa376f9e0e3352f2"}]}