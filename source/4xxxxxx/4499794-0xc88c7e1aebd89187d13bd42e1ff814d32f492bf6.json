{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\ncontract IERC20Token {\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract IToken {\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n  function mintTokens(address _to, uint256 _amount) {}\r\n}\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\ncontract ReentrancyHandling {\r\n    bool locked;\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract Crowdsale is ReentrancyHandling, Owned {\r\n  using SafeMath for uint256;\r\n  \r\n  struct ContributorData {\r\n    bool isWhiteListed;\r\n    bool isCommunityRoundApproved;\r\n    uint256 contributionAmount;\r\n    uint256 tokensIssued;\r\n  }\r\n  mapping(address => ContributorData) public contributorList;\r\n  enum state { pendingStart, communityRound, crowdsaleStarted, crowdsaleEnded }\r\n  state crowdsaleState;\r\n  uint public communityRoundStartDate;\r\n  uint public crowdsaleStartDate;\r\n  uint public crowdsaleEndDate;\r\n  event CommunityRoundStarted(uint timestamp);\r\n  event CrowdsaleStarted(uint timestamp);\r\n  event CrowdsaleEnded(uint timestamp);\r\n  IToken token = IToken(0x0);\r\n  uint ethToTokenConversion;\r\n  uint256 maxCrowdsaleCap;\r\n  uint256 maxCommunityCap;\r\n  uint256 maxCommunityWithoutBonusCap;\r\n  uint256 maxContribution;\r\n  uint256 tokenSold = 0;\r\n  uint256 communityTokenSold = 0;\r\n  uint256 communityTokenWithoutBonusSold = 0;\r\n  uint256 crowdsaleTokenSold = 0;\r\n  uint256 public ethRaisedWithoutCompany = 0;\r\n  address companyAddress;   // company wallet address in cold/hardware storage \r\n  uint maxTokenSupply;\r\n  uint companyTokens;\r\n  bool treasuryLocked = false;\r\n  bool ownerHasClaimedTokens = false;\r\n  bool ownerHasClaimedCompanyTokens = false;\r\n  // validates sender is whitelisted\r\n  modifier onlyWhiteListUser {\r\n    require(contributorList[msg.sender].isWhiteListed == true);\r\n    _;\r\n  }\r\n  // limit gas price to 50 Gwei (about 5-10x the normal amount)\r\n  modifier onlyLowGasPrice {\r\n\t  require(tx.gasprice <= 50*10**9 wei);\r\n\t  _;\r\n  }\r\n  //\r\n  // Unnamed function that runs when eth is sent to the contract\r\n  //\r\n  function() public noReentrancy onlyWhiteListUser onlyLowGasPrice payable {\r\n    require(msg.value != 0);                                         // Throw if value is 0\r\n    require(companyAddress != 0x0);\r\n    require(token != IToken(0x0));\r\n    checkCrowdsaleState();                                           // Calibrate crowdsale state\r\n    assert((crowdsaleState == state.communityRound && contributorList[msg.sender].isCommunityRoundApproved) ||\r\n            crowdsaleState == state.crowdsaleStarted);\r\n    \r\n    processTransaction(msg.sender, msg.value);                       // Process transaction and issue tokens\r\n    checkCrowdsaleState();                                           // Calibrate crowdsale state\r\n  }\r\n  // \r\n  // return state of smart contract\r\n  //\r\n  function getState() public constant returns (uint256, uint256, uint) {\r\n    uint currentState = 0;\r\n    if (crowdsaleState == state.pendingStart) {\r\n      currentState = 1;\r\n    }\r\n    else if (crowdsaleState == state.communityRound) {\r\n      currentState = 2;\r\n    }\r\n    else if (crowdsaleState == state.crowdsaleStarted) {\r\n      currentState = 3;\r\n    }\r\n    else if (crowdsaleState == state.crowdsaleEnded) {\r\n      currentState = 4;\r\n    }\r\n    return (tokenSold, communityTokenSold, currentState);\r\n  }\r\n  //\r\n  // Check crowdsale state and calibrate it\r\n  //\r\n  function checkCrowdsaleState() internal {\r\n    if (now > crowdsaleEndDate || tokenSold >= maxTokenSupply) {  // end crowdsale once all tokens are sold or run out of time\r\n      if (crowdsaleState != state.crowdsaleEnded) {\r\n        crowdsaleState = state.crowdsaleEnded;\r\n        CrowdsaleEnded(now);\r\n      }\r\n    }\r\n    else if (now > crowdsaleStartDate) { // move into crowdsale round\r\n      if (crowdsaleState != state.crowdsaleStarted) {\r\n        uint256 communityTokenRemaining = maxCommunityCap.sub(communityTokenSold);  // apply any remaining tokens from community round to crowdsale round\r\n        maxCrowdsaleCap = maxCrowdsaleCap.add(communityTokenRemaining);\r\n        crowdsaleState = state.crowdsaleStarted;  // change state\r\n        CrowdsaleStarted(now);\r\n      }\r\n    }\r\n    else if (now > communityRoundStartDate) {\r\n      if (communityTokenSold < maxCommunityCap) {\r\n        if (crowdsaleState != state.communityRound) {\r\n          crowdsaleState = state.communityRound;\r\n          CommunityRoundStarted(now);\r\n        }\r\n      }\r\n      else {  // automatically start crowdsale when all community round tokens are sold out \r\n        if (crowdsaleState != state.crowdsaleStarted) {\r\n          crowdsaleState = state.crowdsaleStarted;\r\n          CrowdsaleStarted(now);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  //\r\n  // Issue tokens and return if there is overflow\r\n  //\r\n  function calculateCommunity(address _contributor, uint256 _newContribution) internal returns (uint256, uint256) {\r\n    uint256 communityEthAmount = 0;\r\n    uint256 communityTokenAmount = 0;\r\n    uint previousContribution = contributorList[_contributor].contributionAmount;  // retrieve previous contributions\r\n    // community round ONLY\r\n    if (crowdsaleState == state.communityRound && \r\n        contributorList[_contributor].isCommunityRoundApproved && \r\n        previousContribution < maxContribution) {\r\n        communityEthAmount = _newContribution;\r\n        uint256 availableEthAmount = maxContribution.sub(previousContribution);                 \r\n        // limit the contribution ETH amount to the maximum allowed for the community round\r\n        if (communityEthAmount > availableEthAmount) {\r\n          communityEthAmount = availableEthAmount;\r\n        }\r\n        // compute community tokens without bonus\r\n        communityTokenAmount = communityEthAmount.mul(ethToTokenConversion);\r\n        uint256 availableTokenAmount = maxCommunityWithoutBonusCap.sub(communityTokenWithoutBonusSold);\r\n        // verify community tokens do not go over the max cap for community round\r\n        if (communityTokenAmount > availableTokenAmount) {\r\n          // cap the tokens to the max allowed for the community round\r\n          communityTokenAmount = availableTokenAmount;\r\n          // recalculate the corresponding ETH amount\r\n          communityEthAmount = communityTokenAmount.div(ethToTokenConversion);\r\n        }\r\n        // track tokens sold during community round\r\n        communityTokenWithoutBonusSold = communityTokenWithoutBonusSold.add(communityTokenAmount);\r\n        // compute bonus tokens\r\n        uint256 bonusTokenAmount = communityTokenAmount.mul(15);\r\n        bonusTokenAmount = bonusTokenAmount.div(100);\r\n        // add bonus to community tokens\r\n        communityTokenAmount = communityTokenAmount.add(bonusTokenAmount);\r\n        // track tokens sold during community round\r\n        communityTokenSold = communityTokenSold.add(communityTokenAmount);\r\n    }\r\n    return (communityTokenAmount, communityEthAmount);\r\n  }\r\n  //\r\n  // Issue tokens and return if there is overflow\r\n  //\r\n  function calculateCrowdsale(uint256 _remainingContribution) internal returns (uint256, uint256) {\r\n    uint256 crowdsaleEthAmount = _remainingContribution;\r\n    // compute crowdsale tokens\r\n    uint256 crowdsaleTokenAmount = crowdsaleEthAmount.mul(ethToTokenConversion);\r\n    // determine crowdsale tokens remaining\r\n    uint256 availableTokenAmount = maxCrowdsaleCap.sub(crowdsaleTokenSold);\r\n    // verify crowdsale tokens do not go over the max cap for crowdsale round\r\n    if (crowdsaleTokenAmount > availableTokenAmount) {\r\n      // cap the tokens to the max allowed for the crowdsale round\r\n      crowdsaleTokenAmount = availableTokenAmount;\r\n      // recalculate the corresponding ETH amount\r\n      crowdsaleEthAmount = crowdsaleTokenAmount.div(ethToTokenConversion);\r\n    }\r\n    // track tokens sold during crowdsale round\r\n    crowdsaleTokenSold = crowdsaleTokenSold.add(crowdsaleTokenAmount);\r\n    return (crowdsaleTokenAmount, crowdsaleEthAmount);\r\n  }\r\n  //\r\n  // Issue tokens and return if there is overflow\r\n  //\r\n  function processTransaction(address _contributor, uint256 _amount) internal {\r\n    uint256 newContribution = _amount;\r\n    var (communityTokenAmount, communityEthAmount) = calculateCommunity(_contributor, newContribution);\r\n    // compute remaining ETH amount available for purchasing crowdsale tokens\r\n    var (crowdsaleTokenAmount, crowdsaleEthAmount) = calculateCrowdsale(newContribution.sub(communityEthAmount));\r\n    // add up crowdsale + community tokens\r\n    uint256 tokenAmount = crowdsaleTokenAmount.add(communityTokenAmount);\r\n    assert(tokenAmount > 0);\r\n    // Issue new tokens\r\n    token.mintTokens(_contributor, tokenAmount);                              \r\n    // log token issuance\r\n    contributorList[_contributor].tokensIssued = contributorList[_contributor].tokensIssued.add(tokenAmount);                \r\n    // Add contribution amount to existing contributor\r\n    newContribution = crowdsaleEthAmount.add(communityEthAmount);\r\n    contributorList[_contributor].contributionAmount = contributorList[_contributor].contributionAmount.add(newContribution);\r\n    ethRaisedWithoutCompany = ethRaisedWithoutCompany.add(newContribution);                              // Add contribution amount to ETH raised\r\n    tokenSold = tokenSold.add(tokenAmount);                                  // track how many tokens are sold\r\n    // compute any refund if applicable\r\n    uint256 refundAmount = _amount.sub(newContribution);\r\n    if (refundAmount > 0) {\r\n      _contributor.transfer(refundAmount);                                   // refund contributor amount behind the maximum ETH cap\r\n    }\r\n    companyAddress.transfer(newContribution);                                // send ETH to company\r\n  }\r\n  //\r\n  // whitelist validated participants.\r\n  //\r\n  function WhiteListContributors(address[] _contributorAddresses, bool[] _contributorCommunityRoundApproved) public onlyOwner {\r\n    require(_contributorAddresses.length == _contributorCommunityRoundApproved.length); // Check if input data is correct\r\n    for (uint cnt = 0; cnt < _contributorAddresses.length; cnt++) {\r\n      contributorList[_contributorAddresses[cnt]].isWhiteListed = true;\r\n      contributorList[_contributorAddresses[cnt]].isCommunityRoundApproved = _contributorCommunityRoundApproved[cnt];\r\n    }\r\n  }\r\n  //\r\n  // Method is needed for recovering tokens accidentally sent to token address\r\n  //\r\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) public onlyOwner {\r\n    IERC20Token(_tokenAddress).transfer(_to, _amount);\r\n  }\r\n  //\r\n  // Owner can set multisig address for crowdsale\r\n  //\r\n  function setCompanyAddress(address _newAddress) public onlyOwner {\r\n    require(!treasuryLocked);                              // Check if owner has already claimed tokens\r\n    companyAddress = _newAddress;\r\n    treasuryLocked = true;\r\n  }\r\n  //\r\n  // Owner can set token address where mints will happen\r\n  //\r\n  function setToken(address _newAddress) public onlyOwner {\r\n    token = IToken(_newAddress);\r\n  }\r\n  function getToken() public constant returns (address) {\r\n    return address(token);\r\n  }\r\n  //\r\n  // Claims company tokens\r\n  //\r\n  function claimCompanyTokens() public onlyOwner {\r\n    require(!ownerHasClaimedCompanyTokens);                     // Check if owner has already claimed tokens\r\n    require(companyAddress != 0x0);\r\n    \r\n    tokenSold = tokenSold.add(companyTokens); \r\n    token.mintTokens(companyAddress, companyTokens);            // Issue company tokens \r\n    ownerHasClaimedCompanyTokens = true;                        // Block further mints from this method\r\n  }\r\n  //\r\n  // Claim remaining tokens when crowdsale ends\r\n  //\r\n  function claimRemainingTokens() public onlyOwner {\r\n    checkCrowdsaleState();                                        // Calibrate crowdsale state\r\n    require(crowdsaleState == state.crowdsaleEnded);              // Check crowdsale has ended\r\n    require(!ownerHasClaimedTokens);                              // Check if owner has already claimed tokens\r\n    require(companyAddress != 0x0);\r\n    uint256 remainingTokens = maxTokenSupply.sub(token.totalSupply());\r\n    token.mintTokens(companyAddress, remainingTokens);            // Issue tokens to company\r\n    ownerHasClaimedTokens = true;                                 // Block further mints from this method\r\n  }\r\n}\r\ncontract StormCrowdsale is Crowdsale {\r\n    string public officialWebsite;\r\n    string public officialFacebook;\r\n    string public officialTelegram;\r\n    string public officialEmail;\r\n  function StormCrowdsale() public {\r\n    officialWebsite = \"https://www.stormtoken.com\";\r\n    officialFacebook = \"https://www.facebook.com/stormtoken/\";\r\n    officialTelegram = \"https://t.me/joinchat/GHTZGQwsy9mZk0KFEEjGtg\";\r\n    officialEmail = \"info@stormtoken.com\";\r\n    communityRoundStartDate = 1510063200;                       // Nov 7, 2017 @ 6am PST\r\n    crowdsaleStartDate = communityRoundStartDate + 24 hours;    // 24 hours later\r\n    crowdsaleEndDate = communityRoundStartDate + 30 days + 12 hours; // 30 days + 12 hours later: Dec 7th, 2017 @ 6pm PST [1512698400]\r\n    crowdsaleState = state.pendingStart;\r\n    ethToTokenConversion = 26950;                 // 1 ETH == 26,950 STORM tokens\r\n    maxTokenSupply = 10000000000 ether;           // 10,000,000,000\r\n    companyTokens = 8124766171 ether;             // allocation for company pool, private presale, user pool \r\n                                                  // 2,325,649,071 tokens from the company pool are voluntarily locked for 2 years\r\n    maxCommunityWithoutBonusCap = 945000000 ether;\r\n    maxCommunityCap = 1086750000 ether;           // 945,000,000 with 15% bonus of 141,750,000\r\n    maxCrowdsaleCap = 788483829 ether;            // tokens allocated to crowdsale \r\n    maxContribution = 100 ether;                  // maximum contribution during community round\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"officialEmail\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRemainingTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"officialFacebook\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setCompanyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorList\",\"outputs\":[{\"name\":\"isWhiteListed\",\"type\":\"bool\"},{\"name\":\"isCommunityRoundApproved\",\"type\":\"bool\"},{\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"name\":\"tokensIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRaisedWithoutCompany\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"officialTelegram\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimCompanyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"officialWebsite\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityRoundStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributorAddresses\",\"type\":\"address[]\"},{\"name\":\"_contributorCommunityRoundApproved\",\"type\":\"bool[]\"}],\"name\":\"WhiteListContributors\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"CommunityRoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"StormCrowdsale","CompilerVersion":"v0.4.19-nightly.2017.11.11+commit.284c3839","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e2b689ace3daeac854c0fa90273b3f3c22656dce664044dba6788eb8a6b45d51"}]}