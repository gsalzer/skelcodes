{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * Multiplication with safety check\r\n    */\r\n    function Mul(uint256 a, uint256 b) pure internal returns (uint256) {\r\n      uint256 c = a * b;\r\n      //check result should not be other wise until a=0\r\n      assert(a == 0 || c / a == b);\r\n      return c;\r\n    }\r\n\r\n    /**\r\n    * Division with safety check\r\n    */\r\n    function Div(uint256 a, uint256 b) pure internal returns (uint256) {\r\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n      uint256 c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n      return c;\r\n    }\r\n\r\n    /**\r\n    * Subtraction with safety check\r\n    */\r\n    function Sub(uint256 a, uint256 b) pure internal returns (uint256) {\r\n      //b must be greater that a as we need to store value in unsigned integer\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    /**\r\n    * Addition with safety check\r\n    */\r\n    function Add(uint256 a, uint256 b) pure internal returns (uint256) {\r\n      uint256 c = a + b;\r\n      //We need to check result greater than only one number for valid Addition\r\n      //refer https://ethereum.stackexchange.com/a/15270/16048\r\n      assert(c >= a);\r\n      return c;\r\n    }\r\n}\r\n\r\n/**\r\n * Contract \"ERC20Basic\"\r\n * Purpose: Defining ERC20 standard with basic functionality like - CheckBalance and Transfer including Transfer event\r\n */\r\ncontract ERC20Basic {\r\n\r\n  //Give realtime totalSupply of IAC token\r\n  uint256 public totalSupply;\r\n\r\n  //Get IAC token balance for provided address\r\n  function balanceOf(address who) view public returns (uint256);\r\n\r\n  //Transfer IAC token to provided address\r\n  function transfer(address _to, uint256 _value) public returns(bool ok);\r\n\r\n  //Emit Transfer event outside of blockchain for every IAC token transfer\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n}\r\n\r\n/**\r\n * Contract \"ERC20\"\r\n * Purpose: Defining ERC20 standard with more advanced functionality like - Authorize spender to transfer IAC token\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n\r\n  //Get IAC token amount that spender can spend from provided owner's account\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n  //Transfer initiated by spender\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns(bool ok);\r\n\r\n  //Add spender to authrize for spending specified amount of IAC Token\r\n  function approve(address _spender, uint256 _value) public returns(bool ok);\r\n\r\n  //Emit event for any approval provided to spender\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * Contract \"Ownable\"\r\n * Purpose: Defines Owner for contract and provide functionality to transfer ownership to another account\r\n */\r\ncontract Ownable {\r\n\r\n  //owner variable to store contract owner account\r\n  address public owner;\r\n\r\n  //Constructor for the contract to store owner's account on deployment\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  //modifier to check transaction initiator is only owner\r\n  modifier onlyOwner() {\r\n    require (msg.sender == owner);\r\n      _;\r\n  }\r\n\r\n  //ownership can be transferred to provided newOwner. Function can only be initiated by contract owner's account\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require (newOwner != address(0));\r\n      owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Contract \"Pausable\"\r\n * Purpose: Contract to provide functionality to pause and resume Sale in case of emergency\r\n */\r\ncontract Pausable is Ownable {\r\n\r\n  //flag to indicate whether Sale is paused or not\r\n  bool public stopped;\r\n\r\n  //Emit event when any change happens in crowdsale state\r\n  event StateChanged(bool changed);\r\n\r\n  //modifier to continue with transaction only when Sale is not paused\r\n  modifier stopInEmergency {\r\n    require(!stopped);\r\n    _;\r\n  }\r\n\r\n  //modifier to continue with transaction only when Sale is paused\r\n  modifier onlyInEmergency {\r\n    require(stopped);\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, pause Sale\r\n  function emergencyStop() external onlyOwner  {\r\n    stopped = true;\r\n    //Emit event when crowdsale state changes\r\n    StateChanged(true);\r\n  }\r\n\r\n  // called by the owner on end of emergency, resumes Sale\r\n  function release() external onlyOwner onlyInEmergency {\r\n    stopped = false;\r\n    //Emit event when crowdsale state changes\r\n    StateChanged(true);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Contract \"IAC\"\r\n * Purpose: Create IAC token\r\n */\r\ncontract Injii is ERC20, Ownable {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  /* Public variables of the token */\r\n  //To store name for token\r\n  string public constant name = \"Injii Access Coins\";\r\n\r\n  //To store symbol for token\r\n  string public constant symbol = \"IAC\";\r\n\r\n  //To store decimal places for token\r\n  uint8 public constant decimals = 0;\r\n\r\n  //To store decimal version for token\r\n  string public version = 'v1.0';\r\n\r\n  //flag to indicate whether transfer of IAC Token is allowed or not\r\n  bool public locked;\r\n\r\n  //map to store IAC Token balance corresponding to address\r\n  mapping(address => uint256) balances;\r\n\r\n  //To store spender with allowed amount of IAC Token to spend corresponding to IAC Token holder's account\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  //To handle ERC20 short address attack\r\n  modifier onlyPayloadSize(uint256 size) {\r\n     require(msg.data.length >= size + 4);\r\n     _;\r\n  }\r\n\r\n  // Lock transfer during Sale\r\n  modifier onlyUnlocked() {\r\n    require(!locked);\r\n    _;\r\n  }\r\n\r\n  //Contructor to define IAC Token properties\r\n  function Injii() public {\r\n    // lock the transfer function during Sale\r\n    locked = true;\r\n\r\n    //initial token supply is 0\r\n    totalSupply = 0;\r\n  }\r\n\r\n  //Implementation for transferring IAC Token to provided address\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public onlyUnlocked returns (bool){\r\n\r\n    //Check provided IAC Token should not be 0\r\n    if (_to != address(0) && _value >= 1) {\r\n      //deduct IAC Token amount from transaction initiator\r\n      balances[msg.sender] = balances[msg.sender].Sub(_value);\r\n      //Add IAC Token to balace of target account\r\n      balances[_to] = balances[_to].Add(_value);\r\n      //Emit event for transferring IAC Token\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    }\r\n    else{\r\n      return false;\r\n    }\r\n  }\r\n\r\n  //Transfer initiated by spender\r\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public onlyUnlocked returns (bool) {\r\n\r\n    //Check provided IAC Token should not be 0\r\n    if (_to != address(0) && _from != address(0)) {\r\n      //Get amount of IAC Token for which spender is authorized\r\n      var _allowance = allowed[_from][msg.sender];\r\n      //Add amount of IAC Token in trarget account's balance\r\n      balances[_to] = balances[_to].Add(_value);\r\n      //Deduct IAC Token amount from _from account\r\n      balances[_from] = balances[_from].Sub(_value);\r\n      //Deduct Authorized amount for spender\r\n      allowed[_from][msg.sender] = _allowance.Sub(_value);\r\n      //Emit event for Transfer\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    }else{\r\n      return false;\r\n    }\r\n  }\r\n\r\n  //Get IAC Token balance for provided address\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  //Add spender to authorize for spending specified amount of IAC Token\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    require(_spender != address(0));\r\n    //do not allow decimals\r\n    uint256 iacToApprove = _value;\r\n    allowed[msg.sender][_spender] = iacToApprove;\r\n    //Emit event for approval provided to spender\r\n    Approval(msg.sender, _spender, iacToApprove);\r\n    return true;\r\n  }\r\n\r\n  //Get IAC Token amount that spender can spend from provided owner's account\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract Metadata {\r\n    \r\n    address public owner;\r\n    \r\n    mapping (uint => address) registerMap;\r\n\r\n    function Metadata() public {\r\n        owner = msg.sender;\r\n        registerMap[0] = msg.sender;\r\n    }\r\n\r\n    //get contract address by its ID\r\n    function getAddress (uint addressId) public view returns (address){\r\n        return registerMap[addressId];\r\n    }\r\n\r\n    //add or replace contract address by id. This is also the order of deployment\r\n    //0 = owner\r\n    //1 = Ecosystem\r\n    //2 = Crowdsale. This will deploy the token contract also.\r\n    //3 = Company Inventory\r\n    function addAddress (uint addressId, address addressContract) public {\r\n        assert(addressContract != 0x0 );\r\n        require (owner == msg.sender || owner == tx.origin);\r\n        registerMap[addressId] = addressContract;\r\n    }\r\n}\r\n\r\ncontract Ecosystem is Ownable{\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    //variable of type metadata to store metadata contract object\r\n    Metadata private objMetadata;\r\n    Crowdsale private objCrowdsale;\r\n    uint256 constant private ecosystemContractID = 1;\r\n    uint256 constant private crowdsaleContractID = 2;\r\n    bool public crowdsaleAddressSet;\r\n    event TokensReceived(address receivedFrom, uint256 numberOfTokensReceive);\r\n\r\n    //Constructor\r\n    function Ecosystem(address _metadataContractAddr) public {\r\n        assert(_metadataContractAddr != address(0));\r\n        //passing address of meta data contract to metadata type address variable\r\n        objMetadata = Metadata(_metadataContractAddr);\r\n        //register this contract in metadata\r\n        objMetadata.addAddress(ecosystemContractID, this);\r\n    }\r\n\r\n    function SetCrowdsaleAddress () public onlyOwner {\r\n        require(!crowdsaleAddressSet);\r\n        address crowdsaleContractAddress = objMetadata.getAddress(crowdsaleContractID);\r\n        assert(crowdsaleContractAddress != address(0));\r\n        objCrowdsale = Crowdsale(crowdsaleContractAddress);\r\n        crowdsaleAddressSet = true;\r\n    }\r\n\r\n    function rewardUser(address user, uint256 iacToSend) public onlyOwner{\r\n        assert(crowdsaleAddressSet);\r\n        objCrowdsale.transfer(user, iacToSend);\r\n    }\r\n\r\n    function tokenFallback(address _from, uint _value){\r\n        TokensReceived(_from, _value);\r\n    }\r\n\r\n}\r\n\r\ncontract CompanyInventory is Ownable{\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    //record timestamp when the lock was initiated\r\n    uint256 public startBlock;\r\n    //to record how many tokens are unlocked\r\n    uint256 public unlockedTokens;\r\n    uint256 public initialReleaseDone = 0;\r\n    uint256 public secondReleaseDone = 0;\r\n    uint256 public totalSuppliedAfterLock = 0;\r\n    uint256 public balance = 0;\r\n    uint256 public totalSupplyFromInventory;\r\n    //total number of tokens available in inventory\r\n    uint256 public totalRemainInInventory;\r\n    //variable of type metadata to store metadata contract object\r\n    Metadata private objMetadata;\r\n    Crowdsale private objCrowdsale;\r\n    uint256 constant private crowdsaleContractID = 2;\r\n    uint256 constant private inventoryContractID = 3;\r\n    //Emit event when tokens are transferred from company inventory\r\n    event TransferredUnlockedTokens(address addr, uint value, bytes32 comment);\r\n    //Emit event when any change happens in crowdsale state\r\n    event StateChanged(bool changed);\r\n    \r\n    //constructor\r\n    function CompanyInventory(address _metadataContractAddr) public {\r\n        assert(_metadataContractAddr != address(0));\r\n        //passing address of meta data contract to metadat type address variable\r\n        objMetadata = Metadata(_metadataContractAddr);\r\n        objMetadata.addAddress(inventoryContractID, this);\r\n        objCrowdsale = Crowdsale(objMetadata.getAddress(crowdsaleContractID));\r\n    }\r\n    \r\n    function initiateLocking (uint256 _alreadyTransferredTokens) public {\r\n        require(msg.sender == objMetadata.getAddress(crowdsaleContractID) && startBlock == 0);\r\n        startBlock = now;\r\n        unlockedTokens = 0;\r\n        balance = objCrowdsale.balanceOf(this);\r\n        totalSupplyFromInventory = _alreadyTransferredTokens;\r\n        totalRemainInInventory = balance.Add(_alreadyTransferredTokens).Sub(_alreadyTransferredTokens);\r\n        StateChanged(true);\r\n    }\r\n    \r\n    function releaseTokens () public onlyOwner {\r\n        require(startBlock > 0);\r\n        if(initialReleaseDone == 0){\r\n            require(now >= startBlock.Add(1 years));\r\n            unlockedTokens =  balance/2;\r\n            initialReleaseDone = 1;\r\n        }\r\n        else if(secondReleaseDone == 0){\r\n            require(now >= startBlock.Add(2 years));\r\n            unlockedTokens = balance;\r\n            secondReleaseDone = 1;\r\n        }\r\n        StateChanged(true);\r\n    }\r\n    \r\n    /*\r\n    * To enable transferring tokens from company inventory\r\n    */\r\n    function TransferFromCompanyInventory(address beneficiary,uint256 iacToCredit,bytes32 comment) onlyOwner external {\r\n        require(beneficiary != address(0));\r\n        require(totalSuppliedAfterLock.Add(iacToCredit) <= unlockedTokens);\r\n        objCrowdsale.transfer(beneficiary,iacToCredit);\r\n        //Update total supply for IAC Token\r\n        totalSuppliedAfterLock = totalSuppliedAfterLock.Add(iacToCredit);\r\n        totalSupplyFromInventory = totalSupplyFromInventory.Add(iacToCredit);\r\n        //total number of tokens remaining in inventory\r\n        totalRemainInInventory = totalRemainInInventory.Sub(iacToCredit);\r\n        // send event for transferring IAC Token on offline payment\r\n        TransferredUnlockedTokens(beneficiary, iacToCredit, comment);\r\n        //Emit event when crowdsale state changes\r\n        StateChanged(true);\r\n    }\r\n}\r\n\r\ncontract Crowdsale is Injii, Pausable {\r\n    using SafeMath for uint256;\r\n    //Record the timestamp when sale starts\r\n    uint256 public startBlock;\r\n    //No of days for which the complete crowdsale will run\r\n    uint256 public constant durationCrowdSale = 25 days;\r\n    //the gap period between ending of primary crowdsale and starting of secondary crowdsale\r\n    uint256 public constant gapInPrimaryCrowdsaleAndSecondaryCrowdsale = 2 years;\r\n    //Record the timestamp when sale ends\r\n    uint256 public endBlock;\r\n\r\n    //maximum number of tokens available in company inventory\r\n    uint256 public constant maxCapCompanyInventory = 250e6;\r\n    //Maximum number of tokens in crowdsale = 500M tokens\r\n    uint256 public constant maxCap = 500e6;\r\n    uint256 public constant maxCapEcosystem = 250e6;\r\n    uint256 public constant numberOfTokensToAvail50PercentDiscount = 2e6;\r\n    uint256 public constant numberOfTokensToAvail25percentDiscount = 5e5;\r\n    uint256 public constant minimumNumberOfTokens = 2500;\r\n    uint256 public targetToAchieve;\r\n\r\n    bool public inventoryLocked = false;\r\n    uint256 public totalSupply;\r\n    //Total tokens for crowdsale including mint and transfer \r\n    uint256 public totalSupplyForCrowdsaleAndMint = 0;\r\n    //coinbase account where all ethers should go\r\n    address public coinbase;\r\n    //To store total number of ETH received\r\n    uint256 public ETHReceived;\r\n    //total number of tokens supplied from company inventory\r\n    uint256 public totalSupplyFromInventory;\r\n    //total number of tokens available in inventory\r\n    uint256 public totalRemainInInventory;\r\n    //number of tokens per ether\r\n    uint256 public getPrice;\r\n    // To indicate Sale status\r\n    //crowdsaleStatus=0 => crowdsale not started\r\n    //crowdsaleStatus=1 => crowdsale started;\r\n    //crowdsaleStatus=2 => crowdsale finished\r\n    uint256 public crowdsaleStatus;\r\n    //type of CrowdSale:\r\n    //1 = crowdsale\r\n    //2 = seconadry crowdsale for remaining tokens\r\n    uint8 public crowdSaleType;\r\n    //Emit event on receiving ETH\r\n    event ReceivedETH(address addr, uint value);\r\n    //Emit event on transferring IAC Token to user when payment is received in traditional ways\r\n    event MintAndTransferIAC(address addr, uint value, bytes32 comment);\r\n    //Emit event when tokens are transferred from company inventory\r\n    event SuccessfullyTransferedFromCompanyInventory(address addr, uint value, bytes32 comment);\r\n    //event to log token supplied\r\n    event TokenSupplied(address indexed beneficiary, uint256 indexed tokens, uint256 value);\r\n    //Emit event when any change happens in crowdsale state\r\n    event StateChanged(bool changed);\r\n\r\n    //variable to store object of Metadata contract\r\n    Metadata private objMetada;\r\n    Ecosystem private objEcosystem;\r\n    CompanyInventory private objCompanyInventory;\r\n    address private ecosystemContractAddress;\r\n    //ID of Ecosystem contract\r\n    uint256 constant ecosystemContractID = 1;\r\n    //ID of this contract\r\n    uint256 constant private crowdsaleContractID = 2;\r\n    //ID of company inventory\r\n    uint256 constant private inventoryContractID = 3;\r\n\r\n    /**\r\n     * @dev Constuctor of the contract\r\n     *\r\n     */\r\n    function Crowdsale() public {\r\n        address _metadataContractAddr = 0x8A8473E51D7f562ea773A019d7351A96c419B633;\r\n        startBlock = 0;\r\n        endBlock = 0;\r\n        crowdSaleType = 1;\r\n        totalSupply = maxCapEcosystem;\r\n        crowdsaleStatus=0;\r\n        coinbase = 0xA84196972d6b5796cE523f861CC9E367F739421F;\r\n        owner = msg.sender;\r\n        totalSupplyFromInventory=0;\r\n        totalRemainInInventory = maxCapCompanyInventory;\r\n        getPrice = 2778;\r\n        objMetada = Metadata(_metadataContractAddr);\r\n        ecosystemContractAddress = objMetada.getAddress(ecosystemContractID);\r\n        assert(ecosystemContractAddress != address(0));\r\n        objEcosystem = Ecosystem(ecosystemContractAddress);\r\n        objMetada.addAddress(crowdsaleContractID, this);\r\n        balances[ecosystemContractAddress] = maxCapEcosystem;\r\n        targetToAchieve = (50000*100e18)/(12*getPrice);\r\n    }\r\n\r\n    //Verify if the sender is owner\r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }\r\n\r\n    //Modifier to make sure transaction is happening during sale when it is not stopped\r\n    modifier respectTimeFrame() {\r\n      // When contract is deployed, startblock is 0. When sale is started, startBlock should not be zero\r\n      assert(startBlock != 0 && !stopped && crowdsaleStatus == 1);\r\n      //check if requirest is made after time is up\r\n      if(now > endBlock){\r\n          //tokens cannot be bought after time is up\r\n          revert();\r\n      }\r\n      _;\r\n    }\r\n\r\n    /**\r\n     * @dev To upgrade ecosystem contract\r\n     *\r\n     */\r\n    function SetEcosystemContract () public onlyOwner {\r\n        uint256 balanceOfOldEcosystem = balances[ecosystemContractAddress];\r\n        balances[ecosystemContractAddress] = 0;\r\n        //find new address of contract from metadata\r\n        ecosystemContractAddress = objMetada.getAddress(ecosystemContractID);\r\n        //update the balance of new contract\r\n        balances[ecosystemContractAddress] = balanceOfOldEcosystem;\r\n        assert(ecosystemContractAddress != address(0));\r\n        objEcosystem = Ecosystem(ecosystemContractAddress);\r\n    }\r\n\r\n    function GetIACFundAccount() internal view returns (address) {\r\n        uint remainder = block.number%10;\r\n        if(remainder==0){\r\n            return 0x8786DB52D292551f4139a963F79Ce1018d909655;\r\n        } else if(remainder==1){\r\n            return 0x11818E22CDc0592F69a22b30CF0182888f315FBC;\r\n        } else if(remainder==2){\r\n            return 0x17616b652C3c2eAf2aa82a72Bd2b3cFf40A854fE;\r\n        } else if(remainder==3){\r\n            return 0xD433632CA5cAFDa27655b8E536E5c6335343d408;\r\n        } else if(remainder==4){\r\n            return 0xb0Dc59A8312D901C250f8975E4d99eAB74D79484;\r\n        } else if(remainder==5){\r\n            return 0x0e6B1F7955EF525C2707799963318c49f9Ad7374;\r\n        } else if(remainder==6){\r\n            return 0x2fE6C4D2DC0EB71d2ac885F64f029CE78b9F98d9;\r\n        } else if(remainder==7){\r\n            return 0x0a7cD1cCc55191F8046D1023340bdfdfa475F267;\r\n        } else if(remainder==8){\r\n            return 0x76C40fDFd3284da796851611e7e9e8De0CcA546C;\r\n        }else {\r\n            return 0xe4FE5295772997272914447549D570882423A227;\r\n        }\r\n  }\r\n    /*\r\n    * To start Crowdsale\r\n    */\r\n    function startSale() public onlyOwner {\r\n        assert(startBlock == 0);\r\n        //record timestamp when sale is started\r\n        startBlock = now;\r\n        //change the type of sale to crowdsale\r\n        crowdSaleType = 1;\r\n        //Change status of crowdsale to running\r\n        crowdsaleStatus = 1;\r\n        //Crowdsale should end after its proper duration when started\r\n        endBlock = now.Add(durationCrowdSale);\r\n        //Emit event when crowdsale state changes\r\n        StateChanged(true);\r\n    }\r\n\r\n    /*\r\n    * To start crowdsale after 2 years(gapInPrimaryCrowdsaleAndSecondaryCrowdsale)\r\n    */\r\n    function startSecondaryCrowdsale (uint256 durationSecondaryCrowdSale) public onlyOwner {\r\n      //crowdsale should have been stopped\r\n      //startBlock should have a value. It show that sale was started at some point of time\r\n      //endBlock > the duration of crowdsale: this ensures endblock was updated by finalize\r\n      assert(crowdsaleStatus == 2 && crowdSaleType == 1);\r\n      if(now > endBlock.Add(gapInPrimaryCrowdsaleAndSecondaryCrowdsale)){\r\n          //crowdsale status set to \"running\"\r\n          crowdsaleStatus = 1;\r\n          //change the type of CrowdSale\r\n          crowdSaleType = 2;\r\n          //Duration is received in days\r\n          endBlock = now.Add(durationSecondaryCrowdSale * 86400);\r\n          //Emit event when crowdsale state changes\r\n          StateChanged(true);\r\n      }\r\n      else\r\n        revert();\r\n    }\r\n    \r\n\r\n    /*\r\n    * To set price for IAC Token per ether\r\n    */\r\n    function setPrice(uint _tokensPerEther) public onlyOwner\r\n    {\r\n        require( _tokensPerEther != 0);\r\n        getPrice = _tokensPerEther;\r\n        targetToAchieve = (50000*100e18)/(12*_tokensPerEther);\r\n        //Emit event when crowdsale state changes\r\n        StateChanged(true);\r\n    }\r\n\r\n    /*\r\n    * To create and assign IAC Tokens to transaction initiator\r\n    */\r\n    function createTokens(address beneficiary) internal stopInEmergency  respectTimeFrame {\r\n        //Make sure sent Eth is not 0\r\n        require(msg.value != 0);\r\n        //Initially count without giving discount\r\n        uint256 iacToSend = (msg.value.Mul(getPrice))/1e18;\r\n        //calculate price to avail 50% discount\r\n        uint256 priceToAvail50PercentDiscount = numberOfTokensToAvail50PercentDiscount.Div(2*getPrice).Mul(1e18);\r\n        //calculate price of tokens at 25% discount\r\n        uint256 priceToAvail25PercentDiscount = 3*numberOfTokensToAvail25percentDiscount.Div(4*getPrice).Mul(1e18);\r\n        //Check if less than minimum number of tokens are bought\r\n        if(iacToSend < minimumNumberOfTokens){\r\n            revert();\r\n        }\r\n        else if(msg.value >= priceToAvail25PercentDiscount && msg.value < priceToAvail50PercentDiscount){\r\n            //grant tokens according to 25% discount\r\n            iacToSend = (((msg.value.Mul(getPrice)).Mul(4)).Div(3))/1e18;\r\n        }\r\n        //check if user is eligible for 50% discount\r\n        else if(msg.value >= priceToAvail50PercentDiscount){\r\n            //here tokens are given at 50% discount\r\n            iacToSend = (msg.value.Mul(2*getPrice))/1e18;\r\n        }\r\n        //default case: no discount\r\n        else {\r\n            iacToSend = (msg.value.Mul(getPrice))/1e18;\r\n        }\r\n        //we should not be supplying more tokens than maxCap\r\n        assert(iacToSend.Add(totalSupplyForCrowdsaleAndMint) <= maxCap);\r\n        //increase totalSupply\r\n        totalSupply = totalSupply.Add(iacToSend);\r\n\r\n        totalSupplyForCrowdsaleAndMint = totalSupplyForCrowdsaleAndMint.Add(iacToSend);\r\n\r\n        if(ETHReceived < targetToAchieve){\r\n            //transfer ether to coinbase account\r\n            coinbase.transfer(msg.value);\r\n        }\r\n        else{\r\n            GetIACFundAccount().transfer(msg.value);\r\n        }\r\n\r\n        //store ETHReceived\r\n        ETHReceived = ETHReceived.Add(msg.value);\r\n        //Emit event for contribution\r\n        ReceivedETH(beneficiary,ETHReceived);\r\n        balances[beneficiary] = balances[beneficiary].Add(iacToSend);\r\n\r\n        TokenSupplied(beneficiary, iacToSend, msg.value);\r\n        //Emit event when crowdsale state changes\r\n        StateChanged(true);\r\n    }\r\n\r\n    /*\r\n    * To enable owner to mint tokens\r\n    */\r\n    function MintAndTransferToken(address beneficiary,uint256 iacToCredit,bytes32 comment) external onlyOwner {\r\n        //Available after the crowdsale is started\r\n        assert(crowdsaleStatus == 1 && beneficiary != address(0));\r\n        //number of tokens to mint should be whole number\r\n        require(iacToCredit >= 1);\r\n        //Check whether tokens are available or not\r\n        assert(totalSupplyForCrowdsaleAndMint <= maxCap);\r\n        //Check whether the amount of token are available to transfer\r\n        require(totalSupplyForCrowdsaleAndMint.Add(iacToCredit) <= maxCap);\r\n        //Update IAC Token balance for beneficiary\r\n        balances[beneficiary] = balances[beneficiary].Add(iacToCredit);\r\n        //Update total supply for IAC Token\r\n        totalSupply = totalSupply.Add(iacToCredit);\r\n        totalSupplyForCrowdsaleAndMint = totalSupplyForCrowdsaleAndMint.Add(iacToCredit);\r\n        // send event for transferring IAC Token on offline payment\r\n        MintAndTransferIAC(beneficiary, iacToCredit, comment);\r\n        //Emit event when crowdsale state changes\r\n        StateChanged(true);\r\n    }\r\n\r\n    /*\r\n    * To enable transferring tokens from company inventory\r\n    */\r\n    function TransferFromCompanyInventory(address beneficiary,uint256 iacToCredit,bytes32 comment) external onlyOwner {\r\n        //Available after the crowdsale is started\r\n        assert(startBlock != 0 && beneficiary != address(0));\r\n        //Check whether tokens are available or not\r\n        assert(totalSupplyFromInventory <= maxCapCompanyInventory && !inventoryLocked);\r\n        //number of tokens to transfer should be whole number\r\n        require(iacToCredit >= 1);\r\n        //Check whether the amount of token are available to transfer\r\n        require(totalSupplyFromInventory.Add(iacToCredit) <= maxCapCompanyInventory);\r\n        //Update IAC Token balance for beneficiary\r\n        balances[beneficiary] = balances[beneficiary].Add(iacToCredit);\r\n        //Update total supply for IAC Token\r\n        totalSupplyFromInventory = totalSupplyFromInventory.Add(iacToCredit);\r\n        //Update total supply for IAC Token\r\n        totalSupply = totalSupply.Add(iacToCredit);\r\n        //total number of tokens remaining in inventory\r\n        totalRemainInInventory = totalRemainInInventory.Sub(iacToCredit);\r\n        //send event for transferring IAC Token on offline payment\r\n        SuccessfullyTransferedFromCompanyInventory(beneficiary, iacToCredit, comment);\r\n        //Emit event when crowdsale state changes\r\n        StateChanged(true);\r\n    }\r\n\r\n    function LockInventory () public onlyOwner {\r\n        require(startBlock > 0 && now >= startBlock.Add(durationCrowdSale.Add(90 days)) && !inventoryLocked);\r\n        address inventoryContractAddress = objMetada.getAddress(inventoryContractID);\r\n        require(inventoryContractAddress != address(0));\r\n        balances[inventoryContractAddress] = totalRemainInInventory;\r\n        totalSupply = totalSupply.Add(totalRemainInInventory);\r\n        objCompanyInventory = CompanyInventory(inventoryContractAddress);\r\n        objCompanyInventory.initiateLocking(totalSupplyFromInventory);\r\n        inventoryLocked = true;\r\n    }\r\n\r\n    /*\r\n    * Finalize the crowdsale\r\n    */\r\n    function finalize() public onlyOwner {\r\n          //Make sure Sale is running\r\n          //finalize should be called only if crowdsale is running\r\n          assert(crowdsaleStatus == 1 && (crowdSaleType == 1 || crowdSaleType == 2));\r\n          //finalize only if less than minimum number of tokens are left or if time is up\r\n          assert(maxCap.Sub(totalSupplyForCrowdsaleAndMint) < minimumNumberOfTokens || now >= endBlock);\r\n          //crowdsale is ended\r\n          crowdsaleStatus = 2;\r\n          //update endBlock to the actual ending of crowdsale\r\n          endBlock = now;\r\n          //Emit event when crowdsale state changes\r\n          StateChanged(true);\r\n    }\r\n\r\n    /*\r\n    * To enable transfers of IAC Token anytime owner wishes\r\n    */\r\n    function unlock() public onlyOwner\r\n    {\r\n        //unlock will happen after 90 days of ending of crowdsale\r\n        //crowdsale itself being of 25 days\r\n        assert(crowdsaleStatus==2 && now >= startBlock.Add(durationCrowdSale.Add(90 days)));\r\n        locked = false;\r\n        //Emit event when crowdsale state changes\r\n        StateChanged(true);\r\n    }\r\n\r\n    /**\r\n     * @dev payable function to accept ether.\r\n     *\r\n     */\r\n    function () public payable {\r\n        createTokens(msg.sender);\r\n    }\r\n\r\n   /*\r\n    * Failsafe drain\r\n    */\r\n   function drain() public  onlyOwner {\r\n        GetIACFundAccount().transfer(this.balance);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"iacToCredit\",\"type\":\"uint256\"},{\"name\":\"comment\",\"type\":\"bytes32\"}],\"name\":\"TransferFromCompanyInventory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfTokensToAvail25percentDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inventoryLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"SetEcosystemContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCapCompanyInventory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfTokensToAvail50PercentDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCapEcosystem\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyForCrowdsaleAndMint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gapInPrimaryCrowdsaleAndSecondaryCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"durationSecondaryCrowdSale\",\"type\":\"uint256\"}],\"name\":\"startSecondaryCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensPerEther\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinbase\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetToAchieve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumNumberOfTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRemainInInventory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"LockInventory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"iacToCredit\",\"type\":\"uint256\"},{\"name\":\"comment\",\"type\":\"bytes32\"}],\"name\":\"MintAndTransferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyFromInventory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"durationCrowdSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"bytes32\"}],\"name\":\"MintAndTransferIAC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"bytes32\"}],\"name\":\"SuccessfullyTransferedFromCompanyInventory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenSupplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"changed\",\"type\":\"bool\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5bd3754ae3ff16b7536e1381399e0e49fe03c015f60784c45e26633d848c810f"}]}