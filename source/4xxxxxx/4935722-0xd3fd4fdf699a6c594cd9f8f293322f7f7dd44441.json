{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n/*standart library for uint\r\n*/\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0){\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/*\r\ncontract to identify owner\r\n*/\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  address public newOwner;\r\n\r\n  address public techSupport;\r\n\r\n  address public newTechSupport;\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyTechSupport() {\r\n    require(msg.sender == techSupport);\r\n    _;\r\n  }\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));\r\n    newOwner = _newOwner;\r\n  }\r\n\r\n  function acceptOwnership() public {\r\n    if (msg.sender == newOwner) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n  function transferTechSupport (address _newSupport) public{\r\n    require (msg.sender == owner || msg.sender == techSupport);\r\n    newTechSupport = _newSupport;\r\n  }\r\n\r\n  function acceptSupport() public{\r\n    if(msg.sender == newTechSupport){\r\n      techSupport = newTechSupport;\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\nERC - 20 token contract\r\n*/\r\ncontract VGCToken {\r\n  function setCrowdsaleContract (address _address) public {}\r\n  function burnTokens(address _address) public{}\r\n  function getCrowdsaleBalance() public view returns(uint) {}\r\n  function getRefBalSended () public view returns(bool){}\r\n  function sendCrowdsaleBalance (address _address, uint _value) public {}\r\n  function finishIco() public{}\r\n}\r\n\r\n//Crowdsale contract\r\ncontract Crowdsale is Ownable{\r\n\r\n  using SafeMath for uint;\r\n  //power function\r\n  function pow(uint256 a, uint256 b) internal pure returns (uint256){\r\n   return (a**b);\r\n  }\r\n\r\n  uint decimals = 2;\r\n  // Token contract address\r\n  VGCToken public token;\r\n\r\n  struct Ico{\r\n    uint bonus;\r\n    uint balance;\r\n  }\r\n  // Constructor\r\n  function Crowdsale(address _tokenAddress, address _addressOwner) public{\r\n    token = VGCToken(_tokenAddress);\r\n    owner = _addressOwner;\r\n    structurePreIco.push(Ico(55555555555,1000000*pow(10,decimals))); //80% bonus\r\n    structurePreIco.push(Ico(58823529411,1000000*pow(10,decimals))); //70\r\n    structurePreIco.push(Ico(62500000000,1000000*pow(10,decimals))); //60\r\n    structurePreIco.push(Ico(66666666666,1000000*pow(10,decimals))); //50\r\n    structurePreIco.push(Ico(71428571428,1000000*pow(10,decimals))); //40\r\n    structurePreIco.push(Ico(76923076923,1000000*pow(10,decimals))); //30\r\n\r\n\r\n    structureIco.push(Ico(83333333333,10000000*pow(10,decimals))); //20\r\n    structureIco.push(Ico(90909090909,10000000*pow(10,decimals))); //10\r\n    structureIco.push(Ico(100000000000,10000000*pow(10,decimals))); //0\r\n\r\n    techSupport = msg.sender;\r\n    token.setCrowdsaleContract(this);\r\n  }\r\n  //ICO structures (technical decision)\r\n  Ico[] public structurePreIco;\r\n  Ico[] public structureIco;\r\n    // Buy constants\r\n  uint public tokenPrice = 2000000000000000 / pow(10,decimals);\r\n  uint minDeposit = 100000000000000000; //0.1 ETH\r\n\r\n    // preIco constants\r\n  uint public preIcoStart = 1516320000; // 01/19/2018\r\n  uint public preIcoFinish = 1521590400; // 03/21/2018\r\n\r\n    // Ico constants\r\n  uint public icoStart = 1521590401; // 03/21/2018\r\n  uint public icoFinish = 1529625600; //06/21/2018\r\n  uint icoMinCap = 300000*pow(10,decimals);\r\n\r\n  //check is now preICO\r\n  function isPreIco(uint _time) constant public returns (bool){\r\n    if((preIcoStart <= _time) && (_time <= preIcoFinish)){\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //check is now ICO\r\n  function isIco(uint _time) constant public returns (bool){\r\n    if((icoStart <= _time) && (_time <= icoFinish)){\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //crowdsale variables\r\n  uint public preIcoTokensSold = 0;\r\n  uint public iCoTokensSold = 0;\r\n  uint public tokensSold = 0;\r\n  uint public ethCollected = 0;\r\n\r\n  //Ethereum investor balances (how much Eth they're donate to ICO)\r\n  mapping (address => uint) public investorBalances;\r\n\r\n  //function calculate how many tokens will be send to investor in preIco\r\n  function  buyIfPreIcoDiscount (uint _value) internal returns(uint,uint) {\r\n    uint buffer = 0;\r\n    uint bufferEth = 0;\r\n    uint bufferValue = _value;\r\n    uint res = 0;\r\n\r\n    for (uint i = 0; i<structurePreIco.length; i++){\r\n      res = _value/(tokenPrice*structurePreIco[i].bonus/100000000000);\r\n\r\n      //Purchase over 5,000 VGC and get extra 10% bonus\r\n      if(res >= (uint)(5000).mul(pow(10,decimals))){\r\n        res = res.add(res/10);\r\n      }\r\n      if (res<=structurePreIco[i].balance){\r\n        //   bufferEth = bufferEth+_value;\r\n        structurePreIco[i].balance = structurePreIco[i].balance.sub(res);\r\n        buffer = res.add(buffer);\r\n        return (buffer,0);\r\n      }else {\r\n        buffer = buffer.add(structurePreIco[i].balance);\r\n        //   bufferEth = bufferEth.add(structurePreIco[i].balance.mul(tokenPrice)/structurePreIco[i].bonus);\r\n        bufferEth += structurePreIco[i].balance*tokenPrice*structurePreIco[i].bonus/100000000000;\r\n        _value = _value.sub(structurePreIco[i].balance*tokenPrice*structurePreIco[i].bonus/100000000000);\r\n        structurePreIco[i].balance = 0;\r\n        }\r\n      }\r\n    return  (buffer,bufferValue.sub(bufferEth));\r\n  }\r\n\r\n  //function calculate how many tokens will be send to investor in Ico\r\n  function  buyIfIcoDiscount (uint _value) internal returns(uint,uint) {\r\n    uint buffer = 0;\r\n    uint bufferEth = 0;\r\n    uint bufferValue = _value;\r\n    uint res = 0;\r\n\r\n    for (uint i = 0; i<structureIco.length; i++){\r\n      res = _value/(tokenPrice*structureIco[i].bonus/100000000000);\r\n\r\n      //Purchase over 5,000 VGC and get extra 10% bonus\r\n      if(res >= (uint)(5000).mul(pow(10,decimals))){\r\n        res = res.add(res/10);\r\n      }\r\n        if (res<=structureIco[i].balance){\r\n          bufferEth = bufferEth+_value;\r\n          structureIco[i].balance = structureIco[i].balance.sub(res);\r\n          buffer = res.add(buffer);\r\n          return (buffer,0);\r\n        }else {\r\n          buffer = buffer.add(structureIco[i].balance);\r\n          bufferEth += structureIco[i].balance*tokenPrice*structureIco[i].bonus/100000000000;\r\n          _value = _value.sub(structureIco[i].balance*tokenPrice*structureIco[i].bonus/100000000000);\r\n          structureIco[i].balance = 0;\r\n      }\r\n    }\r\n    return  (buffer,bufferValue.sub(bufferEth));\r\n  }\r\n\r\n  //fallback function (when investor send ether to contract)\r\n  function() public payable{\r\n    require(msg.value >= minDeposit);\r\n    require(isIco(now) || isPreIco(now));\r\n    require(buy(msg.sender,msg.value,now,false)); //redirect to func buy\r\n  }\r\n\r\n  bool public preIcoEnded = false;\r\n  //function buy Tokens\r\n  function buy(address _address, uint _value, uint _time, bool dashboard) internal returns (bool){\r\n    uint tokensForSend;\r\n    uint etherForSend;\r\n    if (isPreIco(_time)){\r\n      (tokensForSend,etherForSend) = buyIfPreIcoDiscount(_value);\r\n      assert (tokensForSend >= 50*pow(10,decimals));\r\n      preIcoTokensSold += tokensForSend;\r\n      if (etherForSend!=0 && !dashboard){\r\n        _address.transfer(etherForSend);\r\n      }\r\n      owner.transfer(this.balance);\r\n    }\r\n    if (isIco(_time)){\r\n      if(!preIcoEnded){\r\n        for (uint i = 0; i<structurePreIco.length; i++){\r\n          structureIco[structureIco.length-1].balance = structureIco[structureIco.length-1].balance.add(structurePreIco[i].balance);\r\n          structurePreIco[i].balance = 0;\r\n        }\r\n       preIcoEnded = true;\r\n      }\r\n      (tokensForSend,etherForSend) = buyIfIcoDiscount(_value);\r\n      assert (tokensForSend >= 50*pow(10,decimals));\r\n      iCoTokensSold += tokensForSend;\r\n\r\n      if (etherForSend!=0 && !dashboard){\r\n        _address.transfer(etherForSend);\r\n      }\r\n      investorBalances[_address] += _value.sub(etherForSend);\r\n\r\n      if (isIcoTrue()){\r\n        owner.transfer(this.balance);\r\n      }\r\n    }\r\n\r\n    tokensSold += tokensForSend;\r\n\r\n    token.sendCrowdsaleBalance(_address,tokensForSend);\r\n\r\n    ethCollected = ethCollected.add(_value.sub(etherForSend));\r\n\r\n    return true;\r\n  }\r\n\r\n  //someone can end ICO using this function (require 3 days after ICO end)\r\n  function finishIco() public {\r\n    require (now > icoFinish + 3 days);\r\n    require (token.getRefBalSended());\r\n    for (uint i = 0; i<structureIco.length; i++){\r\n      structureIco[i].balance = 0;\r\n    }\r\n    for (i = 0; i<structurePreIco.length; i++){\r\n      structurePreIco[i].balance = 0;\r\n    }\r\n    token.finishIco();\r\n  }\r\n\r\n  //function check is ICO complete (minCap exceeded)\r\n  function isIcoTrue() public constant returns (bool){\r\n    if (tokensSold >= icoMinCap){\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //if ICO failed and now = ICO finished date +3 days then investor can withdrow his ether\r\n  function refund() public{\r\n    require (!isIcoTrue());\r\n    require (icoFinish + 3 days <= now);\r\n\r\n    token.burnTokens(msg.sender);\r\n    msg.sender.transfer(investorBalances[msg.sender]);\r\n    investorBalances[msg.sender] = 0;\r\n  }\r\n\r\n\r\n  //ICO cabinets function\r\n  function sendEtherManually(address _address, uint _value) public onlyTechSupport{\r\n    require(buy(_address,_value,now,true));\r\n  }\r\n\r\n  //ICO cabinets function, just for view\r\n  function tokensCount(uint _value) public view onlyTechSupport returns(uint res) {\r\n    if (isPreIco(now)){\r\n      (res,) = buyIfPreIcoDiscount(_value);\r\n    }\r\n    if (isIco(now)){\r\n      (res,) = buyIfIcoDiscount(_value);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function getEtherBalanceOnCrowdsale() public view returns(uint) {\r\n    return this.balance;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"structurePreIco\",\"outputs\":[{\"name\":\"bonus\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"tokensCount\",\"outputs\":[{\"name\":\"res\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"isIco\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preIcoEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSupport\",\"type\":\"address\"}],\"name\":\"transferTechSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preIcoStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIcoTrue\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEtherBalanceOnCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"isPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preIcoTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"structureIco\",\"outputs\":[{\"name\":\"bonus\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sendEtherManually\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"iCoTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preIcoFinish\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoFinish\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"techSupport\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newTechSupport\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_addressOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e750bbc8d86b7c88f9a6fda0eb8dad4bdbf48e2200000000000000000000000027dcd36ecb0615c9407ffb79892076cd1b6d8930","Library":"","SwarmSource":"bzzr://1d5d8e63c622a6093465cd94b741173a10da2d12709ca353af2183e34a52bf1c"}]}