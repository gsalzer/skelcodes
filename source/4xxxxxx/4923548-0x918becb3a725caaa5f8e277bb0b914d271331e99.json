{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\ncontract owned {\r\n    address public owner;\r\n    address private ownerCandidate;\r\n\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerCandidate() {\r\n        assert(msg.sender == ownerCandidate);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address candidate) external onlyOwner {\r\n        ownerCandidate = candidate;\r\n    }\r\n\r\n    function acceptOwnership() external onlyOwnerCandidate {\r\n        owner = ownerCandidate;\r\n    }\r\n}\r\n\r\n\r\ncontract Random {\r\n    uint64 _seed = 0;\r\n\r\n\r\n    function random(uint64 upper) public returns (uint64 randomNumber) {\r\n        _seed = uint64(keccak256(keccak256(block.blockhash(block.number), _seed), now));\r\n        return _seed % upper;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) pure internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) pure internal returns (uint) {\r\n        uint c = a / b;\r\n        assert(b == 0);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) pure internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Token is SafeMath, owned {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals = 8;\r\n\r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => uint) limitAddress;\r\n\r\n    uint public totalSupply = 1 * 10000 * 10000 * 10 ** uint256(decimals);\r\n\r\n    modifier validAddress(address _address) {\r\n        assert(0x0 != _address);\r\n        _;\r\n    }\r\n\r\n    function addLimitAddress(address _a)\r\n        public\r\n        validAddress(_a)\r\n        onlyOwner\r\n    {\r\n        limitAddress[_a] = 1;\r\n    }\r\n\r\n    function delLitAddress(address _a)\r\n        public\r\n        validAddress(_a)\r\n        onlyOwner\r\n    {\r\n        limitAddress[_a] = 0;\r\n    }\r\n\r\n    function Token(string _name, string _symbol)\r\n        public\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        owner = msg.sender;\r\n        balanceOf[this] = totalSupply;\r\n        Transfer(0x0, this, totalSupply);\r\n    }\r\n\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function batchtransfer(address[] _to, uint256[] _amount) public returns(bool success) {\r\n        for(uint i = 0; i < _to.length; i++){\r\n            require(transfer(_to[i], _amount[i]));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferInner(address _to, uint _value)\r\n        private\r\n        returns (bool success)\r\n    {\r\n        balanceOf[this] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(this, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        require(allowance[_from][msg.sender] >= _value);\r\n        balanceOf[_to] += _value;\r\n        balanceOf[_from] -= _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool success)\r\n    {\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function ()\r\n        public\r\n        payable\r\n    {\r\n\r\n    }\r\n\r\n    function mint(address _to, uint _amount) public validAddress(_to)\r\n    {\r\n\r\n        if(limitAddress[msg.sender] != 1) return;\r\n\r\n        uint supply = _amount;\r\n\r\n        if(balanceOf[this] < supply) {\r\n            supply = balanceOf[this];\r\n        }\r\n        require(transferInner(_to, supply));\r\n        \r\n        Mint(_to, supply);\r\n    }\r\n\r\n    function withdraw(uint amount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(this.balance >= amount);\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    event Mint(address _to, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n\r\ncontract GameOne is SafeMath, Random, owned {\r\n\r\n    uint256 public createTime = 0;\r\n\r\n\r\n    uint public gameState = 0;\r\n    uint private constant GAME_RUNNING = 0;\r\n    uint private constant GAME_FINISHED = 2;\r\n    uint public gameCount = 0;\r\n\r\n\r\n    uint public minEth = 0.1 ether;\r\n    uint public maxEth = 100 ether;\r\n\r\n    uint public cut = 10;\r\n    uint public ethQuantity = 0;\r\n\r\n    address public opponent = 0x0;\r\n    uint public opponentAmount = 0;\r\n\r\n    Token public tokenContract;\r\n\r\n    event Bet(address a, uint av, address b, uint bv, uint apercent, uint rand, address winner, uint _now);\r\n\r\n    modifier validAddress(address _address) {\r\n        assert(0x0 != _address);\r\n        _;\r\n    }\r\n\r\n    modifier isOwner {\r\n        assert(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier validEth {\r\n        assert(msg.value >= minEth && msg.value <= maxEth);\r\n        _;\r\n    }\r\n\r\n    modifier validState {\r\n        assert(gameState == GAME_RUNNING);\r\n        _;\r\n    }\r\n\r\n    function GameOne(address _tokenContract) public validAddress(_tokenContract) {\r\n        tokenContract = Token(_tokenContract);\r\n        createTime = now;\r\n    }\r\n\r\n    \r\n    function () public payable {\r\n        bet();\r\n    }\r\n\r\n    function setCut(uint newCut) public isOwner {\r\n        assert(newCut > 0 && newCut <= 20);\r\n        cut = newCut;\r\n    }\r\n\r\n    function setMinEth(uint newMinEth) public isOwner {\r\n        assert(newMinEth >= 0.01 ether);\r\n        minEth = newMinEth;\r\n    }\r\n\r\n    function setMaxEth(uint newMaxEth) public isOwner {\r\n        assert(newMaxEth >= 0.1 ether);\r\n        maxEth = newMaxEth;\r\n    }\r\n\r\n    function setTokenAddress(address _addr) public isOwner {\r\n        tokenContract = Token(_addr);\r\n    }\r\n\r\n\r\n    function bet() public payable\r\n        validState\r\n        validEth\r\n    {\r\n        uint eth = msg.value;\r\n        uint bonus = 0;\r\n        uint amount = 0;\r\n        address winner;\r\n        address loser;\r\n        uint loserAmount = 0;\r\n        uint rate;\r\n        uint token = 0;\r\n\r\n\r\n        ethQuantity = safeAdd(ethQuantity, eth);\r\n\r\n        if (opponent== 0x0) {\r\n            opponent = msg.sender;\r\n            opponentAmount = eth;\r\n        } else {\r\n            winner = randomaward(opponent, msg.sender, opponentAmount, eth);\r\n            if(winner == msg.sender) {\r\n                loser = opponent;\r\n                loserAmount = opponentAmount;\r\n                rate = opponentAmount * cut/100;\r\n            }else{\r\n                loser = msg.sender;\r\n                loserAmount = eth;\r\n                rate = eth * cut/100;\r\n            }\r\n\r\n            token = loserAmount * 10000 / 10 ** 10;\r\n            tokenContract.mint(loser, token);\r\n\r\n            gameCount = safeAdd(gameCount, 1);\r\n\r\n            bonus = safeAdd(opponentAmount, eth);\r\n            amount = safeSub(bonus, rate);\r\n            require(transferInner(winner, amount));\r\n            reset();\r\n        }\r\n    }\r\n\r\n    function reset () private {\r\n        opponent = 0x0;\r\n        opponentAmount = 0;\r\n    }\r\n\r\n    function randomaward(address a, address b, uint av, uint bv) private returns (address win) {\r\n        uint bonus = safeAdd(av, bv);\r\n\r\n        uint apercent = av * 10 ** 2 /bonus;\r\n        uint rand = random(100);\r\n        if (rand<=apercent) {\r\n            win = a;\r\n        } else {\r\n            win = b;\r\n        }\r\n        Bet(a, av, b, bv, apercent, rand, win, now);\r\n        return win;\r\n    }\r\n\r\n    function withdraw (uint amount) public isOwner {\r\n        uint  lef = 0;\r\n        if (opponent != 0x0) {\r\n            lef = this.balance - opponentAmount;\r\n        } else {\r\n            lef = this.balance;\r\n        }\r\n        require(lef >= amount);\r\n\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n    function setFinished () public isOwner {\r\n        gameState = GAME_FINISHED;\r\n    }\r\n\r\n    function setRunning () public isOwner {\r\n        gameState = GAME_RUNNING;\r\n    }\r\n\r\n    function transferInner(address _to, uint _value)\r\n        private\r\n        returns (bool success)\r\n    {\r\n        require(this.balance >= _value);\r\n        _to.transfer(_value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"upper\",\"type\":\"uint64\"}],\"name\":\"random\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxEth\",\"type\":\"uint256\"}],\"name\":\"setMaxEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"createTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setFinished\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCut\",\"type\":\"uint256\"}],\"name\":\"setCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinEth\",\"type\":\"uint256\"}],\"name\":\"setMinEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opponent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setRunning\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opponentAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"av\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"b\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bv\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"apercent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rand\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"Bet\",\"type\":\"event\"}]","ContractName":"GameOne","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fcc36b6fde12f6726040ced05f04c256f9456327","Library":"","SwarmSource":"bzzr://9e8b31010b9f318230c40269a6bd9835ca4a864a8c8a0cc7bad248768cae85d7"}]}