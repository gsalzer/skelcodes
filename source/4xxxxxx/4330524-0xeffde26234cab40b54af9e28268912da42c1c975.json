{"status":"1","message":"OK","result":[{"SourceCode":"// This is ERC 2.0 Token's Trading Market, Decentralized Exchange Contract. 这是一个ERC20Token的去中心化交易所合同。\r\n// 支持使用以太币买卖任意满足ERC20标准的Token。其具体使用流程请参见对应文档。\r\n// by he.guanjun, email: he.d.d.shan@hotmail.com\r\n// 2017-09-28 update\r\n// TODO：\r\n//  1,每一个function，都应该写日志（事件），而且最好不要共用事件。暂不处理。\r\n//  2,Token白名单，更安全，但是需要owner维护，更麻烦。暂不处理。\r\n// 强调：在任何时候调用外部合约的function，都要仔细检查外部合约再调用本合约的任意function是否产生异常后果！预防The DAO事件的错误！作为一种编码习惯，所有的调用外部合约function的地方都要标记出来！\r\n// 处理的方式包括：减少先记账，后转钱；增加先转钱，后记账；输入检查；msg.sender,tx.origin检查；锁定；等。暂时采用锁定，可以极大简化测试路径。\r\n\r\n\r\npragma solidity ^0.4.11; \r\n\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface Erc20Token {\r\n      function totalSupply() constant returns (uint256 totalSupply);\r\n      function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n      function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n      function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n      function approve(address _spender, uint256 _value) returns (bool success);\r\n      function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n      event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n      event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n      function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n}\r\n\r\ncontract Base { \r\n    uint createTime = now;\r\n\r\n    address public owner;\r\n    \r\n    function Base() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address _newOwner)  public  onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    mapping (address => uint256) public userEtherOf;   \r\n\r\n    function userRefund() public   {\r\n        //require(msg.sender == tx.origin);     //TODO：\r\n         _userRefund(msg.sender, msg.sender);\r\n    }\r\n\r\n    function userRefundTo(address _to) public   {\r\n        //require(msg.sender == tx.origin);     //TODO：\r\n        _userRefund(msg.sender, _to);\r\n    }\r\n\r\n    function _userRefund(address _from,  address _to) private {\r\n        require (_to != 0x0);  \r\n        lock();\r\n        uint256 amount = userEtherOf[_from];\r\n        if(amount > 0){\r\n            userEtherOf[_from] -= amount;\r\n            _to.transfer(amount);               //防范外部调用，特别是和支付（买Token）联合调用就有风险， 2017-09-27\r\n        }\r\n        unLock();\r\n    }\r\n\r\n    bool public globalLocked = false;      //锁定，全局，外部智能调用一个方法！ 2017-10-02\r\n\r\n    function lock() internal {              //在 lock 和 unLock 之间，最好不要写有 require 之类会抛出异常的语句，而是在 lock 之前全面检查。\r\n        require(!globalLocked);\r\n        globalLocked = true;\r\n    }\r\n\r\n    function unLock() internal {\r\n        require(globalLocked);\r\n        globalLocked = false;\r\n    }    \r\n\r\n    //event OnSetLock(bool indexed _oldGlobalLocked, bool indexed _newGlobalLocked);\r\n\r\n    function setLock()  public onlyOwner{       //sometime, globalLocked always is true???\r\n        //bool _oldGlobalLocked = globalLocked;\r\n        globalLocked = false;     \r\n        //OnSetLock(_oldGlobalLocked, false);   \r\n    }\r\n}\r\n\r\n//执行 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\ncontract  Erc20TokenMarket is Base         //for exchange token\r\n{\r\n    function Erc20TokenMarket()  Base ()  {\r\n    }\r\n\r\n    mapping (address => uint) public badTokenOf;      //Token 黑名单！\r\n\r\n    event OnBadTokenChanged(address indexed _tokenAddress, uint indexed _badNum);\r\n\r\n    function addBadToken(address _tokenAddress) public onlyOwner{\r\n        badTokenOf[_tokenAddress] += 1;\r\n        OnBadTokenChanged(_tokenAddress, badTokenOf[_tokenAddress]);\r\n    }\r\n\r\n    function removeBadToken(address _tokenAddress) public onlyOwner{\r\n        badTokenOf[_tokenAddress] = 0;\r\n        OnBadTokenChanged(_tokenAddress, badTokenOf[_tokenAddress]);\r\n    }\r\n\r\n    function isBadToken(address _tokenAddress) private returns(bool _result) {\r\n        return badTokenOf[_tokenAddress] > 0;        \r\n    }\r\n\r\n    uint256 public sellerGuaranteeEther = 0 ether;      //保证金，最大惩罚金额。\r\n\r\n    function setSellerGuarantee(uint256 _gurateeEther) public onlyOwner {\r\n        require(now - createTime > 1 years);        //至少一年后才启用保证金\r\n        require(_gurateeEther <= 0.1 ether);        //不能太高，表示一下，能够拒绝恶意者就好。\r\n        sellerGuaranteeEther = _gurateeEther;        \r\n    }    \r\n\r\n    function checkSellerGuarantee(address _seller) private returns (bool _result){\r\n        return userEtherOf[_seller] >= sellerGuaranteeEther;            //保证金不强制冻结，如果保证金不足，将无法完成交易（买和卖）。\r\n    }\r\n\r\n    function userRefundWithoutGuaranteeEther() public   {       //退款，但是保留保证金\r\n        lock();\r\n\r\n        if (userEtherOf[msg.sender] > 0 && userEtherOf[msg.sender] >= sellerGuaranteeEther){\r\n            uint256 amount = userEtherOf[msg.sender] - sellerGuaranteeEther;\r\n            userEtherOf[msg.sender] -= amount;\r\n            msg.sender.transfer(amount);            //防范外部调用 2017-09-28\r\n        }\r\n\r\n        unLock();\r\n    }\r\n\r\n    struct SellingToken{                //TokenInfo，包括：当前金额，已卖总金额，出售价格，是否出售，出售时间限制，转入总金额，转入总金额， TODO：\r\n        uint256    thisAmount;          //currentAmount，当前金额，可以出售的金额,转入到 this 地址的金额。\r\n        uint256    soldoutAmount;       //有可能溢出，恶意合同能做到这点，但不影响合约执行，暂不处理。 2017-09-27\r\n        uint256    price;      \r\n        bool       cancel;              //正在出售，是否出售\r\n        uint       lineTime;            //出售时间限制\r\n    }    \r\n\r\n    mapping (address => mapping(address => SellingToken)) public userSellingTokenOf;    //销售者，代币地址，销售信息\r\n\r\n    //event OnReceiveApproval(address indexed _tokenAddress, address _seller, uint indexed _sellingAmount, uint256 indexed _price, uint _lineTime, bool _cancel);\r\n    event OnSetSellingToken(address indexed _tokenAddress, address _seller, uint indexed _sellingAmount, uint256 indexed _price, uint _lineTime, bool _cancel);\r\n    //event OnCancelSellingToken(address indexed _tokenAddress, address _seller, uint indexed _sellingAmount, uint256 indexed _price, uint _lineTime, bool _cancel);\r\n\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\r\n        _extraData;\r\n        _value;\r\n        require(_from != 0x0);\r\n        require(_token != 0x0);\r\n        //require(_value > 0);              //no\r\n        require(_token == msg.sender && msg.sender != tx.origin);   //防范攻击，防止被发送大量的垃圾信息！就算攻击，也要写一个智能合约来攻击！\r\n        require(!isBadToken(msg.sender));                           //黑名单判断，主要防范垃圾信息，\r\n\r\n        lock();\r\n\r\n        Erc20Token token = Erc20Token(msg.sender);\r\n        var sellingAmount = token.allowance(_from, this);   //_from == tx.origin != msg.sender = _token , _from == tx.origin 不一定，但一般如此，多重签名钱包就不是。\r\n\r\n        //var sa = token.balanceOf(_from);        //检查用户实际拥有的Token，但用户拥有的Token随时可能变化，所以还是无法检查，只能在购买的时候检查。\r\n        //if (sa < sellingAmount){\r\n        //    sellingAmount = sa;\r\n        //}\r\n\r\n        //require(sellingAmount > 0);       //no \r\n\r\n        var st = userSellingTokenOf[_from][_token];                 //用户(卖家)地址， Token地址，\r\n        st.thisAmount = sellingAmount;\r\n        //st.price = 0;\r\n        //st.lineTime = 0;\r\n        //st.cancel = true;      \r\n        OnSetSellingToken(_token, _from, sellingAmount, st.price, st.lineTime, st.cancel);\r\n        unLock();\r\n    }\r\n      \r\n    function setSellingToken(address _tokenAddress,  uint256 _price, uint _lineTime) public returns(uint256  _sellingAmount) {\r\n        require(_tokenAddress != 0x0);\r\n        require(_price > 0);\r\n        require(_lineTime > now);\r\n        require(!isBadToken(_tokenAddress));                //黑名单\r\n        require(checkSellerGuarantee(msg.sender));          //保证金，\r\n        lock();\r\n\r\n        Erc20Token token = Erc20Token(_tokenAddress);\r\n        _sellingAmount = token.allowance(msg.sender,this);      //防范外部调用， 2017-09-27\r\n\r\n        //var sa = token.balanceOf(_from);        //检查用户实际拥有的Token\r\n        //if (sa < _sellingAmount){\r\n        //    _sellingAmount = sa;\r\n        //}\r\n\r\n        var st = userSellingTokenOf[msg.sender][_tokenAddress];\r\n        st.thisAmount = _sellingAmount;\r\n        st.price = _price;\r\n        st.lineTime = _lineTime;\r\n        st.cancel = false;\r\n\r\n        OnSetSellingToken(_tokenAddress, msg.sender, _sellingAmount, _price, _lineTime, st.cancel);\r\n        unLock();\r\n    }   \r\n\r\n    function cancelSellingToken(address _tokenAddress)  public{     // returns(bool _result) delete , 2017-09-27\r\n        require(_tokenAddress != 0x0);    \r\n        \r\n        lock();\r\n\r\n        var st = userSellingTokenOf[msg.sender][_tokenAddress];\r\n        st.cancel = true;\r\n        \r\n        Erc20Token token = Erc20Token(_tokenAddress);\r\n        var sellingAmount = token.allowance(msg.sender,this);   //防范外部调用， 2017-09-27\r\n        st.thisAmount = sellingAmount;\r\n        \r\n        OnSetSellingToken(_tokenAddress, msg.sender, sellingAmount, st.price, st.lineTime, st.cancel);\r\n\r\n        unLock();\r\n    }    \r\n\r\n    event OnBuyToken(address _buyer, uint _buyerRamianEtherAmount, address indexed _seller, address indexed _tokenAddress, uint256  _transTokenAmount, uint256 indexed _tokenPrice, uint256 _sellerRamianTokenAmount);\r\n    //event OnBuyToken(address _buyer, address indexed _seller, address indexed _tokenAddress, uint256  _transTokenAmount, uint256 indexed _tokenPrice, uint256 _sellerRamianTokenAmount);\r\n\r\n    function buyTokenFrom(address _seller, address _tokenAddress, uint256 _buyerTokenPrice) public payable returns(bool _result) {   \r\n        require(_seller != 0x0);\r\n        require(_tokenAddress != 0x0);\r\n        require(_buyerTokenPrice > 0);\r\n\r\n        lock();              //加锁  //拒绝二次进入！   //防范外部调用，某些特殊合约可能无法成功执行此方法，但为了安全就这么简单处理。 2017-09-27\r\n        \r\n        _result = false;\r\n\r\n        userEtherOf[msg.sender] += msg.value;\r\n        if (userEtherOf[msg.sender] == 0){\r\n            unLock();\r\n            return; \r\n        }\r\n\r\n        Erc20Token token = Erc20Token(_tokenAddress);\r\n        var sellingAmount = token.allowance(_seller, this);     //卖家， _spender   \r\n        var st = userSellingTokenOf[_seller][_tokenAddress];    //卖家，Token\r\n\r\n        var sa = token.balanceOf(_seller);        //检查用户实际拥有的Token，但用户拥有的Token随时可能变化，只能在购买的时候检查。\r\n        bool bigger = false;\r\n        if (sa < sellingAmount){                  //一种策略，卖家交定金，如果发现出现这种情况，定金没收，owner 和 买家平分定金。\r\n            sellingAmount = sa;\r\n            bigger = true;\r\n        }\r\n\r\n        if (st.price > 0 && st.lineTime > now && sellingAmount > 0 && !st.cancel){\r\n            if(_buyerTokenPrice < st.price){                                                //price maybe be changed!\r\n                OnBuyToken(msg.sender, userEtherOf[msg.sender], _seller, _tokenAddress, 0, st.price, sellingAmount);\r\n                unLock();\r\n                return;\r\n            }\r\n\r\n            uint256 canTokenAmount =  userEtherOf[msg.sender]  / st.price;      \r\n            if(canTokenAmount > 0 && canTokenAmount *  st.price >  userEtherOf[msg.sender]){\r\n                 canTokenAmount -= 1;\r\n            }\r\n            if(canTokenAmount == 0){\r\n                OnBuyToken(msg.sender, userEtherOf[msg.sender], _seller, _tokenAddress, 0, st.price, sellingAmount);\r\n                unLock();\r\n                return;\r\n            }\r\n            if (canTokenAmount > sellingAmount){\r\n                canTokenAmount = sellingAmount; \r\n            }\r\n            \r\n            var etherAmount =  canTokenAmount *  st.price;      //这里不存在溢出，因为 canTokenAmount =  userEtherOf[msg.sender]  / st.price;      2017-09-27\r\n            userEtherOf[msg.sender] -= etherAmount;                     //减少记账金额\r\n            //require(userEtherOf[msg.sender] >= 0);                      //冗余判断: 必然，uint数据类型。2017-09-27 delete\r\n\r\n            token.transferFrom(_seller, msg.sender, canTokenAmount);    //转代币, ，预防类似 the dao 潜在的风险       \r\n            if(userEtherOf[_seller]  >= sellerGuaranteeEther){          //大于等于最低保证金，这样鼓励卖家存留一点保证金。            \r\n                _seller.transfer(etherAmount);                          //转以太币，预防类似 the dao 潜在的风险      \r\n            }   \r\n            else{                                                       //小于最低保证金\r\n                userEtherOf[_seller] +=  etherAmount;                   //由推改为拖，更安全！ //这里不存在溢出，2017-09-27\r\n            }      \r\n            st.soldoutAmount += canTokenAmount;                         //更新销售额     //可能溢出，只有恶意调用才可能出现溢出，溢出也不影响交易，不处理。 2017-09-27\r\n            st.thisAmount = token.allowance(_seller, this);             //更新可销售代币数量\r\n\r\n            OnBuyToken(msg.sender, userEtherOf[msg.sender], _seller, _tokenAddress, canTokenAmount, st.price, st.thisAmount);     \r\n            _result = true;\r\n        }\r\n        else{\r\n            _result = false;\r\n            OnBuyToken(msg.sender, userEtherOf[msg.sender], _seller, _tokenAddress, 0, st.price, sellingAmount);\r\n        }\r\n\r\n        if (bigger && sellerGuaranteeEther > 0){                                  //虚报可出售Token，要惩罚卖家：只要卖家账上有钱就被扣保证金。\r\n            var pf = sellerGuaranteeEther;\r\n            if (pf > userEtherOf[_seller]){\r\n                pf = userEtherOf[_seller];\r\n            }\r\n            if(pf > 0){\r\n                userEtherOf[owner] +=  pf / 2;           \r\n                userEtherOf[msg.sender] +=   pf - pf / 2;\r\n                userEtherOf[_seller] -= pf;\r\n            }\r\n        }\r\n        \r\n        unLock();\r\n        return;\r\n    }\r\n\r\n    function () public payable {\r\n        if(msg.value > 0){          //来者不拒，比抛出异常或许更合适。\r\n            userEtherOf[msg.sender] += msg.value;\r\n        }\r\n    }\r\n\r\n    function disToken(address _token) public {          //处理捡到的各种Token，也就是别人误操作，直接给 this 发送了 token 。由调用者和Owner平分。因为这种误操作导致的丢失过去一年的损失达到几十万美元。\r\n        lock();\r\n\r\n        Erc20Token token = Erc20Token(_token);  //目前只处理 ERC20 Token，那些非标准Token就会永久丢失！\r\n        var amount = token.balanceOf(this);     //有一定风险，2017-09-27\r\n        if (amount > 0){\r\n            var a1 = amount / 2;\r\n            if (a1 > 0){\r\n                token.transfer(msg.sender, a1); //有一定风险，2017-09-27\r\n            }\r\n            var a2 = amount - a1;\r\n            if (a2 > 0){\r\n                token.transfer(owner, a2);      //有一定风险，2017-09-27\r\n            }\r\n        }\r\n\r\n        unLock();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"globalLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"removeBadToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userSellingTokenOf\",\"outputs\":[{\"name\":\"thisAmount\",\"type\":\"uint256\"},{\"name\":\"soldoutAmount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"cancel\",\"type\":\"bool\"},{\"name\":\"lineTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"disToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"userRefundTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userEtherOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_lineTime\",\"type\":\"uint256\"}],\"name\":\"setSellingToken\",\"outputs\":[{\"name\":\"_sellingAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userRefundWithoutGuaranteeEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"addBadToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gurateeEther\",\"type\":\"uint256\"}],\"name\":\"setSellerGuarantee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"cancelSellingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_buyerTokenPrice\",\"type\":\"uint256\"}],\"name\":\"buyTokenFrom\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"badTokenOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellerGuaranteeEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_badNum\",\"type\":\"uint256\"}],\"name\":\"OnBadTokenChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_sellingAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_lineTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_cancel\",\"type\":\"bool\"}],\"name\":\"OnSetSellingToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_buyerRamianEtherAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_transTokenAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_tokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_sellerRamianTokenAmount\",\"type\":\"uint256\"}],\"name\":\"OnBuyToken\",\"type\":\"event\"}]","ContractName":"Erc20TokenMarket","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8df058614a7a19a1468f0f9aa0b2049c0b4c048ed81fdeb74d63c17ee0bc1093"}]}