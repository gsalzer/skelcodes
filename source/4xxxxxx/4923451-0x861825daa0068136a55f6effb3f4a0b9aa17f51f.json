{"status":"1","message":"OK","result":[{"SourceCode":"//  Copyright (c) 2017, 2018 EtherJack.io. All rights reserved.\r\n//  This code is disclosed only to be used for inspection and audit purposes.\r\n//  Code modification and use for any purpose other than security audit\r\n//  is prohibited. Creation of derived works or unauthorized deployment\r\n//  of the code or any its portion to a blockchain is prohibited.\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\ncontract HouseOwned {\r\n    address house;\r\n\r\n    modifier onlyHouse {\r\n        require(msg.sender == house);\r\n        _;\r\n    }\r\n\r\n    /// @dev Contract constructor\r\n    function HouseOwned() public {\r\n        house = msg.sender;\r\n    }\r\n}\r\n\r\n\r\n// SafeMath is a part of Zeppelin Solidity library\r\n// licensed under MIT License\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/LICENSE\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address _owner) public constant returns (uint balance);\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Token is HouseOwned, ERC20Interface {\r\n    using SafeMath for uint;\r\n\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 0;\r\n    uint256 public supply;\r\n\r\n    // Trusted addresses\r\n    Jackpot public jackpot;\r\n    address public croupier;\r\n\r\n    // All users' balances\r\n    mapping (address => uint256) internal balances;\r\n    // Users' deposits with Croupier\r\n    mapping (address => uint256) public depositOf;\r\n    // Total amount of deposits\r\n    uint256 public totalDeposit;\r\n    // Total amount of \"Frozen Deposit Pool\" -- the tokens for sale at Croupier\r\n    uint256 public frozenPool;\r\n    // Allowance mapping\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    //////\r\n    /// @title Modifiers\r\n    //\r\n\r\n    /// @dev Only Croupier\r\n    modifier onlyCroupier {\r\n        require(msg.sender == croupier);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only Jackpot\r\n    modifier onlyJackpot {\r\n        require(msg.sender == address(jackpot));\r\n        _;\r\n    }\r\n\r\n    /// @dev Protection from short address attack\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length == size + 4);\r\n        _;\r\n    }\r\n\r\n    //////\r\n    /// @title Events\r\n    //\r\n\r\n    /// @dev Fired when a token is burned (bet made)\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    /// @dev Fired when a deposit is made or withdrawn\r\n    ///       direction == 0: deposit\r\n    ///       direction == 1: withdrawal\r\n    event Deposit(address indexed from, uint256 value, uint8 direction, uint256 newDeposit);\r\n\r\n    /// @dev Fired when a deposit with Croupier is frozen (set for sale)\r\n    event DepositFrozen(address indexed from, uint256 value);\r\n\r\n    /// @dev Fired when a deposit with Croupier is unfrozen (removed from sale)\r\n    //       Value is the resulting deposit, NOT the unfrozen amount\r\n    event DepositUnfrozen(address indexed from, uint256 value);\r\n\r\n    //////\r\n    /// @title Constructor and Initialization\r\n    //\r\n\r\n    /// @dev Initializes contract with initial supply tokens to the creator of the contract\r\n    function Token() HouseOwned() public {\r\n        name = \"JACK Token\";\r\n        symbol = \"JACK\";\r\n        supply = 1000000;\r\n    }\r\n\r\n    /// @dev Function to set address of Jackpot contract once after creation\r\n    /// @param _jackpot Address of the Jackpot contract\r\n    function setJackpot(address _jackpot) onlyHouse public {\r\n        require(address(jackpot) == 0x0);\r\n        require(_jackpot != address(this)); // Protection from admin's mistake\r\n\r\n        jackpot = Jackpot(_jackpot);\r\n\r\n        uint256 bountyPortion = supply / 40;           // 2.5% is the bounty portion for marketing expenses\r\n        balances[house] = bountyPortion;               // House receives the bounty tokens\r\n        balances[jackpot] = supply - bountyPortion;    // Jackpot gets the rest\r\n\r\n        croupier = jackpot.croupier();\r\n    }\r\n\r\n    //////\r\n    /// @title Public Methods\r\n    //\r\n\r\n\r\n    /// @dev Croupier invokes this method to return deposits to players\r\n    /// @param _to The address of the recipient\r\n    /// @param _extra Additional off-chain credit (AirDrop support), so that croupier can return more than the user has actually deposited\r\n    function returnDeposit(address _to, uint256 _extra) onlyCroupier public {\r\n        require(depositOf[_to] > 0 || _extra > 0);\r\n        uint256 amount = depositOf[_to];\r\n        depositOf[_to] = 0;\r\n        totalDeposit = totalDeposit.sub(amount);\r\n\r\n        _transfer(croupier, _to, amount.add(_extra));\r\n\r\n        Deposit(_to, amount, 1, 0);\r\n    }\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner The address\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return supply;\r\n    }\r\n\r\n    /// @dev Send `_value` tokens to `_to`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value the amount to send\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) {\r\n        require(address(jackpot) != 0x0);\r\n        require(croupier != 0x0);\r\n\r\n        if (_to == address(jackpot)) {\r\n            // It is a token bet. Ignoring _value, only using 1 token\r\n            _burnFromAccount(msg.sender, 1);\r\n            jackpot.betToken(msg.sender);\r\n            return true;\r\n        }\r\n\r\n        if (_to == croupier && msg.sender != house) {\r\n            // It's a deposit to Croupier. In addition to transferring the token,\r\n            // mark it in the deposits table\r\n\r\n            // House can't make deposits. If House is transferring something to\r\n            // Croupier, it's just a transfer, nothing more\r\n\r\n            depositOf[msg.sender] += _value;\r\n            totalDeposit = totalDeposit.add(_value);\r\n\r\n            Deposit(msg.sender, _value, 0, depositOf[msg.sender]);\r\n        }\r\n\r\n        // In all cases but Jackpot transfer (which is terminated by a return), actually\r\n        // do perform the transfer\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another\r\n    /// @param _from address The address which you want to send tokens from\r\n    /// @param _to address The address which you want to transfer to\r\n    /// @param _value uint256 the amount of tokens to be transferred\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _value The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    /// @param _owner address The address which owns the funds.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @return A uint256 specifying the amount of tokens still available for the spender.\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _addedValue The amount of tokens to increase the allowance by.\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Croupier uses this method to set deposited credits of a player for sale\r\n    /// @param _user The address of the user\r\n    /// @param _extra Additional off-chain credit (AirDrop support), so that croupier could have frozen more than the user had invested\r\n    function freezeDeposit(address _user, uint256 _extra) onlyCroupier public {\r\n        require(depositOf[_user] > 0 || _extra > 0);\r\n\r\n        uint256 deposit = depositOf[_user];\r\n        depositOf[_user] = depositOf[_user].sub(deposit);\r\n        totalDeposit = totalDeposit.sub(deposit);\r\n\r\n        uint256 depositWithExtra = deposit.add(_extra);\r\n\r\n        frozenPool = frozenPool.add(depositWithExtra);\r\n\r\n        DepositFrozen(_user, depositWithExtra);\r\n    }\r\n\r\n    /// @dev Croupier uses this method stop selling user's tokens and return them to normal deposit\r\n    /// @param _user The user whose deposit is being unfrozen\r\n    /// @param _value The value to unfreeze according to Croupier's records (off-chain sale data)\r\n    function unfreezeDeposit(address _user, uint256 _value) onlyCroupier public {\r\n        require(_value > 0);\r\n        require(frozenPool >= _value);\r\n\r\n        depositOf[_user] = depositOf[_user].add(_value);\r\n        totalDeposit = totalDeposit.add(_value);\r\n\r\n        frozenPool = frozenPool.sub(_value);\r\n\r\n        DepositUnfrozen(_user, depositOf[_user]);\r\n    }\r\n\r\n    /// @dev The Jackpot contract invokes this method when selling tokens from Croupier\r\n    /// @param _to The recipient of the tokens\r\n    /// @param _value The amount\r\n    function transferFromCroupier(address _to, uint256 _value) onlyJackpot public {\r\n        require(_value > 0);\r\n        require(frozenPool >= _value);\r\n\r\n        frozenPool = frozenPool.sub(_value);\r\n\r\n        _transfer(croupier, _to, _value);\r\n    }\r\n\r\n    //////\r\n    /// @title Internal Methods\r\n    //\r\n\r\n    /// @dev Internal transfer function\r\n    /// @param _from From address\r\n    /// @param _to To address\r\n    /// @param _value The value to transfer\r\n    /// @return success\r\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\r\n        require(_to != address(0));                         // Prevent transfer to 0x0 address\r\n        require(balances[_from] >= _value);                 // Check if the sender has enough\r\n        balances[_from] = balances[_from].sub(_value);      // Subtract from the sender\r\n        balances[_to] = balances[_to].add(_value);          // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Internal function for burning tokens\r\n    /// @param _sender The token sender (whose tokens are being burned)\r\n    /// @param _value The amount of tokens to burn\r\n    function _burnFromAccount(address _sender, uint256 _value) internal {\r\n        require(balances[_sender] >= _value);               // Check if the sender has enough\r\n        balances[_sender] = balances[_sender].sub(_value);  // Subtract from the sender\r\n        supply = supply.sub(_value);                        // Updates totalSupply\r\n        Burn(_sender, _value);\r\n    }\r\n\r\n}\r\n\r\ncontract Jackpot is HouseOwned {\r\n    using SafeMath for uint;\r\n\r\n    enum Stages {\r\n        InitialOffer,   // ICO stage: forming the jackpot fund\r\n        GameOn,         // The game is running\r\n        GameOver,       // The jackpot is won, paying out the jackpot\r\n        Aborted         // ICO aborted, refunding investments\r\n    }\r\n\r\n    uint256 constant initialIcoTokenPrice = 4 finney;\r\n    uint256 constant initialBetAmount = 10 finney;\r\n    uint constant gameStartJackpotThreshold = 333 ether;\r\n    uint constant icoTerminationTimeout = 48 hours;\r\n\r\n    // These variables hold the values needed for minor prize checking:\r\n    //  - when they were last won (once the number reaches the corresponding amount, the\r\n    //    minor prize is won, and it should be reset)\r\n    //  - how much ether was bet since it was last won\r\n    // `etherSince*` variables start with value of 1 and always have +1 in their value\r\n    // so that the variables never go 0, for gas consumption consistency\r\n    uint32 public totalBets = 0;\r\n    uint256 public etherSince20 = 1;\r\n    uint256 public etherSince50 = 1;\r\n    uint256 public etherSince100 = 1;\r\n    uint256 public pendingEtherForCroupier = 0;\r\n\r\n    // ICO status\r\n    uint32 public icoSoldTokens;\r\n    uint256 public icoEndTime;\r\n\r\n    // Jackpot status\r\n    address public lastBetUser;\r\n    uint256 public terminationTime;\r\n    address public winner;\r\n    uint256 public pendingJackpotForHouse;\r\n    uint256 public pendingJackpotForWinner;\r\n\r\n    // General configuration and stage\r\n    address public croupier;\r\n    Token public token;\r\n    Stages public stage = Stages.InitialOffer;\r\n\r\n    // Price state\r\n    uint256 public currentIcoTokenPrice = initialIcoTokenPrice;\r\n    uint256 public currentBetAmount = initialBetAmount;\r\n\r\n    // Investment tracking for emergency ICO termination\r\n    mapping (address => uint256) public investmentOf;\r\n    uint256 public abortTime;\r\n\r\n    //////\r\n    /// @title Modifiers\r\n    //\r\n\r\n    /// @dev Only Token\r\n    modifier onlyToken {\r\n        require(msg.sender == address(token));\r\n        _;\r\n    }\r\n\r\n    /// @dev Only Croupier\r\n    modifier onlyCroupier {\r\n        require(msg.sender == address(croupier));\r\n        _;\r\n    }\r\n\r\n    //////\r\n    /// @title Events\r\n    //\r\n\r\n    /// @dev Fired when tokens are sold for Ether in ICO\r\n    event EtherIco(address indexed from, uint256 value, uint256 tokens);\r\n\r\n    /// @dev Fired when a bid with Ether is made\r\n    event EtherBet(address indexed from, uint256 value, uint256 dividends);\r\n\r\n    /// @dev Fired when a bid with a Token is made\r\n    event TokenBet(address indexed from);\r\n\r\n    /// @dev Fired when a bidder wins a minor prize\r\n    ///      Type: 1: 20, 2: 50, 3: 100\r\n    event MinorPrizePayout(address indexed from, uint256 value, uint8 prizeType);\r\n\r\n    /// @dev Fired when as a result of ether bid, tokens are sold from the Croupier's pool\r\n    ///      The parameters are who bought them, how many tokens, and for how much Ether they were sold\r\n    event SoldTokensFromCroupier(address indexed from, uint256 value, uint256 tokens);\r\n\r\n    /// @dev Fired when the jackpot is won\r\n    event JackpotWon(address indexed from, uint256 value);\r\n\r\n\r\n    //////\r\n    /// @title Constructor and Initialization\r\n    //\r\n\r\n    /// @dev The contract constructor\r\n    /// @param _croupier The address of the trusted Croupier bot's account\r\n    function Jackpot(address _croupier)\r\n        HouseOwned()\r\n        public\r\n    {\r\n        require(_croupier != 0x0);\r\n        croupier = _croupier;\r\n\r\n        // There are no bets (it even starts in ICO stage), so initialize\r\n        // lastBetUser, just so that value is not zero and is meaningful\r\n        // The game can't end until at least one bid is made, and once\r\n        // a bid is made, this value is permanently overwritten.\r\n        lastBetUser = _croupier;\r\n    }\r\n\r\n    /// @dev Function to set address of Token contract once after creation\r\n    /// @param _token Address of the Token contract (JACK Token)\r\n    function setToken(address _token) onlyHouse public {\r\n        require(address(token) == 0x0);\r\n        require(_token != address(this)); // Protection from admin's mistake\r\n\r\n        token = Token(_token);\r\n    }\r\n\r\n\r\n    //////\r\n    /// @title Default Function\r\n    //\r\n\r\n    /// @dev The fallback function for receiving ether (bets)\r\n    ///      Action depends on stages:\r\n    ///       - ICO: just sell the tokens\r\n    ///       - Game: accept bets, award tokens, award minor (20, 50, 100) prizes\r\n    ///       - Game Over: pay out jackpot\r\n    ///       - Aborted: fail\r\n    function() payable public {\r\n        require(croupier != 0x0);\r\n        require(address(token) != 0x0);\r\n        require(stage != Stages.Aborted);\r\n\r\n        uint256 tokens;\r\n\r\n        if (stage == Stages.InitialOffer) {\r\n\r\n            // First, check if the ICO is over. If it is, trigger the events and\r\n            // refund sent ether\r\n            bool started = checkGameStart();\r\n            if (started) {\r\n                // Refund ether without failing the transaction\r\n                // (because side-effect is needed)\r\n                msg.sender.transfer(msg.value);\r\n                return;\r\n            }\r\n\r\n            require(msg.value >= currentIcoTokenPrice);\r\n        \r\n            // THE PLAN\r\n            // 1. [CHECK + EFFECT] Calculate how much times price, the investment amount is,\r\n            //    calculate how many tokens the investor is going to get\r\n            // 2. [EFFECT] Log and count\r\n            // 3. [EFFECT] Check game start conditions and maybe start the game\r\n            // 4. [INT] Award the tokens\r\n            // 5. [INT] Transfer 20% to house\r\n\r\n            // 1. [CHECK + EFFECT] Checking the amount\r\n            tokens = _icoTokensForEther(msg.value);\r\n\r\n            // 2. [EFFECT] Log\r\n            // Log the ICO event and count investment\r\n            EtherIco(msg.sender, msg.value, tokens);\r\n\r\n            investmentOf[msg.sender] = investmentOf[msg.sender].add(\r\n                msg.value.sub(msg.value / 5)\r\n            );\r\n\r\n            // 3. [EFFECT] Game start\r\n            // Check if we have accumulated the jackpot amount required for game start\r\n            if (icoEndTime == 0 && this.balance >= gameStartJackpotThreshold) {\r\n                icoEndTime = now + icoTerminationTimeout;\r\n            }\r\n\r\n            // 4. [INT] Awarding tokens\r\n            // Award the deserved tokens (if any)\r\n            if (tokens > 0) {\r\n                token.transfer(msg.sender, tokens);\r\n            }\r\n\r\n            // 5. [INT] House\r\n            // House gets 20% of ICO according to the rules\r\n            house.transfer(msg.value / 5);\r\n\r\n        } else if (stage == Stages.GameOn) {\r\n\r\n            // First, check if the game is over. If it is, trigger the events and\r\n            // refund sent ether\r\n            bool terminated = checkTermination();\r\n            if (terminated) {\r\n                // Refund ether without failing the transaction\r\n                // (because side-effect is needed)\r\n                msg.sender.transfer(msg.value);\r\n                return;\r\n            }\r\n\r\n            // Now processing an Ether bid\r\n            require(msg.value >= currentBetAmount);\r\n\r\n            // THE PLAN\r\n            // 1. [CHECK] Calculate how much times min-bet, the bet amount is,\r\n            //    calculate how many tokens the player is going to get\r\n            // 2. [CHECK] Check how much is sold from the Croupier's pool, and how much from Jackpot\r\n            // 3. [EFFECT] Deposit 25% to the Croupier (for dividends and house's benefit)\r\n            // 4. [EFFECT] Log and mark bid\r\n            // 6. [INT] Check and reward (if won) minor (20, 100, 1000) prizes\r\n            // 7. [EFFECT] Update bet amount\r\n            // 8. [INT] Award the tokens\r\n\r\n\r\n            // 1. [CHECK + EFFECT] Checking the bet amount and token reward\r\n            tokens = _betTokensForEther(msg.value);\r\n\r\n            // 2. [CHECK] Check how much is sold from the Croupier's pool, and how much from Jackpot\r\n            //    The priority is (1) Croupier, (2) Jackpot\r\n            uint256 sellingFromJackpot = 0;\r\n            uint256 sellingFromCroupier = 0;\r\n            if (tokens > 0) {\r\n                uint256 croupierPool = token.frozenPool();\r\n                uint256 jackpotPool = token.balanceOf(this);\r\n\r\n                if (croupierPool == 0) {\r\n                    // Simple case: only Jackpot is selling\r\n                    sellingFromJackpot = tokens;\r\n                    if (sellingFromJackpot > jackpotPool) {\r\n                        sellingFromJackpot = jackpotPool;\r\n                    }\r\n                } else if (jackpotPool == 0 || tokens <= croupierPool) {\r\n                    // Simple case: only Croupier is selling\r\n                    // either because Jackpot has 0, or because Croupier takes over\r\n                    // by priority and has enough tokens in its pool\r\n                    sellingFromCroupier = tokens;\r\n                    if (sellingFromCroupier > croupierPool) {\r\n                        sellingFromCroupier = croupierPool;\r\n                    }\r\n                } else {\r\n                    // Complex case: both are selling now\r\n                    sellingFromCroupier = croupierPool;  // (tokens > croupierPool) is guaranteed at this point\r\n                    sellingFromJackpot = tokens.sub(sellingFromCroupier);\r\n                    if (sellingFromJackpot > jackpotPool) {\r\n                        sellingFromJackpot = jackpotPool;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 3. [EFFECT] Croupier deposit\r\n            // Transfer a portion to the Croupier for dividend payout and house benefit\r\n            // Dividends are a sum of:\r\n            //   + 25% of bet\r\n            //   + 50% of price of tokens sold from Jackpot (or just anything other than the bet and Croupier payment)\r\n            //   + 0%  of price of tokens sold from Croupier\r\n            //          (that goes in SoldTokensFromCroupier instead)\r\n            uint256 tokenValue = msg.value.sub(currentBetAmount);\r\n\r\n            uint256 croupierSaleRevenue = 0;\r\n            if (sellingFromCroupier > 0) {\r\n                croupierSaleRevenue = tokenValue.div(\r\n                    sellingFromJackpot.add(sellingFromCroupier)\r\n                ).mul(sellingFromCroupier);\r\n            }\r\n            uint256 jackpotSaleRevenue = tokenValue.sub(croupierSaleRevenue);\r\n\r\n            uint256 dividends = (currentBetAmount.div(4)).add(jackpotSaleRevenue.div(2));\r\n\r\n            // 100% of money for selling from Croupier still goes to Croupier\r\n            // so that it's later paid out to the selling user\r\n            pendingEtherForCroupier = pendingEtherForCroupier.add(dividends.add(croupierSaleRevenue));\r\n\r\n            // 4. [EFFECT] Log and mark bid\r\n            // Log the bet with actual amount charged (value less change)\r\n            EtherBet(msg.sender, msg.value, dividends);\r\n            lastBetUser = msg.sender;\r\n            terminationTime = now + _terminationDuration();\r\n\r\n            // If anything was sold from Croupier, log it appropriately\r\n            if (croupierSaleRevenue > 0) {\r\n                SoldTokensFromCroupier(msg.sender, croupierSaleRevenue, sellingFromCroupier);\r\n            }\r\n\r\n            // 5. [INT] Minor prizes\r\n            // Check for winning minor prizes\r\n            _checkMinorPrizes(msg.sender, currentBetAmount);\r\n\r\n            // 6. [EFFECT] Update bet amount\r\n            _updateBetAmount();\r\n\r\n            // 7. [INT] Awarding tokens\r\n            if (sellingFromJackpot > 0) {\r\n                token.transfer(msg.sender, sellingFromJackpot);\r\n            }\r\n            if (sellingFromCroupier > 0) {\r\n                token.transferFromCroupier(msg.sender, sellingFromCroupier);\r\n            }\r\n\r\n        } else if (stage == Stages.GameOver) {\r\n\r\n            require(msg.sender == winner || msg.sender == house);\r\n\r\n            if (msg.sender == winner) {\r\n                require(pendingJackpotForWinner > 0);\r\n\r\n                uint256 winnersPay = pendingJackpotForWinner;\r\n                pendingJackpotForWinner = 0;\r\n\r\n                msg.sender.transfer(winnersPay);\r\n            } else if (msg.sender == house) {\r\n                require(pendingJackpotForHouse > 0);\r\n\r\n                uint256 housePay = pendingJackpotForHouse;\r\n                pendingJackpotForHouse = 0;\r\n\r\n                msg.sender.transfer(housePay);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Croupier will call this function when the jackpot is won\r\n    // If Croupier fails to call the function for any reason, house and winner\r\n    // still can claim their jackpot portion by sending ether to Jackpot\r\n    function payOutJackpot() onlyCroupier public {\r\n        require(winner != 0x0);\r\n    \r\n        if (pendingJackpotForHouse > 0) {\r\n            uint256 housePay = pendingJackpotForHouse;\r\n            pendingJackpotForHouse = 0;\r\n\r\n            house.transfer(housePay);\r\n        }\r\n\r\n        if (pendingJackpotForWinner > 0) {\r\n            uint256 winnersPay = pendingJackpotForWinner;\r\n            pendingJackpotForWinner = 0;\r\n\r\n            winner.transfer(winnersPay);\r\n        }\r\n\r\n    }\r\n\r\n    //////\r\n    /// @title Public Functions\r\n    //\r\n\r\n    /// @dev View function to check whether the game should be terminated\r\n    ///      Used as internal function by checkTermination, as well as by the\r\n    ///      Croupier bot, to check whether it should call checkTermination\r\n    /// @return Whether the game should be terminated by timeout\r\n    function shouldBeTerminated() public view returns (bool should) {\r\n        return stage == Stages.GameOn && terminationTime != 0 && now > terminationTime;\r\n    }\r\n\r\n    /// @dev Check whether the game should be terminated, and if it should, terminate it\r\n    /// @return Whether the game was terminated as the result\r\n    function checkTermination() public returns (bool terminated) {\r\n        if (shouldBeTerminated()) {\r\n            stage = Stages.GameOver;\r\n\r\n            winner = lastBetUser;\r\n\r\n            // Flush amount due for Croupier immediately\r\n            _flushEtherToCroupier();\r\n\r\n            // The rest should be claimed by the winner (except what house gets)\r\n            JackpotWon(winner, this.balance);\r\n\r\n\r\n            uint256 jackpot = this.balance;\r\n            pendingJackpotForHouse = jackpot.div(5);\r\n            pendingJackpotForWinner = jackpot.sub(pendingJackpotForHouse);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev View function to check whether the game should be started\r\n    ///      Used as internal function by `checkGameStart`, as well as by the\r\n    ///      Croupier bot, to check whether it should call `checkGameStart`\r\n    /// @return Whether the game should be started\r\n    function shouldBeStarted() public view returns (bool should) {\r\n        return stage == Stages.InitialOffer && icoEndTime != 0 && now > icoEndTime;\r\n    }\r\n\r\n    /// @dev Check whether the game should be started, and if it should, start it\r\n    /// @return Whether the game was started as the result\r\n    function checkGameStart() public returns (bool started) {\r\n        if (shouldBeStarted()) {\r\n            stage = Stages.GameOn;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Bet 1 token in the game\r\n    ///      The token has already been burned having passed all checks, so\r\n    ///      just process the bet of 1 token\r\n    function betToken(address _user) onlyToken public {\r\n        // Token bets can only be accepted in the game stage\r\n        require(stage == Stages.GameOn);\r\n\r\n        bool terminated = checkTermination();\r\n        if (terminated) {\r\n            return;\r\n        }\r\n\r\n        TokenBet(_user);\r\n        lastBetUser = _user;\r\n        terminationTime = now + _terminationDuration();\r\n\r\n        // Check for winning minor prizes\r\n        _checkMinorPrizes(_user, 0);\r\n    }\r\n\r\n    /// @dev Allows House to terminate ICO as an emergency measure\r\n    function abort() onlyHouse public {\r\n        require(stage == Stages.InitialOffer);\r\n\r\n        stage = Stages.Aborted;\r\n        abortTime = now;\r\n    }\r\n\r\n    /// @dev In case the ICO is emergency-terminated by House, allows investors\r\n    ///      to pull back the investments\r\n    function claimRefund() public {\r\n        require(stage == Stages.Aborted);\r\n        require(investmentOf[msg.sender] > 0);\r\n\r\n        uint256 payment = investmentOf[msg.sender];\r\n        investmentOf[msg.sender] = 0;\r\n\r\n        msg.sender.transfer(payment);\r\n    }\r\n\r\n    /// @dev In case the ICO was terminated, allows House to kill the contract in 2 months\r\n    ///      after the termination date\r\n    function killAborted() onlyHouse public {\r\n        require(stage == Stages.Aborted);\r\n        require(now > abortTime + 60 days);\r\n\r\n        selfdestruct(house);\r\n    }\r\n\r\n\r\n\r\n    //////\r\n    /// @title Internal Functions\r\n    //\r\n\r\n    /// @dev Get current bid timer duration\r\n    /// @return duration The duration\r\n    function _terminationDuration() internal view returns (uint256 duration) {\r\n        return (5 + 19200 / (100 + totalBets)) * 1 minutes;\r\n    }\r\n\r\n    /// @dev Updates the current ICO price according to the rules\r\n    function _updateIcoPrice() internal {\r\n        uint256 newIcoTokenPrice = currentIcoTokenPrice;\r\n\r\n        if (icoSoldTokens < 10000) {\r\n            newIcoTokenPrice = 4 finney;\r\n        } else if (icoSoldTokens < 20000) {\r\n            newIcoTokenPrice = 5 finney;\r\n        } else if (icoSoldTokens < 30000) {\r\n            newIcoTokenPrice = 5.3 finney;\r\n        } else if (icoSoldTokens < 40000) {\r\n            newIcoTokenPrice = 5.7 finney;\r\n        } else {\r\n            newIcoTokenPrice = 6 finney;\r\n        }\r\n\r\n        if (newIcoTokenPrice != currentIcoTokenPrice) {\r\n            currentIcoTokenPrice = newIcoTokenPrice;\r\n        }\r\n    }\r\n\r\n    /// @dev Updates the current bid price according to the rules\r\n    function _updateBetAmount() internal {\r\n        uint256 newBetAmount = 10 finney + (totalBets / 100) * 6 finney;\r\n\r\n        if (newBetAmount != currentBetAmount) {\r\n            currentBetAmount = newBetAmount;\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates how many tokens a user should get with a given Ether bid\r\n    /// @param value The bid amount\r\n    /// @return tokens The number of tokens\r\n    function _betTokensForEther(uint256 value) internal view returns (uint256 tokens) {\r\n        // One bet amount is for the bet itself, for the rest we will sell\r\n        // tokens\r\n        tokens = (value / currentBetAmount) - 1;\r\n\r\n        if (tokens >= 1000) {\r\n            tokens = tokens + tokens / 4; // +25%\r\n        } else if (tokens >= 300) {\r\n            tokens = tokens + tokens / 5; // +20%\r\n        } else if (tokens >= 100) {\r\n            tokens = tokens + tokens / 7; // ~ +14.3%\r\n        } else if (tokens >= 50) {\r\n            tokens = tokens + tokens / 10; // +10%\r\n        } else if (tokens >= 20) {\r\n            tokens = tokens + tokens / 20; // +5%\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates how many tokens a user should get with a given ICO transfer\r\n    /// @param value The transfer amount\r\n    /// @return tokens The number of tokens\r\n    function _icoTokensForEther(uint256 value) internal returns (uint256 tokens) {\r\n        // How many times the input is greater than current token price\r\n        tokens = value / currentIcoTokenPrice;\r\n\r\n        if (tokens >= 10000) {\r\n            tokens = tokens + tokens / 4; // +25%\r\n        } else if (tokens >= 5000) {\r\n            tokens = tokens + tokens / 5; // +20%\r\n        } else if (tokens >= 1000) {\r\n            tokens = tokens + tokens / 7; // ~ +14.3%\r\n        } else if (tokens >= 500) {\r\n            tokens = tokens + tokens / 10; // +10%\r\n        } else if (tokens >= 200) {\r\n            tokens = tokens + tokens / 20; // +5%\r\n        }\r\n\r\n        // Checking if Jackpot has the tokens in reserve\r\n        if (tokens > token.balanceOf(this)) {\r\n            tokens = token.balanceOf(this);\r\n        }\r\n\r\n        icoSoldTokens += (uint32)(tokens);\r\n\r\n        _updateIcoPrice();\r\n    }\r\n\r\n    /// @dev Flush the currently pending Ether to Croupier\r\n    function _flushEtherToCroupier() internal {\r\n        if (pendingEtherForCroupier > 0) {\r\n            uint256 willTransfer = pendingEtherForCroupier;\r\n            pendingEtherForCroupier = 0;\r\n            \r\n            croupier.transfer(willTransfer);\r\n        }\r\n    }\r\n\r\n    /// @dev Count the bid towards minor prize fund, check if the user\r\n    ///      wins a minor prize, and if they did, transfer the prize to them\r\n    /// @param user The user in question\r\n    /// @param value The bid value\r\n    function _checkMinorPrizes(address user, uint256 value) internal {\r\n        // First and foremost, increment the counters and ether counters\r\n        totalBets ++;\r\n        if (value > 0) {\r\n            etherSince20 = etherSince20.add(value);\r\n            etherSince50 = etherSince50.add(value);\r\n            etherSince100 = etherSince100.add(value);\r\n        }\r\n\r\n        // Now actually check if the bets won\r\n\r\n        uint256 etherPayout;\r\n\r\n        if ((totalBets + 30) % 100 == 0) {\r\n            // Won 100th\r\n            etherPayout = (etherSince100 - 1) / 10;\r\n            etherSince100 = 1;\r\n\r\n            MinorPrizePayout(user, etherPayout, 3);\r\n\r\n            user.transfer(etherPayout);\r\n            return;\r\n        }\r\n\r\n        if ((totalBets + 5) % 50 == 0) {\r\n            // Won 100th\r\n            etherPayout = (etherSince50 - 1) / 10;\r\n            etherSince50 = 1;\r\n\r\n            MinorPrizePayout(user, etherPayout, 2);\r\n\r\n            user.transfer(etherPayout);\r\n            return;\r\n        }\r\n\r\n        if (totalBets % 20 == 0) {\r\n            // Won 20th\r\n            etherPayout = (etherSince20 - 1) / 10;\r\n            etherSince20 = 1;\r\n\r\n            _flushEtherToCroupier();\r\n\r\n            MinorPrizePayout(user, etherPayout, 1);\r\n\r\n            user.transfer(etherPayout);\r\n            return;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unfreezeDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromCroupier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"croupier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpot\",\"type\":\"address\"}],\"name\":\"setJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_extra\",\"type\":\"uint256\"}],\"name\":\"freezeDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_extra\",\"type\":\"uint256\"}],\"name\":\"returnDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozenPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"direction\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DepositFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DepositUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5e20faa37cf25032f2deb856869f27de24ff0d19b98fe1a21026b2aa09e7a648"}]}