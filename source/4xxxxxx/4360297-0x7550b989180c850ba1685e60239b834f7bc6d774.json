{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public constant returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n//Papyrus State Channel Library\r\n//moved to separate library to save gas\r\nlibrary ChannelLibrary {\r\n    \r\n    struct Data {\r\n        uint close_timeout;\r\n        uint settle_timeout;\r\n        uint audit_timeout;\r\n        uint opened;\r\n        uint close_requested;\r\n        uint closed;\r\n        uint settled;\r\n        uint audited;\r\n        ChannelManagerContract manager;\r\n    \r\n        address sender;\r\n        address receiver;\r\n        address client;\r\n        uint balance;\r\n        address auditor;\r\n\r\n        //state update for close\r\n        uint nonce;\r\n        uint completed_transfers;\r\n    }\r\n\r\n    struct StateUpdate {\r\n        uint nonce;\r\n        uint completed_transfers;\r\n    }\r\n\r\n    modifier notSettledButClosed(Data storage self) {\r\n        require(self.settled <= 0 && self.closed > 0);\r\n        _;\r\n    }\r\n\r\n    modifier notAuditedButClosed(Data storage self) {\r\n        require(self.audited <= 0 && self.closed > 0);\r\n        _;\r\n    }\r\n\r\n    modifier stillTimeout(Data storage self) {\r\n        require(self.closed + self.settle_timeout >= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier timeoutOver(Data storage self) {\r\n        require(self.closed + self.settle_timeout <= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier channelSettled(Data storage self) {\r\n        require(self.settled != 0);\r\n        _;\r\n    }\r\n\r\n    modifier senderOnly(Data storage self) {\r\n        require(self.sender == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier receiverOnly(Data storage self) {\r\n        require(self.receiver == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /// @notice Sender deposits amount to channel.\r\n    /// must deposit before the channel is opened.\r\n    /// @param amount The amount to be deposited to the address\r\n    /// @return Success if the transfer was successful\r\n    /// @return The new balance of the invoker\r\n    function deposit(Data storage self, uint256 amount) \r\n    senderOnly(self)\r\n    returns (bool success, uint256 balance)\r\n    {\r\n        require(self.opened > 0);\r\n        require(self.closed == 0);\r\n\r\n        StandardToken token = self.manager.token();\r\n\r\n        require (token.balanceOf(msg.sender) >= amount);\r\n\r\n        success = token.transferFrom(msg.sender, this, amount);\r\n    \r\n        if (success == true) {\r\n            self.balance += amount;\r\n\r\n            return (true, self.balance);\r\n        }\r\n\r\n        return (false, 0);\r\n    }\r\n\r\n    function request_close(\r\n        Data storage self\r\n    ) {\r\n        require(msg.sender == self.sender || msg.sender == self.receiver);\r\n        require(self.close_requested == 0);\r\n        self.close_requested = block.number;\r\n    }\r\n\r\n    function close(\r\n        Data storage self,\r\n        address channel_address,\r\n        uint nonce,\r\n        uint completed_transfers,\r\n        bytes signature\r\n    )\r\n    {\r\n        if (self.close_timeout > 0) {\r\n            require(self.close_requested > 0);\r\n            require(block.number - self.close_requested >= self.close_timeout);\r\n        }\r\n        require(nonce > self.nonce);\r\n        require(completed_transfers >= self.completed_transfers);\r\n        require(completed_transfers <= self.balance);\r\n    \r\n        if (msg.sender != self.sender) {\r\n            //checking signature\r\n            bytes32 signed_hash = hashState(\r\n                channel_address,\r\n                nonce,\r\n                completed_transfers\r\n            );\r\n\r\n            address sign_address = ECRecovery.recover(signed_hash, signature);\r\n            require(sign_address == self.sender);\r\n        }\r\n\r\n        if (self.closed == 0) {\r\n            self.closed = block.number;\r\n        }\r\n    \r\n        self.nonce = nonce;\r\n        self.completed_transfers = completed_transfers;\r\n    }\r\n\r\n    function hashState (\r\n        address channel_address,\r\n        uint nonce,\r\n        uint completed_transfers\r\n    ) returns (bytes32) {\r\n        return sha3 (\r\n            channel_address,\r\n            nonce,\r\n            completed_transfers\r\n        );\r\n    }\r\n\r\n    /// @notice Settles the balance between the two parties\r\n    /// @dev Settles the balances of the two parties fo the channel\r\n    /// @return The participants with netted balances\r\n    function settle(Data storage self)\r\n        notSettledButClosed(self)\r\n        timeoutOver(self)\r\n    {\r\n        StandardToken token = self.manager.token();\r\n        \r\n        if (self.completed_transfers > 0) {\r\n            require(token.transfer(self.receiver, self.completed_transfers));\r\n        }\r\n\r\n        if (self.completed_transfers < self.balance) {\r\n            require(token.transfer(self.sender, self.balance - self.completed_transfers));\r\n        }\r\n\r\n        self.settled = block.number;\r\n    }\r\n\r\n    function audit(Data storage self, address auditor)\r\n        notAuditedButClosed(self) {\r\n        require(self.auditor == auditor);\r\n        require(block.number <= self.closed + self.audit_timeout);\r\n        self.audited = block.number;\r\n    }\r\n\r\n    function validateTransfer(\r\n        Data storage self,\r\n        address transfer_id,\r\n        address channel_address,\r\n        uint sum,\r\n        bytes lock_data,\r\n        bytes signature\r\n    ) returns (uint256) {\r\n\r\n        bytes32 signed_hash = hashTransfer(\r\n            transfer_id,\r\n            channel_address,\r\n            lock_data,\r\n            sum\r\n        );\r\n\r\n        address sign_address = ECRecovery.recover(signed_hash, signature);\r\n        require(sign_address == self.client);\r\n    }\r\n\r\n    function hashTransfer(\r\n        address transfer_id,\r\n        address channel_address,\r\n        bytes lock_data,\r\n        uint sum\r\n    ) returns (bytes32) {\r\n        if (lock_data.length > 0) {\r\n            return sha3 (\r\n                transfer_id,\r\n                channel_address,\r\n                sum,\r\n                lock_data\r\n            );\r\n        } else {\r\n            return sha3 (\r\n                transfer_id,\r\n                channel_address,\r\n                sum\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title ERC20 interface\r\n/// @dev Full ERC20 interface described at https://github.com/ethereum/EIPs/issues/20.\r\ncontract ERC20 {\r\n\r\n  // EVENTS\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  // PUBLIC FUNCTIONS\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  function balanceOf(address _owner) public constant returns (uint256);\r\n  function allowance(address _owner, address _spender) public constant returns (uint256);\r\n\r\n  // FIELDS\r\n\r\n  uint256 public totalSupply;\r\n}\r\n\r\n\r\n/// @title SafeMath\r\n/// @dev Math operations with safety checks that throw on error.\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/// @title Standard ERC20 token\r\n/// @dev Implementation of the basic standard token.\r\ncontract StandardToken is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  // PUBLIC FUNCTIONS\r\n\r\n  /// @dev Transfers tokens to a specified address.\r\n  /// @param _to The address which you want to transfer to.\r\n  /// @param _value The amount of tokens to be transferred.\r\n  /// @return A boolean that indicates if the operation was successful.\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n  \r\n  /// @dev Transfers tokens from one address to another.\r\n  /// @param _from The address which you want to send tokens from.\r\n  /// @param _to The address which you want to transfer to.\r\n  /// @param _value The amount of tokens to be transferred.\r\n  /// @return A boolean that indicates if the operation was successful.\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowances[_from][msg.sender]);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Approves the specified address to spend the specified amount of tokens on behalf of msg.sender.\r\n  /// Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n  /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n  /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n  /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n  /// @param _spender The address which will spend tokens.\r\n  /// @param _value The amount of tokens to be spent.\r\n  /// @return A boolean that indicates if the operation was successful.\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowances[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Gets the balance of the specified address.\r\n  /// @param _owner The address to query the balance of.\r\n  /// @return An uint256 representing the amount owned by the specified address.\r\n  function balanceOf(address _owner) public constant returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /// @dev Function to check the amount of tokens that an owner allowances to a spender.\r\n  /// @param _owner The address which owns tokens.\r\n  /// @param _spender The address which will spend tokens.\r\n  /// @return A uint256 specifying the amount of tokens still available for the spender.\r\n  function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n    return allowances[_owner][_spender];\r\n  }\r\n\r\n  // FIELDS\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowances;\r\n}\r\n\r\n\r\ncontract ChannelApi {\r\n    function applyRuntimeUpdate(address from, address to, uint impressionsCount, uint fraudCount);\r\n\r\n    function applyAuditorsCheckUpdate(address from, address to, uint fraudCountDelta);\r\n}\r\n\r\n\r\ncontract ChannelContract {\r\n    using ChannelLibrary for ChannelLibrary.Data;\r\n    ChannelLibrary.Data data;\r\n\r\n    event ChannelNewBalance(address token_address, address participant, uint balance, uint block_number);\r\n    event ChannelCloseRequested(address closing_address, uint block_number);\r\n    event ChannelClosed(address closing_address, uint block_number);\r\n    event TransferUpdated(address node_address, uint block_number);\r\n    event ChannelSettled(uint block_number);\r\n    event ChannelAudited(uint block_number);\r\n    event ChannelSecretRevealed(bytes32 secret, address receiver_address);\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == address(data.manager));\r\n        _;\r\n    }\r\n\r\n    function ChannelContract(\r\n        address manager_address,\r\n        address sender,\r\n        address client,\r\n        address receiver,\r\n        uint close_timeout,\r\n        uint settle_timeout,\r\n        uint audit_timeout,\r\n        address auditor\r\n    )\r\n    {\r\n        //allow creation only from manager contract\r\n        require(msg.sender == manager_address);\r\n        require (sender != receiver);\r\n        require (client != receiver);\r\n        require (audit_timeout >= 0);\r\n        require (settle_timeout > 0);\r\n        require (close_timeout >= 0);\r\n\r\n        data.sender = sender;\r\n        data.client = client;\r\n        data.receiver = receiver;\r\n        data.auditor = auditor;\r\n        data.manager = ChannelManagerContract(manager_address);\r\n        data.close_timeout = close_timeout;\r\n        data.settle_timeout = settle_timeout;\r\n        data.audit_timeout = audit_timeout;\r\n        data.opened = block.number;\r\n    }\r\n\r\n    /// @notice Caller makes a deposit into their channel balance.\r\n    /// @param amount The amount caller wants to deposit.\r\n    /// @return True if deposit is successful.\r\n    function deposit(uint256 amount) returns (bool) {\r\n        bool success;\r\n        uint256 balance;\r\n\r\n        (success, balance) = data.deposit(amount);\r\n\r\n        if (success == true) {\r\n            ChannelNewBalance(data.manager.token(), msg.sender, balance, 0);\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /// @notice Get the address and balance of both partners in a channel.\r\n    /// @return The address and balance pairs.\r\n    function addressAndBalance()\r\n        constant\r\n        returns (\r\n        address sender,\r\n        address receiver,\r\n        uint balance)\r\n    {\r\n        sender = data.sender;\r\n        receiver = data.receiver;\r\n        balance = data.balance;\r\n    }\r\n\r\n    /// @notice Request to close the channel. \r\n    function request_close () {\r\n        data.request_close();\r\n        ChannelCloseRequested(msg.sender, data.closed);\r\n    }\r\n\r\n    /// @notice Close the channel. \r\n    function close (\r\n        uint nonce,\r\n        uint256 completed_transfers,\r\n        bytes signature\r\n    ) {\r\n        data.close(address(this), nonce, completed_transfers, signature);\r\n        ChannelClosed(msg.sender, data.closed);\r\n    }\r\n\r\n    /// @notice Settle the transfers and balances of the channel and pay out to\r\n    ///         each participant. Can only be called after the channel is closed\r\n    ///         and only after the number of blocks in the settlement timeout\r\n    ///         have passed.\r\n    function settle() {\r\n        data.settle();\r\n        ChannelSettled(data.settled);\r\n    }\r\n\r\n    /// @notice Settle the transfers and balances of the channel and pay out to\r\n    ///         each participant. Can only be called after the channel is closed\r\n    ///         and only after the number of blocks in the settlement timeout\r\n    ///         have passed.\r\n    function audit(address auditor) onlyManager {\r\n        data.audit(auditor);\r\n        ChannelAudited(data.audited);\r\n    }\r\n\r\n    function destroy() onlyManager {\r\n        require(data.settled > 0);\r\n        require(data.audited > 0 || block.number > data.closed + data.audit_timeout);\r\n        selfdestruct(0);\r\n    }\r\n\r\n    function sender() constant returns (address) {\r\n        return data.sender;\r\n    }\r\n\r\n    function receiver() constant returns (address) {\r\n        return data.receiver;\r\n    }\r\n\r\n    function client() constant returns (address) {\r\n        return data.client;\r\n    }\r\n\r\n    function auditor() constant returns (address) {\r\n        return data.auditor;\r\n    }\r\n\r\n    function closeTimeout() constant returns (uint) {\r\n        return data.close_timeout;\r\n    }\r\n\r\n    function settleTimeout() constant returns (uint) {\r\n        return data.settle_timeout;\r\n    }\r\n\r\n    function auditTimeout() constant returns (uint) {\r\n        return data.audit_timeout;\r\n    }\r\n\r\n    /// @return Returns the address of the manager.\r\n    function manager() constant returns (address) {\r\n        return data.manager;\r\n    }\r\n\r\n    function balance() constant returns (uint) {\r\n        return data.balance;\r\n    }\r\n\r\n    function nonce() constant returns (uint) {\r\n        return data.nonce;\r\n    }\r\n\r\n    function completedTransfers() constant returns (uint) {\r\n        return data.completed_transfers;\r\n    }\r\n\r\n    /// @notice Returns the block number for when the channel was opened.\r\n    /// @return The block number for when the channel was opened.\r\n    function opened() constant returns (uint) {\r\n        return data.opened;\r\n    }\r\n\r\n    function closeRequested() constant returns (uint) {\r\n        return data.close_requested;\r\n    }\r\n\r\n    function closed() constant returns (uint) {\r\n        return data.closed;\r\n    }\r\n\r\n    function settled() constant returns (uint) {\r\n        return data.settled;\r\n    }\r\n\r\n    function audited() constant returns (uint) {\r\n        return data.audited;\r\n    }\r\n\r\n    function () { revert(); }\r\n}\r\n\r\n\r\ncontract ChannelManagerContract {\r\n\r\n    event ChannelNew(\r\n        address channel_address,\r\n        address indexed sender,\r\n        address client,\r\n        address indexed receiver,\r\n        uint close_timeout,\r\n        uint settle_timeout,\r\n        uint audit_timeout\r\n    );\r\n\r\n    event ChannelDeleted(\r\n        address channel_address,\r\n        address indexed sender,\r\n        address indexed receiver\r\n    );\r\n\r\n    StandardToken public token;\r\n    ChannelApi public channel_api;\r\n\r\n    function ChannelManagerContract(address token_address, address channel_api_address) {\r\n        require(token_address != 0);\r\n        require(channel_api_address != 0);\r\n        token = StandardToken(token_address);\r\n        channel_api = ChannelApi(channel_api_address);\r\n    }\r\n\r\n    /// @notice Create a new channel from msg.sender to receiver\r\n    /// @param receiver The address of the receiver\r\n    /// @param settle_timeout The settle timeout in blocks\r\n    /// @return The address of the newly created ChannelContract.\r\n    function newChannel(\r\n        address client, \r\n        address receiver, \r\n        uint close_timeout,\r\n        uint settle_timeout,\r\n        uint audit_timeout,\r\n        address auditor\r\n    )\r\n        returns (address)\r\n    {\r\n        address new_channel_address = new ChannelContract(\r\n            this,\r\n            msg.sender,\r\n            client,\r\n            receiver,\r\n            close_timeout,\r\n            settle_timeout,\r\n            audit_timeout,\r\n            auditor\r\n        );\r\n\r\n        ChannelNew(\r\n            new_channel_address, \r\n            msg.sender, \r\n            client, \r\n            receiver,\r\n            close_timeout,\r\n            settle_timeout,\r\n            audit_timeout\r\n        );\r\n\r\n        return new_channel_address;\r\n    }\r\n\r\n    function auditReport(address contract_address, uint total, uint fraud) {\r\n        ChannelContract ch = ChannelContract(contract_address);\r\n        require(ch.manager() == address(this));\r\n        address auditor = msg.sender;\r\n        ch.audit(auditor);\r\n        channel_api.applyRuntimeUpdate(ch.sender(), ch.receiver(), total, fraud);\r\n    }\r\n    \r\n    function destroyChannel(address channel_address) {\r\n        ChannelContract ch = ChannelContract(channel_address);\r\n        require(ch.manager() == address(this));\r\n        ChannelDeleted(channel_address,ch.sender(),ch.receiver());\r\n        ch.destroy();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ChannelLibrary.Data storage\"},{\"name\":\"auditor\",\"type\":\"address\"}],\"name\":\"audit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ChannelLibrary.Data storage\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"channel_address\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"completed_transfers\",\"type\":\"uint256\"}],\"name\":\"hashState\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ChannelLibrary.Data storage\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ChannelLibrary.Data storage\"}],\"name\":\"request_close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ChannelLibrary.Data storage\"},{\"name\":\"transfer_id\",\"type\":\"address\"},{\"name\":\"channel_address\",\"type\":\"address\"},{\"name\":\"sum\",\"type\":\"uint256\"},{\"name\":\"lock_data\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"validateTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transfer_id\",\"type\":\"address\"},{\"name\":\"channel_address\",\"type\":\"address\"},{\"name\":\"lock_data\",\"type\":\"bytes\"},{\"name\":\"sum\",\"type\":\"uint256\"}],\"name\":\"hashTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"ChannelLibrary.Data storage\"},{\"name\":\"channel_address\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"completed_transfers\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChannelLibrary","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"ECRecovery:6a440a4074ff95757d0830719c1b0b5da3ea380c","SwarmSource":"bzzr://271546ef683ad33987441d477fe83dac269b84b2e4ea7047b8931b3153866dc1"}]}