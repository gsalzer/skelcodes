{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n    function balanceOf(address who) constant returns (uint);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isMultiSigWallet = false;\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n    address destination;\r\n    uint value;\r\n    bytes data;\r\n    bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (ownerCount > MAX_OWNER_COUNT) throw;\r\n        if (_required > ownerCount) throw;\r\n        if (_required == 0) throw;\r\n        if (ownerCount == 0) throw;\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n    payable\r\n    {\r\n        if (msg.value > 0)\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n    public\r\n    validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0) throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        isMultiSigWallet = true;\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n    public\r\n    onlyWallet\r\n    ownerDoesNotExist(owner)\r\n    notNull(owner)\r\n    validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n    public\r\n    onlyWallet\r\n    ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n        if (owners[i] == owner) {\r\n            owners[i] = owners[owners.length - 1];\r\n            break;\r\n        }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n        changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param newOwner Address of new owner.\r\n    /// @param index the indx of the owner to be replaced\r\n    function replaceOwnerIndexed(address owner, address newOwner, uint index)\r\n    public\r\n    onlyWallet\r\n    ownerExists(owner)\r\n    ownerDoesNotExist(newOwner)\r\n    {\r\n        if (owners[index] != owner) throw;\r\n        owners[index] = newOwner;\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n    public\r\n    onlyWallet\r\n    validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n    public\r\n    returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    transactionExists(transactionId)\r\n    notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n            count += 1;\r\n            if (count == required)\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n    internal\r\n    notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n            Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n    internal\r\n    notNull(destination)\r\n    returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n        destination: destination,\r\n        value: value,\r\n        data: data,\r\n        executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n        if (confirmations[transactionId][owners[i]])\r\n        count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n        if ((pending && !transactions[i].executed) ||\r\n        (executed && transactions[i].executed))\r\n        count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n    public\r\n    constant\r\n    returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n    public\r\n    constant\r\n    returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n        if (confirmations[transactionId][owners[i]]) {\r\n            confirmationsTemp[count] = owners[i];\r\n            count += 1;\r\n        }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n        _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n        if ((pending && !transactions[i].executed) ||\r\n        (executed && transactions[i].executed))\r\n        {\r\n            transactionIdsTemp[count] = i;\r\n            count += 1;\r\n        }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n        _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n\r\n}\r\n\r\ncontract UpgradeAgent is SafeMath {\r\n    address public owner;\r\n\r\n    bool public isUpgradeAgent;\r\n\r\n    function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n    function finalizeUpgrade() public;\r\n\r\n    function setOriginalSupply() public;\r\n}\r\n\r\n/// @title Time-locked vault of tokens allocated to DecentBet after 365 days\r\ncontract DecentBetVault is SafeMath {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isDecentBetVault = false;\r\n\r\n    DecentBetToken decentBetToken;\r\n\r\n    address decentBetMultisig;\r\n\r\n    uint256 unlockedAtTime;\r\n\r\n    // smaller lock for testing\r\n    uint256 public constant timeOffset = 1 years;\r\n\r\n    /// @notice Constructor function sets the DecentBet Multisig address and\r\n    /// total number of locked tokens to transfer\r\n    function DecentBetVault(address _decentBetMultisig) /** internal */ {\r\n        if (_decentBetMultisig == 0x0) throw;\r\n        decentBetToken = DecentBetToken(msg.sender);\r\n        decentBetMultisig = _decentBetMultisig;\r\n        isDecentBetVault = true;\r\n\r\n        // 1 year later\r\n        unlockedAtTime = safeAdd(getTime(), timeOffset);\r\n    }\r\n\r\n    /// @notice Transfer locked tokens to Decent.bet's multisig wallet\r\n    function unlock() external {\r\n        // Wait your turn!\r\n        if (getTime() < unlockedAtTime) throw;\r\n        // Will fail if allocation (and therefore toTransfer) is 0.\r\n        if (!decentBetToken.transfer(decentBetMultisig, decentBetToken.balanceOf(this))) throw;\r\n    }\r\n\r\n    function getTime() internal returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    // disallow ETH payments to TimeVault\r\n    function() payable {\r\n        throw;\r\n    }\r\n\r\n}\r\n\r\n\r\n/// @title DecentBet crowdsale contract\r\ncontract DecentBetToken is SafeMath, ERC20 {\r\n\r\n    // flag to determine if address is for a real contract or not\r\n    bool public isDecentBetToken = false;\r\n\r\n    // State machine\r\n    enum State{Waiting, PreSale, CommunitySale, PublicSale, Success}\r\n\r\n    // Token information\r\n    string public constant name = \"Decent.Bet Token\";\r\n\r\n    string public constant symbol = \"DBET\";\r\n\r\n    uint256 public constant decimals = 18;  // decimal places\r\n\r\n    uint256 public constant housePercentOfTotal = 10;\r\n\r\n    uint256 public constant vaultPercentOfTotal = 18;\r\n\r\n    uint256 public constant bountyPercentOfTotal = 2;\r\n\r\n    uint256 public constant crowdfundPercentOfTotal = 70;\r\n\r\n    uint256 public constant hundredPercent = 100;\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Authorized addresses\r\n    address public team;\r\n\r\n    // Upgrade information\r\n    bool public finalizedUpgrade = false;\r\n\r\n    address public upgradeMaster;\r\n\r\n    UpgradeAgent public upgradeAgent;\r\n\r\n    uint256 public totalUpgraded;\r\n\r\n    // Crowdsale information\r\n    bool public finalizedCrowdfunding = false;\r\n\r\n    // Whitelisted addresses for pre-sale\r\n    address[] public preSaleWhitelist;\r\n    mapping (address => bool) public preSaleAllowed;\r\n\r\n    // Whitelisted addresses from community\r\n    address[] public communitySaleWhitelist;\r\n    mapping (address => bool) public communitySaleAllowed;\r\n    uint[2] public communitySaleCap = [100000 ether, 200000 ether];\r\n    mapping (address => uint[2]) communitySalePurchases;\r\n\r\n    uint256 public preSaleStartTime; // Pre-sale start block timestamp\r\n    uint256 public fundingStartTime; // crowdsale start block timestamp\r\n    uint256 public fundingEndTime; // crowdsale end block timestamp\r\n    // DBET:ETH exchange rate - Needs to be updated at time of ICO.\r\n    // Price of ETH/0.125. For example: If ETH/USD = 300, it would be 2400 DBETs per ETH.\r\n    uint256 public baseTokensPerEther;\r\n    uint256 public tokenCreationMax = safeMul(250000 ether, 1000); // A maximum of 250M DBETs can be minted during ICO.\r\n\r\n    // Amount of tokens alloted to pre-sale investors.\r\n    uint256 public preSaleAllotment;\r\n    // Address of pre-sale investors.\r\n    address public preSaleAddress;\r\n\r\n    // for testing on testnet\r\n    //uint256 public constant tokenCreationMax = safeMul(10 ether, baseTokensPerEther);\r\n    //uint256 public constant tokenCreationMin = safeMul(3 ether, baseTokensPerEther);\r\n\r\n    address public decentBetMultisig;\r\n\r\n    DecentBetVault public timeVault; // DecentBet's time-locked vault\r\n\r\n    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    event UpgradeFinalized(address sender, address upgradeAgent);\r\n\r\n    event UpgradeAgentSet(address agent);\r\n\r\n    // Allow only the team address to continue\r\n    modifier onlyTeam() {\r\n        if(msg.sender != team) throw;\r\n        _;\r\n    }\r\n\r\n    function DecentBetToken(address _decentBetMultisig,\r\n    address _upgradeMaster, address _team,\r\n    uint256 _baseTokensPerEther, uint256 _fundingStartTime,\r\n    uint256 _fundingEndTime) {\r\n\r\n        if (_decentBetMultisig == 0) throw;\r\n        if (_team == 0) throw;\r\n        if (_upgradeMaster == 0) throw;\r\n        if (_baseTokensPerEther == 0) throw;\r\n\r\n        // For testing/dev\r\n        //         if(_fundingStartTime == 0) throw;\r\n        // Crowdsale can only officially start during/after the current block timestamp.\r\n        if (_fundingStartTime < getTime()) throw;\r\n\r\n        if (_fundingEndTime <= _fundingStartTime) throw;\r\n\r\n        isDecentBetToken = true;\r\n\r\n        upgradeMaster = _upgradeMaster;\r\n        team = _team;\r\n\r\n        baseTokensPerEther = _baseTokensPerEther;\r\n\r\n        preSaleStartTime = _fundingStartTime - 1 days;\r\n        fundingStartTime = _fundingStartTime;\r\n        fundingEndTime = _fundingEndTime;\r\n\r\n        // Pre-sale issuance from pre-sale contract\r\n        // 0x7be601aab2f40cc23653965749b84e5cb8cfda43\r\n        preSaleAddress = 0x87f7beeda96216ec2a325e417a45ed262495686b;\r\n        preSaleAllotment = 45000000 ether;\r\n\r\n        balances[preSaleAddress] = preSaleAllotment;\r\n        totalSupply = safeAdd(totalSupply, preSaleAllotment);\r\n\r\n        timeVault = new DecentBetVault(_decentBetMultisig);\r\n        if (!timeVault.isDecentBetVault()) throw;\r\n\r\n        decentBetMultisig = _decentBetMultisig;\r\n        if (!MultiSigWallet(decentBetMultisig).isMultiSigWallet()) throw;\r\n    }\r\n\r\n    function balanceOf(address who) constant returns (uint) {\r\n        return balances[who];\r\n    }\r\n\r\n    /// @notice Transfer `value` DBET tokens from sender's account\r\n    /// `msg.sender` to provided account address `to`.\r\n    /// @notice This function is disabled during the funding.\r\n    /// @dev Required state: Success\r\n    /// @param to The address of the recipient\r\n    /// @param value The number of DBETs to transfer\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint256 value) returns (bool ok) {\r\n        if (getState() != State.Success) throw;\r\n        // Abort if crowdfunding was not a success.\r\n        uint256 senderBalance = balances[msg.sender];\r\n        if (senderBalance >= value && value > 0) {\r\n            senderBalance = safeSub(senderBalance, value);\r\n            balances[msg.sender] = senderBalance;\r\n            balances[to] = safeAdd(balances[to], value);\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice Transfer `value` DBET tokens from sender 'from'\r\n    /// to provided account address `to`.\r\n    /// @notice This function is disabled during the funding.\r\n    /// @dev Required state: Success\r\n    /// @param from The address of the sender\r\n    /// @param to The address of the recipient\r\n    /// @param value The number of DBETs to transfer\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address from, address to, uint256 value) returns (bool ok) {\r\n        if (getState() != State.Success) throw;\r\n        // Abort if not in Success state.\r\n        // protect against wrapping uints\r\n        if (balances[from] >= value &&\r\n        allowed[from][msg.sender] >= value &&\r\n        safeAdd(balances[to], value) > balances[to])\r\n        {\r\n            balances[to] = safeAdd(balances[to], value);\r\n            balances[from] = safeSub(balances[from], value);\r\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], value);\r\n            Transfer(from, to, value);\r\n            return true;\r\n        }\r\n        else {return false;}\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `value` tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address spender, uint256 value) returns (bool ok) {\r\n        if (getState() != State.Success) throw;\r\n        // Abort if not in Success state.\r\n        allowed[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /// @param owner The address of the account owning tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address owner, address spender) constant returns (uint) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    // Token upgrade functionality\r\n\r\n    /// @notice Upgrade tokens to the new token contract.\r\n    /// @dev Required state: Success\r\n    /// @param value The number of tokens to upgrade\r\n    function upgrade(uint256 value) external {\r\n        if (getState() != State.Success) throw;\r\n        // Abort if not in Success state.\r\n        if (upgradeAgent.owner() == 0x0) throw;\r\n        // need a real upgradeAgent address\r\n        if (finalizedUpgrade) throw;\r\n        // cannot upgrade if finalized\r\n\r\n        // Validate input value.\r\n        if (value == 0) throw;\r\n        if (value > balances[msg.sender]) throw;\r\n\r\n        // update the balances here first before calling out (reentrancy)\r\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n        totalSupply = safeSub(totalSupply, value);\r\n        totalUpgraded = safeAdd(totalUpgraded, value);\r\n        upgradeAgent.upgradeFrom(msg.sender, value);\r\n        Upgrade(msg.sender, upgradeAgent, value);\r\n    }\r\n\r\n    /// @notice Set address of upgrade target contract and enable upgrade\r\n    /// process.\r\n    /// @dev Required state: Success\r\n    /// @param agent The address of the UpgradeAgent contract\r\n    function setUpgradeAgent(address agent) external {\r\n        if (getState() != State.Success) throw;\r\n        // Abort if not in Success state.\r\n        if (agent == 0x0) throw;\r\n        // don't set agent to nothing\r\n        if (msg.sender != upgradeMaster) throw;\r\n        // Only a master can designate the next agent\r\n        upgradeAgent = UpgradeAgent(agent);\r\n        if (!upgradeAgent.isUpgradeAgent()) throw;\r\n        // this needs to be called in success condition to guarantee the invariant is true\r\n        upgradeAgent.setOriginalSupply();\r\n        UpgradeAgentSet(upgradeAgent);\r\n    }\r\n\r\n    /// @notice Set address of upgrade target contract and enable upgrade\r\n    /// process.\r\n    /// @dev Required state: Success\r\n    /// @param master The address that will manage upgrades, not the upgradeAgent contract address\r\n    function setUpgradeMaster(address master) external {\r\n        if (getState() != State.Success) throw;\r\n        // Abort if not in Success state.\r\n        if (master == 0x0) throw;\r\n        if (msg.sender != upgradeMaster) throw;\r\n        // Only a master can designate the next master\r\n        upgradeMaster = master;\r\n    }\r\n\r\n    /// @notice finalize the upgrade\r\n    /// @dev Required state: Success\r\n    function finalizeUpgrade() external {\r\n        if (getState() != State.Success) throw;\r\n        // Abort if not in Success state.\r\n        if (upgradeAgent.owner() == 0x0) throw;\r\n        // we need a valid upgrade agent\r\n        if (msg.sender != upgradeMaster) throw;\r\n        // only upgradeMaster can finalize\r\n        if (finalizedUpgrade) throw;\r\n        // can't finalize twice\r\n\r\n        finalizedUpgrade = true;\r\n        // prevent future upgrades\r\n\r\n        upgradeAgent.finalizeUpgrade();\r\n        // call finalize upgrade on new contract\r\n        UpgradeFinalized(msg.sender, upgradeAgent);\r\n    }\r\n\r\n    // Allow users to purchase by sending Ether to the contract\r\n    function() payable {\r\n        invest();\r\n    }\r\n\r\n    // Updates tokens per ETH rates before the pre-sale\r\n    function updateBaseTokensPerEther(uint _baseTokensPerEther) onlyTeam {\r\n        if(getState() != State.Waiting) throw;\r\n\r\n        baseTokensPerEther = _baseTokensPerEther;\r\n    }\r\n\r\n    // Returns the current rate after adding bonuses for the time period\r\n    function getTokensAtCurrentRate(uint weiValue) constant returns (uint) {\r\n        /* Pre-sale */\r\n        if(getTime() >= preSaleStartTime && getTime() < fundingStartTime) {\r\n            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\r\n        }\r\n\r\n        /* Community sale */\r\n        else if(getTime() >= fundingStartTime && getTime() < fundingStartTime + 1 days) {\r\n            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\r\n        } else if(getTime() >= (fundingStartTime + 1 days) && getTime() < fundingStartTime + 2 days) {\r\n            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\r\n        }\r\n\r\n        /* Public sale */\r\n        else if(getTime() >= (fundingStartTime + 2 days) && getTime() < fundingStartTime + 1 weeks) {\r\n            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 110)), 100); // 10% bonus\r\n        } else if(getTime() >= fundingStartTime + 1 weeks && getTime() < fundingStartTime + 2 weeks) {\r\n            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 105)), 100); // 5% bonus\r\n        } else if(getTime() >= fundingStartTime + 2 weeks && getTime() < fundingEndTime) {\r\n            return safeMul(weiValue, baseTokensPerEther); // 0% bonus\r\n        }\r\n    }\r\n\r\n    // Allows the owner to add an address to the pre-sale whitelist.\r\n    function addToPreSaleWhitelist(address _address) onlyTeam {\r\n\r\n        // Add to pre-sale whitelist only if state is Waiting right now.\r\n        if(getState() != State.Waiting) throw;\r\n\r\n        // Address already added to whitelist.\r\n        if (preSaleAllowed[_address]) throw;\r\n\r\n        preSaleWhitelist.push(_address);\r\n        preSaleAllowed[_address] = true;\r\n    }\r\n\r\n    // Allows the owner to add an address to the community whitelist.\r\n    function addToCommunitySaleWhitelist(address[] addresses) onlyTeam {\r\n\r\n        // Add to community sale whitelist only if state is Waiting or Presale right now.\r\n        if(getState() != State.Waiting &&\r\n        getState() != State.PreSale) throw;\r\n\r\n        for(uint i = 0; i < addresses.length; i++) {\r\n            if(!communitySaleAllowed[addresses[i]]) {\r\n                communitySaleWhitelist.push(addresses[i]);\r\n                communitySaleAllowed[addresses[i]] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Create tokens when funding is active.\r\n    /// @dev Required state: Funding\r\n    /// @dev State transition: -> Funding Success (only if cap reached)\r\n    function invest() payable {\r\n\r\n        // Abort if not in PreSale, CommunitySale or PublicSale state.\r\n        if (getState() != State.PreSale &&\r\n        getState() != State.CommunitySale &&\r\n        getState() != State.PublicSale) throw;\r\n\r\n        // User hasn't been whitelisted for pre-sale.\r\n        if(getState() == State.PreSale && !preSaleAllowed[msg.sender]) throw;\r\n\r\n        // User hasn't been whitelisted for community sale.\r\n        if(getState() == State.CommunitySale && !communitySaleAllowed[msg.sender]) throw;\r\n\r\n        // Do not allow creating 0 tokens.\r\n        if (msg.value == 0) throw;\r\n\r\n        // multiply by exchange rate to get newly created token amount\r\n        uint256 createdTokens = getTokensAtCurrentRate(msg.value);\r\n\r\n        allocateTokens(msg.sender, createdTokens);\r\n    }\r\n\r\n    // Allocates tokens to an investors' address\r\n    function allocateTokens(address _address, uint amount) internal {\r\n\r\n        // we are creating tokens, so increase the totalSupply.\r\n        totalSupply = safeAdd(totalSupply, amount);\r\n\r\n        // don't go over the limit!\r\n        if (totalSupply > tokenCreationMax) throw;\r\n\r\n        // Don't allow community whitelisted addresses to purchase more than their cap.\r\n        if(getState() == State.CommunitySale) {\r\n            // Community sale day 1.\r\n            // Whitelisted addresses can purchase a maximum of 100k DBETs (10k USD).\r\n            if(getTime() >= fundingStartTime &&\r\n            getTime() < fundingStartTime + 1 days) {\r\n                if(safeAdd(communitySalePurchases[msg.sender][0], amount) > communitySaleCap[0])\r\n                throw;\r\n                else\r\n                communitySalePurchases[msg.sender][0] =\r\n                safeAdd(communitySalePurchases[msg.sender][0], amount);\r\n            }\r\n\r\n            // Community sale day 2.\r\n            // Whitelisted addresses can purchase a maximum of 200k DBETs (20k USD).\r\n            else if(getTime() >= (fundingStartTime + 1 days) &&\r\n            getTime() < fundingStartTime + 2 days) {\r\n                if(safeAdd(communitySalePurchases[msg.sender][1], amount) > communitySaleCap[1])\r\n                throw;\r\n                else\r\n                communitySalePurchases[msg.sender][1] =\r\n                safeAdd(communitySalePurchases[msg.sender][1], amount);\r\n            }\r\n        }\r\n\r\n        // Assign new tokens to the sender.\r\n        balances[_address] = safeAdd(balances[_address], amount);\r\n\r\n        // Log token creation event\r\n        Transfer(0, _address, amount);\r\n    }\r\n\r\n    /// @notice Finalize crowdfunding\r\n    /// @dev If cap was reached or crowdfunding has ended then:\r\n    /// create DBET for the DecentBet Multisig and team,\r\n    /// transfer ETH to the DecentBet Multisig address.\r\n    /// @dev Required state: Success\r\n    function finalizeCrowdfunding() external {\r\n        // Abort if not in Funding Success state.\r\n        if (getState() != State.Success) throw;\r\n        // don't finalize unless we won\r\n        if (finalizedCrowdfunding) throw;\r\n        // can't finalize twice (so sneaky!)\r\n\r\n        // prevent more creation of tokens\r\n        finalizedCrowdfunding = true;\r\n\r\n        // Founder's supply : 18% of total goes to vault, time locked for 6 months\r\n        uint256 vaultTokens = safeDiv(safeMul(totalSupply, vaultPercentOfTotal), crowdfundPercentOfTotal);\r\n        balances[timeVault] = safeAdd(balances[timeVault], vaultTokens);\r\n        Transfer(0, timeVault, vaultTokens);\r\n\r\n        // House: 10% of total goes to Decent.bet for initial house setup\r\n        uint256 houseTokens = safeDiv(safeMul(totalSupply, housePercentOfTotal), crowdfundPercentOfTotal);\r\n        balances[timeVault] = safeAdd(balances[decentBetMultisig], houseTokens);\r\n        Transfer(0, decentBetMultisig, houseTokens);\r\n\r\n        // Bounties: 2% of total goes to Decent bet for bounties\r\n        uint256 bountyTokens = safeDiv(safeMul(totalSupply, bountyPercentOfTotal), crowdfundPercentOfTotal);\r\n        balances[decentBetMultisig] = safeAdd(balances[decentBetMultisig], bountyTokens);\r\n        Transfer(0, decentBetMultisig, bountyTokens);\r\n\r\n        // Transfer ETH to the DBET Multisig address.\r\n        if (!decentBetMultisig.send(this.balance)) throw;\r\n    }\r\n\r\n    // Interface marker\r\n    function isDecentBetCrowdsale() returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function getTime() constant returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    /// @notice This manages the crowdfunding state machine\r\n    /// We make it a function and do not assign the result to a variable\r\n    /// So there is no chance of the variable being stale\r\n    function getState() public constant returns (State){\r\n        /* Successful if crowdsale was finalized */\r\n        if(finalizedCrowdfunding) return State.Success;\r\n\r\n        /* Pre-sale not started */\r\n        else if (getTime() < preSaleStartTime) return State.Waiting;\r\n\r\n        /* Pre-sale */\r\n        else if (getTime() >= preSaleStartTime &&\r\n        getTime() < fundingStartTime &&\r\n        totalSupply < tokenCreationMax) return State.PreSale;\r\n\r\n        /* Community sale */\r\n        else if (getTime() >= fundingStartTime &&\r\n        getTime() < fundingStartTime + 2 days &&\r\n        totalSupply < tokenCreationMax) return State.CommunitySale;\r\n\r\n        /* Public sale */\r\n        else if (getTime() >= (fundingStartTime + 2 days) &&\r\n        getTime() < fundingEndTime &&\r\n        totalSupply < tokenCreationMax) return State.PublicSale;\r\n\r\n        /* Success */\r\n        else if (getTime() >= fundingEndTime ||\r\n        totalSupply == tokenCreationMax) return State.Success;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"preSaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultPercentOfTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiValue\",\"type\":\"uint256\"}],\"name\":\"getTokensAtCurrentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdfundPercentOfTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdfunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleAllotment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"communitySaleWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"communitySaleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"communitySaleAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDecentBetToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedCrowdfunding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseTokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hundredPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"housePercentOfTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decentBetMultisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"isDecentBetCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addToPreSaleWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"preSaleWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseTokensPerEther\",\"type\":\"uint256\"}],\"name\":\"updateBaseTokensPerEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"addToCommunitySaleWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"preSaleAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyPercentOfTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_decentBetMultisig\",\"type\":\"address\"},{\"name\":\"_upgradeMaster\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"address\"},{\"name\":\"_baseTokensPerEther\",\"type\":\"uint256\"},{\"name\":\"_fundingStartTime\",\"type\":\"uint256\"},{\"name\":\"_fundingEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"upgradeAgent\",\"type\":\"address\"}],\"name\":\"UpgradeFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"DecentBetToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c87b1bf162c1719e3ffdf34995d1853192d6633b000000000000000000000000818e6a1cdccc7db87e991d979aa8d3eec199b868000000000000000000000000818e6a1cdccc7db87e991d979aa8d3eec199b86800000000000000000000000000000000000000000000000000000000000008e80000000000000000000000000000000000000000000000000000000059c614800000000000000000000000000000000000000000000000000000000059eafe80","Library":"","SwarmSource":"bzzr://8697dadd41b5838ed936227d9d121e93966f6622d6fc34db3d94461b77986ea0"}]}