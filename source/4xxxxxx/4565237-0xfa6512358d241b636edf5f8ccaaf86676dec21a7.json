{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.4;\r\n\r\n/**\r\n * The ENS registry contract.\r\n */\r\ncontract ENS {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    struct Record {\r\n        address owner;\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    mapping(bytes32=>Record) records;\r\n\r\n    // Permits modifications only by the owner of the specified node.\r\n    modifier only_owner(bytes32 node) {\r\n        if (records[node].owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructs a new ENS registrar.\r\n     */\r\n    function ENS() {\r\n        records[0].owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Returns the address that owns the specified node.\r\n     */\r\n    function owner(bytes32 node) constant returns (address) {\r\n        return records[node].owner;\r\n    }\r\n\r\n    /**\r\n     * Returns the address of the resolver for the specified node.\r\n     */\r\n    function resolver(bytes32 node) constant returns (address) {\r\n        return records[node].resolver;\r\n    }\r\n\r\n    /**\r\n     * Returns the TTL of a node, and any records associated with it.\r\n     */\r\n    function ttl(bytes32 node) constant returns (uint64) {\r\n        return records[node].ttl;\r\n    }\r\n\r\n    /**\r\n     * Transfers ownership of a node to a new address. May only be called by the current\r\n     * owner of the node.\r\n     * @param node The node to transfer ownership of.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setOwner(bytes32 node, address owner) only_owner(node) {\r\n        Transfer(node, owner);\r\n        records[node].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\r\n     * called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) {\r\n        var subnode = sha3(node, label);\r\n        NewOwner(node, label, owner);\r\n        records[subnode].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolver address for the specified node.\r\n     * @param node The node to update.\r\n     * @param resolver The address of the resolver.\r\n     */\r\n    function setResolver(bytes32 node, address resolver) only_owner(node) {\r\n        NewResolver(node, resolver);\r\n        records[node].resolver = resolver;\r\n    }\r\n\r\n    /**\r\n     * Sets the TTL for the specified node.\r\n     * @param node The node to update.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setTTL(bytes32 node, uint64 ttl) only_owner(node) {\r\n        NewTTL(node, ttl);\r\n        records[node].ttl = ttl;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev A basic interface for ENS resolvers.\r\n */\r\ncontract Resolver {\r\n  function supportsInterface(bytes4 interfaceID) public pure returns (bool);\r\n  function addr(bytes32 node) public view returns (address);\r\n  function setAddr(bytes32 node, address addr) public;\r\n}\r\n\r\ncontract RegistrarInterface {\r\n  event OwnerChanged(bytes32 indexed label, address indexed oldOwner, address indexed newOwner);\r\n  event DomainConfigured(bytes32 indexed label);\r\n  event DomainUnlisted(bytes32 indexed label);\r\n  event NewRegistration(bytes32 indexed label, string subdomain, address indexed owner, address indexed referrer, uint price);\r\n  event RentPaid(bytes32 indexed label, string subdomain, uint amount, uint expirationDate);\r\n\r\n  // InterfaceID of these four methods is 0xc1b15f5a\r\n  function query(bytes32 label, string subdomain) view returns(string domain, uint signupFee, uint rent, uint referralFeePPM);\r\n  function register(bytes32 label, string subdomain, address owner, address referrer, address resolver) public payable;\r\n\r\n  function rentDue(bytes32 label, string subdomain) public view returns(uint timestamp);\r\n  function payRent(bytes32 label, string subdomain) public payable;\r\n}\r\n/**\r\n * @dev Implements an ENS registrar that sells subdomains on behalf of their owners.\r\n *\r\n * Users may register a subdomain by calling `register` with the name of the domain\r\n * they wish to register under, and the label hash of the subdomain they want to\r\n * register. They must also specify the new owner of the domain, and the referrer,\r\n * who is paid an optional finder's fee. The registrar then configures a simple\r\n * default resolver, which resolves `addr` lookups to the new owner, and sets\r\n * the `owner` account as the owner of the subdomain in ENS.\r\n *\r\n * New domains may be added by calling `configureDomain`, then transferring\r\n * ownership in the ENS registry to this contract. Ownership in the contract\r\n * may be transferred using `transfer`, and a domain may be unlisted for sale\r\n * using `unlistDomain`. There is (deliberately) no way to recover ownership\r\n * in ENS once the name is transferred to this registrar.\r\n *\r\n * Critically, this contract does not check two key properties of a listed domain:\r\n *\r\n * - Is the name UTS46 normalised?\r\n * - Is the Deed held by an appropriate custodian contract?\r\n *\r\n * User applications MUST check these two elements for each domain before\r\n * offering them to users for registration.\r\n *\r\n * Applications should additionally check that the domains they are offering to\r\n * register are controlled by this registrar, since calls to `register` will\r\n * fail if this is not the case.\r\n */\r\ncontract SubdomainRegistrar is RegistrarInterface {\r\n  // namehash('eth')\r\n  bytes32 constant public TLD_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\r\n\r\n  ENS public ens;\r\n\r\n  struct Domain {\r\n    string name;\r\n    address owner;\r\n    uint price;\r\n    uint referralFeePPM;\r\n  }\r\n\r\n  mapping(bytes32=>Domain) domains;\r\n\r\n  function SubdomainRegistrar(ENS _ens) public {\r\n    ens = _ens;\r\n  }\r\n\r\n  /**\r\n   * @dev owner returns the address of the account that controls a domain.\r\n   *      Initially this is the owner of the name in ENS. If the name has been\r\n   *      transferred to this contract, then the internal mapping is consulted\r\n   *      to determine who controls it.\r\n   * @param label The label hash of the deed to check.\r\n   * @return The address owning the deed.\r\n   */\r\n  function owner(bytes32 label) public view returns(address ret) {\r\n      ret = ens.owner(keccak256(TLD_NODE, label));\r\n      if(ret == address(this)) {\r\n        ret = domains[label].owner;\r\n      }\r\n  }\r\n\r\n  modifier owner_only(bytes32 label) {\r\n      require(owner(label) == msg.sender);\r\n      _;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers internal control of a name to a new account. Does not update\r\n   *      ENS.\r\n   * @param name The name to transfer.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  function transfer(string name, address newOwner) public owner_only(keccak256(name)) {\r\n    var label = keccak256(name);\r\n    OwnerChanged(keccak256(name), domains[label].owner, newOwner);\r\n    domains[label].owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the resolver record for a name in ENS.\r\n   * @param name The name to set the resolver for.\r\n   * @param resolver The address of the resolver\r\n   */\r\n  function setResolver(string name, address resolver) public owner_only(keccak256(name)) {\r\n    var label = keccak256(name);\r\n    var node = keccak256(TLD_NODE, label);\r\n    ens.setResolver(node, resolver);\r\n  }\r\n\r\n  /**\r\n   * @dev Configures a domain for sale.\r\n   * @param name The name to configure.\r\n   * @param price The price in wei to charge for subdomain registrations\r\n   * @param referralFeePPM The referral fee to offer, in parts per million\r\n   */\r\n  function configureDomain(string name, uint price, uint referralFeePPM) public owner_only(keccak256(name)) {\r\n    var label = keccak256(name);\r\n    var domain = domains[label];\r\n\r\n    if(keccak256(domain.name) != label) {\r\n      // New listing\r\n      domain.name = name;\r\n    }\r\n    if(domain.owner != msg.sender) {\r\n      domain.owner = msg.sender;\r\n    }\r\n    domain.price = price;\r\n    domain.referralFeePPM = referralFeePPM;\r\n    DomainConfigured(label);\r\n  }\r\n\r\n  /**\r\n   * @dev Unlists a domain\r\n   * May only be called by the owner.\r\n   * @param name The name of the domain to unlist.\r\n   */\r\n  function unlistDomain(string name) public owner_only(keccak256(name)) {\r\n    var label = keccak256(name);\r\n    var domain = domains[label];\r\n    DomainUnlisted(label);\r\n\r\n    domain.name = '';\r\n    domain.owner = owner(label);\r\n    domain.price = 0;\r\n    domain.referralFeePPM = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns information about a subdomain.\r\n   * @param label The label hash for the domain.\r\n   * @param subdomain The label for the subdomain.\r\n   * @return domain The name of the domain, or an empty string if the subdomain\r\n   *                is unavailable.\r\n   * @return price The price to register a subdomain, in wei.\r\n   * @return rent The rent to retain a subdomain, in wei per second.\r\n   * @return referralFeePPM The referral fee for the dapp, in ppm.\r\n   */\r\n  function query(bytes32 label, string subdomain) view returns(string domain, uint price, uint rent, uint referralFeePPM) {\r\n    var node = keccak256(TLD_NODE, label);\r\n    var subnode = keccak256(node, keccak256(subdomain));\r\n\r\n    if(ens.owner(subnode) != 0) {\r\n      return ('', 0, 0, 0);\r\n    }\r\n\r\n    var data = domains[label];\r\n    return (data.name, data.price, 0, data.referralFeePPM);\r\n  }\r\n\r\n  /**\r\n   * @dev Registers a subdomain.\r\n   * @param label The label hash of the domain to register a subdomain of.\r\n   * @param subdomain The desired subdomain label.\r\n   * @param subdomainOwner The account that should own the newly configured subdomain.\r\n   * @param referrer The address of the account to receive the referral fee.\r\n   */\r\n  function register(bytes32 label, string subdomain, address subdomainOwner, address resolver, address referrer) public payable {\r\n    var domainNode = keccak256(TLD_NODE, label);\r\n    var subdomainLabel = keccak256(subdomain);\r\n\r\n    // Subdomain must not be registered already.\r\n    require(ens.owner(keccak256(domainNode, subdomainLabel)) == address(0));\r\n\r\n    var domain = domains[label];\r\n\r\n    // Domain must be available for registration\r\n    require(keccak256(domain.name) == label);\r\n\r\n    // User must have paid enough\r\n    require(msg.value >= domain.price);\r\n\r\n    // Send any extra back\r\n    if(msg.value > domain.price) {\r\n      msg.sender.transfer(msg.value - domain.price);\r\n    }\r\n\r\n    // Send any referral fee\r\n    var total = domain.price;\r\n    if(domain.referralFeePPM * domain.price > 0 && referrer != 0 && referrer != domain.owner) {\r\n      var referralFee = (domain.price * domain.referralFeePPM) / 1000000;\r\n      referrer.transfer(referralFee);\r\n      total -= referralFee;\r\n    }\r\n\r\n    // Send the registration fee\r\n    if(total > 0) {\r\n      domain.owner.transfer(total);\r\n    }\r\n\r\n    // Register the domain\r\n    if(subdomainOwner == 0) {\r\n      subdomainOwner = msg.sender;\r\n    }\r\n    doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\r\n\r\n    NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\r\n  }\r\n\r\n  function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\r\n    // Get the subdomain so we can configure it\r\n    ens.setSubnodeOwner(node, label, this);\r\n\r\n    var subnode = keccak256(node, label);\r\n    // Set the subdomain's resolver\r\n    ens.setResolver(subnode, resolver);\r\n\r\n    // Set the address record on the resolver\r\n    resolver.setAddr(subnode, subdomainOwner);\r\n\r\n    // Pass ownership of the new subdomain to the registrant\r\n    ens.setOwner(subnode, subdomainOwner);\r\n  }\r\n\r\n  function supportsInterface(bytes4 interfaceID) constant returns (bool) {\r\n    return (\r\n         (interfaceID == 0x01ffc9a7) // supportsInterface(bytes4)\r\n      || (interfaceID == 0xc1b15f5a) // RegistrarInterface\r\n    );\r\n  }\r\n\r\n  function rentDue(bytes32 label, string subdomain) public view returns(uint timestamp) {\r\n    return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n  }\r\n\r\n  function payRent(bytes32 label, string subdomain) public payable {\r\n    revert();\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"owner\",\"outputs\":[{\"name\":\"ret\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"query\",\"outputs\":[{\"name\":\"domain\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"rent\",\"type\":\"uint256\"},{\"name\":\"referralFeePPM\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"subdomain\",\"type\":\"string\"},{\"name\":\"subdomainOwner\",\"type\":\"address\"},{\"name\":\"resolver\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"rentDue\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TLD_NODE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"payRent\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"referralFeePPM\",\"type\":\"uint256\"}],\"name\":\"configureDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"unlistDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainUnlisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewRegistration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expirationDate\",\"type\":\"uint256\"}],\"name\":\"RentPaid\",\"type\":\"event\"}]","ContractName":"SubdomainRegistrar","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b","Library":"","SwarmSource":"bzzr://41a6435dd93573935c3578cc0f72e50c975bca17258053e2ace2e23c9954730d"}]}