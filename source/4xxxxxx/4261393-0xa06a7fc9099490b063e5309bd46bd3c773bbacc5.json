{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic authorization control functions, this simplifies\r\n/// and the implementation of \"user permissions\".\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed _by, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    /// account.\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerCandidate() {\r\n        if (msg.sender != newOwnerCandidate) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        require(_newOwnerCandidate != address(0));\r\n\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accept ownership transfer. This method needs to be called by the previously proposed owner.\r\n    function acceptOwnership() external onlyOwnerCandidate {\r\n        address previousOwner = owner;\r\n\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = address(0);\r\n\r\n        OwnershipTransferred(previousOwner, owner);\r\n    }\r\n}\r\n\r\n/// @title Math operations with safety checks\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n/// @title ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/issues/20)\r\ncontract ERC20 {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/// @title Basic ERC20 token contract implementation.\r\n/// @dev Based on OpenZeppelin's StandardToken.\r\ncontract BasicToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public totalSupply;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => uint256) balances;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\r\n            revert();\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    /// @param _owner address The address which owns the funds.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @return uint256 specifying the amount of tokens still available for the spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner address The address to query the the balance of.\r\n    /// @return uint256 representing the amount owned by the passed address.\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @dev transfer token to a specified address.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another.\r\n    /// @param _from address The address which you want to send tokens from.\r\n    /// @param _to address The address which you want to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/// @title Token holder contract.\r\ncontract TokenHolder is Ownable {\r\n    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n    /// @param _tokenAddress address The address of the ERC20 contract.\r\n    /// @param _amount uint256 The amount of tokens to be transferred.\r\n    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) onlyOwner returns (bool success) {\r\n        return ERC20(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}\r\n\r\n\r\n/// @title Kin token contract.\r\ncontract KinToken is Ownable, BasicToken, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Kin\";\r\n    string public constant symbol = \"KIN\";\r\n\r\n    // Using same decimal value as ETH (makes ETH-KIN conversion much easier).\r\n    uint8 public constant decimals = 18;\r\n\r\n    // States whether creating more tokens is allowed or not.\r\n    // Used during token sale.\r\n    bool public isMinting = true;\r\n\r\n    event MintingEnded();\r\n\r\n    modifier onlyDuringMinting() {\r\n        require(isMinting);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterMinting() {\r\n        require(!isMinting);\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Mint Kin tokens.\r\n    /// @param _to address Address to send minted Kin to.\r\n    /// @param _amount uint256 Amount of Kin tokens to mint.\r\n    function mint(address _to, uint256 _amount) external onlyOwner onlyDuringMinting {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n\r\n        Transfer(0x0, _to, _amount);\r\n    }\r\n\r\n    /// @dev End minting mode.\r\n    function endMinting() external onlyOwner {\r\n        if (isMinting == false) {\r\n            return;\r\n        }\r\n\r\n        isMinting = false;\r\n\r\n        MintingEnded();\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if still minting.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public onlyAfterMinting returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if still minting.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public onlyAfterMinting returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if still minting.\r\n    /// @param _from address The address which you want to send tokens from.\r\n    /// @param _to address The address which you want to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyAfterMinting returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n}\r\n\r\n\r\n/// @title Vesting trustee contract for Kin token.\r\ncontract VestingTrustee is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // Kin token contract.\r\n    KinToken public kin;\r\n\r\n    // Vesting grant for a speicifc holder.\r\n    struct Grant {\r\n        uint256 value;\r\n        uint256 start;\r\n        uint256 cliff;\r\n        uint256 end;\r\n        uint256 installmentLength; // In seconds.\r\n        uint256 transferred;\r\n        bool revokable;\r\n    }\r\n\r\n    // Holder to grant information mapping.\r\n    mapping (address => Grant) public grants;\r\n\r\n    // Total tokens available for vesting.\r\n    uint256 public totalVesting;\r\n\r\n    event NewGrant(address indexed _from, address indexed _to, uint256 _value);\r\n    event TokensUnlocked(address indexed _to, uint256 _value);\r\n    event GrantRevoked(address indexed _holder, uint256 _refund);\r\n\r\n    /// @dev Constructor that initializes the address of the Kin token contract.\r\n    /// @param _kin KinToken The address of the previously deployed Kin token contract.\r\n    function VestingTrustee(KinToken _kin) {\r\n        require(_kin != address(0));\r\n\r\n        kin = _kin;\r\n    }\r\n\r\n    /// @dev Grant tokens to a specified address. Please note, that the trustee must have enough ungranted tokens to\r\n    /// accomodate the new grant. Otherwise, the call with fail.\r\n    /// @param _to address The holder address.\r\n    /// @param _value uint256 The amount of tokens to be granted.\r\n    /// @param _start uint256 The beginning of the vesting period.\r\n    /// @param _cliff uint256 Duration of the cliff period (when the first installment is made).\r\n    /// @param _end uint256 The end of the vesting period.\r\n    /// @param _installmentLength uint256 The length of each vesting installment (in seconds).\r\n    /// @param _revokable bool Whether the grant is revokable or not.\r\n    function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\r\n        uint256 _installmentLength, bool _revokable)\r\n        external onlyOwner {\r\n\r\n        require(_to != address(0));\r\n        require(_to != address(this)); // Protect this contract from receiving a grant.\r\n        require(_value > 0);\r\n\r\n        // Require that every holder can be granted tokens only once.\r\n        require(grants[_to].value == 0);\r\n\r\n        // Require for time ranges to be consistent and valid.\r\n        require(_start <= _cliff && _cliff <= _end);\r\n\r\n        // Require installment length to be valid and no longer than (end - start).\r\n        require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\r\n\r\n        // Grant must not exceed the total amount of tokens currently available for vesting.\r\n        require(totalVesting.add(_value) <= kin.balanceOf(address(this)));\r\n\r\n        // Assign a new grant.\r\n        grants[_to] = Grant({\r\n            value: _value,\r\n            start: _start,\r\n            cliff: _cliff,\r\n            end: _end,\r\n            installmentLength: _installmentLength,\r\n            transferred: 0,\r\n            revokable: _revokable\r\n        });\r\n\r\n        // Since tokens have been granted, reduce the total amount available for vesting.\r\n        totalVesting = totalVesting.add(_value);\r\n\r\n        NewGrant(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @dev Revoke the grant of tokens of a specifed address.\r\n    /// @param _holder The address which will have its tokens revoked.\r\n    function revoke(address _holder) public onlyOwner {\r\n        Grant memory grant = grants[_holder];\r\n\r\n        // Grant must be revokable.\r\n        require(grant.revokable);\r\n\r\n        // Calculate amount of remaining tokens that can still be returned.\r\n        uint256 refund = grant.value.sub(grant.transferred);\r\n\r\n        // Remove the grant.\r\n        delete grants[_holder];\r\n\r\n        // Update total vesting amount and transfer previously calculated tokens to owner.\r\n        totalVesting = totalVesting.sub(refund);\r\n        kin.transfer(msg.sender, refund);\r\n\r\n        GrantRevoked(_holder, refund);\r\n    }\r\n\r\n    /// @dev Calculate the total amount of vested tokens of a holder at a given time.\r\n    /// @param _holder address The address of the holder.\r\n    /// @param _time uint256 The specific time to calculate against.\r\n    /// @return a uint256 Representing a holder's total amount of vested tokens.\r\n    function vestedTokens(address _holder, uint256 _time) external constant returns (uint256) {\r\n        Grant memory grant = grants[_holder];\r\n        if (grant.value == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return calculateVestedTokens(grant, _time);\r\n    }\r\n\r\n    /// @dev Calculate amount of vested tokens at a specifc time.\r\n    /// @param _grant Grant The vesting grant.\r\n    /// @param _time uint256 The time to be checked\r\n    /// @return An uint256 Representing the amount of vested tokens of a specific grant.\r\n    function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\r\n        // If we're before the cliff, then nothing is vested.\r\n        if (_time < _grant.cliff) {\r\n            return 0;\r\n        }\r\n\r\n        // If we're after the end of the vesting period - everything is vested;\r\n        if (_time >= _grant.end) {\r\n            return _grant.value;\r\n        }\r\n\r\n        // Calculate amount of installments past until now.\r\n        //\r\n        // NOTE result gets floored because of integer division.\r\n        uint256 installmentsPast = _time.sub(_grant.start).div(_grant.installmentLength);\r\n\r\n        // Calculate amount of days in entire vesting period.\r\n        uint256 vestingDays = _grant.end.sub(_grant.start);\r\n\r\n        // Calculate and return the number of tokens according to vesting days that have passed.\r\n        return _grant.value.mul(installmentsPast.mul(_grant.installmentLength)).div(vestingDays);\r\n    }\r\n\r\n    /// @dev Unlock vested tokens and transfer them to the grantee.\r\n    function unlockVestedTokens() external {\r\n        Grant storage grant = grants[msg.sender];\r\n\r\n        // Make sure the grant has tokens available.\r\n        require(grant.value != 0);\r\n\r\n        // Get the total amount of vested tokens, acccording to grant.\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n        if (vested == 0) {\r\n            return;\r\n        }\r\n\r\n        // Make sure the holder doesn't transfer more than what he already has.\r\n        uint256 transferable = vested.sub(grant.transferred);\r\n        if (transferable == 0) {\r\n            return;\r\n        }\r\n\r\n        // Update transferred and total vesting amount, then transfer remaining vested funds to holder.\r\n        grant.transferred = grant.transferred.add(transferable);\r\n        totalVesting = totalVesting.sub(transferable);\r\n        kin.transfer(msg.sender, transferable);\r\n\r\n        TokensUnlocked(msg.sender, transferable);\r\n    }\r\n}\r\n\r\n\r\n/// @title Kin token sale contract.\r\ncontract KinTokenSale is Ownable, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    // External parties:\r\n\r\n    // KIN token contract.\r\n    KinToken public kin;\r\n\r\n    // Vesting contract for pre-sale participants.\r\n    VestingTrustee public trustee;\r\n\r\n    // Received funds are forwarded to this address.\r\n    address public fundingRecipient;\r\n\r\n    // Kin token unit.\r\n    // Using same decimal value as ETH (makes ETH-KIN conversion much easier).\r\n    // This is the same as in Kin token contract.\r\n    uint256 public constant TOKEN_UNIT = 10 ** 18;\r\n\r\n    // Maximum number of tokens in circulation: 10 trillion.\r\n    uint256 public constant MAX_TOKENS = 10 ** 13 * TOKEN_UNIT;\r\n\r\n    // Maximum tokens offered in the sale.\r\n    uint256 public constant MAX_TOKENS_SOLD = 512195121951 * TOKEN_UNIT;\r\n\r\n    // Wei to 1 USD ratio.\r\n    uint256 public constant WEI_PER_USD = uint256(1 ether) / 289;\r\n\r\n    // KIN to 1 USD ratio,\r\n    // such that MAX_TOKENS_SOLD / KIN_PER_USD is the $75M cap.\r\n    uint256 public constant KIN_PER_USD = 6829 * TOKEN_UNIT;\r\n\r\n    // KIN to 1 wei ratio.\r\n    uint256 public constant KIN_PER_WEI = KIN_PER_USD / WEI_PER_USD;\r\n\r\n    // Sale start and end timestamps.\r\n    uint256 public constant SALE_DURATION = 14 days;\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    // Amount of tokens sold until now in the sale.\r\n    uint256 public tokensSold = 0;\r\n\r\n    // Participation caps, according to KYC tiers.\r\n    uint256 public constant TIER_1_CAP = 100000 * WEI_PER_USD;\r\n    uint256 public constant TIER_2_CAP = uint256(-1); // Maximum uint256 value\r\n\r\n    // Accumulated amount each participant has contributed so far.\r\n    mapping (address => uint256) public participationHistory;\r\n\r\n    // Maximum amount that each participant is allowed to contribute (in WEI).\r\n    mapping (address => uint256) public participationCaps;\r\n\r\n    // Maximum amount ANYBODY is currently allowed to contribute.\r\n    uint256 public hardParticipationCap = 4393 * WEI_PER_USD;\r\n\r\n    // Vesting information for special addresses:\r\n    struct TokenGrant {\r\n        uint256 value;\r\n        uint256 startOffset;\r\n        uint256 cliffOffset;\r\n        uint256 endOffset;\r\n        uint256 installmentLength;\r\n        uint8 percentVested;\r\n    }\r\n\r\n    address[] public tokenGrantees;\r\n    mapping (address => TokenGrant) public tokenGrants;\r\n    uint256 public lastGrantedIndex = 0;\r\n    uint256 public constant MAX_TOKEN_GRANTEES = 100;\r\n    uint256 public constant GRANT_BATCH_SIZE = 10;\r\n\r\n    // Post-TDE multisig addresses.\r\n    address public constant KIN_FOUNDATION_ADDRESS = 0x56aE76573EC54754bC5B6A8cBF04bBd7Dc86b0A0;\r\n    address public constant KIK_ADDRESS = 0x3bf4BbE253153678E9E8E540395C22BFf7fCa87d;\r\n\r\n    event TokensIssued(address indexed _to, uint256 _tokens);\r\n\r\n    /// @dev Reverts if called when not during sale.\r\n    modifier onlyDuringSale() {\r\n        require(!saleEnded() && now >= startTime);\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Reverts if called before sale ends.\r\n    modifier onlyAfterSale() {\r\n        require(saleEnded());\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor that initializes the sale conditions.\r\n    /// @param _fundingRecipient address The address of the funding recipient.\r\n    /// @param _startTime uint256 The start time of the token sale.\r\n    function KinTokenSale(address _fundingRecipient, uint256 _startTime) {\r\n        require(_fundingRecipient != address(0));\r\n        require(_startTime > now);\r\n\r\n        // Deploy new KinToken contract.\r\n        kin = new KinToken();\r\n\r\n        // Deploy new VestingTrustee contract.\r\n        trustee = new VestingTrustee(kin);\r\n\r\n        fundingRecipient = _fundingRecipient;\r\n        startTime = _startTime;\r\n        endTime = startTime + SALE_DURATION;\r\n\r\n        // Initialize special vesting grants.\r\n        initTokenGrants();\r\n    }\r\n\r\n    /// @dev Initialize token grants.\r\n    function initTokenGrants() private onlyOwner {\r\n        // Issue the remaining 60% to Kin Foundation's multisig wallet. In a few days, after the token sale is\r\n        // finalized, these tokens will be loaded into the KinVestingTrustee smart contract, according to the white\r\n        // paper. Please note, that this is implied by setting a 0% vesting percent.\r\n        tokenGrantees.push(KIN_FOUNDATION_ADDRESS);\r\n        tokenGrants[KIN_FOUNDATION_ADDRESS] = TokenGrant(MAX_TOKENS.mul(60).div(100), 0, 0, 3 years, 1 days, 0);\r\n\r\n        // Kik, 30%\r\n        tokenGrantees.push(KIK_ADDRESS);\r\n        tokenGrants[KIK_ADDRESS] = TokenGrant(MAX_TOKENS.mul(30).div(100), 0, 0, 120 weeks, 12 weeks, 100);\r\n    }\r\n\r\n    /// @dev Adds a Kin token vesting grant.\r\n    /// @param _grantee address The address of the token grantee. Can be granted only once.\r\n    /// @param _value uint256 The value of the grant.\r\n    function addTokenGrant(address _grantee, uint256 _value) external onlyOwner {\r\n        require(_grantee != address(0));\r\n        require(_value > 0);\r\n        require(tokenGrantees.length + 1 <= MAX_TOKEN_GRANTEES);\r\n\r\n        // Verify the grant doesn't already exist.\r\n        require(tokenGrants[_grantee].value == 0);\r\n        for (uint i = 0; i < tokenGrantees.length; i++) {\r\n            require(tokenGrantees[i] != _grantee);\r\n        }\r\n\r\n        // Add grant and add to grantee list.\r\n        tokenGrantees.push(_grantee);\r\n        tokenGrants[_grantee] = TokenGrant(_value, 0, 1 years, 1 years, 1 days, 50);\r\n    }\r\n\r\n    /// @dev Deletes a Kin token grant.\r\n    /// @param _grantee address The address of the token grantee.\r\n    function deleteTokenGrant(address _grantee) external onlyOwner {\r\n        require(_grantee != address(0));\r\n\r\n        // Delete the grant from the keys array.\r\n        for (uint i = 0; i < tokenGrantees.length; i++) {\r\n            if (tokenGrantees[i] == _grantee) {\r\n                delete tokenGrantees[i];\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Delete the grant from the mapping.\r\n        delete tokenGrants[_grantee];\r\n    }\r\n\r\n    /// @dev Add a list of participants to a capped participation tier.\r\n    /// @param _participants address[] The list of participant addresses.\r\n    /// @param _cap uint256 The cap amount (in ETH).\r\n    function setParticipationCap(address[] _participants, uint256 _cap) private onlyOwner {\r\n        for (uint i = 0; i < _participants.length; i++) {\r\n            participationCaps[_participants[i]] = _cap;\r\n        }\r\n    }\r\n\r\n    /// @dev Add a list of participants to cap tier #1.\r\n    /// @param _participants address[] The list of participant addresses.\r\n    function setTier1Participants(address[] _participants) external onlyOwner {\r\n        setParticipationCap(_participants, TIER_1_CAP);\r\n    }\r\n\r\n    /// @dev Add a list of participants to tier #2.\r\n    /// @param _participants address[] The list of participant addresses.\r\n    function setTier2Participants(address[] _participants) external onlyOwner {\r\n        setParticipationCap(_participants, TIER_2_CAP);\r\n    }\r\n\r\n    /// @dev Set hard participation cap for all participants.\r\n    /// @param _cap uint256 The hard cap amount.\r\n    function setHardParticipationCap(uint256 _cap) external onlyOwner {\r\n        require(_cap > 0);\r\n\r\n        hardParticipationCap = _cap;\r\n    }\r\n\r\n    /// @dev Fallback function that will delegate the request to create().\r\n    function () external payable onlyDuringSale {\r\n        create(msg.sender);\r\n    }\r\n\r\n    /// @dev Create and sell tokens to the caller.\r\n    /// @param _recipient address The address of the recipient receiving the tokens.\r\n    function create(address _recipient) public payable onlyDuringSale {\r\n        require(_recipient != address(0));\r\n\r\n        // Enforce participation cap (in Wei received).\r\n        uint256 weiAlreadyParticipated = participationHistory[msg.sender];\r\n        uint256 participationCap = SafeMath.min256(participationCaps[msg.sender], hardParticipationCap);\r\n        uint256 cappedWeiReceived = SafeMath.min256(msg.value, participationCap.sub(weiAlreadyParticipated));\r\n        require(cappedWeiReceived > 0);\r\n\r\n        // Accept funds and transfer to funding recipient.\r\n        uint256 weiLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold).div(KIN_PER_WEI);\r\n        uint256 weiToParticipate = SafeMath.min256(cappedWeiReceived, weiLeftInSale);\r\n        participationHistory[msg.sender] = weiAlreadyParticipated.add(weiToParticipate);\r\n        fundingRecipient.transfer(weiToParticipate);\r\n\r\n        // Issue tokens and transfer to recipient.\r\n        uint256 tokensLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold);\r\n        uint256 tokensToIssue = weiToParticipate.mul(KIN_PER_WEI);\r\n        if (tokensLeftInSale.sub(tokensToIssue) < KIN_PER_WEI) {\r\n            // If purchase would cause less than KIN_PER_WEI tokens left then nobody could ever buy them.\r\n            // So, gift them to the last buyer.\r\n            tokensToIssue = tokensLeftInSale;\r\n        }\r\n        tokensSold = tokensSold.add(tokensToIssue);\r\n        issueTokens(_recipient, tokensToIssue);\r\n\r\n        // Partial refund if full participation not possible\r\n        // e.g. due to cap being reached.\r\n        uint256 refund = msg.value.sub(weiToParticipate);\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n    }\r\n\r\n    /// @dev Finalizes the token sale event, by stopping token minting.\r\n    function finalize() external onlyAfterSale onlyOwner {\r\n        if (!kin.isMinting()) {\r\n            revert();\r\n        }\r\n\r\n        require(lastGrantedIndex == tokenGrantees.length);\r\n\r\n        // Finish minting.\r\n        kin.endMinting();\r\n    }\r\n\r\n    /// @dev Grants pre-configured token grants in batches. When the method is called, it'll resume from the last grant,\r\n    /// from its previous run, and will finish either after granting GRANT_BATCH_SIZE grants or finishing the whole list\r\n    /// of grants.\r\n    function grantTokens() external onlyAfterSale onlyOwner {\r\n        uint endIndex = SafeMath.min256(tokenGrantees.length, lastGrantedIndex + GRANT_BATCH_SIZE);\r\n        for (uint i = lastGrantedIndex; i < endIndex; i++) {\r\n            address grantee = tokenGrantees[i];\r\n\r\n            // Calculate how many tokens have been granted, vested, and issued such that: granted = vested + issued.\r\n            TokenGrant memory tokenGrant = tokenGrants[grantee];\r\n            uint256 tokensGranted = tokenGrant.value.mul(tokensSold).div(MAX_TOKENS_SOLD);\r\n            uint256 tokensVesting = tokensGranted.mul(tokenGrant.percentVested).div(100);\r\n            uint256 tokensIssued = tokensGranted.sub(tokensVesting);\r\n\r\n            // Transfer issued tokens that have yet to be transferred to grantee.\r\n            if (tokensIssued > 0) {\r\n                issueTokens(grantee, tokensIssued);\r\n            }\r\n\r\n            // Transfer vested tokens that have yet to be transferred to vesting trustee, and initialize grant.\r\n            if (tokensVesting > 0) {\r\n                issueTokens(trustee, tokensVesting);\r\n                trustee.grant(grantee, tokensVesting, now.add(tokenGrant.startOffset), now.add(tokenGrant.cliffOffset),\r\n                    now.add(tokenGrant.endOffset), tokenGrant.installmentLength, true);\r\n            }\r\n\r\n            lastGrantedIndex++;\r\n        }\r\n    }\r\n\r\n    /// @dev Issues tokens for the recipient.\r\n    /// @param _recipient address The address of the recipient.\r\n    /// @param _tokens uint256 The amount of tokens to issue.\r\n    function issueTokens(address _recipient, uint256 _tokens) private {\r\n        // Request Kin token contract to mint the requested tokens for the buyer.\r\n        kin.mint(_recipient, _tokens);\r\n\r\n        TokensIssued(_recipient, _tokens);\r\n    }\r\n\r\n    /// @dev Returns whether the sale has ended.\r\n    /// @return bool Whether the sale has ended or not.\r\n    function saleEnded() private constant returns (bool) {\r\n        return tokensSold >= MAX_TOKENS_SOLD || now >= endTime;\r\n    }\r\n\r\n    /// @dev Requests to transfer control of the Kin token contract to a new owner.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    ///\r\n    /// NOTE:\r\n    ///   1. The new owner will need to call Kin token contract's acceptOwnership directly in order to accept the ownership.\r\n    ///   2. Calling this method during the token sale will prevent the token sale to continue, since only the owner of\r\n    ///      the Kin token contract can issue new tokens.\r\n    function requestKinTokenOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        kin.requestOwnershipTransfer(_newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accepts new ownership on behalf of the Kin token contract.\r\n    // This can be used by the sale contract itself to claim back ownership of the Kin token contract.\r\n    function acceptKinTokenOwnership() external onlyOwner {\r\n        kin.acceptOwnership();\r\n    }\r\n\r\n    /// @dev Requests to transfer control of the VestingTrustee contract to a new owner.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    ///\r\n    /// NOTE:\r\n    ///   1. The new owner will need to call VestingTrustee's acceptOwnership directly in order to accept the ownership.\r\n    ///   2. Calling this method during the token sale will prevent the token sale from finalizaing, since only the owner\r\n    ///      of the VestingTrustee contract can issue new token grants.\r\n    function requestVestingTrusteeOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        trustee.requestOwnershipTransfer(_newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accepts new ownership on behalf of the VestingTrustee contract.\r\n    /// This can be used by the token sale contract itself to claim back ownership of the VestingTrustee contract.\r\n    function acceptVestingTrusteeOwnership() external onlyOwner {\r\n        trustee.acceptOwnership();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"vestedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockVestedTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_installmentLength\",\"type\":\"uint256\"},{\"name\":\"_revokable\",\"type\":\"bool\"}],\"name\":\"grant\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"grants\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"cliff\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"installmentLength\",\"type\":\"uint256\"},{\"name\":\"transferred\",\"type\":\"uint256\"},{\"name\":\"revokable\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_kin\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"NewGrant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokensUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_refund\",\"type\":\"uint256\"}],\"name\":\"GrantRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"VestingTrustee","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000818Fc6C2Ec5986bc6E2CBf00939d90556aB12ce5","Library":"","SwarmSource":"bzzr://708f9ef9bc918f9f6b04a96203db265d6bebb7e7894a325391b1ea397d60cdfa"}]}