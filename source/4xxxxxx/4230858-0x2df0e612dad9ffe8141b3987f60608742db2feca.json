{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/// @title STABLE Project ICO\r\n/// @author Konrad Sza≈Çapak <konrad.szalapak@gmail.com>\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n}\r\n  \r\n/* New ERC23 contract interface */\r\ncontract ERC223 {\r\n    uint public totalSupply;\r\n    function balanceOf(address who) constant returns (uint);\r\n  \r\n    function name() constant returns (string _name);\r\n    function symbol() constant returns (string _symbol);\r\n    function decimals() constant returns (uint8 _decimals);\r\n    function totalSupply() constant returns (uint256 _supply);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transfer(address to, uint value, bytes data) returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n}\r\n\r\n/*\r\n* Contract that is working with ERC223 tokens\r\n*/\r\ncontract ContractReceiver {\r\n    function tokenFallback(address _from, uint _value, bytes _data);\r\n}\r\n\r\n/**\r\n* ERC23 token by Dexaran\r\n*\r\n* https://github.com/Dexaran/ERC23-tokens\r\n*/\r\n \r\n \r\n/* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */\r\ncontract SafeMath {\r\n    uint256 constant public MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (x > MAX_UINT256 - y) throw;\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (x < y) throw;\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) return 0;\r\n        if (x > MAX_UINT256 / y) throw;\r\n        return x * y;\r\n    }\r\n}\r\n\r\n/**\r\n* STABLE Awareness Token - STA\r\n*/\r\ncontract ERC223Token_STA is ERC223, SafeMath, Ownable {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint) balances;\r\n    \r\n    // stable params:\r\n    uint256 public icoEndBlock;                              // last block number of ICO \r\n    uint256 public maxSupply;                                // maximum token supply\r\n    uint256 public minedTokenCount;                          // counter of mined tokens\r\n    address public icoAddress;                               // address of ICO contract    \r\n    uint256 private multiplier;                              // for managing token fractionals\r\n    struct Miner {                                           // struct for mined tokens data\r\n        uint256 block;\r\n        address minerAddress;\r\n    }\r\n    mapping (uint256 => Miner) public minedTokens;           // mined tokens data\r\n    event MessageClaimMiningReward(address indexed miner, uint256 block, uint256 sta);  // notifies clients about sta winning miner\r\n    event Burn(address indexed from, uint256 value);         // notifies clients about the amount burnt\r\n    \r\n    function ERC223Token_STA() {\r\n        decimals = 8;\r\n        multiplier = 10**uint256(decimals);\r\n        maxSupply = 10000000000;                             // Maximum possible supply == 100 STA\r\n        name = \"STABLE STA Token\";                           // Set the name for display purposes\r\n        symbol = \"STA\";                                      // Set the symbol for display purposes\r\n        icoEndBlock = 4332000;  // INIT                      // last block number for ICO\r\n        totalSupply = 0;                                     // Update total supply\r\n        // balances[msg.sender] = totalSupply;               // Give the creator all initial tokens\r\n    }\r\n \r\n    // trigger rewarding a miner with STA token:\r\n    function claimMiningReward() {  \r\n        if (icoAddress == address(0)) throw;                         // ICO address must be set up first\r\n        if (msg.sender != icoAddress && msg.sender != owner) throw;  // triggering enabled only for ICO or owner\r\n        if (block.number > icoEndBlock) throw;                       // rewarding enabled only before the end of ICO\r\n        if (minedTokenCount * multiplier >= maxSupply) throw; \r\n        if (minedTokenCount > 0) {\r\n            for (uint256 i = 0; i < minedTokenCount; i++) {\r\n                if (minedTokens[i].block == block.number) throw; \r\n            }\r\n        }\r\n        totalSupply += 1 * multiplier;\r\n        balances[block.coinbase] += 1 * multiplier;                  // reward miner with one STA token\r\n        minedTokens[minedTokenCount] = Miner(block.number, block.coinbase);\r\n        minedTokenCount += 1;\r\n        MessageClaimMiningReward(block.coinbase, block.number, 1 * multiplier);\r\n    } \r\n    \r\n    function selfDestroy() onlyOwner {\r\n        // allow to suicide STA token after around 2 weeks (25s/block) from the end of ICO\r\n        if (block.number <= icoEndBlock+14*3456) throw;\r\n        suicide(this); \r\n    }\r\n    // /stable params\r\n   \r\n    // Function to access name of token .\r\n    function name() constant returns (string _name) {\r\n        return name;\r\n    }\r\n    // Function to access symbol of token .\r\n    function symbol() constant returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n    // Function to access decimals of token .\r\n    function decimals() constant returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n    // Function to access total supply of tokens .\r\n    function totalSupply() constant returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n    function minedTokenCount() constant returns (uint256 _minedTokenCount) {\r\n        return minedTokenCount;\r\n    }\r\n    function icoAddress() constant returns (address _icoAddress) {\r\n        return icoAddress;\r\n    }\r\n\r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\n        if(isContract(_to)) {\r\n            transferToContract(_to, _value, _data);\r\n        }\r\n        else {\r\n            transferToAddress(_to, _value, _data);\r\n        }\r\n        return true;\r\n    }\r\n  \r\n    // Standard function transfer similar to ERC20 transfer with no _data .\r\n    // Added due to backwards compatibility reasons .\r\n    function transfer(address _to, uint _value) returns (bool success) {\r\n        bytes memory empty;\r\n        if(isContract(_to)) {\r\n            transferToContract(_to, _value, empty);\r\n        }\r\n        else {\r\n            transferToAddress(_to, _value, empty);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) private returns (bool is_contract) {\r\n        uint length;\r\n        _addr = _addr;  // workaround for Mist's inability to compile\r\n        is_contract = is_contract;  // workaround for Mist's inability to compile\r\n        assembly {\r\n                //retrieve the size of the code on target address, this needs assembly\r\n                length := extcodesize(_addr)\r\n        }\r\n        if(length>0) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    //function that is called when transaction target is an address\r\n    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) throw;\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n  \r\n    //function that is called when transaction target is a contract\r\n    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) throw;\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\t\r\n    function burn(address _address, uint256 _value) returns (bool success) {\r\n        if (icoAddress == address(0)) throw;\r\n        if (msg.sender != owner && msg.sender != icoAddress) throw; // only owner and ico contract are allowed\r\n        if (balances[_address] < _value) throw;                     // Check if the sender has enough tokens\r\n        balances[_address] -= _value;                               // Subtract from the sender\r\n        totalSupply -= _value;                               \r\n        Burn(_address, _value);\r\n        return true;\r\n    }\r\n\t\r\n    /* setting ICO address for allowing execution from the ICO contract */\r\n    function setIcoAddress(address _address) onlyOwner {\r\n        if (icoAddress == address(0)) {\r\n            icoAddress = _address;\r\n        }    \r\n        else throw;\r\n    }\r\n}\r\n\r\n/**\r\n* Stable Token - STB\r\n*/\r\ncontract ERC223Token_STB is ERC223, SafeMath, Ownable {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint) balances;\r\n    \r\n    // stable params:\r\n    uint256 public maxSupply;\r\n    uint256 public icoEndBlock;\r\n    address public icoAddress;\r\n\t\r\n    function ERC223Token_STB() {\r\n        totalSupply = 0;                                     // Update total supply\r\n        maxSupply = 1000000000000;                           // Maximum possible supply of STB == 100M STB\r\n        name = \"STABLE STB Token\";                           // Set the name for display purposes\r\n        decimals = 4;                                        // Amount of decimals for display purposes\r\n        symbol = \"STB\";                                      // Set the symbol for display purposes\r\n        icoEndBlock = 4332000;  // INIT                      // last block number of ICO          \r\n        //balances[msg.sender] = totalSupply;                // Give the creator all initial tokens       \r\n    }\r\n    \r\n    // Function to access max supply of tokens .\r\n    function maxSupply() constant returns (uint256 _maxSupply) {\r\n        return maxSupply;\r\n    }\r\n    // /stable params\r\n  \r\n    // Function to access name of token .\r\n    function name() constant returns (string _name) {\r\n        return name;\r\n    }\r\n    // Function to access symbol of token .\r\n    function symbol() constant returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n    // Function to access decimals of token .\r\n    function decimals() constant returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n    // Function to access total supply of tokens .\r\n    function totalSupply() constant returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n    function icoAddress() constant returns (address _icoAddress) {\r\n        return icoAddress;\r\n    }\r\n\r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\n        if(isContract(_to)) {\r\n            transferToContract(_to, _value, _data);\r\n        }\r\n        else {\r\n            transferToAddress(_to, _value, _data);\r\n        }\r\n        return true;\r\n    }\r\n  \r\n    // Standard function transfer similar to ERC20 transfer with no _data .\r\n    // Added due to backwards compatibility reasons .\r\n    function transfer(address _to, uint _value) returns (bool success) {\r\n        bytes memory empty;\r\n        if(isContract(_to)) {\r\n            transferToContract(_to, _value, empty);\r\n        }\r\n        else {\r\n            transferToAddress(_to, _value, empty);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) private returns (bool is_contract) {\r\n        uint length;\r\n        _addr = _addr;  // workaround for Mist's inability to compile\r\n        is_contract = is_contract;  // workaround for Mist's inability to compile\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        if(length>0) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    //function that is called when transaction target is an address\r\n    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) throw;\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n  \r\n    //function that is called when transaction target is a contract\r\n    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) throw;\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /* setting ICO address for allowing execution from the ICO contract */\r\n    function setIcoAddress(address _address) onlyOwner {\r\n        if (icoAddress == address(0)) {\r\n            icoAddress = _address;\r\n        }    \r\n        else throw;\r\n    }\r\n\r\n    /* mint new tokens */\r\n    function mint(address _receiver, uint256 _amount) {\r\n        if (icoAddress == address(0)) throw;\r\n        if (msg.sender != icoAddress && msg.sender != owner) throw;     // mint allowed only for ICO contract or owner\r\n        if (safeAdd(totalSupply, _amount) > maxSupply) throw;\r\n        totalSupply = safeAdd(totalSupply, _amount); \r\n        balances[_receiver] = safeAdd(balances[_receiver], _amount);\r\n        Transfer(0, _receiver, _amount, new bytes(0)); \r\n    }\r\n    \r\n}\r\n\r\n/* main contract - ICO */\r\ncontract StableICO is Ownable, SafeMath {\r\n    uint256 public crowdfundingTarget;         // ICO target, in wei\r\n    ERC223Token_STA public sta;                // address of STA token\r\n    ERC223Token_STB public stb;                // address of STB token\r\n    address public beneficiary;                // where the donation is transferred after successful ICO\r\n    uint256 public icoStartBlock;              // number of start block of ICO\r\n    uint256 public icoEndBlock;                // number of end block of ICO\r\n    bool public isIcoFinished;                 // boolean for ICO status - is ICO finished?\r\n    bool public isIcoSucceeded;                // boolean for ICO status - is crowdfunding target reached?\r\n    bool public isDonatedEthTransferred;       // boolean for ICO status - is donation transferred to the secure account?\r\n    bool public isStbMintedForStaEx;           // boolean for ICO status - is extra STB tokens minted for covering exchange of STA token?\r\n    uint256 public receivedStaAmount;          // amount of received STA tokens from rewarded miners\r\n    uint256 public totalFunded;                // amount of ETH donations\r\n    uint256 public ownersEth;                  // amount of ETH transferred to ICO contract by the owner\r\n    uint256 public oneStaIsStb;                // one STA value in STB\r\n    \r\n    struct Donor {                                                      // struct for ETH donations\r\n        address donorAddress;\r\n        uint256 ethAmount;\r\n        uint256 block;\r\n        bool exchangedOrRefunded;\r\n        uint256 stbAmount;\r\n    }\r\n    mapping (uint256 => Donor) public donations;                        // storage for ETH donations\r\n    uint256 public donationNum;                                         // counter of ETH donations\r\n\t\r\n    struct Miner {                                                      // struct for received STA tokens\r\n        address minerAddress;\r\n        uint256 staAmount;\r\n        uint256 block;\r\n        bool exchanged;\r\n        uint256 stbAmount;\r\n    }\r\n    mapping (uint256 => Miner) public receivedSta;                      // storage for received STA tokens\r\n    uint256 public minerNum;                                            // counter of STA receives\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value); \r\n    \r\n    event MessageExchangeEthStb(address from, uint256 eth, uint256 stb);\r\n    event MessageExchangeStaStb(address from, uint256 sta, uint256 stb);\r\n    event MessageReceiveEth(address from, uint256 eth, uint256 block);\r\n    event MessageReceiveSta(address from, uint256 sta, uint256 block);\r\n    event MessageReceiveStb(address from, uint256 stb, uint256 block, bytes data);  // it should never happen\r\n    event MessageRefundEth(address donor_address, uint256 eth);\r\n  \r\n    /* constructor */\r\n    function StableICO() {\r\n        crowdfundingTarget = 750000000000000000000; // INIT\r\n        sta = ERC223Token_STA(0x164489AB676C578bED0515dDCF92Ef37aacF9a29);  // INIT\r\n        stb = ERC223Token_STB(0x09bca6ebab05ee2ae945be4eda51393d94bf7b99);  // INIT\r\n        beneficiary = 0xb2e7579f84a8ddafdb376f9872916b7fcb8dbec0;  // INIT\r\n        icoStartBlock = 4232000;  // INIT\r\n        icoEndBlock = 4332000;  // INIT\r\n    }\t\t\r\n    \r\n    /* trigger rewarding the miner with STA token */\r\n    function claimMiningReward() public onlyOwner {\r\n        sta.claimMiningReward();\r\n    }\r\n\t\r\n    /* Receiving STA from miners - during and after ICO */\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) {\r\n        if (block.number < icoStartBlock) throw;\r\n        if (msg.sender == address(sta)) {\r\n            if (_value < 50000000) throw; // minimum 0.5 STA\r\n            if (block.number < icoEndBlock+14*3456) {  // allow STA tokens exchange for around 14 days (25s/block) after ICO\r\n                receivedSta[minerNum] = Miner(_from, _value, block.number, false, 0);\r\n                minerNum += 1;\r\n                receivedStaAmount = safeAdd(receivedStaAmount, _value);\r\n                MessageReceiveSta(_from, _value, block.number);\r\n            } else throw;\t\r\n        } else if(msg.sender == address(stb)) {\r\n            MessageReceiveStb(_from, _value, block.number, _data);\r\n        } else {\r\n            throw; // other tokens\r\n        }\r\n    }\r\n\r\n    /* Receiving ETH */\r\n    function () payable {\r\n\r\n        if (msg.value < 100000000000000000) throw;  // minimum 0.1 ETH\r\n\t\t\r\n        // before ICO (pre-ico)\r\n        if (block.number < icoStartBlock) {\r\n            if (msg.sender == owner) {\r\n                ownersEth = safeAdd(ownersEth, msg.value);\r\n            } else {\r\n                totalFunded = safeAdd(totalFunded, msg.value);\r\n                donations[donationNum] = Donor(msg.sender, msg.value, block.number, false, 0);\r\n                donationNum += 1;\r\n                MessageReceiveEth(msg.sender, msg.value, block.number);\r\n            }    \r\n        } \r\n        // during ICO\r\n        else if (block.number >= icoStartBlock && block.number <= icoEndBlock) {\r\n            if (msg.sender != owner) {\r\n                totalFunded = safeAdd(totalFunded, msg.value);\r\n                donations[donationNum] = Donor(msg.sender, msg.value, block.number, false, 0);\r\n                donationNum += 1;\r\n                MessageReceiveEth(msg.sender, msg.value, block.number);\r\n            } else ownersEth = safeAdd(ownersEth, msg.value);\r\n        }\r\n        // after ICO - first ETH transfer is returned to the sender\r\n        else if (block.number > icoEndBlock) {\r\n            if (!isIcoFinished) {\r\n                isIcoFinished = true;\r\n                msg.sender.transfer(msg.value);  // return ETH to the sender\r\n                if (totalFunded >= crowdfundingTarget) {\r\n                    isIcoSucceeded = true;\r\n                    exchangeStaStb(0, minerNum);\r\n                    exchangeEthStb(0, donationNum);\r\n                    drawdown();\r\n                } else {\r\n                    refund(0, donationNum);\r\n                }\t\r\n            } else {\r\n                if (msg.sender != owner) throw;  // WARNING: senders ETH may be lost (if transferred after finished ICO)\r\n                ownersEth = safeAdd(ownersEth, msg.value);\r\n            }    \r\n        } else {\r\n            throw;  // WARNING: senders ETH may be lost (if transferred after finished ICO)\r\n        }\r\n    }\r\n\r\n    /* send STB to the miners who returned STA tokens - after successful ICO */\r\n    function exchangeStaStb(uint256 _from, uint256 _to) private {  \r\n        if (!isIcoSucceeded) throw;\r\n        if (_from >= _to) return;  // skip the function if there is invalid range given for loop\r\n        uint256 _sta2stb = 10**4; \r\n        uint256 _wei2stb = 10**14; \r\n\r\n        if (!isStbMintedForStaEx) {\r\n            uint256 _mintAmount = (10*totalFunded)*5/1000 / _wei2stb;  // 0.5% extra STB minting for STA covering\r\n            oneStaIsStb = _mintAmount / 100;\r\n            stb.mint(address(this), _mintAmount);\r\n            isStbMintedForStaEx = true;\r\n        }\t\r\n\t\t\t\r\n        /* exchange */\r\n        uint256 _toBurn = 0;\r\n        for (uint256 i = _from; i < _to; i++) {\r\n            if (receivedSta[i].exchanged) continue;  // skip already exchanged STA\r\n            stb.transfer(receivedSta[i].minerAddress, receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4);\r\n            receivedSta[i].exchanged = true;\r\n            receivedSta[i].stbAmount = receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4;\r\n            _toBurn += receivedSta[i].staAmount;\r\n            MessageExchangeStaStb(receivedSta[i].minerAddress, receivedSta[i].staAmount, \r\n              receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4);\r\n        }\r\n        sta.burn(address(this), _toBurn);  // burn received and processed STA tokens\r\n    }\r\n\t\r\n    /* send STB to the donors - after successful ICO */\r\n    function exchangeEthStb(uint256 _from, uint256 _to) private { \r\n        if (!isIcoSucceeded) throw;\r\n        if (_from >= _to) return;  // skip the function if there is invalid range given for loop\r\n        uint256 _wei2stb = 10**14; // calculate eth to stb exchange\r\n        uint _pb = (icoEndBlock - icoStartBlock)/4; \r\n        uint _bonus;\r\n\r\n        /* mint */\r\n        uint256 _mintAmount = 0;\r\n        for (uint256 i = _from; i < _to; i++) {\r\n            if (donations[i].exchangedOrRefunded) continue;  // skip already minted STB\r\n            if (donations[i].block < icoStartBlock + _pb) _bonus = 6;  // first period; bonus in %\r\n            else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4;  // 2nd\r\n            else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2;  // 3rd\r\n            else _bonus = 0;  // 4th\r\n            _mintAmount += 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100);\r\n        }\r\n        stb.mint(address(this), _mintAmount);\r\n\r\n        /* exchange */\r\n        for (i = _from; i < _to; i++) {\r\n            if (donations[i].exchangedOrRefunded) continue;  // skip already exchanged ETH\r\n            if (donations[i].block < icoStartBlock + _pb) _bonus = 6;  // first period; bonus in %\r\n            else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4;  // 2nd\r\n            else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2;  // 3rd\r\n            else _bonus = 0;  // 4th\r\n            stb.transfer(donations[i].donorAddress, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100) );\r\n            donations[i].exchangedOrRefunded = true;\r\n            donations[i].stbAmount = 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100);\r\n            MessageExchangeEthStb(donations[i].donorAddress, donations[i].ethAmount, \r\n              10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100));\r\n        }\r\n    }\r\n  \r\n    // send funds to the ICO beneficiary account - after successful ICO\r\n    function drawdown() private {\r\n        if (!isIcoSucceeded || isDonatedEthTransferred) throw;\r\n        beneficiary.transfer(totalFunded);  \r\n        isDonatedEthTransferred = true;\r\n    }\r\n  \r\n    /* refund ETH - after unsuccessful ICO */\r\n    function refund(uint256 _from, uint256 _to) private {\r\n        if (!isIcoFinished || isIcoSucceeded) throw;\r\n        if (_from >= _to) return;\r\n        for (uint256 i = _from; i < _to; i++) {\r\n            if (donations[i].exchangedOrRefunded) continue;\r\n            donations[i].donorAddress.transfer(donations[i].ethAmount);\r\n            donations[i].exchangedOrRefunded = true;\r\n            MessageRefundEth(donations[i].donorAddress, donations[i].ethAmount);\r\n        }\r\n    }\r\n    \r\n    // send owner's funds to the ICO owner - after ICO\r\n    function transferEthToOwner(uint256 _amount) public onlyOwner { \r\n        if (!isIcoFinished || _amount <= 0 || _amount > ownersEth) throw;\r\n        owner.transfer(_amount); \r\n        ownersEth -= _amount;\r\n    }    \r\n\r\n    // send STB to the ICO owner - after ICO\r\n    function transferStbToOwner(uint256 _amount) public onlyOwner { \r\n        if (!isIcoFinished || _amount <= 0) throw;\r\n        stb.transfer(owner, _amount); \r\n    }    \r\n    \r\n    \r\n    /* backup functions to be executed \"manually\" - in case of a critical ethereum platform failure \r\n      during automatic function execution */\r\n    function backup_finishIcoVars() public onlyOwner {\r\n        if (block.number <= icoEndBlock || isIcoFinished) throw;\r\n        isIcoFinished = true;\r\n        if (totalFunded >= crowdfundingTarget) isIcoSucceeded = true;\r\n    }\r\n    function backup_exchangeStaStb(uint256 _from, uint256 _to) public onlyOwner { \r\n        exchangeStaStb(_from, _to);\r\n    }\r\n    function backup_exchangeEthStb(uint256 _from, uint256 _to) public onlyOwner { \r\n        exchangeEthStb(_from, _to);\r\n    }\r\n    function backup_drawdown() public onlyOwner { \r\n        drawdown();\r\n    }\r\n    function backup_drawdown_amount(uint256 _amount) public onlyOwner {\r\n        if (!isIcoSucceeded) throw;\r\n        beneficiary.transfer(_amount);  \r\n    }\r\n    function backup_refund(uint256 _from, uint256 _to) public onlyOwner { \r\n        refund(_from, _to);\r\n    }\r\n    /* /backup */\r\n \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"oneStaIsStb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIcoSucceeded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdfundingTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"backup_exchangeEthStb\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sta\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStbMintedForStaEx\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"backup_drawdown_amount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"backup_exchangeStaStb\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minerNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDonatedEthTransferred\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIcoFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"backup_refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"backup_drawdown\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"receivedSta\",\"outputs\":[{\"name\":\"minerAddress\",\"type\":\"address\"},{\"name\":\"staAmount\",\"type\":\"uint256\"},{\"name\":\"block\",\"type\":\"uint256\"},{\"name\":\"exchanged\",\"type\":\"bool\"},{\"name\":\"stbAmount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receivedStaAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stb\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferEthToOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"backup_finishIcoVars\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimMiningReward\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferStbToOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donations\",\"outputs\":[{\"name\":\"donorAddress\",\"type\":\"address\"},{\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"name\":\"block\",\"type\":\"uint256\"},{\"name\":\"exchangedOrRefunded\",\"type\":\"bool\"},{\"name\":\"stbAmount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stb\",\"type\":\"uint256\"}],\"name\":\"MessageExchangeEthStb\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sta\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stb\",\"type\":\"uint256\"}],\"name\":\"MessageExchangeStaStb\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"MessageReceiveEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sta\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"MessageReceiveSta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stb\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MessageReceiveStb\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"donor_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"MessageRefundEth\",\"type\":\"event\"}]","ContractName":"StableICO","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f4bbb60439e2d8048f140ae53bda5e6fbb9bba49d91c0577a28e30ae224e30e8"}]}