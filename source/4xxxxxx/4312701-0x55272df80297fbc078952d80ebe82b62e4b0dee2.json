{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract StandardContract {\r\n    // allows usage of \"require\" as a modifier\r\n    modifier requires(bool b) {\r\n        require(b);\r\n        _;\r\n    }\r\n\r\n    // require at least one of the two conditions to be true\r\n    modifier requiresOne(bool b1, bool b2) {\r\n        require(b1 || b2);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address a) {\r\n        require(a != 0);\r\n        _;\r\n    }\r\n\r\n    modifier notZero(uint256 a) {\r\n        require(a != 0);\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private rentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = 0x0;\r\n  }\r\n}\r\n\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  function HasNoEther() payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    assert(owner.send(this.balance));\r\n  }\r\n}\r\n\r\n/*\r\n * A SingleTokenLocker allows a user to create a locker that can lock a single type of ERC20 token.\r\n * The token locker should:\r\n *    - Allow the owner to prove a certain number of their own tokens are locked for until a particular time\r\n *    - Allow the owner to transfer tokens to a recipient and prove the tokens are locked until a particular time\r\n *    - Allow the owner to cancel a transfer before a recipient confirms (in case of transfer to an incorrect address)\r\n *    - Allow the recipient to be certain that they will have access to transferred tokens once the lock expires\r\n *    - Be re-usable by the owner, so an owner can easily schedule/monitor multiple transfers/locks\r\n *\r\n * This class should be reusable for any ERC20 token.  Ideally, this sort of fine grained locking would be available in\r\n * the token contract itself.  Short of that, the token locker receives tokens (presumably from the locker owner) and\r\n * can be configured to release them only under certain conditions.\r\n *\r\n * Usage:\r\n *  - The owner creates a token locker for a particular ERC20 token type\r\n *  - The owner approves the locker up to some number of tokens: token.approve(tokenLockerAddress, tokenAmount)\r\n *    - Alternately, the owner can send tokens to the locker.  When locking tokens, the locker checks its balance first\r\n *  - The owner calls \"lockup\" with a particular recipient, amount, and unlock time.  The recipient will be allowed\r\n *    to collect the tokens once the lockup period is ended.\r\n *  - The recipient calls \"confirm\" which confirms that the recipient's address is correct and is controlled by the\r\n *    intended recipient (e.g. not an exchange address).  The assumption is that if the recipient can call \"confirm\"\r\n *    they have demonstrated that they will also be able to call \"collect\" when the tokens are ready.\r\n *  - Once the lock expires, the recipient calls \"collect\" and the tokens are transferred from the locker to the\r\n *    recipient.\r\n *\r\n * An owner can lockup his/her own tokens in order to demonstrate the they will not be moved until a particular time.\r\n * In this case, no separate \"confirm\" step is needed (confirm happens automatically)\r\n *\r\n * The following diagram shows the actual balance of the token locker and how it is tracked internally\r\n *\r\n *         +-------------------------------------------------------------+\r\n *         |                      Actual Locker Balance                  |\r\n *         |-------------------------------------------------------------|\r\n *         |                     |                Promised               |\r\n *  State  |     Uncommitted     +---------------------------------------|\r\n *         |                     |        Pending            |  Locked   |\r\n *         |---------------------+---------------------------------------|\r\n *  Actions| withdraw            |  confirm, cancel, collect | collect   |\r\n *         |---------------------+---------------------------+-----------|\r\n *  Field  | balance - promised  | promised - locked         | locked    |\r\n *         +---------------------+---------------------------+-----------+\r\n */\r\ncontract SingleTokenLocker is Claimable, ReentrancyGuard, StandardContract, HasNoEther {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  // the type of token this locker is used for\r\n  ERC20 public token;\r\n\r\n  // A counter to generate unique Ids for promises\r\n  uint256 public nextPromiseId;\r\n\r\n  // promise storage\r\n  mapping(uint256 => TokenPromise) public promises;\r\n\r\n  // The total amount of tokens locked or pending lock (in the non-fractional units, like wei)\r\n  uint256 public promisedTokenBalance;\r\n\r\n  // The total amount of tokens actually locked (recipients have confirmed)\r\n  uint256 public lockedTokenBalance;\r\n\r\n  // promise states\r\n  //  none: The default state.  Never explicitly assigned.\r\n  //  pending: The owner has initiated a promise, but it has not been claimed\r\n  //  confirmed: The recipient has confirmed the promise\r\n  //  executed: The promise has completed (after the required lockup)\r\n  //  canceled: The promise was canceled (only from pending state)\r\n  //  failed: The promise could not be fulfilled due to an error\r\n  enum PromiseState { none, pending, confirmed, executed, canceled, failed }\r\n\r\n  // a matrix designating the legal state transitions for a promise (see constructor)\r\n  mapping (uint => mapping(uint => bool)) stateTransitionMatrix;\r\n\r\n  // true if the contract has been initialized\r\n  bool initialized;\r\n\r\n  struct TokenPromise {\r\n    uint256 promiseId;\r\n    address recipient;\r\n    uint256 amount;\r\n    uint256 lockedUntil;\r\n    PromiseState state;\r\n  }\r\n\r\n  event logPromiseCreated(uint256 promiseId, address recipient, uint256 amount, uint256 lockedUntil);\r\n  event logPromiseConfirmed(uint256 promiseId);\r\n  event logPromiseCanceled(uint256 promiseId);\r\n  event logPromiseFulfilled(uint256 promiseId);\r\n  event logPromiseUnfulfillable(uint256 promiseId, address recipient, uint256 amount);\r\n\r\n  /**\r\n   * Guards actions that only the intended recipient should be able to perform\r\n   */\r\n  modifier onlyRecipient(uint256 promiseId) {\r\n    require(msg.sender == promises[promiseId].recipient);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Ensures the promiseId as actually in use.\r\n   */\r\n  modifier promiseExists(uint promiseId) {\r\n    require(promiseId < nextPromiseId);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Ensure state consistency after modifying lockedTokenBalance or promisedTokenBalance\r\n   */\r\n  modifier thenAssertState() {\r\n    _;\r\n    uint256 balance = tokenBalance();\r\n    assert(lockedTokenBalance <= promisedTokenBalance);\r\n    assert(promisedTokenBalance <= balance);\r\n  }\r\n\r\n  // Constructor\r\n  function SingleTokenLocker(address tokenAddress) {\r\n    token = ERC20(tokenAddress);\r\n\r\n    allowTransition(PromiseState.pending, PromiseState.canceled);\r\n    allowTransition(PromiseState.pending, PromiseState.executed);\r\n    allowTransition(PromiseState.pending, PromiseState.confirmed);\r\n    allowTransition(PromiseState.confirmed, PromiseState.executed);\r\n    allowTransition(PromiseState.executed, PromiseState.failed);\r\n    initialized = true;\r\n  }\r\n\r\n  /**\r\n   * Initiates the request to lockup the given number of tokens until the given block.timestamp occurs.\r\n   * This contract will attempt to acquire tokens from the Token contract from the owner if its balance\r\n   * is not sufficient.  Therefore, the locker owner may call token.approve(locker.address, amount) one time\r\n   * and then initiate many smaller transfers to individuals.\r\n   *\r\n   * Note 1: lockup is not guaranteed until the recipient confirms.\r\n   * Note 2: Assumes the owner has already given approval for the TokenLocker to take out the tokens\r\n   *         or that the locker's balance is sufficient\r\n   */\r\n  function lockup(address recipient, uint256 amount, uint256 lockedUntil)\r\n    onlyOwner\r\n    notNull(recipient)\r\n    notZero(amount)\r\n    nonReentrant\r\n    external\r\n  {\r\n    // if the locker does not have sufficient unlocked tokens, assume it has enough\r\n    // approved by the owner to make up the difference\r\n    ensureTokensAvailable(amount);\r\n\r\n    // setup a promise that allow transfer to the recipient after the lock expires\r\n    TokenPromise storage promise = createPromise(recipient, amount, lockedUntil);\r\n\r\n    // auto-confirm if the recipient is the owner\r\n    if (recipient == owner) {\r\n      doConfirm(promise);\r\n    }\r\n  }\r\n\r\n  /***\r\n   * @dev Cancels the pending transaction as long as the caller has permissions and the transaction has not already\r\n   * been confirmed.  Allowing *any* transaction to be canceled would mean no lockup could ever be guaranteed.\r\n   */\r\n  function cancel(uint256 promiseId)\r\n    promiseExists(promiseId)\r\n    requires(promises[promiseId].state == PromiseState.pending)\r\n    requiresOne(\r\n      msg.sender == owner,\r\n      msg.sender == promises[promiseId].recipient\r\n    )\r\n    nonReentrant\r\n    external\r\n  {\r\n    TokenPromise storage promise = promises[promiseId];\r\n    unlockTokens(promise, PromiseState.canceled);\r\n    logPromiseCanceled(promise.promiseId);\r\n  }\r\n\r\n  // @dev Allows the recipient to confirm their address.  If this fails (or they cannot send from the specified address)\r\n  // the owner of the TokenLocker can cancel the promise and initiate a new one\r\n  function confirm(uint256 promiseId)\r\n    promiseExists(promiseId)\r\n    onlyRecipient(promiseId)\r\n    requires(promises[promiseId].state == PromiseState.pending)\r\n    nonReentrant\r\n    external\r\n  {\r\n    doConfirm(promises[promiseId]);\r\n  }\r\n\r\n  /***\r\n   * Called by the recipient after the lock has expired.\r\n   */\r\n  function collect(uint256 promiseId)\r\n    promiseExists(promiseId)\r\n    onlyRecipient(promiseId)\r\n    requires(block.timestamp >= promises[promiseId].lockedUntil)\r\n    requiresOne(\r\n      promises[promiseId].state == PromiseState.pending,\r\n      promises[promiseId].state == PromiseState.confirmed\r\n    )\r\n    nonReentrant\r\n    external\r\n  {\r\n    TokenPromise storage promise = promises[promiseId];\r\n\r\n    unlockTokens(promise, PromiseState.executed);\r\n    if (token.transfer(promise.recipient, promise.amount)) {\r\n      logPromiseFulfilled(promise.promiseId);\r\n    }\r\n    else {\r\n      // everything looked good, but the transfer failed.  :(  Now what?\r\n      // There is no reason to think it will work the next time, so\r\n      // reverting probably won't help here; the tokens would remain locked\r\n      // forever.  Our only hope is that the token owner will resolve the\r\n      // issue in the real world.  Since the amount has been deducted from the\r\n      // locked and pending totals, it has effectively been returned to the owner.\r\n      transition(promise, PromiseState.failed);\r\n      logPromiseUnfulfillable(promiseId, promise.recipient, promise.amount);\r\n    }\r\n  }\r\n\r\n  /***\r\n   * Withdraws the given number of tokens from the locker as long as they are not already locked or promised\r\n   */\r\n  function withdrawUncommittedTokens(uint amount)\r\n    onlyOwner\r\n    requires(amount <= uncommittedTokenBalance())\r\n    nonReentrant\r\n    external\r\n  {\r\n    token.transfer(owner, amount);\r\n  }\r\n\r\n  /***\r\n   * Withdraw all tokens from the wallet that are not locked or promised\r\n   */\r\n  function withdrawAllUncommittedTokens()\r\n    onlyOwner\r\n    nonReentrant\r\n    external\r\n  {\r\n    // not using withdrawUncommittedTokens(uncommittedTokenBalance())\r\n    // to have stronger guarantee on nonReentrant+external\r\n    token.transfer(owner, uncommittedTokenBalance());\r\n  }\r\n\r\n  // tokens can be transferred out by the owner if either\r\n  //  1: The tokens are not the type that are governed by this contract (accidentally sent here, most likely)\r\n  //  2: The tokens are not already promised to a recipient (either pending or confirmed)\r\n  //\r\n  // If neither of these conditions are true, then allowing the owner to transfer the tokens\r\n  // out would violate the purpose of the token locker, which is to prove that the tokens\r\n  // cannot be moved.\r\n  function salvageTokensFromContract(address tokenAddress, address to, uint amount)\r\n    onlyOwner\r\n    requiresOne(\r\n      tokenAddress != address(token),\r\n      amount <= uncommittedTokenBalance()\r\n    )\r\n    nonReentrant\r\n    external\r\n  {\r\n    ERC20(tokenAddress).transfer(to, amount);\r\n  }\r\n\r\n  /***\r\n   * Returns true if the given promise has been confirmed by the recipient\r\n   */\r\n  function isConfirmed(uint256 promiseId)\r\n    constant\r\n    returns(bool)\r\n  {\r\n    return promises[promiseId].state == PromiseState.confirmed;\r\n  }\r\n\r\n  /***\r\n   * Returns true if the give promise can been collected by the recipient\r\n   */\r\n  function canCollect(uint256 promiseId)\r\n    constant\r\n    returns(bool)\r\n  {\r\n    return (promises[promiseId].state == PromiseState.confirmed || promises[promiseId].state == PromiseState.pending)\r\n      && block.timestamp >= promises[promiseId].lockedUntil;\r\n  }\r\n\r\n  // @dev returns the total amount of tokens that are eligible to be collected\r\n  function collectableTokenBalance()\r\n    constant\r\n    returns(uint256 collectable)\r\n  {\r\n    collectable = 0;\r\n    for (uint i=0; i<nextPromiseId; i++) {\r\n      if (canCollect(i)) {\r\n        collectable = collectable.add(promises[i].amount);\r\n      }\r\n    }\r\n    return collectable;\r\n  }\r\n\r\n  /***\r\n   * Return the number of transactions that meet the given criteria.  To be used in conjunction with\r\n   * getPromiseIds()\r\n   *\r\n   * recipient: the recipients address to use for filtering, or 0x0 to return all\r\n   * includeCompleted: true if the list should include transactions that are already executed or canceled\r\n   */\r\n  function getPromiseCount(address recipient, bool includeCompleted)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n  {\r\n    for (uint i=0; i<nextPromiseId; i++) {\r\n      if (recipient != 0x0 && recipient != promises[i].recipient)\r\n        continue;\r\n\r\n        if (includeCompleted\r\n            || promises[i].state == PromiseState.pending\r\n            || promises[i].state == PromiseState.confirmed)\r\n      count += 1;\r\n    }\r\n  }\r\n\r\n  /***\r\n   * Return a list of promiseIds that match the given criteria\r\n   *\r\n   * recipient: the recipients address to use for filtering, or 0x0 to return all\r\n   * includeCompleted: true if the list should include transactions that are already executed or canceled\r\n   */\r\n  function getPromiseIds(uint from, uint to, address recipient, bool includeCompleted)\r\n    public\r\n    constant\r\n    returns (uint[] promiseIds)\r\n  {\r\n    uint[] memory promiseIdsTemp = new uint[](nextPromiseId);\r\n    uint count = 0;\r\n    uint i;\r\n    for (i=0; i<nextPromiseId && count < to; i++) {\r\n      if (recipient != 0x0 && recipient != promises[i].recipient)\r\n        continue;\r\n\r\n      if (includeCompleted\r\n        || promises[i].state == PromiseState.pending\r\n        || promises[i].state == PromiseState.confirmed)\r\n      {\r\n        promiseIdsTemp[count] = i;\r\n        count += 1;\r\n      }\r\n    }\r\n    promiseIds = new uint[](to - from);\r\n    for (i=from; i<to; i++)\r\n      promiseIds[i - from] = promiseIdsTemp[i];\r\n  }\r\n\r\n  /***\r\n   * returns the number of tokens held by the token locker (some might be promised or locked)\r\n   */\r\n  function tokenBalance()\r\n    constant\r\n    returns(uint256)\r\n  {\r\n    return token.balanceOf(address(this));\r\n  }\r\n\r\n  /***\r\n   * returns the number of tokens that are not promised or locked\r\n   */\r\n  function uncommittedTokenBalance()\r\n    constant\r\n    returns(uint256)\r\n  {\r\n    return tokenBalance() - promisedTokenBalance;\r\n  }\r\n\r\n  /***\r\n   * returns the number of tokens that a promised by have not been locked (pending confirmation from recipient)\r\n   */\r\n  function pendingTokenBalance()\r\n    constant\r\n    returns(uint256)\r\n  {\r\n    return promisedTokenBalance - lockedTokenBalance;\r\n  }\r\n\r\n  // ------------------ internal methods ------------------ //\r\n\r\n  // @dev moves the promise to the new state and updates the locked/pending totals accordingly\r\n  function unlockTokens(TokenPromise storage promise, PromiseState newState)\r\n    internal\r\n  {\r\n    promisedTokenBalance = promisedTokenBalance.sub(promise.amount);\r\n    if (promise.state == PromiseState.confirmed) {\r\n      lockedTokenBalance = lockedTokenBalance.sub(promise.amount);\r\n    }\r\n    transition(promise, newState);\r\n  }\r\n\r\n  // @dev add a new state transition to the state transition matrix\r\n  function allowTransition(PromiseState from, PromiseState to)\r\n    requires(!initialized)\r\n    internal\r\n  {\r\n    stateTransitionMatrix[uint(from)][uint(to)] = true;\r\n  }\r\n\r\n  // @dev moves the promise to the new state as long as it's permitted by the state transition matrix\r\n  function transition(TokenPromise storage promise, PromiseState newState)\r\n    internal\r\n  {\r\n    assert(stateTransitionMatrix[uint(promise.state)][uint(newState)]);\r\n    promise.state = newState;\r\n  }\r\n\r\n  // @dev moves the promise to the confirmed state and updates the locked token total\r\n  function doConfirm(TokenPromise storage promise)\r\n    thenAssertState\r\n    internal\r\n  {\r\n    transition(promise, PromiseState.confirmed);\r\n    lockedTokenBalance = lockedTokenBalance.add(promise.amount);\r\n    logPromiseConfirmed(promise.promiseId);\r\n  }\r\n\r\n  /***\r\n   * @dev creates and stores a new promise object, updates the promisedTokenBalance\r\n   */\r\n  function createPromise(address recipient, uint256 amount, uint256 lockedUntil)\r\n    requires(amount <= uncommittedTokenBalance())\r\n    thenAssertState\r\n    internal\r\n    returns(TokenPromise storage promise)\r\n  {\r\n    uint256 promiseId = nextPromiseId++;\r\n    promise = promises[promiseId];\r\n    promise.promiseId = promiseId;\r\n    promise.recipient = recipient;\r\n    promise.amount = amount;\r\n    promise.lockedUntil = lockedUntil;\r\n    promise.state = PromiseState.pending;\r\n\r\n    promisedTokenBalance = promisedTokenBalance.add(promise.amount);\r\n\r\n    logPromiseCreated(promiseId, recipient, amount, lockedUntil);\r\n\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks the uncommitted balance to ensure there the locker has enough tokens to guarantee the\r\n   * amount given can be promised.  If the locker's balance is not enough, the locker will attempt to transfer\r\n   * tokens from the owner.\r\n   */\r\n  function ensureTokensAvailable(uint256 amount)\r\n    onlyOwner\r\n    internal\r\n  {\r\n    uint256 uncommittedBalance = uncommittedTokenBalance();\r\n    if (uncommittedBalance < amount) {\r\n      token.transferFrom(owner, this, amount.sub(uncommittedBalance));\r\n\r\n      // Just assert that the condition we really care about holds, rather\r\n      // than relying on the return value.  see GavCoin and all the tokens copy/pasted therefrom.\r\n      assert(uncommittedTokenBalance() >= amount);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"includeCompleted\",\"type\":\"bool\"}],\"name\":\"getPromiseCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"promises\",\"outputs\":[{\"name\":\"promiseId\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"lockedUntil\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawUncommittedTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllUncommittedTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uncommittedTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"promiseId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"lockup\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promisedTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"includeCompleted\",\"type\":\"bool\"}],\"name\":\"getPromiseIds\",\"outputs\":[{\"name\":\"promiseIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"promiseId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPromiseId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectableTokenBalance\",\"outputs\":[{\"name\":\"collectable\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"promiseId\",\"type\":\"uint256\"}],\"name\":\"confirm\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"promiseId\",\"type\":\"uint256\"}],\"name\":\"canCollect\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"promiseId\",\"type\":\"uint256\"}],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"promiseId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"logPromiseCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"promiseId\",\"type\":\"uint256\"}],\"name\":\"logPromiseConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"promiseId\",\"type\":\"uint256\"}],\"name\":\"logPromiseCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"promiseId\",\"type\":\"uint256\"}],\"name\":\"logPromiseFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"promiseId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"logPromiseUnfulfillable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SingleTokenLocker","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000138a8752093f4f9a79aaedf48d4b9248fab93c9c","Library":"","SwarmSource":"bzzr://cf5d7b40baa4daf5fdea2a3423c4b862ccc543516324bb4de03bdc472d919645"}]}