{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.17;\r\n\r\ncontract Token {\r\n\r\n    /* Total amount of tokens */\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n     * Events\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n\r\n    /// @notice send `value` token to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint value) public returns (bool);\r\n\r\n    /// @notice send `value` token to `to` from `from` on the condition it is approved by `from`\r\n    /// @param from The address of the sender\r\n    /// @param to The address of the recipient\r\n    /// @param value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `value` tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address spender, uint value) public returns (bool);\r\n\r\n    /// @param owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address owner) public constant returns (uint);\r\n\r\n    /// @param owner The address of the account owning tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n}\r\n\r\ncontract StandardToken is Token {\r\n    /*\r\n     *  Storage\r\n    */\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowances;\r\n\r\n    /*\r\n     *  Public functions\r\n    */\r\n\r\n    function transfer(address to, uint value) public returns (bool) {\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((to != 0x0) && (to != address(this)));\r\n        if (balances[msg.sender] < value)\r\n            revert();  // Balance too low\r\n        balances[msg.sender] -= value;\r\n        balances[to] += value;\r\n        Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) public returns (bool) {\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((to != 0x0) && (to != address(this)));\r\n        if (balances[from] < value || allowances[from][msg.sender] < value)\r\n            revert(); // Balance or allowance too low\r\n        balances[to] += value;\r\n        balances[from] -= value;\r\n        allowances[from][msg.sender] -= value;\r\n        Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint value) public returns (bool) {\r\n        allowances[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public constant returns (uint) {\r\n        return allowances[owner][spender];\r\n    }\r\n\r\n    function balanceOf(address owner) public constant returns (uint) {\r\n        return balances[owner];\r\n    }\r\n}\r\n\r\ncontract GMTSafe {\r\n\r\n  /*\r\n  *  GMTSafe parameters\r\n  */\r\n  mapping (address => uint256) allocations;\r\n  uint256 public unlockDate;\r\n  StandardToken public gmtAddress;\r\n\r\n\r\n  function GMTSafe(StandardToken _gmtAddress) public {\r\n    require(address(_gmtAddress) != 0x0);\r\n\r\n    gmtAddress = _gmtAddress;\r\n    unlockDate = now + 6 * 30 days;\r\n\r\n    // Add allocations (must store the token grain amount to be transferred, i.e. 7000 * 10**18)\r\n    allocations[0x6Ab16B4CF38548A6ca0f6666DEf0b7Fb919E2fAb] = 1500000 * 10**18;\r\n    allocations[0x18751880F17E2cdfbb96C2385A82694ff76C9fb4] = 8000000 * 10**18;\r\n    allocations[0x80e97B28f908A49887463e08005A133F7488FcCb] = 6000000 * 10**18;\r\n    allocations[0x68981694e0a4140Db93B1F4f29DCCbB7E63127cf] = 6000000 * 10**18;\r\n    allocations[0xF9a5876A076266b8362A85e26c3b7ce4a338ca6A] = 5500000 * 10**18;\r\n    allocations[0x6FCC6070180E25CBb08a4BF4d2d841914fE3F4D3] = 6000000 * 10**18;\r\n    allocations[0xa0580E8404e07415459cA8E497A9a14c0c9e674e] = 6000000 * 10**18;\r\n    allocations[0x41C341147f76dDe749061A7F114E60B087f5417a] = 3000000 * 10**18;\r\n    allocations[0x53163423D3233fCaF79F3E5b29321A9dC62F7c1b] = 6000000 * 10**18;\r\n    allocations[0x9D8405E32d64F163d4390D4f2128DD20C5eFd2c5] = 6500000 * 10**18;\r\n    allocations[0xe5070738809A16E21146D93bd1E9525539B0537F] = 6000000 * 10**18;\r\n    allocations[0x147c39A17883D1d5c9F95b32e97824a516F02938] = 4000000 * 10**18;\r\n    allocations[0x90dA392F16dBa254C8Ebb2773394A9E2a4693996] = 4000000 * 10**18;\r\n    allocations[0xfd965026631CD4235f7a9BebFcF9B2063A93B89d] = 4000000 * 10**18;\r\n    allocations[0x51d3Fa7e2c61a96C0B93737A6f866F7D92Aaaa64] = 4000000 * 10**18;\r\n    allocations[0x517A577e51298467780a23E3483fD69e617C417d] = 4000000 * 10**18;\r\n    allocations[0x4FdD9136Ccff0acE084f5798EF4973D194d5096a] = 4000000 * 10**18;\r\n    allocations[0x684b9935beA0B3d3FD7Dcd3805E4047E94F753Be] = 4000000 * 10**18;\r\n    allocations[0x753e324cfaF03515b6C3767895F4db764f940c36] = 2000000 * 10**18;\r\n    allocations[0xD2C3b32c3d23BE008a155eBEefF816FA30E9FD33] = 2000000 * 10**18;\r\n    allocations[0x5e8fE6bCdb699837d27eD8F83cD5d822261C9477] = 2000000 * 10**18;\r\n    allocations[0xbf17d390DFBa5543B9BD43eDa921dACf44d5B938] = 2000000 * 10**18;\r\n    allocations[0x13B46bEA905dC7b8BA5A0cc3384cB67af62bBD5d] = 1000000 * 10**18;\r\n    allocations[0xfdB892D3C0dA81F146537aBE224E92d104Ca0FCf] = 1000000 * 10**18;\r\n    allocations[0xc0D51078dfe76238C80b44f91053887a61eF5bC8] = 500000 * 10**18;\r\n    allocations[0xAA989BE25a160d4fb83b12d238133d86f9C1f388] = 450000 * 10**18;\r\n  }\r\n\r\n  /// @notice transfer `allocations[msg.sender]` tokens to `msg.sender` from this contract\r\n  /// @dev The GMT allocations given to the msg.sender are transfered to their account if the lockup period is over\r\n  /// @return boolean indicating whether the transfer was successful or not\r\n  function unlock() external {\r\n    require(now >= unlockDate);\r\n\r\n    uint256 entitled = allocations[msg.sender];\r\n    require(entitled > 0);\r\n    allocations[msg.sender] = 0;\r\n\r\n    if (!StandardToken(gmtAddress).transfer(msg.sender, entitled)) {\r\n        revert();  // Revert state due to unsuccessful refund\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"gmtAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_gmtAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"GMTSafe","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b3bd49e28f8f832b8d1e246106991e546c323502","Library":"","SwarmSource":"bzzr://fefc623b3f40dea6d62d6445e6b9271f4506090dd222f18d987447d14ed2e4b5"}]}