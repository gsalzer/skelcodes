{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SafeMath {\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n    We deleted unused part.\r\n    To see full source code, refer below : \r\n    https://github.com/pipermerriam/ethereum-datetime\r\n\r\n    The MIT License (MIT)\r\n\r\n    Copyright (c) 2015 Piper Merriam\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    of this software and associated documentation files (the \"Software\"), to deal\r\n    in the Software without restriction, including without limitation the rights\r\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the Software is\r\n    furnished to do so, subject to the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included in all\r\n    copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n    SOFTWARE.\r\n*/\r\ncontract DateTime {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) constant returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) constant returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) constant returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) constant returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) constant returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) constant returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) constant returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n}\r\n\r\ncontract ITGTokenBase is ERC20, SafeMath {\r\n\r\n  /* Actual balances of token holders */\r\n  mapping(address => uint) balances;\r\n\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract Authable {\r\n    address public owner;\r\n    address public executor;\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n   \r\n    modifier onlyAuth(){\r\n        require(msg.sender == owner || msg.sender == executor);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner){\r\n        require(owner == 0x0 || owner == msg.sender);\r\n        owner = _owner;\r\n    }\r\n\r\n    function setExecutor(address exec) {\r\n        require(executor == 0x0 || owner == msg.sender || executor == msg.sender);\r\n        executor = exec;\r\n    }\r\n}\r\n\r\ncontract CrowdSale is SafeMath, Authable {\r\n\r\n    struct SaleAttr{\r\n        uint amountRaisedTotal;  // Total funding\r\n\r\n        uint saleSupplyPre; // Supply for Pre crowdSale\r\n        uint saleSupply1; // Supply for 1st crowdSale\r\n        uint saleSupply2; // Supply for 2nd crowdSale\r\n        uint saleSupply3; // Supply for 3rd crowdSale\r\n        uint saleSupply4; // Supply for 4th crowdSale\r\n        \r\n        uint amountRaisedPre;   // Only count Pre crowdSale funding for distribute\r\n        uint amountRaised1;     // Only count 1st crowdSale funding for distribute\r\n        uint amountRaised2;     // Only count 2nd crowdSale funding for just record\r\n        uint amountRaised3;     // Only count 3rd crowdSale funding for distribute\r\n        uint amountRaised4;     // Only count 4th crowdSale funding for just record\r\n\r\n        uint soldSupply2;\r\n        uint soldSupply4;\r\n    }\r\n    SaleAttr public s;\r\n    mapping(address => uint) public participantsForPreSale;    // Pre crowdSale participants\r\n    mapping(address => uint) public participantsFor1stSale;    // 1st crowdSale participants\r\n    mapping(address => uint) public participantsFor3rdSale;    // 3rd crowdSale participants\r\n\r\n    event LogCustomSale(uint startTime, uint endTime, uint tokPerEth, uint supply);\r\n\r\n    struct SaleTimeAttr{\r\n        uint pstart;\r\n        uint pdeadline;\r\n\r\n        // 1st, 3rd sale is time based share\r\n        // 2nd, 4th sale is price sale\r\n        uint start;         // When 1st crowdSale starts\r\n        uint deadline1;     // When 1st crowdSale ends and 2nd crowdSale starts\r\n        uint deadline2;     // When 2nd crowdSale ends\r\n        uint deadline3;     // When 3rd crowdSale ends\r\n        uint deadline4;     // When 4th crowdSale ends\r\n    }\r\n    SaleTimeAttr public t;\r\n\r\n    struct CustomSaleAttr{\r\n        uint start;\r\n        uint end;\r\n        uint tokenPerEth;   // 0 means period sale\r\n        uint saleSupply;\r\n        uint soldSupply;\r\n        uint amountRaised;\r\n    }\r\n    CustomSaleAttr public cs;\r\n    mapping(uint => mapping(address => uint)) public participantsForCustomSale;\r\n\r\n    function setAttrs(uint supplyPre, uint supply1, uint supply2, uint supply3, uint supply4\r\n            , uint preStart, uint preEnd, uint start, uint end1, uint end2, uint end3, uint end4\r\n        ) onlyAuth {\r\n        s.saleSupplyPre = supplyPre; // totalSupply * 10 / 100\r\n        //start, deadline1~4 should be set before start\r\n        s.saleSupply1 = supply1;    //totalSupply * 10 / 100;     // 10% of totalSupply. Total 40% to CrowdSale, 5% to dev team, 55% will be used for game and vote\r\n        s.saleSupply2 = supply2;    //totalSupply *  5 / 100;\r\n        s.saleSupply3 = supply3;    //totalSupply * 10 / 100;\r\n        s.saleSupply4 = supply4;    //totalSupply *  5 / 100;\r\n\r\n        t.pstart = preStart;\r\n        t.pdeadline = preEnd;\r\n        t.start = start;\r\n        t.deadline1 = end1;\r\n        t.deadline2 = end2;\r\n        t.deadline3 = end3;\r\n        t.deadline4 = end4;\r\n    }\r\n\r\n    function setAttrCustom(uint startTime, uint endTime, uint tokPerEth, uint supply) onlyAuth {\r\n        cs.start = startTime;\r\n        cs.end = endTime;\r\n        cs.tokenPerEth = tokPerEth;\r\n        cs.saleSupply = supply;\r\n        cs.soldSupply = 0;\r\n        cs.amountRaised = 0;\r\n        LogCustomSale(startTime, endTime, tokPerEth, supply);\r\n    }\r\n\r\n    function process(address sender, uint sendValue) onlyOwner returns (uint tokenAmount) {\r\n        if(now > t.pstart && now <= t.pdeadline){\r\n            participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue);\r\n            s.amountRaisedPre = add(s.amountRaisedPre, sendValue);\r\n        }else if(now > t.start && now <= t.deadline1){\r\n            participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue);\r\n            s.amountRaised1 = add(s.amountRaised1, sendValue);\r\n        }else if(now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2){\r\n            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\r\n            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\r\n            s.amountRaised2 = add(s.amountRaised2, sendValue);\r\n\r\n            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > t.deadline2 && now <= t.deadline3){\r\n            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\r\n            s.amountRaised3 = add(s.amountRaised3, sendValue);\r\n        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\r\n            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\r\n            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\r\n            s.amountRaised4 = add(s.amountRaised4, sendValue);\r\n\r\n            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\r\n        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\r\n            if(cs.tokenPerEth > 0){\r\n                tokenAmount = sendValue * cs.tokenPerEth;\r\n                cs.soldSupply = add(cs.soldSupply, tokenAmount);\r\n\r\n                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\r\n            }else{\r\n                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\r\n                cs.amountRaised = add(cs.amountRaised, sendValue);\r\n            }\r\n        }else{\r\n            throw;\r\n        }\r\n        s.amountRaisedTotal = add(s.amountRaisedTotal, sendValue);\r\n    }\r\n\r\n    function getToken(address sender) onlyOwner returns (uint tokenAmount){\r\n        if(now > t.pdeadline && participantsForPreSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre);  //Token Amount Per Eth = s.saleSupplyPre / s.amountRaisedPre\r\n            participantsForPreSale[sender] = 0;\r\n        }\r\n        if(now > t.deadline1 && participantsFor1stSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1);  //Token Amount Per Eth = s.saleSupply1 / s.amountRaised1\r\n            participantsFor1stSale[sender] = 0;\r\n        }\r\n        if(now > t.deadline3 && participantsFor3rdSale[sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3);  //Token Amount Per Eth = s.saleSupply3 / s.amountRaised3\r\n            participantsFor3rdSale[sender] = 0;\r\n        }\r\n        if(now > cs.end && participantsForCustomSale[cs.start][sender] != 0){\r\n            tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised);  //Token Amount Per Eth = cs.saleSupply / cs.amountRaised\r\n            participantsForCustomSale[cs.start][sender] = 0;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Voting is SafeMath, Authable {\r\n    mapping(uint => uint) public voteRewardPerUnit; // If the voters vote, they will rewarded x% of tokens by their balances. 100 means 1%, 1000 means 10%\r\n    mapping(uint => uint) public voteWeightUnit;    // If 100 * 1 ether, each 100 * 1 ether token of holder will get vote weight 1. \r\n    mapping(uint => uint) public voteStart;\r\n    mapping(uint => uint) public voteEnd;\r\n    mapping(uint => uint) public maxCandidateId;\r\n\r\n    mapping(uint => mapping(address => bool)) public voted;\r\n    mapping(uint => mapping(uint => uint)) public results;\r\n\r\n    event LogVoteInitiate(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId);\r\n    event LogVote(address voter, uint weight, uint voteId, uint candidateId, uint candidateValue);\r\n\r\n    function voteInitiate(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId) onlyOwner {   \r\n        require(voteEnd[_voteId] == 0);  // Do not allow duplicate voteId\r\n        require(_voteEnd != 0);\r\n\r\n        voteRewardPerUnit[_voteId] = _voteRewardPerUnit;\r\n        voteWeightUnit[_voteId] = _voteWeightUnit;\r\n        voteStart[_voteId] = _voteStart;\r\n        voteEnd[_voteId] = _voteEnd;\r\n        maxCandidateId[_voteId] = _maxCandidateId;\r\n\r\n        LogVoteInitiate(_voteId, _voteRewardPerUnit, _voteWeightUnit, _voteStart, _voteEnd, _maxCandidateId);\r\n    }\r\n\r\n     function vote(address sender, uint holding, uint voteId, uint candidateId) onlyOwner returns (uint tokenAmount, uint lockUntil){\r\n        require(now > voteStart[voteId] && now <= voteEnd[voteId]);\r\n        require(maxCandidateId[voteId] >= candidateId);\r\n        require(holding >= voteRewardPerUnit[voteId]);\r\n        require(!voted[voteId][sender]);\r\n\r\n        uint weight = holding / voteWeightUnit[voteId];\r\n\r\n        results[voteId][candidateId] = add(results[voteId][candidateId], weight);\r\n        voted[voteId][sender] = true;\r\n        tokenAmount = weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100 / 100;\r\n        lockUntil = voteEnd[voteId];\r\n\r\n        LogVote(sender, weight, voteId, candidateId, results[voteId][candidateId]);\r\n    }\r\n}\r\n\r\ncontract Games is SafeMath, DateTime, Authable {\r\n    enum GameTime { Hour, Month, Year, OutOfTime }\r\n    enum GameType { Range, Point}\r\n\r\n    struct Participant {\r\n        address sender;\r\n        uint value;\r\n        uint currency; // 1 : Eth, 2 : Tok\r\n    }\r\n\r\n    struct DateAttr{\r\n        uint currentYear;\r\n        uint gameStart; //Only for Range Game\r\n        uint gameEnd;   //For both Range Game and point Game(=intime timestamp)\r\n        uint prevGameEnd; //Only for Point Game\r\n    }\r\n    DateAttr public d;\r\n\r\n    struct CommonAttr{\r\n        GameTime currentGameTimeType;      // Current Game time type\r\n        GameType gameType;\r\n\r\n        uint hourlyAmountEth;  // Funded Eth amount\r\n        uint monthlyAmountEth;\r\n        uint yearlyAmountEth;\r\n        uint charityAmountEth;\r\n\r\n    }\r\n    CommonAttr public c;\r\n\r\n    struct FundAmountStatusAttr{\r\n        uint hourlyStatusEth;  // Funded Eth amount in current game time\r\n        uint monthlyStatusEth;\r\n        uint yearlyStatusEth;\r\n\r\n        uint hourlyStatusTok;  // Funded Token amount in current game time\r\n        uint monthlyStatusTok;\r\n    }\r\n    FundAmountStatusAttr public f;\r\n\r\n    struct PriceAttr{\r\n        uint bonusPerEth;   // If you not won, xx token to 1 Eth will be rewarded\r\n\r\n        uint inGameTokPricePerEth;   // Regard xx token to 1 Eth for token participants\r\n        uint inGameTokWinRatioMax;   // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\r\n        uint inGameTokWinRatioMin;\r\n        uint currentInGameTokWinRatio;  // Current token winners prize ratio\r\n\r\n        uint hourlyMinParticipateRatio;     // If participants.length are less than 100, x100 would be min prize ratio\r\n        uint monthlyMinParticipateRatio;    // If participants.length are less than 300, x300 would be min prize ratio\r\n        uint yearlyMinParticipateRatio;     // If participants.length are less than 1000, x1000 would be min prize ratio\r\n\r\n        uint boostPrizeEth;    // Boosts prize amount. Default is 100 and it means 100%\r\n    }\r\n    PriceAttr public p;\r\n\r\n\r\n    struct RangeGameAttr{\r\n        uint inTimeRange_H; // 10 means +-10 mins in time\r\n        uint inTimeRange_M;\r\n        uint inTimeRange_Y;\r\n    }\r\n    RangeGameAttr public r;\r\n    Participant[] public participants;  // RangeGame participants\r\n\r\n    mapping(uint256 => mapping(address => uint256)) public winners; // Eth reward\r\n    mapping(uint256 => mapping(address => uint256)) public tokTakers; // Tok reward\r\n    mapping(uint256 => uint256) public winPrizes;\r\n    mapping(uint256 => uint256) public tokPrizes;\r\n\r\n    event LogSelectWinner(uint rand, uint luckyNumber, address sender, uint reward, uint currency, uint amount);\r\n\r\n    function setPriceAttr(\r\n            GameType _gameType, uint _bonusPerEth, uint _inGameTokPricePerEth\r\n            , uint _inGameTokWinRatioMax, uint _inGameTokWinRatioMin, uint _currentInGameTokWinRatio\r\n            , uint _hourlyMinParticipateRatio, uint _monthlyMinParticipateRatio, uint _yearlyMinParticipateRatio, uint _boostPrizeEth\r\n        ) onlyAuth {\r\n        c.gameType = _gameType;\r\n\r\n        p.bonusPerEth = _bonusPerEth;   //300   // Depends on crowdSale average price. Vote needed, but we assume AVG/4 is reasonable.\r\n        p.inGameTokPricePerEth = _inGameTokPricePerEth; //300   // Regard xx token to 1 Eth for token participants. Depends on crowdSale, too.\r\n        p.inGameTokWinRatioMax = _inGameTokWinRatioMax; //50    // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\r\n        p.inGameTokWinRatioMin = _inGameTokWinRatioMin; //25\r\n        p.currentInGameTokWinRatio = _currentInGameTokWinRatio;    //50\r\n        p.hourlyMinParticipateRatio = _hourlyMinParticipateRatio;   //100   // If participants.length are less than 100, x100 would be min prize ratio\r\n        p.monthlyMinParticipateRatio = _monthlyMinParticipateRatio; //300\r\n        p.yearlyMinParticipateRatio = _yearlyMinParticipateRatio;   //1000\r\n        p.boostPrizeEth = _boostPrizeEth;   //100\r\n    }\r\n\r\n    function setRangeGameAttr(uint _inTimeRange_H, uint _inTimeRange_M, uint _inTimeRange_Y) onlyAuth {\r\n        r.inTimeRange_H = _inTimeRange_H;   //10       // 10 mean +-10 mins in time\r\n        r.inTimeRange_M = _inTimeRange_M;   //190 = 3 * 60 + r.inTimeRange_H\r\n        r.inTimeRange_Y = _inTimeRange_Y;   //370 = 6 * 60 + r.inTimeRange_H\r\n    }\r\n     \r\n    // Calulate game time and gc amount record\r\n    modifier beforeRangeGame(){\r\n        require(now > d.gameStart && now <= d.gameEnd);\r\n        _;\r\n    }\r\n\r\n    modifier beforePointGame(){\r\n        refreshGameTime();\r\n        _;\r\n    }\r\n\r\n    function process(address sender, uint sendValue) onlyOwner {\r\n        if(c.gameType == GameType.Range){\r\n            RangeGameProcess(sender, sendValue);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameProcess(sender, sendValue);\r\n        }\r\n    }\r\n\r\n    function processWithITG(address sender, uint tokenAmountToGame) onlyOwner {\r\n        if(c.gameType == GameType.Range){\r\n            RangeGameWithITG(sender, tokenAmountToGame);\r\n        }else if(c.gameType == GameType.Point){\r\n            PointGameWithITG(sender, tokenAmountToGame);\r\n        }\r\n    }\r\n\r\n    // Range Game\r\n    function RangeGameProcess(address sender, uint sendValue) private beforeRangeGame {\r\n        if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }\r\n        participants.push(Participant(sender,sendValue,1));\r\n        if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }\r\n    }\r\n\r\n    function RangeGameWithITG(address sender, uint tokenAmountToGame) private beforeRangeGame {\r\n        require(c.currentGameTimeType != GameTime.Year);\r\n\r\n        if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }\r\n        participants.push(Participant(sender,tokenAmountToGame,2));\r\n    }\r\n\r\n    function getTimeRangeInfo() private returns (GameTime, uint, uint, uint) {\r\n        uint nextTimeStamp;\r\n        uint nextYear;\r\n        uint nextMonth;\r\n        uint basis;\r\n        if(c.gameType == GameType.Range){\r\n            nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\r\n                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours;\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth){\r\n                basis = nextTimeStamp - (nextTimeStamp % 1 days); \r\n                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\r\n            }\r\n            nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours;\r\n            basis = nextTimeStamp - (nextTimeStamp % 1 hours); \r\n            return (GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes);\r\n        }else if(c.gameType == GameType.Point){\r\n            nextTimeStamp = now - (now % 1 hours) + 1 hours;\r\n            nextYear = getYear(nextTimeStamp);\r\n            if(getYear(now) != nextYear){\r\n                return (GameTime.Year, nextYear, 0, nextTimeStamp);\r\n            }\r\n            nextMonth = getMonth(nextTimeStamp);\r\n            if(getMonth(now) != nextMonth){\r\n                return (GameTime.Month, nextYear, 0, nextTimeStamp);\r\n            }\r\n            return (GameTime.Hour, nextYear, 0, nextTimeStamp);\r\n        }\r\n    }\r\n\r\n    function refreshGameTime() private {\r\n        (c.currentGameTimeType, d.currentYear, d.gameStart, d.gameEnd) = getTimeRangeInfo();\r\n    }\r\n\r\n    // Garbage Collect previous funded amount record and log the status\r\n    function gcFundAmount() private {\r\n        f.hourlyStatusEth = 0;\r\n        f.monthlyStatusEth = 0;\r\n        f.yearlyStatusEth = 0;\r\n\r\n        f.hourlyStatusTok = 0;\r\n        f.monthlyStatusTok = 0;\r\n    }\r\n\r\n    function selectWinner(uint rand) onlyOwner {\r\n        uint luckyNumber = participants.length * rand / 100000000;\r\n        uint rewardDiv100 = 0;\r\n\r\n        uint participateRatio = participants.length;\r\n        if(participateRatio != 0){\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\r\n            }\r\n\r\n            if(participants[luckyNumber].currency == 1){\r\n                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\r\n                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\r\n                    p.currentInGameTokWinRatio++;\r\n                }\r\n            }else if(participants[luckyNumber].currency == 2){\r\n                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\r\n                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\r\n                    p.currentInGameTokWinRatio--;\r\n                }\r\n            }\r\n\r\n            if(c.currentGameTimeType == GameTime.Year){\r\n                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\r\n                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\r\n                }else{\r\n                    rewardDiv100 = c.yearlyAmountEth / 104;\r\n                    c.yearlyAmountEth = 0;\r\n                }\r\n            }else if(c.currentGameTimeType == GameTime.Month){\r\n                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\r\n                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\r\n                }else{\r\n                    rewardDiv100 = c.monthlyAmountEth / 107;\r\n                    c.monthlyAmountEth = 0;\r\n                }\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\r\n            }else if(c.currentGameTimeType == GameTime.Hour){\r\n                if(c.hourlyAmountEth >= rewardDiv100*110){\r\n                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\r\n                }else{\r\n                    rewardDiv100 = c.hourlyAmountEth / 110;\r\n                    c.hourlyAmountEth = 0;\r\n                }\r\n                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\r\n                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\r\n            }\r\n            c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4);\r\n\r\n            winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100);\r\n            winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100);\r\n        \r\n            LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value);\r\n\r\n            // Initialize participants\r\n            participants.length = 0;\r\n        }\r\n        if(c.gameType == GameType.Range){\r\n            refreshGameTime();\r\n        }\r\n        gcFundAmount();    \r\n    }\r\n\r\n    //claimAll\r\n    function getPrize(address sender) onlyOwner returns (uint ethPrize, uint tokPrize) {\r\n        ethPrize = add(winners[d.currentYear][sender],winners[d.currentYear-1][sender]);\r\n        tokPrize = add(tokTakers[d.currentYear][sender],tokTakers[d.currentYear-1][sender]);\r\n\r\n        winPrizes[d.currentYear] = sub(winPrizes[d.currentYear],winners[d.currentYear][sender]);\r\n        tokPrizes[d.currentYear] = sub(tokPrizes[d.currentYear],tokTakers[d.currentYear][sender]);\r\n        winners[d.currentYear][sender] = 0;\r\n        tokTakers[d.currentYear][sender] = 0;\r\n\r\n        winPrizes[d.currentYear-1] = sub(winPrizes[d.currentYear-1],winners[d.currentYear-1][sender]);\r\n        tokPrizes[d.currentYear-1] = sub(tokPrizes[d.currentYear-1],tokTakers[d.currentYear-1][sender]);\r\n        winners[d.currentYear-1][sender] = 0;\r\n        tokTakers[d.currentYear-1][sender] = 0;\r\n    }\r\n\r\n    // Point Game\r\n    function PointGameProcess(address sender, uint sendValue) private beforePointGame {\r\n        if(c.currentGameTimeType == GameTime.Year){\r\n            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\r\n            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Month){\r\n            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\r\n            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\r\n            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\r\n        }\r\n\r\n        PointGameParticipate(sender, sendValue, 1);\r\n        \r\n        if(p.bonusPerEth != 0){\r\n            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\r\n            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\r\n        }\r\n    }\r\n\r\n    function PointGameWithITG(address sender, uint tokenAmountToGame) private beforePointGame {\r\n        require(c.currentGameTimeType != GameTime.Year);\r\n\r\n        if(c.currentGameTimeType == GameTime.Month){\r\n            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\r\n        }else if(c.currentGameTimeType == GameTime.Hour){\r\n            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\r\n        }\r\n\r\n        PointGameParticipate(sender, tokenAmountToGame, 2);\r\n    }\r\n\r\n    function PointGameParticipate(address sender, uint sendValue, uint currency) private {\r\n        if(d.prevGameEnd != d.gameEnd){\r\n            selectWinner(1);\r\n        }\r\n        participants.length = 0;\r\n        participants.push(Participant(sender,sendValue,currency));\r\n\r\n        d.prevGameEnd = d.gameEnd;\r\n    }\r\n\r\n    function lossToCharity(uint year) onlyOwner returns (uint amt) {\r\n        require(year < d.currentYear-1);\r\n        \r\n        amt = winPrizes[year];\r\n        tokPrizes[year] = 0;\r\n        winPrizes[year] = 0;\r\n    }\r\n\r\n    function charityAmtToCharity() onlyOwner returns (uint amt) {\r\n        amt = c.charityAmountEth;\r\n        c.charityAmountEth = 0;\r\n    }\r\n\r\n    function distributeTokenSale(uint hour, uint month, uint year, uint charity) onlyOwner{\r\n        c.hourlyAmountEth = add(c.hourlyAmountEth, hour);\r\n        c.monthlyAmountEth = add(c.monthlyAmountEth, month);\r\n        c.yearlyAmountEth = add(c.yearlyAmountEth, year);\r\n        c.charityAmountEth = add(c.charityAmountEth, charity);\r\n    }\r\n}\r\n\r\ncontract ITGToken is ITGTokenBase, Authable {\r\n    bytes32  public  symbol = \"ITG\";\r\n    uint256  public  decimals = 18;\r\n    bytes32   public  name = \"ITG\";\r\n\r\n    enum Status { CrowdSale, Game, Pause }\r\n    Status public status;\r\n\r\n    CrowdSale crowdSale;\r\n    Games games;\r\n    Voting voting;\r\n\r\n    mapping(address => uint) public withdrawRestriction;\r\n\r\n    uint public minEtherParticipate;\r\n    uint public minTokParticipate;\r\n\r\n    event LogFundTransfer(address sender, address to, uint amount, uint8 currency);\r\n\r\n    modifier beforeTransfer(){\r\n        require(withdrawRestriction[msg.sender] < now);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) beforeTransfer returns (bool success) {\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) beforeTransfer returns (bool success) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_to] = add(balances[_to], _value);\r\n        balances[_from] = sub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = sub(_allowance, _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /*  at initialization, setup the owner */\r\n    function ITGToken() {\r\n        owner = msg.sender;\r\n        totalSupply = 100000000 * 1 ether;\r\n        balances[msg.sender] = totalSupply;\r\n\r\n        status = Status.Pause;\r\n    }\r\n    function () payable {\r\n       if(msg.value < minEtherParticipate){\r\n            throw;\r\n       }\r\n\r\n       if(status == Status.CrowdSale){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true);\r\n       }else if(status == Status.Game){\r\n            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\r\n            games.process(msg.sender, msg.value);\r\n       }else if(status == Status.Pause){\r\n            throw;\r\n       }\r\n    }\r\n\r\n    function setAttrs(address csAddr, address gmAddr, address vtAddr, Status _status, uint amtEth, uint amtTok) onlyAuth {\r\n        crowdSale = CrowdSale(csAddr);\r\n        games = Games(gmAddr);\r\n        voting = Voting(vtAddr);\r\n        status = _status;\r\n        minEtherParticipate = amtEth;\r\n        minTokParticipate = amtTok;\r\n    }\r\n\r\n    //getCrowdSaleToken\r\n    function USER_GET_CROWDSALE_TOKEN() {\r\n        itgTokenTransfer(crowdSale.getToken(msg.sender),true);\r\n    }\r\n\r\n    //vote\r\n    function USER_VOTE(uint voteId, uint candidateId){\r\n        uint addedToken;\r\n        uint lockUntil;\r\n        (addedToken, lockUntil) = voting.vote(msg.sender,balances[msg.sender],voteId,candidateId);\r\n        itgTokenTransfer(addedToken,true);\r\n\r\n        if(withdrawRestriction[msg.sender] < lockUntil){\r\n            withdrawRestriction[msg.sender] = lockUntil;\r\n        }\r\n    }\r\n\r\n    function voteInitiate(uint voteId, uint voteRewardPerUnit, uint voteWeightUnit, uint voteStart, uint voteEnd, uint maxCandidateId) onlyAuth {\r\n        voting.voteInitiate(voteId, voteRewardPerUnit, voteWeightUnit, voteStart, voteEnd, maxCandidateId);\r\n    }\r\n\r\n    function itgTokenTransfer(uint amt, bool fromOwner) private {\r\n        if(amt > 0){\r\n            if(fromOwner){\r\n                balances[owner] = sub(balances[owner], amt);\r\n                balances[msg.sender] = add(balances[msg.sender], amt);\r\n                Transfer(owner, msg.sender, amt);\r\n                LogFundTransfer(owner, msg.sender, amt, 2);\r\n            }else{\r\n                balances[owner] = add(balances[owner], amt);\r\n                balances[msg.sender] = sub(balances[msg.sender], amt);\r\n                Transfer(msg.sender, owner, amt);\r\n                LogFundTransfer(msg.sender, owner, amt, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    function ethTransfer(address target, uint amt) private {\r\n        if(amt > 0){\r\n            target.transfer(amt);\r\n            LogFundTransfer(0x0, target, amt, 1);\r\n        }\r\n    }\r\n\r\n    //gameWithToken\r\n    function USER_GAME_WITH_TOKEN(uint tokenAmountToGame) {\r\n        require(status == Status.Game);\r\n        require(balances[msg.sender] >= tokenAmountToGame * 1 ether);\r\n        require(tokenAmountToGame * 1 ether >= minTokParticipate);\r\n\r\n        itgTokenTransfer(tokenAmountToGame * 1 ether,false);\r\n\r\n        games.processWithITG(msg.sender, tokenAmountToGame * 1 ether);\r\n        \r\n    }\r\n\r\n    //getPrize\r\n    function USER_GET_PRIZE() {\r\n        uint ethPrize;\r\n        uint tokPrize;\r\n        (ethPrize, tokPrize) = games.getPrize(msg.sender);\r\n        itgTokenTransfer(tokPrize,true);\r\n        ethTransfer(msg.sender, ethPrize);\r\n    }\r\n\r\n    function selectWinner(uint rand) onlyAuth {\r\n        games.selectWinner(rand);\r\n    }\r\n\r\n    function burn(uint amt) onlyOwner {\r\n        balances[msg.sender] = sub(balances[msg.sender], amt);\r\n        totalSupply = sub(totalSupply,amt);\r\n    }\r\n\r\n    function mint(uint amt) onlyOwner {\r\n        balances[msg.sender] = add(balances[msg.sender], amt);\r\n        totalSupply = add(totalSupply,amt);\r\n    }\r\n\r\n    // We do not want big difference with our contract's balance and actual prize pool.\r\n    // So the ethereum that the winners didn't get over at least 1 year will be used for our charity business.\r\n    // We strongly hope winners get their prize after the game.\r\n    function lossToCharity(uint year,address charityAccount) onlyAuth {\r\n        ethTransfer(charityAccount, games.lossToCharity(year));\r\n    }\r\n\r\n    function charityAmtToCharity(address charityAccount) onlyOwner {\r\n        ethTransfer(charityAccount, games.charityAmtToCharity());\r\n    }\r\n\r\n    function distributeTokenSale(uint hour, uint month, uint year, uint charity) onlyAuth{\r\n        games.distributeTokenSale(hour, month, year, charity);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"USER_GET_CROWDSALE_TOKEN\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exec\",\"type\":\"address\"}],\"name\":\"setExecutor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"charityAccount\",\"type\":\"address\"}],\"name\":\"charityAmtToCharity\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rand\",\"type\":\"uint256\"}],\"name\":\"selectWinner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTokParticipate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"csAddr\",\"type\":\"address\"},{\"name\":\"gmAddr\",\"type\":\"address\"},{\"name\":\"vtAddr\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"uint8\"},{\"name\":\"amtEth\",\"type\":\"uint256\"},{\"name\":\"amtTok\",\"type\":\"uint256\"}],\"name\":\"setAttrs\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"voteId\",\"type\":\"uint256\"},{\"name\":\"candidateId\",\"type\":\"uint256\"}],\"name\":\"USER_VOTE\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawRestriction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"voteId\",\"type\":\"uint256\"},{\"name\":\"voteRewardPerUnit\",\"type\":\"uint256\"},{\"name\":\"voteWeightUnit\",\"type\":\"uint256\"},{\"name\":\"voteStart\",\"type\":\"uint256\"},{\"name\":\"voteEnd\",\"type\":\"uint256\"},{\"name\":\"maxCandidateId\",\"type\":\"uint256\"}],\"name\":\"voteInitiate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hour\",\"type\":\"uint256\"},{\"name\":\"month\",\"type\":\"uint256\"},{\"name\":\"year\",\"type\":\"uint256\"},{\"name\":\"charity\",\"type\":\"uint256\"}],\"name\":\"distributeTokenSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minEtherParticipate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmountToGame\",\"type\":\"uint256\"}],\"name\":\"USER_GAME_WITH_TOKEN\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"year\",\"type\":\"uint256\"},{\"name\":\"charityAccount\",\"type\":\"address\"}],\"name\":\"lossToCharity\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"USER_GET_PRIZE\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"uint8\"}],\"name\":\"LogFundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ITGToken","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b7e9e2b668be4d7a2d31df1618299c5d3e306af5dfebf2eb6192346821945808"}]}