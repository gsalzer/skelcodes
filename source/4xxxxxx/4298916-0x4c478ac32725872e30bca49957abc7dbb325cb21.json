{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n    //Безопасное умножение.\r\n\t//Safe multiplication.\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\t//Безопасное деление.\r\n\t//Safe division.\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\t//Безопасное вычитание.\r\n\t//Safe subtraction.\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\t//Безопасное сложение.\r\n\t//Safe addition.\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  \r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract COIN is Ownable {\r\n    \r\n    using SafeMath for uint256;\r\n\t\r\n\tstring public constant name = \"daoToken\";\r\n    string public constant symbol = \"dao\";\r\n    uint8 constant decimals = 18;\r\n    \r\n    bytes32 constant password = keccak256(\"...And Justice For All!\");\r\n\tbytes32 constant fin = keccak256(\"...I Saw The Throne Of Gods...\");\r\n    \r\n    mapping (address => uint256) balances;\r\n    uint256 public totalSupply = 0;\r\n    bool public mintingFinished = false;\r\n    \r\n    modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n    }\r\n    \r\n    function COIN(){\r\n        mintingFinished = false;\r\n        totalSupply = 0;\r\n    }\r\n  \r\n    mapping (address => mapping(address => uint256)) allowed;\r\n    \r\n    function totalSupply() constant returns (uint256 total_Supply) {\r\n        return totalSupply;\r\n    }\r\n    \r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n  \r\n    function allowance(address _owner, address _spender)constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n  \r\n    function approve(address _spender, uint256 _value)returns (bool) {\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n  \r\n    function transferFrom(address _from, address _to, uint256 _value)returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  } \r\n  \r\n    function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n  }\r\n  \r\n    function passwordMint(address _to, uint256 _amount, bytes32 _pswd) canMint returns (bool) {\r\n\trequire(_pswd == password);\t\t\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n  }\r\n\r\n    function finishMinting() onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n}\r\n\r\n/*contract DAOcoin is Coin {\r\n  \r\n      \r\n    string public constant name = \"DaoToken\";\r\n    string public constant symbol = \"DAO\";\r\n    uint8 constant decimals = 18;\r\n    function DAOcoin(){}\r\n}*/\r\n\r\ncontract daocrowdsale is Ownable {\r\n    using SafeMath for uint256;\r\n    bytes32 constant password = keccak256(\"...And Justice For All!\");\r\n\tbytes32 constant fin = keccak256(\"...I Saw The Throne Of Gods...\");\r\n\t\r\n\tCOIN public DAO;\r\n    \r\n    uint256 public constant price = 500 finney;\r\n\t  \r\n    enum State {READY, LAUNCHED, STAGE1, STAGE2, STAGE3, FAIL}\r\n    \r\n    struct values {\r\n        uint256 hardcap;\r\n        uint256 insuranceFunds;\r\n        uint256 premial;\r\n        uint256 reservance;\r\n    }  \r\n     \r\n    State currentState;\r\n    uint256 timeOfNextShift;\r\n    uint256 timeOfPreviousShift;\r\n\r\n    values public Values; \r\n    \r\n    \r\n    function daocrowdsale(address _token){\r\n\t\tDAO = COIN(_token);\r\n        Values.hardcap = 438200;\r\n        assert(DAO.passwordMint(owner, 5002, password));\r\n        Values.insuranceFunds = 5002;\r\n        assert(DAO.passwordMint(owner, 13000, password));\r\n        Values.premial = 13000;\r\n        assert(DAO.passwordMint(owner, 200, password));\r\n        Values.reservance = 200;\r\n        currentState = State.LAUNCHED;\r\n        timeOfPreviousShift = now;\r\n        timeOfNextShift = (now + 30 * (1 days));\r\n     }\r\n     \r\n    function StateShift(string _reason) private returns (bool){\r\n        require(!(currentState == State.FAIL));\r\n        if (currentState == State.STAGE3) return false;\r\n        if (currentState == State.STAGE2) {\r\n            currentState = State.STAGE3;\r\n            timeOfPreviousShift = block.timestamp;\r\n            timeOfNextShift = (now + 3650 * (1 days));\r\n            StateChanged(State.STAGE3, now, _reason);\r\n            return true;\r\n        }\r\n        if (currentState == State.STAGE1) {\r\n            currentState = State.STAGE2;\r\n            timeOfPreviousShift = block.timestamp;\r\n            timeOfNextShift = (now + 30 * (1 days));\r\n            StateChanged(State.STAGE2, now, _reason);\r\n            return true;\r\n        }\r\n        if (currentState == State.LAUNCHED) {\r\n            currentState = State.STAGE1;\r\n            timeOfPreviousShift = block.timestamp;\r\n            timeOfNextShift = (now + 30 * (1 days));\r\n            StateChanged(State.STAGE1, now, _reason);\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function GetCurrentState() constant returns (State){\r\n        return currentState;\r\n    }\r\n    \r\n    function TimeCheck() private constant returns (bool) {\r\n        if (timeOfNextShift > block.timestamp) return true;\r\n        return false;\r\n    }\r\n    \r\n    function StartNewStage() private returns (bool){\r\n        Values.hardcap = Values.hardcap.add(438200);\r\n        Values.insuranceFunds = Values.insuranceFunds.add(5002);\r\n        Values.premial = Values.premial.add(1300);\r\n        Values.reservance = Values.reservance.add(200);\r\n        return true;\r\n    }\r\n    \r\n    modifier IsOutdated() {\r\n        if(!TimeCheck()){\r\n            _;\r\n            StateShift(\"OUTDATED\");\r\n        }\r\n        else _;\r\n    }\r\n    \r\n    modifier IsBought(uint256 _amount, uint256 _total){\r\n        if(_amount >= _total){\r\n        _;\r\n        StateShift(\"SUCCEED\");\r\n        StartNewStage();\r\n        }\r\n        else _;\r\n    }\r\n    \r\n  /*  function masterMint(address _to, uint256 _amount) IsOutdated IsBought(totalSupply(), Values.hardcap) private returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n  } */\r\n    \r\n    function masterBalanceOf(bytes32 _pswd, address _owner) IsOutdated IsBought(DAO.totalSupply(), Values.hardcap) constant returns (uint256 balance) {\r\n\trequire(_pswd == password);\r\n        return DAO.balanceOf(_owner);\r\n    }\r\n\t\r\n\tfunction totalCoinSupply()constant returns (uint256){\r\n\t\treturn DAO.totalSupply();\r\n\t}\r\n\t\r\n    function buy (uint256 _amount) IsOutdated IsBought(DAO.totalSupply(), Values.hardcap) payable returns (bool) {\r\n    require((msg.value == price*_amount)&&(_amount <= (Values.hardcap - DAO.totalSupply())));\r\n\towner.transfer(msg.value);\r\n    DAO.passwordMint(msg.sender, _amount, password);\r\n    Deal(msg.sender, _amount);\r\n    return true;\r\n   }\r\n   \r\n    function masterFns(bytes32 _pswd) returns (bool){\r\n\trequire(_pswd == fin);\r\n    selfdestruct(msg.sender);\r\n   }\r\n\r\nfunction()payable{\r\n       require(msg.value >= price);\r\n\taddress buyer = msg.sender;\r\n    uint256 refund = (msg.value) % price;\r\n    uint256 accepted = (msg.value) / price;\r\n    assert(accepted + DAO.totalSupply() <= Values.hardcap);\r\n    if (refund != 0){\r\n        buyer.transfer(refund);\r\n    }\r\n\tif (accepted != 0){\r\n\t\towner.transfer(msg.value);\r\n\t\tDAO.passwordMint(buyer, accepted, password);\r\n\t}\r\n\tDeal (buyer, accepted);\r\n   }\r\n    event StateChanged (State indexed _currentState, uint256 _time, string _reason);\r\n    event Deal(address indexed _trader, uint256 _amount);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_pswd\",\"type\":\"bytes32\"}],\"name\":\"passwordMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total_Supply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"}]","ContractName":"COIN","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://50119ff2083f9cb0c8f5502f68c25a9a14f956ec58150efbbf84bc6a4678a317"}]}