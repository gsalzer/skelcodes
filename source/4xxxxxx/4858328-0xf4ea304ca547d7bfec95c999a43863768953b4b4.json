{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract Base {\r\n\r\n    modifier only(address allowed) {\r\n        require(msg.sender == allowed);\r\n        _;\r\n    }\r\n\r\n    // *************************************************\r\n    // *          reentrancy handling                  *\r\n    // *************************************************\r\n    uint private bitlocks = 0;\r\n\r\n    modifier noAnyReentrancy {\r\n        var _locks = bitlocks;\r\n        require(_locks == 0);\r\n        bitlocks = uint(-1);\r\n        _;\r\n        bitlocks = _locks;\r\n    }\r\n}\r\n\r\ncontract TokenTimeLock {\r\n\r\n    IToken public token;\r\n    address public beneficiary;\r\n    uint public releaseTimeFirst;\r\n    uint public amountFirst;\r\n\r\n    function TokenTimeLock(IToken _token, address _beneficiary, uint _releaseTimeFirst, uint _amountFirst)\r\n    public\r\n    {\r\n        require(_releaseTimeFirst > now);\r\n        token = _token;\r\n        beneficiary = _beneficiary;\r\n        releaseTimeFirst = _releaseTimeFirst;\r\n        amountFirst = _amountFirst;\r\n    }\r\n\r\n    function releaseFirst() public {\r\n        require(now >= releaseTimeFirst);\r\n        uint amount = token.balanceOf(this);\r\n        require(amount > 0 && amount >= amountFirst);\r\n        token.transfer(beneficiary, amountFirst);\r\n    }\r\n}\r\n\r\ncontract IToken {\r\n    function mint(address _to, uint _amount) public;\r\n    function start() public;\r\n    function getTotalSupply()  public returns(uint);\r\n    function balanceOf(address _owner)  public returns(uint);\r\n    function transfer(address _to, uint _amount)  public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value)  public returns (bool success);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owned is Base {\r\n    address public owner;\r\n    address newOwner;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public only(owner) {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public only(newOwner) {\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n}\r\n\r\ncontract ATFSCrowdsale is Owned\r\n{\r\n\r\n    using SafeMath for uint;\r\n\r\n    //\r\n    //\r\n    enum State { INIT, ICO, TOKEN_DIST, CLOSED, EMERGENCY_STOP }\r\n\r\n    uint public constant MAX_SALE_SUPPLY \t\t= 35 * (10**15);\r\n    uint public constant MAX_NON_SALE_SUPPLY \t= 18 * (10**15);\r\n\r\n    State public currentState = State.INIT;\r\n\r\n    IToken public token;\r\n\r\n    uint public totalSaleSupply \t= 0;\r\n    uint public totalNonSaleSupply \t= 0;\r\n\r\n    mapping( address => TokenTimeLock ) lockBalances;\r\n\r\n    modifier inState( State _state ) {\r\n        require(currentState == _state);\r\n        _;\r\n    }\r\n\r\n    modifier inICOExtended( ) {\r\n        require( currentState == State.ICO || currentState == State.TOKEN_DIST );\r\n        _;\r\n    }\r\n\r\n    //\r\n\t// constructor\r\n\t//\r\n  //\r\n  // constructor\r\n  //\r\n  function ATFSCrowdsale( ) public {\r\n  }\r\n\r\n  function setToken( IToken _token ) public only( owner ) {\r\n    require( _token != address( 0 ) );\r\n      token = _token;\r\n    }\r\n\r\n    //\r\n    // change state\r\n    //\r\n    // no chance to recover from EMERGENY_STOP ( just never do that ?? )\r\n    //\r\n    function setState( State _newState ) public only(owner)\r\n    {\r\n        require(\r\n           ( currentState == State.INIT && _newState == State.ICO )\r\n        || ( currentState == State.ICO && _newState == State.TOKEN_DIST )\r\n        || ( currentState == State.TOKEN_DIST && _newState == State.CLOSED )\r\n        || _newState == State.EMERGENCY_STOP\r\n        );\r\n        currentState = _newState;\r\n        if( _newState == State.CLOSED ) {\r\n            _finish( );\r\n        }\r\n    }\r\n\r\n    //\r\n    // mint to investor ( sale )\r\n    //\r\n    function mintInvestor( address _to, uint _amount ) public only(owner) inState( State.TOKEN_DIST )\r\n    {\r\n     \trequire( totalSaleSupply.add( _amount ) <= MAX_SALE_SUPPLY );\r\n        totalSaleSupply = totalSaleSupply.add( _amount );\r\n        _mint( _to, _amount );\r\n    }\r\n\r\n    //\r\n    // mint to partner ( non-sale )\r\n    //\r\n    function mintPartner( address _to, uint _amount ) public only( owner ) inState( State.TOKEN_DIST )\r\n    {\r\n    \trequire( totalNonSaleSupply.add( _amount ) <= MAX_NON_SALE_SUPPLY );\r\n    \ttotalNonSaleSupply = totalNonSaleSupply.add( _amount );\r\n    \t_mint( _to, _amount );\r\n    }\r\n\r\n    //\r\n    // mint to partner with lock ( non-sale )\r\n    //\r\n    // [caution] do not mint again before token-receiver retrieves the previous tokens\r\n    //\r\n    function mintPartnerWithLock( address _to, uint _amount, uint _unlockDate ) public only( owner ) inICOExtended( )\r\n    {\r\n    \trequire( totalNonSaleSupply.add( _amount ) <= MAX_NON_SALE_SUPPLY );\r\n        totalNonSaleSupply = totalNonSaleSupply.add( _amount );\r\n\r\n        TokenTimeLock tokenTimeLock = new TokenTimeLock( token, _to, _unlockDate, _amount );\r\n        lockBalances[_to] = tokenTimeLock;\r\n        _mint( address(tokenTimeLock), _amount );\r\n    }\r\n\r\n    function unlockAccount( ) public inState( State.CLOSED )\r\n    {\r\n        require( address( lockBalances[msg.sender] ) != 0 );\r\n        lockBalances[msg.sender].releaseFirst();\r\n    }\r\n\r\n    //\r\n    // mint to private investor ( sale, ICO )\r\n    //\r\n    function mintPrivate( address _to, uint _amount ) public only( owner ) inState( State.ICO )\r\n    {\r\n    \trequire( totalSaleSupply.add( _amount ) <= MAX_SALE_SUPPLY );\r\n    \ttotalSaleSupply = totalSaleSupply.add( _amount );\r\n    \t_mint( _to, _amount );\r\n    }\r\n\r\n    //\r\n    // internal function\r\n    //\r\n    function _mint( address _to, uint _amount ) noAnyReentrancy internal\r\n    {\r\n        token.mint( _to, _amount );\r\n    }\r\n\r\n    function _finish( ) noAnyReentrancy internal\r\n    {\r\n        token.start( );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalNonSaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintPrivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintPartner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newState\",\"type\":\"uint8\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SALE_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_unlockDate\",\"type\":\"uint256\"}],\"name\":\"mintPartnerWithLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_NON_SALE_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ATFSCrowdsale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6d03875f64f2934b5e6242e3ffb8eaac0ae952aac4ebe57f67d302931d04c54a"}]}