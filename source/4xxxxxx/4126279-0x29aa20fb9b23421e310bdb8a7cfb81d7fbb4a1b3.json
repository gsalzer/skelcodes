{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Helps contracts guard agains rentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private rentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\n\r\n// Minimal Bitcoineum interface for proxy mining\r\ncontract BitcoineumInterface {\r\n   function mine() payable;\r\n   function claim(uint256 _blockNumber, address forCreditTo);\r\n   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool);\r\n   function checkWinning(uint256 _blockNum) constant public returns (bool);\r\n   function transfer(address _to, uint256 _value) returns (bool);\r\n   function balanceOf(address _owner) constant returns (uint256 balance);\r\n   function currentDifficultyWei() constant public returns (uint256);\r\n   }\r\n\r\n\r\n// Sharkpool is a rolling window Bitcoineum miner\r\n// Smart contract based virtual mining\r\n// http://www.bitcoineum.com/\r\n\r\ncontract SharkPool is Ownable, ReentrancyGuard {\r\n\r\n    string constant public pool_name = \"SharkPool 100\";\r\n\r\n    // Percentage of BTE pool takes for operations\r\n    uint256 public pool_percentage = 0;\r\n\r\n    // Limiting users because of gas limits\r\n    // I would not increase this value it could make the pool unstable\r\n    uint256 constant public max_users = 100;\r\n\r\n    // Track total users to switch to degraded case when contract is full\r\n    uint256 public total_users = 0;\r\n\r\n    uint256 public constant divisible_units = 10000000;\r\n\r\n    // How long will a payment event mine blocks for you\r\n    uint256 public contract_period = 100;\r\n    uint256 public mined_blocks = 1;\r\n    uint256 public claimed_blocks = 1;\r\n    uint256 public blockCreationRate = 0;\r\n\r\n    BitcoineumInterface base_contract;\r\n\r\n    struct user {\r\n        uint256 start_block;\r\n        uint256 end_block;\r\n        uint256 proportional_contribution;\r\n    }\r\n\r\n    mapping (address => user) public users;\r\n    mapping (uint256 => uint256) public attempts;\r\n    mapping(address => uint256) balances;\r\n    uint8[] slots;\r\n    address[256] public active_users; // Should equal max_users\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n      return balances[_owner];\r\n    }\r\n\r\n    function set_pool_percentage(uint8 _percentage) external nonReentrant onlyOwner {\r\n       // Just in case owner is compromised\r\n       require(_percentage < 6);\r\n       pool_percentage = _percentage;\r\n    }\r\n\r\n\r\n    function find_contribution(address _who) constant external returns (uint256, uint256, uint256, uint256, uint256) {\r\n      if (users[_who].start_block > 0) {\r\n         user memory u = users[_who];\r\n         uint256 remaining_period= 0;\r\n         if (u.end_block > mined_blocks) {\r\n            remaining_period = u.end_block - mined_blocks;\r\n            } else {\r\n            remaining_period = 0;\r\n            }\r\n         return (u.start_block, u.end_block,\r\n                 u.proportional_contribution,\r\n                 u.proportional_contribution * contract_period,\r\n                 u.proportional_contribution * remaining_period);\r\n      }\r\n      return (0,0,0,0,0);\r\n    }\r\n\r\n    function allocate_slot(address _who) internal {\r\n       if(total_users < max_users) { \r\n            // Just push into active_users\r\n            active_users[total_users] = _who;\r\n            total_users += 1;\r\n          } else {\r\n            // The maximum users have been reached, can we allocate a free space?\r\n            if (slots.length == 0) {\r\n                // There isn't any room left\r\n                revert();\r\n            } else {\r\n               uint8 location = slots[slots.length-1];\r\n               active_users[location] = _who;\r\n               delete slots[slots.length-1];\r\n            }\r\n          }\r\n    }\r\n\r\n     function external_to_internal_block_number(uint256 _externalBlockNum) public constant returns (uint256) {\r\n        // blockCreationRate is > 0\r\n        return _externalBlockNum / blockCreationRate;\r\n     }\r\n\r\n     function available_slots() public constant returns (uint256) {\r\n        if (total_users < max_users) {\r\n            return max_users - total_users;\r\n        } else {\r\n          return slots.length;\r\n        }\r\n     }\r\n  \r\n   event LogEvent(\r\n       uint256 _info\r\n   );\r\n\r\n    function get_bitcoineum_contract_address() public constant returns (address) {\r\n       return 0x73dD069c299A5d691E9836243BcaeC9c8C1D8734; // Production\r\n    \r\n       // return 0x7e7a299da34a350d04d204cd80ab51d068ad530f; // Testing\r\n    }\r\n\r\n    // iterate over all account holders\r\n    // and balance transfer proportional bte\r\n    // balance should be 0 aftwards in a perfect world\r\n    function distribute_reward(uint256 _totalAttempt, uint256 _balance) internal {\r\n      uint256 remaining_balance = _balance;\r\n      for (uint8 i = 0; i < total_users; i++) {\r\n          address user_address = active_users[i];\r\n          if (user_address > 0 && remaining_balance != 0) {\r\n              uint256 proportion = users[user_address].proportional_contribution;\r\n              uint256 divided_portion = (proportion * divisible_units) / _totalAttempt;\r\n              uint256 payout = (_balance * divided_portion) / divisible_units;\r\n              if (payout > remaining_balance) {\r\n                 payout = remaining_balance;\r\n              }\r\n              balances[user_address] = balances[user_address] + payout;\r\n              remaining_balance = remaining_balance - payout;\r\n          }\r\n      }\r\n    }\r\n\r\n    function SharkPool() {\r\n      blockCreationRate = 50; // match bte\r\n      base_contract = BitcoineumInterface(get_bitcoineum_contract_address());\r\n    }\r\n\r\n    function current_external_block() public constant returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n\r\n    function calculate_minimum_contribution() public constant returns (uint256)  {\r\n       return base_contract.currentDifficultyWei() / 10000000 * contract_period;\r\n    }\r\n\r\n    // A default ether tx without gas specified will fail.\r\n    function () payable {\r\n         require(msg.value >= calculate_minimum_contribution());\r\n\r\n         // Did the user already contribute\r\n         user storage current_user = users[msg.sender];\r\n\r\n         // Does user exist already\r\n         if (current_user.start_block > 0) {\r\n            if (current_user.end_block > mined_blocks) {\r\n                uint256 periods_left = current_user.end_block - mined_blocks;\r\n                uint256 amount_remaining = current_user.proportional_contribution * periods_left;\r\n                amount_remaining = amount_remaining + msg.value;\r\n                amount_remaining = amount_remaining / contract_period;\r\n                current_user.proportional_contribution = amount_remaining;\r\n            } else {\r\n               current_user.proportional_contribution = msg.value / contract_period;\r\n            }\r\n\r\n          // If the user exists and has a balance let's transfer it to them\r\n          do_redemption();\r\n\r\n          } else {\r\n               current_user.proportional_contribution = msg.value / contract_period;\r\n               allocate_slot(msg.sender);\r\n          }\r\n          current_user.start_block = mined_blocks;\r\n          current_user.end_block = mined_blocks + contract_period;\r\n         }\r\n\r\n    \r\n    // Proxy mining to token\r\n   function mine() external nonReentrant\r\n   {\r\n     // Did someone already try to mine this block?\r\n     uint256 _blockNum = external_to_internal_block_number(current_external_block());\r\n     require(!base_contract.checkMiningAttempt(_blockNum, this));\r\n\r\n     // Alright nobody mined lets iterate over our active_users\r\n\r\n     uint256 total_attempt = 0;\r\n     uint8 total_ejected = 0; \r\n\r\n     for (uint8 i=0; i < total_users; i++) {\r\n         address user_address = active_users[i];\r\n         if (user_address > 0) {\r\n             // This user exists\r\n             user memory u = users[user_address];\r\n             if (u.end_block <= mined_blocks) {\r\n                // This user needs to be ejected, no more attempts left\r\n                // but we limit to 20 to prevent gas issues on slot insert\r\n                if (total_ejected < 10) {\r\n                    delete active_users[i];\r\n                    slots.push(i);\r\n                    delete users[active_users[i]];\r\n                    total_ejected = total_ejected + 1;\r\n                }\r\n             } else {\r\n               // This user is still active\r\n               total_attempt = total_attempt + u.proportional_contribution;\r\n             }\r\n         }\r\n     }\r\n     if (total_attempt > 0) {\r\n        // Now we have a total contribution amount\r\n        attempts[_blockNum] = total_attempt;\r\n        base_contract.mine.value(total_attempt)();\r\n        mined_blocks = mined_blocks + 1;\r\n     }\r\n   }\r\n\r\n   function claim(uint256 _blockNumber, address forCreditTo)\r\n                  nonReentrant\r\n                  external returns (bool) {\r\n                  \r\n                  // Did we win the block in question\r\n                  require(base_contract.checkWinning(_blockNumber));\r\n\r\n                  uint256 initial_balance = base_contract.balanceOf(this);\r\n\r\n                  // We won let's get our reward\r\n                  base_contract.claim(_blockNumber, this);\r\n\r\n                  uint256 balance = base_contract.balanceOf(this);\r\n                  uint256 total_attempt = attempts[_blockNumber];\r\n\r\n                  distribute_reward(total_attempt, balance - initial_balance);\r\n                  claimed_blocks = claimed_blocks + 1;\r\n                  }\r\n\r\n   function do_redemption() internal {\r\n     uint256 balance = balances[msg.sender];\r\n     if (balance > 0) {\r\n        uint256 owner_cut = (balance / 100) * pool_percentage;\r\n        uint256 remainder = balance - owner_cut;\r\n        if (owner_cut > 0) {\r\n            base_contract.transfer(owner, owner_cut);\r\n        }\r\n        base_contract.transfer(msg.sender, remainder);\r\n        balances[msg.sender] = 0;\r\n    }\r\n   }\r\n\r\n   function redeem() external nonReentrant\r\n     {\r\n        do_redemption();\r\n     }\r\n\r\n   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool) {\r\n      return base_contract.checkMiningAttempt(_blockNum, _sender);\r\n   }\r\n   \r\n   function checkWinning(uint256 _blockNum) constant public returns (bool) {\r\n     return base_contract.checkWinning(_blockNum);\r\n   }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"current_external_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimed_blocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculate_minimum_contribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool_name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"attempts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"available_slots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divisible_units\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"checkMiningAttempt\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mine\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"find_contribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"start_block\",\"type\":\"uint256\"},{\"name\":\"end_block\",\"type\":\"uint256\"},{\"name\":\"proportional_contribution\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockCreationRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mined_blocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_users\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_bitcoineum_contract_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNum\",\"type\":\"uint256\"}],\"name\":\"checkWinning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"forCreditTo\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool_percentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentage\",\"type\":\"uint8\"}],\"name\":\"set_pool_percentage\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_users\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"active_users\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_externalBlockNum\",\"type\":\"uint256\"}],\"name\":\"external_to_internal_block_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_info\",\"type\":\"uint256\"}],\"name\":\"LogEvent\",\"type\":\"event\"}]","ContractName":"SharkPool","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ad3aba2b9338c3c58e5c1744da6217b18f6f75a9ce0d1cea621e7fc59c074997"}]}