{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/*\r\nauthor : dungeon\r\n\r\nA contract for doing pools with only one contract.\r\n*/\r\n\r\n// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 {\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n}\r\n\r\ncontract Controller {\r\n    //The addy of the developer\r\n    address public developer = 0xEE06BdDafFA56a303718DE53A5bc347EfbE4C68f;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == developer);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract SanityPools is Controller {\r\n\r\n    //mapping of the pool's index with the corresponding balances\r\n    mapping (uint256 => mapping (address => uint256)) balances;\r\n    //Array of 100 pools max\r\n    Pool[100] pools;\r\n    //Index of the active pool\r\n    uint256 index_active = 0;\r\n    //Allows an emergency withdraw after 1 week after the buy : 7*24*60*60 / 15.3 (mean time for mining a block)\r\n    uint256 public week_in_blocs = 39529;\r\n\r\n    modifier validIndex(uint256 _index){\r\n        require(_index <= index_active);\r\n        _;\r\n    }\r\n\r\n    struct Pool {\r\n        string name;\r\n        //0 means there is no min/max amount\r\n        uint256 min_amount;\r\n        uint256 max_amount;\r\n        //\r\n        address sale;\r\n        ERC20 token;\r\n        // Record ETH value of tokens currently held by contract for the pool.\r\n        uint256 pool_eth_value;\r\n        // Track whether the pool has bought the tokens yet.\r\n        bool bought_tokens;\r\n        uint256 buy_block;\r\n    }\r\n\r\n    //Functions reserved for the owner\r\n    function createPool(string _name, uint256 _min, uint256 _max) onlyOwner {\r\n        require(index_active < 100);\r\n        //Creates a new struct and saves in storage\r\n        pools[index_active] = Pool(_name, _min, _max, 0x0, ERC20(0x0), 0, false, 0);\r\n        //updates the active index\r\n        index_active += 1;\r\n    }\r\n\r\n    function setSale(uint256 _index, address _sale) onlyOwner validIndex(_index) {\r\n        Pool storage pool = pools[_index];\r\n        require(pool.sale == 0x0);\r\n        pool.sale = _sale;\r\n    }\r\n\r\n    function setToken(uint256 _index, address _token) onlyOwner validIndex(_index) {\r\n        Pool storage pool = pools[_index];\r\n        pool.token = ERC20(_token);\r\n    }\r\n\r\n    function buyTokens(uint256 _index) onlyOwner validIndex(_index) {\r\n        Pool storage pool = pools[_index];\r\n        require(pool.pool_eth_value >= pool.min_amount);\r\n        require(pool.pool_eth_value <= pool.max_amount || pool.max_amount == 0);\r\n        require(!pool.bought_tokens);\r\n        //Prevent burning of ETH by mistake\r\n        require(pool.sale != 0x0);\r\n        //Registers the buy block number\r\n        pool.buy_block = block.number;\r\n        // Record that the contract has bought the tokens.\r\n        pool.bought_tokens = true;\r\n        // Transfer all the funds to the crowdsale address.\r\n        pool.sale.transfer(pool.pool_eth_value);\r\n    }\r\n\r\n    function emergency_withdraw(uint256 _index, address _token) onlyOwner validIndex(_index) {\r\n        //Allows to withdraw all the tokens after a certain amount of time, in the case\r\n        //of an unplanned situation\r\n        Pool storage pool = pools[_index];\r\n        require(block.number >= (pool.buy_block + week_in_blocs));\r\n        ERC20 token = ERC20(_token);\r\n        uint256 contract_token_balance = token.balanceOf(address(this));\r\n        require (contract_token_balance != 0);\r\n        // Send the funds.  Throws on failure to prevent loss of funds.\r\n        require(token.transfer(msg.sender, contract_token_balance));\r\n    }\r\n\r\n    function change_delay(uint256 _delay) onlyOwner {\r\n        week_in_blocs = _delay;\r\n    }\r\n\r\n    //Functions accessible to everyone\r\n    function getPoolName(uint256 _index) validIndex(_index) constant returns (string) {\r\n        Pool storage pool = pools[_index];\r\n        return pool.name;\r\n    }\r\n\r\n    function refund(uint256 _index) validIndex(_index) {\r\n        Pool storage pool = pools[_index];\r\n        //Can't refund if tokens were bought\r\n        require(!pool.bought_tokens);\r\n        uint256 eth_to_withdraw = balances[_index][msg.sender];\r\n        //Updates the user's balance prior to sending ETH to prevent recursive call.\r\n        balances[_index][msg.sender] = 0;\r\n        //Updates the pool ETH value\r\n        pool.pool_eth_value -= eth_to_withdraw;\r\n        msg.sender.transfer(eth_to_withdraw);\r\n    }\r\n\r\n    function withdraw(uint256 _index) validIndex(_index) {\r\n        Pool storage pool = pools[_index];\r\n        // Disallow withdraw if tokens haven't been bought yet.\r\n        require(pool.bought_tokens);\r\n        uint256 contract_token_balance = pool.token.balanceOf(address(this));\r\n        // Disallow token withdrawals if there are no tokens to withdraw.\r\n        require(contract_token_balance != 0);\r\n        // Store the user's token balance in a temporary variable.\r\n        uint256 tokens_to_withdraw = (balances[_index][msg.sender] * contract_token_balance) / pool.pool_eth_value;\r\n        // Update the value of tokens currently held by the contract.\r\n        pool.pool_eth_value -= balances[_index][msg.sender];\r\n        // Update the user's balance prior to sending to prevent recursive call.\r\n        balances[_index][msg.sender] = 0;\r\n        //The 1% fee\r\n        uint256 fee = tokens_to_withdraw / 100;\r\n        // Send the funds.  Throws on failure to prevent loss of funds.\r\n        require(pool.token.transfer(msg.sender, tokens_to_withdraw - fee));\r\n        // Send the fee to the developer.\r\n        require(pool.token.transfer(developer, fee));\r\n    }\r\n\r\n    function contribute(uint256 _index) validIndex(_index) payable {\r\n        Pool storage pool = pools[_index];\r\n        require(!pool.bought_tokens);\r\n        //Check if the contribution is within the limits or if there is no max amount\r\n        require(pool.pool_eth_value+msg.value <= pool.max_amount || pool.max_amount == 0);\r\n        //Update the eth held by the pool\r\n        pool.pool_eth_value += msg.value;\r\n        //Updates the user's balance\r\n        balances[_index][msg.sender] += msg.value;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPoolName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"change_delay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_min\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"emergency_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"week_in_blocs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_sale\",\"type\":\"address\"}],\"name\":\"setSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SanityPools","CompilerVersion":"v0.4.19-nightly.2017.11.11+commit.284c3839","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5e9e092434dd28a1097c11a844c27c7443db1d8966545b6dd439fcaecc42e713"}]}