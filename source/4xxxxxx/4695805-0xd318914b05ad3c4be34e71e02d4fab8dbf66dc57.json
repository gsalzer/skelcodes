{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract CollectibleExposure {\r\n  function getClosingTime(bytes32 id) constant returns (uint64 value);\r\n  function collect(bytes32 id) returns (uint256 value);\r\n  function close(bytes32 id) payable;\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract TokenDestructible is Ownable {\r\n\r\n  function TokenDestructible() payable { }\r\n\r\n  /**\r\n   * @notice Terminate contract and refund to owner\r\n   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to\r\n   refund.\r\n   * @notice The called token contracts could try to re-enter this contract. Only\r\n   supply token contracts you trust.\r\n   */\r\n  function destroy(address[] tokens) onlyOwner public {\r\n\r\n    // Transfer tokens to owner\r\n    for(uint256 i = 0; i < tokens.length; i++) {\r\n      ERC20Basic token = ERC20Basic(tokens[i]);\r\n      uint256 balance = token.balanceOf(this);\r\n      token.transfer(owner, balance);\r\n    }\r\n\r\n    // Transfer Eth to owner and terminate contract\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\ncontract VePortfolio is TokenDestructible {\r\n\r\n    //--- Definitions\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct ExposureInfo {\r\n        bytes32 exposureId;\r\n        uint256 value;\r\n    }\r\n\r\n    struct Bucket {\r\n        uint256 value; // Ether\r\n        mapping(address => uint256) holdings; // Tokens\r\n        ExposureInfo[] exposures;\r\n        bool trading;\r\n        uint64 maxClosingTime;\r\n    }\r\n\r\n    //--- Storage\r\n\r\n    CollectibleExposure collectibleExposure;\r\n    EDExecutor etherDeltaExecutor;\r\n\r\n    address public bucketManager;\r\n    address public portfolioManager;\r\n    address public trader;\r\n\r\n    mapping (bytes32 => Bucket) private buckets;\r\n    mapping (address => uint) public model;\r\n    address[] public assets;\r\n\r\n\r\n\r\n    //--- Constructor\r\n\r\n    function VePortfolio() {\r\n        bucketManager = msg.sender;\r\n        portfolioManager = msg.sender;\r\n        trader = msg.sender;\r\n    }\r\n\r\n    //--- Events\r\n\r\n    event BucketCreated(bytes32 id, uint256 initialValue, uint64 closingTime);\r\n    event BucketBuy(bytes32 id, uint256 etherSpent, address token, uint256 tokensBought);\r\n    event BucketSell(bytes32 id, uint256 etherBought, address token, uint256 tokensSold);\r\n    event BucketDestroyed(bytes32 id, uint256 finalValue);\r\n\r\n    //--- Modifiers\r\n\r\n    modifier onlyBucketManager() {\r\n        require(msg.sender == bucketManager);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPortfolioManager() {\r\n        require(msg.sender == portfolioManager);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTrader() {\r\n        require(msg.sender == trader);\r\n        _;\r\n    }\r\n\r\n    //--- Accessors\r\n\r\n    function setCollectibleExposure(CollectibleExposure _collectibleExposure) onlyOwner {\r\n        require(_collectibleExposure != address(0));\r\n\r\n        collectibleExposure = _collectibleExposure;\r\n    }\r\n\r\n    function setEtherDeltaExecutor(EDExecutor _etherDeltaExecutor) public onlyOwner {\r\n        require(_etherDeltaExecutor != address(0));\r\n\r\n        etherDeltaExecutor = _etherDeltaExecutor;\r\n    }\r\n\r\n    function setBucketManager(address _bucketManager) public onlyOwner {\r\n        require(_bucketManager != address(0));\r\n\r\n        bucketManager = _bucketManager;\r\n    }\r\n\r\n    function setPortfolioManager(address _portfolioManager) public onlyOwner {\r\n        require(_portfolioManager != address(0));\r\n\r\n        portfolioManager = _portfolioManager;\r\n    }\r\n\r\n    function setTrader(address _trader) public onlyOwner {\r\n        require(_trader != address(0));\r\n\r\n        trader = _trader;\r\n    }\r\n\r\n    function getAssets() public constant returns (address[]) {\r\n        return assets;\r\n    }\r\n\r\n    //--- Public functions\r\n\r\n    /**\r\n     * @dev Sets supported assets\r\n     * @param _assets Array of asset addresses\r\n     */\r\n    function setAssets(address[] _assets) public onlyPortfolioManager {\r\n        clearModel();\r\n\r\n        assets.length = _assets.length;\r\n        for(uint i = 0; i < assets.length; i++) {\r\n            assets[i] = _assets[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the model portfolio\r\n     * @param  _assets       Array of asset addresses\r\n     * @param  _alloc        Array of percentage values (wei)\r\n     */\r\n    function setModel(address[] _assets, uint256[] _alloc) public onlyPortfolioManager {\r\n        require(_assets.length == _alloc.length);\r\n\r\n        validateModel(_assets);\r\n        clearModel();\r\n\r\n        uint total = 0;\r\n        for(uint256 i = 0; i < _assets.length; i++) {\r\n            uint256 alloc = _alloc[i];\r\n            address asset = _assets[i];\r\n\r\n            total = total.add(alloc);\r\n            model[asset] = alloc;\r\n        }\r\n\r\n        // allocation should be at least 99%\r\n        uint256 whole = 1 ether;\r\n        require(whole.sub(total) < 10 finney);\r\n    }\r\n\r\n    function createBucket(bytes32[] exposureIds)\r\n        public\r\n        onlyBucketManager\r\n        returns (bytes32)\r\n    {\r\n        require(collectibleExposure != address(0));\r\n        require(exposureIds.length > 0);\r\n\r\n        bytes32 bucketId = calculateBucketId(exposureIds);\r\n        Bucket storage bucket = buckets[bucketId];\r\n        require(bucket.exposures.length == 0); // ensure it is a new bucket\r\n\r\n        for (uint256 i = 0; i < exposureIds.length; i++) {\r\n            bytes32 exposureId = exposureIds[i];\r\n            uint64 closureTime = collectibleExposure.getClosingTime(exposureId);\r\n            if (bucket.maxClosingTime < closureTime) {\r\n                bucket.maxClosingTime = closureTime;\r\n            }\r\n\r\n            // Possible reentry attack. Collectible instance must be trusted.\r\n            uint256 value = collectibleExposure.collect(exposureId);\r\n\r\n            bucket.exposures.push(ExposureInfo({\r\n                exposureId: exposureId,\r\n                value: value\r\n            }));\r\n\r\n            bucket.value += value;\r\n        }\r\n\r\n        BucketCreated(bucketId, bucket.value, bucket.maxClosingTime);\r\n    }\r\n\r\n    function destroyBucket(bytes32 bucketId)\r\n        public\r\n        onlyBucketManager\r\n    {\r\n        require(collectibleExposure != address(0));\r\n        Bucket storage bucket = buckets[bucketId];\r\n        require(bucket.exposures.length > 0); // ensure bucket exists\r\n        require(bucket.trading == false);\r\n        uint256 finalValue;\r\n\r\n        for (uint256 i = 0; i < bucket.exposures.length; i++) {\r\n            ExposureInfo storage exposure = bucket.exposures[i];\r\n            finalValue += exposure.value;\r\n\r\n            // Possible reentry attack. Collectible instance must be trusted.\r\n            collectibleExposure.close.value(exposure.value)(exposure.exposureId);\r\n        }\r\n\r\n        BucketDestroyed(bucketId, finalValue);\r\n\r\n        delete buckets[bucketId];\r\n    }\r\n\r\n    function executeEtherDeltaBuy(\r\n        uint256 orderEthAmount,\r\n        address orderToken,\r\n        uint256 orderTokenAmount,\r\n        uint256 orderExpires,\r\n        uint256 orderNonce,\r\n        address orderUser,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        bytes32 bucketId,\r\n        uint256 amount\r\n    ) onlyTrader {\r\n        //Bucket storage bucket = buckets[bucketId];\r\n        require(buckets[bucketId].value >= amount);\r\n        require(isInPortfolioModel(orderToken));\r\n\r\n        uint256 tradedAmount;\r\n        uint256 leftoverEther;\r\n\r\n        // Trusts that etherDeltaExecutor transfers all leftover ether\r\n        // tokens to the sender\r\n        (tradedAmount, leftoverEther) =\r\n            etherDeltaExecutor.buyTokens.value(amount)(\r\n                orderEthAmount,\r\n                orderToken,\r\n                orderTokenAmount,\r\n                orderExpires,\r\n                orderNonce,\r\n                orderUser,\r\n                v, r, s\r\n            );\r\n\r\n        buckets[bucketId].value -= (amount - leftoverEther);\r\n        buckets[bucketId].holdings[orderToken] += tradedAmount;\r\n\r\n        BucketBuy(bucketId, (amount - leftoverEther), orderToken, tradedAmount);\r\n    }\r\n\r\n    function executeEtherDeltaSell(\r\n        uint256 orderEthAmount,\r\n        address orderToken,\r\n        uint256 orderTokenAmount,\r\n        uint256 orderExpires,\r\n        uint256 orderNonce,\r\n        address orderUser,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        bytes32 bucketId,\r\n        uint256 amount\r\n    ) onlyTrader {\r\n        require(buckets[bucketId].holdings[orderToken] >= amount);\r\n        uint256 tradedValue;\r\n        uint256 leftoverTokens;\r\n\r\n        ERC20(orderToken).transfer(etherDeltaExecutor, amount);\r\n\r\n        // Trusts that etherDeltaExecutor transfers all leftover ether\r\n        // tokens to the sender\r\n        (tradedValue, leftoverTokens) =\r\n            etherDeltaExecutor.sellTokens(\r\n                orderEthAmount,\r\n                orderToken,\r\n                orderTokenAmount,\r\n                orderExpires,\r\n                orderNonce,\r\n                orderUser,\r\n                v, r, s\r\n                );\r\n\r\n        buckets[bucketId].value += tradedValue;\r\n        buckets[bucketId].holdings[orderToken] -= (amount - leftoverTokens);\r\n\r\n        BucketSell(bucketId, tradedValue, orderToken, (amount - leftoverTokens));\r\n    }\r\n\r\n    function() payable {\r\n        // Accept Ether deposits\r\n    }\r\n\r\n    //--- Public constant functions\r\n\r\n    function bucketExists(bytes32 bucketId) public constant returns (bool) {\r\n        return buckets[bucketId].exposures.length > 0;\r\n    }\r\n\r\n    function calculateBucketId(bytes32[] exposures)\r\n        public\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        return sha256(this, exposures);\r\n    }\r\n\r\n    function bucketHolding(bytes32 _bucketId, address _asset) constant returns (uint256) {\r\n        Bucket storage bucket = buckets[_bucketId];\r\n        return bucket.holdings[_asset];\r\n    }\r\n\r\n    function bucketValue(bytes32 _bucketId) constant returns (uint256) {\r\n        Bucket storage bucket = buckets[_bucketId];\r\n        return bucket.value;\r\n    }\r\n\r\n    function numAssets() constant public returns (uint256) {\r\n        return assets.length;\r\n    }\r\n\r\n    //--- Private mutable functions\r\n\r\n    function clearModel() private {\r\n        for(uint256 i = 0; i < assets.length; i++) {\r\n            delete model[assets[i]];\r\n        }\r\n    }\r\n\r\n    //--- Private constant functions\r\n\r\n    function validateModel(address[] _assets) internal {\r\n        require(assets.length == _assets.length);\r\n\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            require(_assets[i] == assets[i]);\r\n        }\r\n    }\r\n\r\n    function bucketClosureTime(bytes32 bucketId) constant public returns (uint64) {\r\n       return buckets[bucketId].maxClosingTime;\r\n    }\r\n\r\n    function isInPortfolioModel(address token) constant private returns (bool) {\r\n        return model[token] != 0;\r\n    }\r\n}\r\n\r\ncontract VeExposure is TokenDestructible {\r\n\r\n    //--- Definitions\r\n\r\n    using SafeMath for uint256;\r\n\r\n    enum State { None, Open, Collected, Closing, Closed }\r\n\r\n    struct Exposure {\r\n        address account;\r\n        uint256 veriAmount;\r\n        uint256 initialValue;\r\n        uint256 finalValue;\r\n        uint64 creationTime;\r\n        uint64 closingTime;\r\n        State state;\r\n    }\r\n\r\n    //--- Storage\r\n\r\n    ERC20 public veToken;\r\n    address public portfolio;\r\n\r\n    uint256 public ratio;\r\n    uint32 public minDuration;\r\n    uint32 public maxDuration;\r\n    uint256 public minVeriAmount;\r\n    uint256 public maxVeriAmount;\r\n\r\n    mapping (bytes32 => Exposure) exposures;\r\n    //--- Constructor\r\n\r\n    function VeExposure(\r\n        ERC20 _veToken,\r\n        uint256 _ratio,\r\n        uint32 _minDuration,\r\n        uint32 _maxDuration,\r\n        uint256 _minVeriAmount,\r\n        uint256 _maxVeriAmount\r\n    ) {\r\n        require(_veToken != address(0));\r\n        require(_minDuration > 0 && _minDuration <= _maxDuration);\r\n        require(_minVeriAmount > 0 && _minVeriAmount <= _maxVeriAmount);\r\n\r\n        veToken = _veToken;\r\n        ratio = _ratio;\r\n        minDuration = _minDuration;\r\n        maxDuration = _maxDuration;\r\n        minVeriAmount = _minVeriAmount;\r\n        maxVeriAmount = _maxVeriAmount;\r\n    }\r\n\r\n    //--- Modifiers\r\n    modifier onlyPortfolio {\r\n        require(msg.sender == portfolio);\r\n        _;\r\n    }\r\n\r\n    //--- Accessors\r\n\r\n    function setPortfolio(address _portfolio) public onlyOwner {\r\n        require(_portfolio != address(0));\r\n\r\n        portfolio = _portfolio;\r\n    }\r\n\r\n    function setMinDuration(uint32 _minDuration) public onlyOwner {\r\n        require(_minDuration > 0 && _minDuration <= maxDuration);\r\n\r\n        minDuration = _minDuration;\r\n    }\r\n\r\n    function setMaxDuration(uint32 _maxDuration) public onlyOwner {\r\n        require(_maxDuration >= minDuration);\r\n\r\n        maxDuration = _maxDuration;\r\n    }\r\n\r\n    function setMinVeriAmount(uint32 _minVeriAmount) public onlyOwner {\r\n        require(_minVeriAmount > 0 && _minVeriAmount <= maxVeriAmount);\r\n\r\n        minVeriAmount = _minVeriAmount;\r\n    }\r\n\r\n    function setMaxVeriAmount(uint32 _maxVeriAmount) public onlyOwner {\r\n        require(_maxVeriAmount >= minVeriAmount);\r\n\r\n        maxVeriAmount = _maxVeriAmount;\r\n    }\r\n\r\n    //--- Events\r\n\r\n    event ExposureOpened(\r\n        bytes32 indexed id,\r\n        address indexed account,\r\n        uint256 veriAmount,\r\n        uint256 value,\r\n        uint64 creationTime,\r\n        uint64 closingTime\r\n    );\r\n\r\n    event ExposureCollected(\r\n        bytes32 indexed id,\r\n        address indexed account,\r\n        uint256 value\r\n    );\r\n\r\n    event ExposureClosed(\r\n        bytes32 indexed id,\r\n        address indexed account,\r\n        uint256 initialValue,\r\n        uint256 finalValue\r\n    );\r\n\r\n    event ExposureSettled(\r\n        bytes32 indexed id,\r\n        address indexed account,\r\n        uint256 value\r\n    );\r\n\r\n    //--- Public functions\r\n\r\n    function open(uint256 veriAmount, uint32 duration, uint256 nonce) public payable {\r\n        require(veriAmount >= minVeriAmount && veriAmount <= maxVeriAmount);\r\n        require(duration >= minDuration && duration <= maxDuration);\r\n        require(checkRatio(veriAmount, msg.value));\r\n\r\n        bytes32 id = calculateId({\r\n            veriAmount: veriAmount,\r\n            value: msg.value,\r\n            duration: duration,\r\n            nonce: nonce\r\n        });\r\n        require(!exists(id));\r\n\r\n        openExposure(id, veriAmount, duration);\r\n        forwardTokens(veriAmount);\r\n    }\r\n\r\n    function getClosingTime(bytes32 id) public onlyPortfolio constant returns (uint64) {\r\n        Exposure storage exposure = exposures[id];\r\n        return exposure.closingTime;\r\n    }\r\n\r\n    function collect(bytes32 id) public onlyPortfolio returns (uint256 value) {\r\n        Exposure storage exposure = exposures[id];\r\n        require(exposure.state == State.Open);\r\n\r\n        value = exposure.initialValue;\r\n\r\n        exposure.state = State.Collected;\r\n        msg.sender.transfer(value);\r\n\r\n        ExposureCollected({\r\n            id: id,\r\n            account: exposure.account,\r\n            value: value\r\n        });\r\n    }\r\n\r\n    function close(bytes32 id) public payable onlyPortfolio {\r\n        Exposure storage exposure = exposures[id];\r\n        require(exposure.state == State.Collected);\r\n        require(hasPassed(exposure.closingTime));\r\n\r\n        exposure.state = State.Closed;\r\n        exposure.finalValue = msg.value;\r\n\r\n        ExposureClosed({\r\n            id: id,\r\n            account: exposure.account,\r\n            initialValue: exposure.initialValue,\r\n            finalValue: exposure.finalValue\r\n        });\r\n    }\r\n\r\n    function settle(bytes32 id) public returns (uint256 finalValue) {\r\n        Exposure storage exposure = exposures[id];\r\n        require(msg.sender == exposure.account);\r\n        require(exposure.state == State.Closed);\r\n\r\n        finalValue = exposure.finalValue;\r\n        delete exposures[id];\r\n\r\n        msg.sender.transfer(finalValue);\r\n\r\n        ExposureSettled({\r\n            id: id,\r\n            account: msg.sender,\r\n            value: finalValue\r\n        });\r\n    }\r\n\r\n    //--- Public constant functions\r\n\r\n    function status(bytes32 id)\r\n        public\r\n        constant\r\n        returns (uint8 state)\r\n    {\r\n        Exposure storage exposure = exposures[id];\r\n        state = uint8(exposure.state);\r\n\r\n        if (exposure.state == State.Collected && hasPassed(exposure.closingTime)) {\r\n            state = uint8(State.Closing);\r\n        }\r\n    }\r\n\r\n    function exists(bytes32 id) public constant returns (bool) {\r\n        return exposures[id].creationTime > 0;\r\n    }\r\n\r\n    function checkRatio(uint256 veriAmount, uint256 value)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint256 expectedValue = ratio.mul(veriAmount).div(1 ether);\r\n        return value == expectedValue;\r\n    }\r\n\r\n    function calculateId(\r\n        uint256 veriAmount,\r\n        uint256 value,\r\n        uint32 duration,\r\n        uint256 nonce\r\n    )\r\n        public\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        return sha256(\r\n            this,\r\n            msg.sender,\r\n            value,\r\n            veriAmount,\r\n            duration,\r\n            nonce\r\n        );\r\n    }\r\n\r\n    //--- Fallback function\r\n\r\n    function() public payable {\r\n        // accept Ether deposits\r\n    }\r\n\r\n    //--- Private functions\r\n\r\n    function forwardTokens(uint256 veriAmount) private {\r\n        require(veToken.transferFrom(msg.sender, this, veriAmount));\r\n        require(veToken.approve(portfolio, veriAmount));\r\n    }\r\n\r\n    function openExposure(bytes32 id, uint256 veriAmount, uint32 duration) private constant {\r\n        uint64 creationTime = uint64(block.timestamp);\r\n        uint64 closingTime = uint64(block.timestamp.add(duration));\r\n\r\n        exposures[id] = Exposure({\r\n            account: msg.sender,\r\n            veriAmount: veriAmount,\r\n            initialValue: msg.value,\r\n            finalValue: 0,\r\n            creationTime: creationTime,\r\n            closingTime: closingTime,\r\n            state: State.Open\r\n        });\r\n\r\n        ExposureOpened({\r\n            id: id,\r\n            account: msg.sender,\r\n            creationTime: creationTime,\r\n            closingTime: closingTime,\r\n            veriAmount: veriAmount,\r\n            value: msg.value\r\n        });\r\n    }\r\n\r\n    //--- Private constant functions\r\n\r\n    function hasPassed(uint64 time)\r\n        private\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return block.timestamp >= time;\r\n    }\r\n}\r\n\r\ncontract EDExecutor {\r\n    function buyTokens(\r\n        uint256 orderEthAmount,\r\n        address orderToken,\r\n        uint256 orderTokenAmount,\r\n        uint256 orderExpires,\r\n        uint256 orderNonce,\r\n        address orderUser,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) payable returns (uint256 tradedAmount, uint256 leftoverEther);\r\n\r\n    function sellTokens(\r\n        // ED Order identification\r\n        uint256 orderEthAmount,\r\n        address orderToken,\r\n        uint256 orderTokenAmount,\r\n        uint256 orderExpires,\r\n        uint256 orderNonce,\r\n        address orderUser,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) returns (uint256 tradedValue, uint256 leftoverTokens);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"trader\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bucketId\",\"type\":\"bytes32\"},{\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"bucketHolding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderEthAmount\",\"type\":\"uint256\"},{\"name\":\"orderToken\",\"type\":\"address\"},{\"name\":\"orderTokenAmount\",\"type\":\"uint256\"},{\"name\":\"orderExpires\",\"type\":\"uint256\"},{\"name\":\"orderNonce\",\"type\":\"uint256\"},{\"name\":\"orderUser\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"bucketId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeEtherDeltaSell\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exposureIds\",\"type\":\"bytes32[]\"}],\"name\":\"createBucket\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherDeltaExecutor\",\"type\":\"address\"}],\"name\":\"setEtherDeltaExecutor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"model\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"portfolioManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAssets\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_collectibleExposure\",\"type\":\"address\"}],\"name\":\"setCollectibleExposure\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bucketManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bucketManager\",\"type\":\"address\"}],\"name\":\"setBucketManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bucketId\",\"type\":\"bytes32\"}],\"name\":\"bucketValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_portfolioManager\",\"type\":\"address\"}],\"name\":\"setPortfolioManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAssets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bucketId\",\"type\":\"bytes32\"}],\"name\":\"bucketClosureTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trader\",\"type\":\"address\"}],\"name\":\"setTrader\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assets\",\"type\":\"address[]\"},{\"name\":\"_alloc\",\"type\":\"uint256[]\"}],\"name\":\"setModel\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderEthAmount\",\"type\":\"uint256\"},{\"name\":\"orderToken\",\"type\":\"address\"},{\"name\":\"orderTokenAmount\",\"type\":\"uint256\"},{\"name\":\"orderExpires\",\"type\":\"uint256\"},{\"name\":\"orderNonce\",\"type\":\"uint256\"},{\"name\":\"orderUser\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"bucketId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeEtherDeltaBuy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assets\",\"type\":\"address[]\"}],\"name\":\"setAssets\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exposures\",\"type\":\"bytes32[]\"}],\"name\":\"calculateBucketId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bucketId\",\"type\":\"bytes32\"}],\"name\":\"bucketExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bucketId\",\"type\":\"bytes32\"}],\"name\":\"destroyBucket\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"initialValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closingTime\",\"type\":\"uint64\"}],\"name\":\"BucketCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"etherSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBought\",\"type\":\"uint256\"}],\"name\":\"BucketBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"etherBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensSold\",\"type\":\"uint256\"}],\"name\":\"BucketSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"finalValue\",\"type\":\"uint256\"}],\"name\":\"BucketDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"VePortfolio","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a6020081472ae07644c599e51fc72d88eca4b9634cccf9c0ed017caab24c771a"}]}