{"status":"1","message":"OK","result":[{"SourceCode":"/*************************************************************************\r\n * This contract has been merged with solidify\r\n * https://github.com/tiesnetwork/solidify\r\n *************************************************************************/\r\n \r\n pragma solidity ^0.4.10;\r\n\r\n/*************************************************************************\r\n * import \"./FloorInvestRestrictions.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"./IInvestRestrictions.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../common/Manageable.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../common/Owned.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\ncontract Owned {\r\n    address public owner;        \r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**@dev allows transferring the contract ownership. */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n/*************************************************************************\r\n * import \"../common/Owned.sol\" : end\r\n *************************************************************************/\r\n\r\n///A token that have an owner and a list of managers that can perform some operations\r\n///Owner is always a manager too\r\ncontract Manageable is Owned {\r\n\r\n    event ManagerSet(address manager, bool state);\r\n\r\n    mapping (address => bool) public managers;\r\n\r\n    function Manageable() Owned() {\r\n        managers[owner] = true;\r\n    }\r\n\r\n    /**@dev Allows execution by managers only */\r\n    modifier managerOnly {\r\n        assert(managers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        super.transferOwnership(_newOwner);\r\n\r\n        managers[_newOwner] = true;\r\n        managers[msg.sender] = false;\r\n    }\r\n\r\n    function setManager(address manager, bool state) ownerOnly {\r\n        managers[manager] = state;\r\n        ManagerSet(manager, state);\r\n    }\r\n}/*************************************************************************\r\n * import \"../common/Manageable.sol\" : end\r\n *************************************************************************/\r\n\r\n/** @dev Restrictions on investment */\r\ncontract IInvestRestrictions is Manageable {\r\n    /**@dev Returns true if investmet is allowed */\r\n    function canInvest(address investor, uint amount, uint tokensLeft) constant returns (bool result) {\r\n        investor; amount; result; tokensLeft;\r\n    }\r\n\r\n    /**@dev Called when investment was made */\r\n    function investHappened(address investor, uint amount) managerOnly {}    \r\n}/*************************************************************************\r\n * import \"./IInvestRestrictions.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Allows only investments with large enough amount only  */\r\ncontract FloorInvestRestrictions is IInvestRestrictions {\r\n\r\n    /**@dev The smallest acceptible ether amount */\r\n    uint256 public floor;\r\n\r\n    /**@dev True if address already invested */\r\n    mapping (address => bool) public investors;\r\n\r\n\r\n    function FloorInvestRestrictions(uint256 _floor) {\r\n        floor = _floor;\r\n    }\r\n\r\n    /**@dev IInvestRestrictions implementation */\r\n    function canInvest(address investor, uint amount, uint tokensLeft) constant returns (bool result) {\r\n        \r\n        //allow investment if it isn't the first one \r\n        if (investors[investor]) {\r\n            result = true;\r\n        } else {\r\n            //otherwise check the floor\r\n            result = (amount >= floor);\r\n        }\r\n    }\r\n\r\n    /**@dev IInvestRestrictions implementation */\r\n    function investHappened(address investor, uint amount) managerOnly {\r\n        investors[investor] = true;\r\n    }\r\n\r\n    /**@dev Changes investment low cap */\r\n    function changeFloor(uint256 newFloor) managerOnly {\r\n        floor = newFloor;\r\n    }\r\n}/*************************************************************************\r\n * import \"./FloorInvestRestrictions.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"./ICrowdsaleFormula.sol\" : start\r\n *************************************************************************/\r\n\r\n/**@dev Abstraction of crowdsale token calculation function */\r\ncontract ICrowdsaleFormula {\r\n\r\n    /**@dev Returns amount of tokens that can be bought with given weiAmount */\r\n    function howManyTokensForEther(uint256 weiAmount) constant returns(uint256 tokens, uint256 excess) {\r\n        weiAmount; tokens; excess;\r\n    }\r\n\r\n    /**@dev Returns how many tokens left for sale */\r\n    function tokensLeft() constant returns(uint256 _left) { _left;}    \r\n}/*************************************************************************\r\n * import \"./ICrowdsaleFormula.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev In addition to 'floor' behavior restricts investments if there are already too many investors. \r\nContract owner can reserve some places for future investments:\r\n1. It is possible to reserve a place for unknown address using 'reserve' function. \r\n    When invest happens you should 'unreserve' that place manually\r\n2. It is also possible to reserve a certain address using 'reserveFor'. \r\n    When such investor invests, the place becomes unreserved  */\r\ncontract ParticipantInvestRestrictions is FloorInvestRestrictions {\r\n\r\n    struct ReservedInvestor {\r\n        bool reserved;        \r\n        uint256 tokens;\r\n    }\r\n\r\n    event ReserveKnown(bool state, address investor, uint256 weiAmount, uint256 tokens);\r\n    event ReserveUnknown(bool state, uint32 index, uint256 weiAmount, uint256 tokens);\r\n\r\n    /**@dev Array of unknown investors */\r\n    ReservedInvestor[] public unknownInvestors;\r\n\r\n    /**@dev Formula to calculate amount of tokens to buy*/\r\n    ICrowdsaleFormula public formula;\r\n\r\n    /**@dev Maximum number of allowed investors */\r\n    uint32 public maxInvestors;    \r\n\r\n    /**@dev Current number of investors */\r\n    uint32 public investorsCount;\r\n\r\n    /**@dev Current number of known reserved investors */\r\n    uint32 public knownReserved;\r\n\r\n    /**@dev Current number of unknown reserved investors */\r\n    uint32 public unknownReserved;\r\n\r\n    /**@dev If address is reserved, shows how much tokens reserved for him */\r\n    mapping (address => uint256) public reservedInvestors;\r\n\r\n    /**@dev How much tokens reserved */\r\n    uint256 public tokensReserved;\r\n\r\n    function ParticipantInvestRestrictions(uint256 _floor, uint32 _maxTotalInvestors)\r\n        FloorInvestRestrictions(_floor)\r\n    {\r\n        maxInvestors = _maxTotalInvestors;\r\n    }\r\n\r\n    /**@dev Sets formula */\r\n    function setFormula(ICrowdsaleFormula _formula) managerOnly {\r\n        formula = _formula;        \r\n    }\r\n\r\n    /**@dev Returns true if there are still free places for investors */\r\n    function hasFreePlaces() constant returns (bool) {\r\n        return getInvestorCount() < maxInvestors;\r\n    }\r\n\r\n    /**@dev Returns number of investors, including reserved */\r\n    function getInvestorCount() constant returns(uint32) {\r\n        return investorsCount + knownReserved + unknownReserved;\r\n    }\r\n\r\n    /**@dev IInvestRestrictions override */\r\n    function canInvest(address investor, uint amount, uint tokensLeft) constant returns (bool result) {\r\n        //First check ancestor's restriction. \r\n        //Allow only if it is reserved investor or it invested earlier or there is still room for new investors\r\n        if (super.canInvest(investor, amount, tokensLeft)) {\r\n            if (reservedInvestors[investor] > 0) {\r\n                return true;\r\n            } else {\r\n                var (tokens, excess) = formula.howManyTokensForEther(amount);\r\n                if (tokensLeft >= tokensReserved + tokens) {\r\n                    return investors[investor] || hasFreePlaces();\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n \r\n    /**@dev IInvestRestrictions override */\r\n    function investHappened(address investor, uint amount) managerOnly {\r\n        if (!investors[investor]) {\r\n            investors[investor] = true;\r\n            investorsCount++;\r\n            \r\n            //if that investor was already reserved, unreserve the place\r\n            if (reservedInvestors[investor] > 0) {\r\n                unreserveFor(investor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**@dev Reserves a place for investor */\r\n    function reserveFor(address investor, uint256 weiAmount) managerOnly {\r\n        require(!investors[investor] && hasFreePlaces());\r\n\r\n        if(reservedInvestors[investor] == 0) {\r\n            knownReserved++;\r\n        }\r\n\r\n        reservedInvestors[investor] += reserveTokens(weiAmount);\r\n        ReserveKnown(true, investor, weiAmount, reservedInvestors[investor]);\r\n    }\r\n\r\n    /**@dev Unreserves special address. For example if investor haven't sent ether */\r\n    function unreserveFor(address investor) managerOnly {\r\n        require(reservedInvestors[investor] != 0);\r\n\r\n        knownReserved--;\r\n        unreserveTokens(reservedInvestors[investor]);\r\n        reservedInvestors[investor] = 0;\r\n\r\n        ReserveKnown(false, investor, 0, 0);\r\n    }\r\n\r\n    /**@dev Reserves place for unknown address */\r\n    function reserve(uint256 weiAmount) managerOnly {\r\n        require(hasFreePlaces());\r\n        unknownReserved++;\r\n        uint32 id = uint32(unknownInvestors.length++);\r\n        unknownInvestors[id].reserved = true;        \r\n        unknownInvestors[id].tokens = reserveTokens(weiAmount);\r\n\r\n        ReserveUnknown(true, id, weiAmount, unknownInvestors[id].tokens);\r\n    }\r\n\r\n    /**@dev Unreserves place for unknown address specified by an index in array */\r\n    function unreserve(uint32 index) managerOnly {\r\n        require(index < unknownInvestors.length && unknownInvestors[index].reserved);\r\n        \r\n        assert(unknownReserved > 0);\r\n        unknownReserved--;\r\n        unreserveTokens(unknownInvestors[index].tokens);        \r\n        unknownInvestors[index].reserved = false;\r\n\r\n        ReserveUnknown(false, index, 0, 0);\r\n    }\r\n\r\n    /**@dev Reserved tokens for given amount of ether, returns reserved amount */\r\n    function reserveTokens(uint256 weiAmount) \r\n        internal \r\n        managerOnly \r\n        returns(uint256) \r\n    {\r\n        uint256 tokens;\r\n        uint256 excess;\r\n        (tokens, excess) = formula.howManyTokensForEther(weiAmount);\r\n        \r\n        if (tokensReserved + tokens > formula.tokensLeft()) {\r\n            tokens = formula.tokensLeft() - tokensReserved;\r\n        }\r\n        tokensReserved += tokens;\r\n\r\n        return tokens;\r\n    }\r\n\r\n    /**@dev Unreserves specified amount of tokens */\r\n    function unreserveTokens(uint256 tokenAmount) \r\n        internal \r\n        managerOnly \r\n    {\r\n        if (tokenAmount > tokensReserved) {\r\n            tokensReserved = 0;\r\n        } else {\r\n            tokensReserved = tokensReserved - tokenAmount;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"investorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unknownReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"floor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"formula\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"knownReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"unreserveFor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"investHappened\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"tokensLeft\",\"type\":\"uint256\"}],\"name\":\"canInvest\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"reserve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"unreserve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"reservedInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFloor\",\"type\":\"uint256\"}],\"name\":\"changeFloor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_formula\",\"type\":\"address\"}],\"name\":\"setFormula\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"reserveFor\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unknownInvestors\",\"outputs\":[{\"name\":\"reserved\",\"type\":\"bool\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasFreePlaces\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_floor\",\"type\":\"uint256\"},{\"name\":\"_maxTotalInvestors\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ReserveKnown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ReserveUnknown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"ManagerSet\",\"type\":\"event\"}]","ContractName":"ParticipantInvestRestrictions","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000001158e460913d000000000000000000000000000000000000000000000000000000000000000000064","Library":"","SwarmSource":"bzzr://a734be867f03428bf397571cde68e181f2a666f9fdd837b53a5f62dd8a66d376"}]}