{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\ncontract AccountRegistry is Ownable {\r\n  mapping(address => bool) public accounts;\r\n\r\n  // Inviter + recipient pair\r\n  struct Invite {\r\n    address creator;\r\n    address recipient;\r\n  }\r\n\r\n  // Mapping of public keys as Ethereum addresses to invite information\r\n  // NOTE: the address keys here are NOT Ethereum addresses, we just happen\r\n  // to work with the public keys in terms of Ethereum address strings because\r\n  // this is what `ecrecover` produces when working with signed text.\r\n  mapping(address => Invite) public invites;\r\n\r\n  InviteCollateralizer public inviteCollateralizer;\r\n  ERC20 public blt;\r\n  address private inviteAdmin;\r\n\r\n  event InviteCreated(address indexed inviter);\r\n  event InviteAccepted(address indexed inviter, address indexed recipient);\r\n  event AccountCreated(address indexed newUser);\r\n\r\n  function AccountRegistry(ERC20 _blt, InviteCollateralizer _inviteCollateralizer) public {\r\n    blt = _blt;\r\n    accounts[owner] = true;\r\n    inviteAdmin = owner;\r\n    inviteCollateralizer = _inviteCollateralizer;\r\n  }\r\n\r\n  function setInviteCollateralizer(InviteCollateralizer _newInviteCollateralizer) public nonZero(_newInviteCollateralizer) onlyOwner {\r\n    inviteCollateralizer = _newInviteCollateralizer;\r\n  }\r\n\r\n  function setInviteAdmin(address _newInviteAdmin) public onlyOwner nonZero(_newInviteAdmin) {\r\n    inviteAdmin = _newInviteAdmin;\r\n  }\r\n\r\n  /**\r\n   * @dev Create an account instantly. Reserved for the \"invite admin\" which is managed by the Bloom team\r\n   * @param _newUser Address of the user receiving an account\r\n   */\r\n  function createAccount(address _newUser) public onlyInviteAdmin {\r\n    require(!accounts[_newUser]);\r\n    createAccountFor(_newUser);\r\n  }\r\n\r\n  /**\r\n   * @dev Create an invite using the signing model described in the contract description\r\n   * @param _sig Signature for `msg.sender`\r\n   */\r\n  function createInvite(bytes _sig) public onlyUser {\r\n    require(inviteCollateralizer.takeCollateral(msg.sender));\r\n\r\n    address signer = recoverSigner(_sig);\r\n    require(inviteDoesNotExist(signer));\r\n\r\n    invites[signer] = Invite(msg.sender, address(0));\r\n    InviteCreated(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Accept an invite using the signing model described in the contract description\r\n   * @param _sig Signature for `msg.sender` via the same key that issued the initial invite\r\n   */\r\n  function acceptInvite(bytes _sig) public onlyNonUser {\r\n    address signer = recoverSigner(_sig);\r\n    require(inviteExists(signer) && inviteHasNotBeenAccepted(signer));\r\n\r\n    invites[signer].recipient = msg.sender;\r\n    createAccountFor(msg.sender);\r\n    InviteAccepted(invites[signer].creator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Check if an invite has not been set on the struct meaning it hasn't been accepted\r\n   */\r\n  function inviteHasNotBeenAccepted(address _signer) internal view returns (bool) {\r\n    return invites[_signer].recipient == address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Check that an invite hasn't already been created with this signer\r\n   */\r\n  function inviteDoesNotExist(address _signer) internal view returns (bool) {\r\n    return !inviteExists(_signer);\r\n  }\r\n\r\n  /**\r\n   * @dev Check that an invite has already been created with this signer\r\n   */\r\n  function inviteExists(address _signer) internal view returns (bool) {\r\n    return invites[_signer].creator != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Recover the address associated with the public key that signed the provided signature\r\n   * @param _sig Signature of `msg.sender`\r\n   */\r\n  function recoverSigner(bytes _sig) private view returns (address) {\r\n    address signer = ECRecovery.recover(keccak256(msg.sender), _sig);\r\n    require(signer != address(0));\r\n\r\n    return signer;\r\n  }\r\n\r\n  /**\r\n   * @dev Create an account and emit an event\r\n   * @param _newUser Address of the new user\r\n   */\r\n  function createAccountFor(address _newUser) private {\r\n    accounts[_newUser] = true;\r\n    AccountCreated(_newUser);\r\n  }\r\n\r\n  /**\r\n   * @dev Addresses with Bloom accounts already are not allowed\r\n   */\r\n  modifier onlyNonUser {\r\n    require(!accounts[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Addresses without Bloom accounts already are not allowed\r\n   */\r\n  modifier onlyUser {\r\n    require(accounts[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  modifier nonZero(address _address) {\r\n    require(_address != 0);\r\n    _;\r\n  }\r\n\r\n  modifier onlyInviteAdmin {\r\n    require(msg.sender == inviteAdmin);\r\n    _;\r\n  }\r\n}\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Extracting these values isn't possible without assembly\r\n    // solhint-disable no-inline-assembly\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract InviteCollateralizer is Ownable {\r\n  // We need to rely on time for lockup periods. The amount that miners can manipulate\r\n  // a timestamp is not a concern for this behavior since token lockups are for several months\r\n  // solhint-disable not-rely-on-time\r\n\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  ERC20 public blt;\r\n  address public seizedTokensWallet;\r\n  mapping (address => Collateralization[]) public collateralizations;\r\n  uint256 public collateralAmount = 1e17;\r\n  uint64 public lockupDuration = 1 years;\r\n\r\n  address private collateralTaker;\r\n  address private collateralSeizer;\r\n\r\n  struct Collateralization {\r\n    uint256 value; // Amount of BLT\r\n    uint64 releaseDate; // Date BLT can be withdrawn\r\n    bool claimed; // Has the original owner or the network claimed the collateral\r\n  }\r\n\r\n  event CollateralPosted(address indexed owner, uint64 releaseDate, uint256 amount);\r\n  event CollateralSeized(address indexed owner, uint256 collateralId);\r\n\r\n  function InviteCollateralizer(ERC20 _blt, address _seizedTokensWallet) public {\r\n    blt = _blt;\r\n    seizedTokensWallet = _seizedTokensWallet;\r\n    collateralTaker = owner;\r\n    collateralSeizer = owner;\r\n  }\r\n\r\n  function takeCollateral(address _owner) public onlyCollateralTaker returns (bool) {\r\n    require(blt.transferFrom(_owner, address(this), collateralAmount));\r\n\r\n    uint64 releaseDate = uint64(now) + lockupDuration;\r\n    CollateralPosted(_owner, releaseDate, collateralAmount);\r\n    collateralizations[_owner].push(Collateralization(collateralAmount, releaseDate, false));\r\n\r\n    return true;\r\n  }\r\n\r\n  function reclaim() public returns (bool) {\r\n    require(collateralizations[msg.sender].length > 0);\r\n\r\n    uint256 reclaimableAmount = 0;\r\n\r\n    for (uint256 i = 0; i < collateralizations[msg.sender].length; i++) {\r\n      if (collateralizations[msg.sender][i].claimed) {\r\n        continue;\r\n      } else if (collateralizations[msg.sender][i].releaseDate > now) {\r\n        break;\r\n      }\r\n\r\n      reclaimableAmount = reclaimableAmount.add(collateralizations[msg.sender][i].value);\r\n      collateralizations[msg.sender][i].claimed = true;\r\n    }\r\n\r\n    require(reclaimableAmount > 0);\r\n\r\n    return blt.transfer(msg.sender, reclaimableAmount);\r\n  }\r\n\r\n  function seize(address _subject, uint256 _collateralId) public onlyCollateralSeizer {\r\n    require(collateralizations[_subject].length >= _collateralId + 1);\r\n    require(!collateralizations[_subject][_collateralId].claimed);\r\n\r\n    collateralizations[_subject][_collateralId].claimed = true;\r\n    blt.transfer(seizedTokensWallet, collateralizations[_subject][_collateralId].value);\r\n    CollateralSeized(_subject, _collateralId);\r\n  }\r\n\r\n  function changeCollateralTaker(address _newCollateralTaker) public nonZero(_newCollateralTaker) onlyOwner {\r\n    collateralTaker = _newCollateralTaker;\r\n  }\r\n\r\n  function changeCollateralSeizer(address _newCollateralSeizer) public nonZero(_newCollateralSeizer) onlyOwner {\r\n    collateralSeizer = _newCollateralSeizer;\r\n  }\r\n\r\n  function changeCollateralAmount(uint256 _newAmount) public onlyOwner {\r\n    require(_newAmount > 0);\r\n    collateralAmount = _newAmount;\r\n  }\r\n\r\n  function changeSeizedTokensWallet(address _newSeizedTokensWallet) public nonZero(_newSeizedTokensWallet) onlyOwner {\r\n    seizedTokensWallet = _newSeizedTokensWallet; \r\n  }\r\n\r\n  function changeLockupDuration(uint64 _newLockupDuration) public onlyOwner {\r\n    lockupDuration = _newLockupDuration;\r\n  }\r\n\r\n  modifier nonZero(address _address) {\r\n    require(_address != 0);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCollateralTaker {\r\n    require(msg.sender == collateralTaker);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCollateralSeizer {\r\n    require(msg.sender == collateralSeizer);\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newInviteCollateralizer\",\"type\":\"address\"}],\"name\":\"setInviteCollateralizer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inviteCollateralizer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newInviteAdmin\",\"type\":\"address\"}],\"name\":\"setInviteAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"createInvite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invites\",\"outputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newUser\",\"type\":\"address\"}],\"name\":\"createAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"acceptInvite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_blt\",\"type\":\"address\"},{\"name\":\"_inviteCollateralizer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"inviter\",\"type\":\"address\"}],\"name\":\"InviteCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"InviteAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newUser\",\"type\":\"address\"}],\"name\":\"AccountCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AccountRegistry","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000107c4504cd79c5d2696ea0030a8dd4e92601b82e0000000000000000000000003400696045f706f3309927cb8fdf63f07b616c6f","Library":"ECRecovery:46d9ca26d2c904000b3072c594cf701858d04844","SwarmSource":"bzzr://3acbb6d49ff973d641d433ca900893e90cb5503d6415c9d36473fe83907d83a8"}]}