{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    string public constant name = \"Token Name\";\r\n    string public constant symbol = \"SYM\";\r\n    uint8 public constant decimals = 18;  // 18 is the most common number of decimal places\r\n\r\n}\r\n\r\n/**\r\n *\r\n *\t# Marketboard Listing\r\n *\r\n *\tThis contract represents an item listed on the marketboard at marketboard.io\r\n *\r\n *  Steps for listing:\r\n *  - Server creates a bunch of these contracts in 'idle' state (async, in cron job, 'creating' state until mined)\r\n *  - When a user starts a transaction, server returns an 'idle' state one and marks it as 'pending:tokens' state\r\n *  - User sets their price per token, this is saved on the servers.\r\n *  - User gets the contract address, and sends some tokens to the contract.\r\n *  - While webapp is open, constantly query for incoming tokens to this contract\r\n *  - If no query for 24 hours, put contract back to 'idle' state. Do a token query just in case maybe?\r\n *  - Once tokens received, send a `finalize(tokenContractAddr, senderAddr, tokenPrice)` transaction to the contract from the server, mark as 'pending:finalize'\r\n *  - Show success to user, item is now listed but with finalizing logo\r\n *  - Server contantly queries all 'pending:finalize' contracts until they've been mined\r\n *  - Once mined (ie calling `isReady()` returns true) state change to 'ready'\r\n *\r\n *  Steps for buyback:\r\n *  - REQUIRES 'ready' state\r\n *  - User sends a call to the contract's `buyback()` function\r\n *\r\n *  Steps for purchase:\r\n *  - REQUIRES 'ready' state\r\n *  - User calls `purchase(recipientAddr)` and sends required money to the contract\r\n *  - Server constantly monitors 'ready' contracts (maybe only when a user views it?)\r\n *  - Once contract has been reset, mark contract as 'idle' state\r\n *\r\n *  Type IDs:\r\n *  - 0x01  :   ERC20 listing\r\n */\r\n\r\n/// Represents a listing on the ProWallet Marketboard\r\ncontract MarketboardERC20Listing {\r\n\r\n    /// Contract version\r\n    function _version() pure public returns(uint32) {\r\n        return 1;\r\n    }\r\n\r\n    /// Notifies when the listing has been completed\r\n    event MarketboardListingComplete(address indexed tokenContract, uint256 numTokensSold, uint256 totalEtherPrice, uint256 fee);\r\n\r\n    /// Notifies when the listing was cancelled by the seller\r\n    event MarketboardListingBuyback(address indexed tokenContract, uint256 numTokens);\r\n\r\n\t/// Notifies when the listing has been destroyed\r\n\tevent MarketboardListingDestroyed();\r\n\r\n    /// Notifies that the seller has changed the price on this listing\r\n    event MarketboardListingPriceChanged(uint256 oldPricePerToken, uint256 newPricePerToken);\r\n\r\n\r\n    /// This function modifier fails if the caller is not the contract creator.\r\n    modifier moderatorOnly {\r\n        require(msg.sender == moderator);\r\n        _;\r\n    }\r\n\r\n    /// This function modifier fails if the caller is not the contract creator or token seller.\r\n    modifier moderatorOrSellerOnly {\r\n        require(moderator == msg.sender || seller == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /// The Ethereum price per token\r\n\tuint256 public tokenPrice = 0;\r\n\r\n    /// The ERC20 token contract address that we are selling\r\n    address public tokenContract;\r\n\r\n    /// The account which is moderating this transaction. This is also the account which receives the fee profits.\r\n    address moderator;\r\n\r\n    /// The account which will receive the money if someone buys this listing. This is the account which created the listing.\r\n    address seller;\r\n\r\n    /// This is a fixed Ethereum fee added to the transaction. The fee is\r\n    /// sent back to the contract creator after successful purchase.\r\n    uint256 public feeFixed;\r\n\r\n    /// This fee is a percentage of the total price with a base of 100,000, ie. 1,000 is 1%. The fee is\r\n    /// sent back to the contract creator after successful purchase.\r\n    uint32 public feePercentage;\r\n\tuint32 constant public feePercentageMax = 100000;\r\n\r\n    /// Constructor\r\n    function MarketboardERC20Listing(address _moderator, uint256 _feeFixed, uint32 _feePercentage, address _erc20Token, uint256 _tokenPrice) public {\r\n\r\n        // Store the contract creator (the automated server account)\r\n        seller = msg.sender;\r\n        moderator = _moderator;\r\n        feeFixed = _feeFixed;\r\n        feePercentage = _feePercentage;\r\n        tokenContract = _erc20Token;\r\n        tokenPrice = _tokenPrice;\r\n\r\n    }\r\n\r\n    /// Get the total amount of ERC20 tokens we are sending\r\n    function tokenCount() public view returns(uint256) {\r\n\r\n        // Fetch token balance\r\n        ERC20 erc = ERC20(tokenContract);\r\n        return erc.balanceOf(this);\r\n\r\n    }\r\n\r\n    /// Get the total amount of Ether needed to successfully purchase this item.\r\n    function totalPrice() public view returns(uint256) {\r\n\r\n        // Return price required\r\n        return tokenPrice * tokenCount() + fee();\r\n\r\n    }\r\n\r\n    /// Get the fee this transaction will cost.\r\n    function fee() public view returns(uint256) {\r\n\r\n        // Get total raw price, item cost * item count\r\n        uint256 price = tokenPrice * tokenCount();\r\n\r\n        // Calculate fee\r\n        return price * feePercentage / feePercentageMax + feeFixed;\r\n\r\n    }\r\n\r\n    /// Allows the seller to change the price of this listing\r\n    function setPrice(uint256 newTokenPrice) moderatorOrSellerOnly public {\r\n\r\n        // Store old price\r\n        uint256 oldPrice = tokenPrice;\r\n\r\n        // Set new price\r\n        tokenPrice = newTokenPrice;\r\n\r\n        // Notify\r\n        MarketboardListingPriceChanged(oldPrice, newTokenPrice);\r\n\r\n    }\r\n\r\n    /// Perform a buyback, ie. retrieve the item for free. Only the creator or the seller can do this.\r\n    function buyback(address recipient) moderatorOrSellerOnly public {\r\n\r\n        // Send tokens to the recipient\r\n        ERC20 erc = ERC20(tokenContract);\r\n\t\tuint256 balance = erc.balanceOf(this);\r\n        erc.transfer(recipient, balance);\r\n\r\n        // Send event\r\n        MarketboardListingBuyback(tokenContract, balance);\r\n\r\n        // We are done, reset and send remaining Ether (if any) back to the moderator\r\n        reset();\r\n\r\n    }\r\n\r\n\t/// Purchase the item(s) represented by this listing, and send the tokens to\r\n    /// another address instead of the sender.\r\n    function purchase(address recipient) public payable {\r\n\r\n        // Check if the right amount of Ether was sent\r\n        require(msg.value >= totalPrice());\r\n\r\n        // Send tokens to the recipient\r\n        ERC20 erc = ERC20(tokenContract);\r\n\t\tuint256 balance = erc.balanceOf(this);\r\n        erc.transfer(recipient, balance);\r\n\r\n\t\t// Get the amount of Ether to send to the seller\r\n\t\tuint256 basePrice = tokenPrice * balance;\r\n\t\trequire(basePrice > 0);\r\n\t\trequire(basePrice < this.balance);\r\n\r\n\t\t// Send Ether to the seller\r\n\t\tseller.transfer(basePrice);\r\n\r\n        // Send event\r\n        MarketboardListingComplete(tokenContract, balance, 0, 0);\r\n\r\n        // We are done, reset and send remaining Ether back to the moderator as fee\r\n        reset();\r\n\r\n    }\r\n\r\n    /// If somehow another unrelated type of token was sent to this contract, this can be used to claim those tokens back.\r\n    function claimUnrelatedTokens(address unrelatedTokenContract, address recipient) moderatorOrSellerOnly public {\r\n\r\n        // Make sure we're not dealing with the known token\r\n        require(tokenContract != unrelatedTokenContract);\r\n\r\n        // Send tokens to the recipient\r\n        ERC20 erc = ERC20(unrelatedTokenContract);\r\n        uint256 balance = erc.balanceOf(this);\r\n        erc.transfer(recipient, balance);\r\n\r\n    }\r\n\r\n\t/// Destroys the listing. Also transfers profits to the moderator.\r\n\tfunction reset() internal {\r\n\r\n        // Notify\r\n        MarketboardListingDestroyed();\r\n\r\n\t\t// Send remaining Ether (the fee from the last transaction) to the creator as profits\r\n\t\tselfdestruct(moderator);\r\n\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"feeFixed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokenPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unrelatedTokenContract\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimUnrelatedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercentageMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"buyback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_moderator\",\"type\":\"address\"},{\"name\":\"_feeFixed\",\"type\":\"uint256\"},{\"name\":\"_feePercentage\",\"type\":\"uint32\"},{\"name\":\"_erc20Token\",\"type\":\"address\"},{\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numTokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalEtherPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"MarketboardListingComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"MarketboardListingBuyback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MarketboardListingDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldPricePerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPricePerToken\",\"type\":\"uint256\"}],\"name\":\"MarketboardListingPriceChanged\",\"type\":\"event\"}]","ContractName":"MarketboardERC20Listing","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008ac8fad328b0f3795ed410c19fa733422f474a0c00000000000000000000000000000000000000000000000000038d7ea4c6800000000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000f629cbd94d3791c9250152bd8dfbdf380e2a3b9c00000000000000000000000000000000000000000000000000038d7ea4c68000","Library":"","SwarmSource":"bzzr://bca9be2d31bd03fd25b10191fbe9606bb2796f743577da412384fc17f0f96a23"}]}