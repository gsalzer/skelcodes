{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * ICrowdsale\r\n *\r\n * Base crowdsale interface to manage the sale of \r\n * an ERC20 token\r\n *\r\n * #created 09/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ICrowdsale {\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the presale phase\r\n     *\r\n     * @return True if in presale phase\r\n     */\r\n    function isInPresalePhase() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the ended stage\r\n     *\r\n     * @return True if ended\r\n     */\r\n    function isEnded() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns true if `_beneficiary` has a balance allocated\r\n     *\r\n     * @param _beneficiary The account that the balance is allocated for\r\n     * @param _releaseDate The date after which the balance can be withdrawn\r\n     * @return True if there is a balance that belongs to `_beneficiary`\r\n     */\r\n    function hasBalance(address _beneficiary, uint _releaseDate) public view returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the allocated token balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated token balance will be retrieved\r\n     * @return The allocated token balance\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get the allocated eth balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated eth balance will be retrieved\r\n     * @return The allocated eth balance\r\n     */\r\n    function ethBalanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\r\n     * \r\n     * @param _owner The address from which the refundable balance will be retrieved\r\n     * @return The invested refundable balance\r\n     */\r\n    function refundableEthBalanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Returns the rate and bonus release date\r\n     *\r\n     * @param _phase The phase to use while determining the rate\r\n     * @param _volume The amount wei used to determine what volume multiplier to use\r\n     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\r\n     */\r\n    function getRate(uint _phase, uint _volume) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Convert `_wei` to an amount in tokens using \r\n     * the `_rate`\r\n     *\r\n     * @param _wei amount of wei to convert\r\n     * @param _rate rate to use for the conversion\r\n     * @return Amount in tokens\r\n     */\r\n    function toTokens(uint _wei, uint _rate) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     */\r\n    function withdrawTokens() public;\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     */\r\n    function withdrawEther() public;\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     */\r\n    function refund() public;\r\n}\r\n\r\n\r\n/**\r\n * ICrowdsaleProxy\r\n *\r\n * #created 23/11/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ICrowdsaleProxy {\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * CrowdsaleProxy\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract CrowdsaleProxy is ICrowdsaleProxy {\r\n\r\n    address public owner;\r\n    ICrowdsale public target;\r\n    \r\n\r\n    /**\r\n     * Deploy proxy\r\n     *\r\n     * @param _owner Owner of the proxy\r\n     * @param _target Target crowdsale\r\n     */\r\n    function CrowdsaleProxy(address _owner, address _target) public {\r\n        target = ICrowdsale(_target);\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive contribution and forward to the crowdsale\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     */\r\n    function () public payable {\r\n        target.contributeFor.value(msg.value)(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint) {\r\n        target.contributeFor.value(msg.value)(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint) {\r\n        target.contributeFor.value(msg.value)(_beneficiary);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"contributeFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_target\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"CrowdsaleProxy","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000947507e2fF3aFdbE723066518A5154da937d224800000000000000000000000024c629d4913681b82ae7f9b30befd80e5229c36e","Library":"","SwarmSource":"bzzr://760ae7e11d05486dfea8d11b6351b6a376671fccbe1cdbc0010994142bb234f2"}]}