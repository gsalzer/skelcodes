{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\nlibrary ECVerify {\r\n\r\n    function ecverify(bytes32 hash, bytes signature) internal pure returns (address signature_address) {\r\n        require(signature.length == 65);\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n\r\n            // Here we are loading the last 32 bytes, including 31 bytes of 's'.\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(v == 27 || v == 28);\r\n\r\n        signature_address = ecrecover(hash, v, r, s);\r\n\r\n        // ecrecover returns zero on error\r\n        require(signature_address != 0x0);\r\n\r\n        return signature_address;\r\n    }\r\n}\r\n/// @title Base Token contract - Functions to be implemented by token contracts.\r\ncontract Token {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    /*\r\n     * This is a slight change to the ERC20 base standard.\r\n     * function totalSupply() constant returns (uint256 supply);\r\n     * is replaced with:\r\n     * uint256 public totalSupply;\r\n     * This automatically creates a getter function for the totalSupply.\r\n     * This is moved to the base contract since public getter functions are not\r\n     * currently recognised as an implementation of the matching abstract\r\n     * function by the compiler.\r\n     */\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n     * NOTE:\r\n     * The following variables were optional. Now, they are included in ERC 223 interface.\r\n     * They allow one to customise the token contract & in no way influences the core functionality.\r\n     */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n\r\n\r\n    /// @param _owner The address from which the balance will be retrieved.\r\n    /// @return The balance.\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The amount of token to be transferred.\r\n    /// @param _data Data to be sent to `tokenFallback.\r\n    /// @return Returns success of function call.\r\n    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The amount of token to be transferred.\r\n    /// @return Whether the transfer was successful or not.\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`.\r\n    /// @param _from The address of the sender.\r\n    /// @param _to The address of the recipient.\r\n    /// @param _value The amount of token to be transferred.\r\n    /// @return Whether the transfer was successful or not.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens.\r\n    /// @param _spender The address of the account able to transfer the tokens.\r\n    /// @param _value The amount of tokens to be approved for transfer.\r\n    /// @return Whether the approval was successful or not.\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens.\r\n    /// @param _spender The address of the account able to transfer the tokens.\r\n    /// @return Amount of remaining tokens allowed to spent.\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    /*\r\n     * Events\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n}\r\n/// @title Raiden MicroTransfer Channels Contract.\r\ncontract RaidenMicroTransferChannels {\r\n\r\n    /*\r\n     *  Data structures\r\n     */\r\n\r\n    uint32 public challenge_period;\r\n\r\n    // Contract semantic version\r\n    string public constant version = '0.1.0';\r\n\r\n    // We temporarily limit total token deposits in a channel to 100 tokens with 18 decimals.\r\n    // This was calculated just for RDN with its current (as of 30/11/2017) price and should\r\n    // not be considered to be the same for other tokens.\r\n    // This is just for the bug bounty release, as a safety measure.\r\n    uint256 public constant channel_deposit_bugbounty_limit = 10 ** 18 * 100;\r\n\r\n    Token public token;\r\n\r\n    mapping (bytes32 => Channel) public channels;\r\n    mapping (bytes32 => ClosingRequest) public closing_requests;\r\n\r\n    // 28 (deposit) + 4 (block no settlement)\r\n    struct Channel {\r\n        // uint192 is the maximum uint size needed for deposit based on a\r\n        // 10^8 * 10^18 token totalSupply.\r\n        uint192 deposit;\r\n\r\n        // Used in creating a unique identifier for the channel between a sender and receiver.\r\n        // Supports creation of multiple channels between the 2 parties and prevents\r\n        // replay of messages in later channels.\r\n        uint32 open_block_number;\r\n    }\r\n\r\n    struct ClosingRequest {\r\n        uint192 closing_balance;\r\n        uint32 settle_block_number;\r\n    }\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n\r\n    event ChannelCreated(\r\n        address indexed _sender,\r\n        address indexed _receiver,\r\n        uint192 _deposit);\r\n    event ChannelToppedUp (\r\n        address indexed _sender,\r\n        address indexed _receiver,\r\n        uint32 indexed _open_block_number,\r\n        uint192 _added_deposit);\r\n    event ChannelCloseRequested(\r\n        address indexed _sender,\r\n        address indexed _receiver,\r\n        uint32 indexed _open_block_number,\r\n        uint192 _balance);\r\n    event ChannelSettled(\r\n        address indexed _sender,\r\n        address indexed _receiver,\r\n        uint32 indexed _open_block_number,\r\n        uint192 _balance);\r\n\r\n\r\n    /*\r\n     *  Constructor\r\n     */\r\n\r\n    /// @dev Constructor for creating the uRaiden microtransfer channels contract.\r\n    /// @param _token_address The address of the Token used by the uRaiden contract.\r\n    /// @param _challenge_period A fixed number of blocks representing the challenge period.\r\n    /// We enforce a minimum of 500 blocks waiting period.\r\n    /// after a sender requests the closing of the channel without the receiver's signature.\r\n    function RaidenMicroTransferChannels(address _token_address, uint32 _challenge_period) public {\r\n        require(_token_address != 0x0);\r\n        require(addressHasCode(_token_address));\r\n        require(_challenge_period >= 500);\r\n\r\n        token = Token(_token_address);\r\n\r\n        // Check if the contract is indeed a token contract\r\n        require(token.totalSupply() > 0);\r\n\r\n        challenge_period = _challenge_period;\r\n    }\r\n\r\n    /*\r\n     *  Public helper functions (constant)\r\n     */\r\n    /// @dev Returns the unique channel identifier used in the contract.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @return Unique channel identifier.\r\n    function getKey(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number)\r\n        public\r\n        pure\r\n        returns (bytes32 data)\r\n    {\r\n        return keccak256(_sender_address, _receiver_address, _open_block_number);\r\n    }\r\n\r\n    /// @dev Returns the sender address extracted from the balance proof.\r\n    /// Works with eth_signTypedData https://github.com/ethereum/EIPs/pull/712.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    /// @param _balance_msg_sig The balance message signed by the sender.\r\n    /// @return Address of the balance proof signer.\r\n    function verifyBalanceProof(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance,\r\n        bytes _balance_msg_sig)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        // The variable names from below will be shown to the sender when signing\r\n        // the balance proof, so they have to be kept in sync with the Dapp client.\r\n        // The hashed strings should be kept in sync with this function's parameters\r\n        // (variable names and types).\r\n        // ! Note that EIP712 might change how hashing is done, triggering a\r\n        // new contract deployment with updated code.\r\n        bytes32 message_hash = keccak256(\r\n          keccak256('address receiver', 'uint32 block_created', 'uint192 balance', 'address contract'),\r\n          keccak256(_receiver_address, _open_block_number, _balance, address(this))\r\n        );\r\n\r\n        // Derive address from signature\r\n        address signer = ECVerify.ecverify(message_hash, _balance_msg_sig);\r\n        return signer;\r\n    }\r\n\r\n    /*\r\n     *  External functions\r\n     */\r\n\r\n    /// @dev Opens a new channel or tops up an existing one, compatibility with ERC 223;\r\n    /// msg.sender is Token contract.\r\n    /// @param _sender_address The address that sends the tokens.\r\n    /// @param _deposit The amount of tokens that the sender escrows.\r\n    /// @param _data Receiver address in bytes.\r\n    function tokenFallback(address _sender_address, uint256 _deposit, bytes _data) external {\r\n        // Make sure we trust the token\r\n        require(msg.sender == address(token));\r\n\r\n        uint192 deposit = uint192(_deposit);\r\n        require(deposit == _deposit);\r\n\r\n        uint length = _data.length;\r\n\r\n        // createChannel - receiver address (20 bytes)\r\n        // topUp - receiver address (20 bytes) + open_block_number (4 bytes) = 24 bytes\r\n        require(length == 20 || length == 24);\r\n\r\n        address receiver = addressFromData(_data);\r\n\r\n        if(length == 20) {\r\n            createChannelPrivate(_sender_address, receiver, deposit);\r\n        } else {\r\n            uint32 open_block_number = blockNumberFromData(_data);\r\n            updateInternalBalanceStructs(\r\n                _sender_address,\r\n                receiver,\r\n                open_block_number,\r\n                deposit\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Creates a new channel between a sender and a receiver and transfers\r\n    /// the sender's token deposit to this contract, compatibility with ERC20 tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _deposit The amount of tokens that the sender escrows.\r\n    function createChannelERC20(address _receiver_address, uint192 _deposit) external {\r\n        createChannelPrivate(msg.sender, _receiver_address, _deposit);\r\n\r\n        // transferFrom deposit from sender to contract\r\n        // ! needs prior approval from user\r\n        require(token.transferFrom(msg.sender, address(this), _deposit));\r\n    }\r\n\r\n    /// @dev Increase the sender's current deposit.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _added_deposit The added token deposit with which the current deposit is increased.\r\n    function topUpERC20(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _added_deposit)\r\n        external\r\n    {\r\n        updateInternalBalanceStructs(\r\n            msg.sender,\r\n            _receiver_address,\r\n            _open_block_number,\r\n            _added_deposit\r\n        );\r\n\r\n        // transferFrom deposit from msg.sender to contract\r\n        // ! needs prior approval from user\r\n        // Do transfer after any state change\r\n        require(token.transferFrom(msg.sender, address(this), _added_deposit));\r\n    }\r\n\r\n    /// @dev Function called when any of the parties wants to close the channel and settle;\r\n    /// receiver needs a balance proof to immediately settle, sender triggers a challenge period.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    /// @param _balance_msg_sig The balance message signed by the sender.\r\n    function uncooperativeClose(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance,\r\n        bytes _balance_msg_sig)\r\n        external\r\n    {\r\n        address sender = verifyBalanceProof(_receiver_address, _open_block_number, _balance, _balance_msg_sig);\r\n\r\n        if(msg.sender == _receiver_address) {\r\n            settleChannel(sender, _receiver_address, _open_block_number, _balance);\r\n        } else {\r\n            require(msg.sender == sender);\r\n            initChallengePeriod(_receiver_address, _open_block_number, _balance);\r\n        }\r\n    }\r\n\r\n    /// @dev Function called by the sender, when he has a closing signature from the receiver;\r\n    /// channel is closed immediately.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    /// @param _balance_msg_sig The balance message signed by the sender.\r\n    /// @param _closing_sig The hash of the signed balance message, signed by the receiver.\r\n    function cooperativeClose(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance,\r\n        bytes _balance_msg_sig,\r\n        bytes _closing_sig)\r\n        external\r\n    {\r\n        // Derive receiver address from signature\r\n        address receiver = ECVerify.ecverify(keccak256(_balance_msg_sig), _closing_sig);\r\n        require(receiver == _receiver_address);\r\n\r\n        // Derive sender address from signed balance proof\r\n        address sender = verifyBalanceProof(_receiver_address, _open_block_number, _balance, _balance_msg_sig);\r\n        require(msg.sender == sender);\r\n\r\n        settleChannel(sender, receiver, _open_block_number, _balance);\r\n    }\r\n\r\n    /// @dev Function for getting information about a channel.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @return Channel information (unique_identifier, deposit, settle_block_number, closing_balance).\r\n    function getChannelInfo(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number)\r\n        external\r\n        constant\r\n        returns (bytes32, uint192, uint32, uint192)\r\n    {\r\n        bytes32 key = getKey(_sender_address, _receiver_address, _open_block_number);\r\n        require(channels[key].open_block_number > 0);\r\n\r\n        return (\r\n            key,\r\n            channels[key].deposit,\r\n            closing_requests[key].settle_block_number,\r\n            closing_requests[key].closing_balance\r\n        );\r\n    }\r\n\r\n    /// @dev Function called by the sender after the challenge period has ended,\r\n    /// in case the receiver has not closed the channel.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between\r\n    /// the sender and receiver was created.\r\n    function settle(address _receiver_address, uint32 _open_block_number) external {\r\n        bytes32 key = getKey(msg.sender, _receiver_address, _open_block_number);\r\n\r\n        // Make sure an uncooperativeClose has been initiated\r\n        require(closing_requests[key].settle_block_number > 0);\r\n\r\n        // Make sure the challenge_period has ended\r\n\t    require(block.number > closing_requests[key].settle_block_number);\r\n\r\n        settleChannel(msg.sender, _receiver_address, _open_block_number,\r\n            closing_requests[key].closing_balance\r\n        );\r\n    }\r\n\r\n    /*\r\n     *  Private functions\r\n     */\r\n\r\n    /// @dev Creates a new channel between a sender and a receiver,\r\n    /// only callable by the Token contract.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _deposit The amount of tokens that the sender escrows.\r\n    function createChannelPrivate(address _sender_address, address _receiver_address, uint192 _deposit) private {\r\n        require(_deposit <= channel_deposit_bugbounty_limit);\r\n\r\n        uint32 open_block_number = uint32(block.number);\r\n\r\n        // Create unique identifier from sender, receiver and current block number\r\n        bytes32 key = getKey(_sender_address, _receiver_address, open_block_number);\r\n\r\n        require(channels[key].deposit == 0);\r\n        require(channels[key].open_block_number == 0);\r\n        require(closing_requests[key].settle_block_number == 0);\r\n\r\n        // Store channel information\r\n        channels[key] = Channel({deposit: _deposit, open_block_number: open_block_number});\r\n        ChannelCreated(_sender_address, _receiver_address, _deposit);\r\n    }\r\n\r\n    /// @dev Updates internal balance Structures, only callable by the Token contract.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _added_deposit The added token deposit with which the current deposit is increased.\r\n    function updateInternalBalanceStructs(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _added_deposit)\r\n        private\r\n    {\r\n        require(_added_deposit > 0);\r\n        require(_open_block_number > 0);\r\n\r\n        bytes32 key = getKey(_sender_address, _receiver_address, _open_block_number);\r\n\r\n        require(channels[key].deposit > 0);\r\n        require(closing_requests[key].settle_block_number == 0);\r\n        require(channels[key].deposit + _added_deposit <= channel_deposit_bugbounty_limit);\r\n\r\n        channels[key].deposit += _added_deposit;\r\n        assert(channels[key].deposit > _added_deposit);\r\n        ChannelToppedUp(_sender_address, _receiver_address, _open_block_number, _added_deposit);\r\n    }\r\n\r\n\r\n    /// @dev Sender starts the challenge period; this can only happen once.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between\r\n    /// the sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    function initChallengePeriod(\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance)\r\n        private\r\n    {\r\n        bytes32 key = getKey(msg.sender, _receiver_address, _open_block_number);\r\n\r\n        require(closing_requests[key].settle_block_number == 0);\r\n        require(_balance <= channels[key].deposit);\r\n\r\n        // Mark channel as closed\r\n        closing_requests[key].settle_block_number = uint32(block.number) + challenge_period;\r\n        closing_requests[key].closing_balance = _balance;\r\n        ChannelCloseRequested(msg.sender, _receiver_address, _open_block_number, _balance);\r\n    }\r\n\r\n    /// @dev Deletes the channel and settles by transfering the balance to the receiver\r\n    /// and the rest of the deposit back to the sender.\r\n    /// @param _sender_address The address that sends tokens.\r\n    /// @param _receiver_address The address that receives tokens.\r\n    /// @param _open_block_number The block number at which a channel between the\r\n    /// sender and receiver was created.\r\n    /// @param _balance The amount of tokens owed by the sender to the receiver.\r\n    function settleChannel(\r\n        address _sender_address,\r\n        address _receiver_address,\r\n        uint32 _open_block_number,\r\n        uint192 _balance)\r\n        private\r\n    {\r\n        bytes32 key = getKey(_sender_address, _receiver_address, _open_block_number);\r\n        Channel memory channel = channels[key];\r\n\r\n        require(channel.open_block_number > 0);\r\n        require(_balance <= channel.deposit);\r\n\r\n        // Remove closed channel structures\r\n        // channel.open_block_number will become 0\r\n        // Change state before transfer call\r\n        delete channels[key];\r\n        delete closing_requests[key];\r\n\r\n        // Send _balance to the receiver, as it is always <= deposit\r\n        require(token.transfer(_receiver_address, _balance));\r\n\r\n        // Send deposit - balance back to sender\r\n        require(token.transfer(_sender_address, channel.deposit - _balance));\r\n\r\n        ChannelSettled(_sender_address, _receiver_address, _open_block_number, _balance);\r\n    }\r\n\r\n    /*\r\n     *  Internal functions\r\n     */\r\n\r\n    /// @dev Internal function for getting an address from tokenFallback data bytes.\r\n    /// @param b Bytes received.\r\n    /// @return Address resulted.\r\n    function addressFromData (bytes b) internal pure returns (address) {\r\n        bytes20 addr;\r\n        assembly {\r\n            // Read address bytes\r\n            // Offset of 32 bytes, representing b.length\r\n            addr := mload(add(b, 0x20))\r\n        }\r\n        return address(addr);\r\n    }\r\n\r\n    /// @dev Internal function for getting the block number from tokenFallback data bytes.\r\n    /// @param b Bytes received.\r\n    /// @return Block number.\r\n    function blockNumberFromData(bytes b) internal pure returns (uint32) {\r\n        bytes4 block_number;\r\n        assembly {\r\n            // Read block number bytes\r\n            // Offset of 32 bytes (b.length) + 20 bytes (address)\r\n            block_number := mload(add(b, 0x34))\r\n        }\r\n        return uint32(block_number);\r\n    }\r\n\r\n    /// @notice Check if a contract exists\r\n    /// @param _contract The address of the contract to check for.\r\n    /// @return True if a contract exists, false otherwise\r\n    function addressHasCode(address _contract) internal constant returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(_contract)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"challenge_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"}],\"name\":\"getChannelInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint192\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint192\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"uint192\"},{\"name\":\"_balance_msg_sig\",\"type\":\"bytes\"},{\"name\":\"_closing_sig\",\"type\":\"bytes\"}],\"name\":\"cooperativeClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_deposit\",\"type\":\"uint192\"}],\"name\":\"createChannelERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"channel_deposit_bugbounty_limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"uint192\"},{\"name\":\"_balance_msg_sig\",\"type\":\"bytes\"}],\"name\":\"verifyBalanceProof\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"closing_requests\",\"outputs\":[{\"name\":\"closing_balance\",\"type\":\"uint192\"},{\"name\":\"settle_block_number\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"channels\",\"outputs\":[{\"name\":\"deposit\",\"type\":\"uint192\"},{\"name\":\"open_block_number\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"}],\"name\":\"getKey\",\"outputs\":[{\"name\":\"data\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_balance\",\"type\":\"uint192\"},{\"name\":\"_balance_msg_sig\",\"type\":\"bytes\"}],\"name\":\"uncooperativeClose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender_address\",\"type\":\"address\"},{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver_address\",\"type\":\"address\"},{\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"name\":\"_added_deposit\",\"type\":\"uint192\"}],\"name\":\"topUpERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token_address\",\"type\":\"address\"},{\"name\":\"_challenge_period\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_deposit\",\"type\":\"uint192\"}],\"name\":\"ChannelCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_added_deposit\",\"type\":\"uint192\"}],\"name\":\"ChannelToppedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint192\"}],\"name\":\"ChannelCloseRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_open_block_number\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint192\"}],\"name\":\"ChannelSettled\",\"type\":\"event\"}]","ContractName":"RaidenMicroTransferChannels","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000255aa6df07540cb5d3d297f0d0d4d84cb52bc8e600000000000000000000000000000000000000000000000000000000000021C0","Library":"","SwarmSource":"bzzr://b5ead2751fee6002dbd1432c294d23a630a2257cb566a1d2a3c92d9ecd7f9cfe"}]}