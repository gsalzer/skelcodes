{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/* The authentication manager details user accounts that have access to certain priviledges and keeps a permanent ledger of who has and has had these rights. */\r\ncontract AuthenticationManager {\r\n    /* Map addresses to admins */\r\n    mapping (address => bool) adminAddresses;\r\n\r\n    /* Map addresses to account readers */\r\n    mapping (address => bool) accountReaderAddresses;\r\n\r\n    /* Details of all admins that have ever existed */\r\n    address[] adminAudit;\r\n\r\n    /* Details of all account readers that have ever existed */\r\n    address[] accountReaderAudit;\r\n\r\n    /* Fired whenever an admin is added to the contract. */\r\n    event AdminAdded(address addedBy, address admin);\r\n\r\n    /* Fired whenever an admin is removed from the contract. */\r\n    event AdminRemoved(address removedBy, address admin);\r\n\r\n    /* Fired whenever an account-reader contract is added. */\r\n    event AccountReaderAdded(address addedBy, address account);\r\n\r\n    /* Fired whenever an account-reader contract is removed. */\r\n    event AccountReaderRemoved(address removedBy, address account);\r\n\r\n    /* When this contract is first setup we use the creator as the first admin */    \r\n    function AuthenticationManager() {\r\n        /* Set the first admin to be the person creating the contract */\r\n        adminAddresses[msg.sender] = true;\r\n        AdminAdded(0, msg.sender);\r\n        adminAudit.length++;\r\n        adminAudit[adminAudit.length - 1] = msg.sender;\r\n    }\r\n\r\n    /* Gets the contract version for validation */\r\n    function contractVersion() constant returns(uint256) {\r\n        // Admin contract identifies as 100YYYYMMDDHHMM\r\n        return 100201707171503;\r\n    }\r\n\r\n    /* Gets whether or not the specified address is currently an admin */\r\n    function isCurrentAdmin(address _address) constant returns (bool) {\r\n        return adminAddresses[_address];\r\n    }\r\n\r\n    /* Gets whether or not the specified address has ever been an admin */\r\n    function isCurrentOrPastAdmin(address _address) constant returns (bool) {\r\n        for (uint256 i = 0; i < adminAudit.length; i++)\r\n            if (adminAudit[i] == _address)\r\n                return true;\r\n        return false;\r\n    }\r\n\r\n    /* Gets whether or not the specified address is currently an account reader */\r\n    function isCurrentAccountReader(address _address) constant returns (bool) {\r\n        return accountReaderAddresses[_address];\r\n    }\r\n\r\n    /* Gets whether or not the specified address has ever been an admin */\r\n    function isCurrentOrPastAccountReader(address _address) constant returns (bool) {\r\n        for (uint256 i = 0; i < accountReaderAudit.length; i++)\r\n            if (accountReaderAudit[i] == _address)\r\n                return true;\r\n        return false;\r\n    }\r\n\r\n    /* Adds a user to our list of admins */\r\n    function addAdmin(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already admin\r\n        if (adminAddresses[_address])\r\n            throw;\r\n        \r\n        // Add the user\r\n        adminAddresses[_address] = true;\r\n        AdminAdded(msg.sender, _address);\r\n        adminAudit.length++;\r\n        adminAudit[adminAudit.length - 1] = _address;\r\n    }\r\n\r\n    /* Removes a user from our list of admins but keeps them in the history audit */\r\n    function removeAdmin(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        /* Don't allow removal of self */\r\n        if (_address == msg.sender)\r\n            throw;\r\n\r\n        // Fail if this account is already non-admin\r\n        if (!adminAddresses[_address])\r\n            throw;\r\n\r\n        /* Remove this admin user */\r\n        adminAddresses[_address] = false;\r\n        AdminRemoved(msg.sender, _address);\r\n    }\r\n\r\n    /* Adds a user/contract to our list of account readers */\r\n    function addAccountReader(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already in the list\r\n        if (accountReaderAddresses[_address])\r\n            throw;\r\n        \r\n        // Add the user\r\n        accountReaderAddresses[_address] = true;\r\n        AccountReaderAdded(msg.sender, _address);\r\n        accountReaderAudit.length++;\r\n        accountReaderAudit[adminAudit.length - 1] = _address;\r\n    }\r\n\r\n    /* Removes a user/contracts from our list of account readers but keeps them in the history audit */\r\n    function removeAccountReader(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already not in the list\r\n        if (!accountReaderAddresses[_address])\r\n            throw;\r\n\r\n        /* Remove this admin user */\r\n        accountReaderAddresses[_address] = false;\r\n        AccountReaderRemoved(msg.sender, _address);\r\n    }\r\n}\r\ncontract VotingBase {\r\n    using SafeMath for uint256;\r\n\r\n    /* Map all our our balances for issued tokens */\r\n    mapping (address => uint256) public voteCount;\r\n\r\n    /* List of all token holders */\r\n    address[] public voterAddresses;\r\n\r\n    /* Defines the admin contract we interface with for credentails. */\r\n    AuthenticationManager internal authenticationManager;\r\n\r\n    /* Unix epoch voting starts at */\r\n    uint256 public voteStartTime;\r\n\r\n    /* Unix epoch voting ends at */\r\n    uint256 public voteEndTime;\r\n\r\n    /* This modifier allows a method to only be called by current admins */\r\n    modifier adminOnly {\r\n        if (!authenticationManager.isCurrentAdmin(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    function setVoterCount(uint256 _count) adminOnly {\r\n        // Forbid after voting has started\r\n        if (now >= voteStartTime)\r\n            throw;\r\n\r\n        /* Clear existing voter count */\r\n        for (uint256 i = 0; i < voterAddresses.length; i++) {\r\n            address voter = voterAddresses[i];\r\n            voteCount[voter] = 0;\r\n        }\r\n\r\n        /* Set the count accordingly */\r\n        voterAddresses.length = _count;\r\n    }\r\n\r\n    function setVoter(uint256 _position, address _voter, uint256 _voteCount) adminOnly {\r\n        // Forbid after voting has started\r\n        if (now >= voteStartTime)\r\n            throw;\r\n\r\n        if (_position >= voterAddresses.length)\r\n            throw;\r\n            \r\n        voterAddresses[_position] = _voter;\r\n        voteCount[_voter] = _voteCount;\r\n    }\r\n}\r\n\r\ncontract VoteSvp002 is VotingBase {\r\n    using SafeMath for uint256;\r\n\r\n    /* Votes for SVP002-01.  0 = not votes, 1 = Yes, 2 = No */\r\n     mapping (address => uint256) vote01;\r\n     uint256 public vote01YesCount;\r\n     uint256 public vote01NoCount;\r\n\r\n    /* Votes for SVP002-02.  0 = not votes, 1 = Yes, 2 = No */\r\n     mapping (address => uint256) vote02;\r\n     uint256 public vote02YesCount;\r\n     uint256 public vote02NoCount;\r\n\r\n    /* Votes for SVP003-02.  0 = not votes, 1 = Yes, 2 = No */\r\n     mapping (address => uint256) vote03;\r\n     uint256 public vote03YesCount;\r\n     uint256 public vote03NoCount;\r\n\r\n    /* Create our contract with references to other contracts as required. */\r\n    function VoteSvp002(address _authenticationManagerAddress, uint256 _voteStartTime, uint256 _voteEndTime) {\r\n        /* Setup access to our other contracts and validate their versions */\r\n        authenticationManager = AuthenticationManager(_authenticationManagerAddress);\r\n        if (authenticationManager.contractVersion() != 100201707171503)\r\n            throw;\r\n\r\n        /* Store start/end times */\r\n        if (_voteStartTime >= _voteEndTime)\r\n            throw;\r\n        voteStartTime = _voteStartTime;\r\n        voteEndTime = _voteEndTime;\r\n    }\r\n\r\n     function voteSvp01(bool vote) {\r\n        // Forbid outside of voting period\r\n        if (now < voteStartTime || now > voteEndTime)\r\n            throw;\r\n\r\n         /* Ensure they have voting rights first */\r\n         uint256 voteWeight = voteCount[msg.sender];\r\n         if (voteWeight == 0)\r\n            throw;\r\n        \r\n        /* Set their vote */\r\n        uint256 existingVote = vote01[msg.sender];\r\n        uint256 newVote = vote ? 1 : 2;\r\n        if (newVote == existingVote)\r\n            /* No change so just return */\r\n            return;\r\n        vote01[msg.sender] = newVote;\r\n\r\n        /* If they had voted previous first decrement previous vote count */\r\n        if (existingVote == 1)\r\n            vote01YesCount -= voteWeight;\r\n        else if (existingVote == 2)\r\n            vote01NoCount -= voteWeight;\r\n        if (vote)\r\n            vote01YesCount += voteWeight;\r\n        else\r\n            vote01NoCount += voteWeight;\r\n     }\r\n\r\n     function voteSvp02(bool vote) {\r\n        // Forbid outside of voting period\r\n        if (now < voteStartTime || now > voteEndTime)\r\n            throw;\r\n\r\n         /* Ensure they have voting rights first */\r\n         uint256 voteWeight = voteCount[msg.sender];\r\n         if (voteWeight == 0)\r\n            throw;\r\n        \r\n        /* Set their vote */\r\n        uint256 existingVote = vote02[msg.sender];\r\n        uint256 newVote = vote ? 1 : 2;\r\n        if (newVote == existingVote)\r\n            /* No change so just return */\r\n            return;\r\n        vote02[msg.sender] = newVote;\r\n\r\n        /* If they had voted previous first decrement previous vote count */\r\n        if (existingVote == 1)\r\n            vote02YesCount -= voteWeight;\r\n        else if (existingVote == 2)\r\n            vote02NoCount -= voteWeight;\r\n        if (vote)\r\n            vote02YesCount += voteWeight;\r\n        else\r\n            vote02NoCount += voteWeight;\r\n     }\r\n\r\n     function voteSvp03(bool vote) {\r\n        // Forbid outside of voting period\r\n        if (now < voteStartTime || now > voteEndTime)\r\n            throw;\r\n\r\n         /* Ensure they have voting rights first */\r\n         uint256 voteWeight = voteCount[msg.sender];\r\n         if (voteWeight == 0)\r\n            throw;\r\n        \r\n        /* Set their vote */\r\n        uint256 existingVote = vote03[msg.sender];\r\n        uint256 newVote = vote ? 1 : 2;\r\n        if (newVote == existingVote)\r\n            /* No change so just return */\r\n            return;\r\n        vote03[msg.sender] = newVote;\r\n\r\n        /* If they had voted previous first decrement previous vote count */\r\n        if (existingVote == 1)\r\n            vote03YesCount -= voteWeight;\r\n        else if (existingVote == 2)\r\n            vote03NoCount -= voteWeight;\r\n        if (vote)\r\n            vote03YesCount += voteWeight;\r\n        else\r\n            vote03NoCount += voteWeight;\r\n     }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"vote02YesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vote02NoCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"voteStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vote03YesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vote01YesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vote\",\"type\":\"bool\"}],\"name\":\"voteSvp01\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vote03NoCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vote01NoCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"voteEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setVoterCount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voterAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vote\",\"type\":\"bool\"}],\"name\":\"voteSvp02\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vote\",\"type\":\"bool\"}],\"name\":\"voteSvp03\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_position\",\"type\":\"uint256\"},{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_voteCount\",\"type\":\"uint256\"}],\"name\":\"setVoter\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_authenticationManagerAddress\",\"type\":\"address\"},{\"name\":\"_voteStartTime\",\"type\":\"uint256\"},{\"name\":\"_voteEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"VoteSvp002","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c6a3746aa3fec176559f0865fd5240159402a81f0000000000000000000000000000000000000000000000000000000059ddeba00000000000000000000000000000000000000000000000000000000059e72620","Library":"","SwarmSource":"bzzr://0aea40f9bf236f6c0f6f60a436e581591a037a221e7011e147d9205df8099710"}]}