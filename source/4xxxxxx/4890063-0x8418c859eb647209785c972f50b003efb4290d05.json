{"status":"1","message":"OK","result":[{"SourceCode":"/*************************************************************************\r\n * This contract has been merged with solidify\r\n * https://github.com/tiesnetwork/solidify\r\n *************************************************************************/\r\n \r\n pragma solidity ^0.4.18;\r\n\r\n/*************************************************************************\r\n * import \"./BCSCrowdsale.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../token/ITokenPool.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"./ERC20StandardToken.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"./IERC20Token.sol\" : start\r\n *************************************************************************/\r\n\r\ncontract IERC20Token {\r\n\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \r\n    function name() public constant returns (string _name) { _name; }\r\n    function symbol() public constant returns (string _symbol) { _symbol; }\r\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\r\n    \r\n    function totalSupply() public constant returns (uint total) {total;}\r\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    \r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n/*************************************************************************\r\n * import \"./IERC20Token.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../common/SafeMath.sol\" : start\r\n *************************************************************************/\r\n\r\n/**dev Utility methods for overflow-proof arithmetic operations \r\n*/\r\ncontract SafeMath {\r\n\r\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {        \r\n        assert(a+b >= a);\r\n        return a+b;\r\n    }\r\n\r\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\r\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0) || (z / x == y));\r\n        return z;\r\n    }\r\n\r\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        assert(y != 0);\r\n        return x / y;\r\n    }\r\n}/*************************************************************************\r\n * import \"../common/SafeMath.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Standard ERC20 compliant token implementation */\r\ncontract ERC20StandardToken is IERC20Token, SafeMath {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    //tokens already issued\r\n    uint256 tokensIssued;\r\n    //balances for each account\r\n    mapping (address => uint256) balances;\r\n    //one account approves the transfer of an amount to another account\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function ERC20StandardToken() public {\r\n     \r\n    }    \r\n\r\n    //\r\n    //IERC20Token implementation\r\n    // \r\n\r\n    function totalSupply() public constant returns (uint total) {\r\n        total = tokensIssued;\r\n    }\r\n \r\n    function balanceOf(address _owner) public constant returns (uint balance) {\r\n        balance = balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        // safeSub inside doTransfer will throw if there is not enough balance.\r\n        doTransfer(msg.sender, _to, _value);        \r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        \r\n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \r\n        // safeSub inside doTransfer will throw if there is not enough balance.\r\n        doTransfer(_from, _to, _value);        \r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        remaining = allowed[_owner][_spender];\r\n    }    \r\n\r\n    //\r\n    // Additional functions\r\n    //\r\n    /**@dev Gets real token amount in the smallest token units */\r\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\r\n        return tokens * (uint256(10) ** decimals);\r\n    }\r\n\r\n    //\r\n    // Internal functions\r\n    //    \r\n    \r\n    function doTransfer(address _from, address _to, uint256 _value) internal {\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n    }\r\n}/*************************************************************************\r\n * import \"./ERC20StandardToken.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Token pool that manages its tokens by designating trustees */\r\ncontract ITokenPool {    \r\n\r\n    /**@dev Token to be managed */\r\n    ERC20StandardToken public token;\r\n\r\n    /**@dev Changes trustee state */\r\n    function setTrustee(address trustee, bool state) public;\r\n\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    /**@dev Returns remaining token amount */\r\n    function getTokenAmount() public constant returns (uint256 tokens) {tokens;}\r\n}/*************************************************************************\r\n * import \"../token/ITokenPool.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../token/ReturnTokenAgent.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../common/Manageable.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../common/Owned.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"./IOwned.sol\" : start\r\n *************************************************************************/\r\n\r\n/**@dev Simple interface to Owned base class */\r\ncontract IOwned {\r\n    function owner() public constant returns (address) {}\r\n    function transferOwnership(address _newOwner) public;\r\n}/*************************************************************************\r\n * import \"./IOwned.sol\" : end\r\n *************************************************************************/\r\n\r\ncontract Owned is IOwned {\r\n    address public owner;        \r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**@dev allows transferring the contract ownership. */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n/*************************************************************************\r\n * import \"../common/Owned.sol\" : end\r\n *************************************************************************/\r\n\r\n///A token that have an owner and a list of managers that can perform some operations\r\n///Owner is always a manager too\r\ncontract Manageable is Owned {\r\n\r\n    event ManagerSet(address manager, bool state);\r\n\r\n    mapping (address => bool) public managers;\r\n\r\n    function Manageable() public Owned() {\r\n        managers[owner] = true;\r\n    }\r\n\r\n    /**@dev Allows execution by managers only */\r\n    modifier managerOnly {\r\n        require(managers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        super.transferOwnership(_newOwner);\r\n\r\n        managers[_newOwner] = true;\r\n        managers[msg.sender] = false;\r\n    }\r\n\r\n    function setManager(address manager, bool state) public ownerOnly {\r\n        managers[manager] = state;\r\n        ManagerSet(manager, state);\r\n    }\r\n}/*************************************************************************\r\n * import \"../common/Manageable.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../token/ReturnableToken.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n///Token that when sent to specified contract (returnAgent) invokes additional actions\r\ncontract ReturnableToken is Manageable, ERC20StandardToken {\r\n\r\n    /**@dev List of return agents */\r\n    mapping (address => bool) public returnAgents;\r\n\r\n    function ReturnableToken() public {}    \r\n    \r\n    /**@dev Sets new return agent */\r\n    function setReturnAgent(ReturnTokenAgent agent) public managerOnly {\r\n        returnAgents[address(agent)] = true;\r\n    }\r\n\r\n    /**@dev Removes return agent from list */\r\n    function removeReturnAgent(ReturnTokenAgent agent) public managerOnly {\r\n        returnAgents[address(agent)] = false;\r\n    }\r\n\r\n    function doTransfer(address _from, address _to, uint256 _value) internal {\r\n        super.doTransfer(_from, _to, _value);\r\n        if (returnAgents[_to]) {\r\n            ReturnTokenAgent(_to).returnToken(_from, _value);                \r\n        }\r\n    }\r\n}/*************************************************************************\r\n * import \"../token/ReturnableToken.sol\" : end\r\n *************************************************************************/\r\n\r\n///Returnable tokens receiver\r\ncontract ReturnTokenAgent is Manageable {\r\n    //ReturnableToken public returnableToken;\r\n\r\n    /**@dev List of returnable tokens in format token->flag  */\r\n    mapping (address => bool) public returnableTokens;\r\n\r\n    /**@dev Allows only token to execute method */\r\n    //modifier returnableTokenOnly {require(msg.sender == address(returnableToken)); _;}\r\n    modifier returnableTokenOnly {require(returnableTokens[msg.sender]); _;}\r\n\r\n    /**@dev Executes when tokens are transferred to this */\r\n    function returnToken(address from, uint256 amountReturned)  public;\r\n\r\n    /**@dev Sets token that can call returnToken method */\r\n    function setReturnableToken(ReturnableToken token) public managerOnly {\r\n        returnableTokens[address(token)] = true;\r\n    }\r\n\r\n    /**@dev Removes token that can call returnToken method */\r\n    function removeReturnableToken(ReturnableToken token) public managerOnly {\r\n        returnableTokens[address(token)] = false;\r\n    }\r\n}/*************************************************************************\r\n * import \"../token/ReturnTokenAgent.sol\" : end\r\n *************************************************************************/\r\n\r\n\r\n/*************************************************************************\r\n * import \"./IInvestRestrictions.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n/** @dev Restrictions on investment */\r\ncontract IInvestRestrictions is Manageable {\r\n    /**@dev Returns true if investmet is allowed */\r\n    function canInvest(address investor, uint amount, uint tokensLeft) constant returns (bool result) {\r\n        investor; amount; result; tokensLeft;\r\n    }\r\n\r\n    /**@dev Called when investment was made */\r\n    function investHappened(address investor, uint amount) managerOnly {}    \r\n}/*************************************************************************\r\n * import \"./IInvestRestrictions.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"./ICrowdsaleFormula.sol\" : start\r\n *************************************************************************/\r\n\r\n/**@dev Abstraction of crowdsale token calculation function */\r\ncontract ICrowdsaleFormula {\r\n\r\n    /**@dev Returns amount of tokens that can be bought with given weiAmount */\r\n    function howManyTokensForEther(uint256 weiAmount) constant returns(uint256 tokens, uint256 excess) {\r\n        weiAmount; tokens; excess;\r\n    }\r\n\r\n    /**@dev Returns how many tokens left for sale */\r\n    function tokensLeft() constant returns(uint256 _left) { _left;}    \r\n}/*************************************************************************\r\n * import \"./ICrowdsaleFormula.sol\" : end\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../token/TokenHolder.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n/*************************************************************************\r\n * import \"./ITokenHolder.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n/*************************************************************************\r\n * import \"./ITokenHolder.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev A convenient way to manage token's of a contract */\r\ncontract TokenHolder is ITokenHolder, Manageable {\r\n    \r\n    function TokenHolder() {\r\n    }\r\n\r\n    /** @dev Withdraws tokens held by the contract and sends them to a given address */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        managerOnly\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }\r\n}\r\n/*************************************************************************\r\n * import \"../token/TokenHolder.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Crowdsale base contract, used for PRE-TGE and TGE stages\r\n* Token holder should also be the owner of this contract */\r\ncontract BCSCrowdsale is ReturnTokenAgent, TokenHolder, ICrowdsaleFormula, SafeMath {\r\n\r\n    enum State {Unknown, BeforeStart, Active, FinishedSuccess, FinishedFailure}\r\n    \r\n    ITokenPool public tokenPool;\r\n    IInvestRestrictions public restrictions; //restrictions on investment\r\n    address public beneficiary; //address of contract to collect ether\r\n    uint256 public startTime; //unit timestamp of start time\r\n    uint256 public endTime; //unix timestamp of end date\r\n    uint256 public minimumGoalInWei; //TODO or in tokens\r\n    uint256 public tokensForOneEther; //how many tokens can you buy for 1 ether   \r\n    uint256 realAmountForOneEther; //how many tokens can you buy for 1 ether * 10**decimals   \r\n    uint256 bonusPct;   //additional percent of tokens    \r\n    bool public withdrew; //true if beneficiary already withdrew\r\n\r\n    uint256 public weiCollected;\r\n    uint256 public tokensSold;\r\n    uint256 public totalInvestments;\r\n\r\n    bool public failure; //true if some error occurred during crowdsale\r\n\r\n    mapping (address => uint256) public investedFrom; //how many wei specific address invested\r\n    mapping (address => uint256) public returnedTo; //how many wei returned to specific address if sale fails\r\n    mapping (address => uint256) public tokensSoldTo; //how many tokens sold to specific addreess\r\n    mapping (address => uint256) public overpays;     //overpays for send value excesses\r\n\r\n    // A new investment was made\r\n    event Invested(address investor, uint weiAmount, uint tokenAmount);\r\n    // Refund was processed for a contributor\r\n    event Refund(address investor, uint weiAmount);\r\n    // Overpay refund was processed for a contributor\r\n    event OverpayRefund(address investor, uint weiAmount);\r\n\r\n    /**@dev Crowdsale constructor, can specify startTime as 0 to start crowdsale immediately \r\n    _tokensForOneEther - doesn\"t depend on token decimals   */ \r\n    function BCSCrowdsale(        \r\n        ITokenPool _tokenPool,\r\n        IInvestRestrictions _restrictions,\r\n        address _beneficiary, \r\n        uint256 _startTime, \r\n        uint256 _durationInHours, \r\n        uint256 _goalInWei,\r\n        uint256 _tokensForOneEther,\r\n        uint256 _bonusPct) \r\n    {\r\n        require(_beneficiary != 0x0);\r\n        require(address(_tokenPool) != 0x0);\r\n        require(_tokensForOneEther > 0); \r\n        \r\n        tokenPool = _tokenPool;\r\n        beneficiary = _beneficiary;\r\n        restrictions = _restrictions;\r\n        \r\n        if (_startTime == 0) {\r\n            startTime = now;\r\n        } else {\r\n            startTime = _startTime;\r\n        }\r\n\r\n        endTime = (_durationInHours * 1 hours) + startTime;\r\n        \r\n        tokensForOneEther = _tokensForOneEther;\r\n        minimumGoalInWei = _goalInWei;\r\n        bonusPct = _bonusPct;\r\n\r\n        weiCollected = 0;\r\n        tokensSold = 0;\r\n        totalInvestments = 0;\r\n        failure = false;\r\n        withdrew = false;        \r\n        realAmountForOneEther = tokenPool.token().getRealTokenAmount(tokensForOneEther);\r\n    }\r\n\r\n    function() payable {\r\n        invest();\r\n    }\r\n\r\n    function invest() payable {\r\n        require(canInvest(msg.sender, msg.value));\r\n        \r\n        uint256 excess;\r\n        uint256 weiPaid = msg.value;\r\n        uint256 tokensToBuy;\r\n        (tokensToBuy, excess) = howManyTokensForEther(weiPaid);\r\n\r\n        require(tokensToBuy <= tokensLeft() && tokensToBuy > 0);\r\n\r\n        if (excess > 0) {\r\n            overpays[msg.sender] = safeAdd(overpays[msg.sender], excess);\r\n            weiPaid = safeSub(weiPaid, excess);\r\n        }\r\n        \r\n        investedFrom[msg.sender] = safeAdd(investedFrom[msg.sender], weiPaid);      \r\n        tokensSoldTo[msg.sender] = safeAdd(tokensSoldTo[msg.sender], tokensToBuy);\r\n        \r\n        tokensSold = safeAdd(tokensSold, tokensToBuy);\r\n        weiCollected = safeAdd(weiCollected, weiPaid);\r\n\r\n        if(address(restrictions) != 0x0) {\r\n            restrictions.investHappened(msg.sender, msg.value);\r\n        }\r\n        \r\n        require(tokenPool.token().transferFrom(tokenPool, msg.sender, tokensToBuy));\r\n        ++totalInvestments;\r\n        Invested(msg.sender, weiPaid, tokensToBuy);\r\n    }\r\n\r\n    /**@dev ReturnTokenAgent override. Returns ether if crowdsale is failed \r\n        and amount of returned tokens is exactly the same as bought */\r\n    function returnToken(address from, uint256 amountReturned) public returnableTokenOnly {\r\n        if (msg.sender == address(tokenPool.token()) && getState() == State.FinishedFailure) {\r\n            //require(getState() == State.FinishedFailure);\r\n            require(tokensSoldTo[from] == amountReturned);\r\n\r\n            returnedTo[from] = investedFrom[from];\r\n            investedFrom[from] = 0;\r\n            from.transfer(returnedTo[from]);\r\n\r\n            Refund(from, returnedTo[from]);\r\n        }\r\n    }\r\n\r\n    /**@dev Returns true if it is possible to invest */\r\n    function canInvest(address investor, uint256 amount) constant returns(bool) {\r\n        return getState() == State.Active &&\r\n                    (address(restrictions) == 0x0 || \r\n                    restrictions.canInvest(investor, amount, tokensLeft()));\r\n    }\r\n\r\n    /**@dev ICrowdsaleFormula override */\r\n    function howManyTokensForEther(uint256 weiAmount) constant returns(uint256 tokens, uint256 excess) {        \r\n        uint256 bpct = getCurrentBonusPct(weiAmount);\r\n        uint256 maxTokens = (tokensLeft() * 100) / (100 + bpct);\r\n\r\n        tokens = weiAmount * realAmountForOneEther / 1 ether;\r\n        if (tokens > maxTokens) {\r\n            tokens = maxTokens;\r\n        }\r\n\r\n        excess = weiAmount - tokens * 1 ether / realAmountForOneEther;\r\n\r\n        tokens = (tokens * 100 + tokens * bpct) / 100;\r\n    }\r\n\r\n    /**@dev Returns current bonus percent [0-100] */\r\n    function getCurrentBonusPct(uint256 investment) constant returns (uint256) {\r\n        return bonusPct;\r\n    }\r\n    \r\n    /**@dev Returns how many tokens left for sale */\r\n    function tokensLeft() constant returns(uint256) {        \r\n        return tokenPool.getTokenAmount();\r\n    }\r\n\r\n    /**@dev Returns funds that should be sent to beneficiary */\r\n    function amountToBeneficiary() constant returns (uint256) {\r\n        return weiCollected;\r\n    } \r\n\r\n    /**@dev Returns crowdsale current state */\r\n    function getState() constant returns (State) {\r\n        if (failure) {\r\n            return State.FinishedFailure;\r\n        }\r\n        \r\n        if (now < startTime) {\r\n            return State.BeforeStart;\r\n        } else if ((endTime == 0 || now < endTime) && tokensLeft() > 0) {\r\n            return State.Active;\r\n        } else if (weiCollected >= minimumGoalInWei || tokensLeft() <= 0) {\r\n            return State.FinishedSuccess;\r\n        } else {\r\n            return State.FinishedFailure;\r\n        }\r\n    }\r\n\r\n    /**@dev Allows investor to withdraw overpay */\r\n    function withdrawOverpay() {\r\n        uint amount = overpays[msg.sender];\r\n        overpays[msg.sender] = 0;        \r\n\r\n        if (amount > 0) {\r\n            if (msg.sender.send(amount)) {\r\n                OverpayRefund(msg.sender, amount);\r\n            } else {\r\n                overpays[msg.sender] = amount; //restore funds in case of failed send\r\n            }\r\n        }\r\n    }\r\n\r\n    /**@dev Transfers all collected funds to beneficiary*/\r\n    function transferToBeneficiary() {\r\n        require(getState() == State.FinishedSuccess && !withdrew);\r\n        \r\n        withdrew = true;\r\n        uint256 amount = amountToBeneficiary();\r\n\r\n        beneficiary.transfer(amount);\r\n        Refund(beneficiary, amount);\r\n    }\r\n\r\n    /**@dev Makes crowdsale failed/ok, for emergency reasons */\r\n    function makeFailed(bool state) managerOnly {\r\n        failure = state;\r\n    }\r\n\r\n    /**@dev Sets new beneficiary */\r\n    function changeBeneficiary(address newBeneficiary) managerOnly {\r\n        beneficiary = newBeneficiary;\r\n    }\r\n} /*************************************************************************\r\n * import \"./BCSCrowdsale.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Addition to token-accepting crowdsale contract. \r\n    Allows to set bonus decreasing with time. \r\n    For example, if we ant to set bonus taht decreases from +20% to +5% each week -3%,\r\n    and then stays on +%5, then constructor parameters should be:\r\n    _bonusPct = 20\r\n    _maxDecreasePct = 15\r\n    _decreaseStepPct = 3\r\n    _stepDurationDays = 7\r\n\r\n    In addition, it allows to set investment steps with different bonus. \r\n    For example, if there is following scheme:\r\n    Default bonus +20%\r\n    1-5 ETH : +1% bonus, \r\n    5-10 ETH : +2% bonus,\r\n    10-20 ETH : +3% bonus,\r\n    20+ ETH : +5% bonus, \r\n    then constructor parameters should be:\r\n    _bonusPct = 20\r\n    _investSteps = [1,5,10,20]\r\n    _bonusPctSteps = [1,2,3,5]\r\n    */ \r\ncontract BCSAddBonusCrowdsale is BCSCrowdsale {\r\n    \r\n    uint256 public decreaseStepPct;\r\n    uint256 public stepDuration;\r\n    uint256 public maxDecreasePct;\r\n    uint256[] public investSteps;\r\n    uint8[] public bonusPctSteps;\r\n    \r\n    function BCSAddBonusCrowdsale(        \r\n        ITokenPool _tokenPool,\r\n        IInvestRestrictions _restrictions,\r\n        address _beneficiary, \r\n        uint256 _startTime, \r\n        uint256 _durationInHours, \r\n        uint256 _goalInWei,\r\n        uint256 _tokensForOneEther,\r\n        uint256 _bonusPct,\r\n        uint256 _maxDecreasePct,        \r\n        uint256 _decreaseStepPct,\r\n        uint256 _stepDurationDays,\r\n        uint256[] _investSteps,\r\n        uint8[] _bonusPctSteps              \r\n        ) \r\n        BCSCrowdsale(\r\n            _tokenPool,\r\n            _restrictions,\r\n            _beneficiary, \r\n            _startTime, \r\n            _durationInHours, \r\n            _goalInWei,\r\n            _tokensForOneEther,\r\n            _bonusPct\r\n        )\r\n    {\r\n        require (_bonusPct >= maxDecreasePct);\r\n\r\n        investSteps = _investSteps;\r\n        bonusPctSteps = _bonusPctSteps;\r\n        maxDecreasePct = _maxDecreasePct;\r\n        decreaseStepPct = _decreaseStepPct;\r\n        stepDuration = _stepDurationDays * 1 days;\r\n    }\r\n\r\n    function getCurrentBonusPct(uint256 investment) public constant returns (uint256) {\r\n        \r\n        uint256 decreasePct = decreaseStepPct * (now - startTime) / stepDuration;\r\n        if (decreasePct > maxDecreasePct) {\r\n            decreasePct = maxDecreasePct;\r\n        }\r\n\r\n        uint256 first24hAddition = (now - startTime < 1 days ? 1 : 0);\r\n\r\n        for (int256 i = int256(investSteps.length) - 1; i >= 0; --i) {\r\n            if (investment >= investSteps[uint256(i)]) {\r\n                return bonusPct - decreasePct + bonusPctSteps[uint256(i)] + first24hAddition;\r\n            }\r\n        }\r\n                \r\n        return bonusPct - decreasePct + first24hAddition;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"howManyTokensForEther\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"excess\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investSteps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawOverpay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumGoalInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"returnableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensSoldTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stepDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"overpays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeReturnableToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investment\",\"type\":\"uint256\"}],\"name\":\"getCurrentBonusPct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"failure\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForOneEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amountReturned\",\"type\":\"uint256\"}],\"name\":\"returnToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferToBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"returnedTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setReturnableToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusPctSteps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restrictions\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decreaseStepPct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"makeFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountToBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"changeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrew\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDecreasePct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenPool\",\"type\":\"address\"},{\"name\":\"_restrictions\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_durationInHours\",\"type\":\"uint256\"},{\"name\":\"_goalInWei\",\"type\":\"uint256\"},{\"name\":\"_tokensForOneEther\",\"type\":\"uint256\"},{\"name\":\"_bonusPct\",\"type\":\"uint256\"},{\"name\":\"_maxDecreasePct\",\"type\":\"uint256\"},{\"name\":\"_decreaseStepPct\",\"type\":\"uint256\"},{\"name\":\"_stepDurationDays\",\"type\":\"uint256\"},{\"name\":\"_investSteps\",\"type\":\"uint256[]\"},{\"name\":\"_bonusPctSteps\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"OverpayRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"ManagerSet\",\"type\":\"event\"}]","ContractName":"BCSAddBonusCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001f85b94c55f3b9b1e178ca6742ce837edab4a8a90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b9c5f14e5e460ef926e5772783992f686fc2d3c4000000000000000000000000000000000000000000000000000000005a5c274000000000000000000000000000000000000000000000000000000000000002b800000000000000000000000000000000000000000000001043561a88293000000000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002","Library":"","SwarmSource":"bzzr://9bdd9220ebabef456e6cb8bc232e2191ed832f0fa20965ee50b4e64a1639fa47"}]}