{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/* taking ideas from Zeppelin solidity module */\r\ncontract SafeMath {\r\n\r\n    // it is recommended to define functions which can neither read the state of blockchain nor write in it as pure instead of constant\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x));\r\n        return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        assert(x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z/x == y));\r\n        return z;\r\n    }\r\n\r\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 z = x / y;\r\n        return z;\r\n    }\r\n\r\n    // mitigate short address attack\r\n    // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\r\n    // TODO: doublecheck implication of >= compared to ==\r\n    modifier onlyPayloadSize(uint numWords) {\r\n        assert(msg.data.length >= numWords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n}\r\n// The abstract token contract\r\n\r\ncontract TrakToken {\r\n    function TrakToken () public {}\r\n    function transfer (address ,uint) public pure { }\r\n    function burn (uint256) public pure { }\r\n    function finalize() public pure { }\r\n    function changeTokensWallet (address) public pure { }\r\n}\r\n\r\ncontract CrowdSale is SafeMath {\r\n\r\n    ///metadata\r\n    enum State { Fundraising,Paused,Successful,Closed }\r\n    State public state = State.Fundraising; // equal to 0\r\n    string public version = \"1.0\";\r\n\r\n    //External contracts\r\n    TrakToken public trakToken;\r\n    // who created smart contract\r\n    address public creator;\r\n    // Address which will receive raised funds\r\n    address public contractOwner;\r\n    // adreess vs state mapping (1 for exists , zero default);\r\n    mapping (address => bool) public whitelistedContributors;\r\n\r\n    uint256 public fundingStartBlock; // Dec 15 - Dec 25\r\n    uint256 public firstChangeBlock;  // December 25 - January 5\r\n    uint256 public secondChangeBlock; // January 5 -January 15\r\n    uint256 public thirdChangeBlock;  // January 16\r\n    uint256 public fundingEndBlock;   // Jan 31\r\n    // funding maximum duration in hours\r\n    uint256 public fundingDurationInHours;\r\n    uint256 constant public fundingMaximumTargetInWei = 66685 ether;\r\n    // We need to keep track of how much ether (in units of Wei) has been contributed\r\n    uint256 public totalRaisedInWei;\r\n    // maximum ether we will accept from one user\r\n    uint256 constant public maxPriceInWeiFromUser = 1500 ether;\r\n    uint256 constant public minPriceInWeiForPre = 1 ether;\r\n    uint256 constant public minPriceInWeiForIco = 0.5 ether;\r\n    uint8 constant public  decimals = 18;\r\n    // Number of tokens distributed to investors\r\n    uint public tokensDistributed = 0;\r\n    // tokens per tranche\r\n    uint constant public tokensPerTranche = 11000000 * (uint256(10) ** decimals);\r\n    uint256 public constant privateExchangeRate = 1420; // 23.8%\r\n    uint256 public constant firstExchangeRate   = 1289; // 15.25%\r\n    uint256 public constant secondExchangeRate  = 1193;  //  8.42%\r\n    uint256 public constant thirdExchangeRate   = 1142;  //  4.31%\r\n    uint256 public constant fourthExchangeRate  = 1118;  //  2.25%\r\n    uint256 public constant fifthExchangeRate   = 1105;  // 1.09%\r\n\r\n    /// modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == contractOwner);\r\n        _;\r\n    }\r\n\r\n    modifier isIcoOpen() {\r\n        require(block.number >= fundingStartBlock);\r\n        require(block.number <= fundingEndBlock);\r\n        require(totalRaisedInWei <= fundingMaximumTargetInWei);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier isMinimumPrice() {\r\n        if (tokensDistributed < safeMult(3,tokensPerTranche) || block.number < thirdChangeBlock ) {\r\n           require(msg.value >= minPriceInWeiForPre);\r\n        }\r\n        else if (tokensDistributed <= safeMult(6,tokensPerTranche)) {\r\n           require(msg.value >= minPriceInWeiForIco);\r\n        }\r\n\r\n        require(msg.value <= maxPriceInWeiFromUser);\r\n\r\n         _;\r\n    }\r\n\r\n    modifier isIcoFinished() {\r\n        require(totalRaisedInWei >= fundingMaximumTargetInWei || (block.number > fundingEndBlock) || state == State.Successful );\r\n        _;\r\n    }\r\n\r\n    modifier inState(State _state) {\r\n        require(state == _state);\r\n        _;\r\n    }\r\n\r\n    modifier isCreator() {\r\n        require(msg.sender == creator);\r\n        _;\r\n    }\r\n\r\n    // wait 100 block after final contract state before allowing contract destruction\r\n    modifier atEndOfLifecycle() {\r\n        require(totalRaisedInWei >= fundingMaximumTargetInWei || (block.number > fundingEndBlock + 40000));\r\n        _;\r\n    }\r\n\r\n    /// constructor\r\n    function CrowdSale(\r\n    address _fundsWallet,\r\n    uint256 _fundingStartBlock,\r\n    uint256 _firstInHours,\r\n    uint256 _secondInHours,\r\n    uint256 _thirdInHours,\r\n    uint256 _fundingDurationInHours,\r\n    TrakToken _tokenAddress\r\n    ) public {\r\n\r\n        require(safeAdd(_fundingStartBlock, safeMult(_fundingDurationInHours , 212)) > _fundingStartBlock);\r\n\r\n        creator = msg.sender;\r\n\r\n        if (_fundsWallet !=0) {\r\n            contractOwner = _fundsWallet;\r\n        }\r\n        else {\r\n            contractOwner = msg.sender;\r\n        }\r\n\r\n        fundingStartBlock = _fundingStartBlock;\r\n        firstChangeBlock =  safeAdd(fundingStartBlock, safeMult(_firstInHours , 212));\r\n        secondChangeBlock = safeAdd(fundingStartBlock, safeMult(_secondInHours , 212));\r\n        thirdChangeBlock =  safeAdd(fundingStartBlock, safeMult(_thirdInHours , 212));\r\n        fundingDurationInHours = _fundingDurationInHours;\r\n        fundingEndBlock = safeAdd(fundingStartBlock, safeMult(_fundingDurationInHours , 212));\r\n        trakToken = TrakToken(_tokenAddress);\r\n    }\r\n\r\n\r\n    // fallback function can be used to buy tokens\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n\r\n    function buyTokens(address beneficiary) inState(State.Fundraising) isIcoOpen isMinimumPrice  public  payable  {\r\n        require(beneficiary != 0x0);\r\n        // state 1 is set for\r\n        require(whitelistedContributors[beneficiary] == true );\r\n        uint256 tokenAmount;\r\n        uint256 checkedReceivedWei = safeAdd(totalRaisedInWei, msg.value);\r\n        // Check that this transaction wouldn't exceed the ETH max cap\r\n\r\n        if (checkedReceivedWei > fundingMaximumTargetInWei ) {\r\n\r\n            // update totalRaised After Subtracting\r\n            totalRaisedInWei = safeAdd(totalRaisedInWei,safeSubtract(fundingMaximumTargetInWei,totalRaisedInWei));\r\n            // Calculate how many tokens (in units of Wei) should be awarded on this transaction\r\n            var (rate,/*trancheMaxTokensLeft */) = getCurrentTokenPrice();\r\n            // Calculate how many tokens (in units of Wei) should be awarded on this transaction\r\n            tokenAmount = safeMult(safeSubtract(fundingMaximumTargetInWei,totalRaisedInWei), rate);\r\n            // Send change extra ether to user.\r\n            beneficiary.transfer(safeSubtract(checkedReceivedWei,fundingMaximumTargetInWei));\r\n        }\r\n        else {\r\n            totalRaisedInWei = safeAdd(totalRaisedInWei,msg.value);\r\n            var (currentRate,trancheMaxTokensLeft) = getCurrentTokenPrice();\r\n            // Calculate how many tokens (in units of Wei) should be awarded on this transaction\r\n            tokenAmount = safeMult(msg.value, currentRate);\r\n            if (tokenAmount > trancheMaxTokensLeft) {\r\n                // handle round off error by adding .1 token\r\n                tokensDistributed =  safeAdd(tokensDistributed,safeAdd(trancheMaxTokensLeft,safeDiv(1,10)));\r\n                //find remaining tokens by getCurrentTokenPrice() function and sell them from remaining ethers left\r\n                var (nextCurrentRate,nextTrancheMaxTokensLeft) = getCurrentTokenPrice();\r\n\r\n                if (nextTrancheMaxTokensLeft <= 0) {\r\n                    tokenAmount = safeAdd(trancheMaxTokensLeft,safeDiv(1,10));\r\n                    state =  State.Successful;\r\n                    // Send change extra ether to user.\r\n                    beneficiary.transfer(safeDiv(safeSubtract(tokenAmount,trancheMaxTokensLeft),currentRate));\r\n                } else {\r\n                    uint256 nextTokenAmount = safeMult(safeSubtract(msg.value,safeMult(trancheMaxTokensLeft,safeDiv(1,currentRate))),nextCurrentRate);\r\n                    tokensDistributed =  safeAdd(tokensDistributed,nextTokenAmount);\r\n                    tokenAmount = safeAdd(nextTokenAmount,safeAdd(trancheMaxTokensLeft,safeDiv(1,10)));\r\n                }\r\n            }\r\n            else {\r\n                tokensDistributed =  safeAdd(tokensDistributed,tokenAmount);\r\n            }\r\n        }\r\n\r\n        trakToken.transfer(beneficiary,tokenAmount);\r\n        // immediately transfer ether to fundsWallet\r\n        forwardFunds();\r\n    }\r\n\r\n    function forwardFunds() internal {\r\n        contractOwner.transfer(msg.value);\r\n    }\r\n\r\n    /// @dev Returns the current token rate , minimum ether needed and maximum tokens left in currenttranche\r\n    function getCurrentTokenPrice() private constant returns (uint256 currentRate, uint256 maximumTokensLeft) {\r\n\r\n        if (tokensDistributed < safeMult(1,tokensPerTranche) && (block.number < firstChangeBlock)) {\r\n            //  return ( privateExchangeRate, minPriceInWeiForPre, safeSubtract(tokensPerTranche,tokensDistributed) );\r\n            return ( privateExchangeRate, safeSubtract(tokensPerTranche,tokensDistributed) );\r\n        }\r\n        else if (tokensDistributed < safeMult(2,tokensPerTranche) && (block.number < secondChangeBlock)) {\r\n            return ( firstExchangeRate, safeSubtract(safeMult(2,tokensPerTranche),tokensDistributed) );\r\n        }\r\n        else if (tokensDistributed < safeMult(3,tokensPerTranche) && (block.number < thirdChangeBlock)) {\r\n            return ( secondExchangeRate, safeSubtract(safeMult(3,tokensPerTranche),tokensDistributed) );\r\n        }\r\n        else if (tokensDistributed < safeMult(4,tokensPerTranche) && (block.number < fundingEndBlock)) {\r\n            return  (thirdExchangeRate,safeSubtract(safeMult(4,tokensPerTranche),tokensDistributed)  );\r\n        }\r\n        else if (tokensDistributed < safeMult(5,tokensPerTranche) && (block.number < fundingEndBlock)) {\r\n            return  (fourthExchangeRate,safeSubtract(safeMult(5,tokensPerTranche),tokensDistributed)  );\r\n        }\r\n        else if (tokensDistributed <= safeMult(6,tokensPerTranche)) {\r\n            return  (fifthExchangeRate,safeSubtract(safeMult(6,tokensPerTranche),tokensDistributed)  );\r\n        }\r\n    }\r\n\r\n\r\n    function authorizeKyc(address[] addrs) external onlyOwner returns (bool success) {\r\n\r\n        //@TODO  maximum batch size for uploading\r\n        // @TODO amount of gas for a block of code - and will fail if that is exceeded\r\n        uint arrayLength = addrs.length;\r\n\r\n        for (uint x = 0; x < arrayLength; x++) {\r\n            whitelistedContributors[addrs[x]] = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function withdrawWei () external onlyOwner {\r\n        // send the eth to the project multisig wallet\r\n        contractOwner.transfer(this.balance);\r\n    }\r\n\r\n    function updateFundingEndBlock(uint256 newFundingEndBlock)  external onlyOwner {\r\n        require(newFundingEndBlock > fundingStartBlock);\r\n        //require(newFundingEndBlock >= fundingEndBlock);\r\n        fundingEndBlock = newFundingEndBlock;\r\n    }\r\n\r\n\r\n    // after ICO only owner can call this\r\n    function burnRemainingToken(uint256 _value) external  onlyOwner isIcoFinished {\r\n        //@TODO - check balance of address if no value passed\r\n        require(_value > 0);\r\n        trakToken.burn(_value);\r\n    }\r\n\r\n    // after ICO only owner can call this\r\n    function withdrawRemainingToken(uint256 _value,address trakTokenAdmin)  external onlyOwner isIcoFinished {\r\n        //@TODO - check balance of address if no value passed\r\n        require(trakTokenAdmin != 0x0);\r\n        require(_value > 0);\r\n        trakToken.transfer(trakTokenAdmin,_value);\r\n    }\r\n\r\n\r\n    // after ICO only owner can call this\r\n    function finalize() external  onlyOwner isIcoFinished  {\r\n        state =  State.Closed;\r\n        trakToken.finalize();\r\n    }\r\n\r\n    // after ICO only owner can call this\r\n    function changeTokensWallet(address newAddress) external  onlyOwner  {\r\n        require(newAddress != address(0));\r\n        trakToken.changeTokensWallet(newAddress);\r\n    }\r\n\r\n\r\n    function removeContract ()  external onlyOwner atEndOfLifecycle {\r\n        // msg.sender will receive all the ethers if this contract has ethers\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    /// @param newAddress Address of new owner.\r\n    function changeFundsWallet(address newAddress) external onlyOwner returns (bool)\r\n    {\r\n        require(newAddress != address(0));\r\n        contractOwner = newAddress;\r\n    }\r\n\r\n\r\n    /// @dev Pauses the contract\r\n    function pause() external onlyOwner inState(State.Fundraising) {\r\n        // Move the contract to Paused state\r\n        state =  State.Paused;\r\n    }\r\n\r\n\r\n    /// @dev Resume the contract\r\n    function resume() external onlyOwner {\r\n        // Move the contract out of the Paused state\r\n        state =  State.Fundraising;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdChangeBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPriceInWeiForIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"trakTokenAdmin\",\"type\":\"address\"}],\"name\":\"withdrawRemainingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trakToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondChangeBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPriceInWeiForPre\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeTokensWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"authorizeKyc\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeFundsWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnRemainingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fourthExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingDurationInHours\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingMaximumTargetInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstChangeBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPriceInWeiFromUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedContributors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fifthExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerTranche\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFundingEndBlock\",\"type\":\"uint256\"}],\"name\":\"updateFundingEndBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaisedInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fundsWallet\",\"type\":\"address\"},{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_firstInHours\",\"type\":\"uint256\"},{\"name\":\"_secondInHours\",\"type\":\"uint256\"},{\"name\":\"_thirdInHours\",\"type\":\"uint256\"},{\"name\":\"_fundingDurationInHours\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"CrowdSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000054011a0d6252f50790acaf4340d9e46737ca0ab9000000000000000000000000000000000000000000000000000000000048527600000000000000000000000000000000000000000000000000000000000001a900000000000000000000000000000000000000000000000000000000000002c400000000000000000000000000000000000000000000000000000000000003e0000000000000000000000000000000000000000000000000000000000000054800000000000000000000000012759512d326303b45f1cec8f7b6fd96f387778e","Library":"","SwarmSource":"bzzr://5a8d347f2d3a48e298ffd43fefaa39803672cc26d7093b78a4cc1fbe24bde55f"}]}