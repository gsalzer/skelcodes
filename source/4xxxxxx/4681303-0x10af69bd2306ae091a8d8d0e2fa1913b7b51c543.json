{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() public { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController public {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n\r\n/// `Owned` is a base level contract that assigns an `owner` that can be later changed\r\ncontract Owned {\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner { require (msg.sender == owner); _; }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() { owner = msg.sender;}\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner)  onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n  function balanceOf(address who) constant public returns (uint);\r\n  function allowance(address owner, address spender) constant public returns (uint);\r\n\r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n  function approve(address spender, uint value) public returns (bool ok);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n}\r\n\r\n\r\ncontract ControlledToken is ERC20, Controlled {\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n    uint256 public totalSupply;\r\n\r\n    function ControlledToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(msg.sender, _to, _value));\r\n        }\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        // Alerts the token controller of the transfer\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onTransfer(_from, _to, _value));\r\n        }\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _value));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    ////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount ) onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply;\r\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        totalSupply = curTotalSupply + _amount;\r\n        balances[_owner]  = previousBalanceTo + _amount;\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply;\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        totalSupply = curTotalSupply - _amount;\r\n        balances[_owner] = previousBalanceFrom - _amount;\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice The fallback function: If the contract's controller has not been\r\n    ///  set to 0, then the `proxyPayment` method is called which relays the\r\n    ///  ether and creates tokens as described in the token controller contract\r\n    function ()  payable {\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ControlledToken token = ControlledToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n}\r\n\r\n// Controller for Token interface\r\n// Taken from https://github.com/Giveth/minime/blob/master/contracts/MiniMeToken.sol\r\n\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable public returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public\r\n        returns(bool);\r\n}\r\n\r\n\r\n\r\n\r\ncontract TokenSale is TokenController, Owned, SafeMath {\r\n\r\n\r\n    uint public startFundingTime;           // In UNIX Time Format\r\n    uint public endFundingTime;             // In UNIX Time Format\r\n\r\n    uint public tokenCap;                   // Maximum amount of tokens to be distributed\r\n    uint public totalTokenCount;            // Actual amount of tokens distributed\r\n\r\n    uint public totalCollected;             // In wei\r\n    ControlledToken public tokenContract;   // The new token for this TokenSale\r\n    address public vaultAddress;            // The address to hold the funds donated\r\n    bool public transfersAllowed;           // If the token transfers are allowed\r\n    uint256 public exchangeRate;            // USD/ETH rate * 100\r\n    uint public exchangeRateAt;             // Block number when exchange rate was set\r\n\r\n    /// @notice 'TokenSale()' initiates the TokenSale by setting its funding\r\n    /// parameters\r\n    /// @dev There are several checks to make sure the parameters are acceptable\r\n    /// @param _startFundingTime The UNIX time that the TokenSale will be able to\r\n    /// start receiving funds\r\n    /// @param _endFundingTime The UNIX time that the TokenSale will stop being able\r\n    /// to receive funds\r\n    /// @param _tokenCap Maximum amount of tokens to be sold\r\n    /// @param _vaultAddress The address that will store the donated funds\r\n    /// @param _tokenAddress Address of the token contract this contract controls\r\n    /// @param _transfersAllowed if token transfers are allowed\r\n    /// @param _exchangeRate USD/ETH rate * 100\r\n    function TokenSale (\r\n        uint _startFundingTime,\r\n        uint _endFundingTime,\r\n        uint _tokenCap,\r\n        address _vaultAddress,\r\n        address _tokenAddress,\r\n        bool _transfersAllowed,\r\n        uint256 _exchangeRate\r\n    ) public {\r\n        require ((_endFundingTime >= now) &&           // Cannot end in the past\r\n            (_endFundingTime > _startFundingTime) &&\r\n            (_vaultAddress != 0));                    // To prevent burning ETH\r\n        startFundingTime = _startFundingTime;\r\n        endFundingTime = _endFundingTime;\r\n        tokenCap = _tokenCap;\r\n        tokenContract = ControlledToken(_tokenAddress);// The Deployed Token Contract\r\n        vaultAddress = _vaultAddress;\r\n        transfersAllowed = _transfersAllowed;\r\n        exchangeRate = _exchangeRate;\r\n        exchangeRateAt = block.number;\r\n    }\r\n\r\n    /// @dev The fallback function is called when ether is sent to the contract, it\r\n    /// simply calls `doPayment()` with the address that sent the ether as the\r\n    /// `_owner`. Payable is a required solidity modifier for functions to receive\r\n    /// ether, without this modifier functions will throw if ether is sent to them\r\n    function ()  payable public {\r\n        doPayment(msg.sender);\r\n    }\r\n\r\n\r\n    /// @dev `doPayment()` is an internal function that sends the ether that this\r\n    ///  contract receives to the `vault` and creates tokens in the address of the\r\n    ///  `_owner` assuming the TokenSale is still accepting funds\r\n    /// @param _owner The address that will hold the newly created tokens\r\n\r\n    function doPayment(address _owner) internal {\r\n\r\n        // First check that the TokenSale is allowed to receive this donation\r\n        require ((now >= startFundingTime) &&\r\n            (now <= endFundingTime) &&\r\n            (tokenContract.controller() != 0) &&\r\n            (msg.value != 0) );\r\n\r\n        uint256 tokensAmount = mul(msg.value, exchangeRate) / 100;\r\n\r\n        require( totalTokenCount + tokensAmount <= tokenCap );\r\n\r\n        //Track how much the TokenSale has collected\r\n        totalCollected += msg.value;\r\n\r\n        //Send the ether to the vault\r\n        require (vaultAddress.call.gas(28000).value(msg.value)());\r\n\r\n        // Creates an  amount of tokens base on ether sent and exchange rate. The new tokens are created\r\n        //  in the `_owner` address\r\n        require (tokenContract.generateTokens(_owner, tokensAmount));\r\n\r\n        totalTokenCount += tokensAmount;\r\n\r\n        return;\r\n    }\r\n\r\n    function distributeTokens(address[] _owners, uint256[] _tokens) onlyOwner public {\r\n\r\n        require( _owners.length == _tokens.length );\r\n        for(uint i=0;i<_owners.length;i++){\r\n            require (tokenContract.generateTokens(_owners[i], _tokens[i]));\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /// @notice `onlyOwner` changes the location that ether is sent\r\n    /// @param _newVaultAddress The address that will receive the ether sent to this token sale\r\n    function setVault(address _newVaultAddress) onlyOwner public{\r\n        vaultAddress = _newVaultAddress;\r\n    }\r\n\r\n    /// @notice `onlyOwner` changes the setting to allow transfer tokens\r\n    /// @param _allow  allowing to transfer tokens\r\n    function setTransfersAllowed(bool _allow) onlyOwner public{\r\n        transfersAllowed = _allow;\r\n    }\r\n\r\n    /// @notice `onlyOwner` changes the exchange rate of token to ETH\r\n    /// @param _exchangeRate USD/ETH rate * 100\r\n    function setExchangeRate(uint256 _exchangeRate) onlyOwner public{\r\n        exchangeRate = _exchangeRate;\r\n        exchangeRateAt = block.number;\r\n    }\r\n\r\n    /// @notice `onlyOwner` changes the controller of the tokenContract\r\n    /// @param _newController - controller to be used with token\r\n    function changeController(address _newController) onlyOwner public {\r\n        tokenContract.changeController(_newController);\r\n    }\r\n\r\n    /////////////////\r\n    // TokenController interface\r\n    /////////////////\r\n\r\n    /// @notice `proxyPayment()` allows the caller to send ether to the TokenSale and\r\n    /// have the tokens created in an address of their choosing\r\n    /// @param _owner The address that will hold the newly created tokens\r\n\r\n    function proxyPayment(address _owner) payable public returns(bool) {\r\n        doPayment(_owner);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    /// @notice Notifies the controller about a transfer, for this TokenSale all\r\n    ///  transfers are allowed by default and no extra notifications are needed\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool) {\r\n        return transfersAllowed;\r\n    }\r\n\r\n    /// @notice Notifies the controller about an approval, for this TokenSale all\r\n    ///  approvals are allowed by default and no extra notifications are needed\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public\r\n        returns(bool)\r\n    {\r\n        return transfersAllowed;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"}],\"name\":\"distributeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVaultAddress\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRateAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startFundingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endFundingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setTransfersAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"proxyPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startFundingTime\",\"type\":\"uint256\"},{\"name\":\"_endFundingTime\",\"type\":\"uint256\"},{\"name\":\"_tokenCap\",\"type\":\"uint256\"},{\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_transfersAllowed\",\"type\":\"bool\"},{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"TokenSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a1df880000000000000000000000000000000000000000000000000000000005a494fcf00000000000000000000000000000000000000000014adf4b7320334b9000000000000000000000000000000f4702b0918a8a89dfc38459ce42198834818f26b0000000000000000000000002ad180cbaffbc97237f572148fc1b283b68d886100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009c40","Library":"","SwarmSource":"bzzr://0686e9eaf868fb4a490070229161819cfff20c6b1eb6dfbdb10647474c832b0c"}]}