{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\ncontract Dextera {\r\n\t/*\r\n\t\tStatics\r\n\t*/\r\n\r\n\t// Creator account\r\n\taddress public creator = msg.sender;\r\n\r\n\t// Sellers account\r\n\taddress public seller;\r\n\r\n\t// One ticket price in wei\r\n\tuint256 public ticketPrice;\r\n\r\n\t// Minimum number of tickets for successful completion\r\n\tuint256 public minimumTickets;\r\n\r\n\t// Creator fee percent\r\n\tuint256 public creatorFeePercent;\r\n\r\n\t// Datetime of contract end\r\n\tuint256 public saleEndTime;\r\n\r\n\t/*\r\n\t\tMutables\r\n\t*/\r\n\r\n\t// Datetime of successful processing\r\n\tuint256 public successfulTime;\r\n\r\n\t// Buyers\r\n\tstruct Buyer {\r\n\t\taddress ethAddress;\r\n\t\tuint256 atTicket;\r\n\t\tuint256 amountPaid;\r\n\t}\r\n\tmapping(uint256 => Buyer) public buyers;\r\n\r\n\t// Total buyers counter\r\n\tuint256 public totalBuyers = 0;\r\n\r\n\t// Total tickets counter\r\n\tuint256 public totalTickets = 0;\r\n\r\n\t// Buyer index for funds return\r\n\tuint256 public returnLastBuyerIndex = 0;\r\n\r\n\t// Winner, buyers mapping key (statring from 0)\r\n\tuint256 public winnerKey = 0;\r\n\r\n\t// Winner ticket number (starting from 1)\r\n\tuint256 public winnerTicket = 0;\r\n\r\n\t// Sale states\r\n\tenum States { Started, NoEntry, Failed, Succeeded }\r\n\tStates public saleState = States.Started;\r\n\r\n\t/*\r\n\t\tConstructor\r\n\t*/\r\n\r\n\t// Saving the contract statics\r\n\tfunction Dextera(address _seller, uint256 _ticketPrice, uint256 _minimumTickets, uint256 _creatorFeePercent, uint256 _saleDays) public {\r\n\t\t// Saving the sellers address\r\n\t\tseller = _seller;\r\n\r\n\t\t// Set the 1 ticket price\r\n\t\tticketPrice = _ticketPrice;\r\n\r\n\t\t// Set minimum tickets for a successful sale\r\n\t\tminimumTickets = _minimumTickets;\r\n\r\n\t\t// Set the creator fee\r\n\t\tcreatorFeePercent = _creatorFeePercent;\r\n\r\n\t\t// Set the sale end datetime\r\n \t\tsaleEndTime = now + _saleDays * 1 days;\r\n  }\r\n\r\n\t/*\r\n\t\tModifiers\r\n\t*/\r\n\r\n\t// Only creator\r\n\tmodifier onlyCreator() {\r\n\t\trequire(msg.sender == creator);\r\n\t\t_;\r\n\t}\r\n\r\n\t// State checker\r\n\tmodifier inState(States _state) {\r\n\t\trequire(saleState == _state);\r\n\t\t_;\r\n\t}\r\n\r\n\t/*\r\n\t\tParticipation\r\n\t*/\r\n\r\n\t// Fallback function (simple funds transfer)\r\n\tfunction() public payable {\r\n\t\t// Buy a ticket, only if the sell is running\r\n\t\tif (saleState == States.Started) {\r\n\t\t\t// Is the amount enough?\r\n\t\t\trequire(msg.value >= ticketPrice);\r\n\r\n\t\t\t// How many tickets we can buy?\r\n\t\t\tuint256 _ticketsBought = 1;\r\n\t\t\tif (msg.value > ticketPrice) {\r\n\t\t\t\t_ticketsBought = msg.value / ticketPrice;\r\n\t\t\t}\r\n\r\n\t\t\t// Do we have enough tickets for this sale?\r\n\t\t\trequire(minimumTickets - totalTickets >= _ticketsBought);\r\n\r\n\t\t\t// Increment the quantity of tickets sold\r\n\t\t\ttotalTickets = totalTickets + _ticketsBought;\r\n\r\n\t\t\t// Save the buyer\r\n\t\t\tbuyers[totalBuyers] = Buyer(msg.sender, totalTickets, msg.value);\r\n\r\n\t\t\t// Save the new buyers counter\r\n\t\t\ttotalBuyers = totalBuyers + 1;\r\n\r\n\t\t\t// We sold all the tickets?\r\n\t\t\tif (totalTickets >= minimumTickets) {\r\n\t\t\t\tfinalSuccess();\r\n\t\t\t}\r\n\r\n\t\t// Protection, unblock funds by the winner, only after sell was closed\r\n\t\t} else if (saleState == States.NoEntry) {\r\n\t\t\t// Only winner\r\n\t\t\trequire(msg.sender == buyers[winnerKey].ethAddress);\r\n\r\n\t\t\t// Check if there is enough balance\r\n\t\t\trequire(this.balance > 0);\r\n\r\n\t\t\t// Amount should be zero\r\n\t\t\trequire(msg.value == 0);\r\n\r\n\t\t\t// Setting the state of the sale\r\n\t\t\tsaleState = States.Succeeded;\r\n\r\n\t\t\t// Send fee percent amount to us\r\n\t\t\tuint256 _creatorFee = (this.balance * creatorFeePercent / 100);\r\n\t\t\tcreator.send(_creatorFee);\r\n\r\n\t\t\t// Another amount to the seller\r\n\t\t\tseller.send(this.balance);\r\n\r\n\t\t// Not allowed to send call\r\n\t\t} else {\r\n\t\t\trequire(false);\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t\tCompletion\r\n\t*/\r\n\r\n\t// Not enough tickets sold within timeframe, the sale failed\r\n\tfunction saleFinalize() public inState(States.Started) {\r\n\t\t// Is it the time?\r\n\t\trequire(now >= saleEndTime);\r\n\r\n\t\t// Set new sale state\r\n\t\tsaleState = States.Failed;\r\n\r\n\t\t// Return all the funds to the buyers\r\n\t\treturnToBuyers();\r\n\t}\r\n\r\n\t// Complete, success\r\n\tfunction finalSuccess() private {\r\n\t\t// Set the datetime of a successful processing\r\n\t\tsuccessfulTime = now;\r\n\r\n\t\t// Set new sale state\r\n\t\tsaleState = States.NoEntry;\r\n\r\n\t\t// Select the winning ticket number\r\n\t\twinnerTicket = getRand(totalTickets) + 1;\r\n\r\n\t\t// Get the winner address\r\n\t\twinnerKey = getWinnerKey();\r\n\t}\r\n\r\n\t/*\r\n\t\tSale protection\r\n\t*/\r\n\r\n\t// Protection, return funds after the timeout if the winner did not unblocked the funds\r\n\tfunction revertFunds() public inState(States.NoEntry) {\r\n\t\t// Is it the time?\r\n\t\trequire(now >= successfulTime + 30 * 1 days);\r\n\r\n\t\t// Setting the state of the sale\r\n\t\tsaleState = States.Failed;\r\n\r\n\t\t// Return all the funds to the buyers\r\n\t\treturnToBuyers();\r\n\t}\r\n\r\n\t// Continue to return funds in case the process was interrupted\r\n\tfunction returnToBuyersContinue() public inState(States.Failed) {\r\n\t\t// We didn't finished the refund yet\r\n\t\trequire(returnLastBuyerIndex < totalBuyers);\r\n\r\n\t\t// Start the return process\r\n\t\treturnToBuyers();\r\n\t}\r\n\r\n\t/*\r\n\t\tSystem\r\n\t*/\r\n\r\n\t// In case of emergeny, pull the lever\r\n\tfunction pullTheLever() public onlyCreator {\r\n\t\t// Destruct the contract\r\n\t\tselfdestruct(creator);\r\n\t}\r\n\r\n\t// Pseudo random function, from 0 to _max (exclusive)\r\n\tfunction getRand(uint256 _max) private view returns(uint256) {\r\n\t\treturn (uint256(keccak256(block.difficulty, block.coinbase, now, block.blockhash(block.number - 1))) % _max);\r\n\t}\r\n\r\n\t// Get winner account\r\n\tfunction getWinnerAccount() public view returns(address) {\r\n\t\t// There should be a winner ticket selected\r\n\t\trequire(winnerTicket > 0);\r\n\r\n\t\t// Return the winners address\r\n\t\treturn buyers[winnerKey].ethAddress;\r\n\t}\r\n\r\n\t// Return all the funds to the buyers\r\n\tfunction returnToBuyers() private {\r\n\t\t// Check if there is enough balance\r\n\t\tif (this.balance > 0) {\r\n\t\t\t// Sending funds back (with a gas limiter check)\r\n\t\t\tuint256 _i = returnLastBuyerIndex;\r\n\r\n\t\t\twhile (_i < totalBuyers && msg.gas > 200000) {\r\n\t\t\t\tbuyers[_i].ethAddress.send(buyers[_i].amountPaid);\r\n\t\t\t\t_i++;\r\n\t\t\t}\r\n\t\t\treturnLastBuyerIndex = _i;\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the winner key for a winner ticket\r\n\tfunction getWinnerKey() private view returns(uint256) {\r\n\t\t// Reset the variables\r\n\t\tuint256 _i = 0;\r\n\t\tuint256 _j = totalBuyers - 1;\r\n\t\tuint256 _n = 0;\r\n\r\n\t\t// Let's search who bought this ticket\r\n\t\tdo {\r\n\t\t\t// Buyer found in a lower limiter\r\n\t\t\tif (buyers[_i].atTicket >= winnerTicket) {\r\n\t\t\t\treturn _i;\r\n\r\n\t\t\t// Buyer found in a higher limiter\r\n\t\t\t} else if (buyers[_j].atTicket <= winnerTicket) {\r\n\t\t\t\treturn _j;\r\n\r\n\t\t\t// Only two elements left, get the biggest\r\n\t\t\t} else if ((_j - _i + 1) == 2) {\r\n\t\t\t\treturn _j;\r\n\t\t\t}\r\n\r\n\t\t\t// Split the mapping into halves\r\n\t\t\t_n = ((_j - _i) / 2) + _i;\r\n\r\n\t\t\t// The ticket is in the right part\r\n\t\t\tif (buyers[_n].atTicket <= winnerTicket) {\r\n\t\t\t\t_i = _n;\r\n\r\n\t\t\t// The ticket is in the left part\r\n\t\t\t} else {\r\n\t\t\t\t_j = _n;\r\n\t\t\t}\r\n\r\n\t\t} while(true);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pullTheLever\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBuyers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinnerAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creatorFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"saleFinalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnLastBuyerIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"returnToBuyersContinue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnerTicket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"revertFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnerKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buyers\",\"outputs\":[{\"name\":\"ethAddress\",\"type\":\"address\"},{\"name\":\"atTicket\",\"type\":\"uint256\"},{\"name\":\"amountPaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"successfulTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"name\":\"_minimumTickets\",\"type\":\"uint256\"},{\"name\":\"_creatorFeePercent\",\"type\":\"uint256\"},{\"name\":\"_saleDays\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Dextera","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000028296cc4c90af33f694492ba0e20dd4cefff6700000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000002","Library":"","SwarmSource":"bzzr://b3066a54c11914b0280ee699a266faa3985ec5663d585342f66d364dc782cc4f"}]}