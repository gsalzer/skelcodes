{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n/*\r\n\\/\\/\\/\\/\\/\\/\\/\\WELCOME TO BIG 2018 TOKEN/\\/\\/\\/\\/\\/\\/\\/\r\nThis token is the first stage in a revolutionary new \r\ndistributed game where the odds are forever in your \r\nfavour yet similar to poker where chip leads give you\r\nthe edge; BIG2018TOKEN will play a similar role.\r\n\r\n\r\n\\/\\/\\/\\/\\/\\/\\/\\/THE PRICE CAN ONLY GO UP\\/\\/\\/\\/\\/\\/\\/\\/\r\nThis smart contract will only allow a limited number of \r\ntokens to be bought each day. Once they are gone, you \r\nwill have to wait for the next days release, yet the \r\nprice will go up each day. This is set so the price will\r\nrise 2.7%/DAY (the best I can get from my bank each yr)\r\nor x2.25 each month. Rounded this gives:\r\n    Day001 = 0.00010 Eth\r\n    Day050 = 0.00037 Eth\r\n    Day100 = 0.00138 Eth\r\n    Day150 = 0.00528 Eth\r\n    Day200 = 0.02003 Eth\r\n    Day250 = 0.07633 Eth\r\n    Day300 = 0.28959 Eth\r\n    Day350 = 1.10048 Eth\r\n    Day365 = 1.64232 Eth\r\n    Day366(2019) no longer available :(\r\n \r\n This price increase will be to benifit the super early\r\n birds who work closley with Ethereum and likely to find\r\n this smart contract hidden away and able to call it \r\n directly before word spreads to the wider masses and a\r\n UI and promotion gets involved later in the year.\r\n*/\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\r\n\r\ncontract Big2018Token {\r\n    ////////////////////////////////////////////////////////\r\n    //Intitial Parameters\r\n    /**********Admin**********/\r\n    address public creator;  //keep track of creator\r\n    /**********DailyRelease**********/\r\n    uint256 public tokensDaily = 10000; //max tokens available each day\r\n    uint256 tokensToday = 0; //no tokens given out today\r\n    uint256 public leftToday = 10000; //tokens left to sell today\r\n    uint startPrice = 100000000000000; //COMPOUND INCREASE: Wei starter price that will be compounded\r\n    uint q = 37; //COMPOUND INCREASE: for (1+1/q) multipler rate of 1.027 per day\r\n    uint countBuy = 0; //count times bought\r\n    uint start2018 = 1514764800; //when tokens become available \r\n    uint end2018 = 1546300799; //last second tokens available\r\n    uint day = 1; //what day is it\r\n    uint d = 86400; //sedonds in a day\r\n    uint dayOld = 1; //counter to kep track of last day tokens were given\r\n    /**********GameUsage**********/\r\n    address public game;  //address of Game later in year\r\n    mapping (address => uint) public box; //record each persons box choice\r\n    uint boxRand = 0; //To start with random assignment of box used later in year, ignore use for token\r\n    uint boxMax = 5; //Max random random assignment to box used later in year, ignore use for token\r\n    event BoxChange(address who, uint newBox); //event that notifies of a box change in game\r\n    /**********ERC20**********/\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n    mapping (address => uint256) public balanceOf; //record who owns what\r\n    event Transfer(address indexed from, address indexed to, uint256 value);// This generates a public event on the blockchain that will notify clients\r\n    event Burn(address indexed from, uint256 value); // This notifies clients about the amount burnt\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    /**********EscrowTrades**********/\r\n    struct EscrowTrade {\r\n        uint256 value; //value of number or tokens for sale\r\n        uint price; //min purchase price from seller\r\n        address to; //specify who is to purchase the tokens\r\n        bool open; //anyone can purchase rather than named buyer. false = closed. true = open to all.\r\n    }\r\n    mapping (address => mapping (uint => EscrowTrade)) public escrowTransferInfo;\r\n    mapping (address => uint) userEscrowCount;\r\n    event Escrow(address from, uint256 value, uint price, bool open, address to); // This notifies clients about the escrow\r\n    struct EscrowTfr {\r\n        address from; //who has defined this escrow trade\r\n        uint tradeNo; //trade number this user has made\r\n    }\r\n    EscrowTfr[] public escrowTransferList; //make an array of the escrow trades to be looked up\r\n    uint public escrowCount = 0;\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Run at start\r\n    function Big2018Token() public {\r\n        creator = msg.sender; //store sender as creator\r\n        game = msg.sender; //to be updated once game released with game address\r\n        totalSupply = 3650000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n        balanceOf[this] = totalSupply;     // Give the creator all initial tokens\r\n        name = \"BIG2018TOKEN\";                // Set the name for display purposes\r\n        symbol = \"B18\";                       // Set the symbol for display purposes\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //The Price of the Token Each Day. 0 = today\r\n    function getPriceWei(uint _day) public returns (uint) {\r\n        require(now >= start2018 && now <= end2018); //must be in 2018\r\n        day = (now - start2018)/d + 1; //count number of days since opening\r\n        if (day > dayOld) {  //resent counter if first tx per day\r\n            uint256 _value = ((day - dayOld - 1)*tokensDaily + leftToday) * 10 ** uint256(decimals);\r\n            _transfer(this, creator, _value); //give remaining tokens from previous day to creator\r\n            tokensToday = 0; //reset no of tokens sold today, this wont stick as 'veiw' f(x). will be saved in buy f(x)\r\n            dayOld = day; //reset dayOld counter\r\n        }\r\n        if (_day != 0) { //if _day = 0, calculate price for today\r\n        day = _day; //which day should be calculated\r\n        }\r\n        // Computes 'startPrice * (1+1/q) ^ n' with precision p, needed as solidity does not allow decimal for compounding\r\n            //q & startPrice defined at top\r\n            uint n = day - 1; //n of days to compound the multipler by\r\n            uint p = 3 + n * 5 / 100; //itterations to calculate compound daily multiplier. higher is greater precision but more expensive\r\n            uint s = 0; //output. itterativly added to for result\r\n            uint x = 1; //multiply side of binomial expansion\r\n            uint y = 1; //divide side of binomial expansion\r\n            //itterate top q lines binomial expansion to estimate compound multipler\r\n            for (uint i = 0; i < p; ++i) { //each itteration gets closer, higher p = closer approximation but more costly\r\n                s += startPrice * x / y / (q**i); //iterate adding each time to s\r\n                x = x * (n-i); //calc multiply side\r\n                y = y * (i+1); //calc divide side\r\n            }\r\n            return (s); //return priceInWei = s\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Giving New Tokens To Buyer\r\n    function () external payable {\r\n        // must buy whole token when minting new here, but can buy/sell fractions between eachother\r\n        require(now >= start2018 && now <= end2018); //must be in 2018\r\n        uint priceWei = this.getPriceWei(0); //get todays price\r\n        uint256 giveTokens = msg.value / priceWei; //rounds down to no of tokens that can afford\r\n            if (tokensToday + giveTokens > tokensDaily) { //if asking for tokens than left today\r\n                giveTokens = tokensDaily - tokensToday;    //then limit giving to remaining tokens\r\n                }\r\n        countBuy += 1; //count usage\r\n        tokensToday += giveTokens; //count whole tokens issued today\r\n        box[msg.sender] = this.boxChoice(0); //assign box number to buyer\r\n        _transfer(this, msg.sender, giveTokens * 10 ** uint256(decimals)); //transfer tokens from this contract\r\n        uint256 changeDue = msg.value - (giveTokens * priceWei) * 99 / 100; //calculate change due, charged 1% to disincentivise high volume full refund calls.\r\n        require(changeDue < msg.value); //make sure refund is not more than input\r\n        msg.sender.transfer(changeDue); //give change\r\n        \r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //To Find Users Token Ammount and Box number\r\n    function getValueAndBox(address _address) view external returns(uint, uint) {\r\n        return (balanceOf[_address], box[_address]);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //For transfering tokens to others\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(balanceOf[_from] >= _value); // Check if the sender has enough\r\n        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\r\n        uint previousbalanceOf = balanceOf[_from] + balanceOf[_to]; // Save this for an assertion in the future\r\n        balanceOf[_from] -= _value; // Subtract from the sender\r\n        balanceOf[_to] += _value; // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousbalanceOf); // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Transfer tokens\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Transfer tokens from other address\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]); // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Set allowance for other address\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Set allowance for other address and notify\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Decide or change box used in game\r\n    function boxChoice(uint _newBox) public returns (uint) { \r\n        //for _newBox = 0 assign random \r\n        boxRand += 1; //count up for even start box assingment\r\n        if (boxRand > boxMax) { //stop box assignment too high\r\n                    boxRand = 1; //return to box 1\r\n            }\r\n        if (_newBox == 0) {\r\n            box[msg.sender] = boxRand; //give new random assignment to owner (or this if buying)\r\n        } else {\r\n        box[msg.sender] = _newBox; //give new assignment to owner (or this if buying)\r\n        }\r\n        BoxChange(msg.sender, _newBox); //let everyone know\r\n            return (box[msg.sender]); //output to console\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Release the funds for expanding project\r\n    //Payable to re-top up contract\r\n    function fundsOut() payable public { \r\n        require(msg.sender == creator); //only alow creator to take out\r\n        creator.transfer(this.balance); //take the lot, can pay back into this via different address if wished re-top up\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Used to tweak and update for Game\r\n    function update(uint _option, uint _newNo, address _newAddress) public returns (string, uint) {\r\n        require(msg.sender == creator || msg.sender == game); //only alow creator or game to use\r\n        //change Max Box Choice\r\n        if (_option == 1) {\r\n            require(_newNo > 0);\r\n            boxMax = _newNo;\r\n            return (\"boxMax Updated\", boxMax);\r\n        }\r\n        //change address of game smart contract\r\n        if (_option == 2) {\r\n            game = _newAddress;\r\n            return (\"Game Smart Contract Updated\", 1);\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Destroy tokens\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //Destroy tokens from other account\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    //For trsnsfering tokens to others using this SC to enure they pay    \r\n    function setEscrowTransfer(address _to, uint _value, uint _price, bool _open) external returns (bool success) {\r\n            //_to to specify a address who can purchase\r\n            //_open if anyone can purchase (set _to to any address)\r\n            //_price is min asking value for full value of tokens\r\n            //_value is number of tokens available\r\n            //_to, who will purchase value of tokens\r\n        _transfer(msg.sender, this, _value); //store _value in this contract\r\n        userEscrowCount[msg.sender] += 1;\r\n        var escrowTrade = escrowTransferInfo[msg.sender][userEscrowCount[msg.sender]]; //record transfer option details\r\n        escrowTrade.value += _value;//add value into retaining store for trade\r\n        escrowTrade.price = _price; //set asking price\r\n        escrowTrade.to = _to; //who will purchase\r\n        escrowTrade.open = _open; //is trade open to all. false = closed. true = open to anyone.\r\n        escrowCount += 1;\r\n        escrowTransferList.push(EscrowTfr(msg.sender, userEscrowCount[msg.sender]));\r\n        Escrow(msg.sender, _value, _price, _open, _to); // This notifies clients about the escrow\r\n        return (true); //success!\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////\r\n    //For purchasing tokens from others using this SC to give trust to purchase\r\n    function recieveEscrowTransfer(address _sender, uint _no) external payable returns (bool success) { \r\n            //_sender is person buying from\r\n            require(escrowTransferInfo[_sender][_no].value != 0); //end if trade already completed\r\n        box[msg.sender] = this.boxChoice(box[msg.sender]); //assign box number to buyer\r\n        if (msg.sender == _sender) {\r\n            _transfer(this, msg.sender, escrowTransferInfo[_sender][_no].value); //put tokens back to sender account\r\n            escrowTransferInfo[_sender][_no].value = 0; //reset counter for escrow token\r\n            Escrow(_sender, 0, msg.value, escrowTransferInfo[_sender][_no].open, msg.sender); // This notifies clients about the escrow\r\n            return (true);\r\n        } else {\r\n            require(msg.value >= escrowTransferInfo[_sender][_no].price); //Check _to is Paying Enough\r\n            if (escrowTransferInfo[_sender][_no].open == false) {\r\n                require(msg.sender == escrowTransferInfo[_sender][_no].to); //Check _to is the intended purchaser\r\n                }\r\n            _transfer(this, msg.sender, escrowTransferInfo[_sender][_no].value);   \r\n            _sender.transfer(msg.value); //Send the sender the value of the trade\r\n            escrowTransferInfo[_sender][_no].value = 0; //no more in retaining store\r\n            Escrow(_sender, 0, msg.value, escrowTransferInfo[_sender][_no].open, msg.sender); // This notifies clients about the escrow\r\n            return (true); //success!\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBox\",\"type\":\"uint256\"}],\"name\":\"boxChoice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_option\",\"type\":\"uint256\"},{\"name\":\"_newNo\",\"type\":\"uint256\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leftToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"escrowTransferList\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tradeNo\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrowCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getPriceWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_open\",\"type\":\"bool\"}],\"name\":\"setEscrowTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensDaily\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fundsOut\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"game\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"escrowTransferInfo\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"open\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_no\",\"type\":\"uint256\"}],\"name\":\"recieveEscrowTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"box\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getValueAndBox\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newBox\",\"type\":\"uint256\"}],\"name\":\"BoxChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"open\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Escrow\",\"type\":\"event\"}]","ContractName":"Big2018Token","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://94f46c83d1bca0ca145f9a55953def7d26ef8199140515fbdffaa3b3ed66b2b5"}]}