{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/**\r\n * This contract is used to protect the users of Storm4:\r\n * https://www.storm4.cloud\r\n * \r\n * That is, to ensure the public keys of users are verifiable, auditable & tamper-proof.\r\n * \r\n * Here's the general idea:\r\n * - We batch the public keys of multiple users into a merkle tree.\r\n * - We publish the merkle tree root to this contract.\r\n * - The merkle tree root for any given user can only be assigned once (per hash algorithm).\r\n * \r\n * In order to verify a user:\r\n * - Use this contract to fetch the merkle tree root value for the userID.\r\n * - Then use HTTPS to fetch the corresponding merkle file from our server at\r\n *   https://blockchain.storm4.cloud/merkleTreeRootValueGoesHere.json\r\n * - The JSON file allows you to independently verify the public key information\r\n *   by calculating the merkle tree root for yourself.\r\n**/\r\ncontract PubKeyTrust {\r\n\taddress public owner;\r\n\r\n\t/**\r\n\t * Rather than hard-coding a specific hash algorithm, we allow for upgradeability,\r\n\t * should it become important to do so in the future for security reasons.\r\n\t * \r\n\t * In order to support this, we keep a \"register\" of supported hash algorithms.\r\n\t * Every hash algorithm in the system is assigned a unique ID (a uint8),\r\n\t * along with a corresponding short identifier.\r\n\t * \r\n\t * For example: 0 => \"sha256\"\r\n\t * \r\n\t * Note: Since we are expecting there to be very few hash algorithms used\r\n\t * in practice (probably just 1 or 2), we artificially limit the size of\r\n\t * the hashTypes array to 256 entries. This allows us to use uint8 throughout\r\n\t * the rest of the contract, which helps limit storage requirements.\r\n\t**/\r\n\tstring[] public hashTypes;\r\n\r\n\t/**\r\n\t * We batch the public keys of multiple users into a single merkle tree,\r\n\t * and then publish the merkle tree root to the blockchain.\r\n\t * \r\n\t * Note: merkleTreeRoots[0] is initialized in the constructor to store\r\n\t * the block number of when the contract was published.\r\n\t**/\r\n\tstruct MerkleInfo {\r\n\t\tbytes merkleTreeRoot;\r\n\t\tuint blockNumber;\r\n\t}\r\n\tMerkleInfo[] public merkleTreeRoots;\r\n\r\n\t/**\r\n\t * users[userID][hashTypeID] => merkleTreeRootsIndex\r\n\t * \r\n\t * A value of zero indicates that a merkleTreeRoot has not been\r\n\t * published for the <userID, hashTypeID> tuple.\r\n\t * A nonzero value can be used as the index for the merkleTreeRoots array.\r\n\t * \r\n\t * Note: merkleTreeRoots[0] is initialized in the constructor to store\r\n\t * the block number of when the contract was published.\r\n\t * Thus: merkleTreeRoots[0].merkleTreeRoot.length == 0\r\n\t**/\r\n\tmapping(bytes20 => mapping(uint8 => uint)) public users;\r\n\r\n\tevent HashTypeAdded(uint8 hashTypeID);\r\n\tevent MerkleTreeRootAdded(uint8 hashTypeID, bytes merkleTreeRoot);\r\n\r\n\tfunction PubKeyTrust() public {\r\n\t\towner = msg.sender;\r\n\t\tmerkleTreeRoots.push(MerkleInfo(new bytes(0), block.number));\r\n\t}\r\n\r\n\tmodifier onlyByOwner()\r\n\t{\r\n\t\tif (msg.sender != owner)\r\n\t\t\trequire(false);\r\n\t\telse\r\n\t\t\t_;\r\n\t}\r\n\r\n\tfunction numHashTypes() public view returns (uint) {\r\n\r\n\t\treturn hashTypes.length;\r\n\t}\r\n\r\n\tfunction addHashType(string description) public onlyByOwner returns(bool, uint8) {\r\n\r\n\t\tuint hashTypeID = hashTypes.length;\r\n\r\n\t\t// Restrictions:\r\n\t\t// - there cannot be more than 256 different hash types\r\n\t\t// - the description cannot be the empty string\r\n\t\t// - the description cannot be over 64 bytes long\r\n\t\tif (hashTypeID >= 256) require(false);\r\n\t\tif (bytes(description).length == 0) require(false);\r\n\t\tif (bytes(description).length > 64) require(false);\r\n\r\n\t\t// Ensure the given description doesn't already exist\r\n\t\tfor (uint i = 0; i < hashTypeID; i++)\r\n\t\t{\r\n\t\t\tif (stringsEqual(hashTypes[i], description)) {\r\n\t\t\t\treturn (false, uint8(0));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Go ahead and add the new hash type\r\n\t\thashTypes.push(description);\r\n\t\tHashTypeAdded(uint8(hashTypeID));\r\n\r\n\t\treturn (true, uint8(hashTypeID));\r\n\t}\r\n\r\n\t/**\r\n\t * We originally passed the userIDs as: bytes20[] userIDs\r\n\t * But it was discovered that this was inefficiently packed,\r\n\t * and ended up sending 12 bytes of zero's per userID.\r\n\t * Since gtxdatazero is set to 4 gas/bytes, this translated into\r\n\t * 48 gas wasted per user due to inefficient packing.\r\n\t**/\r\n\tfunction addMerkleTreeRoot(uint8 hashTypeID, bytes merkleTreeRoot, bytes userIDsPacked) public onlyByOwner {\r\n\r\n\t\tif (hashTypeID >= hashTypes.length) require(false);\r\n\t\tif (merkleTreeRoot.length == 0) require(false);\r\n\r\n\t\tuint index = merkleTreeRoots.length;\r\n\t\tbool addedIndexForUser = false;\r\n\r\n\t\tuint numUserIDs = userIDsPacked.length / 20;\r\n\t\tfor (uint i = 0; i < numUserIDs; i++)\r\n\t\t{\r\n\t\t\tbytes20 userID;\r\n\t\t\tassembly {\r\n\t\t\t\tuserID := mload(add(userIDsPacked, add(32, mul(20, i))))\r\n\t\t\t}\r\n\r\n\t\t\tuint existingIndex = users[userID][hashTypeID];\r\n\t\t\tif (existingIndex == 0)\r\n\t\t\t{\r\n\t\t\t\tusers[userID][hashTypeID] = index;\r\n\t\t\t\taddedIndexForUser = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (addedIndexForUser)\r\n\t\t{\r\n\t\t\tmerkleTreeRoots.push(MerkleInfo(merkleTreeRoot, block.number));\r\n\t\t\tMerkleTreeRootAdded(hashTypeID, merkleTreeRoot);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getMerkleTreeRoot(bytes20 userID, uint8 hashTypeID) public view returns (bytes) {\r\n\r\n\t\tuint merkleTreeRootsIndex = users[userID][hashTypeID];\r\n\t\tif (merkleTreeRootsIndex == 0) {\r\n\t\t\treturn new bytes(0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tMerkleInfo storage merkleInfo = merkleTreeRoots[merkleTreeRootsIndex];\r\n\t\t\treturn merkleInfo.merkleTreeRoot;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getBlockNumber(bytes20 userID, uint8 hashTypeID) public view returns (uint) {\r\n\r\n\t\tuint merkleTreeRootsIndex = users[userID][hashTypeID];\r\n\t\tif (merkleTreeRootsIndex == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tMerkleInfo storage merkleInfo = merkleTreeRoots[merkleTreeRootsIndex];\r\n\t\t\treturn merkleInfo.blockNumber;\r\n\t\t}\r\n\t}\r\n\r\n\t// Utility function (because string comparison doesn't exist natively in Solidity yet)\r\n\tfunction stringsEqual(string storage _a, string memory _b) internal view returns (bool) {\r\n\r\n\t\tbytes storage a = bytes(_a);\r\n\t\tbytes memory b = bytes(_b);\r\n\t\tif (a.length != b.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (uint i = 0; i < a.length; i++) {\r\n\t\t\tif (a[i] != b[i]) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"hashTypeID\",\"type\":\"uint8\"},{\"name\":\"merkleTreeRoot\",\"type\":\"bytes\"},{\"name\":\"userIDsPacked\",\"type\":\"bytes\"}],\"name\":\"addMerkleTreeRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleTreeRoots\",\"outputs\":[{\"name\":\"merkleTreeRoot\",\"type\":\"bytes\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numHashTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userID\",\"type\":\"bytes20\"},{\"name\":\"hashTypeID\",\"type\":\"uint8\"}],\"name\":\"getMerkleTreeRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes20\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userID\",\"type\":\"bytes20\"},{\"name\":\"hashTypeID\",\"type\":\"uint8\"}],\"name\":\"getBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"description\",\"type\":\"string\"}],\"name\":\"addHashType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hashTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hashTypeID\",\"type\":\"uint8\"}],\"name\":\"HashTypeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hashTypeID\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"merkleTreeRoot\",\"type\":\"bytes\"}],\"name\":\"MerkleTreeRootAdded\",\"type\":\"event\"}]","ContractName":"PubKeyTrust","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://63a98029a6250d2854b24ef317407b3fb9d4c873b27582bfeb3d4708353c90b2"}]}