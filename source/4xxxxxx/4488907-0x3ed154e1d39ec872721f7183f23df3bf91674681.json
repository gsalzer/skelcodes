{"status":"1","message":"OK","result":[{"SourceCode":"//File: node_modules/giveth-common-contracts/contracts/ERC20.sol\r\npragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title ERC20\r\n * @dev A standard interface for tokens.\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n  \r\n    /// @dev Returns the total token supply.\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @dev Returns the account balance of another account with address _owner.\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @dev Transfers _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Transfers _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Allows _spender to withdraw from your account multiple times, up to the _value amount\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner.\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n//File: node_modules/giveth-common-contracts/contracts/Owned.sol\r\npragma solidity ^0.4.15;\r\n\r\n\r\n/// @title Owned\r\n/// @author Adrià Massanet <adria@codecontext.io>\r\n/// @notice The Owned contract has an owner address, and provides basic \r\n///  authorization control functions, this simplifies & the implementation of\r\n///  \"user permissions\"\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed by, address indexed to);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event OwnershipRemoved();\r\n\r\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner.\r\n    function changeOwnership(address _newOwner) onlyOwner {\r\n        require(_newOwner != 0x0);\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\r\n    ///  new owner\r\n    /// @param _newOwnerCandidate The address being proposed as the new owner\r\n    function proposeOwnership(address _newOwnerCandidate) onlyOwner {\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\r\n    ///  transfer of ownership\r\n    function acceptOwnership() {\r\n        require(msg.sender == newOwnerCandidate);\r\n\r\n        address oldOwner = owner;\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @notice Decentralizes the contract, this operation cannot be undone \r\n    /// @param _dac `0xdac` has to be entered for this function to work\r\n    function removeOwnership(address _dac) onlyOwner {\r\n        require(_dac == 0xdac);\r\n        owner = 0x0;\r\n        newOwnerCandidate = 0x0;\r\n        OwnershipRemoved();     \r\n    }\r\n\r\n} \r\n\r\n//File: node_modules/giveth-common-contracts/contracts/Escapable.sol\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    Contributor: Adrià Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\npragma solidity ^0.4.15;\r\n\r\n\r\n\r\n\r\n\r\n/// @dev `Escapable` is a base level contract built off of the `Owned`\r\n///  contract that creates an escape hatch function to send its ether to\r\n///  `escapeHatchDestination` when called by the `escapeHatchCaller` in the case that\r\n///  something unexpected happens\r\ncontract Escapable is Owned {\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n    mapping (address=>bool) private escapeBlacklist;\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\r\n    ///  `escapeHatchCaller`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot move\r\n    ///  funds out of `escapeHatchDestination`\r\n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) {\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    modifier onlyEscapeHatchCallerOrOwner {\r\n        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\r\n        _;\r\n    }\r\n\r\n    /// @notice The `blacklistEscapeTokens()` marks a token in a whitelist to be\r\n    ///   escaped. The proupose is to be done at construction time.\r\n    /// @param _token the be bloacklisted for escape\r\n    function blacklistEscapeToken(address _token) internal {\r\n        escapeBlacklist[_token] = true;\r\n        EscapeHatchBlackistedToken(_token);\r\n    }\r\n\r\n    function isTokenEscapable(address _token) constant public returns (bool) {\r\n        return !escapeBlacklist[_token];\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    /// @param _token to transfer, use 0x0 for ethers\r\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \r\n        require(escapeBlacklist[_token]==false);\r\n\r\n        uint256 balance;\r\n\r\n        if (_token == 0x0) {\r\n            balance = this.balance;\r\n            escapeHatchDestination.transfer(balance);\r\n            EscapeHatchCalled(_token, balance);\r\n            return;\r\n        }\r\n\r\n        ERC20 token = ERC20(_token);\r\n        balance = token.balanceOf(this);\r\n        token.transfer(escapeHatchDestination, balance);\r\n        EscapeHatchCalled(_token, balance);\r\n    }\r\n\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot\r\n    ///  move funds out of `escapeHatchDestination`\r\n    function changeHatchEscapeCaller(address _newEscapeHatchCaller) onlyEscapeHatchCallerOrOwner {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n    }\r\n\r\n    event EscapeHatchBlackistedToken(address token);\r\n    event EscapeHatchCalled(address token, uint amount);\r\n}\r\n\r\n//File: ./contracts/WithdrawContract.sol\r\npragma solidity ^0.4.18;\r\n/*\r\n    Copyright 2017, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/// @dev This declares a few functions from `MiniMeToken` so that the\r\n///  `WithdrawContract` can interface with the `MiniMeToken`\r\ncontract MiniMeToken {\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint);\r\n}\r\n\r\n\r\n\r\n\r\n/// @dev This is the main contract, it is intended to distribute deposited funds\r\n///  from a TRUSTED `owner` to token holders of a MiniMe style ERC-20 Token;\r\n///  only deposits from the `owner` using the functions `newTokenPayment()` &\r\n///  `newEtherPayment()` will be distributed, any other funds sent to this\r\n///  contract can only be removed via the `escapeHatch()`\r\ncontract WithdrawContract is Escapable {\r\n\r\n    /// @dev Tracks the deposits made to this contract\r\n    struct Deposit {\r\n        uint block;    // Determines which token holders are able to collect\r\n        ERC20 token;   // The token address (0x0 if ether)\r\n        uint amount;   // The amount deposited in the smallest unit (wei if ETH)\r\n        bool canceled; // True if canceled by the `owner`\r\n    }\r\n\r\n    Deposit[] public deposits; // Array of deposits to this contract\r\n    MiniMeToken rewardToken;     // Token that is used for withdraws\r\n\r\n    mapping (address => uint) public nextDepositToPayout; // Tracks Payouts\r\n    mapping (address => mapping(uint => bool)) skipDeposits;\r\n\r\n/////////\r\n// Constructor\r\n/////////\r\n\r\n    /// @notice The Constructor creates the `WithdrawContract` on the blockchain\r\n    ///  the `owner` role is assigned to the address that deploys this contract\r\n    /// @param _rewardToken The address of the token that is used to determine the\r\n    ///  distribution of the deposits according to the balance held at the\r\n    ///  deposit's specified `block`\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract\r\n    ///  to call `escapeHatch()` to send the specified token (or ether) held in\r\n    ///  this contract to the `escapeHatchDestination`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether and tokens held in this contract when the\r\n    ///  `escapeHatch()` is called\r\n    function WithdrawContract(\r\n        MiniMeToken _rewardToken,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination)\r\n        Escapable(_escapeHatchCaller, _escapeHatchDestination)\r\n        public\r\n    {\r\n        rewardToken = _rewardToken;\r\n    }\r\n\r\n    /// @dev When ether is sent to this contract `newEtherDeposit()` is called\r\n    function () payable public {\r\n        newEtherDeposit(0);\r\n    }\r\n/////////\r\n// Owner Functions\r\n/////////\r\n\r\n    /// @notice Adds an ether deposit to `deposits[]`; only the `owner` can\r\n    ///  deposit into this contract\r\n    /// @param _block The block height that determines the snapshot of token\r\n    ///  holders that will be able to withdraw their share of this deposit; this\r\n    ///  block must be set in the past, if 0 it defaults to one block before the\r\n    ///  transaction\r\n    /// @return _idDeposit The id number for the deposit\r\n    function newEtherDeposit(uint _block)\r\n        public onlyOwner payable\r\n        returns (uint _idDeposit)\r\n    {\r\n        require(msg.value>0);\r\n        require(_block < block.number);\r\n        _idDeposit = deposits.length ++;\r\n\r\n        // Record the deposit\r\n        Deposit storage d = deposits[_idDeposit];\r\n        d.block = _block == 0 ? block.number -1 : _block;\r\n        d.token = ERC20(0);\r\n        d.amount = msg.value;\r\n        NewDeposit(_idDeposit, ERC20(0), msg.value);\r\n    }\r\n\r\n    /// @notice Adds a token deposit to `deposits[]`; only the `owner` can\r\n    ///  call this function and it will only work if the account sending the\r\n    ///  tokens has called `approve()` so that this contract can call\r\n    ///  `transferFrom()` and take the tokens\r\n    /// @param _token The address for the ERC20 that is being deposited\r\n    /// @param _amount The quantity of tokens that is deposited into the\r\n    ///  contract in the smallest unit of tokens (if a token has its decimals\r\n    ///  set to 18 and 1 token is sent, the `_amount` would be 10^18)\r\n    /// @param _block The block height that determines the snapshot of token\r\n    ///  holders that will be able to withdraw their share of this deposit; this\r\n    ///  block must be set in the past, if 0 it defaults to one block before the\r\n    ///  transaction\r\n    /// @return _idDeposit The id number for the deposit\r\n    function newTokenDeposit(ERC20 _token, uint _amount, uint _block)\r\n        public onlyOwner\r\n        returns (uint _idDeposit)\r\n    {\r\n        require(_amount > 0);\r\n        require(_block < block.number);\r\n\r\n        // Must `approve()` this contract in a previous transaction\r\n        require( _token.transferFrom(msg.sender, address(this), _amount) );\r\n        _idDeposit = deposits.length ++;\r\n\r\n        // Record the deposit\r\n        Deposit storage d = deposits[_idDeposit];\r\n        d.block = _block == 0 ? block.number -1 : _block;\r\n        d.token = _token;\r\n        d.amount = _amount;\r\n        NewDeposit(_idDeposit, _token, _amount);\r\n    }\r\n\r\n    /// @notice This function is a failsafe function in case a token is\r\n    ///  deposited that has an issue that could prevent it's withdraw loop break\r\n    ///  (e.g. transfers are disabled), can only be called by the `owner`\r\n    /// @param _idDeposit The id number for the deposit being canceled\r\n    function cancelPaymentGlobally(uint _idDeposit) public onlyOwner {\r\n        require(_idDeposit < deposits.length);\r\n        deposits[_idDeposit].canceled = true;\r\n        CancelPaymentGlobally(_idDeposit);\r\n    }\r\n\r\n/////////\r\n// Public Functions\r\n/////////\r\n    /// @notice Sends all the tokens and ether to the token holder by looping\r\n    ///  through all the deposits, determining the appropriate amount by\r\n    ///  dividing the `totalSupply` by the number of tokens the token holder had\r\n    ///  at `deposit.block` for each deposit; this function may have to be\r\n    ///  called multiple times if their are many deposits\r\n    function withdraw() public {\r\n        uint acc = 0; // Accumulates the amount of tokens/ether to be sent\r\n        uint i = nextDepositToPayout[msg.sender]; // Iterates through the deposits\r\n        require(i<deposits.length);\r\n        ERC20 currentToken = deposits[i].token; // Sets the `currentToken` to ether\r\n\r\n        require(msg.gas>149000); // Throws if there is no gas to do at least a single transfer.\r\n        while (( i< deposits.length) && ( msg.gas > 148000)) {\r\n            Deposit storage d = deposits[i];\r\n\r\n            // Make sure `deposit[i]` shouldn't be skipped\r\n            if ((!d.canceled)&&(!isDepositSkiped(msg.sender, i))) {\r\n\r\n                // The current diposti is different of the accumulated until now,\r\n                // so we return the accumulated tokens until now and resset the\r\n                // accumulator.\r\n                if (currentToken != d.token) {\r\n                    nextDepositToPayout[msg.sender] = i;\r\n                    require(doPayment(i-1, msg.sender, currentToken, acc));\r\n                    assert(nextDepositToPayout[msg.sender] == i);\r\n                    currentToken = d.token;\r\n                    acc =0;\r\n                }\r\n\r\n                // Accumulate the amount to send for the `currentToken`\r\n                acc +=  d.amount *\r\n                        rewardToken.balanceOfAt(msg.sender, d.block) /\r\n                            rewardToken.totalSupplyAt(d.block);\r\n            }\r\n\r\n            i++; // Next deposit :-D\r\n        }\r\n        // Return the accumulated tokens.\r\n        nextDepositToPayout[msg.sender] = i;\r\n        require(doPayment(i-1, msg.sender, currentToken, acc));\r\n        assert(nextDepositToPayout[msg.sender] == i);\r\n    }\r\n\r\n    /// @notice This function is a failsafe function in case a token holder\r\n    ///  wants to skip a payment, can only be applied to one deposit at a time\r\n    ///  and only affects the payment for the `msg.sender` calling the function;\r\n    ///  can be undone by calling again with `skip == false`\r\n    /// @param _idDeposit The id number for the deposit being canceled\r\n    /// @param _skip True if the caller wants to skip the payment for `idDeposit`\r\n    function skipPayment(uint _idDeposit, bool _skip) public {\r\n        require(_idDeposit < deposits.length);\r\n        skipDeposits[msg.sender][_idDeposit] = _skip;\r\n        SkipPayment(_idDeposit, _skip);\r\n    }\r\n\r\n/////////\r\n// Constant Functions\r\n/////////\r\n\r\n    /// @notice Calculates the amount of a given token (or ether) the holder can\r\n    ///  receive\r\n    /// @param _token The address of the token being queried, 0x0 = ether\r\n    /// @param _holder The address being checked\r\n    /// @return The amount of `token` able to be collected in the smallest\r\n    ///  unit of the `token` (wei for ether)\r\n    function getPendingReward(ERC20 _token, address _holder) public constant returns(uint) {\r\n        uint acc =0;\r\n        for (uint i=nextDepositToPayout[msg.sender]; i<deposits.length; i++) {\r\n            Deposit storage d = deposits[i];\r\n            if ((d.token == _token)&&(!d.canceled) && (!isDepositSkiped(_holder, i))) {\r\n                acc +=  d.amount *\r\n                    rewardToken.balanceOfAt(_holder, d.block) /\r\n                        rewardToken.totalSupplyAt(d.block);\r\n            }\r\n        }\r\n        return acc;\r\n    }\r\n\r\n    /// @notice A check to see if a specific address has anything to collect\r\n    /// @param _holder The address being checked for available deposits\r\n    /// @return True if there are payments to be collected\r\n    function canWithdraw(address _holder) public constant returns (bool) {\r\n        if (nextDepositToPayout[_holder] == deposits.length) return false;\r\n        for (uint i=nextDepositToPayout[msg.sender]; i<deposits.length; i++) {\r\n            Deposit storage d = deposits[i];\r\n            if ((!d.canceled) && (!isDepositSkiped(_holder, i))) {\r\n                uint amount =  d.amount *\r\n                    rewardToken.balanceOfAt(_holder, d.block) /\r\n                        rewardToken.totalSupplyAt(d.block);\r\n                if (amount>0) return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice Checks how many deposits have been made\r\n    /// @return The number of deposits\r\n    function nDeposits() public constant returns (uint) {\r\n        return deposits.length;\r\n    }\r\n\r\n    /// @notice Checks to see if a specific deposit has been skipped\r\n    /// @param _holder The address being checked for available deposits\r\n    /// @param _idDeposit The id number for the deposit being canceled\r\n    /// @return True if the specified deposit has been skipped\r\n    function isDepositSkiped(address _holder, uint _idDeposit) public constant returns(bool) {\r\n        return skipDeposits[_holder][_idDeposit];\r\n    }\r\n\r\n/////////\r\n// Internal Functions\r\n/////////\r\n\r\n    /// @notice Transfers `amount` of `token` to `dest`, only used internally,\r\n    ///  and does not throw, will always return `true` or `false`\r\n    /// @param _token The address for the ERC20 that is being transferred\r\n    /// @param _dest The destination address of the transfer\r\n    /// @param _amount The quantity of tokens that is being transferred\r\n    ///  denominated in the smallest unit of tokens (if a token has its decimals\r\n    ///  set to 18 and 1 token is being transferred the `amount` would be 10^18)\r\n    /// @return True if the payment succeeded\r\n    function doPayment(uint _idDeposit,  address _dest, ERC20 _token, uint _amount) internal returns (bool) {\r\n        if (_amount == 0) return true;\r\n        if (address(_token) == 0) {\r\n            if (!_dest.send(_amount)) return false;   // If we can't send, we continue...\r\n        } else {\r\n            if (!_token.transfer(_dest, _amount)) return false;\r\n        }\r\n        Withdraw(_idDeposit, _dest, _token, _amount);\r\n        return true;\r\n    }\r\n\r\n    function getBalance(ERC20 _token, address _holder) internal constant returns (uint) {\r\n        if (address(_token) == 0) {\r\n            return _holder.balance;\r\n        } else {\r\n            return _token.balanceOf(_holder);\r\n        }\r\n    }\r\n\r\n/////////\r\n// Events\r\n/////////\r\n\r\n    event Withdraw(uint indexed lastIdPayment, address indexed holder, ERC20 indexed tokenContract, uint amount);\r\n    event NewDeposit(uint indexed idDeposit, ERC20 indexed tokenContract, uint amount);\r\n    event CancelPaymentGlobally(uint indexed idDeposit);\r\n    event SkipPayment(uint indexed idDeposit, bool skip);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"canWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idDeposit\",\"type\":\"uint256\"},{\"name\":\"_skip\",\"type\":\"bool\"}],\"name\":\"skipPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"newTokenDeposit\",\"outputs\":[{\"name\":\"_idDeposit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextDepositToPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dac\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenEscapable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_idDeposit\",\"type\":\"uint256\"}],\"name\":\"isDepositSkiped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"block\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"canceled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"newEtherDeposit\",\"outputs\":[{\"name\":\"_idDeposit\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeHatchEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idDeposit\",\"type\":\"uint256\"}],\"name\":\"cancelPaymentGlobally\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getPendingReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rewardToken\",\"type\":\"address\"},{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lastIdPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idDeposit\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idDeposit\",\"type\":\"uint256\"}],\"name\":\"CancelPaymentGlobally\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"skip\",\"type\":\"bool\"}],\"name\":\"SkipPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EscapeHatchBlackistedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRemoved\",\"type\":\"event\"}]","ContractName":"WithdrawContract","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000667dd163f1a0e6ef3e7bbe8e0676f62146d5662d0000000000000000000000001dba1131000664b884a1ba238464159892252d3a000000000000000000000000667dd163f1a0e6ef3e7bbe8e0676f62146d5662d","Library":"","SwarmSource":"bzzr://2006f388efc797568aea6630c05326f98da497a9d97d7f9eada22ce6d2bfbca7"}]}