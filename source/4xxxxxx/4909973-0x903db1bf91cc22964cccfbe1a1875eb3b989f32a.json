{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\ncontract TrustWallet {\r\n\r\n    struct User {\r\n        // How many seconds the user has to wait between initiating the\r\n        // transaction and finalizing the transaction. This cannot be\r\n        // changed.\r\n        uint delay;\r\n\r\n        address added_by;\r\n        uint time_added;\r\n\r\n        address removed_by;\r\n        uint time_removed;\r\n\r\n        // When this user added another user. (This is to prevent a user from\r\n        // adding many users too quickly).\r\n        uint time_added_another_user;\r\n    }\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n\r\n        address initiated_by;\r\n        uint time_initiated;\r\n\r\n        address finalized_by;\r\n        uint time_finalized;\r\n\r\n        // True if this trasaction was executed. If false, this means it was canceled.\r\n        bool is_executed;\r\n    }\r\n\r\n    Transaction[] public transactions;\r\n    mapping (address => User) public users;\r\n    address[] public userAddresses;\r\n\r\n    modifier onlyActiveUsersAllowed() {\r\n        require(users[msg.sender].time_added != 0);\r\n        require(users[msg.sender].time_removed == 0);\r\n        _;\r\n    }\r\n\r\n    modifier transactionMustBePending() {\r\n        require(isTransactionPending());\r\n        _;\r\n    }\r\n\r\n    modifier transactionMustNotBePending() {\r\n        require(!isTransactionPending());\r\n        _;\r\n    }\r\n\r\n    // Returns true if there is a transaction pending.\r\n    function isTransactionPending() internal constant returns (bool) {\r\n        if (transactions.length == 0) return false;\r\n        return transactions[transactions.length - 1].time_initiated > 0 &&\r\n            transactions[transactions.length - 1].time_finalized == 0;\r\n    }\r\n\r\n    // Constructor. Creates the first user.\r\n    function TrustWallet(address first_user) public {\r\n        users[first_user] = User({\r\n            delay: 0,\r\n            time_added: now,\r\n            added_by: 0x0,\r\n            time_removed: 0,\r\n            removed_by: 0x0,\r\n            time_added_another_user: now\r\n        });\r\n        userAddresses.push(first_user);\r\n    }\r\n\r\n    function () public payable {}\r\n\r\n    // Initiates a transaction. There must not be any pending transaction.\r\n    function initiateTransaction(address _destination, uint _value, bytes _data)\r\n        public\r\n        onlyActiveUsersAllowed()\r\n        transactionMustNotBePending()\r\n    {\r\n        transactions.push(Transaction({\r\n            destination: _destination,\r\n            value: _value,\r\n            data: _data,\r\n            initiated_by: msg.sender,\r\n            time_initiated: now,\r\n            finalized_by: 0x0,\r\n            time_finalized: 0,\r\n            is_executed: false\r\n        }));\r\n    }\r\n\r\n    // Executes the transaction. The delay of the the transaction\r\n    // initiated_by must have passed in order to call this function. Any active\r\n    // user is able to call this function.\r\n    function executeTransaction()\r\n        public\r\n        onlyActiveUsersAllowed()\r\n        transactionMustBePending()\r\n    {\r\n        Transaction storage transaction = transactions[transactions.length - 1];\r\n        require(now > transaction.time_initiated + users[transaction.initiated_by].delay);\r\n        transaction.is_executed = true;\r\n        transaction.time_finalized = now;\r\n        transaction.finalized_by = msg.sender;\r\n        require(transaction.destination.call.value(transaction.value)(transaction.data));\r\n    }\r\n\r\n    // Cancels the transaction. The delay of the user who is trying\r\n    // to cancel must be lower or equal to the delay of the\r\n    // transaction initiated_by.\r\n    function cancelTransaction()\r\n        public\r\n        onlyActiveUsersAllowed()\r\n        transactionMustBePending()\r\n    {\r\n        Transaction storage transaction = transactions[transactions.length - 1];\r\n        // Either the sender is a higher priority user, or twice the waiting time of\r\n        // the user trying to cancel has passed. This is to prevent transactions from\r\n        // getting \"stuck\" if the call() fails when trying to execute the transaction.\r\n        require(users[msg.sender].delay <= users[transaction.initiated_by].delay ||\r\n            now - transaction.time_initiated > users[msg.sender].delay * 2);\r\n        transaction.time_finalized = now;\r\n        transaction.finalized_by = msg.sender;\r\n    }\r\n\r\n    // Adds a user to the wallet. The waiting time of the new user must\r\n    // be greater or equal to the delay of the sender. A user that\r\n    // already exists or was removed cannot be added. To prevent spam,\r\n    // a user must wait delay before adding another user.\r\n    function addUser(address new_user, uint new_user_time)\r\n        public\r\n        onlyActiveUsersAllowed()\r\n    {\r\n        require(users[new_user].time_added == 0);\r\n        require(users[new_user].time_removed == 0);\r\n\r\n        User storage sender = users[msg.sender];\r\n        require(now > sender.delay + sender.time_added_another_user);\r\n        require(new_user_time >= sender.delay);\r\n\r\n        sender.time_added_another_user = now;\r\n        users[new_user] = User({\r\n            delay: new_user_time,\r\n            time_added: now,\r\n            added_by: msg.sender,\r\n            time_removed: 0,\r\n            removed_by: 0x0,\r\n            // The new user will have to wait one delay before being\r\n            // able to add a new user.\r\n            time_added_another_user: now\r\n        });\r\n        userAddresses.push(new_user);\r\n    }\r\n\r\n    // Removes a user. The sender must have a lower or equal delay\r\n    // as the user that she is trying to remove.\r\n    function removeUser(address userAddr)\r\n        public\r\n        onlyActiveUsersAllowed()\r\n    {\r\n        require(users[userAddr].time_added != 0);\r\n        require(users[userAddr].time_removed == 0);\r\n\r\n        User storage sender = users[msg.sender];\r\n        require(sender.delay <= users[userAddr].delay);\r\n\r\n        users[userAddr].removed_by = msg.sender;\r\n        users[userAddr].time_removed = now;\r\n    }\r\n}\r\n\r\ncontract TrustWalletFactory {\r\n    mapping (address => TrustWallet[]) public wallets;\r\n\r\n    function createWallet() public {\r\n        wallets[msg.sender].push(new TrustWallet(msg.sender));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"createWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TrustWalletFactory","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://35298088c899b9158e7eecd77d693eadc45df3377602630fbf811a8cea9286c3"}]}