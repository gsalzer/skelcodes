{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\ncontract Token {\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n}\r\ncontract LocalEthereumEscrows {\r\n    // The address of the arbitrator\r\n    // In the first version, this is always localethereum staff.\r\n    address public arbitrator;\r\n    address public owner;\r\n    address public relayer;\r\n    uint32 public requestCancellationMinimumTime;\r\n    uint256 public feesAvailableForWithdraw;\r\n\r\n    uint8 constant ACTION_SELLER_CANNOT_CANCEL = 0x01; // Called when marking as paid or calling a dispute as the buyer\r\n    uint8 constant ACTION_BUYER_CANCEL = 0x02;\r\n    uint8 constant ACTION_SELLER_CANCEL = 0x03;\r\n    uint8 constant ACTION_SELLER_REQUEST_CANCEL = 0x04;\r\n    uint8 constant ACTION_RELEASE = 0x05;\r\n    uint8 constant ACTION_DISPUTE = 0x06;\r\n\r\n    event Created(bytes32 _tradeHash);\r\n    event SellerCancelDisabled(bytes32 _tradeHash);\r\n    event SellerRequestedCancel(bytes32 _tradeHash);\r\n    event CancelledBySeller(bytes32 _tradeHash);\r\n    event CancelledByBuyer(bytes32 _tradeHash);\r\n    event Released(bytes32 _tradeHash);\r\n    event DisputeResolved(bytes32 _tradeHash);\r\n\r\n    struct Escrow {\r\n        // Set so we know the trade has already been created\r\n        bool exists;\r\n        // The timestamp in which the seller can cancel the trade if the buyer has not yet marked as paid. Set to 0 on marked paid or dispute\r\n        // 1 = unlimited cancel time\r\n        uint32 sellerCanCancelAfter;\r\n        // The total cost of gas spent by relaying parties. This amount will be\r\n        // refunded/paid to localethereum.com once the escrow is finished.\r\n        uint128 totalGasFeesSpentByRelayer;\r\n    }\r\n    // Mapping of active trades. Key is a hash of the trade data\r\n    mapping (bytes32 => Escrow) public escrows;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyArbitrator() {\r\n        require(msg.sender == arbitrator);\r\n        _;\r\n    }\r\n\r\n    function getRelayedSender(\r\n      bytes16 _tradeID, // The unique ID of the trade, generated by localethereum.com\r\n      uint8 _actionByte, // The desired action of the user, matching an ACTION_* constant\r\n      uint128 _maximumGasPrice, // The maximum gas price the user is willing to pay\r\n      uint8 _v, // Signature value\r\n      bytes32 _r, // Signature value\r\n      bytes32 _s // Signature value\r\n    ) view private returns (address) {\r\n        bytes32 _hash = keccak256(_tradeID, _actionByte, _maximumGasPrice);\r\n        if(tx.gasprice > _maximumGasPrice) return;\r\n        return ecrecover(_hash, _v, _r, _s);\r\n    }\r\n\r\n    function LocalEthereumEscrows() public {\r\n        /**\r\n         * Initialize the contract.\r\n         */\r\n        owner = msg.sender;\r\n        arbitrator = msg.sender;\r\n        relayer = msg.sender;\r\n        requestCancellationMinimumTime = 2 hours; // TODO\r\n    }\r\n\r\n    function getEscrowAndHash(\r\n      /**\r\n       * Hashes the values and returns the matching escrow object and trade hash.\r\n       * Returns an empty escrow struct and 0 _tradeHash if not found\r\n       */\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee\r\n    ) view private returns (Escrow, bytes32) {\r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value, _fee);\r\n        return (escrows[_tradeHash], _tradeHash);\r\n    }\r\n\r\n    function createEscrow(\r\n      /**\r\n       * Create a new escrow and add it to `escrows`.\r\n       * _tradeHash is created by hashing _tradeID, _seller, _buyer, _value and _fee variables. These variables must be supplied on future contract calls.\r\n       * v, r and s is the signature data supplied from the api. The sig is keccak256(_tradeHash, _paymentWindowInSeconds, _expiry).\r\n       */\r\n      bytes16 _tradeID, // The unique ID of the trade, generated by localethereum.com\r\n      address _seller, // The selling party of the trade\r\n      address _buyer, // The buying party of the trade\r\n      uint256 _value, // The ether amount being held in escrow\r\n      uint16 _fee, // The localethereum.com fee in 1/10000ths\r\n      uint32 _paymentWindowInSeconds, // The time in seconds from contract creation that the buyer has to mark as paid\r\n      uint32 _expiry, // Provided by localethereum.com. This transaction must be created before this time.\r\n      uint8 _v, // Signature value\r\n      bytes32 _r, // Signature value\r\n      bytes32 _s // Signature value\r\n    ) payable external {\r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value, _fee);\r\n        require(!escrows[_tradeHash].exists); // Require that trade does not already exist\r\n        require(ecrecover(keccak256(_tradeHash, _paymentWindowInSeconds, _expiry), _v, _r, _s) == relayer); // Signature must have come from the relayer\r\n        require(block.timestamp < _expiry);\r\n        require(msg.value == _value && msg.value > 0); // Check sent eth against signed _value and make sure is not 0\r\n        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0 ? 1 : uint32(block.timestamp) + _paymentWindowInSeconds;\r\n        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\r\n        Created(_tradeHash);\r\n    }\r\n\r\n    uint16 constant GAS_doRelease = 36100;\r\n    function doRelease(\r\n      /**\r\n       * Called by the seller to releases the funds for a successful trade.\r\n       * Deletes the trade from the `escrows` mapping.\r\n       */\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee,\r\n      uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? GAS_doRelease + _additionalGas : 0);\r\n        delete escrows[_tradeHash];\r\n        Released(_tradeHash);\r\n        transferMinusFees(_buyer, _value, _gasFees, _fee);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doDisableSellerCancel = 12100;\r\n    function doDisableSellerCancel(\r\n      /**\r\n       * Stops the seller from cancelling the trade.\r\n       * Can only be called the buyer.\r\n       * Used to mark the trade as paid, or if the buyer has a dispute.\r\n       */\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee,\r\n      uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        if(_escrow.sellerCanCancelAfter == 0) return false;\r\n        escrows[_tradeHash].sellerCanCancelAfter = 0;\r\n        SellerCancelDisabled(_tradeHash);\r\n        if (msg.sender == relayer) {\r\n          increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doBuyerCancel = 36100;\r\n    function doBuyerCancel(\r\n      /**\r\n       * Cancels the trade and returns the ether to the seller.\r\n       * Can only be called the buyer.\r\n       */\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee,\r\n      uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? GAS_doBuyerCancel + _additionalGas : 0);\r\n        delete escrows[_tradeHash];\r\n        CancelledByBuyer(_tradeHash);\r\n        transferMinusFees(_seller, _value, _gasFees, 0);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doSellerCancel = 36100;\r\n    function doSellerCancel(\r\n      /**\r\n       * Cancels the trade and returns the ether to the seller.\r\n       * Can only be called the seller.\r\n       * Can only be called if the payment window was missed by the buyer\r\n       */\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee,\r\n      uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) return false;\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? GAS_doSellerCancel + _additionalGas : 0);\r\n        delete escrows[_tradeHash];\r\n        CancelledBySeller(_tradeHash);\r\n        transferMinusFees(_seller, _value, _gasFees, 0);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doSellerRequestCancel = 12100;\r\n    function doSellerRequestCancel(\r\n      /**\r\n       * Called by the seller if the buyer is unresponsive\r\n       * Can only be called on unlimited payment window trades (sellerCanCancelAfter == 1)\r\n       * Sets the payment window to `requestCancellationMinimumTime` from now, in which it can be cancelled.\r\n       */\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee,\r\n      uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        // Called on unlimited payment window trades wheret the buyer is not responding\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        if(_escrow.sellerCanCancelAfter != 1) return false;\r\n        escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp) + requestCancellationMinimumTime;\r\n        SellerRequestedCancel(_tradeHash);\r\n        if (msg.sender == relayer) {\r\n          increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doResolveDispute = 36100;\r\n    function resolveDispute(\r\n      /**\r\n       * Called by the arbitrator to resolve a dispute\r\n       * Requires the signed ACTION_DISPUTE actionByte from either the buyer or the seller\r\n       */\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee,\r\n      uint8 _v,\r\n      bytes32 _r,\r\n      bytes32 _s,\r\n      uint8 _buyerPercent\r\n    ) external onlyArbitrator {\r\n        address _signature = ecrecover(keccak256(_tradeID, ACTION_DISPUTE), _v, _r, _s);\r\n        require(_signature == _buyer || _signature == _seller);\r\n\r\n        var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        require(_escrow.exists);\r\n        require(_buyerPercent <= 100);\r\n\r\n        uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + GAS_doResolveDispute;\r\n        require(_value - _totalFees <= _value); // Prevent underflow\r\n        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw\r\n\r\n        delete escrows[_tradeHash];\r\n        DisputeResolved(_tradeHash);\r\n        _buyer.transfer((_value - _totalFees) * _buyerPercent / 100);\r\n        _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);\r\n    }\r\n\r\n    function release(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool){\r\n      require(msg.sender == _seller);\r\n      return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n    function disableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\r\n      require(msg.sender == _buyer);\r\n      return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n    function buyerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\r\n      require(msg.sender == _buyer);\r\n      return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n    function sellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\r\n      require(msg.sender == _seller);\r\n      return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n    function sellerRequestCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {\r\n      require(msg.sender == _seller);\r\n      return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    function relaySellerCannotCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_CANNOT_CANCEL, 0);\r\n    }\r\n    function relayBuyerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_BUYER_CANCEL, 0);\r\n    }\r\n    function relayRelease(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_RELEASE, 0);\r\n    }\r\n    function relaySellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_CANCEL, 0);\r\n    }\r\n    function relaySellerRequestCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {\r\n      return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_REQUEST_CANCEL, 0);\r\n    }\r\n\r\n    function relay(\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee,\r\n      uint128 _maximumGasPrice,\r\n      uint8 _v,\r\n      bytes32 _r,\r\n      bytes32 _s,\r\n      uint8 _actionByte,\r\n      uint128 _additionalGas\r\n    ) private returns (bool) {\r\n      address _relayedSender = getRelayedSender(_tradeID, _actionByte, _maximumGasPrice, _v, _r, _s);\r\n      if (_relayedSender == _buyer) {\r\n        if (_actionByte == ACTION_SELLER_CANNOT_CANCEL) {\r\n          return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n        } else if (_actionByte == ACTION_BUYER_CANCEL) {\r\n          return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n        }\r\n      } else if (_relayedSender == _seller) {\r\n        if (_actionByte == ACTION_RELEASE) {\r\n          return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n        } else if (_actionByte == ACTION_SELLER_CANCEL) {\r\n          return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n        } else if (_actionByte == ACTION_SELLER_REQUEST_CANCEL){\r\n          return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    uint16 constant GAS_batchRelayBaseCost = 28500;\r\n    function batchRelay(\r\n      /**\r\n       * Call multiple relay methods at once to save on gas.\r\n       */\r\n        bytes16[] _tradeID,\r\n        address[] _seller,\r\n        address[] _buyer,\r\n        uint256[] _value,\r\n        uint16[] _fee,\r\n        uint128[] _maximumGasPrice,\r\n        uint8[] _v,\r\n        bytes32[] _r,\r\n        bytes32[] _s,\r\n        uint8[] _actionByte\r\n    ) public returns (bool[]) {\r\n        bool[] memory _results = new bool[](_tradeID.length);\r\n        uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0);\r\n        for (uint8 i=0; i<_tradeID.length; i++) {\r\n            _results[i] = relay(_tradeID[i], _seller[i], _buyer[i], _value[i], _fee[i], _maximumGasPrice[i], _v[i], _r[i], _s[i], _actionByte[i], _additionalGas);\r\n        }\r\n        return _results;\r\n    }\r\n\r\n    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\r\n        /** Increase `totalGasFeesSpentByRelayer` to be charged later on completion of the trade.\r\n         */\r\n        escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);\r\n    }\r\n\r\n    function transferMinusFees(address _to, uint256 _value, uint128 _totalGasFeesSpentByRelayer, uint16 _fee) private {\r\n        uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;\r\n        if(_value - _totalFees > _value) return; // Prevent underflow\r\n        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw\r\n        _to.transfer(_value - _totalFees);\r\n    }\r\n\r\n    function withdrawFees(address _to, uint256 _amount) onlyOwner external {\r\n      /**\r\n       * Withdraw fees collected by the contract. Only the owner can call this.\r\n       */\r\n        require(_amount <= feesAvailableForWithdraw); // Also prevents underflow\r\n        feesAvailableForWithdraw -= _amount;\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    function setArbitrator(address _newArbitrator) onlyOwner external {\r\n        /**\r\n         * Set the arbitrator to a new address. Only the owner can call this.\r\n         * @param address _newArbitrator\r\n         */\r\n        arbitrator = _newArbitrator;\r\n    }\r\n\r\n    function setOwner(address _newOwner) onlyOwner external {\r\n        /**\r\n         * Change the owner to a new address. Only the owner can call this.\r\n         * @param address _newOwner\r\n         */\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function setRelayer(address _newRelayer) onlyOwner external {\r\n        /**\r\n         * Change the relayer to a new address. Only the owner can call this.\r\n         * @param address _newRelayer\r\n         */\r\n        relayer = _newRelayer;\r\n    }\r\n\r\n    function setRequestCancellationMinimumTime(uint32 _newRequestCancellationMinimumTime) onlyOwner external {\r\n        /**\r\n         * Change the requestCancellationMinimumTime. Only the owner can call this.\r\n         * @param uint32 _newRequestCancellationMinimumTime\r\n         */\r\n        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\r\n    }\r\n\r\n    function transferToken(Token _tokenContract, address _transferTo, uint256 _value) onlyOwner external {\r\n        /**\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\n         */\r\n         _tokenContract.transfer(_transferTo, _value);\r\n    }\r\n    function transferTokenFrom(Token _tokenContract, address _transferTo, address _transferFrom, uint256 _value) onlyOwner external {\r\n        /**\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\n         */\r\n         _tokenContract.transferFrom(_transferTo, _transferFrom, _value);\r\n    }\r\n    function approveToken(Token _tokenContract, address _spender, uint256 _value) onlyOwner external {\r\n        /**\r\n         * If ERC20 tokens are sent to this contract, they will be trapped forever.\r\n         * This function is way for us to withdraw them so we can get them back to their rightful owner\r\n         */\r\n         _tokenContract.approve(_spender, _value);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_maximumGasPrice\",\"type\":\"uint128\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"relaySellerRequestCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequestCancellationMinimumTime\",\"type\":\"uint32\"}],\"name\":\"setRequestCancellationMinimumTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_buyerPercent\",\"type\":\"uint8\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"buyerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"escrows\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"sellerCanCancelAfter\",\"type\":\"uint32\"},{\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_maximumGasPrice\",\"type\":\"uint128\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"relaySellerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"sellerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_maximumGasPrice\",\"type\":\"uint128\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"relayRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestCancellationMinimumTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"disableSellerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRelayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"sellerRequestCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbitrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16[]\"},{\"name\":\"_seller\",\"type\":\"address[]\"},{\"name\":\"_buyer\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"},{\"name\":\"_fee\",\"type\":\"uint16[]\"},{\"name\":\"_maximumGasPrice\",\"type\":\"uint128[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"name\":\"_actionByte\",\"type\":\"uint8[]\"}],\"name\":\"batchRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_maximumGasPrice\",\"type\":\"uint128\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"relaySellerCannotCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newArbitrator\",\"type\":\"address\"}],\"name\":\"setArbitrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_maximumGasPrice\",\"type\":\"uint128\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"relayBuyerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feesAvailableForWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_transferTo\",\"type\":\"address\"},{\"name\":\"_transferFrom\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokenFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_paymentWindowInSeconds\",\"type\":\"uint32\"},{\"name\":\"_expiry\",\"type\":\"uint32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"createEscrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_transferTo\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerCancelDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerRequestedCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"CancelledBySeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"CancelledByBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"DisputeResolved\",\"type\":\"event\"}]","ContractName":"LocalEthereumEscrows","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://edf657bb29033675b97aeac99ca3cc4a832a1d85d19449dc6bd9cd60aa2e305e"}]}