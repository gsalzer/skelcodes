{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n  * account.\r\n  */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the owner.\r\n  */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n  * @param newOwner The address to transfer ownership to.\r\n  */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n* @title Authorizable\r\n* @dev The Authorizable contract has authorized addresses, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"multiple user permissions\".\r\n*/\r\ncontract Authorizable is Ownable {\r\nmapping(address => bool) public authorized;\r\n\r\nevent AuthorizationSet(address indexed addressAuthorized, bool indexed authorization);\r\n\r\n/**\r\n* @dev The Authorizable constructor sets the first `authorized` of the contract to the sender\r\n* account.\r\n*/\r\nfunction Authorizable() public {\r\n  AuthorizationSet(msg.sender, true);\r\n    authorized[msg.sender] = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the authorized.\r\n  */\r\n  modifier onlyAuthorized() {\r\n    require(authorized[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the current owner to set an authorization.\r\n  * @param addressAuthorized The address to change authorization.\r\n  */\r\n  function setAuthorized(address addressAuthorized, bool authorization) public onlyOwner {\r\n    require(authorized[addressAuthorized] != authorization);\r\n    AuthorizationSet(addressAuthorized, authorization);\r\n    authorized[addressAuthorized] = authorization;\r\n  }\r\n}\r\n\r\n/**\r\n* @title WhiteList\r\n* @dev The WhiteList contract has whiteListed addresses, and provides basic whiteListStatus control\r\n* functions, this simplifies the implementation of \"multiple user permissions\".\r\n*/\r\ncontract WhiteList is Authorizable {\r\n  mapping(address => bool) whiteListed;\r\n\r\n  event WhiteListSet(address indexed addressWhiteListed, bool indexed whiteListStatus);\r\n\r\n  /**\r\n  * @dev The WhiteList constructor sets the first `whiteListed` of the contract to the sender\r\n  * account.\r\n  */\r\n  function WhiteList() public {\r\n    WhiteListSet(msg.sender, true);\r\n    whiteListed[msg.sender] = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the whiteListed.\r\n  */\r\n  modifier onlyWhiteListed() {\r\n    require(whiteListed[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function isWhiteListed(address _address) public view returns (bool) {\r\n    return whiteListed[_address];\r\n  }\r\n\r\n  /**\r\n  * @dev Allows the current owner to set an whiteListStatus.\r\n  * @param addressWhiteListed The address to change whiteListStatus.\r\n  */\r\n  function setWhiteListed(address addressWhiteListed, bool whiteListStatus) public onlyAuthorized {\r\n    require(whiteListed[addressWhiteListed] != whiteListStatus);\r\n    WhiteListSet(addressWhiteListed, whiteListStatus);\r\n    whiteListed[addressWhiteListed] = whiteListStatus;\r\n  }\r\n}\r\n\r\n/**\r\n* @title ERC20Basic\r\n* @dev Simpler version of ERC20 interface\r\n* @dev see https://github.com/ethereum/EIPs/issues/179\r\n*/\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n* @title ERC20 interface\r\n* @dev see https://github.com/ethereum/EIPs/issues/20\r\n*/\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n* @title Basic token\r\n* @dev Basic version of StandardToken, with no allowances.\r\n*/\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\n/**\r\n* @title Standard ERC20 token\r\n*\r\n* @dev Implementation of the basic standard token.\r\n* @dev https://github.com/ethereum/EIPs/issues/20\r\n* @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n*/\r\ncontract StandardToken is ERC20, BasicToken {\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /**\r\n  * @dev Transfer tokens from one address to another\r\n  * @param _from address The address which you want to send tokens from\r\n  * @param _to address The address which you want to transfer to\r\n  * @param _value uint256 the amount of tokens to be transferred\r\n  */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n  *\r\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n  * @param _spender The address which will spend the funds.\r\n  * @param _value The amount of tokens to be spent.\r\n  */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n  * @param _owner address The address which owns the funds.\r\n  * @param _spender address The address which will spend the funds.\r\n  * @return A uint256 specifying the amount of tokens still available for the spender.\r\n  */\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n  * approve should be called when allowed[_spender] == 0. To increment\r\n  * allowed value is better to use this function to avoid 2 calls (and wait until\r\n  * the first transaction is mined)\r\n  * From MonolithDAO Token.sol\r\n  */\r\n  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract TreasureBox {\r\n  // ERC20 basic token contract being held\r\n  StandardToken token;\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n  // timestamp where token release is enabled\r\n  uint public releaseTime;\r\n\r\n  function TreasureBox(StandardToken _token, address _beneficiary, uint _releaseTime) public {\r\n    require(_beneficiary != address(0));\r\n    token = StandardToken(_token);\r\n    beneficiary = _beneficiary;\r\n    releaseTime = _releaseTime;\r\n  }\r\n\r\n  function claim() external {\r\n    require(available());\r\n    require(amount() > 0);\r\n    token.transfer(beneficiary, amount());\r\n  }\r\n\r\n  function available() public view returns (bool) {\r\n    return (now >= releaseTime);\r\n  }\r\n\r\n  function amount() public view returns (uint256) {\r\n    return token.balanceOf(this);\r\n  }\r\n}\r\n\r\ncontract AirDropper is Authorizable {\r\n  mapping(address => bool) public isAnExchanger; // allow to airdrop to destination is exchanger with out minimum\r\n  mapping(address => bool) public isTreasureBox; // flag who not eligible airdrop\r\n  mapping(address => address) public airDropDestinations; // setTo 0x0 if want airdrop to self\r\n\r\n  StandardToken token;\r\n\r\n  event SetDestination(address _address, address _destination);\r\n  event SetExchanger(address _address, bool _isExchanger);\r\n\r\n  function AirDropper(StandardToken _token) public {\r\n    token = _token;\r\n  }\r\n\r\n  function getToken() public view returns(StandardToken) {\r\n    return token;\r\n  }\r\n\r\n  /**\r\n  * set _destination to 0x0 if want to self airdrop\r\n  */\r\n  function setAirDropDestination(address _destination) external {\r\n    require(_destination != msg.sender);\r\n    airDropDestinations[msg.sender] = _destination;\r\n    SetDestination(msg.sender, _destination);\r\n  }\r\n\r\n  function setTreasureBox (address _address, bool _status) public onlyAuthorized {\r\n    require(_address != address(0));\r\n    require(isTreasureBox[_address] != _status);\r\n    isTreasureBox[_address] = _status;\r\n  }\r\n\r\n  function setExchanger(address _address, bool _isExchanger) external onlyAuthorized {\r\n    require(_address != address(0));\r\n    require(isAnExchanger[_address] != _isExchanger);\r\n    isAnExchanger[_address] = _isExchanger;\r\n    SetExchanger(_address, _isExchanger);\r\n  }\r\n\r\n  /**\r\n  * help fix airdrop when holder > 100\r\n  * but need to calculate outer\r\n  */\r\n  function multiTransfer(address[] _address, uint[] _value) public returns (bool) {\r\n    for (uint i = 0; i < _address.length; i++) {\r\n      token.transferFrom(msg.sender, _address[i], _value[i]);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n* @title TemToken\r\n* @dev The main ZMINE token contract\r\n*\r\n* ABI\r\n* [{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startTrading\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]\r\n*/\r\ncontract ZMINE is StandardToken, Ownable {\r\n  string public name = \"ZMINE Token\";\r\n  string public symbol = \"ZMN\";\r\n  uint8 public decimals = 18;\r\n\r\n  uint256 public totalSupply = 1000000000000000000000000000; // 1,000,000,000 ^ 18\r\n\r\n  function ZMINE() public {\r\n    balances[owner] = totalSupply;\r\n    Transfer(address(0x0), owner, totalSupply);\r\n  }\r\n\r\n  /**\r\n  * burn token if token is not sold out after Public\r\n  */\r\n  function burn(uint _amount) external onlyOwner {\r\n    require(balances[owner] >= _amount);\r\n    balances[owner] = balances[owner] - _amount;\r\n    totalSupply = totalSupply - _amount;\r\n    Transfer(owner, address(0x0), _amount);\r\n  }\r\n}\r\n\r\ncontract RateContract is Authorizable {\r\n  uint public rate = 6000000000000000000000;\r\n\r\n  event UpdateRate(uint _oldRate, uint _newRate);\r\n\r\n  function updateRate(uint _rate) public onlyAuthorized {\r\n    require(rate != _rate);\r\n    UpdateRate(rate, _rate);\r\n    rate = _rate;\r\n  }\r\n\r\n  function getRate() public view returns (uint) {\r\n    return rate;\r\n  }\r\n}\r\n\r\ncontract FounderThreader is Ownable {\r\n  using SafeMath for uint;\r\n\r\n  event TokenTransferForFounder(address _recipient, uint _value, address box1, address box2);\r\n\r\n  AirDropper public airdropper;\r\n\r\n  uint public hardCap = 300000000000000000000000000; // 300 000 000 * 1e18\r\n  uint public remain = 300000000000000000000000000; // 300 000 000 * 1e18\r\n\r\n  uint public minTx = 100000000000000000000; // 100 * 1e18\r\n\r\n  mapping(address => bool) isFounder;\r\n\r\n  function FounderThreader (AirDropper _airdropper, address[] _founders) public {\r\n    airdropper = AirDropper(_airdropper);\r\n    for (uint i = 0; i < _founders.length; i++) {\r\n      isFounder[_founders[i]] = true;\r\n    }\r\n  }\r\n\r\n  function transferFor(address _recipient, uint _tokens) external onlyOwner {\r\n    require(_recipient != address(0));\r\n    require(_tokens >= minTx);\r\n    require(isFounder[_recipient]);\r\n\r\n    StandardToken token = StandardToken(airdropper.getToken());\r\n\r\n    TreasureBox box1 = new TreasureBox(token, _recipient, 1533088800); // can open 2018-08-01 09+07:00\r\n    TreasureBox box2 = new TreasureBox(token, _recipient, 1548986400); // can open 2019-02-01 09+07:00\r\n\r\n    airdropper.setTreasureBox(box1, true);\r\n    airdropper.setTreasureBox(box2, true);\r\n\r\n    token.transferFrom(owner, _recipient, _tokens.mul(33).div(100)); // 33 % for now\r\n    token.transferFrom(owner, box1, _tokens.mul(33).div(100)); // 33 % for box1\r\n    token.transferFrom(owner, box2, _tokens.mul(34).div(100)); // 34 % for box2\r\n\r\n    remain = remain.sub(_tokens);\r\n\r\n    TokenTransferForFounder(_recipient, _tokens, box1, box2);\r\n  }\r\n}\r\n\r\ncontract PreSale is Ownable {\r\n  using SafeMath for uint;\r\n\r\n  event TokenSold(address _recipient, uint _value, uint _tokens, uint _rate);\r\n  event TokenSold(address _recipient, uint _tokens);\r\n\r\n  ZMINE public token;\r\n  WhiteList whitelist;\r\n\r\n  uint public hardCap = 300000000000000000000000000; // 300 000 000 * 1e18\r\n  uint public remain = 300000000000000000000000000; // 300 000 000 * 1e18\r\n\r\n  uint public startDate = 1512525600; // 2017-12-06 09+07:00\r\n  uint public stopDate = 1517364000;  // 2018-01-31 09+07:00\r\n\r\n  uint public minTx = 100000000000000000000; // 100 * 1e18\r\n  uint public maxTx = 100000000000000000000000; // 100 000 * 1e18\r\n\r\n  RateContract rateContract;\r\n\r\n  function PreSale (ZMINE _token, RateContract _rateContract, WhiteList _whitelist) public {\r\n    token = ZMINE(_token);\r\n    rateContract = RateContract(_rateContract);\r\n    whitelist = WhiteList(_whitelist);\r\n  }\r\n\r\n  /**\r\n  * transfer token to presale investor who pay by cash\r\n  */\r\n  function transferFor(address _recipient, uint _tokens) external onlyOwner {\r\n    require(_recipient != address(0));\r\n    require(available());\r\n\r\n    remain = remain.sub(_tokens);\r\n    token.transferFrom(owner, _recipient, _tokens);\r\n\r\n    TokenSold(_recipient, _tokens);\r\n  }\r\n\r\n  function sale(address _recipient, uint _value, uint _rate) private {\r\n    require(_recipient != address(0));\r\n    require(available());\r\n    require(isWhiteListed(_recipient));\r\n    require(_value >= minTx && _value <= maxTx);\r\n    uint tokens = _rate.mul(_value).div(1000000000000000000);\r\n\r\n    remain = remain.sub(tokens);\r\n    token.transferFrom(owner, _recipient, tokens);\r\n    owner.transfer(_value);\r\n\r\n    TokenSold(_recipient, _value, tokens, _rate);\r\n  }\r\n\r\n  function rate() public view returns (uint) {\r\n    return rateContract.getRate();\r\n  }\r\n\r\n  function available() public view returns (bool) {\r\n    return (now > startDate && now < stopDate);\r\n  }\r\n\r\n  function isWhiteListed(address _address) public view returns (bool) {\r\n    return whitelist.isWhiteListed(_address);\r\n  }\r\n\r\n  function() external payable {\r\n    sale(msg.sender, msg.value, rate());\r\n  }\r\n}\r\n\r\ncontract PublicSale is Ownable {\r\n  using SafeMath for uint;\r\n\r\n  event TokenSold(address _recipient, uint _value, uint _tokens, uint _rate);\r\n  event IncreaseHardCap(uint _amount);\r\n\r\n  ZMINE public token;\r\n\r\n  WhiteList whitelistPublic;\r\n  WhiteList whitelistPRE;\r\n\r\n  uint public hardCap = 400000000000000000000000000; // 400 000 000 * 1e18\r\n  uint public remain = 400000000000000000000000000; // 400 000 000 * 1e18\r\n\r\n  uint public startDate = 1515376800; // 2018-01-08 09+07:00\r\n  uint public stopDate = 1517364000;  // 2018-01-31 09+07:00\r\n\r\n  uint public minTx = 1000000000000000000; // 1e18\r\n  uint public maxTx = 100000000000000000000000; // 100 000 1e18\r\n\r\n  RateContract rateContract;\r\n\r\n  function PublicSale(ZMINE _token, RateContract _rateContract, WhiteList _whitelistPRE, WhiteList _whitelistPublic) public {\r\n    token = ZMINE(_token);\r\n    rateContract = RateContract(_rateContract);\r\n    whitelistPRE = WhiteList(_whitelistPRE);\r\n    whitelistPublic = WhiteList(_whitelistPublic);\r\n  }\r\n\r\n  /**\r\n  * increase hard cap if previous dont sold out\r\n  */\r\n  function increaseHardCap(uint _amount) external onlyOwner {\r\n    require(_amount <= 300000000000000000000000000); // presale hard cap\r\n    hardCap = hardCap.add(_amount);\r\n    remain = remain.add(_amount);\r\n    IncreaseHardCap(_amount);\r\n  }\r\n\r\n  function sale(address _recipient, uint _value, uint _rate) private {\r\n    require(available());\r\n    require(isWhiteListed(_recipient));\r\n    require(_value >= minTx && _value <= maxTx);\r\n    uint tokens = _rate.mul(_value).div(1000000000000000000);\r\n\r\n    remain = remain.sub(tokens);\r\n    token.transferFrom(owner, _recipient, tokens);\r\n    owner.transfer(_value);\r\n\r\n    TokenSold(_recipient, _value, tokens, _rate);\r\n  }\r\n\r\n  function rate() public view returns (uint) {\r\n    return rateContract.getRate();\r\n  }\r\n\r\n  function available () public view returns (bool) {\r\n    return (now > startDate && now < stopDate);\r\n  }\r\n\r\n  function isWhiteListed (address _address) public view returns(bool) {\r\n    return (whitelistPRE.isWhiteListed(_address) || (whitelistPublic.isWhiteListed(_address)));\r\n  }\r\n\r\n  function() external payable {\r\n    sale(msg.sender, msg.value, rate());\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"ZMINE","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0b44f79defaf272977d67da7daa08a91a66f0bb7ca7cedbc70e75f1e2b7af216"}]}