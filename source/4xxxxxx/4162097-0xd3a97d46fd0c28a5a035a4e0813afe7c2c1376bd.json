{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ninterface OraclizeI {\r\n    // address public cbAddress;\r\n    function cbAddress() constant returns (address); // Reads public variable cbAddress \r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasoaurce) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n    function randomDS_getSessionPubKeyHash() returns(bytes32);\r\n}\r\n\r\ninterface OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\n\r\n// this is a reduced and optimize version of the usingOracalize contract in https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\r\ncontract myUsingOracalize is Ownable {\r\n    OraclizeAddrResolverI OAR;\r\n    OraclizeI public oraclize;\r\n    uint public oracalize_gaslimit = 100000;\r\n\r\n    function myUsingOracalize() {\r\n        oraclize_setNetwork();\r\n        update_oracalize();\r\n    }\r\n\r\n    function update_oracalize() public {\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n    }\r\n    \r\n    function oraclize_query(string datasource, string arg1, string arg2) internal returns (bytes32 id) {\r\n        uint price = oraclize.getPrice(datasource, oracalize_gaslimit);\r\n        if (price > 1 ether + tx.gasprice*oracalize_gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, oracalize_gaslimit);\r\n    }\r\n    \r\n    function oraclize_getPrice(string datasource) internal returns (uint) {\r\n        return oraclize.getPrice(datasource, oracalize_gaslimit);\r\n    }\r\n\r\n    function setGasLimit(uint _newLimit) onlyOwner public {\r\n        oracalize_gaslimit = _newLimit;\r\n    }\r\n    \r\n    function oraclize_setNetwork() internal {\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n        }\r\n        else if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n        }\r\n        else if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n        }\r\n        else if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n        }\r\n        else if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n        }\r\n        else if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n        }\r\n        else if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n        }\r\n        else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n        return _size;\r\n    }\r\n\r\n    // This will not throw error on wrong input, but instead consume large and unknown amount of gas\r\n    // This should never occure as it's use with the ShapeShift deposit return value is checked before calling function\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n}\r\n\r\n/// @title Inter-crypto currency converter\r\n/// @author Jack Tanner - <jnt16@ic.ac.uk>\r\ncontract InterCrypto is Ownable, myUsingOracalize {\r\n    // _______________VARIABLES_______________\r\n    struct Transaction {\r\n        address returnAddress;\r\n        uint amount;\r\n    }\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    uint transactionCount = 0;\r\n    mapping (bytes32 => uint) oracalizeMyId2transactionID;\r\n    mapping (address => uint) public recoverable;\r\n\r\n    // _______________EVENTS_______________\r\n    event TransactionStarted(uint indexed transactionID);\r\n    event TransactionSentToShapeShift(uint indexed transactionID, address indexed returnAddress, address indexed depositAddress, uint amount);\r\n    event TransactionAborted(uint indexed transactionID, string reason);\r\n    event Recovered(address indexed recoveredTo, uint amount);\r\n\r\n    // _______________EXTERNAL FUNCTIONS_______________\r\n    // constructor\r\n    function InterCrypto() {}\r\n\r\n    // suicide function\r\n    function kill() onlyOwner external {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // Default function which will accept Ether\r\n    function () payable {}\r\n\r\n    // Return the price of using Oracalize\r\n    function getInterCryptoPrice() constant public returns (uint) {\r\n        return oraclize_getPrice('URL');\r\n    }\r\n\r\n    // Create a cryptocurrency conversion using Oracalize and Shapeshift return address = msg.sender\r\n    function sendToOtherBlockchain1(string _coinSymbol, string _toAddress) external payable returns(uint) {\r\n        return engine(_coinSymbol, _toAddress, msg.sender);\r\n    }\r\n    \r\n    // Create a cryptocurrency conversion using Oracalize and custom Shapeshift return address\r\n    function sendToOtherBlockchain2(string _coinSymbol, string _toAddress, address _returnAddress) external payable returns(uint) {\r\n        return engine(_coinSymbol, _toAddress, _returnAddress);\r\n    }\r\n\r\n    // Callback function for Oracalize\r\n    function __callback(bytes32 myid, string result) {\r\n        if (msg.sender != oraclize.cbAddress()) revert();\r\n\r\n        uint transactionID = oracalizeMyId2transactionID[myid];\r\n        Transaction memory transaction = transactions[transactionID];\r\n        \r\n        if( bytes(result).length == 0 ) {\r\n            TransactionAborted(transactionID, \"Oracalize return value was invalid, this is probably due to incorrect sendToOtherBlockchain() argments\");\r\n            recoverable[transaction.returnAddress] += transaction.amount;\r\n            transaction.amount = 0;\r\n        }\r\n        else {\r\n            address depositAddress = parseAddr(result);\r\n            require(depositAddress != msg.sender); // prevent DAO tpe recursion hack that can potentially be done by oracalize\r\n            uint sendAmount = transaction.amount;\r\n            transaction.amount = 0;\r\n            if (depositAddress.send(sendAmount))\r\n                TransactionSentToShapeShift(transactionID, transaction.returnAddress, depositAddress, sendAmount);\r\n            else {\r\n                TransactionAborted(transactionID, \"transaction to address returned by Oracalize failed\");\r\n                recoverable[transaction.returnAddress] += sendAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Cancel a transaction that has not been completed\r\n    // Note that this should only be required if Oracalize should fail to respond\r\n    function cancelTransaction(uint transactionID) external {\r\n        Transaction memory transaction = transactions[transactionID];\r\n        \r\n        if (transaction.amount > 0) {\r\n            require(msg.sender == transaction.returnAddress);\r\n            recoverable[msg.sender] += transaction.amount;\r\n            transaction.amount = 0;\r\n            TransactionAborted(transactionID, \"transaction cancelled by creator\");\r\n        }\r\n    }\r\n\r\n    // Send any pending funds back to their owner\r\n    function recover() external {\r\n        uint amount = recoverable[msg.sender];\r\n        recoverable[msg.sender] = 0;\r\n        if (msg.sender.send(amount)) {\r\n            Recovered(msg.sender, amount);\r\n        }\r\n        else {\r\n            recoverable[msg.sender] = amount;\r\n        }\r\n    }\r\n    // _______________PUBLIC FUNCTIONS_______________\r\n\r\n\r\n    // _______________INTERNAL FUNCTIONS_______________\r\n    // Request for a ShapeShift transaction to be made\r\n    function engine(string _coinSymbol, string _toAddress, address _returnAddress) internal returns(uint transactionID) {\r\n        // Example arguments:\r\n        // \"ltc\", \"LbZcDdMeP96ko85H21TQii98YFF9RgZg3D\"   Litecoin\r\n        // \"btc\", \"1L8oRijgmkfcZDYA21b73b6DewLtyYs87s\"   Bitcoin\r\n        // \"dash\", \"Xoopows17idkTwNrMZuySXBwQDorsezQAx\"  Dash\r\n        // \"zec\", \"t1N7tf1xRxz5cBK51JADijLDWS592FPJtya\"  ZCash\r\n        // \"doge\", \"DMAFvwTH2upni7eTau8au6Rktgm2bUkMei\"   Dogecoin\r\n        // See https://info.shapeshift.io/about\r\n        // Test symbol pairs using ShapeShift API (shapeshift.io/validateAddress/[address]/[coinSymbol]) or by creating a test\r\n        // transaction first whenever possible before using it with InterCrypto\r\n        \r\n        transactionID = transactionCount++;\r\n\r\n        if (!isValidateParameter(_coinSymbol, 6) || !isValidateParameter(_toAddress, 120)) { // Waves smbol is \"waves\" , Monero integrated addresses are 106 characters\r\n            TransactionAborted(transactionID, \"input parameters are too long or contain invalid symbols\");\r\n            recoverable[msg.sender] += msg.value;\r\n            return;\r\n        }\r\n        \r\n        uint oracalizePrice = getInterCryptoPrice();\r\n\r\n        if (msg.value > oracalizePrice) {\r\n            Transaction memory transaction = Transaction(_returnAddress, msg.value-oracalizePrice);\r\n            transactions[transactionID] = transaction;\r\n            \r\n            // Create post data string like ' {\"withdrawal\":\"LbZcDdMeP96ko85H21TQii98YFF9RgZg3D\",\"pair\":\"eth_ltc\",\"returnAddress\":\"558999ff2e0daefcb4fcded4c89e07fdf9ccb56c\"}'\r\n            string memory postData = createShapeShiftTransactionPost(_coinSymbol, _toAddress);\r\n\r\n            // TODO: send custom gasLimit for retrn transaction equal to the exact cost of __callback. Note that this should only be donewhen the contract is finalized\r\n            bytes32 myQueryId = oraclize_query(\"URL\", \"json(https://shapeshift.io/shift).deposit\", postData);\r\n            \r\n            if (myQueryId == 0) {\r\n                TransactionAborted(transactionID, \"unexpectedly high Oracalize price when calling oracalize_query\");\r\n                recoverable[msg.sender] += msg.value-oracalizePrice;\r\n                transaction.amount = 0;\r\n                return;\r\n            }\r\n            oracalizeMyId2transactionID[myQueryId] = transactionID;\r\n            TransactionStarted(transactionID);\r\n        }\r\n        else {\r\n            TransactionAborted(transactionID, \"Not enough Ether sent to cover Oracalize fee\");\r\n            // transactions[transactionID].amount = 0;\r\n            recoverable[msg.sender] += msg.value;\r\n        }\r\n    }\r\n    \r\n    // Adapted from https://github.com/kieranelby/KingOfTheEtherThrone/blob/master/contracts/KingOfTheEtherThrone.sol\r\n    function isValidateParameter(string _parameter, uint maxSize) constant internal returns (bool allowed) {\r\n        bytes memory parameterBytes = bytes(_parameter);\r\n        uint lengthBytes = parameterBytes.length;\r\n        if (lengthBytes < 1 ||\r\n            lengthBytes > maxSize) {\r\n            return false;\r\n        }\r\n        \r\n        for (uint i = 0; i < lengthBytes; i++) {\r\n            byte b = parameterBytes[i];\r\n            if ( !(\r\n                (b >= 48 && b <= 57) || // 0 - 9\r\n                (b >= 65 && b <= 90) || // A - Z\r\n                (b >= 97 && b <= 122)   // a - z\r\n            )) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function concatBytes(bytes b1, bytes b2, bytes b3, bytes b4, bytes b5, bytes b6, bytes b7) internal returns (bytes bFinal) {\r\n        bFinal = new bytes(b1.length + b2.length + b3.length + b4.length + b5.length + b6.length + b7.length);\r\n\r\n        uint i = 0;\r\n        uint j;\r\n        for (j = 0; j < b1.length; j++) bFinal[i++] = b1[j];\r\n        for (j = 0; j < b2.length; j++) bFinal[i++] = b2[j];\r\n        for (j = 0; j < b3.length; j++) bFinal[i++] = b3[j];\r\n        for (j = 0; j < b4.length; j++) bFinal[i++] = b4[j];\r\n        for (j = 0; j < b5.length; j++) bFinal[i++] = b5[j];\r\n        for (j = 0; j < b6.length; j++) bFinal[i++] = b6[j];\r\n        for (j = 0; j < b7.length; j++) bFinal[i++] = b7[j];\r\n    }\r\n\r\n    function createShapeShiftTransactionPost(string _coinSymbol, string _toAddress) internal returns (string sFinal) {\r\n        string memory s1 = ' {\"withdrawal\":\"';\r\n        string memory s3 = '\",\"pair\":\"eth_';\r\n        string memory s5 = '\",\"returnAddress\":\"';\r\n        string memory s7 = '\"}';\r\n\r\n        bytes memory bFinal = concatBytes(bytes(s1), bytes(_toAddress), bytes(s3), bytes(_coinSymbol), bytes(s5), bytes(addressToBytes(msg.sender)), bytes(s7));\r\n\r\n        sFinal = string(bFinal);\r\n    }\r\n\r\n        // Authored by https://github.com/axic\r\n    function nibbleToChar(uint nibble) internal returns (uint ret) {\r\n        if (nibble > 9)\r\n        return nibble + 87; // nibble + 'a'- 10\r\n        else\r\n        return nibble + 48; // '0'\r\n    }\r\n\r\n    // Authored by https://github.com/axic\r\n    function addressToBytes(address _address) internal returns (bytes) {\r\n        uint160 tmp = uint160(_address);\r\n\r\n        // 40 bytes of space, but actually uses 64 bytes\r\n        string memory holder = \"                                        \";\r\n        bytes memory ret = bytes(holder);\r\n\r\n        // NOTE: this is written in an expensive way, as out-of-order array access\r\n        //       is not supported yet, e.g. we cannot go in reverse easily\r\n        //       (or maybe it is a bug: https://github.com/ethereum/solidity/issues/212)\r\n        uint j = 0;\r\n        for (uint i = 0; i < 20; i++) {\r\n            uint _tmp = tmp / (2 ** (8*(19-i))); // shr(tmp, 8*(19-i))\r\n            uint nb1 = (_tmp / 0x10) & 0x0f;     // shr(tmp, 8) & 0x0f\r\n            uint nb2 = _tmp & 0x0f;\r\n            ret[j++] = byte(nibbleToChar(nb1));\r\n            ret[j++] = byte(nibbleToChar(nb2));\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    // _______________PRIVATE FUNCTIONS_______________\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_coinSymbol\",\"type\":\"string\"},{\"name\":\"_toAddress\",\"type\":\"string\"}],\"name\":\"sendToOtherBlockchain1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionID\",\"type\":\"uint256\"}],\"name\":\"cancelTransaction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclize\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracalize_gaslimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coinSymbol\",\"type\":\"string\"},{\"name\":\"_toAddress\",\"type\":\"string\"},{\"name\":\"_returnAddress\",\"type\":\"address\"}],\"name\":\"sendToOtherBlockchain2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoverable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"returnAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterCryptoPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"update_oracalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recover\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setGasLimit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionID\",\"type\":\"uint256\"}],\"name\":\"TransactionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"returnAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"depositAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransactionSentToShapeShift\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"TransactionAborted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recoveredTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"}]","ContractName":"InterCrypto","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8e13dd379a07f548e001b9641bf49d6e1f4057ca9d233b0b84045789c487473e"}]}