{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Token Trustee Implementation\r\n//\r\n// Copyright (c) 2017 OpenST Ltd.\r\n// https://simpletoken.org/\r\n//\r\n// The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n// SafeMath Library Implementation\r\n//\r\n// Copyright (c) 2017 OpenST Ltd.\r\n// https://simpletoken.org/\r\n//\r\n// The MIT Licence.\r\n//\r\n// Based on the SafeMath library by the OpenZeppelin team.\r\n// Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n// https://github.com/OpenZeppelin/zeppelin-solidity\r\n// The MIT License.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n\r\n        assert(a == 0 || c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n//\r\n// Implements basic ownership with 2-step transfers.\r\n//\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public proposedOwner;\r\n\r\n    event OwnershipTransferInitiated(address indexed _proposedOwner);\r\n    event OwnershipTransferCompleted(address indexed _newOwner);\r\n\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    function isOwner(address _address) internal view returns (bool) {\r\n        return (_address == owner);\r\n    }\r\n\r\n\r\n    function initiateOwnershipTransfer(address _proposedOwner) public onlyOwner returns (bool) {\r\n        proposedOwner = _proposedOwner;\r\n\r\n        OwnershipTransferInitiated(_proposedOwner);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function completeOwnershipTransfer() public returns (bool) {\r\n        require(msg.sender == proposedOwner);\r\n\r\n        owner = proposedOwner;\r\n        proposedOwner = address(0);\r\n\r\n        OwnershipTransferCompleted(owner);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n//\r\n// Implements a more advanced ownership and permission model based on owner,\r\n// admin and ops per Simple Token key management specification.\r\n//\r\ncontract OpsManaged is Owned {\r\n\r\n    address public opsAddress;\r\n    address public adminAddress;\r\n\r\n    event AdminAddressChanged(address indexed _newAddress);\r\n    event OpsAddressChanged(address indexed _newAddress);\r\n\r\n\r\n    function OpsManaged() public\r\n        Owned()\r\n    {\r\n    }\r\n\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyAdminOrOps() {\r\n        require(isAdmin(msg.sender) || isOps(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyOwnerOrAdmin() {\r\n        require(isOwner(msg.sender) || isAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyOps() {\r\n        require(isOps(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    function isAdmin(address _address) internal view returns (bool) {\r\n        return (adminAddress != address(0) && _address == adminAddress);\r\n    }\r\n\r\n\r\n    function isOps(address _address) internal view returns (bool) {\r\n        return (opsAddress != address(0) && _address == opsAddress);\r\n    }\r\n\r\n\r\n    function isOwnerOrOps(address _address) internal view returns (bool) {\r\n        return (isOwner(_address) || isOps(_address));\r\n    }\r\n\r\n\r\n    // Owner and Admin can change the admin address. Address can also be set to 0 to 'disable' it.\r\n    function setAdminAddress(address _adminAddress) external onlyOwnerOrAdmin returns (bool) {\r\n        require(_adminAddress != owner);\r\n        require(_adminAddress != address(this));\r\n        require(!isOps(_adminAddress));\r\n\r\n        adminAddress = _adminAddress;\r\n\r\n        AdminAddressChanged(_adminAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Owner and Admin can change the operations address. Address can also be set to 0 to 'disable' it.\r\n    function setOpsAddress(address _opsAddress) external onlyOwnerOrAdmin returns (bool) {\r\n        require(_opsAddress != owner);\r\n        require(_opsAddress != address(this));\r\n        require(!isAdmin(_opsAddress));\r\n\r\n        opsAddress = _opsAddress;\r\n\r\n        OpsAddressChanged(_opsAddress);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract SimpleTokenConfig {\r\n\r\n    string  public constant TOKEN_SYMBOL   = \"ST\";\r\n    string  public constant TOKEN_NAME     = \"Simple Token\";\r\n    uint8   public constant TOKEN_DECIMALS = 18;\r\n\r\n    uint256 public constant DECIMALSFACTOR = 10**uint256(TOKEN_DECIMALS);\r\n    uint256 public constant TOKENS_MAX     = 800000000 * DECIMALSFACTOR;\r\n}\r\n\r\ncontract ERC20Interface {\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function name() public view returns (string);\r\n    function symbol() public view returns (string);\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n//\r\n// Standard ERC20 implementation, with ownership.\r\n//\r\ncontract ERC20Token is ERC20Interface, Owned {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string  private tokenName;\r\n    string  private tokenSymbol;\r\n    uint8   private tokenDecimals;\r\n    uint256 internal tokenTotalSupply;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n\r\n    function ERC20Token(string _symbol, string _name, uint8 _decimals, uint256 _totalSupply) public\r\n        Owned()\r\n    {\r\n        tokenSymbol      = _symbol;\r\n        tokenName        = _name;\r\n        tokenDecimals    = _decimals;\r\n        tokenTotalSupply = _totalSupply;\r\n        balances[owner]  = _totalSupply;\r\n\r\n        // According to the ERC20 standard, a token contract which creates new tokens should trigger\r\n        // a Transfer event and transfers of 0 values must also fire the event.\r\n        Transfer(0x0, owner, _totalSupply);\r\n    }\r\n\r\n\r\n    function name() public view returns (string) {\r\n        return tokenName;\r\n    }\r\n\r\n\r\n    function symbol() public view returns (string) {\r\n        return tokenSymbol;\r\n    }\r\n\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return tokenDecimals;\r\n    }\r\n\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenTotalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        // According to the EIP20 spec, \"transfers of 0 values MUST be treated as normal\r\n        // transfers and fire the Transfer event\".\r\n        // Also, should throw if not enough balance. This is taken care of by SafeMath.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n//\r\n// SimpleToken is a standard ERC20 token with some additional functionality:\r\n// - It has a concept of finalize\r\n// - Before finalize, nobody can transfer tokens except:\r\n//     - Owner and operations can transfer tokens\r\n//     - Anybody can send back tokens to owner\r\n// - After finalize, no restrictions on token transfers\r\n//\r\n\r\n//\r\n// Permissions, according to the ST key management specification.\r\n//\r\n//                                    Owner    Admin   Ops\r\n// transfer (before finalize)           x               x\r\n// transferForm (before finalize)       x               x\r\n// finalize                                      x\r\n//\r\n\r\ncontract SimpleToken is ERC20Token, OpsManaged, SimpleTokenConfig {\r\n\r\n    bool public finalized;\r\n\r\n\r\n    // Events\r\n    event Burnt(address indexed _from, uint256 _amount);\r\n    event Finalized();\r\n\r\n\r\n    function SimpleToken() public\r\n        ERC20Token(TOKEN_SYMBOL, TOKEN_NAME, TOKEN_DECIMALS, TOKENS_MAX)\r\n        OpsManaged()\r\n    {\r\n        finalized = false;\r\n    }\r\n\r\n\r\n    // Implementation of the standard transfer method that takes into account the finalize flag.\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        checkTransferAllowed(msg.sender, _to);\r\n\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n\r\n    // Implementation of the standard transferFrom method that takes into account the finalize flag.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        checkTransferAllowed(msg.sender, _to);\r\n\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n\r\n    function checkTransferAllowed(address _sender, address _to) private view {\r\n        if (finalized) {\r\n            // Everybody should be ok to transfer once the token is finalized.\r\n            return;\r\n        }\r\n\r\n        // Owner and Ops are allowed to transfer tokens before the sale is finalized.\r\n        // This allows the tokens to move from the TokenSale contract to a beneficiary.\r\n        // We also allow someone to send tokens back to the owner. This is useful among other\r\n        // cases, for the Trustee to transfer unlocked tokens back to the owner (reclaimTokens).\r\n        require(isOwnerOrOps(_sender) || _to == owner);\r\n    }\r\n\r\n    // Implement a burn function to permit msg.sender to reduce its balance\r\n    // which also reduces tokenTotalSupply\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        tokenTotalSupply = tokenTotalSupply.sub(_value);\r\n\r\n        Burnt(msg.sender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Finalize method marks the point where token transfers are finally allowed for everybody.\r\n    function finalize() external onlyAdmin returns (bool success) {\r\n        require(!finalized);\r\n\r\n        finalized = true;\r\n\r\n        Finalized();\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n//\r\n// Implements a simple trustee which can release tokens based on\r\n// an explicit call from the owner.\r\n//\r\n\r\n//\r\n// Permissions, according to the ST key management specification.\r\n//\r\n//                                Owner    Admin   Ops   Revoke\r\n// grantAllocation                           x      x\r\n// revokeAllocation                                        x\r\n// processAllocation                                x\r\n// reclaimTokens                             x\r\n// setRevokeAddress                 x                      x\r\n//\r\n\r\ncontract Trustee is OpsManaged {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    SimpleToken public tokenContract;\r\n\r\n    struct Allocation {\r\n        uint256 amountGranted;\r\n        uint256 amountTransferred;\r\n        bool    revokable;\r\n    }\r\n\r\n    // The trustee has a special 'revoke' key which is allowed to revoke allocations.\r\n    address public revokeAddress;\r\n\r\n    // Total number of tokens that are currently allocated.\r\n    // This does not include tokens that have been processed (sent to an address) already or\r\n    // the ones in the trustee's account that have not been allocated yet.\r\n    uint256 public totalLocked;\r\n\r\n    mapping (address => Allocation) public allocations;\r\n\r\n\r\n    //\r\n    // Events\r\n    //\r\n    event AllocationGranted(address indexed _from, address indexed _account, uint256 _amount, bool _revokable);\r\n    event AllocationRevoked(address indexed _from, address indexed _account, uint256 _amountRevoked);\r\n    event AllocationProcessed(address indexed _from, address indexed _account, uint256 _amount);\r\n    event RevokeAddressChanged(address indexed _newAddress);\r\n    event TokensReclaimed(uint256 _amount);\r\n\r\n\r\n    function Trustee(SimpleToken _tokenContract) public\r\n        OpsManaged()\r\n    {\r\n        require(address(_tokenContract) != address(0));\r\n\r\n        tokenContract = _tokenContract;\r\n    }\r\n\r\n\r\n    modifier onlyOwnerOrRevoke() {\r\n        require(isOwner(msg.sender) || isRevoke(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyRevoke() {\r\n        require(isRevoke(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    function isRevoke(address _address) private view returns (bool) {\r\n        return (revokeAddress != address(0) && _address == revokeAddress);\r\n    }\r\n\r\n\r\n    // Owner and revoke can change the revoke address. Address can also be set to 0 to 'disable' it.\r\n    function setRevokeAddress(address _revokeAddress) external onlyOwnerOrRevoke returns (bool) {\r\n        require(_revokeAddress != owner);\r\n        require(!isAdmin(_revokeAddress));\r\n        require(!isOps(_revokeAddress));\r\n\r\n        revokeAddress = _revokeAddress;\r\n\r\n        RevokeAddressChanged(_revokeAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Allows admin or ops to create new allocations for a specific account.\r\n    function grantAllocation(address _account, uint256 _amount, bool _revokable) public onlyAdminOrOps returns (bool) {\r\n        require(_account != address(0));\r\n        require(_account != address(this));\r\n        require(_amount > 0);\r\n\r\n        // Can't create an allocation if there is already one for this account.\r\n        require(allocations[_account].amountGranted == 0);\r\n\r\n        if (isOps(msg.sender)) {\r\n            // Once the token contract is finalized, the ops key should not be able to grant allocations any longer.\r\n            // Before finalized, it is used by the TokenSale contract to allocate pre-sales.\r\n            require(!tokenContract.finalized());\r\n        }\r\n\r\n        totalLocked = totalLocked.add(_amount);\r\n        require(totalLocked <= tokenContract.balanceOf(address(this)));\r\n\r\n        allocations[_account] = Allocation({\r\n            amountGranted     : _amount,\r\n            amountTransferred : 0,\r\n            revokable         : _revokable\r\n        });\r\n\r\n        AllocationGranted(msg.sender, _account, _amount, _revokable);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Allows the revoke key to revoke allocations, if revoke is allowed.\r\n    function revokeAllocation(address _account) external onlyRevoke returns (bool) {\r\n        require(_account != address(0));\r\n\r\n        Allocation memory allocation = allocations[_account];\r\n\r\n        require(allocation.revokable);\r\n\r\n        uint256 ownerRefund = allocation.amountGranted.sub(allocation.amountTransferred);\r\n\r\n        delete allocations[_account];\r\n\r\n        totalLocked = totalLocked.sub(ownerRefund);\r\n\r\n        AllocationRevoked(msg.sender, _account, ownerRefund);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Push model which allows ops to transfer tokens to the beneficiary.\r\n    // The exact amount to transfer is calculated based on agreements with\r\n    // the beneficiaries. Here we only restrict that the total amount transfered cannot\r\n    // exceed what has been granted.\r\n    function processAllocation(address _account, uint256 _amount) external onlyOps returns (bool) {\r\n        require(_account != address(0));\r\n        require(_amount > 0);\r\n\r\n        Allocation storage allocation = allocations[_account];\r\n\r\n        require(allocation.amountGranted > 0);\r\n\r\n        uint256 transferable = allocation.amountGranted.sub(allocation.amountTransferred);\r\n\r\n        if (transferable < _amount) {\r\n           return false;\r\n        }\r\n\r\n        allocation.amountTransferred = allocation.amountTransferred.add(_amount);\r\n\r\n        // Note that transfer will fail if the token contract has not been finalized yet.\r\n        require(tokenContract.transfer(_account, _amount));\r\n\r\n        totalLocked = totalLocked.sub(_amount);\r\n\r\n        AllocationProcessed(msg.sender, _account, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Allows the admin to claim back all tokens that are not currently allocated.\r\n    // Note that the trustee should be able to move tokens even before the token is\r\n    // finalized because SimpleToken allows sending back to owner specifically.\r\n    function reclaimTokens() external onlyAdmin returns (bool) {\r\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\r\n\r\n        // If balance <= amount locked, there is nothing to reclaim.\r\n        require(ownBalance > totalLocked);\r\n\r\n        uint256 amountReclaimed = ownBalance.sub(totalLocked);\r\n\r\n        address tokenOwner = tokenContract.owner();\r\n        require(tokenOwner != address(0));\r\n\r\n        require(tokenContract.transfer(tokenOwner, amountReclaimed));\r\n\r\n        TokensReclaimed(amountReclaimed);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Pausable Contract Implementation\r\n//\r\n// Copyright (c) 2017 OpenST Ltd.\r\n// https://simpletoken.org/\r\n//\r\n// The MIT Licence.\r\n//\r\n// Based on the Pausable contract by the OpenZeppelin team.\r\n// Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n// https://github.com/OpenZeppelin/zeppelin-solidity\r\n// The MIT License.\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Pausable is OpsManaged {\r\n\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n\r\n  function pause() public onlyAdmin whenNotPaused {\r\n    paused = true;\r\n\r\n    Pause();\r\n  }\r\n\r\n\r\n  function unpause() public onlyAdmin whenPaused {\r\n    paused = false;\r\n\r\n    Unpause();\r\n  }\r\n}\r\n\r\ncontract TokenSaleConfig is SimpleTokenConfig {\r\n\r\n    uint256 public constant PHASE1_START_TIME         = 1510664400; // 2017-11-14, 13:00:00 UTC\r\n    uint256 public constant PHASE2_START_TIME         = 1510750800; // 2017-11-15, 13:00:00 UTC\r\n    uint256 public constant END_TIME                  = 1512133199; // 2017-12-01, 12:59:59 UTC\r\n    uint256 public constant CONTRIBUTION_MIN          = 0.1 ether;\r\n    uint256 public constant CONTRIBUTION_MAX          = 10000.0 ether;\r\n\r\n    // This is the maximum number of tokens each individual account is allowed to\r\n    // buy during Phase 1 of the token sale (whitelisted phase)\r\n    // Calculated based on 300 USD/ETH * 10 ETH / 0.0833 USD / token = ~36,000\r\n    uint256 public constant PHASE1_ACCOUNT_TOKENS_MAX = 36000     * DECIMALSFACTOR;\r\n\r\n    uint256 public constant TOKENS_SALE               = 240000000 * DECIMALSFACTOR;\r\n    uint256 public constant TOKENS_FOUNDERS           = 80000000  * DECIMALSFACTOR;\r\n    uint256 public constant TOKENS_ADVISORS           = 80000000  * DECIMALSFACTOR;\r\n    uint256 public constant TOKENS_EARLY_BACKERS      = 44884831  * DECIMALSFACTOR;\r\n    uint256 public constant TOKENS_ACCELERATOR        = 217600000 * DECIMALSFACTOR;\r\n    uint256 public constant TOKENS_FUTURE             = 137515169 * DECIMALSFACTOR;\r\n\r\n    // We use a default for when the contract is deployed but this can be changed afterwards\r\n    // by calling the setTokensPerKEther function\r\n    // For the public sale, tokens are priced at 0.0833 USD/token.\r\n    // So if we have 300 USD/ETH -> 300,000 USD/KETH / 0.0833 USD/token = ~3,600,000\r\n    uint256 public constant TOKENS_PER_KETHER         = 3600000;\r\n\r\n    // Constant used by buyTokens as part of the cost <-> tokens conversion.\r\n    // 18 for ETH -> WEI, TOKEN_DECIMALS (18 for Simple Token), 3 for the K in tokensPerKEther.\r\n    uint256 public constant PURCHASE_DIVIDER          = 10**(uint256(18) - TOKEN_DECIMALS + 3);\r\n\r\n}\r\n\r\n//\r\n// Implementation of the 1st token sale for Simple Token\r\n//\r\n// * Lifecycle *\r\n// Initialization sequence should be as follow:\r\n//    1. Deploy SimpleToken contract\r\n//    2. Deploy Trustee contract\r\n//    3. Deploy TokenSale contract\r\n//    4. Set operationsAddress of SimpleToken contract to TokenSale contract\r\n//    5. Set operationsAddress of Trustee contract to TokenSale contract\r\n//    6. Set operationsAddress of TokenSale contract to some address\r\n//    7. Transfer tokens from owner to TokenSale contract\r\n//    8. Transfer tokens from owner to Trustee contract\r\n//    9. Initialize TokenSale contract\r\n//\r\n// Pre-sale sequence:\r\n//    - Set tokensPerKEther\r\n//    - Set phase1AccountTokensMax\r\n//    - Add presales\r\n//    - Add allocations for founders, advisors, etc.\r\n//    - Update whitelist\r\n//\r\n// After-sale sequence:\r\n//    1. Finalize the TokenSale contract\r\n//    2. Finalize the SimpleToken contract\r\n//    3. Set operationsAddress of TokenSale contract to 0\r\n//    4. Set operationsAddress of SimpleToken contract to 0\r\n//    5. Set operationsAddress of Trustee contract to some address\r\n//\r\n// Anytime\r\n//    - Add/Remove allocations\r\n//\r\n\r\n//\r\n// Permissions, according to the ST key management specification.\r\n//\r\n//                                Owner    Admin   Ops\r\n// initialize                       x\r\n// changeWallet                              x\r\n// updateWhitelist                                  x\r\n// setTokensPerKEther                        x\r\n// setPhase1AccountTokensMax                 x\r\n// addPresale                                x\r\n// pause / unpause                           x\r\n// reclaimTokens                             x\r\n// burnUnsoldTokens                          x\r\n// finalize                                  x\r\n//\r\n\r\ncontract TokenSale is OpsManaged, Pausable, TokenSaleConfig { // Pausable is also Owned\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    // We keep track of whether the sale has been finalized, at which point\r\n    // no additional contributions will be permitted.\r\n    bool public finalized;\r\n\r\n    // The sale end time is initially defined by the END_TIME constant but it\r\n    // may get extended if the sale is paused.\r\n    uint256 public endTime;\r\n    uint256 public pausedTime;\r\n\r\n    // Number of tokens per 1000 ETH. See TokenSaleConfig for details.\r\n    uint256 public tokensPerKEther;\r\n\r\n    // Keeps track of the maximum amount of tokens that an account is allowed to purchase in phase 1.\r\n    uint256 public phase1AccountTokensMax;\r\n\r\n    // Address where the funds collected during the sale will be forwarded.\r\n    address public wallet;\r\n\r\n    // Token contract that the sale contract will interact with.\r\n    SimpleToken public tokenContract;\r\n\r\n    // Trustee contract to hold on token balances. The following token pools will be held by trustee:\r\n    //    - Founders\r\n    //    - Advisors\r\n    //    - Early investors\r\n    //    - Presales\r\n    Trustee public trusteeContract;\r\n\r\n    // Total amount of tokens sold during presale + public sale. Excludes pre-sale bonuses.\r\n    uint256 public totalTokensSold;\r\n\r\n    // Total amount of tokens given as bonus during presale. Will influence accelerator token balance.\r\n    uint256 public totalPresaleBase;\r\n    uint256 public totalPresaleBonus;\r\n\r\n    // Map of addresses that have been whitelisted in advance (and passed KYC).\r\n    // The whitelist value indicates what phase (1 or 2) the address has been whitelisted for.\r\n    // Addresses whitelisted for phase 1 can also contribute during phase 2.\r\n    mapping(address => uint8) public whitelist;\r\n\r\n\r\n    //\r\n    // EVENTS\r\n    //\r\n    event Initialized();\r\n    event PresaleAdded(address indexed _account, uint256 _baseTokens, uint256 _bonusTokens);\r\n    event WhitelistUpdated(address indexed _account, uint8 _phase);\r\n    event TokensPurchased(address indexed _beneficiary, uint256 _cost, uint256 _tokens, uint256 _totalSold);\r\n    event TokensPerKEtherUpdated(uint256 _amount);\r\n    event Phase1AccountTokensMaxUpdated(uint256 _tokens);\r\n    event WalletChanged(address _newWallet);\r\n    event TokensReclaimed(uint256 _amount);\r\n    event UnsoldTokensBurnt(uint256 _amount);\r\n    event Finalized();\r\n\r\n\r\n    function TokenSale(SimpleToken _tokenContract, Trustee _trusteeContract, address _wallet) public\r\n        OpsManaged()\r\n    {\r\n        require(address(_tokenContract) != address(0));\r\n        require(address(_trusteeContract) != address(0));\r\n        require(_wallet != address(0));\r\n\r\n        require(PHASE1_START_TIME >= currentTime());\r\n        require(PHASE2_START_TIME > PHASE1_START_TIME);\r\n        require(END_TIME > PHASE2_START_TIME);\r\n        require(TOKENS_PER_KETHER > 0);\r\n        require(PHASE1_ACCOUNT_TOKENS_MAX > 0);\r\n\r\n        // Basic check that the constants add up to TOKENS_MAX\r\n        uint256 partialAllocations = TOKENS_FOUNDERS.add(TOKENS_ADVISORS).add(TOKENS_EARLY_BACKERS);\r\n        require(partialAllocations.add(TOKENS_SALE).add(TOKENS_ACCELERATOR).add(TOKENS_FUTURE) == TOKENS_MAX);\r\n\r\n        wallet                 = _wallet;\r\n        pausedTime             = 0;\r\n        endTime                = END_TIME;\r\n        finalized              = false;\r\n        tokensPerKEther        = TOKENS_PER_KETHER;\r\n        phase1AccountTokensMax = PHASE1_ACCOUNT_TOKENS_MAX;\r\n\r\n        tokenContract   = _tokenContract;\r\n        trusteeContract = _trusteeContract;\r\n    }\r\n\r\n\r\n    // Initialize is called to check some configuration parameters.\r\n    // It expects that a certain amount of tokens have already been assigned to the sale contract address.\r\n    function initialize() external onlyOwner returns (bool) {\r\n        require(totalTokensSold == 0);\r\n        require(totalPresaleBase == 0);\r\n        require(totalPresaleBonus == 0);\r\n\r\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\r\n        require(ownBalance == TOKENS_SALE);\r\n\r\n        // Simple check to confirm that tokens are present\r\n        uint256 trusteeBalance = tokenContract.balanceOf(address(trusteeContract));\r\n        require(trusteeBalance >= TOKENS_FUTURE);\r\n\r\n        Initialized();\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Allows the admin to change the wallet where ETH contributions are sent.\r\n    function changeWallet(address _wallet) external onlyAdmin returns (bool) {\r\n        require(_wallet != address(0));\r\n        require(_wallet != address(this));\r\n        require(_wallet != address(trusteeContract));\r\n        require(_wallet != address(tokenContract));\r\n\r\n        wallet = _wallet;\r\n\r\n        WalletChanged(wallet);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    //\r\n    // TIME\r\n    //\r\n\r\n    function currentTime() public view returns (uint256 _currentTime) {\r\n        return now;\r\n    }\r\n\r\n\r\n    modifier onlyBeforeSale() {\r\n        require(hasSaleEnded() == false);\r\n        require(currentTime() < PHASE1_START_TIME);\r\n       _;\r\n    }\r\n\r\n\r\n    modifier onlyDuringSale() {\r\n        require(hasSaleEnded() == false && currentTime() >= PHASE1_START_TIME);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterSale() {\r\n        // require finalized is stronger than hasSaleEnded\r\n        require(finalized);\r\n        _;\r\n    }\r\n\r\n\r\n    function hasSaleEnded() private view returns (bool) {\r\n        // if sold out or finalized, sale has ended\r\n        if (totalTokensSold >= TOKENS_SALE || finalized) {\r\n            return true;\r\n        // else if sale is not paused (pausedTime = 0) \r\n        // and endtime has past, then sale has ended\r\n        } else if (pausedTime == 0 && currentTime() >= endTime) {\r\n            return true;\r\n        // otherwise it is not past and not paused; or paused\r\n        // and as such not ended\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    //\r\n    // WHITELIST\r\n    //\r\n\r\n    // Allows ops to add accounts to the whitelist.\r\n    // Only those accounts will be allowed to contribute during the sale.\r\n    // _phase = 1: Can contribute during phases 1 and 2 of the sale.\r\n    // _phase = 2: Can contribute during phase 2 of the sale only.\r\n    // _phase = 0: Cannot contribute at all (not whitelisted).\r\n    function updateWhitelist(address _account, uint8 _phase) external onlyOps returns (bool) {\r\n        require(_account != address(0));\r\n        require(_phase <= 2);\r\n        require(!hasSaleEnded());\r\n\r\n        whitelist[_account] = _phase;\r\n\r\n        WhitelistUpdated(_account, _phase);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    //\r\n    // PURCHASES / CONTRIBUTIONS\r\n    //\r\n\r\n    // Allows the admin to set the price for tokens sold during phases 1 and 2 of the sale.\r\n    function setTokensPerKEther(uint256 _tokensPerKEther) external onlyAdmin onlyBeforeSale returns (bool) {\r\n        require(_tokensPerKEther > 0);\r\n\r\n        tokensPerKEther = _tokensPerKEther;\r\n\r\n        TokensPerKEtherUpdated(_tokensPerKEther);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Allows the admin to set the maximum amount of tokens that an account can buy during phase 1 of the sale.\r\n    function setPhase1AccountTokensMax(uint256 _tokens) external onlyAdmin onlyBeforeSale returns (bool) {\r\n        require(_tokens > 0);\r\n\r\n        phase1AccountTokensMax = _tokens;\r\n\r\n        Phase1AccountTokensMaxUpdated(_tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function () external payable whenNotPaused onlyDuringSale {\r\n        buyTokens();\r\n    }\r\n\r\n\r\n    // This is the main function to process incoming ETH contributions.\r\n    function buyTokens() public payable whenNotPaused onlyDuringSale returns (bool) {\r\n        require(msg.value >= CONTRIBUTION_MIN);\r\n        require(msg.value <= CONTRIBUTION_MAX);\r\n        require(totalTokensSold < TOKENS_SALE);\r\n\r\n        // All accounts need to be whitelisted to purchase.\r\n        uint8 whitelistedPhase = whitelist[msg.sender];\r\n        require(whitelistedPhase > 0);\r\n\r\n        uint256 tokensMax = TOKENS_SALE.sub(totalTokensSold);\r\n\r\n        if (currentTime() < PHASE2_START_TIME) {\r\n            // We are in phase 1 of the sale\r\n            require(whitelistedPhase == 1);\r\n\r\n            uint256 accountBalance = tokenContract.balanceOf(msg.sender);\r\n\r\n            // Can only purchase up to a maximum per account.\r\n            // Calculate how much of that amount is still available.\r\n            uint256 phase1Balance = phase1AccountTokensMax.sub(accountBalance);\r\n\r\n            if (phase1Balance < tokensMax) {\r\n                tokensMax = phase1Balance;\r\n            }\r\n        }\r\n\r\n        require(tokensMax > 0);\r\n\r\n        uint256 tokensBought = msg.value.mul(tokensPerKEther).div(PURCHASE_DIVIDER);\r\n        require(tokensBought > 0);\r\n\r\n        uint256 cost = msg.value;\r\n        uint256 refund = 0;\r\n\r\n        if (tokensBought > tokensMax) {\r\n            // Not enough tokens available for full contribution, we will do partial.\r\n            tokensBought = tokensMax;\r\n\r\n            // Calculate actual cost for partial amount of tokens.\r\n            cost = tokensBought.mul(PURCHASE_DIVIDER).div(tokensPerKEther);\r\n\r\n            // Calculate refund for contributor.\r\n            refund = msg.value.sub(cost);\r\n        }\r\n\r\n        totalTokensSold = totalTokensSold.add(tokensBought);\r\n\r\n        // Transfer tokens to the account\r\n        require(tokenContract.transfer(msg.sender, tokensBought));\r\n\r\n        // Issue a ETH refund for any unused portion of the funds.\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n\r\n        // Transfer the contribution to the wallet\r\n        wallet.transfer(msg.value.sub(refund));\r\n\r\n        TokensPurchased(msg.sender, cost, tokensBought, totalTokensSold);\r\n\r\n        // If all tokens available for sale have been sold out, finalize the sale automatically.\r\n        if (totalTokensSold == TOKENS_SALE) {\r\n            finalizeInternal();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    //\r\n    // PRESALES\r\n    //\r\n\r\n    // Allows the admin to record pre-sales, before the public sale starts. Presale base tokens come out of the\r\n    // main sale pool (the 30% allocation) while bonus tokens come from the remaining token pool.\r\n    function addPresale(address _account, uint256 _baseTokens, uint256 _bonusTokens) external onlyAdmin onlyBeforeSale returns (bool) {\r\n        require(_account != address(0));\r\n\r\n        // Presales may have 0 bonus tokens but need to have a base amount of tokens sold.\r\n        require(_baseTokens > 0);\r\n        require(_bonusTokens < _baseTokens);\r\n\r\n        // We do not count bonus tokens as part of the sale cap.\r\n        totalTokensSold = totalTokensSold.add(_baseTokens);\r\n        require(totalTokensSold <= TOKENS_SALE);\r\n\r\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\r\n        require(_baseTokens <= ownBalance);\r\n\r\n        totalPresaleBase  = totalPresaleBase.add(_baseTokens);\r\n        totalPresaleBonus = totalPresaleBonus.add(_bonusTokens);\r\n\r\n        // Move base tokens to the trustee\r\n        require(tokenContract.transfer(address(trusteeContract), _baseTokens));\r\n\r\n        // Presale allocations are marked as locked, they cannot be removed by the owner.\r\n        uint256 tokens = _baseTokens.add(_bonusTokens);\r\n        require(trusteeContract.grantAllocation(_account, tokens, false /* revokable */));\r\n\r\n        PresaleAdded(_account, _baseTokens, _bonusTokens);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    //\r\n    // PAUSE / UNPAUSE\r\n    //\r\n\r\n    // Allows the owner or admin to pause the sale for any reason.\r\n    function pause() public onlyAdmin whenNotPaused {\r\n        require(hasSaleEnded() == false);\r\n\r\n        pausedTime = currentTime();\r\n\r\n        return super.pause();\r\n    }\r\n\r\n\r\n    // Unpause may extend the end time of the public sale.\r\n    // Note that we do not extend the start time of each phase.\r\n    // Currently does not extend phase 1 end time, only final end time.\r\n    function unpause() public onlyAdmin whenPaused {\r\n\r\n        // If owner unpauses before sale starts, no impact on end time.\r\n        uint256 current = currentTime();\r\n\r\n        // If owner unpauses after sale starts, calculate how to extend end.\r\n        if (current > PHASE1_START_TIME) {\r\n            uint256 timeDelta;\r\n\r\n            if (pausedTime < PHASE1_START_TIME) {\r\n                // Pause was triggered before the start time, extend by time that\r\n                // passed from proposed start time until now.\r\n                timeDelta = current.sub(PHASE1_START_TIME);\r\n            } else {\r\n                // Pause was triggered while the sale was already started.\r\n                // Extend end time by amount of time since pause.\r\n                timeDelta = current.sub(pausedTime);\r\n            }\r\n\r\n            endTime = endTime.add(timeDelta);\r\n        }\r\n\r\n        pausedTime = 0;\r\n\r\n        return super.unpause();\r\n    }\r\n\r\n\r\n    // Allows the admin to move bonus tokens still available in the sale contract\r\n    // out before burning all remaining unsold tokens in burnUnsoldTokens().\r\n    // Used to distribute bonuses to token sale participants when the sale has ended\r\n    // and all bonuses are known.\r\n    function reclaimTokens(uint256 _amount) external onlyAfterSale onlyAdmin returns (bool) {\r\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\r\n        require(_amount <= ownBalance);\r\n        \r\n        address tokenOwner = tokenContract.owner();\r\n        require(tokenOwner != address(0));\r\n\r\n        require(tokenContract.transfer(tokenOwner, _amount));\r\n\r\n        TokensReclaimed(_amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Allows the admin to burn all unsold tokens in the sale contract.\r\n    function burnUnsoldTokens() external onlyAfterSale onlyAdmin returns (bool) {\r\n        uint256 ownBalance = tokenContract.balanceOf(address(this));\r\n\r\n        require(tokenContract.burn(ownBalance));\r\n\r\n        UnsoldTokensBurnt(ownBalance);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Allows the admin to finalize the sale and complete allocations.\r\n    // The SimpleToken.admin also needs to finalize the token contract\r\n    // so that token transfers are enabled.\r\n    function finalize() external onlyAdmin returns (bool) {\r\n        return finalizeInternal();\r\n    }\r\n\r\n\r\n    // The internal one will be called if tokens are sold out or\r\n    // the end time for the sale is reached, in addition to being called\r\n    // from the public version of finalize().\r\n    function finalizeInternal() private returns (bool) {\r\n        require(!finalized);\r\n\r\n        finalized = true;\r\n\r\n        Finalized();\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PHASE1_START_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensPerKEther\",\"type\":\"uint256\"}],\"name\":\"setTokensPerKEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PURCHASE_DIVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRIBUTION_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_ACCELERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPresaleBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"setAdminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_SALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PHASE2_START_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"updateWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"setPhase1AccountTokensMax\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_EARLY_BACKERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_baseTokens\",\"type\":\"uint256\"},{\"name\":\"_bonusTokens\",\"type\":\"uint256\"}],\"name\":\"addPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_opsAddress\",\"type\":\"address\"}],\"name\":\"setOpsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"reclaimTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALSFACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnUnsoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_ADVISORS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPresaleBase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerKEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PHASE1_ACCOUNT_TOKENS_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pausedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRIBUTION_MIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trusteeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"initiateOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"name\":\"_currentTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"completeOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase1AccountTokensMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_PER_KETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_FOUNDERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_FUTURE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_trusteeContract\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_baseTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bonusTokens\",\"type\":\"uint256\"}],\"name\":\"PresaleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"WhitelistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_cost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSold\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensPerKEtherUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Phase1AccountTokensMaxUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"WalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"UnsoldTokensBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"AdminAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"OpsAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferCompleted\",\"type\":\"event\"}]","ContractName":"TokenSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002c4e8f2d746113d0696ce89b35f0d8bf88e0aeca0000000000000000000000004288f043370910c923f7a600526ca8064da05d0d0000000000000000000000002ef2782905830533d218b7ff4d15b8c0981ce84b","Library":"","SwarmSource":"bzzr://d70335dbd36e2892b2e69a9407bafe127794d39bc50a6ce104a0561861dad2e2"}]}