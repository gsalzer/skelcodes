{"status":"1","message":"OK","result":[{"SourceCode":"/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\npragma solidity 0.4.15;\r\n\r\n\r\n/// @title Abstract token contract - Functions to be implemented by token contracts.\r\ncontract Token {\r\n    function transfer(address to, uint256 value) returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    // This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions.\r\n    //function totalSupply() constant returns (uint256 supply) {};\r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract DutchAuction {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event BidSubmission(address indexed sender, uint256 amount);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint constant public MAX_TOKENS_SOLD = 5000000 * 10**18; // 5M\r\n    uint constant public WAITING_PERIOD = 7 days;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    Token public virtuePlayerPoints;\r\n    address public wallet;\r\n    address public owner;\r\n    uint public ceiling;\r\n    uint public priceFactor;\r\n    uint public startBlock;\r\n    uint public endTime;\r\n    uint public totalReceived;\r\n    uint public finalPrice;\r\n    mapping (address => uint) public bids;\r\n    Stages public stage;\r\n    \r\n    // Bidder whitelist. Entries in the array are whitelisted addresses\r\n    // Entries in the address-keyed map represent the (array_index+1) of\r\n    // the key. \r\n    \r\n    address[] public bidderWhitelist; // allows iteration over whitelisted addresses\r\n    mapping (address => uint ) public whitelistIndexMap;  // allows fast address lookup\r\n\r\n    /*\r\n     *  Enums\r\n     */\r\n    enum Stages {\r\n        AuctionDeployed,\r\n        AuctionSetUp,\r\n        AuctionStarted,\r\n        AuctionEnded,\r\n        TradingStarted\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier atStage(Stages _stage) {\r\n        require (stage == _stage);\r\n            // Contract must be in expected state\r\n        _;\r\n    }\r\n\r\n    modifier isOwner() {\r\n        require (msg.sender == owner);\r\n            // Only owner is allowed to proceed\r\n        _;\r\n    }\r\n\r\n    modifier isWallet() {\r\n        require (msg.sender == wallet);\r\n            // Only wallet is allowed to proceed\r\n        _;\r\n    }\r\n\r\n    modifier isValidPayload() {\r\n        require (msg.data.length == 4 || msg.data.length == 36);\r\n        _;\r\n    }\r\n\r\n    modifier timedTransitions() {\r\n        if (stage == Stages.AuctionStarted && calcTokenPrice() <= calcStopPrice())\r\n            finalizeAuction();\r\n        if (stage == Stages.AuctionEnded && now > endTime + WAITING_PERIOD)\r\n            stage = Stages.TradingStarted;\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Contract constructor function sets owner.\r\n    /// @param _wallet Multisig wallet for auction proceeds.\r\n    /// @param _ceiling Auction ceiling.\r\n    /// @param _priceFactor Auction price factor.\r\n    function DutchAuction(address _wallet, uint _ceiling, uint _priceFactor)\r\n        public\r\n    {\r\n        require (_wallet != 0);\r\n        require (_ceiling != 0);\r\n        require (_priceFactor != 0);\r\n            // Arguments cannot be null.\r\n        owner = msg.sender;\r\n        wallet = _wallet;\r\n        ceiling = _ceiling;\r\n        priceFactor = _priceFactor;\r\n        stage = Stages.AuctionDeployed;\r\n    }\r\n\r\n    /// @dev Setup function sets external contracts' addresses.\r\n    /// @param _virtuePlayerPoints token contract address.\r\n    function setup(address _virtuePlayerPoints)\r\n        public\r\n        isOwner\r\n        atStage(Stages.AuctionDeployed)\r\n    {\r\n        require (_virtuePlayerPoints != 0);\r\n            // Argument cannot be null.\r\n        virtuePlayerPoints = Token(_virtuePlayerPoints);\r\n        // Validate token balance\r\n        require (virtuePlayerPoints.balanceOf(this) == MAX_TOKENS_SOLD);\r\n\r\n        stage = Stages.AuctionSetUp;\r\n    }\r\n\r\n\r\n    /// @dev Add bidder address to whitelist\r\n    /// @param _bidderAddr Bidder Eth address\r\n    function addToWhitelist(address _bidderAddr)\r\n        public\r\n        isOwner\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        require(_bidderAddr != 0);\r\n        if (whitelistIndexMap[_bidderAddr] == 0)\r\n        {\r\n            uint idxPlusOne = bidderWhitelist.push(_bidderAddr);\r\n            whitelistIndexMap[_bidderAddr] = idxPlusOne; \r\n        }\r\n    }\r\n\r\n    /// @dev Add multiple bidder addresses to whitelist\r\n    /// @param _bidderAddrs Array of Bidder Eth addresses\r\n    function addArrayToWhitelist(address[] _bidderAddrs)\r\n        public\r\n        isOwner\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        require(_bidderAddrs.length != 0);\r\n        for(uint idx = 0; idx<_bidderAddrs.length; idx++) {\r\n            addToWhitelist(_bidderAddrs[idx]);\r\n        }\r\n    }\r\n\r\n    /// @dev Remove bidder address from whitelist\r\n    /// @param _bidderAddr Bidder Eth address\r\n    function removeFromWhitelist(address _bidderAddr)\r\n        public\r\n        isOwner\r\n        atStage(Stages.AuctionSetUp)       \r\n    {\r\n        require(_bidderAddr != 0);\r\n        require( whitelistIndexMap[_bidderAddr] != 0); // throw if not in map             \r\n        uint idx = whitelistIndexMap[_bidderAddr] - 1;\r\n        bidderWhitelist[idx] = 0;\r\n        whitelistIndexMap[_bidderAddr] = 0;\r\n    }\r\n    \r\n    /// @dev Is this addres in the whitelist?\r\n    /// @param _addr Bidder Eth address    \r\n    function isInWhitelist(address _addr)\r\n        public\r\n        constant\r\n        returns(bool)\r\n    {\r\n        return (whitelistIndexMap[_addr] != 0);\r\n    }\r\n    \r\n    /// @dev Number of non-zero entries in whitelist\r\n    /// @return number of non-zero entries\r\n    function whitelistCount()\r\n        public\r\n        constant\r\n        returns (uint)        \r\n    {\r\n        uint count = 0;\r\n        for (uint i = 0; i< bidderWhitelist.length; i++) {\r\n            if (bidderWhitelist[i] != 0)\r\n                count++;\r\n        }\r\n        return count;\r\n    }\r\n    \r\n    /// @dev Fetch entries in whitelist\r\n    /// @param _startIdx starting index\r\n    /// @param _count number to fetch. zero for all.\r\n    /// @return array of non-zero entries\r\n    /// Note: because there can be null entries in the bidderWhitelist array,\r\n    /// indices used in this call are not the same as those in bidderwhiteList\r\n    function whitelistEntries(uint _startIdx, uint _count)\r\n        public\r\n        constant\r\n        returns (address[])        \r\n    {\r\n        uint addrCount = whitelistCount();\r\n        if (_count == 0)\r\n            _count = addrCount; \r\n        if (_startIdx >= addrCount) {\r\n            _startIdx = 0;\r\n            _count = 0;\r\n        } else if (_startIdx + _count > addrCount) {\r\n            _count = addrCount - _startIdx;        \r\n        }\r\n\r\n        address[] memory results = new address[](_count);\r\n        // skip to startIdx\r\n        uint dynArrayIdx = 0; \r\n        while (_startIdx > 0) {\r\n            if (bidderWhitelist[dynArrayIdx++] != 0)\r\n                _startIdx--;  \r\n        }   \r\n        // copy into results\r\n        uint resultsIdx = 0; \r\n        while (resultsIdx < _count) {\r\n            address addr = bidderWhitelist[dynArrayIdx++];\r\n            if (addr != 0)\r\n                results[resultsIdx++] = addr;      \r\n        }\r\n        return results;    \r\n    }    \r\n    \r\n    /// @dev Starts auction and sets startBlock.\r\n    function startAuction()\r\n        public\r\n        isWallet\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        stage = Stages.AuctionStarted;\r\n        startBlock = block.number;\r\n    }\r\n\r\n    /// @dev Changes auction ceiling and start price factor before auction is started.\r\n    /// @param _ceiling Updated auction ceiling.\r\n    /// @param _priceFactor Updated start price factor.\r\n    function changeSettings(uint _ceiling, uint _priceFactor)\r\n        public\r\n        isWallet\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        ceiling = _ceiling;\r\n        priceFactor = _priceFactor;\r\n    }\r\n\r\n    /// @dev Calculates current token price.\r\n    /// @return Returns token price.\r\n    function calcCurrentTokenPrice()\r\n        public\r\n        timedTransitions\r\n        returns (uint)\r\n    {\r\n        if (stage == Stages.AuctionEnded || stage == Stages.TradingStarted)\r\n            return finalPrice;\r\n        return calcTokenPrice();\r\n    }\r\n\r\n    /// @dev Returns correct stage, even if a function with timedTransitions modifier has not yet been called yet.\r\n    /// @return Returns current auction stage.\r\n    function updateStage()\r\n        public\r\n        timedTransitions\r\n        returns (Stages)\r\n    {\r\n        return stage;\r\n    }\r\n\r\n    /// @dev Allows to send a bid to the auction.\r\n    /// @param receiver Bid will be assigned to this address if set.\r\n    function bid(address receiver)\r\n        public\r\n        payable\r\n        isValidPayload\r\n        timedTransitions\r\n        atStage(Stages.AuctionStarted)\r\n        returns (uint amount)\r\n    {\r\n        // If a bid is done on behalf of a user via ShapeShift, the receiver address is set.\r\n        if (receiver == 0)\r\n            receiver = msg.sender;\r\n\r\n        require(isInWhitelist(receiver));         \r\n            \r\n        amount = msg.value;\r\n        // Prevent that more than 90% of tokens are sold. Only relevant if cap not reached.\r\n        uint maxWei = (MAX_TOKENS_SOLD / 10**18) * calcTokenPrice() - totalReceived;\r\n        uint maxWeiBasedOnTotalReceived = ceiling - totalReceived;\r\n        if (maxWeiBasedOnTotalReceived < maxWei)\r\n            maxWei = maxWeiBasedOnTotalReceived;\r\n        // Only invest maximum possible amount.\r\n        if (amount > maxWei) {\r\n            amount = maxWei;\r\n            // Send change back to receiver address. In case of a ShapeShift bid the user receives the change back directly.\r\n            receiver.transfer(msg.value - amount); // throws on failure\r\n        }\r\n        // Forward funding to ether wallet\r\n        require (amount != 0);\r\n        wallet.transfer(amount); // throws on failure\r\n        bids[receiver] += amount;\r\n        totalReceived += amount;\r\n        if (maxWei == amount)\r\n            // When maxWei is equal to the big amount the auction is ended and finalizeAuction is triggered.\r\n            finalizeAuction();\r\n        BidSubmission(receiver, amount);\r\n    }\r\n\r\n    /// @dev Claims tokens for bidder after auction.\r\n    /// @param receiver Tokens will be assigned to this address if set.\r\n    function claimTokens(address receiver)\r\n        public\r\n        isValidPayload\r\n        timedTransitions\r\n        atStage(Stages.TradingStarted)\r\n    {\r\n        if (receiver == 0)\r\n            receiver = msg.sender;\r\n        uint tokenCount = bids[receiver] * 10**18 / finalPrice;\r\n        bids[receiver] = 0;\r\n        virtuePlayerPoints.transfer(receiver, tokenCount);\r\n    }\r\n\r\n    /// @dev Calculates stop price.\r\n    /// @return Returns stop price.\r\n    function calcStopPrice()\r\n        constant\r\n        public\r\n        returns (uint)\r\n    {\r\n        return totalReceived * 10**18 / MAX_TOKENS_SOLD + 1;\r\n    }\r\n\r\n    /// @dev Calculates token price.\r\n    /// @return Returns token price.\r\n    function calcTokenPrice()\r\n        constant\r\n        public\r\n        returns (uint)\r\n    {\r\n        return priceFactor * 10**18 / (block.number - startBlock + 8000) + 1;\r\n    }\r\n\r\n    /*\r\n     *  Private functions\r\n     */\r\n    function finalizeAuction()\r\n        private\r\n    {\r\n        stage = Stages.AuctionEnded;\r\n        if (totalReceived == ceiling)\r\n            finalPrice = calcTokenPrice();\r\n        else\r\n            finalPrice = calcStopPrice();\r\n        uint soldTokens = totalReceived * 10**18 / finalPrice;\r\n        // Auction contract transfers all unsold tokens to multisig wallet\r\n        virtuePlayerPoints.transfer(wallet, MAX_TOKENS_SOLD - soldTokens);\r\n        endTime = now;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_bidderAddrs\",\"type\":\"address[]\"}],\"name\":\"addArrayToWhitelist\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isInWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"virtuePlayerPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS_SOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_startIdx\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"whitelistEntries\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistIndexMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ceiling\",\"type\":\"uint256\"},{\"name\":\"_priceFactor\",\"type\":\"uint256\"}],\"name\":\"changeSettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bidderWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_virtuePlayerPoints\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startAuction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAITING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceiling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidderAddr\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"bid\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calcCurrentTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcStopPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidderAddr\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_ceiling\",\"type\":\"uint256\"},{\"name\":\"_priceFactor\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BidSubmission\",\"type\":\"event\"}]","ContractName":"DutchAuction","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002e286da6ee6e8e0afb2c1cfadb1b74669a3cd6420000000000000000000000000000000000000000000011a57db0fed7eaf4000000000000000000000000000000000000000000000000000000000000000002bc","Library":"","SwarmSource":"bzzr://b31049647d6dc4e26ff87b6031ca509f6544e8e2819d0820aa958394a516a36f"}]}