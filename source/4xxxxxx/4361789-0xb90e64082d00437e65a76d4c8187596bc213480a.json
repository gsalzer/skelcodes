{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  StickerRegistry\r\n *\r\n *  This is a simple contract to implement a demo of a collectible blockchain\r\n *  item.\r\n *\r\n *  As part of the Firefly Crowdsale, backers and participants of various events\r\n *  will receive limited edition Firefly stickers. Each sticker is procedurally\r\n *  generated and unique. The ownership of the sticker is tracked by an instance\r\n *  of this contract.\r\n *\r\n *  Since many people will likely not care about the actual sticker, ownership\r\n *  and all that jazz, this has been designed to be very gas effecient from the\r\n *  project owner's point of view.\r\n *\r\n *  When a new series is minted, the entire series manifest is made public, along with\r\n *  a list of faux owners. Each faux owner is an address, for which there exists a\r\n *  secret, which can be used to generate a private key and claim the sticker by\r\n *  signing a message (the destination address) and calling this contract.\r\n *\r\n *  All the faux owners along with their sticker serial number are used to create a\r\n *  merkle tree, of which only the merkle root is registered with the set.\r\n *\r\n *  Nomenclature\r\n *   - Serial Number:  1-indexed (human ordinal) index into the list of items/redeem codes\r\n *   - item index:     0-indexed (mchine ordinal) representation of the Serial Number\r\n */\r\n\r\n/**\r\n *  Why use ENS?\r\n *   - Enforces series name uniqueness\r\n *   - Offloads series ownership and name collision disputes\r\n *   - Hierarchical (e.g. weatherlight.mtg.wotc.eth)\r\n *   - Strong authenticity and identity\r\n *   - Prevents spam\r\n *   - A well-adopted standard that will be maintained and extended\r\n */\r\n\r\n// See: https://github.com/firefly/stickers\r\n\r\n\r\npragma solidity ^0.4.16;\r\n\r\n// This is only used to enable token withdrawl incase this contract is\r\n// somehow given some (e.g. airdopped)\r\ncontract Token {\r\n    function approve(address, uint256) returns (bool);\r\n}\r\n\r\n// We use ENS to manage series ownership\r\ncontract AbstractENS {\r\n    function owner(bytes32) constant returns(address);\r\n    function resolver(bytes32) constant returns(address);\r\n}\r\n\r\ncontract Resolver {\r\n    function addr(bytes32);\r\n}\r\n\r\ncontract ReverseRegistrar {\r\n    function claim(address) returns (bytes32);\r\n}\r\n\r\n\r\n\r\ncontract StickerRegistry {\r\n\r\n    // namehash('addr.reverse')\r\n    bytes32 constant RR_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\n\r\n    event seriesCreated(bytes32 indexed nodehash);\r\n\r\n    event itemTransferred(\r\n        bytes32 indexed nodehash,\r\n        uint256 itemIndex,\r\n        address indexed oldOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    struct Series {\r\n        // The name of the series (the namehash of this should resovle to the nodehash)\r\n        string name;\r\n\r\n        // The merkle root of all stikers in the series\r\n        bytes32 rootHash;\r\n\r\n        // The initial number of cards issued\r\n        uint256 initialCount;\r\n\r\n        // How many have been claimed\r\n        uint256 issuedCount;\r\n\r\n        // The total number in existance after taking provable burning into account\r\n        uint256 currentCount;\r\n\r\n        // Maps a serial number to an owner\r\n        mapping (uint256 => address) owners;\r\n    }\r\n\r\n    AbstractENS _ens;\r\n\r\n    address _owner;\r\n\r\n    mapping (bytes32 => Series) _series;\r\n\r\n\r\n    function StickerRegistry(address ens) {\r\n        _owner = msg.sender;\r\n        _ens = AbstractENS(ens);\r\n\r\n        // Give the owner access to the reverse entry\r\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\r\n    }\r\n\r\n    function setOwner(address newOwner) {\r\n        require(msg.sender == _owner);\r\n        _owner = newOwner;\r\n\r\n        // Give the owner access to the reverse entry\r\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\r\n    }\r\n\r\n    // Bailout - Just in case this contract ever receives funds\r\n    function withdraw(address target, uint256 amount) {\r\n        require(msg.sender == _owner);\r\n        assert(target.send(amount));\r\n    }\r\n\r\n    // Bailout - Just in case this contract ever received tokens\r\n    function approveToken(address token, uint256 amount) {\r\n        require(msg.sender == _owner);\r\n        assert(Token(token).approve(_owner, amount));\r\n    }\r\n\r\n\r\n    // Create a new series\r\n    function createSeries(bytes32 nodehash, string seriesName, bytes32 rootHash, uint256 initialCount) returns (bool success) {\r\n\r\n        // Only the ENS owner of the nodehash may create this series\r\n        if (msg.sender != _ens.owner(nodehash)) { return false; }\r\n\r\n        if (rootHash == 0x00) { return false; }\r\n\r\n        Series storage series = _series[nodehash];\r\n\r\n        // Already exists!\r\n        if (series.rootHash != 0x00) { return false; }\r\n\r\n        series.name = seriesName;\r\n        series.rootHash = rootHash;\r\n        series.initialCount = initialCount;\r\n        series.currentCount = initialCount;\r\n\r\n        seriesCreated(nodehash);\r\n    }\r\n\r\n    // Allow the owner to transfer un-claimed items (they already have the\r\n    // redeem codes, so there is no additional trust required)\r\n    function bestow(bytes32 nodehash, uint256 itemIndex, address owner) returns (bool success) {\r\n\r\n        // Only the ENS owner of nodehash may bestow\r\n        if (_ens.owner(nodehash) != msg.sender) { return false; }\r\n\r\n        Series storage series = _series[nodehash];\r\n\r\n        if (itemIndex >= series.initialCount) { return false; }\r\n\r\n        // Already claimed\r\n        if (series.owners[itemIndex] != 0) { return false; }\r\n\r\n        // Burning...\r\n        if (owner == 0xdead) { series.currentCount--; }\r\n\r\n        series.issuedCount++;\r\n\r\n        series.owners[itemIndex] = owner;\r\n\r\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\r\n    }\r\n\r\n    // Allow a user to claim an item using their redeem code\r\n    function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS,  bytes32[] merkleProof) returns (bool success) {\r\n        Series storage series = _series[nodehash];\r\n\r\n        if (itemIndex >= series.initialCount) { return false; }\r\n\r\n        // Already claimed\r\n        if (series.owners[itemIndex] != 0) { return false; }\r\n\r\n        uint256 path = itemIndex;\r\n\r\n        // Compute the redeem code address from the provided proof\r\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\r\n\r\n        // Verify the merkle proof\r\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\r\n        for (uint16 i = 0; i < merkleProof.length; i++) {\r\n            if ((path & 0x01) == 1) {\r\n                node = keccak256(merkleProof[i], node);\r\n            } else {\r\n                node = keccak256(node, merkleProof[i]);\r\n            }\r\n            path /= 2;\r\n        }\r\n\r\n        // Failed merkle proof\r\n        if (node != series.rootHash) { return false; }\r\n\r\n        // Assign the caller as the owner\r\n        series.owners[itemIndex] = owner;\r\n\r\n        // One more has been issued\r\n        series.issuedCount++;\r\n\r\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Allow item owners to transfer to another account\r\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\r\n\r\n        // Do not allow transfering to 0 (would allow claiming again)\r\n        if (newOwner == 0) { return false; }\r\n\r\n        Series storage series = _series[nodehash];\r\n\r\n        address currentOwner = series.owners[itemIndex];\r\n\r\n        // Only the owner can transfer a item\r\n        if (currentOwner != msg.sender) {\r\n            return false;\r\n        }\r\n\r\n        // Burining! Anyone may choose to destroy a sticker to provably lower\r\n        // its total supply\r\n        if (newOwner == 0xdead) { series.currentCount--; }\r\n\r\n        itemTransferred(nodehash, itemIndex, currentOwner, newOwner);\r\n\r\n        // Assign the new owner\r\n        series.owners[itemIndex] = newOwner;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Get the contract owner\r\n    function owner() constant returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    // Get details about a given series\r\n    function seriesInfo(bytes32 nodehash) constant returns (string name, bytes32 rootHash, uint256 initialCount, uint256 issuedCount, uint256 currentCount) {\r\n        Series storage series = _series[nodehash];\r\n        return (series.name, series.rootHash, series.initialCount, series.issuedCount, series.currentCount);\r\n    }\r\n\r\n    // Get the owner of an item\r\n    function itemOwner(bytes32 nodehash, uint256 itemIndex) constant returns (address) {\r\n        return _series[nodehash].owners[itemIndex];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nodehash\",\"type\":\"bytes32\"},{\"name\":\"itemIndex\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"bestow\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nodehash\",\"type\":\"bytes32\"},{\"name\":\"itemIndex\",\"type\":\"uint256\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nodehash\",\"type\":\"bytes32\"},{\"name\":\"seriesName\",\"type\":\"string\"},{\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"name\":\"initialCount\",\"type\":\"uint256\"}],\"name\":\"createSeries\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nodehash\",\"type\":\"bytes32\"}],\"name\":\"seriesInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"name\":\"initialCount\",\"type\":\"uint256\"},{\"name\":\"issuedCount\",\"type\":\"uint256\"},{\"name\":\"currentCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nodehash\",\"type\":\"bytes32\"},{\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"name\":\"itemOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nodehash\",\"type\":\"bytes32\"},{\"name\":\"itemIndex\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"sigV\",\"type\":\"uint8\"},{\"name\":\"sigR\",\"type\":\"bytes32\"},{\"name\":\"sigS\",\"type\":\"bytes32\"},{\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nodehash\",\"type\":\"bytes32\"}],\"name\":\"seriesCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nodehash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"itemIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"itemTransferred\",\"type\":\"event\"}]","ContractName":"StickerRegistry","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b","Library":"","SwarmSource":"bzzr://652c748c11dc057b1a31053c5628ca0cff4e8adc23cf40c1b4415bde9aacd008"}]}