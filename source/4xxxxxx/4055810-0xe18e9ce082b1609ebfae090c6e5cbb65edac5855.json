{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ncontract ERC20 {\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract Controlled {\r\n    modifier onlyController() {\r\n        require(msg.sender == controller);\r\n        _;\r\n    }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() {\r\n        controller = msg.sender;\r\n    }\r\n\r\n    address public newController;\r\n\r\n    function changeOwner(address _newController) onlyController {\r\n        newController = _newController;\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newController) {\r\n            controller = newController;\r\n        }\r\n    }\r\n}\r\ncontract DAOControlled is Controlled{\r\n    address public dao;\r\n    modifier onlyDAO{\r\n        require(msg.sender == dao);\r\n        _;\r\n    }\r\n    function setDAO(address _dao) onlyController{\r\n        dao = _dao;\r\n    }\r\n}\r\n\r\ncontract MintableToken is ERC20, SafeMath, DAOControlled{\r\n\tmapping(address => uint) public balances;\r\n\taddress[] public mintingFactories;\r\n\tuint public numFactories;\r\n\tfunction resetFactories() onlyController{\r\n\t    numFactories = 0;\r\n\t}\r\n\tfunction addMintingFactory(address _factory) onlyController{\r\n\t    mintingFactories.push(_factory);\r\n\t    numFactories += 1;\r\n\t}\r\n\t\r\n\tfunction removeMintingFactory(address _factory) onlyController{\r\n\t    for (uint i = 0; i < numFactories; i++){\r\n\t        if (_factory == mintingFactories[i])\r\n\t        {\r\n\t            mintingFactories[i] = 0;\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tmodifier onlyFactory{\r\n\t    bool isFactory = false;\r\n\t    for (uint i = 0; i < numFactories; i++){\r\n\t        if (msg.sender == mintingFactories[i] && msg.sender != address(0))\r\n\t        {\r\n\t            isFactory = true;\r\n\t        }\r\n\t    }\r\n\t    if (!isFactory) throw;\r\n\t    _;\r\n\t}\r\n}\r\ncontract CollectibleFeeToken is MintableToken{\r\n\tuint8 public decimals;\r\n\tmapping(uint => uint) public roundFees;\r\n\tmapping(uint => uint) public recordedCoinSupplyForRound;\r\n\tmapping(uint => mapping (address => uint)) public claimedFees;\r\n\tmapping(address => uint) public lastClaimedRound;\r\n\tuint public latestRound = 0;\r\n\tuint public initialRound = 1;\r\n\tuint public reserves;\r\n    event Claimed(address indexed _owner, uint256 _amount);\r\n    event Deposited(uint256 _amount, uint indexed round);\r\n\t\r\n\tmodifier onlyPayloadSize(uint size) {\r\n\t\tif(msg.data.length != size + 4) {\r\n\t\tthrow;\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\t\r\n\tfunction reduceReserves(uint value) onlyPayloadSize(1 * 32) onlyDAO{\r\n\t    reserves = safeSub(reserves, value);\r\n\t}\r\n\t\r\n\tfunction addReserves(uint value) onlyPayloadSize(1 * 32) onlyDAO{\r\n\t    reserves = safeAdd(reserves, value);\r\n\t}\r\n\t\r\n\tfunction depositFees(uint value) onlyDAO {\r\n\t\tlatestRound += 1;\r\n\t\tDeposited(value, latestRound);\r\n\t\trecordedCoinSupplyForRound[latestRound] = totalSupply;\r\n\t\troundFees[latestRound] = value;\r\n\t}\r\n\tfunction claimFees(address _owner) onlyPayloadSize(1 * 32) onlyDAO returns (uint totalFees) {\r\n\t\ttotalFees = 0;\r\n\t\tfor (uint i = lastClaimedRound[_owner] + 1; i <= latestRound; i++){\r\n\t\t\tuint feeForRound = balances[_owner] * feePerUnitOfCoin(i);\r\n\t\t\tif (feeForRound > claimedFees[i][_owner]){\r\n\t\t\t\tfeeForRound = safeSub(feeForRound,claimedFees[i][_owner]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfeeForRound = 0;\r\n\t\t\t}\r\n\t\t\tclaimedFees[i][_owner] = safeAdd(claimedFees[i][_owner], feeForRound);\r\n\t\t\ttotalFees = safeAdd(totalFees, feeForRound);\r\n\t\t}\r\n\t\tlastClaimedRound[_owner] = latestRound;\r\n\t\tClaimed(_owner, feeForRound);\r\n\t\treturn totalFees;\r\n\t}\r\n\r\n\tfunction claimFeesForRound(address _owner, uint round) onlyPayloadSize(2 * 32) onlyDAO returns (uint feeForRound) {\r\n\t\tfeeForRound = balances[_owner] * feePerUnitOfCoin(round);\r\n\t\tif (feeForRound > claimedFees[round][_owner]){\r\n\t\t\tfeeForRound = safeSub(feeForRound,claimedFees[round][_owner]);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfeeForRound = 0;\r\n\t\t}\r\n\t\tclaimedFees[round][_owner] = safeAdd(claimedFees[round][_owner], feeForRound);\r\n\t\tClaimed(_owner, feeForRound);\r\n\t\treturn feeForRound;\r\n\t}\r\n\r\n\tfunction _resetTransferredCoinFees(address _owner, address _receipient, uint numCoins) internal returns (bool){\r\n\t\tfor (uint i = lastClaimedRound[_owner] + 1; i <= latestRound; i++){\r\n\t\t\tuint feeForRound = balances[_owner] * feePerUnitOfCoin(i);\r\n\t\t\tif (feeForRound > claimedFees[i][_owner]) {\r\n\t\t\t\t//Add unclaimed fees to reserves\r\n\t\t\t\tuint unclaimedFees = min256(numCoins * feePerUnitOfCoin(i), safeSub(feeForRound, claimedFees[i][_owner]));\r\n\t\t\t\treserves = safeAdd(reserves, unclaimedFees);\r\n\t\t\t\tclaimedFees[i][_owner] = safeAdd(claimedFees[i][_owner], unclaimedFees);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (uint x = lastClaimedRound[_receipient] + 1; x <= latestRound; x++){\r\n\t\t\t//Empty fees for new receipient\r\n\t\t\tclaimedFees[x][_receipient] = safeAdd(claimedFees[x][_receipient], numCoins * feePerUnitOfCoin(x));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tfunction feePerUnitOfCoin(uint round) public constant returns (uint fee){\r\n\t\treturn safeDiv(roundFees[round], recordedCoinSupplyForRound[round]);\r\n\t}\r\n\t\r\n\tfunction reservesPerUnitToken() public constant returns(uint) {\r\n\t    return reserves / totalSupply;\r\n\t}\r\n\t\r\n   function mintTokens(address _owner, uint amount) onlyFactory{\r\n       //Upon factory transfer, fees will be redistributed into reserves\r\n       lastClaimedRound[msg.sender] = latestRound;\r\n       totalSupply = safeAdd(totalSupply, amount);\r\n       balances[_owner] += amount;\r\n   }\r\n}\r\n\r\ncontract BurnableToken is CollectibleFeeToken{\r\n\r\n    event Burned(address indexed _owner, uint256 _value);\r\n    function burn(address _owner, uint amount) onlyDAO returns (uint burnValue){\r\n        require(balances[_owner] >= amount);\r\n        //Validation is done to ensure no fees remaining in token\r\n        require(latestRound == lastClaimedRound[_owner]);\r\n        burnValue = reservesPerUnitToken() * amount;\r\n        reserves = safeSub(reserves, burnValue);\r\n        balances[_owner] = safeSub(balances[_owner], amount);\r\n        totalSupply = safeSub(totalSupply, amount);\r\n        Transfer(_owner, this, amount);\r\n        Burned(_owner, amount);\r\n        return burnValue;\r\n    }\r\n    \r\n}\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Controlled {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    if (halted) throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!halted) throw;\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function halt() external onlyController {\r\n    halted = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function unhalt() external onlyController onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract SphereToken is BurnableToken, Haltable {\r\n    \r\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n    string public symbol;              //An identifier: e.g. REP\r\n    string public version = 'SPR_0.1'; //An arbitrary versioning scheme\r\n    bool public isTransferEnabled;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n    function SphereToken(){\r\n        name = 'EtherSphere';\r\n        symbol = 'SPR';\r\n        decimals = 4;\r\n        isTransferEnabled = false;\r\n    }\r\n  /**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http://vessenes.com/the-erc20-short-address-attack-explained/\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length != size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n    function setTransferEnable(bool enabled) onlyDAO{\r\n        isTransferEnabled = enabled;\r\n    }\r\n    function doTransfer(address _from, address _to, uint _value) private returns (bool success){\r\n        if (_value > balances[_from] || !isTransferEnabled) return false;\r\n        if (!_resetTransferredCoinFees(_from, _to, _value)) return false;\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) stopInEmergency returns (bool success) {\r\n    return doTransfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function exchangeTransfer(address _to, uint _value) stopInEmergency onlyFactory returns (bool success) {\r\n        if (_value > balances[msg.sender]) {return false;}\r\n        if (!_resetTransferredCoinFees(msg.sender, _to, _value)){ return false;}\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n  }\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) stopInEmergency returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    if (_value > balances[_from] || !isTransferEnabled || _value > _allowance) return false;\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    return doTransfer(_from, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) stopInEmergency returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\r\n        return false;\r\n    }\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * Atomic increment of approved spending\r\n   *\r\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   */\r\n  function addApproval(address _spender, uint _addedValue)\r\n  onlyPayloadSize(2 * 32) stopInEmergency\r\n  returns (bool success) {\r\n      uint oldValue = allowed[msg.sender][_spender];\r\n      allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\r\n      return true;\r\n  }\r\n\r\n  /**\r\n   * Atomic decrement of approved spending.\r\n   *\r\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   */\r\n  function subApproval(address _spender, uint _subtractedValue)\r\n  onlyPayloadSize(2 * 32) stopInEmergency\r\n  returns (bool success) {\r\n\r\n      uint oldVal = allowed[msg.sender][_spender];\r\n\r\n      if (_subtractedValue > oldVal) {\r\n          allowed[msg.sender][_spender] = 0;\r\n      } else {\r\n          allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue);\r\n      }\r\n      return true;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"reduceReserves\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"claimFees\",\"outputs\":[{\"name\":\"totalFees\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recordedCoinSupplyForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numFactories\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintingFactories\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"removeMintingFactory\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"feePerUnitOfCoin\",\"outputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetFactories\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"claimFeesForRound\",\"outputs\":[{\"name\":\"feeForRound\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserves\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"addReserves\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimedRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"burnValue\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"addMintingFactory\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"addApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTransferEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setTransferEnable\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"exchangeTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"subApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dao\",\"type\":\"address\"}],\"name\":\"setDAO\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"depositFees\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservesPerUnitToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SphereToken","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://17f531d3b5df3c0850abd7b72410ceae0147b641394a0e2d99bc96e128414454"}]}