{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract GenericCrowdsale {\r\n    address public icoBackend;\r\n    address public icoManager;\r\n    address public emergencyManager;\r\n\r\n    // paused state\r\n    bool paused = false;\r\n\r\n    /**\r\n     * @dev Confirms that token issuance for an off-chain purchase was processed successfully.\r\n     * @param _beneficiary Token holder.\r\n     * @param _contribution Money received (in USD cents). Copied from issueTokens call arguments.\r\n     * @param _tokensIssued The amount of tokens that was assigned to the holder, not counting bonuses.\r\n     */\r\n    event TokensAllocated(address _beneficiary, uint _contribution, uint _tokensIssued);\r\n\r\n    /**\r\n     * @dev Notifies about bonus token issuance. Is raised even if the bonus is 0.\r\n     * @param _beneficiary Token holder.\r\n     * @param _bonusTokensIssued The amount of bonus tokens that was assigned to the holder.\r\n     */\r\n    event BonusIssued(address _beneficiary, uint _bonusTokensIssued);\r\n\r\n    /**\r\n     * @dev Issues tokens for founders and partners and closes the current phase.\r\n     * @param foundersWallet Wallet address holding the vested tokens.\r\n     * @param tokensForFounders The amount of tokens vested for founders.\r\n     * @param partnersWallet Wallet address holding the tokens for early contributors.\r\n     * @param tokensForPartners The amount of tokens issued for rewarding early contributors.\r\n     */\r\n    event FoundersAndPartnersTokensIssued(address foundersWallet, uint tokensForFounders,\r\n                                          address partnersWallet, uint tokensForPartners);\r\n\r\n    event Paused();\r\n    event Unpaused();\r\n\r\n    /**\r\n     * @dev Issues tokens for the off-chain contributors by accepting calls from the trusted address.\r\n     *        Supposed to be run by the backend.\r\n     * @param _beneficiary Token holder.\r\n     * @param _contribution The equivalent (in USD cents) of the contribution received off-chain.\r\n     */\r\n    function issueTokens(address _beneficiary, uint _contribution) onlyBackend onlyUnpaused external;\r\n\r\n    /**\r\n     * @dev Issues tokens for the off-chain contributors by accepting calls from the trusted address.\r\n     *      Supposed to be run by the backend.\r\n     * @param _beneficiary Token holder.\r\n     * @param _contribution The equivalent (in USD cents) of the contribution received off-chain.\r\n     * @param _tokens Total Tokens to issue for the contribution, must be > 0\r\n     * @param _bonus How many tokens are bonuses, less or equal to _tokens\r\n     */\r\n    function issueTokensWithCustomBonus(address _beneficiary, uint _contribution, uint _tokens, uint _bonus) onlyBackend onlyUnpaused external;\r\n\r\n    /**\r\n     * @dev Pauses the token allocation process.\r\n     */\r\n    function pause() external onlyManager onlyUnpaused {\r\n        paused = true;\r\n        Paused();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpauses the token allocation process.\r\n     */\r\n    function unpause() external onlyManager onlyPaused {\r\n        paused = false;\r\n        Unpaused();\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the manager to change backends.\r\n     */\r\n    function changeicoBackend(address _icoBackend) external onlyManager {\r\n        icoBackend = _icoBackend;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifiers\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == icoManager);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBackend() {\r\n        require(msg.sender == icoBackend);\r\n        _;\r\n    }\r\n\r\n    modifier onlyEmergency() {\r\n        require(msg.sender == emergencyManager);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPaused() {\r\n        require(paused == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyUnpaused() {\r\n        require(paused == false);\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n\r\n  function balanceOf(address _owner) constant public returns (uint balance);\r\n  function transfer(address _to, uint _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n  function approve(address _spender, uint _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) constant public returns (uint remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint value);\r\n}\r\n\r\nlibrary SafeMath {\r\n   function mul(uint a, uint b) internal pure returns (uint) {\r\n     if (a == 0) {\r\n        return 0;\r\n      }\r\n\r\n      uint c = a * b;\r\n      assert(c / a == b);\r\n      return c;\r\n   }\r\n\r\n   function sub(uint a, uint b) internal pure returns (uint) {\r\n      assert(b <= a);\r\n      return a - b;\r\n   }\r\n\r\n   function add(uint a, uint b) internal pure returns (uint) {\r\n      uint c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n   }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract StandardToken is ERC20 {\r\n    using SafeMath for uint;\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) public returns (bool) {\r\n        if (balances[msg.sender] >= _value\r\n            && _value > 0\r\n            && _to != msg.sender\r\n            && _to != address(0)\r\n          ) {\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        if (balances[_from] >= _value\r\n            && allowed[_from][msg.sender] >= _value\r\n            && _value > 0\r\n            && _from != _to\r\n          ) {\r\n            balances[_to]   = balances[_to].add(_value);\r\n            balances[_from] = balances[_from].sub(_value);\r\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(_spender != address(0));\r\n        // needs to be called twice -> first set to 0, then increase to another amount\r\n        // this is to avoid race conditions\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        // useless operation\r\n        require(_spender != address(0));\r\n\r\n        // perform operation\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        // useless operation\r\n        require(_spender != address(0));\r\n\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint _size) {\r\n        require(msg.data.length >= _size + 4);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Cappasity is StandardToken {\r\n\r\n    // Constants\r\n    // =========\r\n    string public constant name = \"Cappasity\";\r\n    string public constant symbol = \"CAPP\";\r\n    uint8 public constant decimals = 2;\r\n    uint public constant TOKEN_LIMIT = 10 * 1e9 * 1e2; // 10 billion tokens, 2 decimals\r\n\r\n    // State variables\r\n    // ===============\r\n    address public manager;\r\n\r\n    // Block token transfers until ICO is finished.\r\n    bool public tokensAreFrozen = true;\r\n\r\n    // Allow/Disallow minting\r\n    bool public mintingIsAllowed = true;\r\n\r\n    // events for minting\r\n    event MintingAllowed();\r\n    event MintingDisabled();\r\n\r\n    // Freeze/Unfreeze assets\r\n    event TokensFrozen();\r\n    event TokensUnfrozen();\r\n\r\n    // Constructor\r\n    // ===========\r\n    function Cappasity(address _manager) public {\r\n        manager = _manager;\r\n    }\r\n\r\n    // Fallback function\r\n    // Do not allow to send money directly to this contract\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    // ERC20 functions\r\n    // =========================\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        require(!tokensAreFrozen);\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        require(!tokensAreFrozen);\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(!tokensAreFrozen);\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        require(!tokensAreFrozen);\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        require(!tokensAreFrozen);\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n\r\n    // PRIVILEGED FUNCTIONS\r\n    // ====================\r\n    modifier onlyByManager() {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    // Mint some tokens and assign them to an address\r\n    function mint(address _beneficiary, uint _value) external onlyByManager {\r\n        require(_value != 0);\r\n        require(totalSupply.add(_value) <= TOKEN_LIMIT);\r\n        require(mintingIsAllowed == true);\r\n\r\n        balances[_beneficiary] = balances[_beneficiary].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n    }\r\n\r\n    // Disable minting. Can be enabled later, but TokenAllocation.sol only does that once.\r\n    function endMinting() external onlyByManager {\r\n        require(mintingIsAllowed == true);\r\n        mintingIsAllowed = false;\r\n        MintingDisabled();\r\n    }\r\n\r\n    // Enable minting. See TokenAllocation.sol\r\n    function startMinting() external onlyByManager {\r\n        require(mintingIsAllowed == false);\r\n        mintingIsAllowed = true;\r\n        MintingAllowed();\r\n    }\r\n\r\n    // Disable token transfer\r\n    function freeze() external onlyByManager {\r\n        require(tokensAreFrozen == false);\r\n        tokensAreFrozen = true;\r\n        TokensFrozen();\r\n    }\r\n\r\n    // Allow token transfer\r\n    function unfreeze() external onlyByManager {\r\n        require(tokensAreFrozen == true);\r\n        tokensAreFrozen = false;\r\n        TokensUnfrozen();\r\n    }\r\n}\r\n\r\n/**\r\n * @dev For the tokens issued for founders.\r\n */\r\ncontract VestingWallet {\r\n    using SafeMath for uint;\r\n\r\n    event TokensReleased(uint _tokensReleased, uint _tokensRemaining, uint _nextPeriod);\r\n\r\n    address public foundersWallet;\r\n    address public crowdsaleContract;\r\n    ERC20 public tokenContract;\r\n\r\n    // Two-year vesting with 1 month cliff. Roughly.\r\n    bool public vestingStarted = false;\r\n    uint constant cliffPeriod = 30 days;\r\n    uint constant totalPeriods = 24;\r\n\r\n    uint public periodsPassed = 0;\r\n    uint public nextPeriod;\r\n    uint public tokensRemaining;\r\n    uint public tokensPerBatch;\r\n\r\n    // Constructor\r\n    // ===========\r\n    function VestingWallet(address _foundersWallet, address _tokenContract) public {\r\n        require(_foundersWallet != address(0));\r\n        require(_tokenContract != address(0));\r\n\r\n        foundersWallet    = _foundersWallet;\r\n        tokenContract     = ERC20(_tokenContract);\r\n        crowdsaleContract = msg.sender;\r\n    }\r\n\r\n    // PRIVILEGED FUNCTIONS\r\n    // ====================\r\n    function releaseBatch() external onlyFounders {\r\n        require(true == vestingStarted);\r\n        require(now > nextPeriod);\r\n        require(periodsPassed < totalPeriods);\r\n\r\n        uint tokensToRelease = 0;\r\n        do {\r\n            periodsPassed   = periodsPassed.add(1);\r\n            nextPeriod      = nextPeriod.add(cliffPeriod);\r\n            tokensToRelease = tokensToRelease.add(tokensPerBatch);\r\n        } while (now > nextPeriod);\r\n\r\n        // If vesting has finished, just transfer the remaining tokens.\r\n        if (periodsPassed >= totalPeriods) {\r\n            tokensToRelease = tokenContract.balanceOf(this);\r\n            nextPeriod = 0x0;\r\n        }\r\n\r\n        tokensRemaining = tokensRemaining.sub(tokensToRelease);\r\n        tokenContract.transfer(foundersWallet, tokensToRelease);\r\n\r\n        TokensReleased(tokensToRelease, tokensRemaining, nextPeriod);\r\n    }\r\n\r\n    function launchVesting() public onlyCrowdsale {\r\n        require(false == vestingStarted);\r\n\r\n        vestingStarted  = true;\r\n        tokensRemaining = tokenContract.balanceOf(this);\r\n        nextPeriod      = now.add(cliffPeriod);\r\n        tokensPerBatch  = tokensRemaining / totalPeriods;\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n    // ==================\r\n    modifier onlyFounders() {\r\n        require(msg.sender == foundersWallet);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCrowdsale() {\r\n        require(msg.sender == crowdsaleContract);\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n* @dev Prepaid token allocation for a capped crowdsale with bonus structure sliding on sales\r\n*      Written with OpenZeppelin sources as a rough reference.\r\n*/\r\ncontract TokenAllocation is GenericCrowdsale {\r\n    using SafeMath for uint;\r\n\r\n    // Events\r\n    event TokensAllocated(address _beneficiary, uint _contribution, uint _tokensIssued);\r\n    event BonusIssued(address _beneficiary, uint _bonusTokensIssued);\r\n    event FoundersAndPartnersTokensIssued(address _foundersWallet, uint _tokensForFounders,\r\n                                          address _partnersWallet, uint _tokensForPartners);\r\n\r\n    // Token information\r\n    uint public tokenRate = 125; // 1 USD = 125 CAPP; so 1 cent = 1.25 CAPP \\\r\n                                 // assuming CAPP has 2 decimals (as set in token contract)\r\n    Cappasity public tokenContract;\r\n\r\n    address public foundersWallet; // A wallet permitted to request tokens from the time vaults.\r\n    address public partnersWallet; // A wallet that distributes the tokens to early contributors.\r\n\r\n    // Crowdsale progress\r\n    uint constant public hardCap     = 5 * 1e7 * 1e2; // 50 000 000 dollars * 100 cents per dollar\r\n    uint constant public phaseOneCap = 3 * 1e7 * 1e2; // 30 000 000 dollars * 100 cents per dollar\r\n    uint public totalCentsGathered = 0;\r\n\r\n    // Total sum gathered in phase one, need this to adjust the bonus tiers in phase two.\r\n    // Updated only once, when the phase one is concluded.\r\n    uint public centsInPhaseOne = 0;\r\n    uint public totalTokenSupply = 0;     // Counting the bonuses, not counting the founders' share.\r\n\r\n    // Total tokens issued in phase one, including bonuses. Need this to correctly calculate the founders' \\\r\n    // share and issue it in parts, once after each round. Updated when issuing tokens.\r\n    uint public tokensDuringPhaseOne = 0;\r\n    VestingWallet public vestingWallet;\r\n\r\n    enum CrowdsalePhase { PhaseOne, BetweenPhases, PhaseTwo, Finished }\r\n    enum BonusPhase { TenPercent, FivePercent, None }\r\n\r\n    uint public constant bonusTierSize = 1 * 1e7 * 1e2; // 10 000 000 dollars * 100 cents per dollar\r\n    uint public constant bigContributionBound  = 1 * 1e5 * 1e2; // 100 000 dollars * 100 cents per dollar\r\n    uint public constant hugeContributionBound = 3 * 1e5 * 1e2; // 300 000 dollars * 100 cents per dollar\r\n    CrowdsalePhase public crowdsalePhase = CrowdsalePhase.PhaseOne;\r\n    BonusPhase public bonusPhase = BonusPhase.TenPercent;\r\n\r\n    /**\r\n     * @dev Constructs the allocator.\r\n     * @param _icoBackend Wallet address that should be owned by the off-chain backend, from which \\\r\n     *          \\ it mints the tokens for contributions accepted in other currencies.\r\n     * @param _icoManager Allowed to start phase 2.\r\n     * @param _foundersWallet Where the founders' tokens to to after vesting.\r\n     * @param _partnersWallet A wallet that distributes tokens to early contributors.\r\n     */\r\n    function TokenAllocation(address _icoManager,\r\n                             address _icoBackend,\r\n                             address _foundersWallet,\r\n                             address _partnersWallet,\r\n                             address _emergencyManager\r\n                             ) public {\r\n        require(_icoManager != address(0));\r\n        require(_icoBackend != address(0));\r\n        require(_foundersWallet != address(0));\r\n        require(_partnersWallet != address(0));\r\n        require(_emergencyManager != address(0));\r\n\r\n        tokenContract = new Cappasity(address(this));\r\n\r\n        icoManager       = _icoManager;\r\n        icoBackend       = _icoBackend;\r\n        foundersWallet   = _foundersWallet;\r\n        partnersWallet   = _partnersWallet;\r\n        emergencyManager = _emergencyManager;\r\n    }\r\n\r\n    // PRIVILEGED FUNCTIONS\r\n    // ====================\r\n    /**\r\n     * @dev Issues tokens for a particular address as for a contribution of size _contribution, \\\r\n     *          \\ then issues bonuses in proportion.\r\n     * @param _beneficiary Receiver of the tokens.\r\n     * @param _contribution Size of the contribution (in USD cents).\r\n     */\r\n    function issueTokens(address _beneficiary, uint _contribution) external onlyBackend onlyValidPhase onlyUnpaused {\r\n        // phase 1 cap less than hard cap\r\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\r\n            require(totalCentsGathered.add(_contribution) <= phaseOneCap);\r\n        } else {\r\n            require(totalCentsGathered.add(_contribution) <= hardCap);\r\n        }\r\n\r\n        uint remainingContribution = _contribution;\r\n\r\n        // Check if the contribution fills the current bonus phase. If so, break it up in parts,\r\n        // mint tokens for each part separately, assign bonuses, trigger events. For transparency.\r\n        do {\r\n            // 1 - calculate contribution part for current bonus stage\r\n            uint centsLeftInPhase = calculateCentsLeftInPhase(remainingContribution);\r\n            uint contributionPart = min(remainingContribution, centsLeftInPhase);\r\n\r\n            // 3 - mint tokens\r\n            uint tokensToMint = tokenRate.mul(contributionPart);\r\n            mintAndUpdate(_beneficiary, tokensToMint);\r\n            TokensAllocated(_beneficiary, contributionPart, tokensToMint);\r\n\r\n            // 4 - mint bonus\r\n            uint tierBonus = calculateTierBonus(contributionPart);\r\n            if (tierBonus > 0) {\r\n                mintAndUpdate(_beneficiary, tierBonus);\r\n                BonusIssued(_beneficiary, tierBonus);\r\n            }\r\n\r\n            // 5 - advance bonus phase\r\n            if ((bonusPhase != BonusPhase.None) && (contributionPart == centsLeftInPhase)) {\r\n                advanceBonusPhase();\r\n            }\r\n\r\n            // 6 - log the processed part of the contribution\r\n            totalCentsGathered = totalCentsGathered.add(contributionPart);\r\n            remainingContribution = remainingContribution.sub(contributionPart);\r\n\r\n            // 7 - continue?\r\n        } while (remainingContribution > 0);\r\n\r\n        // Mint contribution size bonus\r\n        uint sizeBonus = calculateSizeBonus(_contribution);\r\n        if (sizeBonus > 0) {\r\n            mintAndUpdate(_beneficiary, sizeBonus);\r\n            BonusIssued(_beneficiary, sizeBonus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Issues tokens for the off-chain contributors by accepting calls from the trusted address.\r\n     *        Supposed to be run by the backend. Used for distributing bonuses for affiliate transactions\r\n     *        and special offers\r\n     *\r\n     * @param _beneficiary Token holder.\r\n     * @param _contribution The equivalent (in USD cents) of the contribution received off-chain.\r\n     * @param _tokens Total token allocation size\r\n     * @param _bonus Bonus size\r\n     */\r\n    function issueTokensWithCustomBonus(address _beneficiary, uint _contribution, uint _tokens, uint _bonus)\r\n                                            external onlyBackend onlyValidPhase onlyUnpaused {\r\n\r\n        // sanity check, ensure we allocate more than 0\r\n        require(_tokens > 0);\r\n        // all tokens can be bonuses, but they cant be less than bonuses\r\n        require(_tokens >= _bonus);\r\n        // check capps\r\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\r\n            // ensure we are not over phase 1 cap after this contribution\r\n            require(totalCentsGathered.add(_contribution) <= phaseOneCap);\r\n        } else {\r\n            // ensure we are not over hard cap after this contribution\r\n            require(totalCentsGathered.add(_contribution) <= hardCap);\r\n        }\r\n\r\n        uint remainingContribution = _contribution;\r\n\r\n        // Check if the contribution fills the current bonus phase. If so, break it up in parts,\r\n        // mint tokens for each part separately, assign bonuses, trigger events. For transparency.\r\n        do {\r\n          // 1 - calculate contribution part for current bonus stage\r\n          uint centsLeftInPhase = calculateCentsLeftInPhase(remainingContribution);\r\n          uint contributionPart = min(remainingContribution, centsLeftInPhase);\r\n\r\n          // 3 - log the processed part of the contribution\r\n          totalCentsGathered = totalCentsGathered.add(contributionPart);\r\n          remainingContribution = remainingContribution.sub(contributionPart);\r\n\r\n          // 4 - advance bonus phase\r\n          if ((remainingContribution == centsLeftInPhase) && (bonusPhase != BonusPhase.None)) {\r\n              advanceBonusPhase();\r\n          }\r\n\r\n        } while (remainingContribution > 0);\r\n\r\n        // add tokens to the beneficiary\r\n        mintAndUpdate(_beneficiary, _tokens);\r\n\r\n        // if tokens arent equal to bonus\r\n        if (_tokens > _bonus) {\r\n          TokensAllocated(_beneficiary, _contribution, _tokens.sub(_bonus));\r\n        }\r\n\r\n        // if bonus exists\r\n        if (_bonus > 0) {\r\n          BonusIssued(_beneficiary, _bonus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Issues the rewards for founders and early contributors. 18% and 12% of the total token supply by the end\r\n     *   of the crowdsale, respectively, including all the token bonuses on early contributions. Can only be\r\n     *   called after the end of the crowdsale phase, ends the current phase.\r\n     */\r\n    function rewardFoundersAndPartners() external onlyManager onlyValidPhase onlyUnpaused {\r\n        uint tokensDuringThisPhase;\r\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\r\n            tokensDuringThisPhase = totalTokenSupply;\r\n        } else {\r\n            tokensDuringThisPhase = totalTokenSupply - tokensDuringPhaseOne;\r\n        }\r\n\r\n        // Total tokens sold is 70% of the overall supply, founders' share is 18%, early contributors' is 12%\r\n        // So to obtain those from tokens sold, multiply them by 0.18 / 0.7 and 0.12 / 0.7 respectively.\r\n        uint tokensForFounders = tokensDuringThisPhase.mul(257).div(1000); // 0.257 of 0.7 is 0.18 of 1\r\n        uint tokensForPartners = tokensDuringThisPhase.mul(171).div(1000); // 0.171 of 0.7 is 0.12 of 1\r\n\r\n        tokenContract.mint(partnersWallet, tokensForPartners);\r\n\r\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\r\n            vestingWallet = new VestingWallet(foundersWallet, address(tokenContract));\r\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\r\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\r\n                                            partnersWallet,         tokensForPartners);\r\n\r\n            // Store the total sum collected during phase one for calculations in phase two.\r\n            centsInPhaseOne = totalCentsGathered;\r\n            tokensDuringPhaseOne = totalTokenSupply;\r\n\r\n            // Enable token transfer.\r\n            tokenContract.unfreeze();\r\n            crowdsalePhase = CrowdsalePhase.BetweenPhases;\r\n        } else {\r\n            tokenContract.mint(address(vestingWallet), tokensForFounders);\r\n            vestingWallet.launchVesting();\r\n\r\n            FoundersAndPartnersTokensIssued(address(vestingWallet), tokensForFounders,\r\n                                            partnersWallet,         tokensForPartners);\r\n            crowdsalePhase = CrowdsalePhase.Finished;\r\n        }\r\n\r\n        tokenContract.endMinting();\r\n   }\r\n\r\n    /**\r\n     * @dev Set the CAPP / USD rate for Phase two, and then start the second phase of token allocation.\r\n     *        Can only be called by the crowdsale manager.\r\n     * _tokenRate How many CAPP per 1 USD cent. As dollars, CAPP has two decimals.\r\n     *            For instance: tokenRate = 125 means \"1.25 CAPP per USD cent\" <=> \"125 CAPP per USD\".\r\n     */\r\n    function beginPhaseTwo(uint _tokenRate) external onlyManager onlyUnpaused {\r\n        require(crowdsalePhase == CrowdsalePhase.BetweenPhases);\r\n        require(_tokenRate != 0);\r\n\r\n        tokenRate = _tokenRate;\r\n        crowdsalePhase = CrowdsalePhase.PhaseTwo;\r\n        bonusPhase = BonusPhase.TenPercent;\r\n        tokenContract.startMinting();\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to freeze all token transfers in the future\r\n     * This is done to allow migrating to new contract in the future\r\n     * If such need ever arises (ie Migration to ERC23, or anything that community decides worth doing)\r\n     */\r\n    function freeze() external onlyUnpaused onlyEmergency {\r\n        require(crowdsalePhase != CrowdsalePhase.PhaseOne);\r\n        tokenContract.freeze();\r\n    }\r\n\r\n    function unfreeze() external onlyUnpaused onlyEmergency {\r\n        require(crowdsalePhase != CrowdsalePhase.PhaseOne);\r\n        tokenContract.unfreeze();\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n    // ====================\r\n    function calculateCentsLeftInPhase(uint _remainingContribution) internal view returns(uint) {\r\n        // Ten percent bonuses happen in both Phase One and Phase two, therefore:\r\n        // Take the bonus tier size, subtract the total money gathered in the current phase\r\n        if (bonusPhase == BonusPhase.TenPercent) {\r\n            return bonusTierSize.sub(totalCentsGathered.sub(centsInPhaseOne));\r\n        }\r\n\r\n        if (bonusPhase == BonusPhase.FivePercent) {\r\n          // Five percent bonuses only happen in Phase One, so no need to account\r\n          // for the first phase separately.\r\n          return bonusTierSize.mul(2).sub(totalCentsGathered);\r\n        }\r\n\r\n        return _remainingContribution;\r\n    }\r\n\r\n    function mintAndUpdate(address _beneficiary, uint _tokensToMint) internal {\r\n        tokenContract.mint(_beneficiary, _tokensToMint);\r\n        totalTokenSupply = totalTokenSupply.add(_tokensToMint);\r\n    }\r\n\r\n    function calculateTierBonus(uint _contribution) constant internal returns (uint) {\r\n        // All bonuses are additive and not multiplicative\r\n        // Calculate bonus on contribution size, then convert it to bonus tokens.\r\n        uint tierBonus = 0;\r\n\r\n        // tierBonus tier tierBonuses. We make sure in issueTokens that the processed contribution \\\r\n        // falls entirely into one tier\r\n        if (bonusPhase == BonusPhase.TenPercent) {\r\n            tierBonus = _contribution.div(10); // multiply by 0.1\r\n        } else if (bonusPhase == BonusPhase.FivePercent) {\r\n            tierBonus = _contribution.div(20); // multiply by 0.05\r\n        }\r\n\r\n        tierBonus = tierBonus.mul(tokenRate);\r\n        return tierBonus;\r\n    }\r\n\r\n    function calculateSizeBonus(uint _contribution) constant internal returns (uint) {\r\n        uint sizeBonus = 0;\r\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\r\n            // 10% for huge contribution\r\n            if (_contribution >= hugeContributionBound) {\r\n                sizeBonus = _contribution.div(10); // multiply by 0.1\r\n            // 5% for big one\r\n            } else if (_contribution >= bigContributionBound) {\r\n                sizeBonus = _contribution.div(20); // multiply by 0.05\r\n            }\r\n\r\n            sizeBonus = sizeBonus.mul(tokenRate);\r\n        }\r\n        return sizeBonus;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Advance the bonus phase to next tier when appropriate, do nothing otherwise.\r\n     */\r\n    function advanceBonusPhase() internal onlyValidPhase {\r\n        if (crowdsalePhase == CrowdsalePhase.PhaseOne) {\r\n            if (bonusPhase == BonusPhase.TenPercent) {\r\n                bonusPhase = BonusPhase.FivePercent;\r\n            } else if (bonusPhase == BonusPhase.FivePercent) {\r\n                bonusPhase = BonusPhase.None;\r\n            }\r\n        } else if (bonusPhase == BonusPhase.TenPercent) {\r\n            bonusPhase = BonusPhase.None;\r\n        }\r\n    }\r\n\r\n    function min(uint _a, uint _b) internal pure returns (uint result) {\r\n        return _a < _b ? _a : _b;\r\n    }\r\n\r\n    /**\r\n     * Modifiers\r\n     */\r\n    modifier onlyValidPhase() {\r\n        require( crowdsalePhase == CrowdsalePhase.PhaseOne\r\n                 || crowdsalePhase == CrowdsalePhase.PhaseTwo );\r\n        _;\r\n    }\r\n\r\n    // Do not allow to send money directly to this contract\r\n    function() payable public {\r\n        revert();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bigContributionBound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundersWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoBackend\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCentsGathered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_contribution\",\"type\":\"uint256\"}],\"name\":\"issueTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensDuringPhaseOne\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phaseOneCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_contribution\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"issueTokensWithCustomBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hugeContributionBound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoBackend\",\"type\":\"address\"}],\"name\":\"changeicoBackend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"centsInPhaseOne\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnersWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsalePhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rewardFoundersAndPartners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusTierSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenRate\",\"type\":\"uint256\"}],\"name\":\"beginPhaseTwo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_icoManager\",\"type\":\"address\"},{\"name\":\"_icoBackend\",\"type\":\"address\"},{\"name\":\"_foundersWallet\",\"type\":\"address\"},{\"name\":\"_partnersWallet\",\"type\":\"address\"},{\"name\":\"_emergencyManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensIssued\",\"type\":\"uint256\"}],\"name\":\"TokensAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_bonusTokensIssued\",\"type\":\"uint256\"}],\"name\":\"BonusIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_foundersWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokensForFounders\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_partnersWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokensForPartners\",\"type\":\"uint256\"}],\"name\":\"FoundersAndPartnersTokensIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"}]","ContractName":"TokenAllocation","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000dc895137042e1b0959e85e60747ed9b58f0701000000000000000000000000005c1e464f8d4422e08b0620c7adcdcbbe0fb240000000000000000000000000008ebee8422f9fe222a9b2c4a14a595846a457a400000000000000000000000000bbb48739cfd64b622776a22a57d741e48164c4000000000000000000000000004899c9bae1129fe359e6faa2c97ab6095c7335","Library":"","SwarmSource":"bzzr://aae7252a04d75dd9b6180657454476c6b715329f50bb603876154f65c5a464a0"}]}