{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract ERC20 {\r\n    // Standard interface\r\n    function totalSupply() public constant returns(uint256 _totalSupply);\r\n    function balanceOf(address who) public constant returns(uint256 balance);\r\n    function transfer(address to, uint value) public returns(bool success);\r\n    function transferFrom(address from, address to, uint value) public returns(bool success);\r\n    function approve(address spender, uint value) public returns(bool success);\r\n    function allowance(address owner, address spender) public constant returns(uint remaining);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SMSCoin is ERC20 {\r\n    string public constant name = \"Speed Mining Service\";\r\n    string public constant symbol = \"SMS\";\r\n    uint256 public constant decimals = 3;\r\n\r\n    uint256 public constant UNIT = 10 ** decimals;\r\n\r\n    uint public totalSupply = 0; // (initial with 0), targeted 2.9 Million SMS\r\n\r\n    uint tokenSaleLot1 = 150000 * UNIT;\r\n    uint reservedBonusLot1 = 45000 * UNIT; // 45,000 tokens are the maximum possible bonus from 30% of 150,000 tokens in the bonus phase\r\n    uint tokenSaleLot2 = 50000 * UNIT;\r\n    uint tokenSaleLot3 = 50000 * UNIT;\r\n\r\n    struct BonusStruct {\r\n        uint8 ratio1;\r\n        uint8 ratio2;\r\n        uint8 ratio3;\r\n        uint8 ratio4;\r\n    }\r\n    BonusStruct bonusRatio;\r\n\r\n    uint public saleCounter = 0;\r\n\r\n    uint public limitedSale = 0;\r\n\r\n    uint public sentBonus = 0;\r\n\r\n    uint public soldToken = 0;\r\n\r\n    mapping(address => uint) balances;\r\n\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    address[] addresses;\r\n\r\n    mapping(address => address) private userStructs;\r\n\r\n    address owner;\r\n\r\n    address mint = address(this);   // Contract address as a minter\r\n    \r\n    address genesis = 0x0;\r\n\r\n    //uint256 public tokenPrice = 0.001 ether; // Test\r\n    uint256 public tokenPrice = 0.8 ether;\r\n\r\n    event Log(uint e);\r\n\r\n    event TOKEN(string e);\r\n\r\n    bool icoOnPaused = false;\r\n\r\n    uint256 startDate;\r\n\r\n    uint256 endDate;\r\n\r\n    uint currentPhase = 0;\r\n\r\n    bool needToBurn = false;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function SMSCoin() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Divide with safety check\r\n     */\r\n    function safeDiv(uint a, uint b) pure internal returns(uint) {\r\n        //overflow check; b must not be 0\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Multiplication with safety check\r\n     */\r\n    function safeMul(uint a, uint b) pure internal returns(uint) {\r\n        uint c = a * b;\r\n        //check result should not be other wise until a=0\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Add with safety check\r\n     */\r\n    function safeAdd(uint a, uint b) pure internal returns (uint) {\r\n        assert (a + b >= a);\r\n        return a + b;\r\n    }\r\n\r\n    function setBonus(uint8 ratio1, uint8 ratio2, uint8 ratio3, uint8 ratio4) private {\r\n        bonusRatio.ratio1 = ratio1;\r\n        bonusRatio.ratio2 = ratio2;\r\n        bonusRatio.ratio3 = ratio3;\r\n        bonusRatio.ratio4 = ratio4;\r\n    }\r\n\r\n    function calcBonus(uint256 sendingSMSToken) view private returns(uint256) {\r\n        uint256 sendingSMSBonus;\r\n\r\n        // Calculating bonus\r\n        if (sendingSMSToken < (10 * UNIT)) {            // 0-9\r\n            sendingSMSBonus = (sendingSMSToken * bonusRatio.ratio1) / 100;\r\n        } else if (sendingSMSToken < (50 * UNIT)) {     // 10-49\r\n            sendingSMSBonus = (sendingSMSToken * bonusRatio.ratio2) / 100;\r\n        } else if (sendingSMSToken < (100 * UNIT)) {    // 50-99\r\n            sendingSMSBonus = (sendingSMSToken * bonusRatio.ratio3) / 100;\r\n        } else {                                        // 100+\r\n            sendingSMSBonus = (sendingSMSToken * bonusRatio.ratio4) / 100;\r\n        }\r\n\r\n        return sendingSMSBonus;\r\n    }\r\n\r\n    // Selling SMS token\r\n    function () public payable {\r\n        uint256 receivedETH = 0;\r\n        uint256 sendingSMSToken = 0;\r\n        uint256 sendingSMSBonus = 0;\r\n        Log(msg.value);\r\n\r\n        // Only for selling to investors\r\n        if (!icoOnPaused && msg.sender != owner) {\r\n            if (now <= endDate) {\r\n                // All the phases\r\n                Log(currentPhase);\r\n\r\n                // Calculating SMS\r\n                receivedETH = (msg.value * UNIT);\r\n                sendingSMSToken = safeDiv(receivedETH, tokenPrice);\r\n                Log(sendingSMSToken);\r\n\r\n                // Calculating Bonus\r\n                if (currentPhase == 1 || currentPhase == 2 || currentPhase == 3) {\r\n                    // Phase 1-3 with Bonus 1\r\n                    sendingSMSBonus = calcBonus(sendingSMSToken);\r\n                    Log(sendingSMSBonus);\r\n                }\r\n\r\n                // Giving SMS + Bonus (if any)\r\n                Log(sendingSMSToken);\r\n                if (!transferTokens(msg.sender, sendingSMSToken, sendingSMSBonus))\r\n                    revert();\r\n            } else {\r\n                revert();\r\n            }\r\n\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    // ======== Bonus Period 1 ========\r\n    // --- Bonus ---\r\n    // 0-9 SMS -> 5%\r\n    // 10-49 SMS -> 10%\r\n    // 50-99 SMS -> 20%\r\n    // 100~ SMS -> 30%\r\n    // --- Time --- (2 days 9 hours 59 minutes 59 seconds )\r\n    // From 27 Oct 2017, 14:00 PM JST (27 Oct 2017, 5:00 AM GMT)\r\n    // To   29 Oct 2017, 23:59 PM JST (29 Oct 2017, 14:59 PM GMT)\r\n    function start1BonusPeriod1() external onlyOwner {\r\n        // Supply setting (only once)\r\n        if (currentPhase == 0) {\r\n            balances[owner] = tokenSaleLot1; // Start balance for SpeedMining Co., Ltd.\r\n            balances[address(this)] = tokenSaleLot1;  // Start balance for SMSCoin (for investors)\r\n            totalSupply = balances[owner] + balances[address(this)];\r\n            saleCounter = 0;\r\n            limitedSale = tokenSaleLot1;\r\n\r\n            // Add owner address into the list as the first wallet who own token(s)\r\n            addAddress(owner);\r\n\r\n            // Send owner account the initial tokens (rather than only a contract address)\r\n            Transfer(address(this), owner, balances[owner]);\r\n\r\n            // Set burning is needed\r\n            needToBurn = true;\r\n        }\r\n\r\n        // ICO stage init\r\n        icoOnPaused = false;\r\n        currentPhase = 1;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 2 days + 9 hours + 59 minutes + 59 seconds;\r\n\r\n        // Bonus setting \r\n        setBonus(5, 10, 20, 30);\r\n    }\r\n\r\n    // ======== Bonus Period 2 ========\r\n    // --- Bonus ---\r\n    // 0-9 SMS -> 3%\r\n    // 10-49 SMS -> 5%\r\n    // 50-99 SMS -> 10%\r\n    // 100~ SMS -> 15%\r\n    // --- Time --- (11 days 9 hours 59 minutes 59 seconds)\r\n    // From 30 Oct 2017, 14:00 PM JST (30 Oct 2017, 5:00 AM GMT)\r\n    // To   10 Nov 2017, 23:59 PM JST (10 Nov 2017, 14:59 PM GMT)\r\n    function start2BonusPeriod2() external onlyOwner {\r\n        // ICO stage init\r\n        icoOnPaused = false;\r\n        currentPhase = 2;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 11 days + 9 hours + 59 minutes + 59 seconds;\r\n\r\n        // Bonus setting \r\n        setBonus(3, 5, 10, 15);\r\n    }\r\n\r\n    // ======== Bonus Period 3 ========\r\n    // --- Bonus ---\r\n    // 0-9 SMS -> 1%\r\n    // 10-49 SMS -> 3%\r\n    // 50-99 SMS -> 5%\r\n    // 100~ SMS -> 8%\r\n    // --- Time --- (51 days)\r\n    // From 11 Nov 2017, 00:00 AM JST (10 Nov 2017, 15:00 PM GMT)\r\n    // To   31 Dec 2017, 23:59 PM JST (31 Dec 2017, 14:59 PM GMT)\r\n    function start3BonusPeriod3() external onlyOwner {\r\n        // ICO stage init\r\n        icoOnPaused = false;\r\n        currentPhase = 3;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 51 days;\r\n\r\n        // Bonus setting \r\n        setBonus(1, 3, 5, 8);\r\n    }\r\n\r\n    // ======== Normal Period 1 (2018) ========\r\n    // --- Time --- (31 days)\r\n    // From 1 Jan 2018, 00:00 AM JST (31 Dec 2017, 15:00 PM GMT)\r\n    // To   31 Jan 2018, 23:59 PM JST (31 Jan 2018, 14:59 PM GMT)\r\n    function start4NormalPeriod() external onlyOwner {\r\n        // ICO stage init\r\n        icoOnPaused = false;\r\n        currentPhase = 4;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 31 days;\r\n\r\n        // Reset bonus\r\n        setBonus(0, 0, 0, 0);\r\n    }\r\n\r\n    // ======== Normal Period 2 (2020) ========\r\n    // --- Bonus ---\r\n    // 3X\r\n    // --- Time --- (7 days)\r\n    // From 2 Jan 2020, 00:00 AM JST (1 Jan 2020, 15:00 PM GMT)\r\n    // To   8 Jan 2020, 23:59 PM JST (8 Oct 2020, 14:59 PM GMT)\r\n    function start5Phase2020() external onlyOwner {\r\n        // Supply setting (only after phase 4)\r\n        if (currentPhase == 4) {\r\n            // Burn SMS if it was not done yet\r\n            if (needToBurn)\r\n                burnSMSProcess();\r\n                \r\n            balances[address(this)] = tokenSaleLot2;\r\n            totalSupply = 3 * totalSupply;\r\n            totalSupply += balances[address(this)];\r\n            saleCounter = 0;\r\n            limitedSale = tokenSaleLot2;\r\n\r\n            // Bonus\r\n            x3Token(); // 3X distributions to token holders\r\n\r\n            // Mint new tokens for 2020\r\n            Transfer(mint, address(this), balances[address(this)]);\r\n\r\n            // Set burning is needed\r\n            needToBurn = true;\r\n        }\r\n\r\n        // ICO stage init\r\n        icoOnPaused = false;\r\n        currentPhase = 5;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 7 days;\r\n    }\r\n\r\n    // ======== Normal Period 3 (2025) ========\r\n    // --- Bonus ---\r\n    // 3X\r\n    // --- Time --- (7 days)\r\n    // From 2 Jan 2025, 00:00 AM JST (1 Jan 2025, 15:00 PM GMT)\r\n    // To   8 Jan 2025, 23:59 PM JST (8 Oct 2025, 14:59 PM GMT)\r\n    function start6Phase2025() external onlyOwner {\r\n        // Supply setting (only after phase 5)\r\n        if (currentPhase == 5) {\r\n            // Burn SMS if it was not done yet\r\n            if (needToBurn)\r\n                burnSMSProcess();\r\n\r\n            balances[address(this)] = tokenSaleLot3;\r\n            totalSupply = 3 * totalSupply;\r\n            totalSupply += balances[address(this)];\r\n            saleCounter = 0;\r\n            limitedSale = tokenSaleLot3;\r\n            \r\n            // Bonus\r\n            x3Token(); // 3X distributions to token holders\r\n\r\n            // Mint new tokens for 2025\r\n            Transfer(mint, address(this), balances[address(this)]);\r\n\r\n            // Set burning is needed\r\n            needToBurn = true;\r\n        }\r\n        \r\n        // ICO stage init\r\n        icoOnPaused = false;\r\n        currentPhase = 6;\r\n        startDate = block.timestamp;\r\n        endDate = startDate + 7 days;\r\n    }\r\n\r\n    function x3Token() private {\r\n        // Multiply token by 3 to all the current addresses\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            uint curr1XBalance = balances[addresses[i]];\r\n            // In total 3X, then also calculate value to balances\r\n            balances[addresses[i]] = 3 * curr1XBalance;\r\n            // Transfer 2X from Mint to add with the existing 1X\r\n            Transfer(mint, addresses[i], 2 * curr1XBalance);\r\n            // To keep tracking bonus distribution\r\n            sentBonus += (2 * curr1XBalance);\r\n        }\r\n    }\r\n\r\n    // Called by the owner, to emergency pause the current phase\r\n    function pausePhase() external onlyOwner {\r\n        icoOnPaused = true;\r\n    }\r\n\r\n    // Called by the owner, to resumes the paused phase\r\n    function resumePhase() external onlyOwner {\r\n        icoOnPaused = false;\r\n    }\r\n\r\n    // Standard interface\r\n    function totalSupply() public constant returns(uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address sender) public constant returns(uint256 balance) {\r\n        return balances[sender];\r\n    }\r\n\r\n    function soldToken() public constant returns(uint256 _soldToken) {\r\n        return soldToken;\r\n    }\r\n\r\n    function sentBonus() public constant returns(uint256 _sentBonus) {\r\n        return sentBonus;\r\n    }\r\n\r\n    function saleCounter() public constant returns(uint256 _saleCounter) {\r\n        return saleCounter;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool success) {\r\n        if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n                \r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Price should be entered in multiple of 10000's\r\n    // E.g. for .0001 ether enter 1, for 5 ether price enter 50000 \r\n    function setTokenPrice(uint ethRate) external onlyOwner {\r\n        tokenPrice = (ethRate * 10 ** 18) / 10000; // (Convert to ether unit then make 4 decimals)\r\n    }\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _amount) public returns(bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Transfer the balance from caller's wallet address to investor's wallet address\r\n    function transfer(address _to, uint256 _amount) public returns(bool success) {\r\n        if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n\r\n            // Add destination wallet address to the list\r\n            addAddress(_to);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Transfer the balance from SMS's contract address to an investor's wallet account\r\n    function transferTokens(address _to, uint256 _amount, uint256 _bonus) private returns(bool success) {\r\n        if (_amount > 0 && balances[address(this)] >= _amount && balances[address(this)] - _amount >= 0 && soldToken + _amount > soldToken && saleCounter + _amount <= limitedSale && balances[_to] + _amount > balances[_to]) {\r\n            \r\n            // Transfer token from contract to target\r\n            balances[address(this)] -= _amount;\r\n            soldToken += _amount;\r\n            saleCounter += _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(address(this), _to, _amount);\r\n            \r\n            // Transfer bonus token from owner to target\r\n            if (currentPhase <= 3 && _bonus > 0 && balances[owner] - _bonus >= 0 && sentBonus + _bonus > sentBonus && sentBonus + _bonus <= reservedBonusLot1 && balances[_to] + _bonus > balances[_to]) {\r\n\r\n                // Transfer with bonus\r\n                balances[owner] -= _bonus;\r\n                sentBonus += _bonus;\r\n                balances[_to] += _bonus;\r\n                Transfer(owner, _to, _bonus);\r\n            }\r\n\r\n            // Add investor wallet address to the list\r\n            addAddress(_to);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Add wallet address with existing check\r\n    function addAddress(address _to) private {\r\n        if (addresses.length > 0) {\r\n            if (userStructs[_to] != _to) {\r\n                userStructs[_to] = _to;\r\n                addresses.push(_to);\r\n            }\r\n        } else {\r\n            userStructs[_to] = _to;\r\n            addresses.push(_to);\r\n        }\r\n    }\r\n\r\n    // Drain all the available ETH from the contract back to owner's wallet\r\n    function drainETH() external onlyOwner {\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    // Burn all the available SMS from the contract and from owner to make it equal to investors\r\n    // This will burn only the available token up to the current phase\r\n    // A burning function \r\n    function burnSMSProcess() private {\r\n        // Allow to burn left SMS only on phase 4, 5, 6\r\n        if (currentPhase >= 4) {\r\n            // Burn all available tokens\r\n            // From SMS contract\r\n            if (balances[address(this)] > 0) {\r\n                uint toBeBurnedFromContract = balances[address(this)];\r\n                Transfer(address(this), genesis, toBeBurnedFromContract);\r\n                balances[address(this)] = 0;\r\n                totalSupply -= toBeBurnedFromContract;\r\n\r\n                // Burn from owner wallet only in phase 4\r\n                if (currentPhase == 4) {\r\n                    if (balances[owner] > soldToken) {\r\n                        uint toBeBurnedFromOwner = balances[owner] - soldToken;\r\n                        Transfer(owner, genesis, toBeBurnedFromOwner);\r\n                        balances[owner] = balances[owner] - toBeBurnedFromOwner;\r\n                        totalSupply -= toBeBurnedFromOwner;\r\n                    }\r\n                }\r\n\r\n                // Clear burning status\r\n                needToBurn = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function used in Reward contract to know address of token holder\r\n    function getAddress(uint i) public constant returns(address) {\r\n        return addresses[i];\r\n    }\r\n\r\n    // Function used in Reward contract to get to know the address array length\r\n    function getAddressSize() public constant returns(uint) {\r\n        return addresses.length;\r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"saleCounter\",\"outputs\":[{\"name\":\"_saleCounter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start2BonusPeriod2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start4NormalPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sentBonus\",\"outputs\":[{\"name\":\"_sentBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldToken\",\"outputs\":[{\"name\":\"_soldToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ethRate\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumePhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitedSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start1BonusPeriod1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pausePhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start3BonusPeriod3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drainETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start5Phase2020\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start6Phase2025\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"e\",\"type\":\"uint256\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"e\",\"type\":\"string\"}],\"name\":\"TOKEN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SMSCoin","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a210c00c7b21d17568d0733ed0d0ee312507e9c3491f84783c749be0c780435e"}]}