{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function getOwner() returns(address){\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * Базовый контракт, который поддерживает остановку продаж\r\n */\r\n\r\ncontract Haltable is Ownable {\r\n    bool public halted;\r\n\r\n    modifier stopInEmergency {\r\n        require(!halted);\r\n        _;\r\n    }\r\n\r\n    /* Модификатор, который вызывается в потомках */\r\n    modifier onlyInEmergency {\r\n        require(halted);\r\n        _;\r\n    }\r\n\r\n    /* Вызов функции прервет продажи, вызывать может только владелец */\r\n    function halt() external onlyOwner {\r\n        halted = true;\r\n    }\r\n\r\n    /* Вызов возвращает режим продаж */\r\n    function unhalt() external onlyOwner onlyInEmergency {\r\n        halted = false;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Различные валидаторы\r\n */\r\n\r\ncontract ValidationUtil {\r\n    function requireNotEmptyAddress(address value) internal{\r\n        require(isAddressValid(value));\r\n    }\r\n\r\n    function isAddressValid(address value) internal constant returns (bool result){\r\n        return value != 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n  \r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until \r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) \r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) \r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Шаблон для токена, который можно сжечь\r\n*/\r\ncontract BurnableToken is StandardToken, Ownable, ValidationUtil {\r\n    using SafeMath for uint;\r\n\r\n    address public tokenOwnerBurner;\r\n\r\n    /** Событие, сколько токенов мы сожгли */\r\n    event Burned(address burner, uint burnedAmount);\r\n\r\n    function setOwnerBurner(address _tokenOwnerBurner) public onlyOwner invalidOwnerBurner{\r\n        // Проверка, что адрес не пустой\r\n        requireNotEmptyAddress(_tokenOwnerBurner);\r\n\r\n        tokenOwnerBurner = _tokenOwnerBurner;\r\n    }\r\n\r\n    /**\r\n     * Сжигаем токены на балансе владельца токенов, вызвать может только tokenOwnerBurner\r\n     */\r\n    function burnOwnerTokens(uint burnAmount) public onlyTokenOwnerBurner validOwnerBurner{\r\n        burnTokens(tokenOwnerBurner, burnAmount);\r\n    }\r\n\r\n    /**\r\n     * Сжигаем токены на балансе адреса токенов, вызвать может только tokenOwnerBurner\r\n     */\r\n    function burnTokens(address _address, uint burnAmount) public onlyTokenOwnerBurner validOwnerBurner{\r\n        balances[_address] = balances[_address].sub(burnAmount);\r\n\r\n        // Вызываем событие\r\n        Burned(_address, burnAmount);\r\n    }\r\n\r\n    /**\r\n     * Сжигаем все токены на балансе владельца\r\n     */\r\n    function burnAllOwnerTokens() public onlyTokenOwnerBurner validOwnerBurner{\r\n        uint burnAmount = balances[tokenOwnerBurner];\r\n        burnTokens(tokenOwnerBurner, burnAmount);\r\n    }\r\n\r\n    /** Модификаторы\r\n     */\r\n    modifier onlyTokenOwnerBurner() {\r\n        require(msg.sender == tokenOwnerBurner);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier validOwnerBurner() {\r\n        // Проверка, что адрес не пустой\r\n        requireNotEmptyAddress(tokenOwnerBurner);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier invalidOwnerBurner() {\r\n        // Проверка, что адрес не пустой\r\n        require(!isAddressValid(tokenOwnerBurner));\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * Токен продаж\r\n *\r\n * ERC-20 токен, для ICO\r\n *\r\n */\r\n\r\ncontract CrowdsaleToken is StandardToken, Ownable {\r\n\r\n    /* Описание см. в конструкторе */\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint public decimals;\r\n\r\n    address public mintAgent;\r\n\r\n    /** Событие обновления токена (имя и символ) */\r\n    event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n    /** Событие выпуска токенов */\r\n    event TokenMinted(uint amount, address toAddress);\r\n\r\n    /**\r\n     * Конструктор\r\n     *\r\n     * Токен должен быть создан только владельцем через кошелек (либо с мультиподписью, либо без нее)\r\n     *\r\n     * @param _name - имя токена\r\n     * @param _symbol - символ токена\r\n     * @param _decimals - кол-во знаков после запятой\r\n     */\r\n    function CrowdsaleToken(string _name, string _symbol, uint _decimals) {\r\n        owner = msg.sender;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n     * Владелец должен вызвать эту функцию, чтобы выпустить токены на адрес\r\n     */\r\n    function mintToAddress(uint amount, address toAddress) onlyMintAgent{\r\n        // перевод токенов на аккаунт\r\n        balances[toAddress] = amount;\r\n\r\n        // вызываем событие\r\n        TokenMinted(amount, toAddress);\r\n    }\r\n\r\n    /**\r\n     * Владелец может обновить инфу по токену\r\n     */\r\n    function setTokenInformation(string _name, string _symbol) onlyOwner {\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        // Вызываем событие\r\n        UpdatedTokenInformation(name, symbol);\r\n    }\r\n\r\n    /**\r\n     * Только владелец может обновить агента для создания токенов\r\n     */\r\n    function setMintAgent(address _address) onlyOwner {\r\n        mintAgent =  _address;\r\n    }\r\n\r\n    modifier onlyMintAgent(){\r\n        require(msg.sender == mintAgent);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * Шаблон для продаж токена, который можно сжечь\r\n *\r\n */\r\ncontract BurnableCrowdsaleToken is BurnableToken, CrowdsaleToken {\r\n\r\n    function BurnableCrowdsaleToken(string _name, string _symbol, uint _decimals) CrowdsaleToken(_name, _symbol, _decimals) BurnableToken(){\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Базовый контракт для продаж\r\n *\r\n * Содержит\r\n * - Дата начала и конца\r\n */\r\n\r\n/* Продажи могут быть остановлены в любой момент по вызову halt() */\r\n\r\ncontract AllocatedCappedCrowdsale is Haltable, ValidationUtil {\r\n    using SafeMath for uint;\r\n\r\n    // Кол-во токенов для распределения\r\n    uint public advisorsTokenAmount = 8040817;\r\n    uint public supportTokenAmount = 3446064;\r\n    uint public marketingTokenAmount = 3446064;\r\n    uint public teamTokenAmount = 45947521;\r\n\r\n    uint public teamTokensIssueDate;\r\n\r\n    /* Токен, который продаем */\r\n    BurnableCrowdsaleToken public token;\r\n\r\n    /* Адрес, куда будут переведена собранная сумма, в случае успеха */\r\n    address public destinationMultisigWallet;\r\n\r\n    /* Первая стадия в формате UNIX timestamp */\r\n    uint public firstStageStartsAt;\r\n    /* Конец продаж в формате UNIX timestamp */\r\n    uint public firstStageEndsAt;\r\n\r\n    /* Вторая стадия в формате UNIX timestamp */\r\n    uint public secondStageStartsAt;\r\n    /* Конец продаж в формате UNIX timestamp */\r\n    uint public secondStageEndsAt;\r\n\r\n    /* Минимальная кепка для первой стадии в центах */\r\n    uint public softCapFundingGoalInCents = 392000000;\r\n\r\n    /* Минимальная кепка для второй стадии в центах */\r\n    uint public hardCapFundingGoalInCents = 985000000;\r\n\r\n    /* Сколько всего в wei мы получили 10^18 wei = 1 ether */\r\n    uint public weiRaised;\r\n\r\n    /* Сколько всего собрали в ценах на первой стадии */\r\n    uint public firstStageRaisedInWei;\r\n\r\n    /* Сколько всего собрали в ценах на второй стадии */\r\n    uint public secondStageRaisedInWei;\r\n\r\n    /* Кол-во уникальных адресов, которые у наc получили токены */\r\n    uint public investorCount;\r\n\r\n    /*  Сколько wei отдали инвесторам на refund'е в wei */\r\n    uint public weiRefunded;\r\n\r\n    /*  Сколько токенов продали всего */\r\n    uint public tokensSold;\r\n\r\n    /* Флаг того, что сработал финализатор первой стадии */\r\n    bool public isFirstStageFinalized;\r\n\r\n    /* Флаг того, что сработал финализатор второй стадии */\r\n    bool public isSecondStageFinalized;\r\n\r\n    /* Флаг нормального завершнения продаж */\r\n    bool public isSuccessOver;\r\n\r\n    /* Флаг того, что начался процесс возврата */\r\n    bool public isRefundingEnabled;\r\n\r\n    /*  Сколько сейчас стоит 1 eth в центах, округленная до целых */\r\n    uint public currentEtherRateInCents;\r\n\r\n    /* Текущая стоимость токена в центах */\r\n    uint public oneTokenInCents = 7;\r\n\r\n    /* Выпущены ли токены для первой стадии */\r\n    bool public isFirstStageTokensMinted;\r\n\r\n    /* Выпущены ли токены для второй стадии */\r\n    bool public isSecondStageTokensMinted;\r\n\r\n    /* Кол-во токенов для первой стадии */\r\n    uint public firstStageTotalSupply = 112000000;\r\n\r\n    /* Кол-во токенов проданных на первой стадии*/\r\n    uint public firstStageTokensSold;\r\n\r\n    /* Кол-во токенов для второй стадии */\r\n    uint public secondStageTotalSupply = 229737610;\r\n\r\n    /* Кол-во токенов проданных на второй стадии*/\r\n    uint public secondStageTokensSold;\r\n\r\n    /* Кол-во токенов, которые находятся в резерве и не продаются, после успеха, они распределяются в соотвествии с Token Policy на второй стадии*/\r\n    uint public secondStageReserve = 60880466;\r\n\r\n    /* Кол-во токенов предназначенных для продажи, на второй стадии*/\r\n    uint public secondStageTokensForSale;\r\n\r\n    /* Мапа адрес инвестора - кол-во выданных токенов */\r\n    mapping (address => uint) public tokenAmountOf;\r\n\r\n    /* Мапа, адрес инвестора - кол-во эфира */\r\n    mapping (address => uint) public investedAmountOf;\r\n\r\n    /* Адреса, куда будут распределены токены */\r\n    address public advisorsAccount;\r\n    address public marketingAccount;\r\n    address public supportAccount;\r\n    address public teamAccount;\r\n\r\n    /** Возможные состояния\r\n     *\r\n     * - Prefunding: подготовка, залили контракт, но текущая дата меньше даты первой стадии\r\n     * - FirstStageFunding: Продажи первой стадии\r\n     * - FirstStageEnd: Окончены продажи первой стадии, но еще не вызван финализатор первой стадии\r\n     * - SecondStageFunding: Продажи второго этапа\r\n     * - SecondStageEnd: Окончены продажи второй стадии, но не вызван финализатор второй сдадии\r\n     * - Success: Успешно закрыли ICO\r\n     * - Failure: Не собрали Soft Cap\r\n     * - Refunding: Возвращаем собранный эфир\r\n     */\r\n    enum State{PreFunding, FirstStageFunding, FirstStageEnd, SecondStageFunding, SecondStageEnd, Success, Failure, Refunding}\r\n\r\n    // Событие покупки токена\r\n    event Invested(address indexed investor, uint weiAmount, uint tokenAmount, uint centAmount, uint txId);\r\n\r\n    // Событие изменения курса eth\r\n    event ExchangeRateChanged(uint oldExchangeRate, uint newExchangeRate);\r\n\r\n    // Событие изменения даты окончания первой стадии\r\n    event FirstStageStartsAtChanged(uint newFirstStageStartsAt);\r\n    event FirstStageEndsAtChanged(uint newFirstStageEndsAt);\r\n\r\n    // Событие изменения даты окончания второй стадии\r\n    event SecondStageStartsAtChanged(uint newSecondStageStartsAt);\r\n    event SecondStageEndsAtChanged(uint newSecondStageEndsAt);\r\n\r\n    // Событие изменения Soft Cap'а\r\n    event SoftCapChanged(uint newGoal);\r\n\r\n    // Событие изменения Hard Cap'а\r\n    event HardCapChanged(uint newGoal);\r\n\r\n    // Конструктор\r\n    function AllocatedCappedCrowdsale(uint _currentEtherRateInCents, address _token, address _destinationMultisigWallet, uint _firstStageStartsAt, uint _firstStageEndsAt, uint _secondStageStartsAt, uint _secondStageEndsAt, address _advisorsAccount, address _marketingAccount, address _supportAccount, address _teamAccount, uint _teamTokensIssueDate) {\r\n        requireNotEmptyAddress(_destinationMultisigWallet);\r\n        // Проверка, что даты установлены\r\n        require(_firstStageStartsAt != 0);\r\n        require(_firstStageEndsAt != 0);\r\n\r\n        require(_firstStageStartsAt < _firstStageEndsAt);\r\n\r\n        require(_secondStageStartsAt != 0);\r\n        require(_secondStageEndsAt != 0);\r\n\r\n        require(_secondStageStartsAt < _secondStageEndsAt);\r\n        require(_teamTokensIssueDate != 0);\r\n\r\n        // Токен, который поддерживает сжигание\r\n        token = BurnableCrowdsaleToken(_token);\r\n\r\n        destinationMultisigWallet = _destinationMultisigWallet;\r\n\r\n        firstStageStartsAt = _firstStageStartsAt;\r\n        firstStageEndsAt = _firstStageEndsAt;\r\n        secondStageStartsAt = _secondStageStartsAt;\r\n        secondStageEndsAt = _secondStageEndsAt;\r\n\r\n        // Адреса кошельков для адвизоров, маркетинга, команды\r\n        advisorsAccount = _advisorsAccount;\r\n        marketingAccount = _marketingAccount;\r\n        supportAccount = _supportAccount;\r\n        teamAccount = _teamAccount;\r\n\r\n        teamTokensIssueDate = _teamTokensIssueDate;\r\n\r\n        currentEtherRateInCents = _currentEtherRateInCents;\r\n\r\n        secondStageTokensForSale = secondStageTotalSupply.sub(secondStageReserve);\r\n    }\r\n\r\n    /**\r\n     * Функция, инициирующая нужное кол-во токенов для первого этапа продаж, вызвать можно только 1 раз\r\n     */\r\n    function mintTokensForFirstStage() public onlyOwner {\r\n        // Если уже создали токены для первой стадии, делаем откат\r\n        require(!isFirstStageTokensMinted);\r\n\r\n        uint tokenMultiplier = 10 ** token.decimals();\r\n\r\n        token.mintToAddress(firstStageTotalSupply.mul(tokenMultiplier), address(this));\r\n\r\n        isFirstStageTokensMinted = true;\r\n    }\r\n\r\n    /**\r\n     * Функция, инициирующая нужное кол-во токенов для второго этапа продаж, только в случае, если это еще не сделано и были созданы токены для первой стадии\r\n     */\r\n    function mintTokensForSecondStage() private {\r\n        // Если уже создали токены для второй стадии, делаем откат\r\n        require(!isSecondStageTokensMinted);\r\n\r\n        require(isFirstStageTokensMinted);\r\n\r\n        uint tokenMultiplier = 10 ** token.decimals();\r\n\r\n        token.mintToAddress(secondStageTotalSupply.mul(tokenMultiplier), address(this));\r\n\r\n        isSecondStageTokensMinted = true;\r\n    }\r\n\r\n    /**\r\n     * Функция возвращающая текущую стоимость 1 токена в wei\r\n     */\r\n    function getOneTokenInWei() external constant returns(uint){\r\n        return oneTokenInCents.mul(10 ** 18).div(currentEtherRateInCents);\r\n    }\r\n\r\n    /**\r\n     * Функция, которая переводит wei в центы по текущему курсу\r\n     */\r\n    function getWeiInCents(uint value) public constant returns(uint){\r\n        return currentEtherRateInCents.mul(value).div(10 ** 18);\r\n    }\r\n\r\n    /**\r\n     * Перевод токенов покупателю\r\n     */\r\n    function assignTokens(address receiver, uint tokenAmount) private {\r\n        // Если перевод не удался, откатываем транзакцию\r\n        if (!token.transfer(receiver, tokenAmount)) revert();\r\n    }\r\n\r\n    /**\r\n     * Fallback функция вызывающаяся при переводе эфира\r\n     */\r\n    function() payable {\r\n        buy();\r\n    }\r\n\r\n    /**\r\n     * Низкоуровневая функция перевода эфира и выдачи токенов\r\n     */\r\n    function internalAssignTokens(address receiver, uint tokenAmount, uint weiAmount, uint centAmount, uint txId) internal {\r\n        // Переводим токены инвестору\r\n        assignTokens(receiver, tokenAmount);\r\n\r\n        // Вызываем событие\r\n        Invested(receiver, weiAmount, tokenAmount, centAmount, txId);\r\n\r\n        // Может переопределяеться в наследниках\r\n    }\r\n\r\n    /**\r\n     * Инвестиции\r\n     * Должен быть включен режим продаж первой или второй стадии и не собран Hard Cap\r\n     * @param receiver - эфирный адрес получателя\r\n     * @param txId - id внешней транзакции\r\n     */\r\n    function internalInvest(address receiver, uint weiAmount, uint txId) stopInEmergency inFirstOrSecondFundingState notHardCapReached internal {\r\n        State currentState = getState();\r\n\r\n        uint tokenMultiplier = 10 ** token.decimals();\r\n\r\n        uint amountInCents = getWeiInCents(weiAmount);\r\n\r\n        // Очень внимательно нужно менять значения, т.к. для второй стадии 1000%, чтобы учесть дробные значения\r\n        uint bonusPercentage = 0;\r\n        uint bonusStateMultiplier = 1;\r\n\r\n        // если запущена первая стадия, в конструкторе уже выпустили нужное кол-во токенов для первой стадии\r\n        if (currentState == State.FirstStageFunding){\r\n            // меньше 25000$ не принимаем\r\n            require(amountInCents >= 2500000);\r\n\r\n            // [25000$ - 50000$) - 50% бонуса\r\n            if (amountInCents >= 2500000 && amountInCents < 5000000){\r\n                bonusPercentage = 50;\r\n            // [50000$ - 100000$) - 75% бонуса\r\n            }else if(amountInCents >= 5000000 && amountInCents < 10000000){\r\n                bonusPercentage = 75;\r\n            // >= 100000$ - 100% бонуса\r\n            }else if(amountInCents >= 10000000){\r\n                bonusPercentage = 100;\r\n            }else{\r\n                revert();\r\n            }\r\n\r\n        // если запущена вторая стадия\r\n        } else if(currentState == State.SecondStageFunding){\r\n            // Процент проданных токенов, будем считать с множителем 10, т.к. есть дробные значения\r\n            bonusStateMultiplier = 10;\r\n\r\n            // Кол-во проданных токенов нужно считать от значения тех токенов, которые предназначены для продаж, т.е. secondStageTokensForSale\r\n            uint tokensSoldPercentage = secondStageTokensSold.mul(100).div(secondStageTokensForSale.mul(tokenMultiplier));\r\n\r\n            // меньше 7$ не принимаем\r\n            require(amountInCents >= 700);\r\n\r\n            // (0% - 10%) - 20% бонуса\r\n            if (tokensSoldPercentage >= 0 && tokensSoldPercentage < 10){\r\n                bonusPercentage = 200;\r\n            // [10% - 20%) - 17.5% бонуса\r\n            }else if (tokensSoldPercentage >= 10 && tokensSoldPercentage < 20){\r\n                bonusPercentage = 175;\r\n            // [20% - 30%) - 15% бонуса\r\n            }else if (tokensSoldPercentage >= 20 && tokensSoldPercentage < 30){\r\n                bonusPercentage = 150;\r\n            // [30% - 40%) - 12.5% бонуса\r\n            }else if (tokensSoldPercentage >= 30 && tokensSoldPercentage < 40){\r\n                bonusPercentage = 125;\r\n            // [40% - 50%) - 10% бонуса\r\n            }else if (tokensSoldPercentage >= 40 && tokensSoldPercentage < 50){\r\n                bonusPercentage = 100;\r\n            // [50% - 60%) - 8% бонуса\r\n            }else if (tokensSoldPercentage >= 50 && tokensSoldPercentage < 60){\r\n                bonusPercentage = 80;\r\n            // [60% - 70%) - 6% бонуса\r\n            }else if (tokensSoldPercentage >= 60 && tokensSoldPercentage < 70){\r\n                bonusPercentage = 60;\r\n            // [70% - 80%) - 4% бонуса\r\n            }else if (tokensSoldPercentage >= 70 && tokensSoldPercentage < 80){\r\n                bonusPercentage = 40;\r\n            // [80% - 90%) - 2% бонуса\r\n            }else if (tokensSoldPercentage >= 80 && tokensSoldPercentage < 90){\r\n                bonusPercentage = 20;\r\n            // >= 90% - 0% бонуса\r\n            }else if (tokensSoldPercentage >= 90){\r\n                bonusPercentage = 0;\r\n            }else{\r\n                revert();\r\n            }\r\n        } else revert();\r\n\r\n        // сколько токенов нужно выдать без бонуса\r\n        uint resultValue = amountInCents.mul(tokenMultiplier).div(oneTokenInCents);\r\n\r\n        // с учетом бонуса\r\n        uint tokenAmount = resultValue.mul(bonusStateMultiplier.mul(100).add(bonusPercentage)).div(bonusStateMultiplier.mul(100));\r\n\r\n        // краевой случай, когда запросили больше, чем можем выдать\r\n        uint tokensLeft = getTokensLeftForSale(currentState);\r\n        if (tokenAmount > tokensLeft){\r\n            tokenAmount = tokensLeft;\r\n        }\r\n\r\n        // Кол-во 0?, делаем откат\r\n        require(tokenAmount != 0);\r\n\r\n        // Новый инвестор?\r\n        if (investedAmountOf[receiver] == 0) {\r\n            investorCount++;\r\n        }\r\n\r\n        // Кидаем токены инвестору\r\n        internalAssignTokens(receiver, tokenAmount, weiAmount, amountInCents, txId);\r\n\r\n        // Обновляем статистику\r\n        updateStat(currentState, receiver, tokenAmount, weiAmount);\r\n\r\n        // Шлем на кошелёк эфир\r\n        // Функция - прослойка для возможности переопределения в дочерних классах\r\n        // Если это внешний вызов, то депозит не кладем\r\n        if (txId == 0){\r\n            internalDeposit(destinationMultisigWallet, weiAmount);\r\n        }\r\n\r\n        // Может переопределяеться в наследниках\r\n    }\r\n\r\n    /**\r\n     * Низкоуровневая функция перевода эфира на контракт, функция доступна для переопределения в дочерних классах, но не публична\r\n     */\r\n    function internalDeposit(address receiver, uint weiAmount) internal{\r\n        // Переопределяется в наследниках\r\n    }\r\n\r\n    /**\r\n     * Низкоуровневая функция для возврата средств, функция доступна для переопределения в дочерних классах, но не публична\r\n     */\r\n    function internalRefund(address receiver, uint weiAmount) internal{\r\n        // Переопределяется в наследниках\r\n    }\r\n\r\n    /**\r\n     * Низкоуровневая функция для включения режима возврата средств\r\n     */\r\n    function internalEnableRefunds() internal{\r\n        // Переопределяется в наследниках\r\n    }\r\n\r\n    /**\r\n     * Спец. функция, которая позволяет продавать токены вне ценовой политики, доступка только владельцу\r\n     * Результаты пишутся в общую статистику, без разделения на стадии\r\n     * @param receiver - получатель\r\n     * @param tokenAmount - общее кол-во токенов c decimals!!!\r\n     * @param weiAmount - цена в wei\r\n     */\r\n    function internalPreallocate(State currentState, address receiver, uint tokenAmount, uint weiAmount) internal {\r\n        // Cколько токенов осталось для продажи? Больше этого значения выдать не можем!\r\n        require(getTokensLeftForSale(currentState) >= tokenAmount);\r\n\r\n        // Может быть 0, выдаем токены бесплатно\r\n        internalAssignTokens(receiver, tokenAmount, weiAmount, getWeiInCents(weiAmount), 0);\r\n\r\n        // Обновляем статистику\r\n        updateStat(currentState, receiver, tokenAmount, weiAmount);\r\n\r\n        // Может переопределяеться в наследниках\r\n    }\r\n\r\n    /**\r\n     * Низкоуровневая функция для действий, в случае успеха\r\n     */\r\n    function internalSuccessOver() internal {\r\n        // Переопределяется в наследниках\r\n    }\r\n\r\n    /**\r\n     * Функция, которая переопределяется в надледниках и выполняется после установки адреса аккаунта для перевода средств\r\n     */\r\n    function internalSetDestinationMultisigWallet(address destinationAddress) internal{\r\n    }\r\n\r\n    /**\r\n     * Обновляем статистику для первой или второй стадии\r\n     */\r\n    function updateStat(State currentState, address receiver, uint tokenAmount, uint weiAmount) private{\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokensSold = tokensSold.add(tokenAmount);\r\n\r\n        // Если это первая стадия\r\n        if (currentState == State.FirstStageFunding){\r\n            // Увеличиваем стату\r\n            firstStageRaisedInWei = firstStageRaisedInWei.add(weiAmount);\r\n            firstStageTokensSold = firstStageTokensSold.add(tokenAmount);\r\n        }\r\n\r\n        // Если это вторая стадия\r\n        if (currentState == State.SecondStageFunding){\r\n            // Увеличиваем стату\r\n            secondStageRaisedInWei = secondStageRaisedInWei.add(weiAmount);\r\n            secondStageTokensSold = secondStageTokensSold.add(tokenAmount);\r\n        }\r\n\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\r\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * Функция, которая позволяет менять адрес аккаунта, куда будут переведены средства, в случае успеха,\r\n     * менять может только владелец и только в случае если продажи еще не завершены успехом\r\n     */\r\n    function setDestinationMultisigWallet(address destinationAddress) public onlyOwner canSetDestinationMultisigWallet{\r\n        destinationMultisigWallet = destinationAddress;\r\n\r\n        internalSetDestinationMultisigWallet(destinationAddress);\r\n    }\r\n\r\n    /**\r\n     * Функция, которая задает текущий курс eth в центах\r\n     */\r\n    function changeCurrentEtherRateInCents(uint value) public onlyOwner {\r\n        // Если случайно задали 0, не откатываем транзакцию\r\n        require(value > 0);\r\n\r\n        currentEtherRateInCents = value;\r\n\r\n        ExchangeRateChanged(currentEtherRateInCents, value);\r\n    }\r\n\r\n    /**\r\n    * Разделил на 2 метода, чтобы не запутаться при вызове\r\n    * Эти функции нужны в 2-х случаях: немного не собрали до Cap'а, сами докидываем необходимую сумму, есть приватные инвесторы, для которых существуют особые условия\r\n    */\r\n\r\n    /* Для первой стадии */\r\n    function preallocateFirstStage(address receiver, uint tokenAmount, uint weiAmount) public onlyOwner isFirstStageFundingOrEnd {\r\n        internalPreallocate(State.FirstStageFunding, receiver, tokenAmount, weiAmount);\r\n    }\r\n\r\n    /* Для второй стадии, выдать можем не больше остатка для продажи */\r\n    function preallocateSecondStage(address receiver, uint tokenAmount, uint weiAmount) public onlyOwner isSecondStageFundingOrEnd {\r\n        internalPreallocate(State.SecondStageFunding, receiver, tokenAmount, weiAmount);\r\n    }\r\n\r\n    /* В случае успеха, заблокированные токены для команды могут быть востребованы только если наступила определенная дата */\r\n    function issueTeamTokens() public onlyOwner inState(State.Success) {\r\n        require(block.timestamp >= teamTokensIssueDate);\r\n\r\n        uint teamTokenTransferAmount = teamTokenAmount.mul(10 ** token.decimals());\r\n\r\n        if (!token.transfer(teamAccount, teamTokenTransferAmount)) revert();\r\n    }\r\n\r\n    /**\r\n    * Включает режим возвратов, только в случае если режим возврата еще не установлен и продажи не завершены успехом\r\n    * Вызвать можно только 1 раз\r\n    */\r\n    function enableRefunds() public onlyOwner canEnableRefunds{\r\n        isRefundingEnabled = true;\r\n\r\n        // Сжигаем остатки на балансе текущего контракта\r\n        token.burnAllOwnerTokens();\r\n\r\n        internalEnableRefunds();\r\n    }\r\n\r\n    /**\r\n     * Покупка токенов, кидаем токены на адрес отправителя\r\n     */\r\n    function buy() public payable {\r\n        internalInvest(msg.sender, msg.value, 0);\r\n    }\r\n\r\n    /**\r\n     * Покупка токенов через внешние системы\r\n     */\r\n    function externalBuy(address buyerAddress, uint weiAmount, uint txId) external onlyOwner {\r\n        require(txId != 0);\r\n\r\n        internalInvest(buyerAddress, weiAmount, txId);\r\n    }\r\n\r\n    /**\r\n     * Инвесторы могут затребовать возврат средств, только в случае, если текущее состояние - Refunding\r\n     */\r\n    function refund() public inState(State.Refunding) {\r\n        // Получаем значение, которое нам было переведено в эфире\r\n        uint weiValue = investedAmountOf[msg.sender];\r\n\r\n        require(weiValue != 0);\r\n\r\n        // Кол-во токенов на балансе, берем 2 значения: контракт продаж и контракт токена.\r\n        // Вернуть wei можем только тогда, когда эти значения совпадают, если не совпадают, значит были какие-то\r\n        // манипуляции с токенами и такие ситуации будут решаться в индивидуальном порядке, по запросу\r\n        uint saleContractTokenCount = tokenAmountOf[msg.sender];\r\n        uint tokenContractTokenCount = token.balanceOf(msg.sender);\r\n\r\n        require(saleContractTokenCount <= tokenContractTokenCount);\r\n\r\n        investedAmountOf[msg.sender] = 0;\r\n        weiRefunded = weiRefunded.add(weiValue);\r\n\r\n        // Событие генерируется в наследниках\r\n        internalRefund(msg.sender, weiValue);\r\n    }\r\n\r\n    /**\r\n     * Финализатор первой стадии, вызвать может только владелец при условии еще незавершившейся продажи\r\n     * Если вызван halt, то финализатор вызвать не можем\r\n     * Вызвать можно только 1 раз\r\n     */\r\n    function finalizeFirstStage() public onlyOwner isNotSuccessOver {\r\n        require(!isFirstStageFinalized);\r\n\r\n        // Сжигаем остатки\r\n        // Всего можем продать firstStageTotalSupply\r\n        // Продали - firstStageTokensSold\r\n        // Все токены на балансе контракта сжигаем - это будет остаток\r\n\r\n        token.burnAllOwnerTokens();\r\n\r\n        // Переходим ко второй стадии\r\n        // Если повторно вызвать финализатор, то еще раз токены не создадутся, условие внутри\r\n        mintTokensForSecondStage();\r\n\r\n        isFirstStageFinalized = true;\r\n    }\r\n\r\n    /**\r\n     * Финализатор второй стадии, вызвать может только владелец, и только в случае финилизированной первой стадии\r\n     * и только в случае, если сборы еще не завершились успехом. Если вызван halt, то финализатор вызвать не можем.\r\n     * Вызвать можно только 1 раз\r\n     */\r\n    function finalizeSecondStage() public onlyOwner isNotSuccessOver {\r\n        require(isFirstStageFinalized && !isSecondStageFinalized);\r\n\r\n        // Сжигаем остатки\r\n        // Всего можем продать secondStageTokensForSale\r\n        // Продали - secondStageTokensSold\r\n        // Разницу нужно сжечь, в любом случае\r\n\r\n        // Если достигнут Soft Cap, то считаем вторую стадию успешной\r\n        if (isSoftCapGoalReached()){\r\n            uint tokenMultiplier = 10 ** token.decimals();\r\n\r\n            uint remainingTokens = secondStageTokensForSale.mul(tokenMultiplier).sub(secondStageTokensSold);\r\n\r\n            // Если кол-во оставшихся токенов > 0, то сжигаем их\r\n            if (remainingTokens > 0){\r\n                token.burnOwnerTokens(remainingTokens);\r\n            }\r\n\r\n            // Переводим на подготовленные аккаунты: advisorsWalletAddress, marketingWalletAddress, teamWalletAddress\r\n            uint advisorsTokenTransferAmount = advisorsTokenAmount.mul(tokenMultiplier);\r\n            uint marketingTokenTransferAmount = marketingTokenAmount.mul(tokenMultiplier);\r\n            uint supportTokenTransferAmount = supportTokenAmount.mul(tokenMultiplier);\r\n\r\n            // Токены для команды заблокированы до даты teamTokensIssueDate и могут быть востребованы, только при вызове спец. функции\r\n            // issueTeamTokens\r\n\r\n            if (!token.transfer(advisorsAccount, advisorsTokenTransferAmount)) revert();\r\n            if (!token.transfer(marketingAccount, marketingTokenTransferAmount)) revert();\r\n            if (!token.transfer(supportAccount, supportTokenTransferAmount)) revert();\r\n\r\n            // Контракт выполнен!\r\n            isSuccessOver = true;\r\n\r\n            // Вызываем метод успеха\r\n            internalSuccessOver();\r\n        }else{\r\n            // Если не собрали Soft Cap, то сжигаем все токены на балансе контракта\r\n            token.burnAllOwnerTokens();\r\n        }\r\n\r\n        isSecondStageFinalized = true;\r\n    }\r\n\r\n    /**\r\n     * Позволяет менять владельцу даты стадий\r\n     */\r\n    function setFirstStageStartsAt(uint time) public onlyOwner {\r\n        firstStageStartsAt = time;\r\n\r\n        // Вызываем событие\r\n        FirstStageStartsAtChanged(firstStageStartsAt);\r\n    }\r\n\r\n    function setFirstStageEndsAt(uint time) public onlyOwner {\r\n        firstStageEndsAt = time;\r\n\r\n        // Вызываем событие\r\n        FirstStageEndsAtChanged(firstStageEndsAt);\r\n    }\r\n\r\n    function setSecondStageStartsAt(uint time) public onlyOwner {\r\n        secondStageStartsAt = time;\r\n\r\n        // Вызываем событие\r\n        SecondStageStartsAtChanged(secondStageStartsAt);\r\n    }\r\n\r\n    function setSecondStageEndsAt(uint time) public onlyOwner {\r\n        secondStageEndsAt = time;\r\n\r\n        // Вызываем событие\r\n        SecondStageEndsAtChanged(secondStageEndsAt);\r\n    }\r\n\r\n    /**\r\n     * Позволяет менять владельцу Cap'ы\r\n     */\r\n    function setSoftCapInCents(uint value) public onlyOwner {\r\n        require(value > 0);\r\n\r\n        softCapFundingGoalInCents = value;\r\n\r\n        // Вызываем событие\r\n        SoftCapChanged(softCapFundingGoalInCents);\r\n    }\r\n\r\n    function setHardCapInCents(uint value) public onlyOwner {\r\n        require(value > 0);\r\n\r\n        hardCapFundingGoalInCents = value;\r\n\r\n        // Вызываем событие\r\n        HardCapChanged(hardCapFundingGoalInCents);\r\n    }\r\n\r\n    /**\r\n     * Проверка сбора Soft Cap'а\r\n     */\r\n    function isSoftCapGoalReached() public constant returns (bool) {\r\n        // Проверка по текущему курсу в центах, считает от общих продаж\r\n        return getWeiInCents(weiRaised) >= softCapFundingGoalInCents;\r\n    }\r\n\r\n    /**\r\n     * Проверка сбора Hard Cap'а\r\n     */\r\n    function isHardCapGoalReached() public constant returns (bool) {\r\n        // Проверка по текущему курсу в центах, считает от общих продаж\r\n        return getWeiInCents(weiRaised) >= hardCapFundingGoalInCents;\r\n    }\r\n\r\n    /**\r\n     * Возвращает кол-во нераспроданных токенов, которые можно продать, в зависимости от стадии\r\n     */\r\n    function getTokensLeftForSale(State forState) public constant returns (uint) {\r\n        // Кол-во токенов, которое адрес контракта можеть снять у owner'а и есть кол-во оставшихся токенов, из этой суммы нужно вычесть кол-во которое не участвует в продаже\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        uint tokensReserve = 0;\r\n        if (forState == State.SecondStageFunding) tokensReserve = secondStageReserve.mul(10 ** token.decimals());\r\n\r\n        if (tokenBalance <= tokensReserve){\r\n            return 0;\r\n        }\r\n\r\n        return tokenBalance.sub(tokensReserve);\r\n    }\r\n\r\n    /**\r\n     * Получаем стейт\r\n     *\r\n     * Не пишем в переменную, чтобы не было возможности поменять извне, только вызов функции может отразить текущее состояние\r\n     * См. граф состояний\r\n     */\r\n    function getState() public constant returns (State) {\r\n        // Контракт выполнен\r\n        if (isSuccessOver) return State.Success;\r\n\r\n        // Контракт находится в режиме возврата\r\n        if (isRefundingEnabled) return State.Refunding;\r\n\r\n        // Контракт еще не начал действовать\r\n        if (block.timestamp < firstStageStartsAt) return State.PreFunding;\r\n\r\n        //Если первая стадия - не финализирована\r\n        if (!isFirstStageFinalized){\r\n            // Флаг того, что текущая дата находится в интервале первой стадии\r\n            bool isFirstStageTime = block.timestamp >= firstStageStartsAt && block.timestamp <= firstStageEndsAt;\r\n\r\n            // Если идет первая стадия\r\n            if (isFirstStageTime) return State.FirstStageFunding;\r\n            // Иначе первый этап - закончен\r\n            else return State.FirstStageEnd;\r\n\r\n        } else {\r\n\r\n            // Если первая стадия финализирована и текущее время блок чейна меньше начала второй стадии, то это означает, что первая стадия - окончена\r\n            if(block.timestamp < secondStageStartsAt)return State.FirstStageEnd;\r\n\r\n            // Флаг того, что текущая дата находится в интервале второй стадии\r\n            bool isSecondStageTime = block.timestamp >= secondStageStartsAt && block.timestamp <= secondStageEndsAt;\r\n\r\n            // Первая стадия финализирована, вторая - финализирована\r\n            if (isSecondStageFinalized){\r\n\r\n                // Если набрали Soft Cap при условии финализации второй сдадии - это успешное закрытие продаж\r\n                if (isSoftCapGoalReached())return State.Success;\r\n                // Собрать Soft Cap не удалось, текущее состояние - провал\r\n                else return State.Failure;\r\n\r\n            }else{\r\n\r\n                // Вторая стадия - не финализирована\r\n                if (isSecondStageTime)return State.SecondStageFunding;\r\n                // Вторая стадия - закончилась\r\n                else return State.SecondStageEnd;\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n   /**\r\n    * Модификаторы\r\n    */\r\n\r\n    /** Только, если текущее состояние соответсвует состоянию  */\r\n    modifier inState(State state) {\r\n        require(getState() == state);\r\n\r\n        _;\r\n    }\r\n\r\n    /** Только, если текущее состояние - продажи: первая или вторая стадия */\r\n    modifier inFirstOrSecondFundingState() {\r\n        State curState = getState();\r\n        require(curState == State.FirstStageFunding || curState == State.SecondStageFunding);\r\n\r\n        _;\r\n    }\r\n\r\n    /** Только, если не достигнут Hard Cap */\r\n    modifier notHardCapReached(){\r\n        require(!isHardCapGoalReached());\r\n\r\n        _;\r\n    }\r\n\r\n    /** Только, если текущее состояние - продажи первой стадии или первая стадия закончилась */\r\n    modifier isFirstStageFundingOrEnd() {\r\n        State curState = getState();\r\n        require(curState == State.FirstStageFunding || curState == State.FirstStageEnd);\r\n\r\n        _;\r\n    }\r\n\r\n    /** Только, если контракт не финализирован */\r\n    modifier isNotSuccessOver() {\r\n        require(!isSuccessOver);\r\n\r\n        _;\r\n    }\r\n\r\n    /** Только, если идет вторая стадия или вторая стадия завершилась */\r\n    modifier isSecondStageFundingOrEnd() {\r\n        State curState = getState();\r\n        require(curState == State.SecondStageFunding || curState == State.SecondStageEnd);\r\n\r\n        _;\r\n    }\r\n\r\n    /** Только, если еще не включен режим возврата и продажи не завершены успехом */\r\n    modifier canEnableRefunds(){\r\n        require(!isRefundingEnabled && getState() != State.Success);\r\n\r\n        _;\r\n    }\r\n\r\n    /** Только, если продажи не завершены успехом */\r\n    modifier canSetDestinationMultisigWallet(){\r\n        require(getState() != State.Success);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\n\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/**\r\n * Шаблон класса хранилища средств, которое используется в контракте продаж\r\n * Поддерживает возврат средств, а такте перевод средств на кошелек, в случае успешного проведения продаж\r\n */\r\ncontract FundsVault is Ownable, ValidationUtil {\r\n    using SafeMath for uint;\r\n    using Math for uint;\r\n\r\n    enum State {Active, Refunding, Closed}\r\n\r\n    mapping (address => uint256) public deposited;\r\n\r\n    address public wallet;\r\n\r\n    State public state;\r\n\r\n    event Closed();\r\n\r\n    event RefundsEnabled();\r\n\r\n    event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n    /**\r\n     * Указываем на какой кошелек будут потом переведены собранные средства, в случае, если будет вызвана функция close()\r\n     * Поддерживает возврат средств, а такте перевод средств на кошелек, в случае успешного проведения продаж\r\n     */\r\n    function FundsVault(address _wallet) {\r\n        requireNotEmptyAddress(_wallet);\r\n\r\n        wallet = _wallet;\r\n\r\n        state = State.Active;\r\n    }\r\n\r\n    /**\r\n     * Положить депозит в хранилище\r\n     */\r\n    function deposit(address investor) public payable onlyOwner inState(State.Active) {\r\n        deposited[investor] = deposited[investor].add(msg.value);\r\n    }\r\n\r\n    /**\r\n     * Перевод собранных средств на указанный кошелек\r\n     */\r\n    function close() public onlyOwner inState(State.Active) {\r\n        state = State.Closed;\r\n\r\n        Closed();\r\n\r\n        wallet.transfer(this.balance);\r\n    }\r\n\r\n    /**\r\n     * Установливаем кошелек\r\n     */\r\n    function setWallet(address newWalletAddress) public onlyOwner inState(State.Active) {\r\n        wallet = newWalletAddress;\r\n    }\r\n\r\n    /**\r\n     * Установить режим возврата денег\r\n     */\r\n    function enableRefunds() public onlyOwner inState(State.Active) {\r\n        state = State.Refunding;\r\n\r\n        RefundsEnabled();\r\n    }\r\n\r\n    /**\r\n     * Функция возврата средств\r\n     */\r\n    function refund(address investor, uint weiAmount) public onlyOwner inState(State.Refunding){\r\n        uint256 depositedValue = weiAmount.min256(deposited[investor]);\r\n        deposited[investor] = 0;\r\n        investor.transfer(depositedValue);\r\n\r\n        Refunded(investor, depositedValue);\r\n    }\r\n\r\n    /** Только, если текущее состояние соответсвует состоянию  */\r\n    modifier inState(State _state) {\r\n        require(state == _state);\r\n\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* Контракт продажи\r\n* Возврат средств поддержмвается только тем, кто купил токены через функцию internalInvest\r\n* Таким образом, если инвесторы будут обмениваться токенами, то вернуть можно будет только тем, у кого в контракте продаж\r\n* такая же сумма токенов, как и в контракте токена, в противном случае переведенный эфир остается навсегда в системе и не может быть выведен\r\n*/\r\ncontract RefundableAllocatedCappedCrowdsale is AllocatedCappedCrowdsale {\r\n\r\n    /**\r\n    * Хранилище, куда будут собираться средства, делается для того, чтобы гарантировать возвраты\r\n    */\r\n    FundsVault public fundsVault;\r\n\r\n    /** Мапа адрес инвестора - был ли совершен возврат среств */\r\n    mapping (address => bool) public refundedInvestors;\r\n\r\n    function RefundableAllocatedCappedCrowdsale(uint _currentEtherRateInCents, address _token, address _destinationMultisigWallet, uint _firstStageStartsAt, uint _firstStageEndsAt, uint _secondStageStartsAt, uint _secondStageEndsAt, address _advisorsAccount, address _marketingAccount, address _supportAccount, address _teamAccount, uint _teamTokensIssueDate) AllocatedCappedCrowdsale(_currentEtherRateInCents, _token, _destinationMultisigWallet, _firstStageStartsAt, _firstStageEndsAt, _secondStageStartsAt, _secondStageEndsAt, _advisorsAccount, _marketingAccount, _supportAccount, _teamAccount, _teamTokensIssueDate) {\r\n        // Создаем от контракта продаж новое хранилище, доступ к нему имеет только контракт продаж\r\n        // При успешном завершении продаж, все собранные средства поступят на _destinationMultisigWallet\r\n        // В противном случае могут быть переведены обратно инвесторам\r\n        fundsVault = new FundsVault(_destinationMultisigWallet);\r\n\r\n    }\r\n\r\n    /** Устанавливаем новый кошелек для финального перевода\r\n    */\r\n    function internalSetDestinationMultisigWallet(address destinationAddress) internal{\r\n        fundsVault.setWallet(destinationAddress);\r\n\r\n        super.internalSetDestinationMultisigWallet(destinationAddress);\r\n    }\r\n\r\n    /** Финализация второго этапа\r\n    */\r\n    function internalSuccessOver() internal {\r\n        // Успешно закрываем хранилище средств и переводим эфир на указанный кошелек\r\n        fundsVault.close();\r\n\r\n        super.internalSuccessOver();\r\n    }\r\n\r\n    /** Переопределение функции принятия допозита на счет, в данном случае, идти будет через vault\r\n    */\r\n    function internalDeposit(address receiver, uint weiAmount) internal{\r\n        // Шлем на кошелёк эфир\r\n        fundsVault.deposit.value(weiAmount)(msg.sender);\r\n    }\r\n\r\n    /** Переопределение функции включения состояния возврата\r\n    */\r\n    function internalEnableRefunds() internal{\r\n        super.internalEnableRefunds();\r\n\r\n        fundsVault.enableRefunds();\r\n    }\r\n\r\n    /** Переопределение функции возврата, возврат можно сделать только раз\r\n    */\r\n    function internalRefund(address receiver, uint weiAmount) internal{\r\n        // Делаем возврат\r\n        // Поддерживаем только 1 возврат\r\n\r\n        if (refundedInvestors[receiver]) revert();\r\n\r\n        fundsVault.refund(receiver, weiAmount);\r\n\r\n        refundedInvestors[receiver] = true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getWeiInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageRaisedInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSoftCapGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"preallocateFirstStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageTokensForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refundedInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorsAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSoftCapInCents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapFundingGoalInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapFundingGoalInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokensIssueDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"preallocateSecondStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintTokensForFirstStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setHardCapInCents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageStartsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStageStartsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setSecondStageEndsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSuccessOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFirstStageFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oneTokenInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStageTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"txId\",\"type\":\"uint256\"}],\"name\":\"externalBuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageEndsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSecondStageTokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeFirstStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changeCurrentEtherRateInCents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRefundingEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destinationMultisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeSecondStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setFirstStageEndsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFirstStageTokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStageTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setSecondStageStartsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEtherRateInCents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"forState\",\"type\":\"uint8\"}],\"name\":\"getTokensLeftForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStageEndsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supportTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSecondStageFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isHardCapGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setFirstStageStartsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supportAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"issueTeamTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destinationAddress\",\"type\":\"address\"}],\"name\":\"setDestinationMultisigWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStageRaisedInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOneTokenInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorsTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_currentEtherRateInCents\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_destinationMultisigWallet\",\"type\":\"address\"},{\"name\":\"_firstStageStartsAt\",\"type\":\"uint256\"},{\"name\":\"_firstStageEndsAt\",\"type\":\"uint256\"},{\"name\":\"_secondStageStartsAt\",\"type\":\"uint256\"},{\"name\":\"_secondStageEndsAt\",\"type\":\"uint256\"},{\"name\":\"_advisorsAccount\",\"type\":\"address\"},{\"name\":\"_marketingAccount\",\"type\":\"address\"},{\"name\":\"_supportAccount\",\"type\":\"address\"},{\"name\":\"_teamAccount\",\"type\":\"address\"},{\"name\":\"_teamTokensIssueDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"centAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"txId\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldExchangeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newExchangeRate\",\"type\":\"uint256\"}],\"name\":\"ExchangeRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFirstStageStartsAt\",\"type\":\"uint256\"}],\"name\":\"FirstStageStartsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFirstStageEndsAt\",\"type\":\"uint256\"}],\"name\":\"FirstStageEndsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newSecondStageStartsAt\",\"type\":\"uint256\"}],\"name\":\"SecondStageStartsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newSecondStageEndsAt\",\"type\":\"uint256\"}],\"name\":\"SecondStageEndsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newGoal\",\"type\":\"uint256\"}],\"name\":\"SoftCapChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newGoal\",\"type\":\"uint256\"}],\"name\":\"HardCapChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RefundableAllocatedCappedCrowdsale","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000001c520000000000000000000000000c15a399c4ea7815fe36857c9e290ee452a5d6b210000000000000000000000006a9944243e417b588a4b4651085fe3f6b736c746000000000000000000000000000000000000000000000000000000005a5492a0000000000000000000000000000000000000000000000000000000005a97184f000000000000000000000000000000000000000000000000000000005a97cf20000000000000000000000000000000000000000000000000000000005ad3bd4f000000000000000000000000318907bd8463d9a22e297b065c4bd405c180e8e0000000000000000000000000e6a8068c33b3b747eed514bd79f8b9235eb179ef000000000000000000000000fdbbfb26b73fb17d3988caef0642c3b51f80abce000000000000000000000000e0d4ceb6b23e3dfbafd972c15725e22b74e664af000000000000000000000000000000000000000000000000000000005bc46520","Library":"","SwarmSource":"bzzr://dc0e9fc362910ac4dc405c5a9736c0df6688c3a637015cc008e8edc26c5f90c5"}]}