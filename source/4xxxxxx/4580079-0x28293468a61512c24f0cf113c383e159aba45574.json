{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract functions to test Ethereum message signing\r\n//\r\n// Deployed to Etheruem mainnet 0x28293468a61512c24F0CF113c383e159abA45574\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\ncontract ECVerifyTest {\r\n\r\n    // ------------------------------------------------------------------------\r\n    // ecrecover from a signature rather than the signature in parts [v, r, s]\r\n    // The signature format is a compact form {bytes32 r}{bytes32 s}{uint8 v}.\r\n    // Compact means, uint8 is not padded to 32 bytes.\r\n    //\r\n    // An invalid signature results in the address(0) being returned, make\r\n    // sure that the returned result is checked to be non-zero for validity\r\n    //\r\n    // Parts from https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n    // ------------------------------------------------------------------------\r\n    function ecrecoverFromSig(bytes32 hash, bytes sig) public pure returns (address recoveredAddress) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (sig.length != 65) return address(0);\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            // Here we are loading the last 32 bytes. We exploit the fact that 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]\r\n        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n          v += 27;\r\n        }\r\n        if (v != 27 && v != 28) return address(0);\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // ecrecover from the signature parts [v, r, s]\r\n    //\r\n    // An invalid signature results in the address(0) being returned, make\r\n    // sure that the returned result is checked to be non-zero for validity\r\n    //\r\n    // Parts from https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n    // ------------------------------------------------------------------------\r\n    function ecrecoverFromVRS(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure returns (address recoveredAddress) {\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ecrecoverFromVRS\",\"outputs\":[{\"name\":\"recoveredAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"ecrecoverFromSig\",\"outputs\":[{\"name\":\"recoveredAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ECVerifyTest","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://189da202af788bf5d48631b34060930f7ba624cbe7ba0515431bb3f34afb5dc7"}]}