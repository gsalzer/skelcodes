{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n * By OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/contracts/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ContractReceiver {\r\n    function tokenFallback(address _from, uint256 _value, bytes  _data) external;\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public ownerCandidate;\r\n    event OwnerTransfer(address originalOwner, address currentOwner);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function proposeNewOwner(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0) && newOwner != owner);\r\n        ownerCandidate = newOwner;\r\n    }\r\n\r\n    function acceptOwnerTransfer() public {\r\n        require(msg.sender == ownerCandidate);\r\n        OwnerTransfer(owner, ownerCandidate);\r\n        owner = ownerCandidate;\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n// Based in part on code by Open-Zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\r\n// Based in part on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n// Smart contract for the RepuX token & the first crowdsale\r\ncontract RepuX is StandardToken, Ownable {\r\n    string public constant name = \"RepuX\";\r\n    string public constant symbol = \"REPUX\";\r\n    uint8 public constant decimals = 18;\r\n    address public multisig; //multisig wallet, to which all contributions will be sent\r\n\r\n    uint256 public phase1StartBlock; //Crowdsale start block\r\n    uint256 public phase1EndBlock; // Day 7 (estimate)\r\n    uint256 public phase2EndBlock; // Day 13 (estimate)\r\n    uint256 public phase3EndBlock; // Day 19 (estimate)\r\n    uint256 public phase4EndBlock; // Day 25 (estimate)\r\n    uint256 public phase5EndBlock; // Day 31 (estimate)\r\n    uint256 public endBlock; //whole crowdsale end block\r\n\r\n    uint256 public basePrice = 1818 * (10**11); // ICO token base price: ~$0.20 (estimate assuming $1100 per Eth)\r\n\r\n    uint256 public totalSupply = 500000000 * (10**uint256(decimals)); //Token total supply: 500000000 RPX\r\n    uint256 public presaleTokenSupply = totalSupply.mul(20).div(100); //Amount of tokens available during presale (10%)\r\n    uint256 public crowdsaleTokenSupply = totalSupply.mul(30).div(100); //Amount of tokens available during crowdsale (50%)\r\n    uint256 public rewardsTokenSupply = totalSupply.mul(15).div(100); //Rewards pool (VIP etc, 10%), ambassador share(3%) & ICO bounties(2%)\r\n    uint256 public teamTokenSupply = totalSupply.mul(12).div(100); //Tokens distributed to team (12% in total, 4% vested for 12, 24 & 36 months)\r\n    uint256 public platformTokenSupply = totalSupply.mul(23).div(100); //Token reserve for sale on platform\r\n    uint256 public presaleTokenSold = 0; //Records the amount of tokens sold during presale\r\n    uint256 public crowdsaleTokenSold = 0; //Records the amount of tokens sold during the crowdsale\r\n\r\n    uint256 public phase1Cap = crowdsaleTokenSupply.mul(50).div(100);\r\n    uint256 public phase2Cap = crowdsaleTokenSupply.mul(60).div(100);\r\n    uint256 public phase3Cap = crowdsaleTokenSupply.mul(70).div(100);\r\n    uint256 public phase4Cap = crowdsaleTokenSupply.mul(80).div(100);\r\n\r\n    uint256 public transferLockup = 5760; //Lock up token transfer until ~2 days after crowdsale concludes\r\n    uint256 public teamLockUp; \r\n    uint256 private teamWithdrawlCount = 0;\r\n    uint256 public averageBlockTime = 18; //Average block time in seconds\r\n\r\n    bool public presaleStarted = false;\r\n    bool public presaleConcluded = false;\r\n    bool public crowdsaleStarted = false;\r\n    bool public crowdsaleConcluded = false;\r\n    bool public ICOReserveWithdrawn = false;\r\n    bool public halted = false; //Halt crowdsale in emergency\r\n\r\n    uint256 contributionCount = 0;\r\n    bytes32[] public contributionHashes;\r\n    mapping (bytes32 => Contribution) private contributions;\r\n\r\n    address public teamWithdrawalRecipient = address(0);\r\n    bool public teamWithdrawalProposed = false;\r\n    bool teamWithdrawn = false;\r\n\r\n    event Halt(); //Halt event\r\n    event Unhalt(); //Unhalt event\r\n    event Burn(address burner, uint256 amount);\r\n    event StartPresale();\r\n    event ConcludePresale();\r\n    event StartCrowdsale();\r\n    event ConcludeCrowdsale();\r\n    event SetMultisig(address newMultisig);\r\n\r\n    struct Contribution {\r\n        address contributor;\r\n        address recipient;\r\n        uint256 ethWei;\r\n        uint256 tokens;\r\n        bool resolved;\r\n        bool success;\r\n        uint8 stage;\r\n    }\r\n\r\n    event ContributionReceived(bytes32 contributionHash, address contributor, address recipient,\r\n        uint256 ethWei, uint256 pendingTokens);\r\n\r\n    event ContributionResolved(bytes32 contributionHash, bool pass, address contributor, \r\n        address recipient, uint256 ethWei, uint256 tokens);\r\n\r\n\r\n    // lockup during and after 48h of end of crowdsale\r\n    modifier crowdsaleTransferLock() {\r\n        require(crowdsaleConcluded && block.number >= endBlock.add(transferLockup));\r\n        _;\r\n    }\r\n\r\n    modifier whenNotHalted() {\r\n        require(!halted);\r\n        _;\r\n    }\r\n\r\n    //Constructor: set owner (team) address & crowdsale recipient multisig wallet address\r\n    //Allocate reward tokens to the team wallet\r\n  \tfunction RepuX(address _multisig) {\r\n        owner = msg.sender;\r\n        multisig = _multisig;\r\n  \t}\r\n\r\n    //Fallback function when receiving Ether. Contributors can directly send Ether to the token address during crowdsale.\r\n    function() payable {\r\n        buy();\r\n    }\r\n\r\n\r\n    //Halt ICO in case of emergency.\r\n    function halt() public onlyOwner {\r\n        halted = true;\r\n        Halt();\r\n    }\r\n\r\n    function unhalt() public onlyOwner {\r\n        halted = false;\r\n        Unhalt();\r\n    }\r\n\r\n    function startPresale() public onlyOwner {\r\n        require(!presaleStarted);\r\n        presaleStarted = true;\r\n        StartPresale();\r\n    }\r\n\r\n    function concludePresale() public onlyOwner {\r\n        require(presaleStarted && !presaleConcluded);\r\n        presaleConcluded = true;\r\n        //Unsold tokens in the presale are made available in the crowdsale.\r\n        crowdsaleTokenSupply = crowdsaleTokenSupply.add(presaleTokenSupply.sub(presaleTokenSold)); \r\n        ConcludePresale();\r\n    }\r\n\r\n    //Can only be called after presale is concluded.\r\n    function startCrowdsale() public onlyOwner {\r\n        require(presaleConcluded && !crowdsaleStarted);\r\n        crowdsaleStarted = true;\r\n        phase1StartBlock = block.number;\r\n        phase1EndBlock = phase1StartBlock.add(dayToBlockNumber(7));\r\n        phase2EndBlock = phase1EndBlock.add(dayToBlockNumber(6));\r\n        phase3EndBlock = phase2EndBlock.add(dayToBlockNumber(6));\r\n        phase4EndBlock = phase3EndBlock.add(dayToBlockNumber(6));\r\n        phase5EndBlock = phase4EndBlock.add(dayToBlockNumber(6));\r\n        endBlock = phase5EndBlock;\r\n        StartCrowdsale();\r\n    }\r\n\r\n    //Can only be called either after crowdsale time period ends, or after tokens have sold out\r\n    function concludeCrowdsale() public onlyOwner {\r\n        require(crowdsaleStarted && !crowdsaleOn() && !crowdsaleConcluded);\r\n        crowdsaleConcluded = true;\r\n        endBlock = block.number;\r\n        uint256 unsold = crowdsaleTokenSupply.sub(crowdsaleTokenSold);\r\n        if (unsold > 0) {\r\n            //Burn unsold tokens\r\n            totalSupply = totalSupply.sub(unsold);\r\n            Burn(this, unsold);\r\n            Transfer(this, address(0), unsold);\r\n        }\r\n        teamLockUp = dayToBlockNumber(365); //12-month lock-up period\r\n        ConcludeCrowdsale();\r\n    }\r\n\r\n    function proposeTeamWithdrawal(address recipient) public onlyOwner {\r\n        require(!teamWithdrawn);\r\n        teamWithdrawalRecipient = recipient;\r\n        teamWithdrawalProposed = true;\r\n    }\r\n\r\n    function cancelTeamWithdrawal() public onlyOwner {\r\n        require(!teamWithdrawn);\r\n        require(teamWithdrawalProposed);\r\n        teamWithdrawalProposed = false;\r\n        teamWithdrawalRecipient = address(0); \r\n    }\r\n\r\n    function confirmTeamWithdrawal() public {\r\n        require(!teamWithdrawn);\r\n        require(teamWithdrawalProposed);\r\n        require(msg.sender == teamWithdrawalRecipient);\r\n        teamWithdrawn = true;\r\n        uint256 tokens = rewardsTokenSupply.add(teamTokenSupply).add(platformTokenSupply);\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        Transfer(this, msg.sender, tokens);\r\n    }\r\n\r\n\r\n    function buy() payable {\r\n        buyRecipient(msg.sender);\r\n    }\r\n\r\n\r\n    //Allow addresses to buy token for another account\r\n    function buyRecipient(address recipient) public payable whenNotHalted {\r\n        require(msg.value > 0);\r\n        require(presaleOn()||crowdsaleOn()); //Contribution only allowed during presale/crowdsale\r\n        uint256 tokens = msg.value.mul(10**uint256(decimals)).div(tokenPrice()); \r\n        uint8 stage = 0;\r\n\r\n        if(presaleOn()) {\r\n            require(presaleTokenSold.add(tokens) <= presaleTokenSupply);\r\n            presaleTokenSold = presaleTokenSold.add(tokens);\r\n        } else {\r\n            require(crowdsaleTokenSold.add(tokens) <= crowdsaleTokenSupply);\r\n            crowdsaleTokenSold = crowdsaleTokenSold.add(tokens);\r\n            stage = 1;\r\n        }\r\n        contributionCount = contributionCount.add(1);\r\n        bytes32 transactionHash = keccak256(contributionCount, msg.sender, msg.value, msg.data,\r\n            msg.gas, block.number, tx.gasprice);\r\n        contributions[transactionHash] = Contribution(msg.sender, recipient, msg.value, \r\n            tokens, false, false, stage);\r\n        contributionHashes.push(transactionHash);\r\n        ContributionReceived(transactionHash, msg.sender, recipient, msg.value, tokens);\r\n    }\r\n\r\n    //Accept a contribution if KYC passed.\r\n    function acceptContribution(bytes32 transactionHash) public onlyOwner {\r\n        Contribution storage c = contributions[transactionHash];\r\n        require(!c.resolved);\r\n        c.resolved = true;\r\n        c.success = true;\r\n        balances[c.recipient] = balances[c.recipient].add(c.tokens);\r\n        assert(multisig.send(c.ethWei));\r\n        Transfer(this, c.recipient, c.tokens);\r\n        ContributionResolved(transactionHash, true, c.contributor, c.recipient, c.ethWei, \r\n            c.tokens);\r\n    }\r\n\r\n    //Reject a contribution if KYC failed.\r\n    function rejectContribution(bytes32 transactionHash) public onlyOwner {\r\n        Contribution storage c = contributions[transactionHash];\r\n        require(!c.resolved);\r\n        c.resolved = true;\r\n        c.success = false;\r\n        if (c.stage == 0) {\r\n            presaleTokenSold = presaleTokenSold.sub(c.tokens);\r\n        } else {\r\n            crowdsaleTokenSold = crowdsaleTokenSold.sub(c.tokens);\r\n        }\r\n        assert(c.contributor.send(c.ethWei));\r\n        ContributionResolved(transactionHash, false, c.contributor, c.recipient, c.ethWei, \r\n            c.tokens);\r\n    }\r\n\r\n    // Team manually mints tokens in case of BTC/wire-transfer contributions\r\n    function mint(address recipient, uint256 value) public onlyOwner {\r\n    \trequire(value > 0);\r\n    \trequire(presaleOn()||crowdsaleOn()); //Minting only allowed during presale/crowdsale\r\n    \tif(presaleOn()) {\r\n            require(presaleTokenSold.add(value) <= presaleTokenSupply);\r\n            presaleTokenSold = presaleTokenSold.add(value);\r\n        } else {\r\n            require(crowdsaleTokenSold.add(value) <= crowdsaleTokenSupply);\r\n            crowdsaleTokenSold = crowdsaleTokenSold.add(value);\r\n        }\r\n        balances[recipient] = balances[recipient].add(value);\r\n        Transfer(this, recipient, value);\r\n    }\r\n\r\n\r\n    //Burns the specified amount of tokens from the team wallet address\r\n    function burn(uint256 _value) public onlyOwner returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Transfer(msg.sender, address(0), _value);\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    //Allow team to change the recipient multisig address\r\n    function setMultisig(address addr) public onlyOwner {\r\n      \trequire(addr != address(0));\r\n      \tmultisig = addr;\r\n        SetMultisig(addr);\r\n    }\r\n\r\n    //Allows Team to adjust average blocktime according to network status, \r\n    //in order to provide more precise timing for ICO phases & lock-up periods\r\n    function setAverageBlockTime(uint256 newBlockTime) public onlyOwner {\r\n        require(newBlockTime > 0);\r\n        averageBlockTime = newBlockTime;\r\n    }\r\n\r\n    //Allows Team to adjust basePrice so price of the token has correct correlation to dollar\r\n    function setBasePrice(uint256 newBasePrice) public onlyOwner {\r\n        require(newBasePrice > 0);\r\n        basePrice = newBasePrice;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public crowdsaleTransferLock \r\n    returns(bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public \r\n    crowdsaleTransferLock returns(bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    //Price of token in terms of ether.\r\n    function tokenPrice() public constant returns(uint256) {\r\n        uint8 p = phase();\r\n        if (p == 0) return basePrice.mul(50).div(100); //Presale: 50% discount\r\n        if (p == 1) return basePrice.mul(70).div(100); //ICO phase 1: 30% discount\r\n        if (p == 2) return basePrice.mul(75).div(100); //Phase 2 :25% discount\r\n        if (p == 3) return basePrice.mul(80).div(100); //Phase 3: 20% discount\r\n        if (p == 4) return basePrice.mul(85).div(100); //Phase 4: 15% discount\r\n        if (p == 5) return basePrice.mul(90).div(100); //Phase 5: 10% discount\r\n        return basePrice;\r\n    }\r\n\r\n    function phase() public constant returns (uint8) {\r\n        if (presaleOn()) return 0;\r\n        if (crowdsaleTokenSold <= phase1Cap && block.number <= phase1EndBlock) return 1;\r\n        if (crowdsaleTokenSold <= phase2Cap && block.number <= phase2EndBlock) return 2;\r\n        if (crowdsaleTokenSold <= phase3Cap && block.number <= phase3EndBlock) return 3;\r\n        if (crowdsaleTokenSold <= phase4Cap && block.number <= phase4EndBlock) return 4;\r\n        if (crowdsaleTokenSold <= crowdsaleTokenSupply && block.number <= phase5EndBlock) return 5;\r\n        return 6;\r\n    }\r\n\r\n    function presaleOn() public constant returns (bool) {\r\n        return (presaleStarted && !presaleConcluded && presaleTokenSold < presaleTokenSupply);\r\n    }\r\n\r\n    function crowdsaleOn() public constant returns (bool) {\r\n        return (crowdsaleStarted && block.number <= endBlock && crowdsaleTokenSold < crowdsaleTokenSupply);\r\n    }\r\n\r\n    function dayToBlockNumber(uint256 dayNum) public constant returns(uint256) {\r\n        return dayNum.mul(86400).div(averageBlockTime); //86400 = 24*60*60 = number of seconds in a day\r\n    }\r\n\r\n    function getContributionFromHash(bytes32 contributionHash) public constant returns (\r\n            address contributor,\r\n            address recipient,\r\n            uint256 ethWei,\r\n            uint256 tokens,\r\n            bool resolved,\r\n            bool success\r\n        ) {\r\n        Contribution c = contributions[contributionHash];\r\n        contributor = c.contributor;\r\n        recipient = c.recipient;\r\n        ethWei = c.ethWei;\r\n        tokens = c.tokens;\r\n        resolved = c.resolved;\r\n        success = c.success;\r\n    }\r\n\r\n    function getContributionHashes() public constant returns (bytes32[]) {\r\n        return contributionHashes;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleConcluded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"buyRecipient\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase1StartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleTokenSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"averageBlockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase5EndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBlockTime\",\"type\":\"uint256\"}],\"name\":\"setAverageBlockTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmTeamWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWithdrawalProposed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContributionHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributionHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelTeamWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase1EndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"acceptContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"rejectContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase4Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase2EndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnerTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"concludePresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"concludeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase3EndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dayNum\",\"type\":\"uint256\"}],\"name\":\"dayToBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWithdrawalRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"proposeTeamWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICOReserveWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"proposeNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferLockup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase4EndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamLockUp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase2Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase3Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBasePrice\",\"type\":\"uint256\"}],\"name\":\"setBasePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase1Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleConcluded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contributionHash\",\"type\":\"bytes32\"}],\"name\":\"getContributionFromHash\",\"outputs\":[{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"ethWei\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"resolved\",\"type\":\"bool\"},{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setMultisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleTokenSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Halt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unhalt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StartPresale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ConcludePresale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StartCrowdsale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ConcludeCrowdsale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMultisig\",\"type\":\"address\"}],\"name\":\"SetMultisig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pendingTokens\",\"type\":\"uint256\"}],\"name\":\"ContributionReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"pass\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ContributionResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"originalOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"OwnerTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"RepuX","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005d71e3becd65d61e3befe3917ae34f26960a1a7f","Library":"","SwarmSource":"bzzr://70df99688efd5c6029f525ea8d8214200de10e728e7de319a7f8606175d71449"}]}