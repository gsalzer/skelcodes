{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\ncontract owned {\r\n    \r\n    address public owner;\r\n    \r\n    event ContractOwnershipTransferred(address newOwner);\r\n    \r\n    function owned() { owner = msg.sender; }\r\n    \r\n    modifier onlyOwner { \r\n        require(msg.sender == owner); \r\n        _; \r\n    }\r\n    \r\n    function setContractOwner(address newOwner) external onlyOwner  {\r\n        owner = newOwner;\r\n        ContractOwnershipTransferred(newOwner);\r\n    }\r\n}\r\n\r\n/// Cillionaire is a lottery where people can participate until a pot limit is reached. Then, a random participant is chosen to be the winner.\r\n/// \r\n/// Randomness is achieved by XOR'ing the following two numbers:\r\n/// ownerRandomNumber ... a random number supplied by the contract owner and submitted upon `start` as a hash, much like a concealed bid in an auction.\r\n/// minerRandomNumber ... timestamp of the block that contains the last participant's `particpate` transaction.\r\n/// Neither can the owner know the minerRandomNumber, nor can the miner know the ownerRandomNumber (unless the owner supplies a breakable hash, e.h. keccak256(1)).\r\n///\r\n/// Many safeguards are in place to prevent loss of participants' stakes and ensure fairness:\r\n/// - The owner can `cancel`, in which case participants must be refunded.\r\n/// - If the owner does not end the game via `chooseWinner` within 24 hours after PARTICIPATION `state` ended, then anyone can `cancel`.\r\n/// - The contract has no `kill` function which would allow the owner to run off with the pot.\r\n/// - Game parameters cannot be changed when a game is ongoing\r\n/// - Logging of relevant events to increase transparency\r\ncontract Cillionaire is owned {\r\n    \r\n    enum State { ENDED, PARTICIPATION, CHOOSE_WINNER, REFUND }\r\n\r\n    /// Target amount of ether. As long as the `potTarget` is not reached, people can `participate` when the contract is in PARTICIPATION `state`.\r\n    uint public potTarget;\r\n    /// Amount of ether that will be used to `participate`.\r\n    uint public stake;\r\n    /// Amount of ether that will be taken from `stake` as a fee for the owner.\r\n    uint public fee;\r\n    \r\n    State public state;\r\n    address[] public participants;\r\n    bytes32 public ownerRandomHash;\r\n    uint public minerRandomNumber;\r\n    uint public ownerRandomNumber;\r\n    uint public participationEndTimestamp;\r\n    uint public pot;\r\n    address public winner;\r\n    mapping (address => uint) public funds;\r\n    uint public fees;\r\n    uint public lastRefundedIndex;\r\n    \r\n    event StateChange(State newState);\r\n    event NewParticipant(address participant, uint total, uint stakeAfterFee, uint refundNow);\r\n    event MinerRandomNumber(uint number);\r\n    event OwnerRandomNumber(uint number);\r\n    event RandomNumber(uint randomNumber);\r\n    event WinnerIndex(uint winnerIndex);\r\n    event Winner(address _winner, uint amount);\r\n    event Refund(address participant, uint amount);\r\n    event Cancelled(address cancelledBy);\r\n    event ParametersChanged(uint newPotTarget, uint newStake, uint newFee);\r\n    \r\n    modifier onlyState(State _state) { \r\n        require(state == _state); \r\n        _; \r\n    }\r\n    \r\n    // Taken from: https://solidity.readthedocs.io/en/develop/common-patterns.html\r\n    // This modifier requires a certain\r\n    // fee being associated with a function call.\r\n    // If the caller sent too much, he or she is\r\n    // refunded, but only after the function body.\r\n    // This was dangerous before Solidity version 0.4.0,\r\n    // where it was possible to skip the part after `_;`.\r\n    modifier costs(uint _amount) {\r\n        require(msg.value >= _amount);\r\n        _;\r\n        if (msg.value > _amount) {\r\n            msg.sender.transfer(msg.value - _amount);\r\n        }\r\n    }\r\n    \r\n    function Cillionaire() {\r\n        state = State.ENDED;\r\n        potTarget = 0.1 ether;\r\n        stake = 0.05 ether;\r\n        fee = 0;\r\n    }\r\n    \r\n    function setState(State _state) internal {\r\n        state = _state;\r\n        StateChange(state);\r\n    }\r\n    \r\n    /// Starts the game, i.e. resets game variables and transitions to state `PARTICIPATION`\r\n    /// `_ownerRandomHash` is the owner's concealed random number. \r\n    /// It must be a keccak256 hash that can be verfied in `chooseWinner`.\r\n    function start(bytes32 _ownerRandomHash) external onlyOwner onlyState(State.ENDED) {\r\n        ownerRandomHash = _ownerRandomHash;\r\n        minerRandomNumber = 0;\r\n        ownerRandomNumber = 0;\r\n        participationEndTimestamp = 0;\r\n        winner = 0;\r\n        pot = 0;\r\n        lastRefundedIndex = 0;\r\n        delete participants;\r\n        setState(State.PARTICIPATION);\r\n    }\r\n    \r\n    /// Participate in the game.\r\n    /// You must send at least `stake` amount of ether. Surplus ether is refunded automatically and immediately.\r\n    /// This function will only work when the contract is in `state` PARTICIPATION.\r\n    /// Once the `potTarget` is reached, the `state` transitions to CHOOSE_WINNER.\r\n    function participate() external payable onlyState(State.PARTICIPATION) costs(stake) {\r\n        participants.push(msg.sender);\r\n        uint stakeAfterFee = stake - fee;\r\n        pot += stakeAfterFee;\r\n        fees += fee;\r\n        NewParticipant(msg.sender, msg.value, stakeAfterFee, msg.value - stake);\r\n        if (pot >= potTarget) {\r\n            participationEndTimestamp = block.timestamp;\r\n            minerRandomNumber = block.timestamp;\r\n            MinerRandomNumber(minerRandomNumber);\r\n            setState(State.CHOOSE_WINNER);\r\n        }\r\n    }\r\n    \r\n    /// Reveal the owner's random number and choose a winner using all three random numbers.\r\n    /// The winner is credited the pot and can get their funds using `withdraw`.\r\n    /// This function will only work when the contract is in `state` CHOOSE_WINNER.\r\n    function chooseWinner(string _ownerRandomNumber, string _ownerRandomSecret) external onlyOwner onlyState(State.CHOOSE_WINNER) {\r\n        require(keccak256(_ownerRandomNumber, _ownerRandomSecret) == ownerRandomHash);\r\n        require(!startsWithDigit(_ownerRandomSecret)); // This is needed because keccak256(\"12\", \"34\") == keccak256(\"1\", \"234\") to prevent owner from changing his initially comitted random number\r\n        ownerRandomNumber = parseInt(_ownerRandomNumber);\r\n        OwnerRandomNumber(ownerRandomNumber);\r\n        uint randomNumber = ownerRandomNumber ^ minerRandomNumber;\r\n        RandomNumber(randomNumber);\r\n        uint winnerIndex = randomNumber % participants.length;\r\n        WinnerIndex(winnerIndex);\r\n        winner = participants[winnerIndex];\r\n        funds[winner] += pot;\r\n        Winner(winner, pot);\r\n        setState(State.ENDED);\r\n    }\r\n    \r\n    /// Cancel the game.\r\n    /// Participants' stakes (including fee) are refunded. Use the `withdraw` function to get the refund.\r\n    /// Owner can cancel at any time in `state` PARTICIPATION or CHOOSE_WINNER\r\n    /// Anyone can cancel 24h after `state` PARTICIPATION ended. This is to make sure no funds get locked up due to inactivity of the owner.\r\n    function cancel() external {\r\n        if (msg.sender == owner) {\r\n            require(state == State.PARTICIPATION || state == State.CHOOSE_WINNER);\r\n        } else {\r\n            require((state == State.CHOOSE_WINNER) && (participationEndTimestamp != 0) && (block.timestamp > participationEndTimestamp + 1 days));\r\n        }\r\n        Cancelled(msg.sender);\r\n        // refund index 0 so lastRefundedIndex=0 is correct\r\n        if (participants.length > 0) {\r\n            funds[participants[0]] += stake;\r\n            fees -= fee;\r\n            lastRefundedIndex = 0;\r\n            Refund(participants[0], stake);\r\n            if (participants.length == 1) {\r\n                setState(State.ENDED);\r\n            } else {\r\n                setState(State.REFUND);\r\n            }\r\n        } else {\r\n            // nothing to refund\r\n            setState(State.ENDED);\r\n        }\r\n    }\r\n    \r\n    /// Refund a number of accounts specified by `_count`, beginning at the next un-refunded index which is lastRefundedIndex`+1.\r\n    /// This is so that refunds can be dimensioned such that they don't exceed block gas limit.\r\n    /// Once all participants are refunded `state` transitions to ENDED.\r\n    /// Any user can do the refunds.\r\n    function refund(uint _count) onlyState(State.REFUND) {\r\n        require(participants.length > 0);\r\n        uint first = lastRefundedIndex + 1;\r\n        uint last = lastRefundedIndex + _count;\r\n        if (last > participants.length - 1) {\r\n            last = participants.length - 1;\r\n        }\r\n        for (uint i = first; i <= last; i++) {\r\n            funds[participants[i]] += stake;\r\n            fees -= fee;\r\n            Refund(participants[i], stake);\r\n        }\r\n        lastRefundedIndex = last;\r\n        if (lastRefundedIndex >= participants.length - 1) {\r\n            setState(State.ENDED);\r\n        }\r\n    }\r\n\r\n    /// Withdraw your funds, i.e. winnings and refunds.\r\n    /// This function can be called in any state and will withdraw all winnings as well as refunds. \r\n    function withdraw() external {\r\n        uint amount = funds[msg.sender];\r\n        funds[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    /// Withdraw accumulated fees. \r\n    /// Usable by contract owner when `state` is ENDED.\r\n    function withdrawFees() external onlyOwner onlyState(State.ENDED) {\r\n        uint amount = fees;\r\n        fees = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    /// Adjust game parameters. All parameters are in Wei.\r\n    /// Can be called by the contract owner in `state` ENDED.\r\n    function setParams(uint _potTarget, uint _stake, uint _fee) external onlyOwner onlyState(State.ENDED) {\r\n        require(_fee < _stake);\r\n        potTarget = _potTarget;\r\n        stake = _stake; \r\n        fee = _fee;\r\n        ParametersChanged(potTarget, stake, fee);\r\n    }\r\n    \r\n    function startsWithDigit(string str) internal returns (bool) {\r\n        bytes memory b = bytes(str);\r\n        return b[0] >= 48 && b[0] <= 57; // 0-9; see http://dev.networkerror.org/utf8/\r\n    }\r\n    \r\n    // parseInt \r\n    // Copyright (c) 2015-2016 Oraclize SRL\r\n    // Copyright (c) 2016 Oraclize LTD\r\n    // Source: https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    // Copyright (c) 2015-2016 Oraclize SRL\r\n    // Copyright (c) 2016 Oraclize LTD\r\n    // Source: https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_ownerRandomHash\",\"type\":\"bytes32\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerRandomHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_potTarget\",\"type\":\"uint256\"},{\"name\":\"_stake\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setParams\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerRandomNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerRandomNumber\",\"type\":\"string\"},{\"name\":\"_ownerRandomSecret\",\"type\":\"string\"}],\"name\":\"chooseWinner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRefundedIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minerRandomNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setContractOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"participate\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"funds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participationEndTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeAfterFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refundNow\",\"type\":\"uint256\"}],\"name\":\"NewParticipant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"MinerRandomNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"OwnerRandomNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"name\":\"RandomNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winnerIndex\",\"type\":\"uint256\"}],\"name\":\"WinnerIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cancelledBy\",\"type\":\"address\"}],\"name\":\"Cancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newPotTarget\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newStake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"ParametersChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ContractOwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Cillionaire","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d3c55fe53136fe649328f518da823758192159b4830f4c0fd29ad98fc99d81f9"}]}