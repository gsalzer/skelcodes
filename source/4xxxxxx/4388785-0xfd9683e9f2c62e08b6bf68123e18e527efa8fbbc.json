{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.15;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title PausableOnce\r\n * @dev The PausableOnce contract provides an option for the \"pauseMaster\"\r\n * to pause once the transactions for two weeks.\r\n *\r\n */\r\n\r\ncontract PausableOnce is Ownable {\r\n\r\n    /** Address that can start the pause */\r\n    address public pauseMaster;\r\n\r\n    uint constant internal PAUSE_DURATION = 14 days;\r\n    uint64 public pauseEnd = 0;\r\n\r\n    event Paused();\r\n\r\n    /**\r\n     * @dev Set the pauseMaster (callable by the owner only).\r\n     * @param _pauseMaster The address of the pauseMaster\r\n     */\r\n    function setPauseMaster(address _pauseMaster) onlyOwner external returns (bool success) {\r\n        require(_pauseMaster != address(0));\r\n        pauseMaster = _pauseMaster;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Start the pause (by the pauseMaster, ONCE only).\r\n     */\r\n    function pause() onlyPauseMaster external returns (bool success) {\r\n        require(pauseEnd == 0);\r\n        pauseEnd = uint64(now + PAUSE_DURATION);\r\n        Paused();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(now > pauseEnd);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the pauseMaster.\r\n     */\r\n    modifier onlyPauseMaster() {\r\n        require(msg.sender == pauseMaster);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @title Upgrade agent interface\r\n*/\r\ncontract InterfaceUpgradeAgent {\r\n\r\n    uint32 public revision;\r\n    uint256 public originalSupply;\r\n\r\n    /**\r\n     * @dev Reissue the tokens onto the new contract revision.\r\n     * @param holder Holder (owner) of the tokens\r\n     * @param tokenQty How many tokens to be issued\r\n     */\r\n    function upgradeFrom(address holder, uint256 tokenQty) public;\r\n}\r\n\r\n/**\r\n * @title UpgradableToken\r\n * @dev The UpgradableToken contract provides an option of upgrading the tokens to a new revision.\r\n * The \"upgradeMaster\" may propose the upgrade. Token holders can opt-in amount of tokens to upgrade.\r\n */\r\n\r\ncontract UpgradableToken is StandardToken, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint32 public REVISION;\r\n\r\n    /** Address that can set the upgrade agent thus enabling the upgrade. */\r\n    address public upgradeMaster = address(0);\r\n\r\n    /** Address of the contract that issues the new revision tokens. */\r\n    address public upgradeAgent = address(0);\r\n\r\n    /** How many tokens are upgraded. */\r\n    uint256 public totalUpgraded;\r\n\r\n    event Upgrade(address indexed _from, uint256 _value);\r\n    event UpgradeEnabled(address agent);\r\n\r\n    /**\r\n     * @dev Set the upgrade master.\r\n     * parameter _upgradeMaster Upgrade master\r\n     */\r\n    function setUpgradeMaster(address _upgradeMaster) onlyOwner external {\r\n        require(_upgradeMaster != address(0));\r\n        upgradeMaster = _upgradeMaster;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the upgrade agent (once only) thus enabling the upgrade.\r\n     * @param _upgradeAgent Upgrade agent contract address\r\n     * @param _revision Unique ID that agent contract must return on \".revision()\"\r\n     */\r\n    function setUpgradeAgent(address _upgradeAgent, uint32 _revision)\r\n        onlyUpgradeMaster whenUpgradeDisabled external\r\n    {\r\n        require((_upgradeAgent != address(0)) && (_revision != 0));\r\n\r\n        InterfaceUpgradeAgent agent = InterfaceUpgradeAgent(_upgradeAgent);\r\n\r\n        require(agent.revision() == _revision);\r\n        require(agent.originalSupply() == totalSupply);\r\n\r\n        upgradeAgent = _upgradeAgent;\r\n        UpgradeEnabled(_upgradeAgent);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade tokens to the new revision.\r\n     * @param value How many tokens to be upgraded\r\n     */\r\n    function upgrade(uint256 value) whenUpgradeEnabled external {\r\n        require(value > 0);\r\n\r\n        uint256 balance = balances[msg.sender];\r\n        require(balance > 0);\r\n\r\n        // Take tokens out from the old contract\r\n        balances[msg.sender] = balance.sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        totalUpgraded = totalUpgraded.add(value);\r\n        // Issue the new revision tokens\r\n        InterfaceUpgradeAgent agent = InterfaceUpgradeAgent(upgradeAgent);\r\n        agent.upgradeFrom(msg.sender, value);\r\n\r\n        Upgrade(msg.sender, value);\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the upgrade is enabled.\r\n    */\r\n    modifier whenUpgradeEnabled() {\r\n        require(upgradeAgent != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the upgrade is impossible.\r\n    */\r\n    modifier whenUpgradeDisabled() {\r\n        require(upgradeAgent == address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the upgradeMaster.\r\n    */\r\n    modifier onlyUpgradeMaster() {\r\n        require(msg.sender == upgradeMaster);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Withdrawable\r\n * @dev The Withdrawable contract provides a mechanism of withdrawal(s).\r\n * \"Withdrawals\" are permissions for specified addresses to pull (withdraw) payments from the contract balance.\r\n */\r\n\r\ncontract Withdrawable {\r\n\r\n    mapping (address => uint) pendingWithdrawals;\r\n\r\n    /*\r\n     * @dev Logged upon a granted allowance to the specified drawer on withdrawal.\r\n     * @param drawer The address of the drawer.\r\n     * @param weiAmount The value in Wei which may be withdrawn.\r\n     */\r\n    event Withdrawal(address indexed drawer, uint256 weiAmount);\r\n\r\n    /*\r\n     * @dev Logged upon a withdrawn value.\r\n     * @param drawer The address of the drawer.\r\n     * @param weiAmount The value in Wei which has been withdrawn.\r\n     */\r\n    event Withdrawn(address indexed drawer, uint256 weiAmount);\r\n\r\n    /*\r\n     * @dev Allow the specified drawer to withdraw the specified value from the contract balance.\r\n     * @param drawer The address of the drawer.\r\n     * @param weiAmount The value in Wei allowed to withdraw.\r\n     * @return success\r\n     */\r\n    function setWithdrawal(address drawer, uint256 weiAmount) internal returns (bool success) {\r\n        if ((drawer != address(0)) && (weiAmount > 0)) {\r\n            uint256 oldBalance = pendingWithdrawals[drawer];\r\n            uint256 newBalance = oldBalance + weiAmount;\r\n            if (newBalance > oldBalance) {\r\n                pendingWithdrawals[drawer] = newBalance;\r\n                Withdrawal(drawer, weiAmount);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     * @dev Withdraw the allowed value from the contract balance.\r\n     * @return success\r\n     */\r\n    function withdraw() public returns (bool success) {\r\n        uint256 weiAmount = pendingWithdrawals[msg.sender];\r\n        require(weiAmount > 0);\r\n\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        msg.sender.transfer(weiAmount);\r\n        Withdrawn(msg.sender, weiAmount);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Cointed Token\r\n * @dev Cointed Token (CTD) and Token Sale (ICO).\r\n */\r\n\r\ncontract CtdToken is UpgradableToken, PausableOnce, Withdrawable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Cointed Token\";\r\n    string public constant symbol = \"CTD\";\r\n    /** Number of \"Atom\" in 1 CTD (1 CTD = 1x10^decimals Atom) */\r\n    uint8  public constant decimals = 18;\r\n\r\n    /** Holder of bounty tokens */\r\n    address public bounty;\r\n\r\n    /** Limit (in Atom) issued, inclusive owner's and bounty shares */\r\n    uint256 constant internal TOTAL_LIMIT   = 650000000 * (10 ** uint256(decimals));\r\n    /** Limit (in Atom) for Pre-ICO Phases A, incl. owner's and bounty shares */\r\n    uint256 constant internal PRE_ICO_LIMIT = 130000000 * (10 ** uint256(decimals));\r\n\r\n    /**\r\n    * ICO Phases.\r\n    *\r\n    * - PreStart: tokens are not yet sold/issued\r\n    * - PreIcoA:  new tokens sold/issued at the premium price\r\n    * - PreIcoB:  new tokens sold/issued at the discounted price\r\n    * - MainIco   new tokens sold/issued at the regular price\r\n    * - AfterIco: new tokens can not be not be sold/issued any longer\r\n    */\r\n    enum Phases {PreStart, PreIcoA, PreIcoB, MainIco, AfterIco}\r\n\r\n    uint64 constant internal PRE_ICO_DURATION = 30 days;\r\n    uint64 constant internal ICO_DURATION = 82 days;\r\n    uint64 constant internal RETURN_WEI_PAUSE = 30 days;\r\n\r\n    // Main ICO rate in CTD(s) per 1 ETH:\r\n    uint256 constant internal TO_SENDER_RATE   = 1000;\r\n    uint256 constant internal TO_OWNER_RATE    =  263;\r\n    uint256 constant internal TO_BOUNTY_RATE   =   52;\r\n    uint256 constant internal TOTAL_RATE   =   TO_SENDER_RATE + TO_OWNER_RATE + TO_BOUNTY_RATE;\r\n    // Pre-ICO Phase A rate\r\n    uint256 constant internal TO_SENDER_RATE_A = 1150;\r\n    uint256 constant internal TO_OWNER_RATE_A  =  304;\r\n    uint256 constant internal TO_BOUNTY_RATE_A =   61;\r\n    uint256 constant internal TOTAL_RATE_A   =   TO_SENDER_RATE_A + TO_OWNER_RATE_A + TO_BOUNTY_RATE_A;\r\n    // Pre-ICO Phase B rate\r\n    uint256 constant internal TO_SENDER_RATE_B = 1100;\r\n    uint256 constant internal TO_OWNER_RATE_B  =  292;\r\n    uint256 constant internal TO_BOUNTY_RATE_B =   58;\r\n    uint256 constant internal TOTAL_RATE_B   =   TO_SENDER_RATE_B + TO_OWNER_RATE_B + TO_BOUNTY_RATE_B;\r\n\r\n    // Award in Wei(s) to a successful initiator of a Phase shift\r\n    uint256 constant internal PRE_OPENING_AWARD = 100 * (10 ** uint256(15));\r\n    uint256 constant internal ICO_OPENING_AWARD = 200 * (10 ** uint256(15));\r\n    uint256 constant internal ICO_CLOSING_AWARD = 500 * (10 ** uint256(15));\r\n\r\n    struct Rates {\r\n        uint256 toSender;\r\n        uint256 toOwner;\r\n        uint256 toBounty;\r\n        uint256 total;\r\n    }\r\n\r\n    event NewTokens(uint256 amount);\r\n    event NewFunds(address funder, uint256 value);\r\n    event NewPhase(Phases phase);\r\n\r\n    // current Phase\r\n    Phases public phase = Phases.PreStart;\r\n\r\n    // Timestamps limiting duration of Phases, in seconds since Unix epoch.\r\n    uint64 public preIcoOpeningTime;  // when Pre-ICO Phase A starts\r\n    uint64 public icoOpeningTime;     // when Main ICO starts (if not sold out before)\r\n    uint64 public closingTime;        // by when the ICO campaign finishes in any way\r\n    uint64 public returnAllowedTime;  // when owner may withdraw Eth from contract, if any\r\n\r\n    uint256 public totalProceeds;\r\n\r\n    /*\r\n     * @dev constructor\r\n     * @param _preIcoOpeningTime Timestamp when the Pre-ICO (Phase A) shall start.\r\n     * msg.value MUST be at least the sum of awards.\r\n     */\r\n    function CtdToken(uint64 _preIcoOpeningTime) payable {\r\n        require(_preIcoOpeningTime > now);\r\n\r\n        preIcoOpeningTime = _preIcoOpeningTime;\r\n        icoOpeningTime = preIcoOpeningTime + PRE_ICO_DURATION;\r\n        closingTime = icoOpeningTime + ICO_DURATION;\r\n    }\r\n\r\n    /*\r\n     * @dev Fallback function delegates the request to create().\r\n     */\r\n    function () payable external {\r\n        create();\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the holder of bounty tokens.\r\n     * @param _bounty The address of the bounty token holder.\r\n     * @return success/failure\r\n     */\r\n    function setBounty(address _bounty) onlyOwner external returns (bool success) {\r\n        require(_bounty != address(0));\r\n        bounty = _bounty;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Mint tokens and add them to the balance of the message.sender.\r\n     * Additional tokens are minted and added to the owner and the bounty balances.\r\n     * @return success/failure\r\n     */\r\n    function create() payable whenNotClosed whenNotPaused public returns (bool success) {\r\n        require(msg.value > 0);\r\n        require(now >= preIcoOpeningTime);\r\n\r\n        Phases oldPhase = phase;\r\n        uint256 weiToParticipate = msg.value;\r\n        uint256 overpaidWei;\r\n\r\n        adjustPhaseBasedOnTime();\r\n\r\n        if (phase != Phases.AfterIco) {\r\n\r\n            Rates memory rates = getRates();\r\n            uint256 newTokens = weiToParticipate.mul(rates.total);\r\n            uint256 requestedSupply = totalSupply.add(newTokens);\r\n\r\n            uint256 oversoldTokens = computeOversoldAndAdjustPhase(requestedSupply);\r\n            overpaidWei = (oversoldTokens > 0) ? oversoldTokens.div(rates.total) : 0;\r\n\r\n            if (overpaidWei > 0) {\r\n                weiToParticipate = msg.value.sub(overpaidWei);\r\n                newTokens = weiToParticipate.mul(rates.total);\r\n                requestedSupply = totalSupply.add(newTokens);\r\n            }\r\n\r\n            // \"emission\" of new tokens\r\n            totalSupply = requestedSupply;\r\n            balances[msg.sender] = balances[msg.sender].add(weiToParticipate.mul(rates.toSender));\r\n            balances[owner] = balances[owner].add(weiToParticipate.mul(rates.toOwner));\r\n            balances[bounty] = balances[bounty].add(weiToParticipate.mul(rates.toBounty));\r\n\r\n            // ETH transfers\r\n            totalProceeds = totalProceeds.add(weiToParticipate);\r\n            owner.transfer(weiToParticipate);\r\n            if (overpaidWei > 0) {\r\n                setWithdrawal(msg.sender, overpaidWei);\r\n            }\r\n\r\n            // Logging\r\n            NewTokens(newTokens);\r\n            NewFunds(msg.sender, weiToParticipate);\r\n\r\n        } else {\r\n            setWithdrawal(msg.sender, msg.value);\r\n        }\r\n\r\n        if (phase != oldPhase) {\r\n            logShiftAndBookAward();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Send the value (ethers) that the contract holds to the owner address.\r\n     */\r\n    function returnWei() onlyOwner whenClosed afterWithdrawPause external {\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    function adjustPhaseBasedOnTime() internal {\r\n\r\n        if (now >= closingTime) {\r\n            if (phase != Phases.AfterIco) {\r\n                phase = Phases.AfterIco;\r\n            }\r\n        } else if (now >= icoOpeningTime) {\r\n            if (phase != Phases.MainIco) {\r\n                phase = Phases.MainIco;\r\n            }\r\n        } else if (phase == Phases.PreStart) {\r\n            setDefaultParamsIfNeeded();\r\n            phase = Phases.PreIcoA;\r\n        }\r\n    }\r\n\r\n    function setDefaultParamsIfNeeded() internal {\r\n        if (bounty == address(0)) {\r\n            bounty = owner;\r\n        }\r\n        if (upgradeMaster == address(0)) {\r\n            upgradeMaster = owner;\r\n        }\r\n        if (pauseMaster == address(0)) {\r\n            pauseMaster = owner;\r\n        }\r\n    }\r\n\r\n    function computeOversoldAndAdjustPhase(uint256 newTotalSupply) internal returns (uint256 oversoldTokens) {\r\n\r\n        if ((phase == Phases.PreIcoA) &&\r\n            (newTotalSupply >= PRE_ICO_LIMIT)) {\r\n            phase = Phases.PreIcoB;\r\n            oversoldTokens = newTotalSupply.sub(PRE_ICO_LIMIT);\r\n\r\n        } else if (newTotalSupply >= TOTAL_LIMIT) {\r\n            phase = Phases.AfterIco;\r\n            oversoldTokens = newTotalSupply.sub(TOTAL_LIMIT);\r\n\r\n        } else {\r\n            oversoldTokens = 0;\r\n        }\r\n\r\n        return oversoldTokens;\r\n    }\r\n\r\n    function getRates() internal returns (Rates rates) {\r\n\r\n        if (phase == Phases.PreIcoA) {\r\n            rates.toSender = TO_SENDER_RATE_A;\r\n            rates.toOwner = TO_OWNER_RATE_A;\r\n            rates.toBounty = TO_BOUNTY_RATE_A;\r\n            rates.total = TOTAL_RATE_A;\r\n        } else if (phase == Phases.PreIcoB) {\r\n            rates.toSender = TO_SENDER_RATE_B;\r\n            rates.toOwner = TO_OWNER_RATE_B;\r\n            rates.toBounty = TO_BOUNTY_RATE_B;\r\n            rates.total = TOTAL_RATE_B;\r\n        } else {\r\n            rates.toSender = TO_SENDER_RATE;\r\n            rates.toOwner = TO_OWNER_RATE;\r\n            rates.toBounty = TO_BOUNTY_RATE;\r\n            rates.total = TOTAL_RATE;\r\n        }\r\n        return rates;\r\n    }\r\n\r\n    function logShiftAndBookAward() internal {\r\n        uint256 shiftAward;\r\n\r\n        if ((phase == Phases.PreIcoA) || (phase == Phases.PreIcoB)) {\r\n            shiftAward = PRE_OPENING_AWARD;\r\n\r\n        } else if (phase == Phases.MainIco) {\r\n            shiftAward = ICO_OPENING_AWARD;\r\n\r\n        } else {\r\n            shiftAward = ICO_CLOSING_AWARD;\r\n            returnAllowedTime = uint64(now + RETURN_WEI_PAUSE);\r\n        }\r\n\r\n        setWithdrawal(msg.sender, shiftAward);\r\n        NewPhase(phase);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens to the specified address.\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount of tokens to be transferred.\r\n     * @return success/failure\r\n     */\r\n    function transfer(address _to, uint256 _value)\r\n        whenNotPaused limitForOwner public returns (bool success)\r\n    {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * @param _from address The address which you want to send tokens from.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value the amount of tokens to be transferred.\r\n     * @return success/failure\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        whenNotPaused limitForOwner public returns (bool success)\r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the specified address to spend the specified amount of tokens on behalf of the msg.sender.\r\n     * Use \"increaseApproval\" or \"decreaseApproval\" function to change the approval, if needed.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     * @return success/failure\r\n     */\r\n    function approve(address _spender, uint256 _value)\r\n        whenNotPaused limitForOwner public returns (bool success)\r\n    {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the approval for the passed address to spend tokens on behalf of the msg.sender.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the approval with.\r\n     * @return success/failure\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue)\r\n        whenNotPaused limitForOwner public returns (bool success)\r\n    {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the approval for the passed address to spend tokens on behalf of the msg.sender.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the approval with.\r\n     * @return success/failure\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue)\r\n        whenNotPaused limitForOwner public returns (bool success)\r\n    {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n\r\n    /*\r\n     * @dev Withdraw the allowed value (ethers) from the contract balance.\r\n     * @return success/failure\r\n     */\r\n    function withdraw() whenNotPaused public returns (bool success) {\r\n        return super.withdraw();\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called when ICO is active.\r\n     */\r\n    modifier whenClosed() {\r\n        require(phase == Phases.AfterIco);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called when ICO is completed.\r\n     */\r\n    modifier whenNotClosed() {\r\n        require(phase != Phases.AfterIco);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by the owner before ICO is completed.\r\n     */\r\n    modifier limitForOwner() {\r\n        require((msg.sender != owner) || (phase == Phases.AfterIco));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called before returnAllowedTime.\r\n     */\r\n    modifier afterWithdrawPause() {\r\n        require(now > returnAllowedTime);\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pauseMaster\",\"type\":\"address\"}],\"name\":\"setPauseMaster\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoOpeningTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"returnWei\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_upgradeAgent\",\"type\":\"address\"},{\"name\":\"_revision\",\"type\":\"uint32\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bounty\",\"type\":\"address\"}],\"name\":\"setBounty\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauseMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauseEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REVISION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"create\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalProceeds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preIcoOpeningTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnAllowedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_upgradeMaster\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_preIcoOpeningTime\",\"type\":\"uint64\"}],\"payable\":true,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phase\",\"type\":\"uint8\"}],\"name\":\"NewPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"drawer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"drawer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CtdToken","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000059e92060","Library":"","SwarmSource":"bzzr://01b95e451007242667edc2ca694a832b34c392fff48835360cd0f525874ce549"}]}