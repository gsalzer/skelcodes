{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.10;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n     * Events\r\n     */\r\n    event ChangedOwner(address indexed new_owner);\r\n\r\n    /**\r\n     * Functionality\r\n     */\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) onlyOwner external {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n            newOwner = 0x0;\r\n            ChangedOwner(owner);\r\n        }\r\n    }\r\n}\r\n\r\ncontract IOwned {\r\n    function owner() returns (address);\r\n    function changeOwner(address);\r\n    function acceptOwnership();\r\n}\r\n\r\ncontract Token {\r\n\tfunction transferFrom(address from, address to, uint amount) returns(bool);\r\n\tfunction transfer(address to, uint amount) returns(bool);\r\n\tfunction balanceOf(address addr) constant returns(uint);\r\n}\r\n\r\n\r\n/**\r\n * Savings is a contract that releases Tokens on a predefined\r\n * schedule, and allocates bonus tokens upon withdrawal on a\r\n * proportional basis, determined by the ratio of deposited tokens\r\n * to total owned tokens.\r\n *\r\n * The distribution schedule consists of a monthly withdrawal schedule\r\n * responsible for distribution 75% of the total savings, and a\r\n * one-off withdrawal event available before or at the start of the\r\n * withdrawal schedule, distributing 25% of the total savings.\r\n *\r\n * To be exact, upon contract deployment there may be a period of time in which\r\n * only the one-off withdrawal event is available, define this period of time as:\r\n * [timestamp(start), timestamp(startBlockTimestamp)),\r\n *\r\n * Then the periodic withdrawal range is defined as:\r\n * [timestamp(startBlockTimestamp), +inf)\r\n *\r\n * DO NOT SEND TOKENS TO THIS CONTRACT. Use the deposit() or depositTo() method.\r\n * As an exception, tokens transferred to this contract before locking are the\r\n * bonus tokens that are distributed.\r\n */\r\ncontract Savings is Owned {\r\n\t/**\r\n\t * Periods is the total monthly withdrawable amount, not counting the\r\n\t * special withdrawal.\r\n\t */\r\n\tuint public periods;\r\n\r\n\t/**\r\n\t * t0special is an additional multiplier that determines what\r\n\t * fraction of the total distribution is distributed in the\r\n\t * one-off withdrawal event. It is used in conjunction with\r\n\t * a periodic multiplier (p) to determine the total savings withdrawable\r\n\t * to the user at that point in time.\r\n\t *\r\n\t * The value is not set, it is calculated based on periods\r\n\t */\r\n\tuint public t0special;\r\n\r\n\tuint constant public intervalSecs = 30 days;\r\n\tuint constant public precision = 10 ** 18;\r\n\r\n\r\n\t/**\r\n\t * Events\r\n\t */\r\n\tevent Withdraws(address indexed who, uint amount);\r\n\tevent Deposit(address indexed who, uint amount);\r\n\r\n\tbool public inited;\r\n\tbool public locked;\r\n\tuint public startBlockTimestamp = 0;\r\n\r\n\tToken public token;\r\n\r\n\t// face value deposited by an address before locking\r\n\tmapping (address => uint) public deposited;\r\n\r\n\t// total face value deposited; sum of deposited\r\n\tuint public totalfv;\r\n\r\n\t// the total remaining value\r\n\tuint public remainder;\r\n\r\n\t/**\r\n\t * Total tokens owned by the contract after locking, and possibly\r\n\t * updated by the foundation after subsequent sales.\r\n\t */\r\n\tuint public total;\r\n\r\n\t// the total value withdrawn\r\n\tmapping (address => uint256) public withdrawn;\r\n\r\n\tbool public nullified;\r\n\r\n\tmodifier notNullified() { require(!nullified); _; }\r\n\r\n\tmodifier preLock() { require(!locked && startBlockTimestamp == 0); _; }\r\n\r\n\t/**\r\n\t * Lock called, deposits no longer available.\r\n\t */\r\n\tmodifier postLock() { require(locked); _; }\r\n\r\n\t/**\r\n\t * Prestart, state is after lock, before start\r\n\t */\r\n\tmodifier preStart() { require(locked && startBlockTimestamp == 0); _; }\r\n\r\n\t/**\r\n\t * Start called, the savings contract is now finalized, and withdrawals\r\n\t * are now permitted.\r\n\t */\r\n\tmodifier postStart() { require(locked && startBlockTimestamp != 0); _; }\r\n\r\n\t/**\r\n\t * Uninitialized state, before init is called. Mainly used as a guard to\r\n\t * finalize periods and t0special.\r\n\t */\r\n\tmodifier notInitialized() { require(!inited); _; }\r\n\r\n\t/**\r\n\t * Post initialization state, mainly used to guarantee that\r\n\t * periods and t0special have been set properly before starting\r\n\t * the withdrawal process.\r\n\t */\r\n\tmodifier initialized() { require(inited); _; }\r\n\r\n\t/**\r\n\t * Revert under all conditions for fallback, cheaper mistakes\r\n\t * in the future?\r\n\t */\r\n\tfunction() {\r\n\t\trevert();\r\n\t}\r\n\r\n\t/**\r\n\t * Nullify functionality is intended to disable the contract.\r\n\t */\r\n\tfunction nullify() onlyOwner {\r\n\t\tnullified = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Initialization function, should be called after contract deployment. The\r\n\t * addition of this function allows contract compilation to be simplified\r\n\t * to one contract, instead of two.\r\n\t *\r\n\t * periods and t0special are finalized, and effectively invariant, after\r\n\t * init is called for the first time.\r\n\t */\r\n\tfunction init(uint _periods, uint _t0special) onlyOwner notInitialized {\r\n\t\trequire(_periods != 0);\r\n\t\tperiods = _periods;\r\n\t\tt0special = _t0special;\r\n\t}\r\n\r\n\tfunction finalizeInit() onlyOwner notInitialized {\r\n\t\tinited = true;\r\n\t}\r\n\r\n\tfunction setToken(address tok) onlyOwner {\r\n\t\ttoken = Token(tok);\r\n\t}\r\n\r\n\t/**\r\n\t * Lock is called by the owner to lock the savings contract\r\n\t * so that no more deposits may be made.\r\n\t */\r\n\tfunction lock() onlyOwner {\r\n\t\tlocked = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Starts the distribution of savings, it should be called\r\n\t * after lock(), once all of the bonus tokens are send to this contract,\r\n\t * and multiMint has been called.\r\n\t */\r\n\tfunction start(uint _startBlockTimestamp) onlyOwner initialized preStart {\r\n\t\tstartBlockTimestamp = _startBlockTimestamp;\r\n\t\tuint256 tokenBalance = token.balanceOf(this);\r\n\t\ttotal = tokenBalance;\r\n\t\tremainder = tokenBalance;\r\n\t}\r\n\r\n\t/**\r\n\t * Check withdrawal is live, useful for checking whether\r\n\t * the savings contract is \"live\", withdrawal enabled, started.\r\n\t */\r\n\tfunction isStarted() constant returns(bool) {\r\n\t\treturn locked && startBlockTimestamp != 0;\r\n\t}\r\n\r\n\t// if someone accidentally transfers tokens to this contract,\r\n\t// the owner can return them as long as distribution hasn't started\r\n\r\n\t/**\r\n\t * Used to refund users who accidentaly transferred tokens to this\r\n\t * contract, only available before contract is locked\r\n\t */\r\n\tfunction refundTokens(address addr, uint amount) onlyOwner preLock {\r\n\t\ttoken.transfer(addr, amount);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Update the total balance, to be called in case of subsequent sales. Updates\r\n\t * the total recorded balance of the contract by the difference in expected\r\n\t * remainder and the current balance. This means any positive difference will\r\n\t * be \"recorded\" into the contract, and distributed within the remaining\r\n\t * months of the TRS.\r\n\t */\r\n\tfunction updateTotal() onlyOwner postLock {\r\n\t\tuint current = token.balanceOf(this);\r\n\t\trequire(current >= remainder); // for sanity\r\n\r\n\t\tuint difference = (current - remainder);\r\n\t\ttotal += difference;\r\n\t\tremainder = current;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the monthly period, starting after the startBlockTimestamp,\r\n\t * periodAt will return 0 for all timestamps before startBlockTimestamp.\r\n\t *\r\n\t * Therefore period 0 is the range of time in which we have called start(),\r\n\t * but have not yet passed startBlockTimestamp. Period 1 is the\r\n\t * first monthly period, and so-forth all the way until the last\r\n\t * period == periods.\r\n\t *\r\n\t * NOTE: not guarded since no state modifications are made. However,\r\n\t * it will return invalid data before the postStart state. It is\r\n\t * up to the user to manually check that the contract is in\r\n\t * postStart state.\r\n\t */\r\n\tfunction periodAt(uint _blockTimestamp) constant returns(uint) {\r\n\t\t/**\r\n\t\t * Lower bound, consider period 0 to be the time between\r\n\t\t * start() and startBlockTimestamp\r\n\t\t */\r\n\t\tif (startBlockTimestamp > _blockTimestamp)\r\n\t\t\treturn 0;\r\n\r\n\t\t/**\r\n\t\t * Calculate the appropriate period, and set an upper bound of\r\n\t\t * periods - 1.\r\n\t\t */\r\n\t\tuint p = ((_blockTimestamp - startBlockTimestamp) / intervalSecs) + 1;\r\n\t\tif (p > periods)\r\n\t\t\tp = periods;\r\n\t\treturn p;\r\n\t}\r\n\r\n\t// what withdrawal period are we in?\r\n\t// returns the period number from [0, periods)\r\n\tfunction period() constant returns(uint) {\r\n\t\treturn periodAt(block.timestamp);\r\n\t}\r\n\r\n\t// deposit your tokens to be saved\r\n\t//\r\n\t// the despositor must have approve()'d the tokens\r\n\t// to be transferred by this contract\r\n\tfunction deposit(uint tokens) onlyOwner notNullified {\r\n\t\tdepositTo(msg.sender, tokens);\r\n\t}\r\n\r\n\r\n\tfunction depositTo(address beneficiary, uint tokens) onlyOwner preLock notNullified {\r\n\t\trequire(token.transferFrom(msg.sender, this, tokens));\r\n\t    deposited[beneficiary] += tokens;\r\n\t\ttotalfv += tokens;\r\n\t\tDeposit(beneficiary, tokens);\r\n\t}\r\n\r\n\t// convenience function for owner: deposit on behalf of many\r\n\tfunction bulkDepositTo(uint256[] bits) onlyOwner {\r\n\t\tuint256 lomask = (1 << 96) - 1;\r\n\t\tfor (uint i=0; i<bits.length; i++) {\r\n\t\t\taddress a = address(bits[i]>>96);\r\n\t\t\tuint val = bits[i]&lomask;\r\n\t\t\tdepositTo(a, val);\r\n\t\t}\r\n\t}\r\n\r\n\t// withdraw withdraws tokens to the sender\r\n\t// withdraw can be called at most once per redemption period\r\n\tfunction withdraw() notNullified returns(bool) {\r\n\t\treturn withdrawTo(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the fraction of total (one-off + monthly) withdrawable\r\n\t * given the current timestamp. No guards due to function being constant.\r\n\t * Will output invalid data until the postStart state. It is up to the user\r\n\t * to manually confirm contract is in postStart state.\r\n\t */\r\n\tfunction availableForWithdrawalAt(uint256 blockTimestamp) constant returns (uint256) {\r\n\t\t/**\r\n\t\t * Calculate the total withdrawable, giving a numerator with range:\r\n\t\t * [0.25 * 10 ** 18, 1 * 10 ** 18]\r\n\t\t */\r\n\t\treturn ((t0special + periodAt(blockTimestamp)) * precision) / (t0special + periods);\r\n\t}\r\n\r\n\t/**\r\n\t * Business logic of _withdrawTo, the code is separated this way mainly for\r\n\t * testing. We can inject and test parameters freely without worrying about the\r\n\t * blockchain model.\r\n\t *\r\n\t * NOTE: Since function is constant, no guards are applied. This function will give\r\n\t * invalid outputs unless in postStart state. It is up to user to manually check\r\n\t * that the correct state is given (isStart() == true)\r\n\t */\r\n\tfunction _withdrawTo(uint _deposit, uint _withdrawn, uint _blockTimestamp, uint _total) constant returns (uint) {\r\n\t\tuint256 fraction = availableForWithdrawalAt(_blockTimestamp);\r\n\r\n\t\t/**\r\n\t\t * There are concerns that the multiplication could possibly\r\n\t\t * overflow, however this should not be the case if we calculate\r\n\t\t * the upper bound based on our known parameters:\r\n\t\t *\r\n\t\t * Lets assume the minted token amount to be 500 million (reasonable),\r\n\t\t * given a precision of 8 decimal places, we get:\r\n\t\t * deposited[addr] = 5 * (10 ** 8) * (10 ** 8) = 5 * (10 ** 16)\r\n\t\t *\r\n\t\t * The max for fraction = 10 ** 18, and the max for total is\r\n\t\t * also 5 * (10 ** 16).\r\n\t\t *\r\n\t\t * Therefore:\r\n\t\t * deposited[addr] * fraction * total = 2.5 * (10 ** 51)\r\n\t\t *\r\n\t\t * The maximum for a uint256 is = 1.15 * (10 ** 77)\r\n\t\t */\r\n\t\tuint256 withdrawable = ((_deposit * fraction * _total) / totalfv) / precision;\r\n\r\n\t\t// check that we can withdraw something\r\n\t\tif (withdrawable > _withdrawn) {\r\n\t\t\treturn withdrawable - _withdrawn;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Public facing withdrawTo, injects business logic with\r\n\t * the correct model.\r\n\t */\r\n\tfunction withdrawTo(address addr) postStart notNullified returns (bool) {\r\n\t\tuint _d = deposited[addr];\r\n\t\tuint _w = withdrawn[addr];\r\n\r\n\t\tuint diff = _withdrawTo(_d, _w, block.timestamp, total);\r\n\r\n\t\t// no withdrawal could be made\r\n\t\tif (diff == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// check that we cannot withdraw more than max\r\n\t\trequire((diff + _w) <= ((_d * total) / totalfv));\r\n\r\n\t\t// transfer and increment\r\n\t\trequire(token.transfer(addr, diff));\r\n\r\n\t\twithdrawn[addr] += diff;\r\n\t\tremainder -= diff;\r\n\t\tWithdraws(addr, diff);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// force withdrawal to many addresses\r\n\tfunction bulkWithdraw(address[] addrs) notNullified {\r\n\t\tfor (uint i=0; i<addrs.length; i++)\r\n\t\t\twithdrawTo(addrs[i]);\r\n\t}\r\n\r\n\t// Code off the chain informs this contract about\r\n\t// tokens that were minted to it on behalf of a depositor.\r\n\t//\r\n\t// Note: the function signature here is known to New Alchemy's\r\n\t// tooling, which is why it is arguably misnamed.\r\n\tuint public mintingNonce;\r\n\tfunction multiMint(uint nonce, uint256[] bits) onlyOwner preLock {\r\n\r\n\t\tif (nonce != mintingNonce) return;\r\n\t\tmintingNonce += 1;\r\n\t\tuint256 lomask = (1 << 96) - 1;\r\n\t\tuint sum = 0;\r\n\t\tfor (uint i=0; i<bits.length; i++) {\r\n\t\t\taddress a = address(bits[i]>>96);\r\n\t\t\tuint value = bits[i]&lomask;\r\n\t\t\tdeposited[a] += value;\r\n\t\t\tsum += value;\r\n\t\t\tDeposit(a, value);\r\n\t\t}\r\n\t\ttotalfv += sum;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tok\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"availableForWithdrawalAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"bulkWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inited\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"intervalSecs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"refundTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeInit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"bits\",\"type\":\"uint256[]\"}],\"name\":\"multiMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t0special\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startBlockTimestamp\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_withdrawn\",\"type\":\"uint256\"},{\"name\":\"_blockTimestamp\",\"type\":\"uint256\"},{\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"_withdrawTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periods\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_periods\",\"type\":\"uint256\"},{\"name\":\"_t0special\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlockTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bits\",\"type\":\"uint256[]\"}],\"name\":\"bulkDepositTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateTotal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalfv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"precision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nullify\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nullified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"periodAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"depositTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraws\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"ChangedOwner\",\"type\":\"event\"}]","ContractName":"Savings","CompilerVersion":"v0.4.19-nightly.2017.11.11+commit.284c3839","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://49156e6026fe3d0d48be8c392dd46ac9aba298ffb88e409594fbcc8d8d0d24fe"}]}