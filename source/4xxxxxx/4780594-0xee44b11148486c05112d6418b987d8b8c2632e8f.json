{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract Spineth\r\n{\r\n    /// The states the game will transition through\r\n    enum State\r\n    {\r\n        WaitingForPlayers, // the game has been created by a player and is waiting for an opponent\r\n        WaitingForReveal, // someone has joined and also placed a bet, we are now waiting for the creator to their reveal bet\r\n        Complete // the outcome of the game is determined and players can withdraw their earnings\r\n    }\r\n\r\n    /// All possible event types\r\n    enum Event\r\n    {\r\n        Create,\r\n        Cancel,\r\n        Join,\r\n        Reveal,\r\n        Expire,\r\n        Complete,\r\n        Withdraw,\r\n        StartReveal\r\n    }\r\n    \r\n    // The game state associated with a single game between two players\r\n    struct GameInstance\r\n    {\r\n        // Address for players of this game\r\n        // player1 is always the creator\r\n        address player1;\r\n        address player2;\r\n    \r\n        // How much is being bet this game\r\n        uint betAmountInWei;\r\n    \r\n        // The wheelBet for each player\r\n        // For player1, the bet starts as a hash and is only changed to the real bet once revealed\r\n        uint wheelBetPlayer1;\r\n        uint wheelBetPlayer2;\r\n    \r\n        // The final wheel position after game is complete\r\n        uint wheelResult;\r\n    \r\n        // The time by which the creator of the game must reveal his bet after an opponent joins\r\n        // If the creator does not reveal in time, the opponent can expire the game, causing them to win the maximal amount of their bet\r\n        uint expireTime;\r\n\r\n        // Current state of the game    \r\n        State state;\r\n\r\n        // Tracks whether each player has withdrawn their earnings yet\r\n        bool withdrawnPlayer1;\r\n        bool withdrawnPlayer2;\r\n    }\r\n\r\n    /// How many places there are on the wheel that a bet can be placed\r\n    uint public constant WHEEL_SIZE = 19;\r\n    \r\n    /// What percentage of your opponent's bet a player wins for each place on \r\n    /// the wheel they are closer to the result than their opponent\r\n    /// i.e. If player1 distance from result = 4 and player2 distance from result = 6\r\n    /// then player1 earns (6-4) x WIN_PERCENT_PER_DISTANCE = 20% of player2's bet\r\n    uint public constant WIN_PERCENT_PER_DISTANCE = 10;\r\n\r\n    /// The percentage charged on earnings that are won\r\n    uint public constant FEE_PERCENT = 2;\r\n\r\n    /// The minimum amount that can be bet\r\n    uint public minBetWei = 1 finney;\r\n    \r\n    /// The maximum amount that can be bet\r\n    uint public maxBetWei = 10 ether;\r\n    \r\n    /// The amount of time creators have to reavel their bets before\r\n    /// the game can be expired by an opponent\r\n    uint public maxRevealSeconds = 3600 * 24;\r\n\r\n    /// The account that will receive fees and can configure min/max bet options\r\n    address public authority;\r\n\r\n    /// Counters that tracks how many games have been created by each player\r\n    /// This is used to generate a unique game id per player\r\n    mapping(address => uint) private counterContext;\r\n\r\n    /// Context for all created games\r\n    mapping(uint => GameInstance) public gameContext;\r\n\r\n    /// List of all currently open gameids\r\n    uint[] public openGames;\r\n\r\n    /// Indexes specific to each player\r\n    mapping(address => uint[]) public playerActiveGames;\r\n    mapping(address => uint[]) public playerCompleteGames;    \r\n\r\n    /// Event fired when a game's state changes\r\n    event GameEvent(uint indexed gameId, address indexed player, Event indexed eventType);\r\n\r\n    /// Create the contract and verify constant configurations make sense\r\n    function Spineth() public\r\n    {\r\n        // Make sure that the maximum possible win distance (WHEEL_SIZE / 2)\r\n        // multiplied by the WIN_PERCENT_PER_DISTANCE is less than 100%\r\n        // If it's not, then a maximally won bet can't be paid out\r\n        require((WHEEL_SIZE / 2) * WIN_PERCENT_PER_DISTANCE < 100);\r\n\r\n        authority = msg.sender;\r\n    }\r\n    \r\n    // Change authority\r\n    // Can only be called by authority\r\n    function changeAuthority(address newAuthority) public\r\n    {\r\n        require(msg.sender == authority);\r\n\r\n        authority = newAuthority;\r\n    }\r\n\r\n    // Change min/max bet amounts\r\n    // Can only be called by authority\r\n    function changeBetLimits(uint minBet, uint maxBet) public\r\n    {\r\n        require(msg.sender == authority);\r\n        require(maxBet >= minBet);\r\n\r\n        minBetWei = minBet;\r\n        maxBetWei = maxBet;\r\n    }\r\n    \r\n    // Internal helper function to add elements to an array\r\n    function arrayAdd(uint[] storage array, uint element) private\r\n    {\r\n        array.push(element);\r\n    }\r\n\r\n    // Internal helper function to remove element from an array\r\n    function arrayRemove(uint[] storage array, uint element) private\r\n    {\r\n        for(uint i = 0; i < array.length; ++i)\r\n        {\r\n            if(array[i] == element)\r\n            {\r\n                array[i] = array[array.length - 1];\r\n                delete array[array.length - 1];\r\n                --array.length;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Get next game id to be associated with a player address\r\n    function getNextGameId(address player) public view\r\n        returns (uint)\r\n    {\r\n        uint counter = counterContext[player];\r\n\r\n        // Addresses are 160 bits so we can safely shift them up by (256 - 160 = 96 bits)\r\n        // to make room for the counter in the bottom 96 bits\r\n        // This means a single player cannot theoretically create more than 2^96 games\r\n        // which should more than enough for the lifetime of any player.\r\n        uint result = (uint(player) << 96) + counter;\r\n\r\n        // Check that we didn't overflow the counter (this will never happen)\r\n        require((result >> 96) == uint(player));\r\n\r\n        return result;\r\n    }\r\n\r\n    /// Used to calculate the bet hash given a wheel bet and a player secret.\r\n    /// Used by a game creator to calculate their bet bash off chain first.\r\n    /// When bet is revealed, contract will use this function to verify the revealed bet is valid\r\n    function createWheelBetHash(uint gameId, uint wheelBet, uint playerSecret) public pure\r\n        returns (uint)\r\n    {\r\n        require(wheelBet < WHEEL_SIZE);\r\n        return uint(keccak256(gameId, wheelBet, playerSecret));\r\n    }\r\n    \r\n    /// Create and initialize a game instance with the sent bet amount.\r\n    /// The creator will automatically become a participant of the game.\r\n    /// gameId must be the return value of getNextGameId(...) for the sender\r\n    /// wheelPositionHash should be calculated using createWheelBetHash(...)\r\n    function createGame(uint gameId, uint wheelPositionHash) public payable\r\n    {\r\n        // Make sure the player passed the correct value for the game id\r\n        require(getNextGameId(msg.sender) == gameId);\r\n\r\n        // Get the game instance and ensure that it doesn't already exist\r\n        GameInstance storage game = gameContext[gameId];\r\n        require(game.betAmountInWei == 0); \r\n        \r\n        // Must provide non-zero bet\r\n        require(msg.value > 0);\r\n        \r\n        // Restrict betting amount\r\n        // NOTE: Game creation can be disabled by setting min/max bet to 0\r\n        require(msg.value >= minBetWei && msg.value <= maxBetWei);\r\n\r\n        // Increment the create game counter for this player\r\n        counterContext[msg.sender] = counterContext[msg.sender] + 1;\r\n\r\n        // Update game state\r\n        // The creator becomes player1\r\n        game.state = State.WaitingForPlayers;\r\n        game.betAmountInWei = msg.value;\r\n        game.player1 = msg.sender;\r\n        game.wheelBetPlayer1 = wheelPositionHash;\r\n        \r\n        // This game is now open to others and active for the player\r\n        arrayAdd(openGames, gameId);\r\n        arrayAdd(playerActiveGames[msg.sender], gameId);\r\n\r\n        // Fire event for the creation of this game\r\n        GameEvent(gameId, msg.sender, Event.Create);\r\n    }\r\n    \r\n    /// Cancel a game that was created but never had another player join\r\n    /// A creator can use this function if they have been waiting too long for another\r\n    /// player and want to get their bet funds back. NOTE. Once someone joins\r\n    /// the game can no longer be cancelled.\r\n    function cancelGame(uint gameId) public\r\n    {\r\n        // Get the game instance and check that it exists\r\n        GameInstance storage game = gameContext[gameId];\r\n        require(game.betAmountInWei > 0); \r\n\r\n        // Can only cancel if we are still waiting for other participants\r\n        require(game.state == State.WaitingForPlayers);\r\n        \r\n        // Is the sender the creator?\r\n        require(game.player1 == msg.sender);\r\n\r\n        // Update game state\r\n        // Mark earnings as already withdrawn since we are returning the bet amount\r\n        game.state = State.Complete;\r\n        game.withdrawnPlayer1 = true;\r\n\r\n        // This game is no longer open and no longer active for the player\r\n        arrayRemove(openGames, gameId);\r\n        arrayRemove(playerActiveGames[msg.sender], gameId);\r\n\r\n        // Fire event for player canceling this game\r\n        GameEvent(gameId, msg.sender, Event.Cancel);\r\n\r\n        // Transfer the player's bet amount back to them\r\n        msg.sender.transfer(game.betAmountInWei);\r\n    }\r\n\r\n    /// Join an open game instance\r\n    /// Sender must provide an amount of wei equal to betAmountInWei\r\n    /// After the second player has joined, the creator will have maxRevealSeconds to reveal their bet\r\n    function joinGame(uint gameId, uint wheelBet) public payable\r\n    {\r\n        // Get the game instance and check that it exists\r\n        GameInstance storage game = gameContext[gameId];\r\n        require(game.betAmountInWei > 0); \r\n        \r\n        // Only allowed to participate while we are waiting for players\r\n        require(game.state == State.WaitingForPlayers);\r\n        \r\n        // Can't join a game that you created\r\n        require(game.player1 != msg.sender);\r\n        \r\n        // Is there space available?\r\n        require(game.player2 == 0);\r\n\r\n        // Must pay the amount of the bet to play\r\n        require(msg.value == game.betAmountInWei);\r\n\r\n        // Make sure the wheelBet makes sense\r\n        require(wheelBet < WHEEL_SIZE);\r\n\r\n        // Update game state\r\n        // The sender becomes player2\r\n        game.state = State.WaitingForReveal;\r\n        game.player2 = msg.sender;\r\n        game.wheelBetPlayer2 = wheelBet;\r\n        game.expireTime = now + maxRevealSeconds; // After expireTime the game can be expired\r\n\r\n        // This game is no longer open, and is now active for the joiner\r\n        arrayRemove(openGames, gameId);\r\n        arrayAdd(playerActiveGames[msg.sender], gameId);\r\n\r\n        // Fire event for player joining this game\r\n        GameEvent(gameId, msg.sender, Event.Join);\r\n\r\n        // Fire event for creator, letting them know they need to reveal their bet now\r\n        GameEvent(gameId, game.player1, Event.StartReveal);\r\n    }\r\n    \r\n    /// This can be called by the joining player to force the game to end once the expire\r\n    /// time has been reached. This is a safety measure to ensure the game can be completed\r\n    /// in case where the creator decides to not to reveal their bet. In this case, the creator\r\n    /// will lose the maximal amount of their bet\r\n    function expireGame(uint gameId) public\r\n    {\r\n        // Get the game instance and check that it exists\r\n        GameInstance storage game = gameContext[gameId];\r\n        require(game.betAmountInWei > 0); \r\n\r\n        // Only expire from the WaitingForReveal state\r\n        require(game.state == State.WaitingForReveal);\r\n        \r\n        // Has enough time passed to perform this action?\r\n        require(now > game.expireTime);\r\n        \r\n        // Can only expire the game if you are the second player\r\n        require(msg.sender == game.player2);\r\n\r\n        // Player1 (creator) did not reveal bet in time\r\n        // Complete the game in favor of player2\r\n        game.wheelResult = game.wheelBetPlayer2;\r\n        game.wheelBetPlayer1 = (game.wheelBetPlayer2 + (WHEEL_SIZE / 2)) % WHEEL_SIZE;\r\n        \r\n        // This game is complete, the withdrawEarnings flow can now be invoked\r\n        game.state = State.Complete;\r\n\r\n        // Fire an event for the player forcing this game to end\r\n        GameEvent(gameId, game.player1, Event.Expire);\r\n        GameEvent(gameId, game.player2, Event.Expire);\r\n    }\r\n    \r\n    /// Once a player has joined the game, the creator must reveal their bet\r\n    /// by providing the same playerSecret that was passed to createGame(...)\r\n    function revealBet(uint gameId, uint playerSecret) public\r\n    {\r\n        // Get the game instance and check that it exists\r\n        GameInstance storage game = gameContext[gameId];\r\n        require(game.betAmountInWei > 0); \r\n\r\n        // We can only reveal bets during the revealing bets state\r\n        require(game.state == State.WaitingForReveal);\r\n\r\n        // Only the creator does this\r\n        require(game.player1 == msg.sender);\r\n\r\n        uint i; // Loop counter used below\r\n\r\n        // Find the wheelBet the player made by enumerating the hash\r\n        // possibilities. It is done this way so the player only has to\r\n        // remember their secret in order to revel the bet\r\n        for(i = 0; i < WHEEL_SIZE; ++i)\r\n        {\r\n            // Find the bet that was provided in createGame(...)\r\n            if(createWheelBetHash(gameId, i, playerSecret) == game.wheelBetPlayer1)\r\n            {\r\n                // Update the bet to the revealed value\r\n                game.wheelBetPlayer1 = i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Make sure we successfully revealed the bet, otherwise\r\n        // the playerSecret was invalid\r\n        require(i < WHEEL_SIZE);\r\n        \r\n        // Fire an event for the revealing of the bet\r\n        GameEvent(gameId, msg.sender, Event.Reveal);\r\n\r\n        // Use the revealed bets to calculate the wheelResult\r\n        // NOTE: Neither player knew the unrevealed state of both bets when making their\r\n        // bet, so the combination can be used to generate a random number neither player could anticipate.\r\n        // This algorithm was tested for good outcome distribution for arbitrary hash values\r\n        uint256 hashResult = uint256(keccak256(gameId, now, game.wheelBetPlayer1, game.wheelBetPlayer2));\r\n        uint32 randomSeed = uint32(hashResult >> 0)\r\n                          ^ uint32(hashResult >> 32)\r\n                          ^ uint32(hashResult >> 64)\r\n                          ^ uint32(hashResult >> 96)\r\n                          ^ uint32(hashResult >> 128)\r\n                          ^ uint32(hashResult >> 160)\r\n                          ^ uint32(hashResult >> 192)\r\n                          ^ uint32(hashResult >> 224);\r\n\r\n        uint32 randomNumber = randomSeed;\r\n        uint32 randMax = 0xFFFFFFFF; // We use the whole 32 bit range\r\n\r\n        // Generate random numbers until we get a value in the unbiased range (see below)\r\n        do\r\n        {\r\n            randomNumber ^= (randomNumber >> 11);\r\n            randomNumber ^= (randomNumber << 7) & 0x9D2C5680;\r\n            randomNumber ^= (randomNumber << 15) & 0xEFC60000;\r\n            randomNumber ^= (randomNumber >> 18);\r\n        }\r\n        // Since WHEEL_SIZE is not divisible by randMax, using modulo below will introduce bias for\r\n        // numbers at the end of the randMax range. To remedy this, we discard these out of range numbers\r\n        // and generate additional numbers until we are in the largest range divisble by WHEEL_SIZE.\r\n        // This range will ensure we do not introduce any modulo bias\r\n        while(randomNumber >= (randMax - (randMax % WHEEL_SIZE)));\r\n\r\n        // Update game state        \r\n        game.wheelResult = randomNumber % WHEEL_SIZE;\r\n        game.state = State.Complete;\r\n        \r\n        // Fire an event for the completion of the game\r\n        GameEvent(gameId, game.player1, Event.Complete);\r\n        GameEvent(gameId, game.player2, Event.Complete);\r\n    }\r\n\r\n    /// A utility function to get the minimum distance between two selections\r\n    /// on a wheel of WHEEL_SIZE wrapping around at 0\r\n    function getWheelDistance(uint value1, uint value2) private pure\r\n        returns (uint)\r\n    {\r\n        // Make sure the values are within range\r\n        require(value1 < WHEEL_SIZE && value2 < WHEEL_SIZE);\r\n\r\n        // Calculate the distance of value1 with respect to value2\r\n        uint dist1 = (WHEEL_SIZE + value1 - value2) % WHEEL_SIZE;\r\n        \r\n        // Calculate the distance going the other way around the wheel\r\n        uint dist2 = WHEEL_SIZE - dist1;\r\n\r\n        // Whichever distance is shorter is the wheel distance\r\n        return (dist1 < dist2) ? dist1 : dist2;\r\n    }\r\n\r\n    /// Once the game is complete, use this function to get the results of\r\n    /// the game. Returns:\r\n    /// - the amount of wei charged for the fee\r\n    /// - the amount of wei to be paid out to player1\r\n    /// - the amount of wei to be paid out to player2\r\n    /// The sum of all the return values is exactly equal to the contributions\r\n    /// of both player bets. i.e. \r\n    ///     feeWei + weiPlayer1 + weiPlayer2 = 2 * betAmountInWei\r\n    function calculateEarnings(uint gameId) public view\r\n        returns (uint feeWei, uint weiPlayer1, uint weiPlayer2)\r\n    {\r\n        // Get the game instance and check that it exists\r\n        GameInstance storage game = gameContext[gameId];\r\n        require(game.betAmountInWei > 0); \r\n\r\n        // It doesn't make sense to call this function when the game isn't complete\r\n        require(game.state == State.Complete);\r\n        \r\n        uint distancePlayer1 = getWheelDistance(game.wheelBetPlayer1, game.wheelResult);\r\n        uint distancePlayer2 = getWheelDistance(game.wheelBetPlayer2, game.wheelResult);\r\n\r\n        // Outcome if there is a tie\r\n        feeWei = 0;\r\n        weiPlayer1 = game.betAmountInWei;\r\n        weiPlayer2 = game.betAmountInWei;\r\n\r\n        uint winDist = 0;\r\n        uint winWei = 0;\r\n        \r\n        // Player one was closer, so they won\r\n        if(distancePlayer1 < distancePlayer2)\r\n        {\r\n            winDist = distancePlayer2 - distancePlayer1;\r\n            winWei = game.betAmountInWei * (winDist * WIN_PERCENT_PER_DISTANCE) / 100;\r\n\r\n            feeWei = winWei * FEE_PERCENT / 100;\r\n            weiPlayer1 += winWei - feeWei;\r\n            weiPlayer2 -= winWei;\r\n        }\r\n        // Player two was closer, so they won\r\n        else if(distancePlayer2 < distancePlayer1)\r\n        {\r\n            winDist = distancePlayer1 - distancePlayer2;\r\n            winWei = game.betAmountInWei * (winDist * WIN_PERCENT_PER_DISTANCE) / 100;\r\n\r\n            feeWei = winWei * FEE_PERCENT / 100;\r\n            weiPlayer2 += winWei - feeWei;\r\n            weiPlayer1 -= winWei;\r\n        }\r\n        // Same distance, so it was a tie (see above)\r\n    }\r\n    \r\n    /// Once the game is complete, each player can withdraw their earnings\r\n    /// A fee is charged on winnings only and provided to the contract authority\r\n    function withdrawEarnings(uint gameId) public\r\n    {\r\n        // Get the game instance and check that it exists\r\n        GameInstance storage game = gameContext[gameId];\r\n        require(game.betAmountInWei > 0); \r\n\r\n        require(game.state == State.Complete);\r\n        \r\n        var (feeWei, weiPlayer1, weiPlayer2) = calculateEarnings(gameId);\r\n\r\n        bool payFee = false;\r\n        uint withdrawAmount = 0;\r\n\r\n        if(game.player1 == msg.sender)\r\n        {\r\n            // Can't have already withrawn\r\n            require(game.withdrawnPlayer1 == false);\r\n            \r\n            game.withdrawnPlayer1 = true; // They can't withdraw again\r\n            \r\n            // If player1 was the winner, they will pay the fee\r\n            if(weiPlayer1 > weiPlayer2)\r\n            {\r\n                payFee = true;\r\n            }\r\n            \r\n            withdrawAmount = weiPlayer1;\r\n        }\r\n        else if(game.player2 == msg.sender)\r\n        {\r\n            // Can't have already withrawn\r\n            require(game.withdrawnPlayer2 == false);\r\n            \r\n            game.withdrawnPlayer2 = true;\r\n\r\n            // If player2 was the winner, they will pay the fee\r\n            if(weiPlayer2 > weiPlayer1)\r\n            {\r\n                payFee = true;\r\n            }\r\n            \r\n            withdrawAmount = weiPlayer2;\r\n        }\r\n        else\r\n        {\r\n            // The sender isn't a participant\r\n            revert();\r\n        }\r\n\r\n        // This game is no longer active for this player, and now moved to complete for this player\r\n        arrayRemove(playerActiveGames[msg.sender], gameId);\r\n        arrayAdd(playerCompleteGames[msg.sender], gameId);\r\n\r\n        // Fire an event for the withdrawing of funds\r\n        GameEvent(gameId, msg.sender, Event.Withdraw);\r\n\r\n        // Pay the fee, if necessary\r\n        if(payFee == true)\r\n        {\r\n            authority.transfer(feeWei);\r\n        }\r\n    \r\n        // Transfer sender their outcome\r\n        msg.sender.transfer(withdrawAmount);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"changeAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBetWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WHEEL_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"calculateEarnings\",\"outputs\":[{\"name\":\"feeWei\",\"type\":\"uint256\"},{\"name\":\"weiPlayer1\",\"type\":\"uint256\"},{\"name\":\"weiPlayer2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameContext\",\"outputs\":[{\"name\":\"player1\",\"type\":\"address\"},{\"name\":\"player2\",\"type\":\"address\"},{\"name\":\"betAmountInWei\",\"type\":\"uint256\"},{\"name\":\"wheelBetPlayer1\",\"type\":\"uint256\"},{\"name\":\"wheelBetPlayer2\",\"type\":\"uint256\"},{\"name\":\"wheelResult\",\"type\":\"uint256\"},{\"name\":\"expireTime\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"withdrawnPlayer1\",\"type\":\"bool\"},{\"name\":\"withdrawnPlayer2\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRevealSeconds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minBet\",\"type\":\"uint256\"},{\"name\":\"maxBet\",\"type\":\"uint256\"}],\"name\":\"changeBetLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getNextGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"wheelPositionHash\",\"type\":\"uint256\"}],\"name\":\"createGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"expireGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"cancelGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"withdrawEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WIN_PERCENT_PER_DISTANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerCompleteGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"playerSecret\",\"type\":\"uint256\"}],\"name\":\"revealBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"wheelBet\",\"type\":\"uint256\"}],\"name\":\"joinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerActiveGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"wheelBet\",\"type\":\"uint256\"},{\"name\":\"playerSecret\",\"type\":\"uint256\"}],\"name\":\"createWheelBetHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"openGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBetWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"eventType\",\"type\":\"uint8\"}],\"name\":\"GameEvent\",\"type\":\"event\"}]","ContractName":"Spineth","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ade44effe03dd9be4665049aae02b3ea4c3fdc19f6ffa807177da58af4740011"}]}