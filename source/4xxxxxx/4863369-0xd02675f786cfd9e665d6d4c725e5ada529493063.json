{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\nlibrary DateTimeLib {\r\n    /*\r\n     *  Date and Time utilities for ethereum contracts\r\n     *\r\n     */\r\n    struct _DateTime {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        uint8 weekday;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint constant HOUR_IN_SECONDS = 3600;\r\n    uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) public pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function leapYearsBefore(uint year) public pure returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            return 31;\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n            return 30;\r\n        }\r\n        else if (isLeapYear(year)) {\r\n            return 29;\r\n        }\r\n        else {\r\n            return 28;\r\n        }\r\n    }\r\n\r\n    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        // Year\r\n        dt.year = getYear(timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n        // Month\r\n        uint secondsInMonth;\r\n        for (i = 1; i <= 12; i++) {\r\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                dt.month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        // Day\r\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                dt.day = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n\r\n        // Hour\r\n        dt.hour = getHour(timestamp);\r\n\r\n        // Minute\r\n        dt.minute = getMinute(timestamp);\r\n\r\n        // Second\r\n        dt.second = getSecond(timestamp);\r\n\r\n        // Day of week.\r\n        dt.weekday = getWeekday(timestamp);\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint16) {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n        while (secondsAccountedFor > timestamp) {\r\n            if (isLeapYear(uint16(year - 1))) {\r\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n            }\r\n            year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function getMonth(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n\r\n    function getDay(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n\r\n    function getHour(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60 / 60) % 24);\r\n    }\r\n\r\n    function getMinute(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / 60) % 60);\r\n    }\r\n\r\n    function getSecond(uint timestamp) public pure returns (uint8) {\r\n        return uint8(timestamp % 60);\r\n    }\r\n\r\n    function getWeekday(uint timestamp) public pure returns (uint8) {\r\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, 0, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, 0, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n        return toTimestamp(year, month, day, hour, minute, 0);\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i < year; i++) {\r\n            if (isLeapYear(i)) {\r\n                timestamp += LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                timestamp += YEAR_IN_SECONDS;\r\n            }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n            monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < month; i++) {\r\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n\r\n        // Day\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n        // Hour\r\n        timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n        // Minute\r\n        timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n        // Second\r\n        timestamp += second;\r\n\r\n        return timestamp;\r\n    }\r\n}\r\n\r\nlibrary SafeMathLib {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    //function totalSupply() public constant returns (uint256 totalSupply);\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address _spender, uint256 _value);\r\n}\r\n\r\ncontract StandardToken is IERC20 {\r\n\r\n    using SafeMathLib for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    function StandardToken() public payable {\r\n\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        return transferInternal(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n        require(_value > 0 && balances[_from] >= _value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value > 0 && allowed[_from][msg.sender] >= _value && balances[_from] >= _value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address _spender, uint256 _value);\r\n}\r\n\r\ncontract LockableToken is StandardToken {\r\n\r\n    mapping(address => uint256) internal lockedBalance;\r\n\r\n    mapping(address => uint) internal timeRelease;\r\n\r\n    address internal teamReservedHolder;\r\n\r\n    uint256 internal teamReservedBalance;\r\n\r\n    uint [8] internal teamReservedFrozenDates;\r\n\r\n    uint256 [8] internal teamReservedFrozenLimits;\r\n\r\n    function LockableToken() public payable {\r\n\r\n    }\r\n\r\n    function lockInfo(address _address) public constant returns (uint timeLimit, uint256 balanceLimit) {\r\n        return (timeRelease[_address], lockedBalance[_address]);\r\n    }\r\n\r\n    function teamReservedLimit() internal returns (uint256 balanceLimit) {\r\n        uint time = now;\r\n        for (uint index = 0; index < teamReservedFrozenDates.length; index++) {\r\n            if (teamReservedFrozenDates[index] == 0x0) {\r\n                continue;\r\n            }\r\n            if (time > teamReservedFrozenDates[index]) {\r\n                teamReservedFrozenDates[index] = 0x0;\r\n            } else {\r\n                return teamReservedFrozenLimits[index];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        return transferInternal(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n        require(_to != 0x0 && _value > 0x0);\r\n        if (_from == teamReservedHolder) {\r\n            uint256 reservedLimit = teamReservedLimit();\r\n            require(balances[_from].sub(reservedLimit) >= _value);\r\n        }\r\n        var (timeLimit, lockLimit) = lockInfo(_from);\r\n        if (timeLimit <= now && timeLimit != 0x0) {\r\n            timeLimit = 0x0;\r\n            timeRelease[_from] = 0x0;\r\n            lockedBalance[_from] = 0x0;\r\n            UnLock(_from, lockLimit);\r\n            lockLimit = 0x0;\r\n        }\r\n        if (timeLimit != 0x0 && lockLimit > 0x0) {\r\n            require(balances[_from].sub(lockLimit) >= _value);\r\n        }\r\n        return super.transferInternal(_from, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        return transferFromInternal(_from, _to, _value);\r\n    }\r\n\r\n    function transferFromInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n        require(_to != 0x0 && _value > 0x0);\r\n        if (_from == teamReservedHolder) {\r\n            uint256 reservedLimit = teamReservedLimit();\r\n            require(balances[_from].sub(reservedLimit) >= _value);\r\n        }\r\n        var (timeLimit, lockLimit) = lockInfo(_from);\r\n        if (timeLimit <= now && timeLimit != 0x0) {\r\n            timeLimit = 0x0;\r\n            timeRelease[_from] = 0x0;\r\n            lockedBalance[_from] = 0x0;\r\n            UnLock(_from, lockLimit);\r\n            lockLimit = 0x0;\r\n        }\r\n        if (timeLimit != 0x0 && lockLimit > 0x0) {\r\n            require(balances[_from].sub(lockLimit) >= _value);\r\n        }\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    event Lock(address indexed owner, uint256 value, uint releaseTime);\r\n    event UnLock(address indexed owner, uint256 value);\r\n}\r\n\r\ncontract TradeableToken is LockableToken {\r\n\r\n    address public publicOfferingHolder;\r\n\r\n    uint256 internal baseExchangeRate;\r\n\r\n    uint256 internal earlyExchangeRate;\r\n\r\n    uint internal earlyEndTime;\r\n\r\n    function TradeableToken() public payable {\r\n\r\n    }\r\n\r\n    function buy(address _beneficiary, uint256 _weiAmount) internal {\r\n        require(_beneficiary != 0x0);\r\n        require(publicOfferingHolder != 0x0);\r\n        require(earlyEndTime != 0x0 && baseExchangeRate != 0x0 && earlyExchangeRate != 0x0);\r\n        require(_weiAmount != 0x0);\r\n\r\n        uint256 rate = baseExchangeRate;\r\n        if (now <= earlyEndTime) {\r\n            rate = earlyExchangeRate;\r\n        }\r\n        uint256 exchangeToken = _weiAmount.mul(rate);\r\n        exchangeToken = exchangeToken.div(1 * 10 ** 10);\r\n\r\n        publicOfferingHolder.transfer(_weiAmount);\r\n        super.transferInternal(publicOfferingHolder, _beneficiary, exchangeToken);\r\n    }\r\n}\r\n\r\ncontract OwnableToken is TradeableToken {\r\n\r\n    address internal owner;\r\n\r\n    uint internal _totalSupply = 1500000000 * 10 ** 8;\r\n\r\n    function OwnableToken() public payable {\r\n\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) onlyOwner public {\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n        OwnershipTransferred(owner, _newOwner);\r\n    }\r\n\r\n    function lock(address _owner, uint256 _value, uint _releaseTime) public payable onlyOwner returns (uint releaseTime, uint256 limit) {\r\n        require(_owner != 0x0 && _value > 0x0 && _releaseTime >= now);\r\n        _value = lockedBalance[_owner].add(_value);\r\n        _releaseTime = _releaseTime >= timeRelease[_owner] ? _releaseTime : timeRelease[_owner];\r\n        lockedBalance[_owner] = _value;\r\n        timeRelease[_owner] = _releaseTime;\r\n        Lock(_owner, _value, _releaseTime);\r\n        return (_releaseTime, _value);\r\n    }\r\n\r\n    function unlock(address _owner) public payable onlyOwner returns (bool) {\r\n        require(_owner != 0x0);\r\n        uint256 _value = lockedBalance[_owner];\r\n        lockedBalance[_owner] = 0x0;\r\n        timeRelease[_owner] = 0x0;\r\n        UnLock(_owner, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferAndLock(address _to, uint256 _value, uint _releaseTime) public payable onlyOwner returns (bool success) {\r\n        require(_to != 0x0);\r\n        require(_value > 0);\r\n        require(_releaseTime >= now);\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        super.transfer(_to, _value);\r\n        lock(_to, _value, _releaseTime);\r\n        return true;\r\n    }\r\n\r\n    function setBaseExchangeRate(uint256 _baseExchangeRate) public payable onlyOwner returns (bool success) {\r\n        require(_baseExchangeRate > 0x0);\r\n        baseExchangeRate = _baseExchangeRate;\r\n        BaseExchangeRateChanged(baseExchangeRate);\r\n        return true;\r\n    }\r\n\r\n    function setEarlyExchangeRate(uint256 _earlyExchangeRate) public payable onlyOwner returns (bool success) {\r\n        require(_earlyExchangeRate > 0x0);\r\n        earlyExchangeRate = _earlyExchangeRate;\r\n        EarlyExchangeRateChanged(earlyExchangeRate);\r\n        return true;\r\n    }\r\n\r\n    function setEarlyEndTime(uint256 _earlyEndTime) public payable onlyOwner returns (bool success) {\r\n        require(_earlyEndTime > 0x0);\r\n        earlyEndTime = _earlyEndTime;\r\n        EarlyEndTimeChanged(earlyEndTime);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 _value) public payable onlyOwner returns (bool success) {\r\n        require(_value > 0x0);\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        Burned(_value);\r\n        return true;\r\n    }\r\n\r\n    function setPublicOfferingHolder(address _publicOfferingHolder) public payable onlyOwner returns (bool success) {\r\n        require(_publicOfferingHolder != 0x0);\r\n        publicOfferingHolder = _publicOfferingHolder;\r\n        return true;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event BaseExchangeRateChanged(uint256 baseExchangeRate);\r\n    event EarlyExchangeRateChanged(uint256 earlyExchangeRate);\r\n    event EarlyEndTimeChanged(uint256 earlyEndTime);\r\n    event Burned(uint256 value);\r\n}\r\n\r\ncontract TenYunToken is OwnableToken {\r\n\r\n    string public constant symbol = \"TYC\";\r\n\r\n    string public constant name = \"TenYun Coin\";\r\n\r\n    uint8 public constant decimals = 8;\r\n\r\n    function TenYunToken() public payable {\r\n        owner = 0x593841e27b7122ef48F7854c7E7E1d5A374f8BB3;\r\n        balances[owner] = 1500000000 * 10 ** 8;\r\n\r\n        publicOfferingHolder = 0x0B83ED7C57c335dCA9C978f78819A739AC67fD5D;\r\n        balances[publicOfferingHolder] = 0x0;\r\n        baseExchangeRate = 8500;\r\n        earlyExchangeRate = 9445;\r\n        earlyEndTime = 1516291200;\r\n\r\n        teamReservedHolder = 0x6e4890764AA2Bba346459e2D6b811e26C9691704;\r\n        teamReservedBalance = 300000000 * 10 ** 8;\r\n        balances[teamReservedHolder] = 0x0;\r\n        teamReservedFrozenDates =\r\n        [\r\n        DateTimeLib.toTimestamp(2018, 4, 25),\r\n        DateTimeLib.toTimestamp(2018, 7, 25),\r\n        DateTimeLib.toTimestamp(2018, 10, 25),\r\n        DateTimeLib.toTimestamp(2019, 1, 25),\r\n        DateTimeLib.toTimestamp(2019, 4, 25),\r\n        DateTimeLib.toTimestamp(2019, 7, 25),\r\n        DateTimeLib.toTimestamp(2019, 10, 25),\r\n        DateTimeLib.toTimestamp(2020, 1, 25)\r\n        ];\r\n        teamReservedFrozenLimits =\r\n        [\r\n        teamReservedBalance,\r\n        teamReservedBalance - (teamReservedBalance / 8) * 1,\r\n        teamReservedBalance - (teamReservedBalance / 8) * 2,\r\n        teamReservedBalance - (teamReservedBalance / 8) * 3,\r\n        teamReservedBalance - (teamReservedBalance / 8) * 4,\r\n        teamReservedBalance - (teamReservedBalance / 8) * 5,\r\n        teamReservedBalance - (teamReservedBalance / 8) * 6,\r\n        teamReservedBalance - (teamReservedBalance / 8) * 7\r\n        ];\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function() public payable {\r\n        buy(msg.sender, msg.value);\r\n    }\r\n\r\n    function ethBalanceOf(address _owner) public constant returns (uint256){\r\n        return _owner.balance;\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint256 totalSupply) {\r\n        return _totalSupply;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"unlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_earlyEndTime\",\"type\":\"uint256\"}],\"name\":\"setEarlyEndTime\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseExchangeRate\",\"type\":\"uint256\"}],\"name\":\"setBaseExchangeRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"lockInfo\",\"outputs\":[{\"name\":\"timeLimit\",\"type\":\"uint256\"},{\"name\":\"balanceLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ethBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_releaseTime\",\"type\":\"uint256\"}],\"name\":\"transferAndLock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_earlyExchangeRate\",\"type\":\"uint256\"}],\"name\":\"setEarlyExchangeRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_releaseTime\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[{\"name\":\"releaseTime\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicOfferingHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_publicOfferingHolder\",\"type\":\"address\"}],\"name\":\"setPublicOfferingHolder\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"baseExchangeRate\",\"type\":\"uint256\"}],\"name\":\"BaseExchangeRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"earlyExchangeRate\",\"type\":\"uint256\"}],\"name\":\"EarlyExchangeRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"earlyEndTime\",\"type\":\"uint256\"}],\"name\":\"EarlyEndTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"releaseTime\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"UnLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"TenYunToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"DateTimeLib:C99AF939c2E21D26E8D534a150E70178ed2573dD","SwarmSource":"bzzr://711015e5ca23ae87be5cc05dcf8d535d3f6eaa3ca3808c73cfe59b9f92126d2f"}]}