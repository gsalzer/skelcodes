{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\ncontract Base {\r\n  function isContract(address _addr) constant internal returns(bool) {\r\n    uint size;\r\n    if (_addr == 0) return false;\r\n    assembly {\r\n        size := extcodesize(_addr)\r\n    }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n//TODO change to interface if that ever gets added to the parser\r\ncontract RngRequester {\r\n  function acceptRandom(bytes32 id, bytes result);\r\n}\r\n\r\n//TODO change to interface if that ever gets added to the parser\r\ncontract CryptoLuckRng {\r\n  function requestRandom(uint8 numberOfBytes) payable returns(bytes32);\r\n\r\n  function getFee() returns(uint256);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract StateQuickEth is Ownable {\r\n  //Certain parameters of the game can only be changed if the game is stopped.\r\n  //Rules shouldn't be changed while the game is going on :)\r\n  //\r\n  //This way, the owner can't e.g. lock up contributed funds or such, \r\n  //by updating the game params to bad values, like minimum 1 million participants, etc.\r\n  modifier gameStopped {\r\n    require(!gameRunning);\r\n    \r\n    _;\r\n  }\r\n\r\n  uint16 internal constant MANUAL_WITHDRAW_INTERVAL = 1 hours;\r\n  \r\n  bool public gameRunning;\r\n  \r\n  //Instead of being able to stop the game outright, the owner can only \"schedule\"\r\n  //for the game to stop at the end of the current round.\r\n  //Game stays locked until explicitly restarted.\r\n  bool public stopGameOnNextRound;\r\n\r\n  //When someone sends ETH to the contract, what's the minimum gas the tx should have,\r\n  //so that it can execute the draw. \r\n  uint32 public minGasForDrawing = 350000;\r\n  \r\n  //Ideally, we dont want the execution of a lottery to last too long, \r\n  //so require a decent gas price when drawing. 6 GWEI\r\n  uint256 public minGasPriceForDrawing = 6000000000;\r\n\r\n  //This reward should cover the gas cost for drawing.\r\n  //At the end of each lottery, the drawer will be refunded this amount \r\n  //(0.002 eth to start with) - about 350k gas at 6 gwei price.\r\n  uint256 public rewardForDrawing = 2 finney;\r\n\r\n  //House takes a 1% fee (10/1000). Can be updated when game is stopped.\r\n  //Value is divided by 1000 instead of 100, to be able to use fractional percentages e.g., 1.5%\r\n  uint8 public houseFee = 10;\r\n\r\n  //Min and max contribution of this lottery.   \r\n  uint256 public minContribution = 20 finney;\r\n  uint256 public maxContribution = 1 ether;\r\n  \r\n  //Max bonus tickets for drawer.\r\n  uint256 public maxBonusTickets = 5;\r\n  \r\n  //Percentage of tickets purchased, awarded as bonus to the drawer.\r\n  uint8 public bonusTicketsPercentage = 1;\r\n  \r\n  //Minimum entries required to allow a draw to happen\r\n  uint16 public requiredEntries = 5;\r\n  \r\n  //Allow at least 60 minutes between draws, to have a minimally decent prize pool.\r\n  uint256 public requiredTimeBetweenDraws = 60 minutes;\r\n\r\n  address public rngAddress;\r\n  ////////////////////////////////////////////////////////\r\n  //Owner methods\r\n\r\n  //Game rules - can only be changed if the game is stopped.\r\n  function updateHouseFee(uint8 _value) public onlyOwner gameStopped {\r\n    houseFee = _value;\r\n  }\r\n\r\n  function updateMinContribution(uint256 _value) public onlyOwner gameStopped {\r\n    minContribution = _value;\r\n  }\r\n\r\n  function updateMaxContribution(uint256 _value) public onlyOwner gameStopped {\r\n    maxContribution = _value;\r\n  }\r\n\r\n  function updateRequiredEntries(uint16 _value) public onlyOwner gameStopped {\r\n    requiredEntries = _value;\r\n  }\r\n\r\n  function updateRequiredTimeBetweenDraws(uint256 _value) public onlyOwner gameStopped {\r\n    requiredTimeBetweenDraws = _value;\r\n  }\r\n  //END of Game rules\r\n  /////\r\n\r\n  //Logistics\r\n  function updateMaxBonusTickets(uint256 _value) public onlyOwner {\r\n    maxBonusTickets = _value;\r\n  }\r\n\r\n  function updateBonusTicketsPercentage(uint8 _value) public onlyOwner {\r\n    bonusTicketsPercentage = _value;\r\n  }\r\n\r\n  function updateStopGameOnNextRound(bool _value) public onlyOwner {\r\n    stopGameOnNextRound = _value;\r\n  }\r\n\r\n  function restartGame() public onlyOwner {\r\n    gameRunning = true;\r\n  }\r\n  \r\n  function updateMinGasForDrawing(uint32 newGasAmount) public onlyOwner {\r\n    minGasForDrawing = newGasAmount;\r\n  }\r\n\r\n  function updateMinGasPriceForDrawing(uint32 newGasPrice) public onlyOwner {\r\n    minGasPriceForDrawing = newGasPrice;\r\n  }\r\n\r\n  function updateRngAddress(address newAddress) public onlyOwner {\r\n    require(rngAddress != 0x0);\r\n    rngAddress = newAddress;\r\n  }\r\n\r\n  function updateRewardForDrawing(uint256 newRewardForDrawing) public onlyOwner {\r\n    require(newRewardForDrawing > 0);\r\n\r\n    rewardForDrawing = newRewardForDrawing;\r\n  }\r\n  //END Logistics\r\n\r\n  //END owner methods  \r\n}\r\n\r\n//\r\n//-----------------------------\r\n// <<<<Contract begins here>>>>\r\n//-----------------------------\r\n//\r\n//* CryptoLuck Lottery Game \r\n//* Quick, ETH\r\n//* Version: 1\r\n//* Website: https://cryptoluck.fun\r\n//*\r\ncontract CryptoLuckQuickEthV1 is RngRequester, StateQuickEth, Base {\r\n  using SafeMath for uint;\r\n\r\n  modifier onlyRng {\r\n    require(msg.sender == rngAddress);\r\n    \r\n    _;\r\n  }\r\n\r\n  event LogLotteryResult(\r\n    uint32 indexed lotteryId, \r\n    uint8 status,\r\n    bytes32 indexed oraclizeId, \r\n    bytes oraclizeResult\r\n  );\r\n  \r\n  struct Lottery {\r\n    uint256 prizePool;\r\n    uint256 totalContributions;\r\n    uint256 oraclizeFees;\r\n    \r\n    uint256 drawerBonusTickets;\r\n    \r\n    mapping (address => uint256) balances;\r\n    address[] participants;\r\n      \r\n    address winner;\r\n    address drawer;\r\n\r\n    bytes32[] oraclizeIds;\r\n    bytes oraclizeResult;\r\n\r\n    uint256 winningNumber;\r\n\r\n    //0 => initial state, open\r\n    //1 => finalized with success\r\n    //2 => finalized with error (e.g. due to Oraclize not returning proper results etc)\r\n    uint8 status;\r\n\r\n    bool awaitingOraclizeCallback;\r\n  }\r\n  \r\n  bool public useOraclize;\r\n  //Keep track of all lotteries. Stats ftw\r\n  uint32 public currentLotteryId = 0;\r\n  mapping (uint32 => Lottery) public lotteries;\r\n  \r\n  //1 finney == 0.001 ETH. Estimating for a run of ETH to 1000 USD, that's $1 per ticket.\r\n  uint256 public ticketPrice = 1 finney;\r\n  \r\n  //Timestamp to keep track of when the last draw happened\r\n  uint256 public lastDrawTs;\r\n  \r\n  uint256 public houseBalance = 0;\r\n  \r\n  function CryptoLuckQuickEthV1(address _rngAddress, bool _useOraclize) {\r\n    stopGameOnNextRound = false;\r\n    gameRunning = true;\r\n    \r\n    require(_rngAddress != 0x0);\r\n\r\n    rngAddress = _rngAddress;\r\n    useOraclize = _useOraclize;\r\n    \r\n    //Initialize lottery draw to contract deploy time - \r\n    //that's when we \"start\" the lottery.\r\n    lastDrawTs = block.timestamp;\r\n  }\r\n\r\n  //Convenience method to return the current lottery\r\n  function currentLottery() view internal returns (Lottery storage) {\r\n    return lotteries[currentLotteryId];\r\n  }\r\n\r\n  /////////////////\r\n  //Lottery flow:\r\n  //STEP 1: send ETH to enter lottery \r\n  function () public payable {\r\n    // Disallow contracts - this avoids a whole host of issues, automations etc.\r\n    require(!isContract(msg.sender));\r\n    \r\n    // Disallow deposits if game is not running\r\n    require(gameRunning);\r\n    \r\n    // Require the sender to be able to purchase at least 1 ticket\r\n    require(msg.value >= ticketPrice);\r\n    \r\n    uint256 existingBalance = currentLottery().balances[msg.sender];\r\n    \r\n    //Total contribution should be at least the minimum contribution (0.05 ETH to start with)\r\n    require(msg.value + existingBalance >= minContribution);\r\n    //But their total contribution must not exceed max contribution\r\n    require(msg.value + existingBalance <= maxContribution);\r\n    \r\n    updatePlayerBalance(currentLotteryId);\r\n    \r\n    //If the requirements for a draw are met, and the gas price and gas limit are OK as well,\r\n    //execute the draw.\r\n    if (mustDraw() && gasRequirementsOk()) {\r\n      draw();\r\n    }\r\n  }\r\n\r\n  //Ensure there's enough gas left (minGasForDrawing is an estimate)\r\n  //and that the gas price is enough to ensure it doesnt take an eternity to process the draw tx.\r\n  function gasRequirementsOk() view private returns(bool) {\r\n    return (msg.gas >= minGasForDrawing) && (tx.gasprice >= minGasPriceForDrawing);\r\n  }\r\n\r\n  /////////////////\r\n  //STEP 2: store balance\r\n  //\r\n  //When someone sends Ether to this contract, we keep track of their total contribution.\r\n  function updatePlayerBalance(uint32 lotteryId) private returns(uint) {\r\n    Lottery storage lot = lotteries[lotteryId];\r\n    \r\n    //if current lottery is locked, since we made the call to Oraclize for the random number,\r\n    //but we haven't received the response yet, put the player's ether into the next lottery instead.\r\n    if (lot.awaitingOraclizeCallback) {\r\n      updatePlayerBalance(lotteryId + 1);\r\n      return;\r\n    }\r\n\r\n    address participant = msg.sender;\r\n    \r\n    //If we dont have this participant in the balances mapping, \r\n    //then it's a new address, so add it to the participants list, to keep track of the address.\r\n    if (lot.balances[participant] == 0) {\r\n      lot.participants.push(participant);\r\n    }\r\n    \r\n    //Increase the total contribution of this address (people can buy multiple times from the same address)\r\n    lot.balances[participant] = lot.balances[participant].add(msg.value);\r\n    //And the prize pool, of course.\r\n    lot.prizePool = lot.prizePool.add(msg.value);\r\n    \r\n    return lot.balances[participant];\r\n  }\r\n  \r\n  /////////////////\r\n  //STEP 3: when someone contributes to the lottery, check to see if we've met the requirements for a draw yet.\r\n  function mustDraw() view private returns (bool) {\r\n    Lottery memory lot = currentLottery();\r\n    \r\n    //At least 60 mins have elapsed since the last draw\r\n    bool timeDiffOk = now - lastDrawTs >= requiredTimeBetweenDraws;\r\n    \r\n    //We have at least 5 participants\r\n    bool minParticipantsOk = lot.participants.length >= requiredEntries;\r\n\r\n    return minParticipantsOk && timeDiffOk;\r\n  }\r\n\r\n  /////////////////\r\n  //STEP 4: If STEP 3 is a-ok, execute the draw, request a random number from our RNG provider.\r\n  //Flow will be resumed when the RNG provider contract receives the Oraclize callback, and in turn\r\n  //calls back into the lottery contract.\r\n  function draw() private {\r\n    Lottery storage lot = currentLottery();\r\n    \r\n    lot.awaitingOraclizeCallback = true;\r\n    \r\n    //Record total contributions for posterity and for correct calculation of the result,\r\n    //since the prize pool is used to pay for the Oraclize fees.\r\n    lot.totalContributions = lot.prizePool;\r\n\r\n    //Track who was the drawer of the lottery, to be awarded the drawer bonuses: \r\n    //extra ticket(s) and some ETH to cover the gas cost\r\n    lot.drawer = msg.sender;\r\n\r\n    lastDrawTs = now;\r\n    \r\n    requestRandom();\r\n  }\r\n\r\n  /////////////////\r\n  //STEP 5: Generate a random number between 0 and the sum of purchased tickets, using Oraclize random DS.\r\n  function requestRandom() private {\r\n    Lottery storage lot = currentLottery();\r\n    \r\n    CryptoLuckRng rngContract = CryptoLuckRng(rngAddress);\r\n    \r\n    //RNG provider returns the estimated Oraclize fee\r\n    uint fee = rngContract.getFee();\r\n    \r\n    //Pay oraclize query from the prize pool and keep track of all fees paid \r\n    //(usually, only 1 fee, but can be more if the first call fails)\r\n    lot.prizePool = lot.prizePool.sub(fee);\r\n    lot.oraclizeFees = lot.oraclizeFees.add(fee);\r\n    \r\n    //Store the query ID so we can match it on callback, to ensure we are receiving a legit callback.\r\n    //Ask for a 7 bytes number. max is 72'057'594'037'927'936, should be ok :)\r\n    bytes32 oraclizeId = rngContract.requestRandom.value(fee)(7);\r\n    \r\n    lot.oraclizeIds.push(oraclizeId);\r\n  }\r\n\r\n  /////////////////\r\n  //STEP 6: callback from the RNG provider - find the winner based on the generated random number\r\n  function acceptRandom(bytes32 reqId, bytes result) public onlyRng {\r\n    Lottery storage lot = currentLottery();\r\n    \r\n    //Verify the current lottery matches its oraclizeID with the supplied one, \r\n    //if we use Oraclize on this network (true for non-dev ones)\r\n    if (useOraclize) {\r\n      require(currentOraclizeId() == reqId);\r\n    }\r\n    \r\n    //Store the raw result.\r\n    lot.oraclizeResult = result;\r\n\r\n    //Award bonus tickets to the drawer.\r\n    uint256 bonusTickets = calculateBonusTickets(lot.totalContributions);\r\n\r\n    lot.drawerBonusTickets = bonusTickets;\r\n\r\n    //Compute total tickets in the draw, including the bonus ones.\r\n    uint256 totalTickets = bonusTickets + (lot.totalContributions / ticketPrice);\r\n    \r\n    //mod with totalTickets to get a number in [0..totalTickets - 1]\r\n    //add 1 to bring it in the range of [1, totalTickets], since we start our interval slices at 1 (see below)\r\n    lot.winningNumber = 1 + (uint(keccak256(result)) % totalTickets);\r\n\r\n    findWinner();\r\n\r\n    LogLotteryResult(currentLotteryId, 1, reqId, result);\r\n  }\r\n  \r\n  //STEP 6': Drawer receives bonus tickets, to cover the higher gas consumption and incentivize people to do so.\r\n  function calculateBonusTickets(uint256 totalContributions) view internal returns(uint256) {\r\n    \r\n    //1% of all contributions\r\n    uint256 bonusTickets = (totalContributions * bonusTicketsPercentage / 100) / ticketPrice;\r\n    \r\n    //bonus = between 1 to maxBonusTickets (initially, 5)\r\n    if (bonusTickets == 0) {\r\n       bonusTickets = 1;\r\n    }\r\n\r\n    if (bonusTickets > maxBonusTickets) {\r\n      bonusTickets = maxBonusTickets;\r\n    }\r\n    \r\n    return bonusTickets;\r\n  }\r\n\r\n  /////////////////\r\n  //STEP 7: determine winner by figuring out which address owns the interval \r\n  // encompassing the generated random number and pay the winner.\r\n  function findWinner() private {\r\n    Lottery storage lot = currentLottery();\r\n    \r\n    uint256 currentLocation = 1;\r\n\r\n    for (uint16 i = 0; i < lot.participants.length; i++) {\r\n      address participant = lot.participants[i];\r\n      \r\n      //A1 bought 70 tickets => head = 1 + 70 - 1 => owns [1, 70]; at the end of the loop, location ++\r\n      //A2 bought 90 tickets => head = 71 + 90 - 1 => owns [71, 160]; increment, etc\r\n      uint256 finalTickets = lot.balances[participant] / ticketPrice;\r\n      \r\n      //The drawer receives some bonus tickets, for the effort of having executed the lottery draw.\r\n      if (participant == lot.drawer) {\r\n        finalTickets += lot.drawerBonusTickets;\r\n      }\r\n\r\n      currentLocation += finalTickets - 1; \r\n      \r\n      if (currentLocation >= lot.winningNumber) {\r\n          lot.winner = participant;\r\n          break;\r\n      }\r\n      //move to the \"start\" of the next interval, for the next participant.\r\n      currentLocation += 1; \r\n    }\r\n    \r\n    //Prize is all current balance on current lottery, minus the house fee and reward for drawing\r\n    uint256 prize = lot.prizePool;\r\n\r\n    //Calculate house fee and track it. \r\n    //House fee is integer per mille, e,g, 5 = 0.5%, thus, divide by 1000 to get the percentage\r\n    uint256 houseShare = houseFee * prize / 1000;\r\n    \r\n    houseBalance = houseBalance.add(houseShare);\r\n    \r\n    //deduct the house share and the reward for drawing from the prize pool.\r\n    prize = prize.sub(houseShare);\r\n    prize = prize.sub(rewardForDrawing);\r\n    \r\n    lot.status = 1;\r\n    lot.awaitingOraclizeCallback = false;\r\n    \r\n    lot.prizePool = prize;\r\n\r\n    //Transfer the prize to the winner\r\n    lot.winner.transfer(prize);\r\n    \r\n    //Transfer the reward for drawing to the drawer.\r\n    //(should cover most of the gas paid for executing the draw)\r\n    lot.drawer.transfer(rewardForDrawing);\r\n\r\n    finalizeLottery();\r\n  } \r\n  \r\n  //END lottery flow\r\n  ////////////////////\r\n  \r\n  //Function which moves on to the next lottery and stops the next round if indicated\r\n  function finalizeLottery() private {\r\n    currentLotteryId += 1;\r\n\r\n    if (stopGameOnNextRound) {\r\n      gameRunning = false;\r\n      stopGameOnNextRound = false;\r\n    }\r\n  }\r\n\r\n  function currentOraclizeId() view private returns(bytes32) {\r\n    Lottery memory lot = currentLottery();\r\n    \r\n    return lot.oraclizeIds[lot.oraclizeIds.length - 1];\r\n  }\r\n\r\n  //Allow players to withdraw their money in case the lottery fails.\r\n  //Can happen if the oraclize call fails 2 times\r\n  function withdrawFromFailedLottery(uint32 lotteryId) public {\r\n    address player = msg.sender;\r\n    \r\n    Lottery storage lot = lotteries[lotteryId];\r\n    \r\n    //can only withdraw from failed lotteries\r\n    require(lot.status == 2);\r\n    \r\n    //can withdraw contributed balance, minus the fees that have been paid to Oraclize, divided/supported among all participants\r\n    uint256 playerBalance = lot.balances[player].sub(lot.oraclizeFees / lot.participants.length);\r\n    //require to have something to send back\r\n    require(playerBalance > 0);\r\n\r\n    //update the local balances\r\n    lot.balances[player] = 0;\r\n    lot.prizePool = lot.prizePool.sub(playerBalance);\r\n\r\n    //send to player\r\n    player.transfer(playerBalance);\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////\r\n  //Public methods outside lottery flow\r\n  \r\n  //In case ETH is needed in the contract for whatever reason.\r\n  //Generally, the owner of the house will top up the contract, so increase the house balance.\r\n  //PS: If someone else tops up the house, thanks! :)\r\n  function houseTopUp() public payable {\r\n    houseBalance = houseBalance.add(msg.value);\r\n  }\r\n  \r\n  //Allow the owner to withdraw the house fees + house top ups.\r\n  function houseWithdraw() public onlyOwner {\r\n    owner.transfer(houseBalance);\r\n  }\r\n\r\n  //In case the lottery gets stuck, oraclize doesnt call back etc., need a way to retry.\r\n  function manualDraw() public onlyOwner {\r\n    Lottery storage lot = currentLottery();\r\n    //Only for open lotteries\r\n    require(lot.status == 0);\r\n    \r\n    //Allow the owner to draw only when it would normally be allowed\r\n    require(mustDraw());\r\n    \r\n    //Also, ensure there's at least 1 hr since the call to oraclize has been made.\r\n    //If the result didnt come in 1 hour, then something is wrong with oraclize, so it's ok to try again.\r\n    require(now - lastDrawTs > MANUAL_WITHDRAW_INTERVAL);\r\n\r\n    //If we try to draw manually but we already have 2 Oraclize requests logged, then we need to fail the lottery.\r\n    //then something is wrong with Oraclize - maybe down or someone at Oraclize trying to meddle with the results.\r\n    //As such, fail the lottery, move on to the next and allow people to withdraw their money from this one.\r\n    if (lot.oraclizeIds.length == 2) {\r\n      lot.status = 2;\r\n      lot.awaitingOraclizeCallback = false;\r\n      \r\n      LogLotteryResult(currentLotteryId, 2, lot.oraclizeIds[lot.oraclizeIds.length - 1], \"\");\r\n\r\n      finalizeLottery();\r\n    } else {\r\n      draw();\r\n    }\r\n  }\r\n\r\n  \r\n  ///////////\r\n\r\n  //Helper methods.\r\n  function balanceInLottery(uint32 lotteryId, address player) view public returns(uint) {\r\n    return lotteries[lotteryId].balances[player];\r\n  }\r\n\r\n  function participantsOf(uint32 lotteryId) view public returns (address[]) {\r\n    return lotteries[lotteryId].participants;\r\n  }\r\n\r\n  function oraclizeIds(uint32 lotteryId) view public returns(bytes32[]) {\r\n    return lotteries[lotteryId].oraclizeIds;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"minGasPriceForDrawing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"houseTopUp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateRequiredTimeBetweenDraws\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint8\"}],\"name\":\"updateHouseFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rngAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateMaxBonusTickets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newGasAmount\",\"type\":\"uint32\"}],\"name\":\"updateMinGasForDrawing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardForDrawing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredEntries\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newGasPrice\",\"type\":\"uint32\"}],\"name\":\"updateMinGasPriceForDrawing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint32\"}],\"name\":\"withdrawFromFailedLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBonusTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reqId\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"acceptRandom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDrawTs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateMinContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"updateStopGameOnNextRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint32\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"balanceInLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint32\"}],\"name\":\"participantsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusTicketsPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRewardForDrawing\",\"type\":\"uint256\"}],\"name\":\"updateRewardForDrawing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentLotteryId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameRunning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateRngAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint8\"}],\"name\":\"updateBonusTicketsPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateMaxContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minGasForDrawing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopGameOnNextRound\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"houseWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredTimeBetweenDraws\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint16\"}],\"name\":\"updateRequiredEntries\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint32\"}],\"name\":\"oraclizeIds\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"useOraclize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"lotteries\",\"outputs\":[{\"name\":\"prizePool\",\"type\":\"uint256\"},{\"name\":\"totalContributions\",\"type\":\"uint256\"},{\"name\":\"oraclizeFees\",\"type\":\"uint256\"},{\"name\":\"drawerBonusTickets\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"drawer\",\"type\":\"address\"},{\"name\":\"oraclizeResult\",\"type\":\"bytes\"},{\"name\":\"winningNumber\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"awaitingOraclizeCallback\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rngAddress\",\"type\":\"address\"},{\"name\":\"_useOraclize\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lotteryId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"oraclizeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"oraclizeResult\",\"type\":\"bytes\"}],\"name\":\"LogLotteryResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CryptoLuckQuickEthV1","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000017f3b274c9cbc591e2801f921b64a7247b0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://4c27b50fb99a5531279062438df63022cb052193eda7c1c981eb2feb3f299ab9"}]}