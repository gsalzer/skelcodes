{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n/*\r\n    Copyright 2017, Griff Green\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of BasicToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/// @dev `Escapable` is a base level contract for and contract that wants to\r\n///  add an escape hatch for a contract that holds ETH or ERC20 tokens. This\r\n///  contract creates an `escapeHatch()` function to send its `baseTokens` to\r\n///  `escapeHatchDestination` when called by the `escapeHatchCaller` in the case that\r\n///  something unexpected happens\r\ncontract Escapable {\r\n    BasicToken public baseToken;\r\n\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination`, the\r\n    ///  `escapeHatchCaller`, and the `baseToken`\r\n    /// @param _baseToken The address of the token that is used as a store value\r\n    ///  for this contract, 0x0 in case of ether. The token must have the ERC20\r\n    ///  standard `balanceOf()` and `transfer()` functions\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the `baseToken` held in this contract\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the `baseToken` in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\r\n    /// cannot move funds out of `escapeHatchDestination`\r\n    function Escapable(\r\n        address _baseToken,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination) {\r\n        baseToken = BasicToken(_baseToken);\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    /// @dev The addresses preassigned the `escapeHatchCaller` role\r\n    ///  is the only addresses that can call a function with this modifier\r\n    modifier onlyEscapeHatchCaller {\r\n        require (msg.sender == escapeHatchCaller);\r\n        _;\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    function escapeHatch() onlyEscapeHatchCaller {\r\n        uint total = getBalance();\r\n        // Send the total balance of this contract to the `escapeHatchDestination`\r\n        transfer(escapeHatchDestination, total);\r\n        EscapeHatchCalled(total);\r\n    }\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller` cannot\r\n    ///  move funds out of `escapeHatchDestination`\r\n    function changeEscapeHatchCaller(address _newEscapeHatchCaller\r\n        ) onlyEscapeHatchCaller \r\n    {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n        EscapeHatchCallerChanged(escapeHatchCaller);\r\n    }\r\n    /// @notice Returns the balance of the `baseToken` stored in this contract\r\n    function getBalance() constant returns(uint) {\r\n        if (address(baseToken) != 0) {\r\n            return baseToken.balanceOf(this);\r\n        } else {\r\n            return this.balance;\r\n        }\r\n    }\r\n    /// @notice Sends an `_amount` of `baseToken` to `_to` from this contract,\r\n    /// and it can only be called by the contract itself\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of `baseToken to be sent\r\n    function transfer(address _to, uint _amount) internal {\r\n        if (address(baseToken) != 0) {\r\n            require (baseToken.transfer(_to, _amount));\r\n        } else {\r\n            require ( _to.send(_amount));\r\n        }\r\n    }\r\n\r\n\r\n//////\r\n// Receive Ether\r\n//////\r\n\r\n    /// @notice Called anytime ether is sent to the contract && creates an event\r\n    /// to more easily track the incoming transactions\r\n    function receiveEther() payable {\r\n        // Do not accept ether if baseToken is not ETH\r\n        require (address(baseToken) == 0);\r\n        EtherReceived(msg.sender, msg.value);\r\n    }\r\n\r\n//////////\r\n// Safety Methods\r\n//////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyEscapeHatchCaller {\r\n        if (_token == 0x0) {\r\n            escapeHatchDestination.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        BasicToken token = BasicToken(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(escapeHatchDestination, balance);\r\n        ClaimedTokens(_token, escapeHatchDestination, balance);\r\n    }\r\n\r\n    /// @notice The fall back function is called whenever ether is sent to this\r\n    ///  contract\r\n    function () payable {\r\n        receiveEther();\r\n    }\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n    event EscapeHatchCalled(uint amount);\r\n    event EscapeHatchCallerChanged(address indexed newEscapeHatchCaller);\r\n    event EtherReceived(address indexed from, uint amount);\r\n}\r\n\r\n/// @title Mexico Matcher\r\n/// @author Vojtech Simetka, Jordi Baylina, Dani Philia, Arthur Lunn, Griff Green\r\n/// @notice This contract is used to match donations inspired by the generosity\r\n///  of Bitso:  \r\n///  The escapeHatch allows removal of any other tokens deposited by accident.\r\n\r\n\r\n/// @dev The main contract which forwards funds sent to contract.\r\ncontract MexicoMatcher is Escapable {\r\n    address public beneficiary; // expected to be a Giveth campaign\r\n\r\n    /// @notice The Constructor assigns the `beneficiary`, the\r\n    ///  `escapeHatchDestination` and the `escapeHatchCaller` as well as deploys\r\n    ///  the contract to the blockchain (obviously)\r\n    /// @param _beneficiary The address that will receive donations\r\n    /// @param _escapeHatchDestination The address of a safe location (usually a\r\n    ///  Multisig) to send the ether deposited to be matched in this contract if\r\n    ///  there is an issue\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract\r\n    ///  to call `escapeHatch()` to send the ether in this contract to the \r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    function MexicoMatcher(\r\n            address _beneficiary, // address that receives ether\r\n            address _escapeHatchCaller,\r\n            address _escapeHatchDestination\r\n        )\r\n        // Set the escape hatch to accept ether (0x0)\r\n        Escapable(0x0, _escapeHatchCaller, _escapeHatchDestination)\r\n    {\r\n        beneficiary = _beneficiary;\r\n    }\r\n    \r\n    /// @notice Simple function to deposit more ETH to match future donations\r\n    function depositETH() payable {\r\n        DonationDeposited4Matching(msg.sender, msg.value);\r\n    }\r\n    /// @notice Donate ETH to the `beneficiary`, and if there is enough in the \r\n    ///  contract double it. The `msg.sender` is rewarded with Campaign tokens;\r\n    ///  This contract may have a high gasLimit requirement\r\n    function () payable {\r\n        uint256 amount;\r\n        \r\n        // If there is enough ETH in the contract to double it, DOUBLE IT!\r\n        if (this.balance >= msg.value*2){\r\n            amount = msg.value*2; // do it two it!\r\n        \r\n            // Send ETH to the beneficiary; must be an account, not a contract\r\n            require (beneficiary.send(amount));\r\n            DonationMatched(msg.sender, amount);\r\n        } else {\r\n            amount = this.balance;\r\n            require (beneficiary.send(amount));\r\n            DonationSentButNotMatched(msg.sender, amount);\r\n        }\r\n    }\r\n    event DonationDeposited4Matching(address indexed sender, uint amount);\r\n    event DonationMatched(address indexed sender, uint amount);\r\n    event DonationSentButNotMatched(address indexed sender, uint amount);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeEscapeHatchCaller\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveEther\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonationDeposited4Matching\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonationMatched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonationSentButNotMatched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"EscapeHatchCallerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"}]","ContractName":"MexicoMatcher","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000088b6021ae4bb9830f2e9d5bb38b83427b9d7ffec000000000000000000000000839395e20bbb182fa440d08f850e6c7a8f6f07800000000000000000000000008f951903c9360345b4e1b536c7f5ae8f88a64e79","Library":"","SwarmSource":"bzzr://a48d342d6d022e365e7620ed14f5042fd43839c90dffef59985b9b32606944e7"}]}