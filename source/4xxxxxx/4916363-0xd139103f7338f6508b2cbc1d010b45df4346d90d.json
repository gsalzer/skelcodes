{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    assert(b != 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n  function mulByFraction(uint256 number, uint256 numerator, uint256 denominator) pure internal returns (uint256) {\r\n      return div(mul(number, numerator), denominator);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n\r\n  // timestamps until all tokens transfers are blocked\r\n  uint256 public blockedTimeForBountyTokens = 0;\r\n  uint256 public blockedTimeForInvestedTokens = 0;\r\n\r\n  // minimum timestamp that tokens will be blocked for transfers\r\n  uint256 constant MIN_blockedTimeForBountyTokens = 1524949200; //29.04.2018, 0:00:00\r\n  uint256 constant MIN_blockedTimeForInvestedTokens = 1521061200; //15.03.2018, 0:00:00\r\n\r\n  //Addresses pre-ico investors\r\n  mapping(address => bool) preIcoAccounts;\r\n\r\n  //Addresses bounty campaign\r\n  mapping(address => bool) bountyAccounts;\r\n\r\n  //Addresses with founders tokens and flag is it blocking transfers from this address\r\n  mapping(address => uint) founderAccounts; // 1 - block transfers, 2 - do not block transfers\r\n\r\n  function Pausable() public {\r\n    blockedTimeForBountyTokens = MIN_blockedTimeForBountyTokens;\r\n    blockedTimeForInvestedTokens = MIN_blockedTimeForInvestedTokens;\r\n  }\r\n\r\n  /**\r\n  * @dev called by owner for changing blockedTimeForBountyTokens\r\n  */\r\n  function changeBlockedTimeForBountyTokens(uint256 _blockedTime) onlyOwner external {\r\n    require(_blockedTime < MIN_blockedTimeForBountyTokens);\r\n    blockedTimeForBountyTokens = _blockedTime;\r\n  }\r\n\r\n  /**\r\n* @dev called by owner for changing blockedTimeForInvestedTokens\r\n*/\r\n  function changeBlockedTimeForInvestedTokens(uint256 _blockedTime) onlyOwner external {\r\n    require(_blockedTime < MIN_blockedTimeForInvestedTokens);\r\n    blockedTimeForInvestedTokens = _blockedTime;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!getPaused());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(getPaused());\r\n    _;\r\n  }\r\n\r\n  function getPaused() internal returns (bool) {\r\n    if (now > blockedTimeForBountyTokens && now > blockedTimeForInvestedTokens) {\r\n      return false;\r\n    } else {\r\n      uint256 blockedTime = checkTimeForTransfer(msg.sender);\r\n      return now < blockedTime;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev called by owner, add preIcoAccount\r\n  */\r\n  function addPreIcoAccounts(address _addr) onlyOwner internal {\r\n    require(_addr != 0x0);\r\n    preIcoAccounts[_addr] = true;\r\n  }\r\n\r\n  /**\r\n  * @dev called by owner, add addBountyAccount\r\n  */\r\n  function addBountyAccounts(address _addr) onlyOwner internal {\r\n    require(_addr != 0x0);\r\n    preIcoAccounts[_addr] = true;\r\n  }\r\n\r\n  /**\r\n  * @dev called by owner, add founderAccount\r\n  */\r\n  function addFounderAccounts(address _addr, uint _flag) onlyOwner external {\r\n    require(_addr != 0x0);\r\n    founderAccounts[_addr] = _flag;\r\n  }\r\n\r\n  /**\r\n   * @dev called by external contract (ImmlaToken) for checking rights for transfers, depends on who owner of this address\r\n   */\r\n  function checkTimeForTransfer(address _account) internal returns (uint256) {\r\n    if (founderAccounts[_account] == 1) {\r\n      return blockedTimeForInvestedTokens;\r\n    } else if(founderAccounts[_account] == 2) {\r\n      return 1; //do not block transfers\r\n    } else if (preIcoAccounts[_account]) {\r\n      return blockedTimeForInvestedTokens;\r\n    } else if (bountyAccounts[_account]) {\r\n      return blockedTimeForBountyTokens;\r\n    } else {\r\n      return blockedTimeForInvestedTokens;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n *\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is PausableToken {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to mint tokens for pre-ico\r\n   */\r\n  function multiMintPreico(address[] _dests, uint256[] _values) onlyOwner canMint public returns (uint256) {\r\n    uint256 i = 0;\r\n    uint256 count = _dests.length;\r\n    while (i < count) {\r\n      totalSupply = totalSupply.add(_values[i]);\r\n      balances[_dests[i]] = balances[_dests[i]].add(_values[i]);\r\n      addPreIcoAccounts(_dests[i]);\r\n      Mint(_dests[i], _values[i]);\r\n      Transfer(address(0), _dests[i], _values[i]);\r\n      i += 1;\r\n    }\r\n    return(i);\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to mint tokens for pre-ico\r\n   */\r\n  function multiMintBounty(address[] _dests, uint256[] _values) onlyOwner canMint public returns (uint256) {\r\n    uint256 i = 0;\r\n    uint256 count = _dests.length;\r\n    while (i < count) {\r\n      totalSupply = totalSupply.add(_values[i]);\r\n      balances[_dests[i]] = balances[_dests[i]].add(_values[i]);\r\n      addBountyAccounts(_dests[i]);\r\n      Mint(_dests[i], _values[i]);\r\n      Transfer(address(0), _dests[i], _values[i]);\r\n      i += 1;\r\n    }\r\n    return(i);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 token that transferable by owner\r\n */\r\ncontract TransferableByOwner is StandardToken, Ownable {\r\n\r\n  // timestamp until owner could transfer all tokens\r\n  uint256 constant public OWNER_TRANSFER_TOKENS = now + 1 years;\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another by owner\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferByOwner(address _from, address _to, uint256 _value) onlyOwner public returns (bool) {\r\n    require(now < OWNER_TRANSFER_TOKENS);\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract ImmlaToken is MintableToken, TransferableByOwner {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     * Token meta data\r\n     */\r\n    string public constant name = \"IMMLA\";\r\n    string public constant symbol = \"IML\";\r\n    uint8 public constant decimals = 18;\r\n}\r\n\r\n\r\n\r\ncontract ImmlaDistribution is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // minimum amount of tokens a buyer gets per 1 ether\r\n    uint256 constant RATE_MIN = 3640;\r\n\r\n    // timestamp until owner could transfer all tokens\r\n    uint256 constant public OWNER_TRANSFER_TOKENS = now + 1 years;\r\n\r\n    // The token being sold\r\n    ImmlaToken public token;\r\n\r\n    //maximum tokens for mint in additional emission\r\n    uint256 public constant emissionLimit = 418124235 * 1 ether;\r\n\r\n    // amount of tokens that already minted in additional emission\r\n    uint256 public additionalEmission = 0;\r\n\r\n    // amount of token that currently available for buying\r\n    uint256 public availableEmission = 0;\r\n\r\n    bool public mintingPreIcoFinish = false;\r\n    bool public mintingBountyFinish = false;\r\n    bool public mintingFoundersFinish = false;\r\n\r\n    // address where funds are collected (by default t_Slava address)\r\n    address public wallet;\r\n\r\n    // how many token units a buyer gets per 1 ether\r\n    uint256 public rate;\r\n\r\n    address constant public t_ImmlaTokenDepository = 0x64075EEf64d9E105A61227CcCd5fA9F6b54DB278;\r\n    address constant public t_ImmlaTokenDepository2 = 0x2Faaf371Af6392fdd3016E111fB4b3B551Ee46aB;\r\n    address constant public t_ImmlaBountyTokenDepository = 0x5AB08C5Dfd53b8f6f6C3e3bbFDb521170C3863B0;\r\n    address constant public t_Andrey = 0x027810A9C17cb0E739a33769A9E794AAF40D2338;\r\n    address constant public t_Michail = 0x00af06cF0Ae6BD83fC36b6Ae092bb4F669B6dbF0;\r\n    address constant public t_Slava = 0x00c11E5B0b5db0234DfF9a357F56077c9a7A83D0;\r\n    address constant public t_Andrey2 = 0xC7e788FeaE61503136021cC48a0c95bB66d0B9f2;\r\n    address constant public t_Michail2 = 0xb6f4ED2CE19A08c164790419D5d87D3074D4Bd92;\r\n    address constant public t_Slava2 = 0x00ded30026135fBC460c2A9bf7beC06c7F31101a;\r\n\r\n    /**\r\n     * @dev Proposals for mint tokens to some address\r\n     */\r\n    mapping(address => Proposal) public proposals;\r\n\r\n    struct Proposal {\r\n        address wallet;\r\n        uint256 amount;\r\n        uint256 numberOfVotes;\r\n        mapping(address => bool) voted;\r\n    }\r\n\r\n    /**\r\n     * @dev Members of congress\r\n     */\r\n    mapping(address => bool) public congress;\r\n\r\n    /**\r\n     * @dev Minimal quorum value\r\n     */\r\n    uint256 public minimumQuorum = 1;\r\n\r\n    /**\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n    event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\r\n\r\n    /**\r\n     * @dev On proposal added\r\n     * @param congressman Congressman address\r\n     * @param wallet Wallet\r\n     * @param amount Amount of wei to transfer\r\n     */\r\n    event ProposalAdded(address indexed congressman, address indexed wallet, uint256 indexed amount);\r\n\r\n    /**\r\n     * @dev On proposal passed\r\n     * @param congressman Congressman address\r\n     * @param wallet Wallet\r\n     * @param amount Amount of wei to transfer\r\n     */\r\n    event ProposalPassed(address indexed congressman, address indexed wallet, uint256 indexed amount);\r\n\r\n    /**\r\n   * @dev Modifier to make a function callable only when the minting for pre-ico is not paused.\r\n   */\r\n    modifier whenNotPreIcoFinish() {\r\n        require(!mintingPreIcoFinish);\r\n        _;\r\n    }\r\n\r\n    /**\r\n   * @dev Modifier to make a function callable only when the minting for bounty is not paused.\r\n   */\r\n    modifier whenNotBountyFinish() {\r\n        require(!mintingBountyFinish);\r\n        _;\r\n    }\r\n\r\n    /**\r\n   * @dev Modifier to make a function callable only when the minting for bounty is not paused.\r\n   */\r\n    modifier whenNotMintingFounders() {\r\n        require(!mintingFoundersFinish);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier that allows only congress to vote and create new proposals\r\n     */\r\n    modifier onlyCongress {\r\n        require (congress[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * ImmlaDistribution constructor\r\n     */\r\n    function ImmlaDistribution(address _token) public payable { // gas 6297067\r\n        token = ImmlaToken(_token);\r\n\r\n        //@TODO - change this to t_Slava (0x00c11E5B0b5db0234DfF9a357F56077c9a7A83D0) address or deploy contract from this address\r\n        owner = msg.sender;\r\n\r\n        wallet = owner;\r\n        rate = RATE_MIN;\r\n\r\n        congress[t_Andrey] = true;\r\n        congress[t_Michail] = true;\r\n        congress[t_Slava] = true;\r\n        minimumQuorum = 3;\r\n    }\r\n\r\n    /**\r\n   * @dev called by the owner to mint tokens to founders\r\n   */\r\n    function mintToFounders() onlyOwner whenNotMintingFounders public returns (bool) {\r\n        mintToFounders(t_ImmlaTokenDepository, 52000 * 1 ether, 2);\r\n        mintToFounders(t_ImmlaTokenDepository2, 0, 2);\r\n        mintToFounders(t_ImmlaBountyTokenDepository, 0, 2);\r\n        mintToFounders(t_Andrey,   525510849836086000000000, 1);\r\n        mintToFounders(t_Michail,  394133137377065000000000, 1);\r\n        mintToFounders(t_Slava,    394133137377065000000000, 1);\r\n        mintToFounders(t_Andrey2,  284139016853060000000000, 2);\r\n        mintToFounders(t_Michail2, 213104262639795000000000, 2);\r\n        mintToFounders(t_Slava2,   213104262639795000000000, 2);\r\n        mintingFoundersFinish = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function () external payable {\r\n        buyTokens();\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens() public payable {\r\n        require(availableEmission > 0);\r\n        require(msg.value != 0);\r\n\r\n        address investor = msg.sender;\r\n        uint256 weiAmount = msg.value;\r\n\r\n        uint256 tokensAmount = weiAmount.mul(rate);\r\n\r\n        //calculate change\r\n        uint256 tokensChange = 0;\r\n        if (tokensAmount > availableEmission) {\r\n            tokensChange = tokensAmount - availableEmission;\r\n            tokensAmount = availableEmission;\r\n        }\r\n\r\n        //make change\r\n        uint256 weiChange = 0;\r\n        if (tokensChange > 0) {\r\n            weiChange = tokensChange.div(rate);\r\n            investor.transfer(weiChange);\r\n        }\r\n\r\n        uint256 weiRaised = weiAmount - weiChange;\r\n\r\n        // update raised amount and additional emission\r\n        additionalEmission = additionalEmission.add(tokensAmount);\r\n        availableEmission = availableEmission.sub(tokensAmount);\r\n\r\n        //send tokens to investor\r\n        token.mint(investor, tokensAmount);\r\n        TokenPurchase(investor, weiRaised, tokensAmount);\r\n        mintBonusToFounders(tokensAmount);\r\n\r\n        //send ether to owner wallet\r\n        wallet.transfer(weiRaised);\r\n    }\r\n\r\n    /**\r\n   * @dev called by the owner to make additional emission\r\n   */\r\n    function updateAdditionalEmission(uint256 _amount, uint256 _rate) onlyOwner public { // gas 48191\r\n        require(_amount > 0);\r\n        require(_amount < (emissionLimit - additionalEmission));\r\n\r\n        availableEmission = _amount;\r\n        if (_rate > RATE_MIN) {\r\n            rate = RATE_MIN;\r\n        } else {\r\n            rate = _rate;\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev called by the owner to stop minting\r\n   */\r\n    function stopPreIcoMint() onlyOwner whenNotPreIcoFinish public {\r\n        mintingPreIcoFinish = true;\r\n    }\r\n\r\n    /**\r\n   * @dev called by the owner to stop minting\r\n   */\r\n    function stopBountyMint() onlyOwner whenNotBountyFinish public {\r\n        mintingBountyFinish = true;\r\n    }\r\n\r\n    /**\r\n   * @dev called by the owner to mint tokens for pre-ico\r\n   */\r\n    function multiMintPreIco(address[] _dests, uint256[] _values) onlyOwner whenNotPreIcoFinish public returns (bool) {\r\n        token.multiMintPreico(_dests, _values);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n   * @dev called by the owner to mint tokens for bounty\r\n   */\r\n    function multiMintBounty(address[] _dests, uint256[] _values) onlyOwner whenNotBountyFinish public returns (bool) {\r\n        token.multiMintBounty(_dests, _values);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n   * @dev called to mint tokens to founders\r\n   */\r\n    function mintToFounders(address _dest, uint256 _value, uint _flag) internal {\r\n        token.mint(_dest, _value);\r\n        token.addFounderAccounts(_dest, _flag);\r\n    }\r\n\r\n    /**\r\n   * @dev called to mint bonus tokens to founders\r\n   */\r\n    function mintBonusToFounders(uint256 _value) internal {\r\n\r\n        uint256 valueWithCoefficient = (_value * 1000) / 813;\r\n        uint256 valueWithMultiplier1 = valueWithCoefficient / 10;\r\n        uint256 valueWithMultiplier2 = (valueWithCoefficient * 7) / 100;\r\n\r\n        token.mint(t_Andrey, (valueWithMultiplier1 * 4) / 10);\r\n        token.mint(t_Michail, (valueWithMultiplier1 * 3) / 10);\r\n        token.mint(t_Slava, (valueWithMultiplier1 * 3) / 10);\r\n        token.mint(t_Andrey2, (valueWithMultiplier2 * 4) / 10);\r\n        token.mint(t_Michail2, (valueWithMultiplier2 * 3) / 10);\r\n        token.mint(t_Slava2, (valueWithMultiplier2 * 3) / 10);\r\n        token.mint(t_ImmlaBountyTokenDepository, (valueWithCoefficient * 15) / 1000);\r\n    }\r\n\r\n    /**\r\n  * @dev called by owner for changing blockedTimeForBountyTokens\r\n  */\r\n    function changeBlockedTimeForBountyTokens(uint256 _blockedTime) onlyOwner public {\r\n        token.changeBlockedTimeForBountyTokens(_blockedTime);\r\n    }\r\n\r\n    /**\r\n  * @dev called by owner for changing blockedTimeForInvestedTokens\r\n  */\r\n    function changeBlockedTimeForInvestedTokens(uint256 _blockedTime) onlyOwner public {\r\n        token.changeBlockedTimeForInvestedTokens(_blockedTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new proposal\r\n     * @param _wallet Beneficiary account address\r\n     * @param _amount Amount of tokens\r\n     */\r\n    function proposal(address _wallet, uint256 _amount) onlyCongress public {\r\n        require(availableEmission > 0);\r\n        require(_amount > 0);\r\n        require(_wallet != 0x0);\r\n        \r\n        if (proposals[_wallet].amount > 0) {\r\n            require(proposals[_wallet].voted[msg.sender] != true); // If has already voted, cancel\r\n            require(proposals[_wallet].amount == _amount); // If amounts is equal\r\n\r\n            proposals[_wallet].voted[msg.sender] = true; // Set this voter as having voted\r\n            proposals[_wallet].numberOfVotes++; // Increase the number of votes\r\n\r\n            //proposal passed\r\n            if (proposals[_wallet].numberOfVotes >= minimumQuorum) {\r\n                if (_amount > availableEmission) {\r\n                    _amount = availableEmission;\r\n                }\r\n\r\n                // update raised amount and additional emission\r\n                additionalEmission = additionalEmission.add(_amount);\r\n                availableEmission = availableEmission.sub(_amount);\r\n\r\n                token.mint(_wallet, _amount);\r\n                TokenPurchase(_wallet, 0, _amount);\r\n                ProposalPassed(msg.sender, _wallet, _amount);\r\n\r\n                mintBonusToFounders(_amount);\r\n                delete proposals[_wallet];\r\n            }\r\n\r\n        } else {\r\n            Proposal storage p = proposals[_wallet];\r\n\r\n            p.wallet           = _wallet;\r\n            p.amount           = _amount;\r\n            p.numberOfVotes    = 1;\r\n            p.voted[msg.sender] = true;\r\n\r\n            ProposalAdded(msg.sender, _wallet, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n  * @dev called by owner for transfer tokens\r\n  */\r\n    function transferTokens(address _from, address _to, uint256 _amount) onlyOwner public {\r\n        require(_amount > 0);\r\n\r\n        //can't transfer after OWNER_TRANSFER_TOKENS date (after 1 year)\r\n        require(now < OWNER_TRANSFER_TOKENS);\r\n\r\n        //can't transfer from and to congressman addresses\r\n        require(!congress[_from]);\r\n        require(!congress[_to]);\r\n\r\n        token.transferByOwner(_from, _to, _amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"t_Slava\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER_TRANSFER_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockedTime\",\"type\":\"uint256\"}],\"name\":\"changeBlockedTimeForInvestedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_Michail\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopPreIcoMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"proposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockedTime\",\"type\":\"uint256\"}],\"name\":\"changeBlockedTimeForBountyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFoundersFinish\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dests\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"multiMintPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopBountyMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emissionLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"additionalEmission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dests\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"multiMintBounty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingBountyFinish\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_Andrey\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_Michail2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_ImmlaBountyTokenDepository\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateAdditionalEmission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingPreIcoFinish\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_ImmlaTokenDepository2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"congress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_Slava2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintToFounders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_ImmlaTokenDepository\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableEmission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"t_Andrey2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"congressman\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"congressman\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProposalPassed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ImmlaDistribution","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000026ab4e37a0ca037791c9c935a5691d63466ba487","Library":"","SwarmSource":"bzzr://8c0b1ec8f7acf8bad198863102e9fbe43c61b8ecf67836d42ee2afc55be0f6d2"}]}