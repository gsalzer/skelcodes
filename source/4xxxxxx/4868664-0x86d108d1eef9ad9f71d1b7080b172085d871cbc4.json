{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Token {\r\n    function transfer(address _to, uint _value) public returns(bool);\r\n    function burn(uint _value) public;\r\n    function balanceOf(address _owner) view public returns(uint);\r\n    function decimals() view public returns(uint8);\r\n    function transferOwnership(address _newOwner) public;\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint _a, uint _b) internal pure returns(uint) {\r\n        uint c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n\r\n    function mul(uint _a, uint _b) internal pure returns(uint) {\r\n        if (_a == 0) {\r\n          return 0;\r\n        }\r\n        uint c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint _a, uint _b) internal pure returns(uint) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function sub(uint _a, uint _b) internal pure returns (uint) {\r\n        assert(_b <= _a);\r\n        return _a - _b;\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n    address public contractOwner;\r\n    address public pendingContractOwner;\r\n\r\n    event LogContractOwnershipChangeInitiated(address to);\r\n    event LogContractOwnershipChangeCompleted(address to);\r\n\r\n    function Owned() public {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    modifier onlyContractOwner() {\r\n        require(contractOwner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function changeContractOwnership(address _to) onlyContractOwner() public returns(bool) {\r\n        pendingContractOwner = _to;\r\n        LogContractOwnershipChangeInitiated(_to);\r\n        return true;\r\n    }\r\n\r\n    function claimContractOwnership() public returns(bool) {\r\n        if (pendingContractOwner != msg.sender) {\r\n            return false;\r\n        }\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n        LogContractOwnershipChangeCompleted(contractOwner);\r\n        return true;\r\n    }\r\n\r\n    function forceChangeContractOwnership(address _to) onlyContractOwner() public returns(bool) {\r\n        contractOwner = _to;\r\n        LogContractOwnershipChangeCompleted(contractOwner);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract NeuroSale is Owned {\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) public totalSpentEth;\r\n    mapping(address => uint) public totalTokensWithoutBonuses;\r\n    mapping(address => uint) public volumeBonusesTokens;\r\n\r\n    uint public constant TOKEN_PRICE = 0.001 ether;\r\n    uint public constant MULTIPLIER = uint(10) ** uint(18);\r\n    uint public salesStart;\r\n    uint public salesDeadline;\r\n    Token public token;\r\n    address public wallet;\r\n    bool public salePaused;\r\n\r\n    event LogBought(address indexed receiver, uint contribution, uint reward, uint128 customerId);\r\n    event LogPaused(bool isPaused);\r\n    event LogWalletUpdated(address to);\r\n\r\n    modifier notPaused() {\r\n        require(!salePaused);\r\n        _;\r\n    }\r\n\r\n    // Can be iniitialized only once.\r\n    function init(Token _token, address _wallet, uint _start, uint _deadline) onlyContractOwner() public returns(bool) {\r\n        require(address(token) == 0);\r\n        require(_wallet != 0);\r\n        token = _token;\r\n        wallet = _wallet;\r\n        salesStart = _start;\r\n        salesDeadline = _deadline;\r\n        return true;\r\n    }\r\n\r\n    function setSalePause(bool _value) onlyContractOwner() public returns(bool) {\r\n        salePaused = _value;\r\n        LogPaused(_value);\r\n        return true;\r\n    }\r\n\r\n    function setWallet(address _wallet) onlyContractOwner() public returns(bool) {\r\n        require(_wallet != 0);\r\n        wallet = _wallet;\r\n        LogWalletUpdated(_wallet);\r\n        return true;\r\n    }\r\n\r\n    function transferOwnership() onlyContractOwner() public returns(bool) {\r\n        token.transferOwnership(contractOwner);\r\n        return true;\r\n    }\r\n\r\n    function burnUnsold() onlyContractOwner() public returns(bool) {\r\n        uint tokensToBurn = token.balanceOf(address(this));\r\n        token.burn(tokensToBurn);\r\n        return true;\r\n    }\r\n\r\n    function buy() payable notPaused() public returns(bool) {\r\n        require(now >= salesStart);\r\n        require(now < salesDeadline);\r\n\r\n        // Overflow is impossible because amounts are calculated based on actual ETH being sent.\r\n        // There is no division remainder.\r\n        uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;\r\n        require(tokensToBuy > 0);\r\n        uint timeBonus = _calculateTimeBonus(tokensToBuy, now);\r\n        uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);\r\n        // Overflow is impossible because amounts are calculated based on actual ETH being sent.\r\n        uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;\r\n        require(token.transfer(msg.sender, totalTokensToTransfer));\r\n        LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);\r\n        // Call is performed as the last action, no threats.\r\n        require(wallet.call.value(msg.value)());\r\n        return true;\r\n    }\r\n\r\n    function buyWithCustomerId(address _beneficiary, uint _value, uint _amount, uint128 _customerId, uint _date, bool _autobonus) onlyContractOwner() public returns(bool) {\r\n        uint totalTokensToTransfer;\r\n        uint volumeBonus;\r\n\r\n        if (_autobonus) {\r\n            uint tokensToBuy = _value.mul(MULTIPLIER).div(TOKEN_PRICE);\r\n            require(tokensToBuy > 0);\r\n            uint timeBonus = _calculateTimeBonus(tokensToBuy, _date);\r\n            volumeBonus = _calculateVolumeBonus(tokensToBuy, _beneficiary, _value);\r\n            // Overflow is possible because value is specified in the input.\r\n            totalTokensToTransfer = tokensToBuy.add(timeBonus).add(volumeBonus);\r\n        } else {\r\n            totalTokensToTransfer = _amount;\r\n        }\r\n\r\n        require(token.transfer(_beneficiary, totalTokensToTransfer));\r\n        LogBought(_beneficiary, _value, totalTokensToTransfer, _customerId);\r\n        return true;\r\n    }\r\n\r\n    function _calculateTimeBonus(uint _value, uint _date) view internal returns(uint) {\r\n        // Overflows are possible because value is specified in the input.\r\n        if (_date < salesStart) {\r\n            return 0;\r\n        }\r\n        // between 07.01.2018 00:00:00 UTC and 14.01.2018 00:00:00 UTC +15%\r\n        if (_date < salesStart + 1 weeks) {\r\n            return _value.mul(150).div(1000);\r\n        }\r\n        // between 14.01.2018 00:00:00 UTC and 21.01.2018 00:00:00 UTC +10%\r\n        if (_date < salesStart + 2 weeks) {\r\n            return _value.mul(100).div(1000);\r\n        }\r\n        // between 21.01.2018 00:00:00 UTC and 28.01.2018 00:00:00 UTC +7%\r\n        if (_date < salesStart + 3 weeks) {\r\n            return _value.mul(70).div(1000);\r\n        }\r\n        // between 28.01.2018 00:00:00 UTC and 04.02.2018 00:00:00 UTC +4%\r\n        if (_date < salesStart + 4 weeks) {\r\n            return _value.mul(40).div(1000);\r\n        }\r\n        // between 04.02.2018 00:00:00 UTC and 11.02.2018 00:00:00 UTC +2%\r\n        if (_date < salesStart + 5 weeks) {\r\n            return _value.mul(20).div(1000);\r\n        }\r\n        // between 11.02.2018 00:00:00 UTC and 15.02.2018 23:59:59 UTC +1%\r\n        if (_date < salesDeadline) {\r\n            return _value.mul(10).div(1000);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function _calculateVolumeBonus(uint _amount, address _receiver, uint _value) internal returns(uint) {\r\n        // Overflows are possible because amount and value are specified in the input.\r\n        uint totalCollected = totalTokensWithoutBonuses[_receiver].add(_amount);\r\n        uint totalEth = totalSpentEth[_receiver].add(_value);\r\n        uint totalBonus;\r\n\r\n        if (totalEth < 30 ether) {\r\n            totalBonus = 0;\r\n        } else if (totalEth < 50 ether) {\r\n            totalBonus = totalCollected.mul(10).div(1000);\r\n        } else if (totalEth < 100 ether) {\r\n            totalBonus = totalCollected.mul(25).div(1000);\r\n        } else if (totalEth < 300 ether) {\r\n            totalBonus = totalCollected.mul(50).div(1000);\r\n        } else if (totalEth < 500 ether) {\r\n            totalBonus = totalCollected.mul(80).div(1000);\r\n        } else if (totalEth < 1000 ether) {\r\n            totalBonus = totalCollected.mul(150).div(1000);\r\n        } else if (totalEth < 2000 ether) {\r\n            totalBonus = totalCollected.mul(200).div(1000);\r\n        } else if (totalEth < 3000 ether) {\r\n            totalBonus = totalCollected.mul(300).div(1000);\r\n        } else if (totalEth >= 3000 ether) {\r\n            totalBonus = totalCollected.mul(400).div(1000);\r\n        }\r\n\r\n        // Overflow is impossible because totalBonus is always >= volumeBonusesTokens[_receiver];\r\n        uint bonusToPay = totalBonus - volumeBonusesTokens[_receiver];\r\n        volumeBonusesTokens[_receiver] = totalBonus;\r\n\r\n        totalSpentEth[_receiver] = totalEth;\r\n        totalTokensWithoutBonuses[_receiver] = totalCollected;\r\n        return bonusToPay;\r\n    }\r\n\r\n    function () payable public {\r\n        buy();\r\n    }\r\n\r\n    // In case somebody sends tokens here.\r\n    function recoverTokens(Token _token, uint _amount) onlyContractOwner() public returns(bool) {\r\n        return _token.transfer(contractOwner, _amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalTokensWithoutBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"salePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_customerId\",\"type\":\"uint128\"},{\"name\":\"_date\",\"type\":\"uint256\"},{\"name\":\"_autobonus\",\"type\":\"bool\"}],\"name\":\"buyWithCustomerId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"salesDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnUnsold\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalSpentEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"salesStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setSalePause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"forceChangeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"volumeBonusesTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customerId\",\"type\":\"uint128\"}],\"name\":\"LogBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"LogPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LogWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LogContractOwnershipChangeInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LogContractOwnershipChangeCompleted\",\"type\":\"event\"}]","ContractName":"NeuroSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://aa99b6c09e722302271b36d14289c61d2175fceb1fd601513e4f20e7b38267ff"}]}