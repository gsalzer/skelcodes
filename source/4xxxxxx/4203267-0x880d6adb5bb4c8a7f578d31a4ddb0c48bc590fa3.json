{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n *\r\n *  STEAK TOKEN (BOV)\r\n *\r\n *  Make bank by eating flank. See https://steaktoken.com.\r\n *\r\n */\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\n library SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\n contract Ownable {\r\n  address public owner;\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract SteakToken is Ownable {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  string public name = \"Steak Token\";\r\n  string public symbol = \"BOV\";\r\n  uint public decimals = 18;\r\n  uint public totalSupply;      // Total BOV in circulation.\r\n\r\n  mapping(address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed ownerAddress, address indexed spenderAddress, uint256 value);\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MineFinished();\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    if(msg.data.length < (2 * 32) + 4) { revert(); } // protect against short address attack\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n   function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   */\r\n   function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n    /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will recieve the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n   function mint(address _to, uint256 _amount) internal returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AuctionCrowdsale \r\n * @dev The owner starts and ends the crowdsale manually.\r\n * Players can make token purchases during the crowdsale\r\n * and their tokens can be claimed after the sale ends.\r\n * Players receive an amount proportional to their investment.\r\n */\r\n contract AuctionCrowdsale is SteakToken {\r\n  using SafeMath for uint;\r\n\r\n  uint public initialSale;                  // Amount of BOV tokens being sold during crowdsale.\r\n\r\n  bool public saleStarted;\r\n  bool public saleEnded;\r\n\r\n  uint public absoluteEndBlock;             // Anybody can end the crowdsale and trigger token distribution if beyond this block number.\r\n\r\n  uint256 public weiRaised;                 // Total amount raised in crowdsale.\r\n\r\n  address[] public investors;               // Investor addresses\r\n  uint public numberOfInvestors;\r\n  mapping(address => uint256) public investments; // How much each address has invested.\r\n\r\n  mapping(address => bool) public claimed;      // Keep track of whether each investor has been awarded their BOV tokens.\r\n\r\n\r\n  bool public bovBatchDistributed;              // TODO: this can be removed with manual crowdsale end-time\r\n\r\n  uint public initialPrizeWeiValue;             // The first steaks mined will be awarded BOV equivalent to this ETH value. Set in Steak() initializer.\r\n  uint public initialPrizeBov;                  // Initial mining prize in BOV units. Set in endCrowdsale() or endCrowdsalePublic().\r\n\r\n  uint public dailyHashExpires;        // When the dailyHash expires. Will be roughly around 3am EST.\r\n\r\n\r\n\r\n\r\n\r\n  /**\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   */ \r\n   event TokenInvestment(address indexed purchaser, address indexed beneficiary, uint256 value);\r\n\r\n\r\n\r\n   // Sending ETH to this contract's address registers the investment.\r\n   function () payable {\r\n    invest(msg.sender);\r\n  }\r\n\r\n\r\n  // Participate in the crowdsale.\r\n  // Records how much each address has invested.\r\n  function invest(address beneficiary) payable {\r\n    require(beneficiary != 0x0);\r\n    require(validInvestment());\r\n\r\n    uint256 weiAmount = msg.value;\r\n\r\n    uint investedAmount = investments[beneficiary];\r\n\r\n    forwardFunds();\r\n\r\n    if (investedAmount > 0) { // If they've already invested, increase their balance.\r\n      investments[beneficiary] = investedAmount + weiAmount; // investedAmount.add(weiAmount);\r\n    } else { // If new investor\r\n      investors.push(beneficiary);\r\n      numberOfInvestors += 1;\r\n      investments[beneficiary] = weiAmount;\r\n    }\r\n    weiRaised = weiRaised.add(weiAmount);\r\n    TokenInvestment(msg.sender, beneficiary, weiAmount);\r\n  }\r\n\r\n\r\n\r\n  // @return true if the transaction can invest\r\n  function validInvestment() internal constant returns (bool) {\r\n    bool withinPeriod = saleStarted && !saleEnded;\r\n    bool nonZeroPurchase = (msg.value > 0);\r\n    return withinPeriod && nonZeroPurchase;\r\n  }\r\n\r\n\r\n\r\n\r\n  // Distribute 10M tokens proportionally amongst all investors. Can be called by anyone after the crowdsale ends.\r\n  // ClaimTokens() can be run by individuals to claim their tokens.\r\n  function distributeAllTokens() public {\r\n\r\n    require(!bovBatchDistributed);\r\n    require(crowdsaleHasEnded());\r\n\r\n    // Allocate BOV proportionally to each investor.\r\n\r\n    for (uint i=0; i < numberOfInvestors; i++) {\r\n      address investorAddr = investors[i];\r\n      if (!claimed[investorAddr]) { // If the investor hasn't already claimed their BOV.\r\n        claimed[investorAddr] = true;\r\n        uint amountInvested = investments[investorAddr];\r\n        uint bovEarned = amountInvested.mul(initialSale).div(weiRaised);\r\n        mint(investorAddr, bovEarned);\r\n      }\r\n    }\r\n\r\n    bovBatchDistributed = true;\r\n  }\r\n\r\n\r\n  // Claim your BOV; allocates BOV proportionally to this investor.\r\n  // Can be called by investors to claim their BOV after the crowdsale ends.\r\n  // distributeAllTokens() is a batch alternative to this.\r\n  function claimTokens(address origAddress) public {\r\n    require(crowdsaleHasEnded());\r\n    require(claimed[origAddress] == false);\r\n    uint amountInvested = investments[origAddress];\r\n    uint bovEarned = amountInvested.mul(initialSale).div(weiRaised);\r\n    claimed[origAddress] = true;\r\n    mint(origAddress, bovEarned);\r\n  }\r\n\r\n\r\n  // Investors: see how many BOV you are currently entitled to (before the end of the crowdsale and distribution of tokens).\r\n  function getCurrentShare(address addr) public constant returns (uint) {\r\n    require(!bovBatchDistributed && !claimed[addr]); // Tokens cannot have already been distributed.\r\n    uint amountInvested = investments[addr];\r\n    uint currentBovShare = amountInvested.mul(initialSale).div(weiRaised);\r\n    return currentBovShare;\r\n  }\r\n\r\n\r\n\r\n  // send ether to the fund collection wallet\r\n  function forwardFunds() internal {\r\n    owner.transfer(msg.value);\r\n  }\r\n\r\n\r\n  // The owner manually starts the crowdsale at a pre-determined time.\r\n  function startCrowdsale() onlyOwner {\r\n    require(!saleStarted && !saleEnded);\r\n    saleStarted = true;\r\n  }\r\n\r\n  // endCrowdsale() and endCrowdsalePublic() moved to Steak contract\r\n    // Normally, the owner will end the crowdsale at the pre-determined time.\r\n  function endCrowdsale() onlyOwner {\r\n    require(saleStarted && !saleEnded);\r\n    dailyHashExpires = now; // Will end crowdsale at 3am EST, so expiration time will roughly be around 3am.\r\n    saleEnded = true;\r\n    setInitialPrize();\r\n  }\r\n\r\n  // Normally, Madame BOV ends the crowdsale at the pre-determined time, but if Madame BOV fails to do so, anybody can trigger endCrowdsalePublic() after absoluteEndBlock.\r\n  function endCrowdsalePublic() public {\r\n    require(block.number > absoluteEndBlock);\r\n    require(saleStarted && !saleEnded);\r\n    dailyHashExpires = now;\r\n    saleEnded = true;\r\n    setInitialPrize();\r\n  }\r\n\r\n\r\n  // Calculate initial mining prize (0.0357 ether's worth of BOV). This is called in endCrowdsale().\r\n  function setInitialPrize() internal returns (uint) {\r\n    require(crowdsaleHasEnded());\r\n    require(initialPrizeBov == 0); // Can only be set once\r\n    uint tokenUnitsPerWei = initialSale.div(weiRaised);\r\n    initialPrizeBov = tokenUnitsPerWei.mul(initialPrizeWeiValue);\r\n    return initialPrizeBov;\r\n  }\r\n\r\n\r\n  // @return true if crowdsale event has ended\r\n  function crowdsaleHasEnded() public constant returns (bool) {\r\n    return saleStarted && saleEnded;\r\n  }\r\n\r\n  function getInvestors() public returns (address[]) {\r\n    return investors;\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Steak is AuctionCrowdsale {\r\n  // using SafeMath for uint;\r\n\r\n  bytes32 public dailyHash;            // The last five digits of the dailyHash must be included in steak pictures.\r\n\r\n\r\n  Submission[] public submissions;          // All steak pics\r\n  uint public numSubmissions;\r\n\r\n  Submission[] public approvedSubmissions;\r\n  mapping (address => uint) public memberId;    // Get member ID from address.\r\n  Member[] public members;                      // Index is memberId\r\n\r\n  uint public halvingInterval;                  // BOV award is halved every x steaks\r\n  uint public numberOfHalvings;                 // How many times the BOV reward per steak is halved before it returns 0. \r\n\r\n\r\n\r\n  uint public lastMiningBlock;                  // No mining after this block. Set in initializer.\r\n\r\n  bool public ownerCredited;    // Has the owner been credited BOV yet?\r\n\r\n  event PicAdded(address msgSender, uint submissionID, address recipient, bytes32 propUrl); // Need msgSender so we can watch for this event.\r\n  event Judged(uint submissionID, bool position, address voter, bytes32 justification);\r\n  event MembershipChanged(address member, bool isMember);\r\n\r\n  struct Submission {\r\n    address recipient;    // Would-be BOV recipient\r\n    bytes32 url;           // IMGUR url; 32-char max\r\n    bool judged;          // Has an admin voted?\r\n    bool submissionApproved;// Has it been approved?\r\n    address judgedBy;     // Admin who judged this steak\r\n    bytes32 adminComments; // Admin should leave feedback on non-approved steaks. 32-char max.\r\n    bytes32 todaysHash;   // The hash in the image should match this hash.\r\n    uint awarded;         // Amount awarded\r\n  }\r\n\r\n  // Members can vote on steak\r\n  struct Member {\r\n    address member;\r\n    bytes32 name;\r\n    uint memberSince;\r\n  }\r\n\r\n\r\n  modifier onlyMembers {\r\n    require(memberId[msg.sender] != 0); // member id must be in the mapping\r\n    _;\r\n  }\r\n\r\n\r\n  function Steak() {\r\n\r\n    owner = msg.sender;\r\n    initialSale = 10000000 * 1000000000000000000; // 10M BOV units are awarded in the crowdsale.\r\n\r\n    // Normally, the owner both starts and ends the crowdsale.\r\n    // To guarantee that the crowdsale ends at some maximum point (at that tokens are distributed),\r\n    // we calculate the absoluteEndBlock, the block beyond which anybody can end the crowdsale and distribute tokens.\r\n    uint blocksPerHour = 212;\r\n    uint maxCrowdsaleLifeFromLaunchDays = 40; // After about this many days from launch, anybody can end the crowdsale and distribute / claim their tokens. \r\n    absoluteEndBlock = block.number + (blocksPerHour * 24 * maxCrowdsaleLifeFromLaunchDays);\r\n\r\n    uint miningDays = 365; // Approximately how many days BOV can be mined from the launch of the contract.\r\n    lastMiningBlock = block.number + (blocksPerHour * 24 * miningDays);\r\n\r\n    dailyHashExpires = now;\r\n\r\n    halvingInterval = 500;    // How many steaks get awarded the given getSteakPrize() amount before the reward is halved.\r\n    numberOfHalvings = 8;      // How many times the steak prize gets halved before no more prize is awarded.\r\n\r\n    // initialPrizeWeiValue = 50 finney; // 0.05 ether == 50 finney == 2.80 USD * 5 == 14 USD\r\n    initialPrizeWeiValue = (357 finney / 10); // 0.0357 ether == 35.7 finney == 2.80 USD * 3.57 == 9.996 USD\r\n\r\n    // To finish initializing, owner calls initMembers() and creditOwner() after launch.\r\n  }\r\n\r\n\r\n  // Add Madame BOV as a beef judge.\r\n  function initMembers() onlyOwner {\r\n    addMember(0, '');                        // Must add an empty first member\r\n    addMember(msg.sender, 'Madame BOV');\r\n  }\r\n\r\n\r\n\r\n  // Send 1M BOV to Madame BOV. \r\n  function creditOwner() onlyOwner {\r\n    require(!ownerCredited);\r\n    uint ownerAward = initialSale / 10;  // 10% of the crowdsale amount.\r\n    ownerCredited = true;   // Can only be run once.\r\n    mint(owner, ownerAward);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  /* Add beef judge */\r\n  function addMember(address targetMember, bytes32 memberName) onlyOwner {\r\n    uint id;\r\n    if (memberId[targetMember] == 0) {\r\n      memberId[targetMember] = members.length;\r\n      id = members.length++;\r\n      members[id] = Member({member: targetMember, memberSince: now, name: memberName});\r\n    } else {\r\n      id = memberId[targetMember];\r\n      // Member m = members[id];\r\n    }\r\n    MembershipChanged(targetMember, true);\r\n  }\r\n\r\n  function removeMember(address targetMember) onlyOwner {\r\n    if (memberId[targetMember] == 0) revert();\r\n\r\n    memberId[targetMember] = 0;\r\n\r\n    for (uint i = memberId[targetMember]; i<members.length-1; i++){\r\n      members[i] = members[i+1];\r\n    }\r\n    delete members[members.length-1];\r\n    members.length--;\r\n  }\r\n\r\n\r\n\r\n  /* Submit a steak picture. (After crowdsale has ended.)\r\n  *  WARNING: Before taking the picture, call getDailyHash() and  minutesToPost()\r\n  *  so you can be sure that you have the correct dailyHash and that it won't expire before you post it.\r\n  */\r\n  function submitSteak(address addressToAward, bytes32 steakPicUrl)  returns (uint submissionID) {\r\n    require(crowdsaleHasEnded());\r\n    require(block.number <= lastMiningBlock); // Cannot submit beyond this block.\r\n    submissionID = submissions.length++; // Increase length of array\r\n    Submission storage s = submissions[submissionID];\r\n    s.recipient = addressToAward;\r\n    s.url = steakPicUrl;\r\n    s.judged = false;\r\n    s.submissionApproved = false;\r\n    s.todaysHash = getDailyHash(); // Each submission saves the hash code the user should take picture of in steak picture.\r\n\r\n    PicAdded(msg.sender, submissionID, addressToAward, steakPicUrl);\r\n    numSubmissions = submissionID+1;\r\n\r\n    return submissionID;\r\n  }\r\n\r\n  // Retrieving any Submission must be done via this function, not `submissions()`\r\n  function getSubmission(uint submissionID) public constant returns (address recipient, bytes32 url, bool judged, bool submissionApproved, address judgedBy, bytes32 adminComments, bytes32 todaysHash, uint awarded) {\r\n    Submission storage s = submissions[submissionID];\r\n    recipient = s.recipient;\r\n    url = s.url;                 // IMGUR url\r\n    judged = s.judged;           // Has an admin voted?\r\n    submissionApproved = s.submissionApproved;  // Has it been approved?\r\n    judgedBy = s.judgedBy;           // Admin who judged this steak\r\n    adminComments = s.adminComments; // Admin should leave feedback on non-approved steaks\r\n    todaysHash = s.todaysHash;       // The hash in the image should match this hash.\r\n    awarded = s.awarded;         // Amount awarded   // return (users[index].salaryId, users[index].name, users[index].userAddress, users[index].salary);\r\n    // return (recipient, url, judged, submissionApproved, judgedBy, adminComments, todaysHash, awarded);\r\n  }\r\n\r\n\r\n\r\n  // Members judge steak pics, providing justification if necessary.\r\n  function judge(uint submissionNumber, bool supportsSubmission, bytes32 justificationText) onlyMembers {\r\n    Submission storage s = submissions[submissionNumber];         // Get the submission.\r\n    require(!s.judged);                                     // Musn't be judged.\r\n\r\n    s.judged = true;\r\n    s.judgedBy = msg.sender;\r\n    s.submissionApproved = supportsSubmission;\r\n    s.adminComments = justificationText;    // Admin can add comments whether approved or not\r\n\r\n    if (supportsSubmission) { // If it passed muster, credit the user and admin.\r\n      uint prizeAmount = getSteakPrize(); // Calculate BOV prize\r\n      s.awarded = prizeAmount;            // Record amount in the Submission\r\n      mint(s.recipient, prizeAmount);     // Credit the user's account\r\n\r\n      // Credit the member one-third of the prize amount.\r\n      uint adminAward = prizeAmount.div(3);\r\n      mint(msg.sender, adminAward);\r\n\r\n      approvedSubmissions.push(s);\r\n    }\r\n\r\n    Judged(submissionNumber, supportsSubmission, msg.sender, justificationText);\r\n  }\r\n\r\n\r\n  // Calculate how many BOV are rewarded per approved steak pic.\r\n  function getSteakPrize() public constant returns (uint) {\r\n    require(initialPrizeBov > 0); // crowdsale must be over (endCrowdsale() calls setInitialPrize())\r\n    uint halvings = numberOfApprovedSteaks().div(halvingInterval);\r\n    if (halvings > numberOfHalvings) {  // After 8 halvings, no more BOV is awarded.\r\n      return 0;\r\n    }\r\n\r\n    uint prize = initialPrizeBov;\r\n\r\n    prize = prize >> halvings; // Halve the initial prize \"halvings\"-number of times.\r\n    return prize;\r\n  }\r\n\r\n\r\n  function numberOfApprovedSteaks() public constant returns (uint) {\r\n    return approvedSubmissions.length;\r\n  }\r\n\r\n\r\n  // Always call this before calling dailyHash and submitting a steak.\r\n  // If expired, the new hash is set to the last block's hash.\r\n  function getDailyHash() public returns (bytes32) {\r\n    if (dailyHashExpires > now) { // If the hash hasn't expired yet, return it.\r\n      return dailyHash;\r\n    } else { // Udderwise, set the new dailyHash and dailyHashExpiration.\r\n\r\n      // Get hash from the last block.\r\n      bytes32 newHash = block.blockhash(block.number-1);\r\n      dailyHash = newHash;\r\n\r\n      // Set the new expiration, jumping ahead in 24-hour increments so the expiration time remains roughly constant from day to day (e.g. 3am).\r\n      uint nextExpiration = dailyHashExpires + 24 hours; // It will already be expired, so set it to next possible date.\r\n      while (nextExpiration < now) { // if it's still in the past, advance by 24 hours.\r\n        nextExpiration += 24 hours;\r\n      }\r\n      dailyHashExpires = nextExpiration;\r\n      return newHash;\r\n    }\r\n  }\r\n\r\n  // Returns the amount of minutes to post with the current dailyHash\r\n  function minutesToPost() public constant returns (uint) {\r\n    if (dailyHashExpires > now) {\r\n      return (dailyHashExpires - now) / 60; // returns minutes\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function currentBlock() public constant returns (uint) {\r\n    return block.number;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrizeWeiValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"absoluteEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"creditOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleHasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getDailyHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributeAllTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfHalvings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedSubmissions\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"url\",\"type\":\"bytes32\"},{\"name\":\"judged\",\"type\":\"bool\"},{\"name\":\"submissionApproved\",\"type\":\"bool\"},{\"name\":\"judgedBy\",\"type\":\"address\"},{\"name\":\"adminComments\",\"type\":\"bytes32\"},{\"name\":\"todaysHash\",\"type\":\"bytes32\"},{\"name\":\"awarded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initMembers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"submissionID\",\"type\":\"uint256\"}],\"name\":\"getSubmission\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"url\",\"type\":\"bytes32\"},{\"name\":\"judged\",\"type\":\"bool\"},{\"name\":\"submissionApproved\",\"type\":\"bool\"},{\"name\":\"judgedBy\",\"type\":\"address\"},{\"name\":\"adminComments\",\"type\":\"bytes32\"},{\"name\":\"todaysHash\",\"type\":\"bytes32\"},{\"name\":\"awarded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSteakPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"},{\"name\":\"memberName\",\"type\":\"bytes32\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minutesToPost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastMiningBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"memberSince\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrizeBov\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halvingInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numSubmissions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsalePublic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bovBatchDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"submissions\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"url\",\"type\":\"bytes32\"},{\"name\":\"judged\",\"type\":\"bool\"},{\"name\":\"submissionApproved\",\"type\":\"bool\"},{\"name\":\"judgedBy\",\"type\":\"address\"},{\"name\":\"adminComments\",\"type\":\"bytes32\"},{\"name\":\"todaysHash\",\"type\":\"bytes32\"},{\"name\":\"awarded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addressToAward\",\"type\":\"address\"},{\"name\":\"steakPicUrl\",\"type\":\"bytes32\"}],\"name\":\"submitSteak\",\"outputs\":[{\"name\":\"submissionID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dailyHashExpires\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getCurrentShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfApprovedSteaks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"submissionNumber\",\"type\":\"uint256\"},{\"name\":\"supportsSubmission\",\"type\":\"bool\"},{\"name\":\"justificationText\",\"type\":\"bytes32\"}],\"name\":\"judge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCredited\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"origAddress\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"submissionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"propUrl\",\"type\":\"bytes32\"}],\"name\":\"PicAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"submissionID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"justification\",\"type\":\"bytes32\"}],\"name\":\"Judged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isMember\",\"type\":\"bool\"}],\"name\":\"MembershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spenderAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MineFinished\",\"type\":\"event\"}]","ContractName":"Steak","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://234899b978ae8e2d2ddc2ae4c57bfa6cd5da9524f9f89cfc4dd9d4c6e77fdc87"}]}