{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract IMintableToken {\r\n    function mint(address _to, uint256 _amount) returns (bool);\r\n    function finishMinting() returns (bool);\r\n}\r\n\r\ncontract PricingStrategy {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint public rate0;\r\n    uint public rate1;\r\n    uint public rate2;\r\n\r\n    uint public threshold1;\r\n    uint public threshold2;\r\n\r\n    uint public minimumWeiAmount;\r\n\r\n    function PricingStrategy(\r\n        uint _rate0,\r\n        uint _rate1,\r\n        uint _rate2,\r\n        uint _minimumWeiAmount,\r\n        uint _threshold1,\r\n        uint _threshold2\r\n    ) {\r\n        require(_rate0 > 0);\r\n        require(_rate1 > 0);\r\n        require(_rate2 > 0);\r\n        require(_minimumWeiAmount > 0);\r\n        require(_threshold1 > 0);\r\n        require(_threshold2 > 0);\r\n\r\n        rate0 = _rate0;\r\n        rate1 = _rate1;\r\n        rate2 = _rate2;\r\n        minimumWeiAmount = _minimumWeiAmount;\r\n        threshold1 = _threshold1;\r\n        threshold2 = _threshold2;\r\n    }\r\n\r\n    /** Interface declaration. */\r\n    function isPricingStrategy() public constant returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /** Calculate the current price for buy in amount. */\r\n    function calculateTokenAmount(uint weiAmount) public constant returns (uint tokenAmount) {\r\n        uint bonusRate = 0;\r\n\r\n        if (weiAmount >= minimumWeiAmount) {\r\n            bonusRate = rate0;\r\n        }\r\n\r\n        if (weiAmount >= threshold1) {\r\n            bonusRate = rate1;\r\n        }\r\n\r\n        if (weiAmount >= threshold2) {\r\n            bonusRate = rate2;\r\n        }\r\n\r\n        return weiAmount.mul(bonusRate);\r\n    }\r\n}\r\n\r\ncontract Presale is Pausable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /* Max investment count when we are still allowed to change the multisig address */\r\n    uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 500;\r\n\r\n    /* The token we are selling */\r\n    IMintableToken public token;\r\n\r\n    /* How we are going to price our offering */\r\n    PricingStrategy public pricingStrategy;\r\n\r\n    /* tokens will be transfered from this address */\r\n    address public multisigWallet;\r\n\r\n    /* if the funding goal is not reached, investors may withdraw their funds */\r\n    uint public minimumFundingGoal;\r\n\r\n    /* the UNIX timestamp start date of the presale */\r\n    uint public startsAt;\r\n\r\n    /* the UNIX timestamp end date of the presale */\r\n    uint public endsAt;\r\n\r\n    /* Maximum amount of tokens this presale can sell. */\r\n    uint public tokensHardCap;\r\n\r\n    /* the number of tokens already sold through this contract*/\r\n    uint public tokensSold = 0;\r\n\r\n    /* How many wei of funding we have raised */\r\n    uint public weiRaised = 0;\r\n\r\n    /* How many distinct addresses have invested */\r\n    uint public investorCount = 0;\r\n\r\n    /* How much wei we have returned back to the contract after a failed crowdfund. */\r\n    uint public loadedRefund = 0;\r\n\r\n    /* How much wei we have given back to investors.*/\r\n    uint public weiRefunded = 0;\r\n\r\n    /** How much ETH each address has invested to this presale */\r\n    mapping (address => uint256) public investedAmountOf;\r\n\r\n    /** How much tokens this presale has credited for each investor address */\r\n    mapping (address => uint256) public tokenAmountOf;\r\n\r\n    /** Addresses that are allowed to invest even before ICO offical opens. Only for testing purpuses. */\r\n    mapping (address => bool) public earlyParticipantWhitelist;\r\n\r\n    /** State machine\r\n    *\r\n    * - Preparing: All contract initialization calls and variables have not been set yet\r\n    * - Prefunding: We have not passed start time yet\r\n    * - Funding: Active presale\r\n    * - Success: Minimum funding goal reached\r\n    * - Failure: Minimum funding goal not reached before ending time\r\n    * - Refunding: Refunds are loaded on the contract for reclaim.\r\n    */\r\n    enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Refunding}\r\n\r\n    // A new investment was made\r\n    event Invested(address investor, uint weiAmount, uint tokenAmount);\r\n\r\n    // Refund was processed for a contributor\r\n    event Refund(address investor, uint weiAmount);\r\n\r\n    // Address early participation whitelist status changed\r\n    event Whitelisted(address addr, bool status);\r\n\r\n    // Presale end time has been changed\r\n    event EndsAtChanged(uint endsAt);\r\n\r\n    function Presale(\r\n        address _token, \r\n        address _pricingStrategy, \r\n        address _multisigWallet, \r\n        uint _start, \r\n        uint _end, \r\n        uint _tokensHardCap,\r\n        uint _minimumFundingGoal\r\n    ) {\r\n        require(_token != 0);\r\n        require(_pricingStrategy != 0);\r\n        require(_multisigWallet != 0);\r\n        require(_start != 0);\r\n        require(_end != 0);\r\n        require(_start < _end);\r\n        require(_tokensHardCap != 0);\r\n\r\n        token = IMintableToken(_token);\r\n        setPricingStrategy(_pricingStrategy);\r\n        multisigWallet = _multisigWallet;\r\n        startsAt = _start;\r\n        endsAt = _end;\r\n        tokensHardCap = _tokensHardCap;\r\n        minimumFundingGoal = _minimumFundingGoal;\r\n    }\r\n\r\n    /**\r\n    * Buy tokens\r\n    */\r\n    function() payable {\r\n        invest(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * Make an investment.\r\n    *\r\n    * Presale must be running for one to invest.\r\n    * We must have not pressed the emergency brake.\r\n    *\r\n    * @param receiver The Ethereum address who receives the tokens\r\n    */\r\n    function invest(address receiver) whenNotPaused payable {\r\n\r\n        // Determine if it's a good time to accept investment from this participant\r\n        if (getState() == State.PreFunding) {\r\n            // Are we whitelisted for early deposit\r\n            require(earlyParticipantWhitelist[receiver]);\r\n        } else {\r\n            require(getState() == State.Funding);\r\n        }\r\n\r\n        uint weiAmount = msg.value;\r\n\r\n        // Account presale sales separately, so that they do not count against pricing tranches\r\n        uint tokenAmount = pricingStrategy.calculateTokenAmount(weiAmount);\r\n\r\n        // Dust transaction\r\n        require(tokenAmount > 0);\r\n\r\n        if (investedAmountOf[receiver] == 0) {\r\n            // A new investor\r\n            investorCount++;\r\n        }\r\n\r\n        // Update investor\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\r\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\r\n\r\n        // Update totals\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokensSold = tokensSold.add(tokenAmount);\r\n\r\n        // Check that we did not bust the cap\r\n        require(!isBreakingCap(tokensSold));\r\n\r\n        token.mint(receiver, tokenAmount);\r\n\r\n        // Pocket the money\r\n        multisigWallet.transfer(weiAmount);\r\n\r\n        // Tell us invest was success\r\n        Invested(receiver, weiAmount, tokenAmount);\r\n    }\r\n\r\n    /**\r\n    * Allow addresses to do early participation.\r\n    *\r\n    */\r\n    function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\r\n        earlyParticipantWhitelist[addr] = status;\r\n        Whitelisted(addr, status);\r\n    }\r\n\r\n    /**\r\n    * Allow presale owner to close early or extend the presale.\r\n    *\r\n    * This is useful e.g. for a manual soft cap implementation:\r\n    * - after X amount is reached determine manual closing\r\n    *\r\n    * This may put the presale to an invalid state,\r\n    * but we trust owners know what they are doing.\r\n    *\r\n    */\r\n    function setEndsAt(uint time) onlyOwner {\r\n\r\n        require(now <= time);\r\n\r\n        endsAt = time;\r\n        EndsAtChanged(endsAt);\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set pricing strategy.\r\n    *\r\n    * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\n    */\r\n    function setPricingStrategy(address _pricingStrategy) onlyOwner {\r\n        pricingStrategy = PricingStrategy(_pricingStrategy);\r\n\r\n        // Don't allow setting bad agent\r\n        require(pricingStrategy.isPricingStrategy());\r\n    }\r\n\r\n    /**\r\n    * Allow to change the team multisig address in the case of emergency.\r\n    *\r\n    * This allows to save a deployed presale wallet in the case the presale has not yet begun\r\n    * (we have done only few test transactions). After the presale is going\r\n    * then multisig address stays locked for the safety reasons.\r\n    */\r\n    function setMultisig(address addr) public onlyOwner {\r\n\r\n        require(investorCount <= MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE);\r\n\r\n        multisigWallet = addr;\r\n    }\r\n\r\n    /**\r\n    * Allow load refunds back on the contract for the refunding.\r\n    *\r\n    * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\n    */\r\n    function loadRefund() public payable inState(State.Failure) {\r\n        require(msg.value > 0);\r\n\r\n        loadedRefund = loadedRefund.add(msg.value);\r\n    }\r\n\r\n    /**\r\n    * Investors can claim refund.\r\n    *\r\n    * Note that any refunds from proxy buyers should be handled separately,\r\n    * and not through this contract.\r\n    */\r\n    function refund() public inState(State.Refunding) {\r\n        uint256 weiValue = investedAmountOf[msg.sender];\r\n        require(weiValue > 0);\r\n\r\n        investedAmountOf[msg.sender] = 0;\r\n        weiRefunded = weiRefunded.add(weiValue);\r\n        Refund(msg.sender, weiValue);\r\n        \r\n        msg.sender.transfer(weiValue);\r\n    }\r\n\r\n    /**\r\n    * Crowdfund state machine management.\r\n    *\r\n    * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\r\n    */\r\n    function getState() public constant returns (State) {\r\n        if (address(pricingStrategy) == 0)\r\n            return State.Preparing;\r\n        else if (block.timestamp < startsAt)\r\n            return State.PreFunding;\r\n        else if (block.timestamp <= endsAt && !isPresaleFull())\r\n            return State.Funding;\r\n        else if (isMinimumGoalReached())\r\n            return State.Success;\r\n        else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised)\r\n            return State.Refunding;\r\n        else\r\n            return State.Failure;\r\n    }\r\n\r\n    /**\r\n    * @return true if the presale has raised enough money to be a successful.\r\n    */\r\n    function isMinimumGoalReached() public constant returns (bool reached) {\r\n        return weiRaised >= minimumFundingGoal;\r\n    }\r\n\r\n    /**\r\n    * Called from invest() to confirm if the curret investment does not break our cap rule.\r\n    */\r\n    function isBreakingCap(uint tokensSoldTotal) constant returns (bool) {\r\n        return tokensSoldTotal > tokensHardCap;\r\n    }\r\n\r\n    function isPresaleFull() public constant returns (bool) {\r\n        return tokensSold >= tokensHardCap;\r\n    }\r\n\r\n    //\r\n    // Modifiers\r\n    //\r\n\r\n    /** Modified allowing execution only if the presale is currently running.  */\r\n    modifier inState(State state) {\r\n        require(getState() == state);\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumFundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pricingStrategy\",\"type\":\"address\"}],\"name\":\"setPricingStrategy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setEndsAt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricingStrategy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loadedRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinimumGoalReached\",\"outputs\":[{\"name\":\"reached\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPresaleFull\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"loadRefund\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyParticipantWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokensSoldTotal\",\"type\":\"uint256\"}],\"name\":\"isBreakingCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setEarlyParicipantWhitelist\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setMultisig\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_pricingStrategy\",\"type\":\"address\"},{\"name\":\"_multisigWallet\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_tokensHardCap\",\"type\":\"uint256\"},{\"name\":\"_minimumFundingGoal\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endsAt\",\"type\":\"uint256\"}],\"name\":\"EndsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"Presale","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007b06ad092541635cf83a1ff03daf713269d94a15000000000000000000000000b9803fe3e2646ed6c5e6b774024101e7418cdee10000000000000000000000006fe56527be2aaf18347dd772fc333504b83c444700000000000000000000000000000000000000000000000000000000599359210000000000000000000000000000000000000000000000000000000059b48080000000000000000000000000000000000000002fcea387507bc85c1e0084c3610000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://d9d8e48fbfb3212637b3e10457b517452710763592e789897cd327d569a518bb"}]}