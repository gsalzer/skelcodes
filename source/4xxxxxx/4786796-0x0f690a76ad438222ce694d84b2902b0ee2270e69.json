{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/** \r\n * BlackBox - Secure Ether Storage\r\n * Proof Of Concept - Lock ether with a proof set derived off-chain.  The proof\r\n * encodes a blinded receiver to accept funds once the correct caller executes \r\n * the unlockAmount() function with the correct seed.\r\n*/ \r\n\r\ncontract Secure {\r\n    enum Algorithm { sha, keccak }\r\n\r\n    // function for off-chain proof derivation.  Use the return values as input for the \r\n    // lockAmount() function.  Execute unlockAmount() with the correct caller \r\n    // and seed to transfer funds to an encoded recipient.\r\n    function generateProof(\r\n        string seed,\r\n        address caller, \r\n        address receiver,\r\n        Algorithm algorithm\r\n    ) pure public returns(bytes32 hash, bytes32 operator, bytes32 check, address check_receiver, bool valid) {\r\n        (hash, operator, check) = _escrow(seed, caller, receiver, algorithm);\r\n        check_receiver = address(hash_data(hash_seed(seed, algorithm), algorithm)^operator);\r\n        valid = (receiver == check_receiver);\r\n        if (check_receiver == 0) check_receiver = caller;\r\n    }\r\n\r\n    function _escrow(\r\n        string seed, \r\n        address caller, \r\n        address receiver,\r\n        Algorithm algorithm\r\n    ) pure internal returns(bytes32 index, bytes32 operator, bytes32 check) {\r\n        require(caller != receiver && caller != 0);\r\n        bytes32 x = hash_seed(seed, algorithm);\r\n        if (algorithm == Algorithm.sha) {\r\n            index = sha256(x, caller);\r\n            operator = sha256(x)^bytes32(receiver);\r\n            check = x^sha256(receiver);\r\n        } else {\r\n            index = keccak256(x, caller);\r\n            operator = keccak256(x)^bytes32(receiver);\r\n            check = x^keccak256(receiver);\r\n        }\r\n    }\r\n    \r\n    // internal function for hashing the seed\r\n    function hash_seed(\r\n        string seed, \r\n        Algorithm algorithm\r\n    ) pure internal returns(bytes32) {\r\n        if (algorithm == Algorithm.sha) {\r\n            return sha256(seed);\r\n        } else {\r\n            return keccak256(seed);\r\n        }\r\n    }\r\n    \r\n   // internal function for hashing bytes\r\n    function hash_data(\r\n        bytes32 key, \r\n        Algorithm algorithm\r\n    ) pure internal returns(bytes32) {\r\n        if (algorithm == Algorithm.sha) {\r\n            return sha256(key);\r\n        } else {\r\n            return keccak256(key);\r\n        }\r\n    }\r\n    \r\n    // internal function for hashing an address\r\n    function blind(\r\n        address addr,\r\n        Algorithm algorithm\r\n    ) pure internal returns(bytes32) {\r\n        if (algorithm == Algorithm.sha) {\r\n            return sha256(addr);\r\n        } else {\r\n            return keccak256(addr);\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract BlackBox is Secure {\r\n    address public owner;\r\n\r\n    // stored proof info\r\n    struct Proof {\r\n        uint256 balance;\r\n        bytes32 operator;\r\n        bytes32 check;\r\n    }\r\n    \r\n    mapping(bytes32 => Proof) public proofs;\r\n    mapping(bytes32 => bool) public used;\r\n    mapping(address => uint256) private donations;\r\n\r\n    // events for audit purposes\r\n    event Unlocked(string _key, bytes32 _hash, address _receiver);\r\n    event Locked(bytes32 _hash, bytes32 _operator, bytes32 _check);\r\n    event Donation(address _from, uint256 value);\r\n    \r\n    function BlackBox() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev lockAmount - Lock ether with a proof\r\n    /// @param hash Hash Key used to index the proof\r\n    /// @param operator A derived operator to encode the intended recipient\r\n    /// @param check A derived operator to check the operation\r\n    function lockAmount(\r\n        bytes32 hash,\r\n        bytes32 operator,\r\n        bytes32 check\r\n    ) public payable {\r\n        // protect invalid entries on value transfer\r\n        if (msg.value > 0) {\r\n            require(hash != 0 && operator != 0 && check != 0);\r\n        }\r\n        // check existence\r\n        require(!used[hash]);\r\n        // lock the ether\r\n        proofs[hash].balance = msg.value;\r\n        proofs[hash].operator = operator;\r\n        proofs[hash].check = check;\r\n        // track unique keys\r\n        used[hash] = true;\r\n        Locked(hash, operator, check);\r\n    }\r\n\r\n    /// @dev unlockAmount - Verify a proof to transfer the locked funds\r\n    /// @param seed Secret used to derive the proof set\r\n    /// @param algorithm Hash algorithm type\r\n    function unlockAmount(\r\n        string seed,\r\n        Algorithm algorithm\r\n    ) public payable {\r\n        require(msg.value == 0);\r\n        bytes32 hash = 0x0;\r\n        bytes32 operator = 0x0;\r\n        bytes32 check = 0x0;\r\n        // calculate the proof\r\n        (hash, operator, check) = _escrow(seed, msg.sender, 0, algorithm);\r\n        // check existence\r\n        require(used[hash]);\r\n        // calculate the receiver and transfer\r\n        address receiver = address(proofs[hash].operator^operator);\r\n        // verify integrity of operation\r\n        require(proofs[hash].check^hash_seed(seed, algorithm) == blind(receiver, algorithm));\r\n        // check for valid transfer\r\n        if (receiver == address(this) || receiver == 0) receiver = msg.sender;\r\n        // get locked balance to avoid recursive attacks\r\n        uint bal = proofs[hash].balance;\r\n        // owner collecting donations\r\n        if (donations[msg.sender] > 0) {\r\n            bal += donations[msg.sender];\r\n            delete donations[msg.sender];\r\n        }\r\n        // delete the entry to free up memory\r\n        delete proofs[hash];\r\n        // check the balance to send to the receiver\r\n        if (bal <= this.balance && bal > 0) {\r\n            // transfer to receiver \r\n            // this could fail if receiver is another contract, so fallback\r\n            if(!receiver.send(bal)){\r\n                require(msg.sender.send(bal));\r\n            }\r\n        }\r\n        Unlocked(seed, hash, receiver);\r\n    }\r\n    \r\n    // deposits get stored for the owner\r\n    function() public payable {\r\n        require(msg.value > 0);\r\n        donations[owner] += msg.value;\r\n        Donation(msg.sender, msg.value);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"bytes32\"},{\"name\":\"check\",\"type\":\"bytes32\"}],\"name\":\"lockAmount\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proofs\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"operator\",\"type\":\"bytes32\"},{\"name\":\"check\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seed\",\"type\":\"string\"},{\"name\":\"caller\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"algorithm\",\"type\":\"uint8\"}],\"name\":\"generateProof\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"bytes32\"},{\"name\":\"check\",\"type\":\"bytes32\"},{\"name\":\"check_receiver\",\"type\":\"address\"},{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"used\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seed\",\"type\":\"string\"},{\"name\":\"algorithm\",\"type\":\"uint8\"}],\"name\":\"unlockAmount\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"Unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_operator\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_check\",\"type\":\"bytes32\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Donation\",\"type\":\"event\"}]","ContractName":"BlackBox","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7da46b4bbc2a38beab4b902e17c572ee16047f7f0719323a0a57dd98ebdaca30"}]}