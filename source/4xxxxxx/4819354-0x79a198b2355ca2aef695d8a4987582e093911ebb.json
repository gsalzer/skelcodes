{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract ERC721 {\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n}\r\n\r\ncontract GeneScienceInterface {\r\n    function isGeneScience() public pure returns (bool);\r\n    function mixGenes(uint256 genes1, uint256 genes2, uint256 targetBlock) public returns (uint256);\r\n}\r\n\r\ncontract BotAccessControl {\r\n    event ContractUpgrade(address newContract);\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n    bool public paused = false;\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\n\r\ncontract BotBase is BotAccessControl {\r\n    event Birth(\r\n      address owner,\r\n      uint256 botId,\r\n      uint256 matronId,\r\n      uint256 sireId,\r\n      uint256 genes,\r\n      uint256 birthTime\r\n    );\r\n\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    struct Bot {\r\n        uint256 genes;\r\n        uint64 birthTime;\r\n        uint64 cooldownEndBlock;\r\n        uint32 matronId;\r\n        uint32 sireId;\r\n        uint32 siringWithId;\r\n        uint16 cooldownIndex;\r\n        uint16 generation;\r\n    }\r\n\r\n    uint32[14] public cooldowns = [\r\n        uint32(1 minutes),\r\n        uint32(2 minutes),\r\n        uint32(5 minutes),\r\n        uint32(10 minutes),\r\n        uint32(30 minutes),\r\n        uint32(1 hours),\r\n        uint32(2 hours),\r\n        uint32(4 hours),\r\n        uint32(8 hours),\r\n        uint32(16 hours),\r\n        uint32(1 days),\r\n        uint32(2 days),\r\n        uint32(4 days),\r\n        uint32(7 days)\r\n    ];\r\n\r\n    uint256 public secondsPerBlock = 15;\r\n\r\n    Bot[] bots;\r\n\r\n    mapping (uint256 => address) public botIndexToOwner;\r\n    mapping (address => uint256) ownershipTokenCount;\r\n    mapping (uint256 => address) public botIndexToApproved;\r\n    mapping (uint256 => address) public sireAllowedToAddress;\r\n    uint32 public destroyedBots;\r\n    SaleClockAuction public saleAuction;\r\n    SiringClockAuction public siringAuction;\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        if (_to == address(0)) {\r\n            delete botIndexToOwner[_tokenId];\r\n        } else {\r\n            ownershipTokenCount[_to]++;\r\n            botIndexToOwner[_tokenId] = _to;\r\n        }\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n            delete sireAllowedToAddress[_tokenId];\r\n            delete botIndexToApproved[_tokenId];\r\n        }\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _createBot(\r\n        uint256 _matronId,\r\n        uint256 _sireId,\r\n        uint256 _generation,\r\n        uint256 _genes,\r\n        address _owner\r\n    )\r\n        internal\r\n        returns (uint)\r\n    {\r\n        require(_matronId == uint256(uint32(_matronId)));\r\n        require(_sireId == uint256(uint32(_sireId)));\r\n        require(_generation == uint256(uint16(_generation)));\r\n\r\n        uint16 cooldownIndex = uint16(_generation / 2);\r\n        if (cooldownIndex > 13) {\r\n            cooldownIndex = 13;\r\n        }\r\n\r\n        Bot memory _bot = Bot({\r\n            genes: _genes,\r\n            birthTime: uint64(now),\r\n            cooldownEndBlock: 0,\r\n            matronId: uint32(_matronId),\r\n            sireId: uint32(_sireId),\r\n            siringWithId: 0,\r\n            cooldownIndex: cooldownIndex,\r\n            generation: uint16(_generation)\r\n        });\r\n        uint256 newBotId = bots.push(_bot) - 1;\r\n\r\n        require(newBotId == uint256(uint32(newBotId)));\r\n\r\n        Birth(\r\n            _owner,\r\n            newBotId,\r\n            uint256(_bot.matronId),\r\n            uint256(_bot.sireId),\r\n            _bot.genes,\r\n            uint256(_bot.birthTime)\r\n       );\r\n\r\n        _transfer(0, _owner, newBotId);\r\n\r\n        return newBotId;\r\n    }\r\n\r\n    function _destroyBot(uint256 _botId) internal {\r\n        require(_botId > 0);\r\n        address from = botIndexToOwner[_botId];\r\n        require(from != address(0));\r\n        destroyedBots++;\r\n        _transfer(from, 0, _botId);\r\n    }\r\n\r\n    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\r\n        require(secs < cooldowns[0]);\r\n        secondsPerBlock = secs;\r\n    }\r\n}\r\n\r\n\r\ncontract BotExtension is BotBase {\r\n    event Lock(uint256 botId, uint16 mask);\r\n    mapping (address => bool) extensions;\r\n    mapping (uint256 => uint16) locks;\r\n    uint16 constant LOCK_BREEDING = 1;\r\n    uint16 constant LOCK_TRANSFER = 2;\r\n    uint16 constant LOCK_ALL = LOCK_BREEDING | LOCK_TRANSFER;\r\n\r\n    function addExtension(address _contract) external onlyCEO {\r\n        extensions[_contract] = true;\r\n    }\r\n\r\n    function removeExtension(address _contract) external onlyCEO {\r\n        delete extensions[_contract];\r\n    }\r\n\r\n    modifier onlyExtension() {\r\n        require(extensions[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    function extCreateBot(\r\n        uint256 _matronId,\r\n        uint256 _sireId,\r\n        uint256 _generation,\r\n        uint256 _genes,\r\n        address _owner\r\n    )\r\n        public\r\n        onlyExtension\r\n        returns (uint)\r\n    {\r\n        return _createBot(_matronId, _sireId, _generation, _genes, _owner);\r\n    }\r\n\r\n    function extDestroyBot(uint256 _botId)\r\n        public\r\n        onlyExtension\r\n    {\r\n        require(locks[_botId] == 0);\r\n\r\n        _destroyBot(_botId);\r\n    }\r\n\r\n    function extLockBot(uint256 _botId, uint16 _mask)\r\n        public\r\n        onlyExtension\r\n    {\r\n        _lockBot(_botId, _mask);\r\n    }\r\n\r\n    function _lockBot(uint256 _botId, uint16 _mask)\r\n        internal\r\n    {\r\n        require(_mask > 0);\r\n\r\n        uint16 mask = locks[_botId];\r\n        require(mask & _mask == 0);\r\n\r\n        if (_mask & LOCK_BREEDING > 0) {\r\n            Bot storage bot = bots[_botId];\r\n            require(bot.siringWithId == 0);\r\n        }\r\n\r\n        if (_mask & LOCK_TRANSFER > 0) {\r\n            address owner = botIndexToOwner[_botId];\r\n            require(owner != address(saleAuction));\r\n            require(owner != address(siringAuction));\r\n        }\r\n\r\n        mask |= _mask;\r\n\r\n        locks[_botId] = mask;\r\n\r\n        Lock(_botId, mask);\r\n    }\r\n\r\n    function extUnlockBot(uint256 _botId, uint16 _mask)\r\n        public\r\n        onlyExtension\r\n        returns (uint16)\r\n    {\r\n        _unlockBot(_botId, _mask);\r\n    }\r\n\r\n    function _unlockBot(uint256 _botId, uint16 _mask)\r\n        internal\r\n    {\r\n        require(_mask > 0);\r\n\r\n        uint16 mask = locks[_botId];\r\n        require(mask & _mask == _mask);\r\n        mask ^= _mask;\r\n\r\n        locks[_botId] = mask;\r\n\r\n        Lock(_botId, mask);\r\n    }\r\n\r\n    function extGetLock(uint256 _botId)\r\n        public\r\n        view\r\n        onlyExtension\r\n        returns (uint16)\r\n    {\r\n        return locks[_botId];\r\n    }\r\n}\r\n\r\n\r\ncontract BotOwnership is BotExtension, ERC721 {\r\n    string public constant name = \"CryptoBots\";\r\n    string public constant symbol = \"CBT\";\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return botIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return botIndexToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        botIndexToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_to != address(saleAuction));\r\n        require(_to != address(siringAuction));\r\n        require(_owns(msg.sender, _tokenId));\r\n        require(locks[_tokenId] & LOCK_TRANSFER == 0);\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function approve(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _tokenId));\r\n        require(locks[_tokenId] & LOCK_TRANSFER == 0);\r\n        _approve(_tokenId, _to);\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n        require(locks[_tokenId] & LOCK_TRANSFER == 0);\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return bots.length - destroyedBots;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address owner)\r\n    {\r\n        owner = botIndexToOwner[_tokenId];\r\n        require(owner != address(0));\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalBots = bots.length - 1;\r\n            uint256 resultIndex = 0;\r\n            uint256 botId;\r\n            for (botId = 0; botId <= totalBots; botId++) {\r\n                if (botIndexToOwner[botId] == _owner) {\r\n                    result[resultIndex] = botId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract BotBreeding is BotOwnership {\r\n    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock);\r\n    uint256 public autoBirthFee = 2 finney;\r\n    uint256 public pregnantBots;\r\n    GeneScienceInterface public geneScience;\r\n\r\n    function setGeneScienceAddress(address _address) external onlyCEO {\r\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\r\n        require(candidateContract.isGeneScience());\r\n        geneScience = candidateContract;\r\n    }\r\n\r\n    function _isReadyToBreed(uint256 _botId, Bot _bot) internal view returns (bool) {\r\n        return\r\n            (_bot.siringWithId == 0) &&\r\n            (_bot.cooldownEndBlock <= uint64(block.number)) &&\r\n            (locks[_botId] & LOCK_BREEDING == 0);\r\n    }\r\n\r\n    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns (bool) {\r\n        address matronOwner = botIndexToOwner[_matronId];\r\n        address sireOwner = botIndexToOwner[_sireId];\r\n        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);\r\n    }\r\n\r\n    function _triggerCooldown(Bot storage _bot) internal {\r\n        _bot.cooldownEndBlock = uint64((cooldowns[_bot.cooldownIndex]/secondsPerBlock) + block.number);\r\n        if (_bot.cooldownIndex < 13) {\r\n            _bot.cooldownIndex += 1;\r\n        }\r\n    }\r\n\r\n    function approveSiring(address _addr, uint256 _sireId)\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _sireId));\r\n        sireAllowedToAddress[_sireId] = _addr;\r\n    }\r\n\r\n    function setAutoBirthFee(uint256 val) external onlyCOO {\r\n        autoBirthFee = val;\r\n    }\r\n\r\n    function _isReadyToGiveBirth(Bot _matron) private view returns (bool) {\r\n        return (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));\r\n    }\r\n\r\n    function isReadyToBreed(uint256 _botId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        Bot storage bot = bots[_botId];\r\n        return _botId > 0 && _isReadyToBreed(_botId, bot);\r\n    }\r\n\r\n    function isPregnant(uint256 _botId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _botId > 0 && bots[_botId].siringWithId != 0;\r\n    }\r\n\r\n    function _isValidMatingPair(\r\n        Bot storage _matron,\r\n        uint256 _matronId,\r\n        Bot storage _sire,\r\n        uint256 _sireId\r\n    )\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        if (_matronId == _sireId) {\r\n            return false;\r\n        }\r\n        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {\r\n            return false;\r\n        }\r\n        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {\r\n            return false;\r\n        }\r\n        if (_sire.matronId == 0 || _matron.matronId == 0) {\r\n            return true;\r\n        }\r\n        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {\r\n            return false;\r\n        }\r\n        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        Bot storage matron = bots[_matronId];\r\n        Bot storage sire = bots[_sireId];\r\n        return _isValidMatingPair(matron, _matronId, sire, _sireId);\r\n    }\r\n\r\n    function canBreedWith(uint256 _matronId, uint256 _sireId)\r\n        external\r\n        view\r\n        returns(bool)\r\n    {\r\n        require(_matronId > 0);\r\n        require(_sireId > 0);\r\n        Bot storage matron = bots[_matronId];\r\n        Bot storage sire = bots[_sireId];\r\n        return _isValidMatingPair(matron, _matronId, sire, _sireId) &&\r\n            _isSiringPermitted(_sireId, _matronId);\r\n    }\r\n\r\n    function _breedWith(uint256 _matronId, uint256 _sireId) internal {\r\n        Bot storage sire = bots[_sireId];\r\n        Bot storage matron = bots[_matronId];\r\n        matron.siringWithId = uint32(_sireId);\r\n        _triggerCooldown(sire);\r\n        _triggerCooldown(matron);\r\n        delete sireAllowedToAddress[_matronId];\r\n        delete sireAllowedToAddress[_sireId];\r\n        pregnantBots++;\r\n        Pregnant(botIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock);\r\n    }\r\n\r\n    function breedWithAuto(uint256 _matronId, uint256 _sireId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        require(msg.value >= autoBirthFee);\r\n        require(_owns(msg.sender, _matronId));\r\n        require(_isSiringPermitted(_sireId, _matronId));\r\n        Bot storage matron = bots[_matronId];\r\n        require(_isReadyToBreed(_matronId, matron));\r\n        Bot storage sire = bots[_sireId];\r\n        require(_isReadyToBreed(_sireId, sire));\r\n        require(_isValidMatingPair(\r\n            matron,\r\n            _matronId,\r\n            sire,\r\n            _sireId\r\n        ));\r\n        _breedWith(_matronId, _sireId);\r\n    }\r\n\r\n    function giveBirth(uint256 _matronId)\r\n        external\r\n        whenNotPaused\r\n        returns(uint256)\r\n    {\r\n        Bot storage matron = bots[_matronId];\r\n        require(matron.birthTime != 0);\r\n        require(_isReadyToGiveBirth(matron));\r\n        uint256 sireId = matron.siringWithId;\r\n        Bot storage sire = bots[sireId];\r\n        uint16 parentGen = matron.generation;\r\n        if (sire.generation > matron.generation) {\r\n            parentGen = sire.generation;\r\n        }\r\n        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);\r\n        address owner = botIndexToOwner[_matronId];\r\n        uint256 botId = _createBot(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\r\n        delete matron.siringWithId;\r\n        pregnantBots--;\r\n        msg.sender.send(autoBirthFee);\r\n        return botId;\r\n    }\r\n}\r\n\r\n\r\ncontract ClockAuctionBase {\r\n    struct Auction {\r\n        address seller;\r\n        uint128 startingPrice;\r\n        uint128 endingPrice;\r\n        uint64 duration;\r\n        uint64 startedAt;\r\n    }\r\n    ERC721 public nonFungibleContract;\r\n    uint256 public ownerCut;\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n    event AuctionCreated(\r\n      address seller,\r\n      uint256 tokenId,\r\n      uint256 startingPrice,\r\n      uint256 endingPrice,\r\n      uint256 creationTime,\r\n      uint256 duration\r\n    );\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address seller, address winner, uint256 time);\r\n    event AuctionCancelled(uint256 tokenId, address seller, uint256 time);\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n\r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\r\n        require(_auction.duration >= 1 minutes);\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n        AuctionCreated(\r\n            _auction.seller,\r\n            uint256(_tokenId),\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.startedAt),\r\n            uint256(_auction.duration)\r\n        );\r\n    }\r\n\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        AuctionCancelled(_tokenId, _seller, uint256(now));\r\n    }\r\n\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        uint256 price = _currentPrice(auction);\r\n        require(_bidAmount >= price);\r\n        address seller = auction.seller;\r\n        _removeAuction(_tokenId);\r\n        if (price > 0) {\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - auctioneerCut;\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n        uint256 bidExcess = _bidAmount - price;\r\n        msg.sender.transfer(bidExcess);\r\n        AuctionSuccessful(_tokenId, price, seller, msg.sender, uint256(now));\r\n        return price;\r\n    }\r\n\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_secondsPassed >= _duration) {\r\n            return _endingPrice;\r\n        } else {\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        return _price * ownerCut / 10000;\r\n    }\r\n}\r\n\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner whenNotPaused returns (bool) {\r\n        paused = true;\r\n        Pause();\r\n        return true;\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused returns (bool) {\r\n        paused = false;\r\n        Unpause();\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract ClockAuction is Pausable, ClockAuctionBase {\r\n    function ClockAuction(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    function withdrawBalance() external {\r\n        address nftAddress = address(nonFungibleContract);\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == nftAddress\r\n        );\r\n        bool res = nftAddress.send(this.balance);\r\n    }\r\n\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n        require(_owns(msg.sender, _tokenId));\r\n        _escrow(msg.sender, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    function cancelAuction(uint256 _tokenId)\r\n        external\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n        external\r\n        whenPaused\r\n        onlyOwner\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    )\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n            auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SiringClockAuction is ClockAuction {\r\n    bool public isSiringClockAuction = true;\r\n\r\n    function SiringClockAuction(address _nftAddr, uint256 _cut) public\r\n        ClockAuction(_nftAddr, _cut) {}\r\n\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n    {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(seller, _tokenId);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SaleClockAuction is ClockAuction {\r\n    bool public isSaleClockAuction = true;\r\n    uint256 public gen0SaleCount;\r\n    uint256[5] public lastGen0SalePrices;\r\n\r\n    function SaleClockAuction(address _nftAddr, uint256 _cut) public\r\n        ClockAuction(_nftAddr, _cut) {}\r\n\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n    {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        uint256 price = _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n        if (seller == address(nonFungibleContract)) {\r\n            lastGen0SalePrices[gen0SaleCount % 5] = price;\r\n            gen0SaleCount++;\r\n        }\r\n    }\r\n\r\n    function averageGen0SalePrice() external view returns (uint256) {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < 5; i++) {\r\n            sum += lastGen0SalePrices[i];\r\n        }\r\n        return sum / 5;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract BotAuction is BotBreeding {\r\n    function setSaleAuctionAddress(address _address) external onlyCEO {\r\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\r\n        require(candidateContract.isSaleClockAuction());\r\n        saleAuction = candidateContract;\r\n    }\r\n\r\n    function setSiringAuctionAddress(address _address) external onlyCEO {\r\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\r\n        require(candidateContract.isSiringClockAuction());\r\n        siringAuction = candidateContract;\r\n    }\r\n\r\n    function createSaleAuction(\r\n        uint256 _botId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _botId));\r\n        require(!isPregnant(_botId));\r\n        _approve(_botId, saleAuction);\r\n        saleAuction.createAuction(\r\n            _botId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function createSiringAuction(\r\n        uint256 _botId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _botId));\r\n        require(isReadyToBreed(_botId));\r\n        _approve(_botId, siringAuction);\r\n        siringAuction.createAuction(\r\n            _botId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function bidOnSiringAuction(\r\n        uint256 _sireId,\r\n        uint256 _matronId\r\n    )\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _matronId));\r\n        require(isReadyToBreed(_matronId));\r\n        require(_canBreedWithViaAuction(_matronId, _sireId));\r\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\r\n        require(msg.value >= currentPrice + autoBirthFee);\r\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\r\n        _breedWith(uint32(_matronId), uint32(_sireId));\r\n    }\r\n\r\n    function withdrawAuctionBalances() external onlyCLevel {\r\n        saleAuction.withdrawBalance();\r\n        siringAuction.withdrawBalance();\r\n    }\r\n}\r\n\r\n\r\ncontract BotMinting is BotAuction {\r\n    uint256 public constant PROMO_CREATION_LIMIT = 5000;\r\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\r\n    uint256 public constant GEN0_STARTING_PRICE = 10 finney;\r\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\r\n    uint256 public promoCreatedCount;\r\n    uint256 public gen0CreatedCount;\r\n\r\n    function createPromoBot(uint256 _genes, address _owner) external onlyCOO {\r\n        address botOwner = _owner;\r\n        if (botOwner == address(0)) {\r\n            botOwner = cooAddress;\r\n        }\r\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\r\n\r\n        promoCreatedCount++;\r\n        _createBot(0, 0, 0, _genes, botOwner);\r\n    }\r\n\r\n    function createGen0Auction(uint256 _genes) external onlyCOO {\r\n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\r\n\r\n        uint256 botId = _createBot(0, 0, 0, _genes, address(this));\r\n        _approve(botId, saleAuction);\r\n\r\n        saleAuction.createAuction(\r\n            botId,\r\n            _computeNextGen0Price(),\r\n            0,\r\n            GEN0_AUCTION_DURATION,\r\n            address(this)\r\n        );\r\n\r\n        gen0CreatedCount++;\r\n    }\r\n\r\n    function _computeNextGen0Price() internal view returns (uint256) {\r\n        uint256 avePrice = saleAuction.averageGen0SalePrice();\r\n        require(avePrice == uint256(uint128(avePrice)));\r\n        uint256 nextPrice = avePrice + (avePrice / 2);\r\n        if (nextPrice < GEN0_STARTING_PRICE) {\r\n            nextPrice = GEN0_STARTING_PRICE;\r\n        }\r\n        return nextPrice;\r\n    }\r\n}\r\n\r\n\r\ncontract BotCore is BotMinting {\r\n    address public newContractAddress;\r\n\r\n    function BotCore() public {\r\n        paused = true;\r\n        ceoAddress = msg.sender;\r\n        cooAddress = msg.sender;\r\n        _createBot(0, 0, 0, uint256(-1), msg.sender);\r\n    }\r\n\r\n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\r\n        newContractAddress = _v2Address;\r\n        ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    function() external payable {\r\n        require(\r\n            msg.sender == address(saleAuction) ||\r\n            msg.sender == address(siringAuction)\r\n        );\r\n    }\r\n\r\n    function getBot(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n        bool isGestating,\r\n        bool isReady,\r\n        uint256 cooldownIndex,\r\n        uint256 nextActionAt,\r\n        uint256 siringWithId,\r\n        uint256 birthTime,\r\n        uint256 matronId,\r\n        uint256 sireId,\r\n        uint256 generation,\r\n        uint256 genes\r\n    )\r\n    {\r\n        require(botIndexToOwner[_id] != address(0));\r\n        Bot storage bot = bots[_id];\r\n        isGestating = (bot.siringWithId != 0);\r\n        isReady = (bot.cooldownEndBlock <= block.number);\r\n        cooldownIndex = uint256(bot.cooldownIndex);\r\n        nextActionAt = uint256(bot.cooldownEndBlock);\r\n        siringWithId = uint256(bot.siringWithId);\r\n        birthTime = uint256(bot.birthTime);\r\n        matronId = uint256(bot.matronId);\r\n        sireId = uint256(bot.sireId);\r\n        generation = uint256(bot.generation);\r\n        genes = bot.genes;\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n        require(saleAuction != address(0));\r\n        require(siringAuction != address(0));\r\n        require(geneScience != address(0));\r\n        require(newContractAddress == address(0));\r\n        super.unpause();\r\n    }\r\n\r\n    function withdrawBalance() external onlyCFO {\r\n        uint256 balance = this.balance;\r\n        uint256 subtractFees = (pregnantBots + 1) * autoBirthFee;\r\n        if (balance > subtractFees) {\r\n            cfoAddress.send(balance - subtractFees);\r\n        }\r\n    }\r\n\r\n    function destroyBot(uint256 _botId) external onlyCEO {\r\n        require(locks[_botId] == 0);\r\n        _destroyBot(_botId);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSiringClockAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nftAddr\",\"type\":\"address\"},{\"name\":\"_cut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creationTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"SiringClockAuction","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f7a6e15dfd5cdd9ef12711bd757a9b6021abf643000000000000000000000000000000000000000000000000000000000000012c","Library":"","SwarmSource":"bzzr://71c1285791d6db7351f727478d1603250dbbf3429534694086d3a0f8907a086c"}]}