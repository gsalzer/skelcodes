{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/// @title A library for implementing a generic state machine pattern.\r\nlibrary StateMachineLib {\r\n\r\n    struct Stage {\r\n        // The id of the next stage\r\n        bytes32 nextId;\r\n\r\n        // The identifiers for the available functions in each stage\r\n        mapping(bytes4 => bool) allowedFunctions;\r\n    }\r\n\r\n    struct State {\r\n        // The current stage id\r\n        bytes32 currentStageId;\r\n\r\n        // A callback that is called when entering this stage\r\n        function(bytes32) internal onTransition;\r\n\r\n        // Checks if a stage id is valid\r\n        mapping(bytes32 => bool) validStage;\r\n\r\n        // Maps stage ids to their Stage structs\r\n        mapping(bytes32 => Stage) stages;\r\n    }\r\n\r\n    /// @dev Creates and sets the initial stage. It has to be called before creating any transitions.\r\n    /// @param stageId The id of the (new) stage to set as initial stage.\r\n    function setInitialStage(State storage self, bytes32 stageId) internal {\r\n        self.validStage[stageId] = true;\r\n        self.currentStageId = stageId;\r\n    }\r\n\r\n    /// @dev Creates a transition from 'fromId' to 'toId'. If fromId already had a nextId, it deletes the now unreachable stage.\r\n    /// @param fromId The id of the stage from which the transition begins.\r\n    /// @param toId The id of the stage that will be reachable from \"fromId\".\r\n    function createTransition(State storage self, bytes32 fromId, bytes32 toId) internal {\r\n        require(self.validStage[fromId]);\r\n\r\n        Stage storage from = self.stages[fromId];\r\n\r\n        // Invalidate the stage that won't be reachable any more\r\n        if (from.nextId != 0) {\r\n            self.validStage[from.nextId] = false;\r\n            delete self.stages[from.nextId];\r\n        }\r\n\r\n        from.nextId = toId;\r\n        self.validStage[toId] = true;\r\n    }\r\n\r\n    /// @dev Goes to the next stage if posible (if the next stage is valid)\r\n    function goToNextStage(State storage self) internal {\r\n        Stage storage current = self.stages[self.currentStageId];\r\n\r\n        require(self.validStage[current.nextId]);\r\n\r\n        self.currentStageId = current.nextId;\r\n\r\n        self.onTransition(current.nextId);\r\n    }\r\n\r\n    /// @dev Checks if the a function is allowed in the current stage.\r\n    /// @param selector A function selector (bytes4[keccak256(functionSignature)])\r\n    /// @return true If the function is allowed in the current stage\r\n    function checkAllowedFunction(State storage self, bytes4 selector) internal constant returns(bool) {\r\n        return self.stages[self.currentStageId].allowedFunctions[selector];\r\n    }\r\n\r\n    /// @dev Allow a function in the given stage.\r\n    /// @param stageId The id of the stage\r\n    /// @param selector A function selector (bytes4[keccak256(functionSignature)])\r\n    function allowFunction(State storage self, bytes32 stageId, bytes4 selector) internal {\r\n        require(self.validStage[stageId]);\r\n        self.stages[stageId].allowedFunctions[selector] = true;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract StateMachine {\r\n    using StateMachineLib for StateMachineLib.State;\r\n\r\n    event LogTransition(bytes32 indexed stageId, uint256 blockNumber);\r\n\r\n    StateMachineLib.State internal state;\r\n\r\n    /* This modifier performs the conditional transitions and checks that the function \r\n     * to be executed is allowed in the current stage\r\n     */\r\n    modifier checkAllowed {\r\n        conditionalTransitions();\r\n        require(state.checkAllowedFunction(msg.sig));\r\n        _;\r\n    }\r\n\r\n    function StateMachine() public {\r\n        // Register the startConditions function and the onTransition callback\r\n        state.onTransition = onTransition;\r\n    }\r\n\r\n    /// @dev Gets the current stage id.\r\n    /// @return The current stage id.\r\n    function getCurrentStageId() public view returns(bytes32) {\r\n        return state.currentStageId;\r\n    }\r\n\r\n    /// @dev Performs conditional transitions. Can be called by anyone.\r\n    function conditionalTransitions() public {\r\n\r\n        bytes32 nextId = state.stages[state.currentStageId].nextId;\r\n\r\n        while (state.validStage[nextId]) {\r\n            StateMachineLib.Stage storage next = state.stages[nextId];\r\n            // If the next stage's condition is true, go to next stage and continue\r\n            if (startConditions(nextId)) {\r\n                state.goToNextStage();\r\n                nextId = next.nextId;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Determines whether the conditions for transitioning to the given stage are met.\r\n    /// @return true if the conditions are met for the given stageId. False by default (must override in child contracts).\r\n    function startConditions(bytes32) internal constant returns(bool) {\r\n        return false;\r\n    }\r\n\r\n    /// @dev Callback called when there is a stage transition. It should be overridden for additional functionality.\r\n    function onTransition(bytes32 stageId) internal {\r\n        LogTransition(stageId, block.number);\r\n    }\r\n\r\n\r\n}\r\n\r\n/// @title A contract that implements the state machine pattern and adds time dependant transitions.\r\ncontract TimedStateMachine is StateMachine {\r\n\r\n    event LogSetStageStartTime(bytes32 indexed stageId, uint256 startTime);\r\n\r\n    // Stores the start timestamp for each stage (the value is 0 if the stage doesn't have a start timestamp).\r\n    mapping(bytes32 => uint256) internal startTime;\r\n\r\n    /// @dev This function overrides the startConditions function in the parent class in order to enable automatic transitions that depend on the timestamp.\r\n    function startConditions(bytes32 stageId) internal constant returns(bool) {\r\n        // Get the startTime for stage\r\n        uint256 start = startTime[stageId];\r\n        // If the startTime is set and has already passed, return true.\r\n        return start != 0 && block.timestamp > start;\r\n    }\r\n\r\n    /// @dev Sets the starting timestamp for a stage.\r\n    /// @param stageId The id of the stage for which we want to set the start timestamp.\r\n    /// @param timestamp The start timestamp for the given stage. It should be bigger than the current one.\r\n    function setStageStartTime(bytes32 stageId, uint256 timestamp) internal {\r\n        require(state.validStage[stageId]);\r\n        require(timestamp > block.timestamp);\r\n\r\n        startTime[stageId] = timestamp;\r\n        LogSetStageStartTime(stageId, timestamp);\r\n    }\r\n\r\n    /// @dev Returns the timestamp for the given stage id.\r\n    /// @param stageId The id of the stage for which we want to set the start timestamp.\r\n    function getStageStartTime(bytes32 stageId) public view returns(uint256) {\r\n        return startTime[stageId];\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\ncontract ERC223Basic is ERC20Basic {\r\n\r\n    /**\r\n      * @dev Transfer the specified amount of tokens to the specified address.\r\n      *      Now with a new parameter _data.\r\n      *\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      * @param _data  Transaction metadata.\r\n      */\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool);\r\n\r\n    /**\r\n      * @dev triggered when transfer is successfully called.\r\n      *\r\n      * @param _from  Sender address.\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      * @param _data  Transaction metadata.\r\n      */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\r\n}\r\n\r\n/// @title Contract that supports the receival of ERC223 tokens.\r\ncontract ERC223ReceivingContract {\r\n\r\n    /// @dev Standard ERC223 function that will handle incoming token transfers.\r\n    /// @param _from  Token sender address.\r\n    /// @param _value Amount of tokens.\r\n    /// @param _data  Transaction metadata.\r\n    function tokenFallback(address _from, uint _value, bytes _data);\r\n\r\n}\r\n\r\n/**\r\n * @title ERC223 standard token implementation.\r\n */\r\ncontract ERC223BasicToken is ERC223Basic, BasicToken {\r\n\r\n    /**\r\n      * @dev Transfer the specified amount of tokens to the specified address.\r\n      *      Invokes the `tokenFallback` function if the recipient is a contract.\r\n      *      The token transfer fails if the recipient is a contract\r\n      *      but does not implement the `tokenFallback` function\r\n      *      or the fallback function to receive funds.\r\n      *\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      * @param _data  Transaction metadata.\r\n      */\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        require(super.transfer(_to, _value));\r\n\r\n        if(codeLength>0) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n      /**\r\n      * @dev Transfer the specified amount of tokens to the specified address.\r\n      *      Invokes the `tokenFallback` function if the recipient is a contract.\r\n      *      The token transfer fails if the recipient is a contract\r\n      *      but does not implement the `tokenFallback` function\r\n      *      or the fallback function to receive funds.\r\n      *\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        bytes memory empty;\r\n        require(transfer(_to, _value, empty));\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/// @title Token for the Pryze project.\r\ncontract PryzeToken is DetailedERC20, MintableToken, ERC223BasicToken {\r\n    string constant NAME = \"Pryze\";\r\n    string constant SYMBOL = \"PRYZ\";\r\n    uint8 constant DECIMALS = 18;\r\n\r\n    //// @dev Constructor that sets details of the ERC20 token.\r\n    function PryzeToken()\r\n        DetailedERC20(NAME, SYMBOL, DECIMALS)\r\n        public\r\n    {}\r\n}\r\n\r\n\r\n\r\ncontract Whitelistable is Ownable {\r\n    \r\n    event LogUserRegistered(address indexed sender, address indexed userAddress);\r\n    event LogUserUnregistered(address indexed sender, address indexed userAddress);\r\n    \r\n    mapping(address => bool) public whitelisted;\r\n\r\n    function registerUser(address userAddress) \r\n        public \r\n        onlyOwner \r\n    {\r\n        require(userAddress != 0);\r\n        whitelisted[userAddress] = true;\r\n        LogUserRegistered(msg.sender, userAddress);\r\n    }\r\n\r\n    function unregisterUser(address userAddress) \r\n        public \r\n        onlyOwner \r\n    {\r\n        require(whitelisted[userAddress] == true);\r\n        whitelisted[userAddress] = false;\r\n        LogUserUnregistered(msg.sender, userAddress);\r\n    }\r\n}\r\n\r\n\r\ncontract DisbursementHandler is Ownable {\r\n\r\n    struct Disbursement {\r\n        uint256 timestamp;\r\n        uint256 tokens;\r\n    }\r\n\r\n    event LogSetup(address indexed vestor, uint256 tokens, uint256 timestamp);\r\n    event LogChangeTimestamp(address indexed vestor, uint256 index, uint256 timestamp);\r\n    event LogWithdraw(address indexed to, uint256 value);\r\n\r\n    ERC20 public token;\r\n    mapping(address => Disbursement[]) public disbursements;\r\n    mapping(address => uint256) public withdrawnTokens;\r\n\r\n    function DisbursementHandler(address _token) public {\r\n        token = ERC20(_token);\r\n    }\r\n\r\n    /// @dev Called by the sale contract to create a disbursement.\r\n    /// @param vestor The address of the beneficiary.\r\n    /// @param tokens Amount of tokens to be locked.\r\n    /// @param timestamp Funds will be locked until this timestamp.\r\n    function setupDisbursement(\r\n        address vestor,\r\n        uint256 tokens,\r\n        uint256 timestamp\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(block.timestamp < timestamp);\r\n        disbursements[vestor].push(Disbursement(timestamp, tokens));\r\n        LogSetup(vestor, timestamp, tokens);\r\n    }\r\n\r\n    /// @dev Change an existing disbursement.\r\n    /// @param vestor The address of the beneficiary.\r\n    /// @param timestamp Funds will be locked until this timestamp.\r\n    /// @param index Index of the DisbursementVesting in the vesting array.\r\n    function changeTimestamp(\r\n        address vestor,\r\n        uint256 index,\r\n        uint256 timestamp\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(block.timestamp < timestamp);\r\n        require(index < disbursements[vestor].length);\r\n        disbursements[vestor][index].timestamp = timestamp;\r\n        LogChangeTimestamp(vestor, index, timestamp);\r\n    }\r\n\r\n    /// @dev Transfers tokens to a given address\r\n    /// @param to Address of token receiver\r\n    /// @param value Number of tokens to transfer\r\n    function withdraw(address to, uint256 value)\r\n        public\r\n    {\r\n        uint256 maxTokens = calcMaxWithdraw();\r\n        uint256 withdrawAmount = value < maxTokens ? value : maxTokens;\r\n        withdrawnTokens[msg.sender] = SafeMath.add(withdrawnTokens[msg.sender], withdrawAmount);\r\n        token.transfer(to, withdrawAmount);\r\n        LogWithdraw(to, value);\r\n    }\r\n\r\n    /// @dev Calculates the maximum amount of vested tokens\r\n    /// @return Number of vested tokens to withdraw\r\n    function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        uint256 maxTokens = 0;\r\n        Disbursement[] storage temp = disbursements[msg.sender];\r\n        for (uint256 i = 0; i < temp.length; i++) {\r\n            if (block.timestamp > temp[i].timestamp) {\r\n                maxTokens = SafeMath.add(maxTokens, temp[i].tokens);\r\n            }\r\n        }\r\n        maxTokens = SafeMath.sub(maxTokens, withdrawnTokens[msg.sender]);\r\n        return maxTokens;\r\n    }\r\n}\r\n\r\n\r\n/// @title Sale base contract\r\ncontract Sale is Ownable, TimedStateMachine {\r\n    using SafeMath for uint256;\r\n\r\n    event LogContribution(address indexed contributor, uint256 amountSent, uint256 excessRefunded);\r\n    event LogTokenAllocation(address indexed contributor, uint256 contribution, uint256 tokens);\r\n    event LogDisbursement(address indexed beneficiary, uint256 tokens);\r\n\r\n    // Stages for the state machine\r\n    bytes32 public constant SETUP = \"setup\";\r\n    bytes32 public constant SETUP_DONE = \"setupDone\";\r\n    bytes32 public constant SALE_IN_PROGRESS = \"saleInProgress\";\r\n    bytes32 public constant SALE_ENDED = \"saleEnded\";\r\n\r\n    mapping(address => uint256) public contributions;\r\n\r\n    uint256 public weiContributed = 0;\r\n    uint256 public contributionCap;\r\n\r\n    // Wallet where funds will be sent\r\n    address public wallet;\r\n\r\n    MintableToken public token;\r\n\r\n    DisbursementHandler public disbursementHandler;\r\n\r\n    function Sale(\r\n        address _wallet, \r\n        uint256 _contributionCap\r\n    ) \r\n        public \r\n    {\r\n        require(_wallet != 0);\r\n        require(_contributionCap != 0);\r\n\r\n        wallet = _wallet;\r\n\r\n        token = createTokenContract();\r\n        disbursementHandler = new DisbursementHandler(token);\r\n\r\n        contributionCap = _contributionCap;\r\n\r\n        setupStages();\r\n    }\r\n\r\n    function() external payable {\r\n        contribute();\r\n    }\r\n\r\n    /// @dev Sets the start timestamp for the SALE_IN_PROGRESS stage.\r\n    /// @param timestamp The start timestamp.\r\n    function setSaleStartTime(uint256 timestamp) \r\n        external \r\n        onlyOwner \r\n        checkAllowed\r\n    {\r\n        // require(_startTime < getStageStartTime(SALE_ENDED));\r\n        setStageStartTime(SALE_IN_PROGRESS, timestamp);\r\n    }\r\n\r\n    /// @dev Sets the start timestamp for the SALE_ENDED stage.\r\n    /// @param timestamp The start timestamp.\r\n    function setSaleEndTime(uint256 timestamp) \r\n        external \r\n        onlyOwner \r\n        checkAllowed\r\n    {\r\n        require(getStageStartTime(SALE_IN_PROGRESS) < timestamp);\r\n        setStageStartTime(SALE_ENDED, timestamp);\r\n    }\r\n\r\n    /// @dev Called in the SETUP stage, check configurations and to go to the SETUP_DONE stage.\r\n    function setupDone() \r\n        public \r\n        onlyOwner \r\n        checkAllowed\r\n    {\r\n        uint256 _startTime = getStageStartTime(SALE_IN_PROGRESS);\r\n        uint256 _endTime = getStageStartTime(SALE_ENDED);\r\n        require(block.timestamp < _startTime);\r\n        require(_startTime < _endTime);\r\n\r\n        state.goToNextStage();\r\n    }\r\n\r\n    /// @dev Called by users to contribute ETH to the sale.\r\n    function contribute() \r\n        public \r\n        payable\r\n        checkAllowed \r\n    {\r\n        require(msg.value > 0);   \r\n\r\n        uint256 contributionLimit = getContributionLimit(msg.sender);\r\n        require(contributionLimit > 0);\r\n\r\n        // Check that the user is allowed to contribute\r\n        uint256 totalContribution = contributions[msg.sender].add(msg.value);\r\n        uint256 excess = 0;\r\n\r\n        // Check if it goes over the eth cap for the sale.\r\n        if (weiContributed.add(msg.value) > contributionCap) {\r\n            // Subtract the excess\r\n            excess = weiContributed.add(msg.value).sub(contributionCap);\r\n            totalContribution = totalContribution.sub(excess);\r\n        }\r\n\r\n        // Check if it goes over the contribution limit of the user. \r\n        if (totalContribution > contributionLimit) {\r\n            excess = excess.add(totalContribution).sub(contributionLimit);\r\n            contributions[msg.sender] = contributionLimit;\r\n        } else {\r\n            contributions[msg.sender] = totalContribution;\r\n        }\r\n\r\n        // We are only able to refund up to msg.value because the contract will not contain ether\r\n        excess = excess < msg.value ? excess : msg.value;\r\n\r\n        weiContributed = weiContributed.add(msg.value).sub(excess);\r\n\r\n        if (excess > 0) {\r\n            msg.sender.transfer(excess);\r\n        }\r\n\r\n        wallet.transfer(this.balance);\r\n\r\n        assert(contributions[msg.sender] <= contributionLimit);\r\n        LogContribution(msg.sender, msg.value, excess);\r\n    }\r\n\r\n    /// @dev Create a disbursement of tokens.\r\n    /// @param beneficiary The beneficiary of the disbursement.\r\n    /// @param tokenAmount Amount of tokens to be locked.\r\n    /// @param timestamp Tokens will be locked until this timestamp.\r\n    function distributeTimelockedTokens(\r\n        address beneficiary,\r\n        uint256 tokenAmount,\r\n        uint256 timestamp\r\n    ) \r\n        external\r\n        onlyOwner\r\n        checkAllowed\r\n    { \r\n        disbursementHandler.setupDisbursement(\r\n            beneficiary,\r\n            tokenAmount,\r\n            timestamp\r\n        );\r\n        token.mint(disbursementHandler, tokenAmount);\r\n        LogDisbursement(beneficiary, tokenAmount);\r\n    }\r\n    \r\n    function setupStages() internal {\r\n        // Set the stages\r\n        state.setInitialStage(SETUP);\r\n        state.createTransition(SETUP, SETUP_DONE);\r\n        state.createTransition(SETUP_DONE, SALE_IN_PROGRESS);\r\n        state.createTransition(SALE_IN_PROGRESS, SALE_ENDED);\r\n\r\n        // The selectors should be hardcoded\r\n        state.allowFunction(SETUP, this.distributeTimelockedTokens.selector);\r\n        state.allowFunction(SETUP, this.setSaleStartTime.selector);\r\n        state.allowFunction(SETUP, this.setSaleEndTime.selector);\r\n        state.allowFunction(SETUP, this.setupDone.selector);\r\n        state.allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\r\n        state.allowFunction(SALE_IN_PROGRESS, 0); // fallback\r\n    }\r\n\r\n    // Override in the child sales\r\n    function createTokenContract() internal returns (MintableToken);\r\n    function getContributionLimit(address userAddress) internal returns (uint256);\r\n\r\n    /// @dev Stage start conditions.\r\n    function startConditions(bytes32 stageId) internal constant returns (bool) {\r\n        // If the cap has been reached, end the sale.\r\n        if (stageId == SALE_ENDED && contributionCap == weiContributed) {\r\n            return true;\r\n        }\r\n        return super.startConditions(stageId);\r\n    }\r\n\r\n    /// @dev State transitions callbacks.\r\n    function onTransition(bytes32 stageId) internal {\r\n        if (stageId == SALE_ENDED) { \r\n            onSaleEnded(); \r\n        }\r\n        super.onTransition(stageId);\r\n    }\r\n\r\n    /// @dev Callback that gets called when entering the SALE_ENDED stage.\r\n    function onSaleEnded() internal {}\r\n}\r\n\r\n\r\n\r\ncontract PryzeSale is Sale, Whitelistable {\r\n\r\n    uint256 public constant PRESALE_WEI = 10695.303 ether; // Amount raised in the presale\r\n    uint256 public constant PRESALE_WEI_WITH_BONUS = 10695.303 ether * 1.5; // Amount raised in the presale times the bonus\r\n\r\n    uint256 public constant MAX_WEI = 24695.303 ether; // Max wei to raise, including PRESALE_WEI\r\n    uint256 public constant WEI_CAP = 14000 ether; // MAX_WEI - PRESALE_WEI\r\n    uint256 public constant MAX_TOKENS = 400000000 * 1000000000000000000; // 4mm times 10^18 (18 decimals)\r\n\r\n    uint256 public presaleWeiContributed = 0;\r\n    uint256 private weiAllocated = 0;\r\n\r\n    mapping(address => uint256) public presaleContributions;\r\n\r\n    function PryzeSale(\r\n        address _wallet\r\n    )\r\n        Sale(_wallet, WEI_CAP)\r\n        public \r\n    {\r\n    }\r\n\r\n    /// @dev Sets the presale contribution for a contributor.\r\n    /// @param _contributor The contributor.\r\n    /// @param _amount The amount contributed in the presale (without the bonus).\r\n    function presaleContribute(address _contributor, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n        checkAllowed\r\n    {\r\n        // If presale contribution is already set, replace the amount in the presaleWeiContributed variable\r\n        if (presaleContributions[_contributor] != 0) {\r\n            presaleWeiContributed = presaleWeiContributed.sub(presaleContributions[_contributor]);\r\n        } \r\n        presaleWeiContributed = presaleWeiContributed.add(_amount);\r\n        require(presaleWeiContributed <= PRESALE_WEI);\r\n        presaleContributions[_contributor] = _amount;\r\n    }\r\n\r\n    /// @dev Called to allocate the tokens depending on eth contributed.\r\n    /// @param contributor The address of the contributor.\r\n    function allocateTokens(address contributor) \r\n        external \r\n        checkAllowed\r\n    {\r\n        require(presaleContributions[contributor] != 0 || contributions[contributor] != 0);\r\n        uint256 tokensToAllocate = calculateAllocation(contributor);\r\n\r\n        // We keep a record of how much wei contributed has already been used for allocations\r\n        weiAllocated = weiAllocated.add(presaleContributions[contributor]).add(contributions[contributor]);\r\n\r\n        // Set contributions to 0\r\n        presaleContributions[contributor] = 0;\r\n        contributions[contributor] = 0;\r\n\r\n        // Mint the respective tokens to the contributor\r\n        token.mint(contributor, tokensToAllocate);\r\n\r\n        // If all tokens were allocated, stop minting functionality\r\n        if (weiAllocated == PRESALE_WEI.add(weiContributed)) {\r\n          token.finishMinting();\r\n        }\r\n    }\r\n\r\n    function setupDone() \r\n        public \r\n        onlyOwner \r\n        checkAllowed\r\n    {\r\n        require(presaleWeiContributed == PRESALE_WEI);\r\n        super.setupDone();\r\n    }\r\n\r\n    /// @dev Calculate the PRYZ allocation for the given contributor. The allocation is proportional to the amount of wei contributed.\r\n    /// @param contributor The address of the contributor\r\n    /// @return The amount of tokens to allocate\r\n    function calculateAllocation(address contributor) public constant returns (uint256) {\r\n        uint256 presale = presaleContributions[contributor].mul(15).div(10); // Multiply by 1.5\r\n        uint256 totalContribution = presale.add(contributions[contributor]);\r\n        return totalContribution.mul(MAX_TOKENS).div(PRESALE_WEI_WITH_BONUS.add(weiContributed));\r\n    }\r\n\r\n    function setupStages() internal {\r\n        super.setupStages();\r\n        state.allowFunction(SETUP, this.presaleContribute.selector);\r\n        state.allowFunction(SALE_ENDED, this.allocateTokens.selector);\r\n    }\r\n\r\n    function createTokenContract() internal returns(MintableToken) {\r\n        return new PryzeToken();\r\n    }\r\n\r\n    function getContributionLimit(address userAddress) internal returns (uint256) {\r\n        // No contribution cap if whitelisted\r\n        return whitelisted[userAddress] ? 2**256 - 1 : 0;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"setupDone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"registerUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"unregisterUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_WEI_WITH_BONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_ENDED\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"presaleContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WEI_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setSaleStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleWeiContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_WEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disbursementHandler\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SETUP_DONE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"calculateAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"presaleContribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStageId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stageId\",\"type\":\"bytes32\"}],\"name\":\"getStageStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"allocateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setSaleEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"conditionalTransitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_WEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_IN_PROGRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SETUP\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"distributeTimelockedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"LogUserRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"LogUserUnregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"excessRefunded\",\"type\":\"uint256\"}],\"name\":\"LogContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"LogTokenAllocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"LogDisbursement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"stageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"LogSetStageStartTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"stageId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"LogTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PryzeSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f7a299884ad7be5bc3465a0b1d8bb2be2b00fd0a","Library":"","SwarmSource":"bzzr://29a4bad5db5948a5519fed495d14cc1b4f8a726640389348345147c84fa9fb82"}]}