{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Sales{\r\n\r\n\tenum ICOSaleState{\r\n\t    PrivateSale,\r\n\t    PreSale,\r\n\t    PreICO,\r\n\t    PublicICO\r\n\t}\r\n}\r\n\r\ncontract Utils{\r\n\r\n\t//verifies the amount greater than zero\r\n\r\n\tmodifier greaterThanZero(uint256 _value){\r\n\t\trequire(_value>0);\r\n\t\t_;\r\n\t}\r\n\r\n\t///verifies an address\r\n\r\n\tmodifier validAddress(address _add){\r\n\t\trequire(_add!=0x0);\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract SMTToken is Token,Ownable,Sales {\r\n    string public constant name = \"Sun Money Token\";\r\n    string public constant symbol = \"SMT\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    ///The value to be sent to our BTC address\r\n    uint public valueToBeSent = 1;\r\n    ///The ethereum address of the person manking the transaction\r\n    address personMakingTx;\r\n    //uint private output1,output2,output3,output4;\r\n    ///to return the address just for the testing purposes\r\n    address public addr1;\r\n    ///to return the tx origin just for the testing purposes\r\n    address public txorigin;\r\n\r\n    //function for testing only btc address\r\n    bool isTesting;\r\n    ///testing the name remove while deploying\r\n    bytes32 testname;\r\n    address finalOwner;\r\n    bool public finalizedPublicICO = false;\r\n    bool public finalizedPreICO = false;\r\n\r\n    uint256 public SMTfundAfterPreICO;\r\n    uint256 public ethraised;\r\n    uint256 public btcraised;\r\n\r\n    bool public istransferAllowed;\r\n\r\n    uint256 public constant SMTfund = 10 * (10**6) * 10**decimals; \r\n    uint256 public fundingStartBlock; // crowdsale start block\r\n    uint256 public fundingEndBlock; // crowdsale end block\r\n    uint256 public  tokensPerEther = 150; //TODO\r\n    uint256 public  tokensPerBTC = 22*150*(10**10);\r\n    uint256 public tokenCreationMax= 72* (10**5) * 10**decimals; //TODO\r\n    mapping (address => bool) ownership;\r\n\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n      if(!istransferAllowed) throw;\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    //this is the default constructor\r\n    function SMTToken(uint256 _fundingStartBlock, uint256 _fundingEndBlock){\r\n        totalSupply = SMTfund;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n    }\r\n\r\n\r\n    ICOSaleState public salestate = ICOSaleState.PrivateSale;\r\n\r\n    ///**To be replaced  the following by the following*///\r\n    /**\r\n\r\n    **/\r\n\r\n    /***Event to be fired when the state of the sale of the ICO is changes**/\r\n    event stateChange(ICOSaleState state);\r\n\r\n    /**\r\n\r\n    **/\r\n    function setState(ICOSaleState state)  returns (bool){\r\n    if(!ownership[msg.sender]) throw;\r\n    salestate = state;\r\n    stateChange(salestate);\r\n    return true;\r\n    }\r\n\r\n    /**\r\n\r\n    **/\r\n    function getState() returns (ICOSaleState) {\r\n    return salestate;\r\n\r\n    }\r\n\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n        if(!istransferAllowed) throw;\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function addToBalances(address _person,uint256 value) {\r\n        if(!ownership[msg.sender]) throw;\r\n        balances[_person] = SafeMath.add(balances[_person],value);\r\n\r\n    }\r\n\r\n    function addToOwnership(address owners) onlyOwner{\r\n        ownership[owners] = true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n        if(!istransferAllowed) throw;\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      if(!istransferAllowed) throw;\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    function increaseEthRaised(uint256 value){\r\n        if(!ownership[msg.sender]) throw;\r\n        ethraised+=value;\r\n    }\r\n\r\n    function increaseBTCRaised(uint256 value){\r\n        if(!ownership[msg.sender]) throw;\r\n        btcraised+=value;\r\n    }\r\n\r\n\r\n\r\n\r\n    function finalizePreICO(uint256 value) returns(bool){\r\n        if(!ownership[msg.sender]) throw;\r\n        finalizedPreICO = true;\r\n        SMTfundAfterPreICO =value;\r\n        return true;\r\n    }\r\n\r\n\r\n    function finalizePublicICO() returns(bool) {\r\n        if(!ownership[msg.sender]) throw;\r\n        finalizedPublicICO = true;\r\n        istransferAllowed = true;\r\n        return true;\r\n    }\r\n\r\n\r\n    function isValid() returns(bool){\r\n        if(block.number>=fundingStartBlock && block.number<fundingEndBlock ){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    ///do not allow payments on this address\r\n\r\n    function() payable{\r\n        throw;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  modifier stopInEmergency {\r\n    if (paused) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n// Bitcoin transaction parsing library\r\n\r\n// Copyright 2016 rain <https://keybase.io/rain>\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\r\n//\r\n// Raw Bitcoin transaction structure:\r\n//\r\n// field     | size | type     | description\r\n// version   | 4    | int32    | transaction version number\r\n// n_tx_in   | 1-9  | var_int  | number of transaction inputs\r\n// tx_in     | 41+  | tx_in[]  | list of transaction inputs\r\n// n_tx_out  | 1-9  | var_int  | number of transaction outputs\r\n// tx_out    | 9+   | tx_out[] | list of transaction outputs\r\n// lock_time | 4    | uint32   | block number / timestamp at which tx locked\r\n//\r\n// Transaction input (tx_in) structure:\r\n//\r\n// field      | size | type     | description\r\n// previous   | 36   | outpoint | Previous output transaction reference\r\n// script_len | 1-9  | var_int  | Length of the signature script\r\n// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\r\n// sequence   | 4    | uint32   | Sender transaction version\r\n//\r\n// OutPoint structure:\r\n//\r\n// field      | size | type     | description\r\n// hash       | 32   | char[32] | The hash of the referenced transaction\r\n// index      | 4    | uint32   | The index of this output in the referenced transaction\r\n//\r\n// Transaction output (tx_out) structure:\r\n//\r\n// field         | size | type     | description\r\n// value         | 8    | int64    | Transaction value (Satoshis)\r\n// pk_script_len | 1-9  | var_int  | Length of the public key script\r\n// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\r\n//\r\n// Variable integers (var_int) can be encoded differently depending\r\n// on the represented value, to save space. Variable integers always\r\n// precede an array of a variable length data type (e.g. tx_in).\r\n//\r\n// Variable integer encodings as a function of represented value:\r\n//\r\n// value           | bytes  | format\r\n// <0xFD (253)     | 1      | uint8\r\n// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\r\n// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\r\n// -               | 9      | 0xFF followed by length as uint64\r\n//\r\n// Public key scripts `pk_script` are set on the output and can\r\n// take a number of forms. The regular transaction script is\r\n// called 'pay-to-pubkey-hash' (P2PKH):\r\n//\r\n// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\r\n//\r\n// OP_x are Bitcoin script opcodes. The bytes representation (including\r\n// the 0x14 20-byte stack push) is:\r\n//\r\n// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\r\n//\r\n// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\r\n// the public key, preceded by a network version byte. (21 bytes total)\r\n//\r\n// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\r\n//\r\n// The Bitcoin address is derived from the pubKeyHash. The binary form is the\r\n// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\r\n// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\r\n// This is converted to base58 to form the publicly used Bitcoin address.\r\n// Mainnet P2PKH transaction scripts are to addresses beginning with '1'.\r\n//\r\n// P2SH ('pay to script hash') scripts only supply a script hash. The spender\r\n// must then provide the script that would allow them to redeem this output.\r\n// This allows for arbitrarily complex scripts to be funded using only a\r\n// hash of the script, and moves the onus on providing the script from\r\n// the spender to the redeemer.\r\n//\r\n// The P2SH script format is simple:\r\n//\r\n// OP_HASH160 <scriptHash> OP_EQUAL\r\n//\r\n// 0xA9 0x14 <scriptHash> 0x87\r\n//\r\n// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\r\n// redeem script. The P2SH address is derived from the scriptHash.\r\n// Addresses are the scriptHash with a version prefix of 5, encoded as\r\n// Base58check. These addresses begin with a '3'.\r\n\r\n\r\n\r\n// parse a raw bitcoin transaction byte array\r\nlibrary BTC {\r\n    // Convert a variable integer into something useful and return it and\r\n    // the index to after it.\r\n    function parseVarInt(bytes txBytes, uint pos) returns (uint, uint) {\r\n        // the first byte tells us how big the integer is\r\n        var ibit = uint8(txBytes[pos]);\r\n        pos += 1;  // skip ibit\r\n\r\n        if (ibit < 0xfd) {\r\n            return (ibit, pos);\r\n        } else if (ibit == 0xfd) {\r\n            return (getBytesLE(txBytes, pos, 16), pos + 2);\r\n        } else if (ibit == 0xfe) {\r\n            return (getBytesLE(txBytes, pos, 32), pos + 4);\r\n        } else if (ibit == 0xff) {\r\n            return (getBytesLE(txBytes, pos, 64), pos + 8);\r\n        }\r\n    }\r\n    // convert little endian bytes to uint\r\n    function getBytesLE(bytes data, uint pos, uint bits) returns (uint) {\r\n        if (bits == 8) {\r\n            return uint8(data[pos]);\r\n        } else if (bits == 16) {\r\n            return uint16(data[pos])\r\n                 + uint16(data[pos + 1]) * 2 ** 8;\r\n        } else if (bits == 32) {\r\n            return uint32(data[pos])\r\n                 + uint32(data[pos + 1]) * 2 ** 8\r\n                 + uint32(data[pos + 2]) * 2 ** 16\r\n                 + uint32(data[pos + 3]) * 2 ** 24;\r\n        } else if (bits == 64) {\r\n            return uint64(data[pos])\r\n                 + uint64(data[pos + 1]) * 2 ** 8\r\n                 + uint64(data[pos + 2]) * 2 ** 16\r\n                 + uint64(data[pos + 3]) * 2 ** 24\r\n                 + uint64(data[pos + 4]) * 2 ** 32\r\n                 + uint64(data[pos + 5]) * 2 ** 40\r\n                 + uint64(data[pos + 6]) * 2 ** 48\r\n                 + uint64(data[pos + 7]) * 2 ** 56;\r\n        }\r\n    }\r\n    // scan the full transaction bytes and return the first two output\r\n    // values (in satoshis) and addresses (in binary)\r\n    function getFirstTwoOutputs(bytes txBytes)\r\n             returns (uint, bytes20, uint, bytes20)\r\n    {\r\n        uint pos;\r\n        uint[] memory input_script_lens = new uint[](2);\r\n        uint[] memory output_script_lens = new uint[](2);\r\n        uint[] memory script_starts = new uint[](2);\r\n        uint[] memory output_values = new uint[](2);\r\n        bytes20[] memory output_addresses = new bytes20[](2);\r\n\r\n        pos = 4;  // skip version\r\n\r\n        (input_script_lens, pos) = scanInputs(txBytes, pos, 0);\r\n\r\n        (output_values, script_starts, output_script_lens, pos) = scanOutputs(txBytes, pos, 2);\r\n\r\n        for (uint i = 0; i < 2; i++) {\r\n            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\r\n            output_addresses[i] = pkhash;\r\n        }\r\n\r\n        return (output_values[0], output_addresses[0],\r\n                output_values[1], output_addresses[1]);\r\n    }\r\n    // Check whether `btcAddress` is in the transaction outputs *and*\r\n    // whether *at least* `value` has been sent to it.\r\n        // Check whether `btcAddress` is in the transaction outputs *and*\r\n    // whether *at least* `value` has been sent to it.\r\n    function checkValueSent(bytes txBytes, bytes20 btcAddress, uint value)\r\n             returns (bool,uint)\r\n    {\r\n        uint pos = 4;  // skip version\r\n        (, pos) = scanInputs(txBytes, pos, 0);  // find end of inputs\r\n\r\n        // scan *all* the outputs and find where they are\r\n        var (output_values, script_starts, output_script_lens,) = scanOutputs(txBytes, pos, 0);\r\n\r\n        // look at each output and check whether it at least value to btcAddress\r\n        for (uint i = 0; i < output_values.length; i++) {\r\n            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\r\n            if (pkhash == btcAddress && output_values[i] >= value) {\r\n                return (true,output_values[i]);\r\n            }\r\n        }\r\n    }\r\n    // scan the inputs and find the script lengths.\r\n    // return an array of script lengths and the end position\r\n    // of the inputs.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // outputs to scan through. stop=0 => scan all.\r\n    function scanInputs(bytes txBytes, uint pos, uint stop)\r\n             returns (uint[], uint)\r\n    {\r\n        uint n_inputs;\r\n        uint halt;\r\n        uint script_len;\r\n\r\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_inputs) {\r\n            halt = n_inputs;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory script_lens = new uint[](halt);\r\n\r\n        for (var i = 0; i < halt; i++) {\r\n            pos += 36;  // skip outpoint\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            script_lens[i] = script_len;\r\n            pos += script_len + 4;  // skip sig_script, seq\r\n        }\r\n\r\n        return (script_lens, pos);\r\n    }\r\n    // scan the outputs and find the values and script lengths.\r\n    // return array of values, array of script lengths and the\r\n    // end position of the outputs.\r\n    // takes a 'stop' argument which sets the maximum number of\r\n    // outputs to scan through. stop=0 => scan all.\r\n    function scanOutputs(bytes txBytes, uint pos, uint stop)\r\n             returns (uint[], uint[], uint[], uint)\r\n    {\r\n        uint n_outputs;\r\n        uint halt;\r\n        uint script_len;\r\n\r\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\r\n\r\n        if (stop == 0 || stop > n_outputs) {\r\n            halt = n_outputs;\r\n        } else {\r\n            halt = stop;\r\n        }\r\n\r\n        uint[] memory script_starts = new uint[](halt);\r\n        uint[] memory script_lens = new uint[](halt);\r\n        uint[] memory output_values = new uint[](halt);\r\n\r\n        for (var i = 0; i < halt; i++) {\r\n            output_values[i] = getBytesLE(txBytes, pos, 64);\r\n            pos += 8;\r\n\r\n            (script_len, pos) = parseVarInt(txBytes, pos);\r\n            script_starts[i] = pos;\r\n            script_lens[i] = script_len;\r\n            pos += script_len;\r\n        }\r\n\r\n        return (output_values, script_starts, script_lens, pos);\r\n    }\r\n    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\r\n    function sliceBytes20(bytes data, uint start) returns (bytes20) {\r\n        uint160 slice = 0;\r\n        for (uint160 i = 0; i < 20; i++) {\r\n            slice += uint160(data[i + start]) << (8 * (19 - i));\r\n        }\r\n        return bytes20(slice);\r\n    }\r\n    // returns true if the bytes located in txBytes by pos and\r\n    // script_len represent a P2PKH script\r\n    function isP2PKH(bytes txBytes, uint pos, uint script_len) returns (bool) {\r\n        return (script_len == 25)           // 20 byte pubkeyhash + 5 bytes of script\r\n            && (txBytes[pos] == 0x76)       // OP_DUP\r\n            && (txBytes[pos + 1] == 0xa9)   // OP_HASH160\r\n            && (txBytes[pos + 2] == 0x14)   // bytes to push\r\n            && (txBytes[pos + 23] == 0x88)  // OP_EQUALVERIFY\r\n            && (txBytes[pos + 24] == 0xac); // OP_CHECKSIG\r\n    }\r\n    // returns true if the bytes located in txBytes by pos and\r\n    // script_len represent a P2SH script\r\n    function isP2SH(bytes txBytes, uint pos, uint script_len) returns (bool) {\r\n        return (script_len == 23)           // 20 byte scripthash + 3 bytes of script\r\n            && (txBytes[pos + 0] == 0xa9)   // OP_HASH160\r\n            && (txBytes[pos + 1] == 0x14)   // bytes to push\r\n            && (txBytes[pos + 22] == 0x87); // OP_EQUAL\r\n    }\r\n    // Get the pubkeyhash / scripthash from an output script. Assumes\r\n    // pay-to-pubkey-hash (P2PKH) or pay-to-script-hash (P2SH) outputs.\r\n    // Returns the pubkeyhash/ scripthash, or zero if unknown output.\r\n    function parseOutputScript(bytes txBytes, uint pos, uint script_len)\r\n             returns (bytes20)\r\n    {\r\n        if (isP2PKH(txBytes, pos, script_len)) {\r\n            return sliceBytes20(txBytes, pos + 3);\r\n        } else if (isP2SH(txBytes, pos, script_len)) {\r\n            return sliceBytes20(txBytes, pos + 2);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract PricingStrategy{\r\n\r\n\t/**\r\n\treturns the base discount value\r\n\t@param  currentsupply is a 'current supply' value\r\n\t@param  contribution  is 'sent by the contributor'\r\n\t@return   an integer for getting the discount value of the base discounts\r\n\t**/\r\n\tfunction baseDiscounts(uint256 currentsupply,uint256 contribution,string types) returns (uint256){\r\n\t\tif(contribution==0) throw;\r\n\t\tif(keccak256(\"ethereum\")==keccak256(types)){\r\n\t\t\tif(currentsupply>=0 && currentsupply<= 15*(10**5) * (10**18) && contribution>=1*10**18){\r\n\t\t\t return 40;\r\n\t\t\t}else if(currentsupply> 15*(10**5) * (10**18) && currentsupply< 30*(10**5) * (10**18) && contribution>=5*10**17){\r\n\t\t\t\treturn 30;\r\n\t\t\t}else{\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\t}else if(keccak256(\"bitcoin\")==keccak256(types)){\r\n\t\t\t\tif(currentsupply>=0 && currentsupply<= 15*(10**5) * (10**18) && contribution>=45*10**5){\r\n\t\t\t\t return 40;\r\n\t\t\t\t}else if(currentsupply> 15*(10**5) * (10**18) && currentsupply< 30*(10**5) * (10**18) && contribution>=225*10**4){\r\n\t\t\t\t\treturn 30;\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t}\r\n\r\n\t/**\r\n\t\r\n\tThese are the base discounts offered by the sunMOneyToken\r\n\tThese are valid ffor every value sent to the contract\r\n\t@param   contribution is a 'the value sent in wei by the contributor in ethereum'\r\n\t@return  the discount\r\n\t**/\r\n\tfunction volumeDiscounts(uint256 contribution,string types) returns (uint256){\r\n\t\t///do not allow the zero contrbution \r\n\t\t//its unsigned negative checking not required\r\n\t\tif(contribution==0) throw;\r\n\t\tif(keccak256(\"ethereum\")==keccak256(types)){\r\n\t\t\tif(contribution>=3*10**18 && contribution<10*10**18){\r\n\t\t\t\treturn 0;\r\n\t\t\t}else if(contribution>=10*10**18 && contribution<20*10**18){\r\n\t\t\t\treturn 5;\r\n\t\t\t}else if(contribution>=20*10**18){\r\n\t\t\t\treturn 10;\r\n\t\t\t}else{\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\t}else if(keccak256(\"bitcoin\")==keccak256(types)){\r\n\t\t\t\tif(contribution>=3*45*10**5 && contribution<10*45*10**5){\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}else if(contribution>=10*45*10**5 && contribution<20*45*10**5){\r\n\t\t\t\t\treturn 5;\r\n\t\t\t\t}else if(contribution>=20*45*10**5){\r\n\t\t\t\t\treturn 10;\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t}\r\n\r\n\t/**returns the total discount value**/\r\n\t/**\r\n\t@param  currentsupply is a 'current supply'\r\n\t@param  contribution is a 'sent by the contributor'\r\n\t@return   an integer for getting the total discounts\r\n\t**/\r\n\tfunction totalDiscount(uint256 currentsupply,uint256 contribution,string types) returns (uint256){\r\n\t\tuint256 basediscount = baseDiscounts(currentsupply,contribution,types);\r\n\t\tuint256 volumediscount = volumeDiscounts(contribution,types);\r\n\t\tuint256 totaldiscount = basediscount+volumediscount;\r\n\t\treturn totaldiscount;\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract PreICO is Ownable,Pausable, Utils,PricingStrategy,Sales{\r\n\r\n\tSMTToken token;\r\n\tuint256 public tokensPerBTC;\r\n\tuint public tokensPerEther;\r\n\tuint256 public initialSupplyPrivateSale;\r\n\tuint256 public initialSupplyPreSale;\r\n\tuint256 public SMTfundAfterPreICO;\r\n\tuint256 public initialSupplyPublicPreICO;\r\n\tuint256 public currentSupply;\r\n\tuint256 public fundingStartBlock;\r\n\tuint256 public fundingEndBlock;\r\n\tuint256 public SMTfund;\r\n\tuint256 public tokenCreationMaxPreICO = 15* (10**5) * 10**18;\r\n\tuint256 public tokenCreationMaxPrivateSale = 15*(10**5) * (10**18);\r\n\t///tokens for the team\r\n\tuint256 public team = 1*(10**6)*(10**18);\r\n\t///tokens for reserve\r\n\tuint256 public reserve = 1*(10**6)*(10**18);\r\n\t///tokens for the mentors\r\n\tuint256 public mentors = 5*(10**5)*10**18;\r\n\t///tokkens for the bounty\r\n\tuint256 public bounty = 3*(10**5)*10**18;\r\n\t///address for the teeam,investores,etc\r\n\r\n\tuint256 totalsend = team+reserve+bounty+mentors;\r\n\taddress public addressPeople = 0xea0f17CA7C3e371af30EFE8CbA0e646374552e8B;\r\n\r\n\taddress public ownerAddr = 0x4cA09B312F23b390450D902B21c7869AA64877E3;\r\n\t///array of addresses for the ethereum relateed back funding  contract\r\n\tuint256 public numberOfBackers;\r\n\t///the txorigin is the web3.eth.coinbase account\r\n\t//record Transactions that have claimed ether to prevent the replay attacks\r\n\t//to-do\r\n\tmapping(uint256 => bool) transactionsClaimed;\r\n\tuint256 public valueToBeSent;\r\n\r\n\t//the constructor function\r\n   function PreICO(address tokenAddress){\r\n\t\t//require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\r\n\t\ttoken = SMTToken(tokenAddress);\r\n\t\ttokensPerEther = token.tokensPerEther();\r\n\t\ttokensPerBTC = token.tokensPerBTC();\r\n\t\tvalueToBeSent = token.valueToBeSent();\r\n\t\tSMTfund = token.SMTfund();\r\n\t}\r\n\t\r\n\t////function to send initialFUnd\r\n    function sendFunds() onlyOwner{\r\n        token.addToBalances(addressPeople,totalsend);\r\n    }\r\n\r\n\t///a function using safemath to work with\r\n\t///the new function\r\n\tfunction calNewTokens(uint256 contribution,string types) returns (uint256){\r\n\t\tuint256 disc = totalDiscount(currentSupply,contribution,types);\r\n\t\tuint256 CreatedTokens;\r\n\t\tif(keccak256(types)==keccak256(\"ethereum\")) CreatedTokens = SafeMath.mul(contribution,tokensPerEther);\r\n\t\telse if(keccak256(types)==keccak256(\"bitcoin\"))  CreatedTokens = SafeMath.mul(contribution,tokensPerBTC);\r\n\t\tuint256 tokens = SafeMath.add(CreatedTokens,SafeMath.div(SafeMath.mul(CreatedTokens,disc),100));\r\n\t\treturn tokens;\r\n\t}\r\n\t/**\r\n\t\tPayable function to send the ether funds\r\n\t**/\r\n\tfunction() external payable stopInEmergency{\r\n        if(token.getState()==ICOSaleState.PublicICO) throw;\r\n        bool isfinalized = token.finalizedPreICO();\r\n        bool isValid = token.isValid();\r\n        if(isfinalized) throw;\r\n        if(!isValid) throw;\r\n        if (msg.value == 0) throw;\r\n        uint256 newCreatedTokens;\r\n        ///since we are creating tokens we need to increase the total supply\r\n        if(token.getState()==ICOSaleState.PrivateSale||token.getState()==ICOSaleState.PreSale) {\r\n        \tif((msg.value) < 1*10**18) throw;\r\n        \tnewCreatedTokens =calNewTokens(msg.value,\"ethereum\");\r\n        \tuint256 temp = SafeMath.add(initialSupplyPrivateSale,newCreatedTokens);\r\n        \tif(temp>tokenCreationMaxPrivateSale){\r\n        \t\tuint256 consumed = SafeMath.sub(tokenCreationMaxPrivateSale,initialSupplyPrivateSale);\r\n        \t\tinitialSupplyPrivateSale = SafeMath.add(initialSupplyPrivateSale,consumed);\r\n        \t\tcurrentSupply = SafeMath.add(currentSupply,consumed);\r\n        \t\tuint256 nonConsumed = SafeMath.sub(newCreatedTokens,consumed);\r\n        \t\tuint256 finalTokens = SafeMath.sub(nonConsumed,SafeMath.div(nonConsumed,10));\r\n        \t\tswitchState();\r\n        \t\tinitialSupplyPublicPreICO = SafeMath.add(initialSupplyPublicPreICO,finalTokens);\r\n        \t\tcurrentSupply = SafeMath.add(currentSupply,finalTokens);\r\n        \t\tif(initialSupplyPublicPreICO>tokenCreationMaxPreICO) throw;\r\n        \t\tnumberOfBackers++;\r\n               token.addToBalances(msg.sender,SafeMath.add(finalTokens,consumed));\r\n        \t if(!ownerAddr.send(msg.value))throw;\r\n        \t  token.increaseEthRaised(msg.value);\r\n        \t}else{\r\n    \t\t\tinitialSupplyPrivateSale = SafeMath.add(initialSupplyPrivateSale,newCreatedTokens);\r\n    \t\t\tcurrentSupply = SafeMath.add(currentSupply,newCreatedTokens);\r\n    \t\t\tif(initialSupplyPrivateSale>tokenCreationMaxPrivateSale) throw;\r\n    \t\t\tnumberOfBackers++;\r\n                token.addToBalances(msg.sender,newCreatedTokens);\r\n            \tif(!ownerAddr.send(msg.value))throw;\r\n            \ttoken.increaseEthRaised(msg.value);\r\n    \t\t}\r\n        }\r\n        else if(token.getState()==ICOSaleState.PreICO){\r\n        \tif(msg.value < 5*10**17) throw;\r\n        \tnewCreatedTokens =calNewTokens(msg.value,\"ethereum\");\r\n        \tinitialSupplyPublicPreICO = SafeMath.add(initialSupplyPublicPreICO,newCreatedTokens);\r\n        \tcurrentSupply = SafeMath.add(currentSupply,newCreatedTokens);\r\n        \tif(initialSupplyPublicPreICO>tokenCreationMaxPreICO) throw;\r\n        \tnumberOfBackers++;\r\n             token.addToBalances(msg.sender,newCreatedTokens);\r\n        \tif(!ownerAddr.send(msg.value))throw;\r\n        \ttoken.increaseEthRaised(msg.value);\r\n        }\r\n\r\n\t}\r\n\r\n\t///token distribution initial function for the one in the exchanges\r\n\t///to be done only the owner can run this function\r\n\tfunction tokenAssignExchange(address addr,uint256 val,uint256 txnHash) public onlyOwner {\r\n\t   // if(msg.sender!=owner) throw;\r\n\t  if (val == 0) throw;\r\n\t  if(token.getState()==ICOSaleState.PublicICO) throw;\r\n\t  if(transactionsClaimed[txnHash]) throw;\r\n\t  bool isfinalized = token.finalizedPreICO();\r\n\t  if(isfinalized) throw;\r\n\t  bool isValid = token.isValid();\r\n\t  if(!isValid) throw;\r\n\t  uint256 newCreatedTokens;\r\n        if(token.getState()==ICOSaleState.PrivateSale||token.getState()==ICOSaleState.PreSale) {\r\n        \tif(val < 1*10**18) throw;\r\n        \tnewCreatedTokens =calNewTokens(val,\"ethereum\");\r\n        \tuint256 temp = SafeMath.add(initialSupplyPrivateSale,newCreatedTokens);\r\n        \tif(temp>tokenCreationMaxPrivateSale){\r\n        \t\tuint256 consumed = SafeMath.sub(tokenCreationMaxPrivateSale,initialSupplyPrivateSale);\r\n        \t\tinitialSupplyPrivateSale = SafeMath.add(initialSupplyPrivateSale,consumed);\r\n        \t\tcurrentSupply = SafeMath.add(currentSupply,consumed);\r\n        \t\tuint256 nonConsumed = SafeMath.sub(newCreatedTokens,consumed);\r\n        \t\tuint256 finalTokens = SafeMath.sub(nonConsumed,SafeMath.div(nonConsumed,10));\r\n        \t\tswitchState();\r\n        \t\tinitialSupplyPublicPreICO = SafeMath.add(initialSupplyPublicPreICO,finalTokens);\r\n        \t\tcurrentSupply = SafeMath.add(currentSupply,finalTokens);\r\n        \t\tif(initialSupplyPublicPreICO>tokenCreationMaxPreICO) throw;\r\n        \t\tnumberOfBackers++;\r\n               token.addToBalances(addr,SafeMath.add(finalTokens,consumed));\r\n        \t   token.increaseEthRaised(val);\r\n        \t}else{\r\n    \t\t\tinitialSupplyPrivateSale = SafeMath.add(initialSupplyPrivateSale,newCreatedTokens);\r\n    \t\t\tcurrentSupply = SafeMath.add(currentSupply,newCreatedTokens);\r\n    \t\t\tif(initialSupplyPrivateSale>tokenCreationMaxPrivateSale) throw;\r\n    \t\t\tnumberOfBackers++;\r\n                token.addToBalances(addr,newCreatedTokens);\r\n            \ttoken.increaseEthRaised(val);\r\n    \t\t}\r\n        }\r\n        else if(token.getState()==ICOSaleState.PreICO){\r\n        \tif(msg.value < 5*10**17) throw;\r\n        \tnewCreatedTokens =calNewTokens(val,\"ethereum\");\r\n        \tinitialSupplyPublicPreICO = SafeMath.add(initialSupplyPublicPreICO,newCreatedTokens);\r\n        \tcurrentSupply = SafeMath.add(currentSupply,newCreatedTokens);\r\n        \tif(initialSupplyPublicPreICO>tokenCreationMaxPreICO) throw;\r\n        \tnumberOfBackers++;\r\n             token.addToBalances(addr,newCreatedTokens);\r\n        \ttoken.increaseEthRaised(val);\r\n        }\r\n\t}\r\n\r\n\t//Token distribution for the case of the ICO\r\n\t///function to run when the transaction has been veified\r\n\tfunction processTransaction(bytes txn, uint256 txHash,address addr,bytes20 btcaddr) onlyOwner returns (uint)\r\n\t{\r\n\t\tbool valueSent;\r\n\t\tbool isValid = token.isValid();\r\n\t\tif(!isValid) throw;\r\n\t\t//txorigin = tx.origin;\r\n\t\t//\tif(token.getState()!=State.Funding) throw;\r\n\t\tif(!transactionsClaimed[txHash]){\r\n\t\t\tvar (a,b) = BTC.checkValueSent(txn,btcaddr,valueToBeSent);\r\n\t\t\tif(a){\r\n\t\t\t\tvalueSent = true;\r\n\t\t\t\ttransactionsClaimed[txHash] = true;\r\n\t\t\t\tuint256 newCreatedTokens;\r\n\t\t\t\t ///since we are creating tokens we need to increase the total supply\r\n            if(token.getState()==ICOSaleState.PrivateSale||token.getState()==ICOSaleState.PreSale) {\r\n        \tif(b < 45*10**5) throw;\r\n        \tnewCreatedTokens =calNewTokens(b,\"bitcoin\");\r\n        \tuint256 temp = SafeMath.add(initialSupplyPrivateSale,newCreatedTokens);\r\n        \tif(temp>tokenCreationMaxPrivateSale){\r\n        \t\tuint256 consumed = SafeMath.sub(tokenCreationMaxPrivateSale,initialSupplyPrivateSale);\r\n        \t\tinitialSupplyPrivateSale = SafeMath.add(initialSupplyPrivateSale,consumed);\r\n        \t\tcurrentSupply = SafeMath.add(currentSupply,consumed);\r\n        \t\tuint256 nonConsumed = SafeMath.sub(newCreatedTokens,consumed);\r\n        \t\tuint256 finalTokens = SafeMath.sub(nonConsumed,SafeMath.div(nonConsumed,10));\r\n        \t\tswitchState();\r\n        \t\tinitialSupplyPublicPreICO = SafeMath.add(initialSupplyPublicPreICO,finalTokens);\r\n        \t\tcurrentSupply = SafeMath.add(currentSupply,finalTokens);\r\n        \t\tif(initialSupplyPublicPreICO>tokenCreationMaxPreICO) throw;\r\n        \t\tnumberOfBackers++;\r\n               token.addToBalances(addr,SafeMath.add(finalTokens,consumed));\r\n        \t   token.increaseBTCRaised(b);\r\n        \t}else{\r\n    \t\t\tinitialSupplyPrivateSale = SafeMath.add(initialSupplyPrivateSale,newCreatedTokens);\r\n    \t\t\tcurrentSupply = SafeMath.add(currentSupply,newCreatedTokens);\r\n    \t\t\tif(initialSupplyPrivateSale>tokenCreationMaxPrivateSale) throw;\r\n    \t\t\tnumberOfBackers++;\r\n                token.addToBalances(addr,newCreatedTokens);\r\n            \ttoken.increaseBTCRaised(b);\r\n    \t\t}\r\n        }\r\n        else if(token.getState()==ICOSaleState.PreICO){\r\n        \tif(msg.value < 225*10**4) throw;\r\n        \tnewCreatedTokens =calNewTokens(b,\"bitcoin\");\r\n        \tinitialSupplyPublicPreICO = SafeMath.add(initialSupplyPublicPreICO,newCreatedTokens);\r\n        \tcurrentSupply = SafeMath.add(currentSupply,newCreatedTokens);\r\n        \tif(initialSupplyPublicPreICO>tokenCreationMaxPreICO) throw;\r\n        \tnumberOfBackers++;\r\n             token.addToBalances(addr,newCreatedTokens);\r\n        \ttoken.increaseBTCRaised(b);\r\n         }\r\n\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse{\r\n\t\t    throw;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction finalizePreICO() public onlyOwner{\r\n\t\tuint256 val = currentSupply;\r\n\t\ttoken.finalizePreICO(val);\r\n\t}\r\n\r\n\tfunction switchState() internal  {\r\n\t\t token.setState(ICOSaleState.PreICO);\r\n\t\t\r\n\t}\r\n\t\r\n\r\n\t\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupplyPreSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"valueToBeSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupplyPublicPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contribution\",\"type\":\"uint256\"},{\"name\":\"types\",\"type\":\"string\"}],\"name\":\"volumeDiscounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMaxPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizePreICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mentors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contribution\",\"type\":\"uint256\"},{\"name\":\"types\",\"type\":\"string\"}],\"name\":\"calNewTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressPeople\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"val\",\"type\":\"uint256\"},{\"name\":\"txnHash\",\"type\":\"uint256\"}],\"name\":\"tokenAssignExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupplyPrivateSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txn\",\"type\":\"bytes\"},{\"name\":\"txHash\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"btcaddr\",\"type\":\"bytes20\"}],\"name\":\"processTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currentsupply\",\"type\":\"uint256\"},{\"name\":\"contribution\",\"type\":\"uint256\"},{\"name\":\"types\",\"type\":\"string\"}],\"name\":\"totalDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SMTfundAfterPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerBTC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SMTfund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currentsupply\",\"type\":\"uint256\"},{\"name\":\"contribution\",\"type\":\"uint256\"},{\"name\":\"types\",\"type\":\"string\"}],\"name\":\"baseDiscounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMaxPrivateSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PreICO","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000c761c8dc05ae52a8a785665e528ddbb00c098ad1","Library":"BTC:720c9a0a45b46a84fc1730224ab6cf617cdd98de","SwarmSource":"bzzr://bf314860ea0208aad4b9816b36ef42f1c06e639e075ae47bb744369d0bcc5dff"}]}