{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned()  public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner  public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract tokenRecipient {\r\n    event receivedEther(address sender, uint amount);\r\n    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);\r\n\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\r\n        Token t = Token(_token);\r\n        require(t.transferFrom(_from, this, _value));\r\n        receivedTokens(_from, _value, _token, _extraData);\r\n    }\r\n\r\n    function () payable  public {\r\n        receivedEther(msg.sender, msg.value);\r\n    }\r\n}\r\n\r\ninterface Token {\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract Congress is owned, tokenRecipient {\r\n    // Contract Variables and events\r\n    uint public minimumQuorum;\r\n    uint public debatingPeriodInMinutes;\r\n    int public majorityMargin;\r\n    Proposal[] public proposals;\r\n    uint public numProposals;\r\n    mapping (address => uint) public memberId;\r\n    Member[] public members;\r\n\r\n    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\r\n    event Voted(uint proposalID, bool position, address voter, string justification);\r\n    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\r\n    event MembershipChanged(address member, bool isMember);\r\n    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, int newMajorityMargin);\r\n\r\n    struct Proposal {\r\n        address recipient;\r\n        uint amount;\r\n        string description;\r\n        uint votingDeadline;\r\n        bool executed;\r\n        bool proposalPassed;\r\n        uint numberOfVotes;\r\n        int currentResult;\r\n        bytes32 proposalHash;\r\n        Vote[] votes;\r\n        mapping (address => bool) voted;\r\n    }\r\n\r\n    struct Member {\r\n        address member;\r\n        string name;\r\n        uint memberSince;\r\n    }\r\n\r\n    struct Vote {\r\n        bool inSupport;\r\n        address voter;\r\n        string justification;\r\n    }\r\n\r\n    // Modifier that allows only shareholders to vote and create new proposals\r\n    modifier onlyMembers {\r\n        require(memberId[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor function\r\n     */\r\n    function Congress (\r\n        uint minimumQuorumForProposals,\r\n        uint minutesForDebate,\r\n        int marginOfVotesForMajority\r\n    )  payable public {\r\n        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);\r\n        // Itâ€™s necessary to add an empty first member\r\n        addMember(0, \"\");\r\n        // and let's add the founder, to save a step later\r\n        addMember(owner, 'founder');\r\n    }\r\n\r\n    /**\r\n     * Add member\r\n     *\r\n     * Make `targetMember` a member named `memberName`\r\n     *\r\n     * @param targetMember ethereum address to be added\r\n     * @param memberName public name for that member\r\n     */\r\n    function addMember(address targetMember, string memberName) onlyOwner public {\r\n        uint id = memberId[targetMember];\r\n        if (id == 0) {\r\n            memberId[targetMember] = members.length;\r\n            id = members.length++;\r\n        }\r\n\r\n        members[id] = Member({member: targetMember, memberSince: now, name: memberName});\r\n        MembershipChanged(targetMember, true);\r\n    }\r\n\r\n    /**\r\n     * Remove member\r\n     *\r\n     * @notice Remove membership from `targetMember`\r\n     *\r\n     * @param targetMember ethereum address to be removed\r\n     */\r\n    function removeMember(address targetMember) onlyOwner public {\r\n        require(memberId[targetMember] != 0);\r\n\r\n        for (uint i = memberId[targetMember]; i<members.length-1; i++){\r\n            members[i] = members[i+1];\r\n        }\r\n        delete members[members.length-1];\r\n        members.length--;\r\n    }\r\n\r\n    /**\r\n     * Change voting rules\r\n     *\r\n     * Make so that proposals need tobe discussed for at least `minutesForDebate/60` hours,\r\n     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed\r\n     *\r\n     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed\r\n     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\r\n     * @param marginOfVotesForMajority the proposal needs to have 50% plus this number\r\n     */\r\n    function changeVotingRules(\r\n        uint minimumQuorumForProposals,\r\n        uint minutesForDebate,\r\n        int marginOfVotesForMajority\r\n    ) onlyOwner public {\r\n        minimumQuorum = minimumQuorumForProposals;\r\n        debatingPeriodInMinutes = minutesForDebate;\r\n        majorityMargin = marginOfVotesForMajority;\r\n\r\n        ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);\r\n    }\r\n\r\n    /**\r\n     * Add Proposal\r\n     *\r\n     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\r\n     *\r\n     * @param beneficiary who to send the ether to\r\n     * @param weiAmount amount of ether to send, in wei\r\n     * @param jobDescription Description of job\r\n     * @param transactionBytecode bytecode of transaction\r\n     */\r\n    function newProposal(\r\n        address beneficiary,\r\n        uint weiAmount,\r\n        string jobDescription,\r\n        bytes transactionBytecode\r\n    )\r\n        onlyMembers public\r\n        returns (uint proposalID)\r\n    {\r\n        proposalID = proposals.length++;\r\n        Proposal storage p = proposals[proposalID];\r\n        p.recipient = beneficiary;\r\n        p.amount = weiAmount;\r\n        p.description = jobDescription;\r\n        p.proposalHash = keccak256(beneficiary, weiAmount, transactionBytecode);\r\n        p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\r\n        p.executed = false;\r\n        p.proposalPassed = false;\r\n        p.numberOfVotes = 0;\r\n        ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\r\n        numProposals = proposalID+1;\r\n\r\n        return proposalID;\r\n    }\r\n\r\n    /**\r\n     * Add proposal in Ether\r\n     *\r\n     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\r\n     * This is a convenience function to use if the amount to be given is in round number of ether units.\r\n     *\r\n     * @param beneficiary who to send the ether to\r\n     * @param etherAmount amount of ether to send\r\n     * @param jobDescription Description of job\r\n     * @param transactionBytecode bytecode of transaction\r\n     */\r\n    function newProposalInEther(\r\n        address beneficiary,\r\n        uint etherAmount,\r\n        string jobDescription,\r\n        bytes transactionBytecode\r\n    )\r\n        onlyMembers public\r\n        returns (uint proposalID)\r\n    {\r\n        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\r\n    }\r\n\r\n    /**\r\n     * Check if a proposal code matches\r\n     *\r\n     * @param proposalNumber ID number of the proposal to query\r\n     * @param beneficiary who to send the ether to\r\n     * @param weiAmount amount of ether to send\r\n     * @param transactionBytecode bytecode of transaction\r\n     */\r\n    function checkProposalCode(\r\n        uint proposalNumber,\r\n        address beneficiary,\r\n        uint weiAmount,\r\n        bytes transactionBytecode\r\n    )\r\n        constant public\r\n        returns (bool codeChecksOut)\r\n    {\r\n        Proposal storage p = proposals[proposalNumber];\r\n        return p.proposalHash == keccak256(beneficiary, weiAmount, transactionBytecode);\r\n    }\r\n\r\n    /**\r\n     * Log a vote for a proposal\r\n     *\r\n     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\r\n     *\r\n     * @param proposalNumber number of proposal\r\n     * @param supportsProposal either in favor or against it\r\n     * @param justificationText optional justification text\r\n     */\r\n    function vote(\r\n        uint proposalNumber,\r\n        bool supportsProposal,\r\n        string justificationText\r\n    )\r\n        onlyMembers public\r\n        returns (uint voteID)\r\n    {\r\n        Proposal storage p = proposals[proposalNumber];         // Get the proposal\r\n        require(!p.voted[msg.sender]);         // If has already voted, cancel\r\n        p.voted[msg.sender] = true;                     // Set this voter as having voted\r\n        p.numberOfVotes++;                              // Increase the number of votes\r\n        if (supportsProposal) {                         // If they support the proposal\r\n            p.currentResult++;                          // Increase score\r\n        } else {                                        // If they don't\r\n            p.currentResult--;                          // Decrease the score\r\n        }\r\n\r\n        // Create a log of this event\r\n        Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);\r\n        return p.numberOfVotes;\r\n    }\r\n\r\n    /**\r\n     * Finish vote\r\n     *\r\n     * Count the votes proposal #`proposalNumber` and execute it if approved\r\n     *\r\n     * @param proposalNumber proposal number\r\n     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\r\n     */\r\n    function executeProposal(uint proposalNumber, bytes transactionBytecode) public {\r\n        Proposal storage p = proposals[proposalNumber];\r\n\r\n        require(now > p.votingDeadline                                            // If it is past the voting deadline\r\n            && !p.executed                                                         // and it has not already been executed\r\n            && p.proposalHash == keccak256(p.recipient, p.amount, transactionBytecode)  // and the supplied code matches the proposal\r\n            && p.numberOfVotes >= minimumQuorum);                                  // and a minimum quorum has been reached...\r\n\r\n        // ...then execute result\r\n\r\n        if (p.currentResult > majorityMargin) {\r\n            // Proposal passed; execute the transaction\r\n\r\n            p.executed = true; // Avoid recursive calling\r\n            require(p.recipient.call.value(p.amount)(transactionBytecode));\r\n\r\n            p.proposalPassed = true;\r\n        } else {\r\n            // Proposal failed\r\n            p.proposalPassed = false;\r\n        }\r\n\r\n        // Fire Events\r\n        ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"currentResult\",\"type\":\"int256\"},{\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"memberId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"member\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"memberSince\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriodInMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"majorityMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"jobDescription\",\"type\":\"string\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"jobDescription\",\"type\":\"string\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"newProposalInEther\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"}],\"name\":\"changeVotingRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetMember\",\"type\":\"address\"},{\"name\":\"memberName\",\"type\":\"string\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"supportsProposal\",\"type\":\"bool\"},{\"name\":\"justificationText\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"voteID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"transactionBytecode\",\"type\":\"bytes\"}],\"name\":\"checkProposalCode\",\"outputs\":[{\"name\":\"codeChecksOut\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"minimumQuorumForProposals\",\"type\":\"uint256\"},{\"name\":\"minutesForDebate\",\"type\":\"uint256\"},{\"name\":\"marginOfVotesForMajority\",\"type\":\"int256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"justification\",\"type\":\"string\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isMember\",\"type\":\"bool\"}],\"name\":\"MembershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMinimumQuorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDebatingPeriodInMinutes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newMajorityMargin\",\"type\":\"int256\"}],\"name\":\"ChangeOfRules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"receivedEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receivedTokens\",\"type\":\"event\"}]","ContractName":"Congress","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://de5b52ef3b5be43c7116093e1197fac5a8709e014daa9a70bdab181a14182025"}]}