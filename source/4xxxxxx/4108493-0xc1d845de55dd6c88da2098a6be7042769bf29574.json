{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4 .13;\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns(uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) {\r\n            revert();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        if (newOwner != address(0)) owner = newOwner;\r\n    }\r\n\r\n    function kill() {\r\n        if (msg.sender == owner) selfdestruct(owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert();\r\n            _;\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    bool public stopped;\r\n\r\n    modifier stopInEmergency {\r\n        if (stopped) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyInEmergency {\r\n        if (!stopped) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    // Called by the owner in emergency, triggers stopped state\r\n    function emergencyStop() external onlyOwner {\r\n        stopped = true;\r\n    }\r\n\r\n    // Called by the owner to end of emergency, returns to normal state\r\n    function release() external onlyOwner onlyInEmergency {\r\n        stopped = false;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// Presale Smart Contract\r\n// This smart contract collects ETH during presale. Tokens are not distributed during\r\n// this time. Only informatoion stored how much tokens should be allocated in the future.\r\ncontract Presale is SafeMath, Pausable {\r\n\r\n    struct Backer {\r\n        uint weiReceived;   // amount of ETH contributed\r\n        uint SOCXSent;      // amount of tokens to be sent\r\n        bool processed;     // true if tokens transffered.\r\n    }\r\n    \r\n    address public multisigETH; // Multisig contract that will receive the ETH    \r\n    uint public ETHReceived;    // Number of ETH received\r\n    uint public SOCXSentToETH;  // Number of SOCX sent to ETH contributors\r\n    uint public startBlock;     // Presale start block\r\n    uint public endBlock;       // Presale end block\r\n\r\n    uint public minContributeETH;// Minimum amount to contribute\r\n    bool public presaleClosed;  // Is presale still on going\r\n    uint public maxCap;         // Maximum number of SOCX to sell\r\n\r\n    uint totalTokensSold;       // tokens sold during the campaign\r\n    uint tokenPriceWei;         // price of tokens in Wei\r\n\r\n\r\n    uint multiplier = 10000000000;              // to provide 10 decimal values\r\n    mapping(address => Backer) public backers;  // backer list accessible through address\r\n    address[] public backersIndex;              // order list of backer to be able to itarate through when distributing the tokens. \r\n\r\n\r\n    // @notice to be used when certain account is required to access the function\r\n    // @param a {address}  The address of the authorised individual\r\n    modifier onlyBy(address a) {\r\n        if (msg.sender != a) revert();\r\n        _;\r\n    }\r\n\r\n    // @notice to verify if action is not performed out of the campaing time range\r\n    modifier respectTimeFrame() {\r\n        if ((block.number < startBlock) || (block.number > endBlock)) revert();\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    // Events\r\n    event ReceivedETH(address backer, uint amount, uint tokenAmount);\r\n\r\n\r\n\r\n    // Presale  {constructor}\r\n    // @notice fired when contract is crated. Initilizes all constnat variables.\r\n    function Presale() {     \r\n           \r\n        multisigETH = 0x7bf08cb1732e1246c65b51b83ac092f9b4ebb8c6; //TODO: Replace address with correct one\r\n        maxCap = 2000000 * multiplier;  // max amount of tokens to be sold\r\n        SOCXSentToETH = 0;              // tokens sold so far\r\n        minContributeETH = 1 ether;     // minimum contribution acceptable\r\n        startBlock = 0;                 // start block of the campaign, it will be set in start() function\r\n        endBlock = 0;                   // end block of the campaign, it will be set in start() function \r\n        tokenPriceWei = 720000000000000;// price of token expressed in Wei \r\n    }\r\n\r\n    // @notice to obtain number of contributors so later \"front end\" can loop through backersIndex and \r\n    // triggger transfer of tokens\r\n    // @return  {uint} true if transaction was successful\r\n    function numberOfBackers() constant returns(uint) {\r\n        return backersIndex.length;\r\n    }\r\n\r\n    function updateMultiSig(address _multisigETH) onlyBy(owner) {\r\n        multisigETH = _multisigETH;\r\n    }\r\n\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handels allocation of Ether and calculates SOCX tokens.\r\n    function () payable {\r\n        if (block.number > endBlock) revert();\r\n        handleETH(msg.sender);\r\n    }\r\n\r\n    // @notice It will be called by owner to start the sale\r\n    // TODO WARNING REMOVE _block parameter and _block variable in function\r\n    function start() onlyBy(owner) {\r\n        startBlock = block.number;        \r\n        endBlock = startBlock + 57600;\r\n        // 10 days in blocks = 57600 (4*60*24*10)\r\n        // enable this for live assuming each bloc takes 15 sec.\r\n    }\r\n\r\n    // @notice called to mark contributer when tokens are transfered to them after ICO\r\n    // @param _backer {address} address of beneficiary\r\n    function process(address _backer) onlyBy(owner) returns (bool){\r\n\r\n        Backer storage backer = backers[_backer]; \r\n        backer.processed = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _backer {address} address of beneficiary\r\n    // @return res {bool} true if transaction was successful\r\n    function handleETH(address _backer) internal stopInEmergency respectTimeFrame returns(bool res) {\r\n\r\n        if (msg.value < minContributeETH) revert();                     // stop when required minimum is not sent\r\n        uint SOCXToSend = (msg.value / tokenPriceWei) * multiplier; // calculate number of tokens\r\n\r\n        \r\n        if (safeAdd(SOCXSentToETH, SOCXToSend) > maxCap) revert();  // ensure that max cap hasn't been reached yet\r\n\r\n        Backer storage backer = backers[_backer];                   // access backer record\r\n        backer.SOCXSent = safeAdd(backer.SOCXSent, SOCXToSend);     // calculate number of tokens sent by backer\r\n        backer.weiReceived = safeAdd(backer.weiReceived, msg.value);// store amount of Ether received in Wei\r\n        ETHReceived = safeAdd(ETHReceived, msg.value);              // update the total Ether recived\r\n        SOCXSentToETH = safeAdd(SOCXSentToETH, SOCXToSend);         // keep total number of tokens sold\r\n        backersIndex.push(_backer);                                 // maintain iterable storage of contributors\r\n\r\n        ReceivedETH(_backer, msg.value, SOCXToSend);                // register event\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    // @notice This function will finalize the sale.\r\n    // It will only execute if predetermined sale time passed \r\n    // if successfull it will transfer collected Ether into predetermined multisig wallet or address\r\n    function finalize() onlyBy(owner) {\r\n\r\n        if (block.number < endBlock && SOCXSentToETH < maxCap) revert();\r\n\r\n        if (!multisigETH.send(this.balance)) revert();\r\n        presaleClosed = true;\r\n\r\n    }\r\n\r\n    \r\n    // @notice Failsafe drain\r\n    // in case finalize failes, we need guaranteed way to transfer Ether out of this contract. \r\n    function drain() onlyBy(owner) {\r\n        if (!owner.send(this.balance)) revert();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"minContributeETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SOCXSentToETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"backers\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"SOCXSent\",\"type\":\"uint256\"},{\"name\":\"processed\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backer\",\"type\":\"address\"}],\"name\":\"process\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_multisigETH\",\"type\":\"address\"}],\"name\":\"updateMultiSig\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backersIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"}]","ContractName":"Presale","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://155b8e17b8add2c6792c1626466b53b466fbf1f155533cecda04ff75b41dd1b4"}]}