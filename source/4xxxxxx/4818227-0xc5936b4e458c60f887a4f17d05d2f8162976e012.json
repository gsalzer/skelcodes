{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n * V 1.0. \r\n * (C) profit-chain.net Licensed under MIT terms\r\n *\r\n * ProfitChain is a game allowing participants to win some Ether. Based on Ethereum intrinsic randomness and difficulty, you must be either lucky or one\r\n * hell of a hacker to win... Read the code, and if you find a problem, write owner AT profit-chain.net !\r\n *\r\n * Investors participate in rounds of fixed size and investment. Once a round is full, a new one opens automatically.\r\n * A single winner is picked per round, raking all the round's investments (minus invitor fees).\r\n *\r\n * Each investor must provide an invitor address when making the first investment in the group.\r\n * The game includes a time and depth limited invitation pyramid - you must invest first, then you can invite others. As invitor you'll enjoy a part of invitees investment\r\n * and wins, as well as their sub-invitees, for a limited time, and up to certain number of generations.\r\n *\r\n * There are multiple groups, each with its specific characteristics- to cater to all players.\r\n * \r\n * We deter hacking of the winner by making it non-economical:\r\n * There is a \"security factor\" K, which is larger than the group round size N.\r\n * For example, for N=10 we may choose K=50.\r\n * A few blocks following the round's last investment, the winner is picked if the block's hash mod K is a number of 1...N.\r\n * If a hacker miner made a single invetment in the round, the miner would have to match 1 out of 50 \"guesses\", ie. 50 times greater effort than usual...\r\n * If a hacker miner made all invetments but one in the round, the miner would have to match 9 of of 50 \"guesses\", or about 5 times greater than usual...\r\n * And then there's the participation fees, that render even that last scenario non-economical.\r\n *\r\n * It would take a little over K blocks on average to declare the winner.\r\n * At 15 seconds per block, if K=50, it would take on average 13 minutes after the last investment, before a winner is found.\r\n * BUT! \r\n * Winner declaration is temporary - checking is done on last 255 blocks. So even if a winner exists now, the winner must be actively named using a transaction while relevant.\r\n * A \"checkAndDeclareWinner\" transaction is required to write the winner (at the time of the transaction!) into the blockchain.\r\n * \r\n * All Ether withdrawals, after wins or invitor fees payouts, require execution of a \"withdraw\" transaction, for safety. \r\n */\r\n\r\n\r\ncontract ProfitChain {\r\n\r\n    using SafeMath256 for uint256;\r\n    using SafeMath32 for uint32;\r\n    \r\n    // types\r\n    \r\n    struct Investment {\r\n        address investor;               // who made the investment\r\n        uint256 sum;                    // actual investment, after fees deduction\r\n        uint256 time;                   // investment time\r\n    }\r\n    \r\n    struct Round {\r\n        mapping(uint32 => Investment) investments;      // all investments made in round\r\n        mapping (address => uint32) investorMapping;    // quickly find an investor by address\r\n        uint32 totalInvestors;          // the number of investors in round so far\r\n        uint256 totalInvestment;        // the sum of all investments in round, so far\r\n        address winner;                 // winner of the round (0 if not yet known)\r\n        uint256 lastBlock;              // block number of latest investment\r\n    }\r\n    \r\n    struct GroupMember {\r\n        uint256 joinTime;               // when the pariticipant joined the group\r\n        address invitor;                // who invited the participant\r\n    }\r\n\r\n    struct Group {\r\n        string name;                    // group name\r\n        uint32 roundSize;               // round size (number of investors)\r\n        uint256 investment;             // investment size in wei\r\n        uint32 blocksBeforeWinCheck;    // how many blocks to wait after round's final investment, prior to determining the winner\r\n        uint32 securityFactor;          // security factor, larger than the group size, to make hacking difficult\r\n        uint32 invitationFee;           // promiles of invitation fee out of investment and winning\r\n        uint32 ownerFee;                // promiles of owner fee out of investment\r\n        uint32 invitationFeePeriod;     // number of days an invitation incurs fees\r\n        uint8 invitationFeeDepth;       // how many invitors can be paid up the invitation chain\r\n        bool active;                    // is the group open for new rounds?\r\n        mapping (address => GroupMember) members;   // all the group members\r\n        mapping(uint32 => Round) rounds;            // rounds of this group\r\n        uint32 currentRound;            // the current round\r\n        uint32 firstUnwonRound;         // the oldest round we need to check for win\r\n    }\r\n    \r\n    \r\n    // variables\r\n    string public contractName = \"ProfitChain 1.0\";\r\n    uint256 public contractBlock;               // block of contract\r\n    address public owner;                       // owner of the contract\r\n    mapping (address => uint256) balances;      // balance of each investor\r\n    Group[] groups;                             // all groups\r\n    mapping (string => bool) groupNames;        // for exclusivity of group names\r\n\r\n    // modifiers\r\n    modifier onlyOwner() {require(msg.sender == owner); _;}\r\n    \r\n    // events\r\n    event GroupCreated(uint32 indexed group, uint256 timestamp);\r\n    event GroupClosed(uint32 indexed group, uint256 timestamp);\r\n    event NewInvestor(address indexed investor, uint32 indexed group, uint256 timestamp);\r\n    event Invest(address indexed investor, uint32 indexed group, uint32 indexed round, uint256 timestamp);\r\n    event Winner(address indexed payee, uint32 indexed group, uint32 indexed round, uint256 timestamp);\r\n    event Deposit(address indexed payee, uint256 sum, uint256 timestamp);\r\n    event Withdraw(address indexed payee, uint256 sum, uint256 timestamp);\r\n\r\n    // functions\r\n    \r\n    /**\r\n     * Constructor:\r\n     * - owner account\r\n     */\r\n    function ProfitChain () public {\r\n        owner = msg.sender;\r\n        contractBlock = block.number;\r\n    }\r\n\r\n    /**\r\n     * if someones sends Ether directly to the contract - fail it!\r\n     */\r\n    function /* fallback */ () public payable {\r\n        revert();\r\n    } \r\n\r\n    /**\r\n     * Create new group (only owner)\r\n     */\r\n    function newGroup (\r\n        string _groupName, \r\n        uint32 _roundSize,\r\n        uint256 _investment,\r\n        uint32 _blocksBeforeWinCheck,\r\n        uint32 _securityFactor,\r\n        uint32 _invitationFee,\r\n        uint32 _ownerFee,\r\n        uint32 _invitationFeePeriod,\r\n        uint8 _invitationFeeDepth\r\n    ) public onlyOwner \r\n    {\r\n        // some basic tests\r\n        require(_roundSize > 0);\r\n        require(_investment > 0);\r\n        require(_invitationFee.add(_ownerFee) < 1000);\r\n        require(_securityFactor > _roundSize);\r\n        // check if group name exists\r\n        require(!groupNameExists(_groupName));\r\n        \r\n        // create the group\r\n        Group memory group;\r\n        group.name = _groupName;\r\n        group.roundSize = _roundSize;\r\n        group.investment = _investment;\r\n        group.blocksBeforeWinCheck = _blocksBeforeWinCheck;\r\n        group.securityFactor = _securityFactor;\r\n        group.invitationFee = _invitationFee;\r\n        group.ownerFee = _ownerFee;\r\n        group.invitationFeePeriod = _invitationFeePeriod;\r\n        group.invitationFeeDepth = _invitationFeeDepth;\r\n        group.active = true;\r\n        // group.currentRound = 0; // initialized with 0 anyway\r\n        // group.firstUnwonRound = 0; // initialized with 0 anyway\r\n        \r\n        groups.push(group);\r\n        groupNames[_groupName] = true;\r\n\r\n        // notify world\r\n        GroupCreated(uint32(groups.length).sub(1), block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Close group (only owner)\r\n     * Once closed, it will not initiate new rounds.\r\n     */\r\n    function closeGroup(uint32 _group) onlyOwner public {\r\n        // verify group exists and not closed\r\n        require(groupExists(_group));\r\n        require(groups[_group].active);\r\n        \r\n        groups[_group].active = false;\r\n\r\n        // notify the world\r\n        GroupClosed(_group, block.timestamp);\r\n    } \r\n    \r\n    \r\n    /**\r\n     * Join group and make first investment\r\n     * Invitor must already belong to group (or be owner), investor must not.\r\n     */\r\n     \r\n    function joinGroupAndInvest(uint32 _group, address _invitor) payable public {\r\n        address investor = msg.sender;\r\n        // owner is not allowed to invest\r\n        require(msg.sender != owner);\r\n        // check group exists, investor does not yet belong to group, and invitor exists (or owner)\r\n        Group storage thisGroup = groups[_group];\r\n        require(thisGroup.roundSize > 0);\r\n        require(thisGroup.members[_invitor].joinTime > 0 || _invitor == owner);\r\n        require(thisGroup.members[investor].joinTime == 0);\r\n        // check payment is as required\r\n        require(msg.value == thisGroup.investment);\r\n        \r\n        // add investor to group\r\n        thisGroup.members[investor].joinTime = block.timestamp;\r\n        thisGroup.members[investor].invitor = _invitor;\r\n        \r\n        // notify the world\r\n        NewInvestor(investor, _group, block.timestamp);\r\n        \r\n        // make the first investment\r\n        invest(_group);\r\n    }\r\n\r\n    /**\r\n     * Invest in a group\r\n     * Can invest once per round.\r\n     * Must be a member of the group.\r\n     */\r\n    function invest(uint32 _group) payable public {\r\n        address investor = msg.sender;\r\n        Group storage thisGroup = groups[_group];\r\n        uint32 round = thisGroup.currentRound;\r\n        Round storage thisRound = thisGroup.rounds[round];\r\n        \r\n        // check the group is still open for business - only if we're about to be the first investors\r\n        require(thisGroup.active || thisRound.totalInvestors > 0);\r\n        \r\n        // check payment is as required\r\n        require(msg.value == thisGroup.investment);\r\n        // verify we're members\r\n        require(thisGroup.members[investor].joinTime > 0);\r\n        // verify we're not already investors in this round\r\n        require(! isInvestorInRound(thisRound, investor));\r\n        \r\n        // notify the world\r\n        Invest(investor, _group, round, block.timestamp);\r\n\r\n        // calculate fees. there are owner fee and invitor fee\r\n        uint256 ownerFee = msg.value.mul(thisGroup.ownerFee).div(1000);\r\n        balances[owner] = balances[owner].add(ownerFee);\r\n        Deposit(owner, ownerFee, block.timestamp);\r\n                \r\n        uint256 investedSumLessOwnerFee = msg.value.sub(ownerFee);\r\n\r\n        uint256 invitationFee = payAllInvitors(thisGroup, investor, block.timestamp, investedSumLessOwnerFee, 0);\r\n\r\n        uint256 investedNetSum = investedSumLessOwnerFee.sub(invitationFee);\r\n        \r\n        // join the round\r\n        thisRound.investorMapping[investor] = thisRound.totalInvestors;\r\n        thisRound.investments[thisRound.totalInvestors] = Investment({\r\n            investor: investor,\r\n            sum: investedNetSum,\r\n            time: block.timestamp});\r\n        \r\n        thisRound.totalInvestors = thisRound.totalInvestors.add(1);\r\n        thisRound.totalInvestment = thisRound.totalInvestment.add(investedNetSum);\r\n        \r\n        // check if this round has been completely populated. If so, close this round and prepare the next round\r\n        if (thisRound.totalInvestors == thisGroup.roundSize) {\r\n            thisGroup.currentRound = thisGroup.currentRound.add(1);\r\n            thisRound.lastBlock = block.number;\r\n        }\r\n\r\n        // every investor also helps by checking for a previous winner.\r\n        address winner;\r\n        string memory reason;\r\n        (winner, reason) = checkWinnerInternal(thisGroup);\r\n        if (winner != 0)\r\n            declareWinner(_group, winner);\r\n    }\r\n\r\n    \r\n    /**\r\n     * withdraw collects due funds in a safe manner\r\n     */\r\n    function withdraw(uint256 sum) public {\r\n        address withdrawer = msg.sender;\r\n        // do we have enough funds for withdrawal?\r\n        require(balances[withdrawer] >= sum);\r\n\r\n        // notify the world\r\n        Withdraw(withdrawer, sum, block.timestamp);\r\n        \r\n        // update (safely)\r\n        balances[withdrawer] = balances[withdrawer].sub(sum);\r\n        withdrawer.transfer(sum);\r\n    }\r\n    \r\n    /**\r\n     * checkWinner checks if at the time of the call a winner exists for the currently earliest unwon round of the given group.\r\n     * No declaration is made - so another winner could be selected later!\r\n     */\r\n    function checkWinner(uint32 _group) public constant returns (bool foundWinner, string reason) {\r\n        Group storage thisGroup = groups[_group];\r\n        require(thisGroup.roundSize > 0);\r\n        address winner;\r\n        (winner, reason) = checkWinnerInternal(thisGroup);\r\n        foundWinner = winner != 0;\r\n    }\r\n    \r\n    /**\r\n     * checkAndDeclareWinner checks if at the time of the call a winner exists for the currently earliest unwon round of the given group,\r\n     * and then declares the winner.\r\n     * Reverts if no winner found, to prevent unnecessary gas expenses.\r\n     */\r\n\r\n    function checkAndDeclareWinner(uint32 _group) public {\r\n        Group storage thisGroup = groups[_group];\r\n        require(thisGroup.roundSize > 0);\r\n        address winner;\r\n        string memory reason;\r\n        (winner, reason) = checkWinnerInternal(thisGroup);\r\n        // revert if no winner found\r\n        require(winner != 0);\r\n        // let's declare the winner!\r\n        declareWinner(_group, winner);\r\n    }\r\n\r\n    /**\r\n     * declareWinner etches the winner into the blockchain.\r\n     */\r\n\r\n    function declareWinner(uint32 _group, address _winner) internal {\r\n        // let's declare the winner!\r\n        Group storage thisGroup = groups[_group];\r\n        Round storage unwonRound = thisGroup.rounds[thisGroup.firstUnwonRound];\r\n    \r\n        unwonRound.winner = _winner;\r\n        \r\n        // notify the world\r\n        Winner(_winner, _group, thisGroup.firstUnwonRound, block.timestamp);\r\n        uint256 wonSum = unwonRound.totalInvestment;\r\n        \r\n        wonSum = wonSum.sub(payAllInvitors(thisGroup, _winner, block.timestamp, wonSum, 0));\r\n        \r\n        balances[_winner] = balances[_winner].add(wonSum);\r\n        \r\n        Deposit(_winner, wonSum, block.timestamp);\r\n            \r\n        // update the unwon round\r\n        thisGroup.firstUnwonRound = thisGroup.firstUnwonRound.add(1);\r\n    }\r\n\r\n    /**\r\n     * checkWinnerInernal tries finding a winner for the oldest non-decided round.\r\n     * Returns winner != 0 iff a new winner was found, as well as reason\r\n     */\r\n    function checkWinnerInternal(Group storage thisGroup) internal constant returns (address winner, string reason) {\r\n        winner = 0; // assume have not found a new winner\r\n        // some tests\r\n        // the first round has no previous rounds to check\r\n        if (thisGroup.currentRound == 0) {\r\n            reason = 'Still in first round';\r\n            return;\r\n        }\r\n        // we don't check current round - by definition it is not full\r\n        if (thisGroup.currentRound == thisGroup.firstUnwonRound) {\r\n            reason = 'No unwon finished rounds';\r\n            return;\r\n        }\r\n     \r\n        Round storage unwonRound = thisGroup.rounds[thisGroup.firstUnwonRound];\r\n        \r\n        // we will scan a range of blocks, from unwonRound.lastBlock + thisGroup.blocksBeforeWinCheck;\r\n        uint256 firstBlock = unwonRound.lastBlock.add(thisGroup.blocksBeforeWinCheck);\r\n        // but we can't scan more than 255 blocks into the past\r\n        // the first test is for testing environments that may have less than 256 blocks :)\r\n        if (block.number > 255 && firstBlock < block.number.sub(255))\r\n            firstBlock = block.number.sub(255);\r\n        // the scan ends at the last committed block\r\n        uint256 lastBlock = block.number.sub(1);\r\n\r\n        for (uint256 thisBlock = firstBlock; thisBlock <= lastBlock; thisBlock = thisBlock.add(1)) {\r\n            uint256 latestHash = uint256(block.blockhash(thisBlock));\r\n            // we're \"drawing\" a winner out of the security-factor-sized group - perhaps no winner at all  \r\n            uint32 drawn = uint32(latestHash % thisGroup.securityFactor);\r\n            if (drawn < thisGroup.roundSize) {\r\n                // we have a winner!\r\n                winner = unwonRound.investments[drawn].investor;\r\n                return;\r\n            }\r\n        }\r\n        reason = 'No winner picked';\r\n    } \r\n    \r\n    /**\r\n     * Given a group, investor and amount of wei, pay all the eligible invitors.\r\n     * NOTE: does not draw from the _payer balance - we're assuming the returned value will be deducted when necessary.\r\n     * NOTE 2: a recursive call, yet the depth is limited by 8-bits so no real stack concren.\r\n     * Return the amount of wei to be deducted from the payer\r\n     */\r\n    function payAllInvitors(Group storage thisGroup, address _payer, uint256 _relevantTime, uint256 _amount, uint32 _depth) internal returns (uint256 invitationFee) {\r\n\r\n        address invitor = thisGroup.members[_payer].invitor;\r\n        // conditions for payment:\r\n        if (\r\n        // the payer's invitor is not the owner...\r\n            invitor == owner ||\r\n        // must have something to share...\r\n            _amount == 0 ||\r\n        // no more than specified depth\r\n            _depth >= thisGroup.invitationFeeDepth ||\r\n        // the invitor's invitation time has not expired\r\n            _relevantTime > thisGroup.members[_payer].joinTime.add(thisGroup.invitationFeePeriod.mul(1 days))\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // compute how much to pay\r\n        invitationFee = _amount.mul(thisGroup.invitationFee).div(1000);\r\n        \r\n        // we may have reached rock bottom - don't continue\r\n        if (invitationFee == 0) return;\r\n\r\n        // calculate recursively even higher-hierarcy fees\r\n        uint256 invitorFee = payAllInvitors(thisGroup, invitor, _relevantTime,  invitationFee, _depth.add(1));\r\n        \r\n        // out net invitation fees are...\r\n        uint256 paid = invitationFee.sub(invitorFee);\r\n        \r\n        // pay\r\n        balances[invitor] = balances[invitor].add(paid);\r\n        \r\n        // notify the world\r\n        Deposit(invitor, paid, block.timestamp);\r\n    }\r\n\r\n\r\n    \r\n    /**\r\n     * Is a specific investor in a specific round?\r\n     */\r\n    function isInvestorInRound(Round storage _round, address _investor) internal constant returns (bool investorInRound) {\r\n        return (_round.investments[_round.investorMapping[_investor]].investor == _investor);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Get info about specific account\r\n     */\r\n    function balanceOf(address investor) public constant returns (uint256 balance) {\r\n        balance = balances[investor];\r\n    }\r\n    \r\n     \r\n    /**\r\n     * Get info about groups\r\n     */\r\n    function groupsCount() public constant returns (uint256 count) {\r\n        count = groups.length;\r\n    }\r\n     \r\n    /**\r\n     * Get info about specific group\r\n     */ \r\n    function groupInfo(uint32 _group) public constant returns (\r\n        string name,\r\n        uint32 roundSize,\r\n        uint256 investment,\r\n        uint32 blocksBeforeWinCheck,\r\n        uint32 securityFactor,\r\n        uint32 invitationFee,\r\n        uint32 ownerFee,\r\n        uint32 invitationFeePeriod,\r\n        uint8 invitationFeeDepth,\r\n        bool active,\r\n        uint32 currentRound,\r\n        uint32 firstUnwonRound\r\n    ) {\r\n        require(groupExists(_group));\r\n        Group storage thisGroup = groups[_group];\r\n        name = thisGroup.name;\r\n        roundSize = thisGroup.roundSize;\r\n        investment = thisGroup.investment;\r\n        blocksBeforeWinCheck = thisGroup.blocksBeforeWinCheck;\r\n        securityFactor = thisGroup.securityFactor;\r\n        invitationFee = thisGroup.invitationFee;\r\n        ownerFee = thisGroup.ownerFee;\r\n        invitationFeePeriod = thisGroup.invitationFeePeriod;\r\n        invitationFeeDepth = thisGroup.invitationFeeDepth;\r\n        active = thisGroup.active;\r\n        currentRound = thisGroup.currentRound;\r\n        firstUnwonRound = thisGroup.firstUnwonRound;\r\n    }\r\n    \r\n     \r\n    /**\r\n     * Get info about specific group member\r\n     */\r\n    function groupMemberInfo (uint32 _group, address investor) public constant returns (\r\n        uint256 joinTime,\r\n        address invitor\r\n    ) {\r\n        require(groupExists(_group));\r\n        GroupMember storage groupMember = groups[_group].members[investor];\r\n        joinTime = groupMember.joinTime;\r\n        invitor = groupMember.invitor;\r\n    }\r\n    \r\n    /**\r\n     * Get info about specific group's round\r\n     */\r\n    function roundInfo (uint32 _group, uint32 _round) public constant returns (\r\n        uint32 totalInvestors,\r\n        uint256 totalInvestment,\r\n        address winner,\r\n        uint256 lastBlock\r\n    ) {\r\n        require(groupExists(_group));\r\n        Round storage round = groups[_group].rounds[_round];\r\n        totalInvestors = round.totalInvestors;\r\n        totalInvestment = round.totalInvestment;\r\n        winner = round.winner;\r\n        lastBlock = round.lastBlock;\r\n    } \r\n    \r\n    /**\r\n     * Get info about specific round's investment, by investor\r\n     */\r\n    function roundInvestorInfoByAddress (uint32 _group, uint32 _round, address investor) public constant returns (\r\n        bool inRound,\r\n        uint32 index\r\n    ) {\r\n        require(groupExists(_group));\r\n        index = groups[_group].rounds[_round].investorMapping[investor];\r\n        inRound = isInvestorInRound(groups[_group].rounds[_round], investor);\r\n    }\r\n    \r\n    /**\r\n     * Get info about specific round's investment - by index\r\n     */\r\n    function roundInvestorInfoByIndex (uint32 _group, uint32 _round, uint32 _index) public constant returns (\r\n        address investor,\r\n        uint256 sum,\r\n        uint256 time\r\n    ) {\r\n        require(groupExists(_group));\r\n        require(groups[_group].rounds[_round].totalInvestors > _index);\r\n        Investment storage investment = groups[_group].rounds[_round].investments[_index];\r\n        investor = investment.investor;\r\n        sum = investment.sum;\r\n        time = investment.time;\r\n    }\r\n\r\n    /**\r\n     * Does group name exist?\r\n     */\r\n    function groupNameExists(string _groupName) internal constant returns (bool exists) {\r\n        return groupNames[_groupName];\r\n    }\r\n\r\n    function groupExists(uint32 _group) internal constant returns (bool exists) {\r\n        return _group < groups.length;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeMath256 {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // require(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // require(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_groupName\",\"type\":\"string\"},{\"name\":\"_roundSize\",\"type\":\"uint32\"},{\"name\":\"_investment\",\"type\":\"uint256\"},{\"name\":\"_blocksBeforeWinCheck\",\"type\":\"uint32\"},{\"name\":\"_securityFactor\",\"type\":\"uint32\"},{\"name\":\"_invitationFee\",\"type\":\"uint32\"},{\"name\":\"_ownerFee\",\"type\":\"uint32\"},{\"name\":\"_invitationFeePeriod\",\"type\":\"uint32\"},{\"name\":\"_invitationFeeDepth\",\"type\":\"uint8\"}],\"name\":\"newGroup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"},{\"name\":\"_round\",\"type\":\"uint32\"},{\"name\":\"_index\",\"type\":\"uint32\"}],\"name\":\"roundInvestorInfoByIndex\",\"outputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"sum\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"}],\"name\":\"checkWinner\",\"outputs\":[{\"name\":\"foundWinner\",\"type\":\"bool\"},{\"name\":\"reason\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sum\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"}],\"name\":\"groupInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"roundSize\",\"type\":\"uint32\"},{\"name\":\"investment\",\"type\":\"uint256\"},{\"name\":\"blocksBeforeWinCheck\",\"type\":\"uint32\"},{\"name\":\"securityFactor\",\"type\":\"uint32\"},{\"name\":\"invitationFee\",\"type\":\"uint32\"},{\"name\":\"ownerFee\",\"type\":\"uint32\"},{\"name\":\"invitationFeePeriod\",\"type\":\"uint32\"},{\"name\":\"invitationFeeDepth\",\"type\":\"uint8\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"currentRound\",\"type\":\"uint32\"},{\"name\":\"firstUnwonRound\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"}],\"name\":\"closeGroup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"},{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"groupMemberInfo\",\"outputs\":[{\"name\":\"joinTime\",\"type\":\"uint256\"},{\"name\":\"invitor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"groupsCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"}],\"name\":\"checkAndDeclareWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"},{\"name\":\"_round\",\"type\":\"uint32\"},{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"roundInvestorInfoByAddress\",\"outputs\":[{\"name\":\"inRound\",\"type\":\"bool\"},{\"name\":\"index\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"},{\"name\":\"_invitor\",\"type\":\"address\"}],\"name\":\"joinGroupAndInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_group\",\"type\":\"uint32\"},{\"name\":\"_round\",\"type\":\"uint32\"}],\"name\":\"roundInfo\",\"outputs\":[{\"name\":\"totalInvestors\",\"type\":\"uint32\"},{\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"lastBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"group\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"GroupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"group\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"GroupClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"group\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"NewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"group\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"group\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"ProfitChain","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0416883fd0111a71a2bdae9ad674668df81e8e59ee9225a9587e26d9fe5a4024"}]}