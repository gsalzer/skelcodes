{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/Discounts.sol\r\n\r\nlibrary Discounts {\r\n  using SafeMath for uint256;\r\n\r\n  /**************************************************************************\r\n   * TYPES\r\n   *************************************************************************/\r\n\r\n  /*\r\n   * Top-level struct for grouping of tiers with a base purchase rate\r\n   */\r\n  struct Collection {\r\n    Tier[] tiers;\r\n\r\n    // number of tokens per wei\r\n    uint256 baseRate;\r\n  }\r\n\r\n  /*\r\n   * Struct for a given tier - discount and availability\r\n   */\r\n  struct Tier {\r\n    // discount the set purchase price, expressed in basis points (‱)\r\n    // range (0‱ .. 10,000‱) corresponds to (0.00% .. 100.00%)\r\n    uint256 discount;\r\n\r\n    // number of remaining available tokens in tier\r\n    uint256 available;\r\n  }\r\n\r\n  // upper-bound of basis point scale\r\n  uint256 public constant MAX_DISCOUNT = 10000;\r\n\r\n\r\n  /**************************************************************************\r\n   * CREATE\r\n   *************************************************************************/\r\n\r\n  /*\r\n   * @dev Add a new tier at the end of the list\r\n   * @param _discount - Discount in basis points\r\n   * @param _available - Available supply at tier\r\n   */\r\n  function addTier(\r\n    Collection storage self,\r\n    uint256 _discount,\r\n    uint256 _available\r\n  )\r\n    internal\r\n  {\r\n    self.tiers.push(Tier({\r\n      discount: _discount,\r\n      available: _available\r\n    }));\r\n  }\r\n\r\n\r\n  /**************************************************************************\r\n   * PURCHASE\r\n   *************************************************************************/\r\n\r\n  /*\r\n   * @dev Subtracts supply from tiers starting at a minimum, using up funds\r\n   * @param _amount - Maximum number of tokens to purchase\r\n   * @param _funds - Allowance in Wei\r\n   * @param _minimumTier - Minimum tier to start purchasing from\r\n   * @return Total tokens purchased and remaining funds in wei\r\n   */\r\n  function purchaseTokens(\r\n    Collection storage self,\r\n    uint256 _amount,\r\n    uint256 _funds,\r\n    uint256 _minimumTier\r\n  )\r\n    internal\r\n    returns (\r\n      uint256 purchased,\r\n      uint256 remaining\r\n    )\r\n  {\r\n    uint256 issue = 0; // tracks total tokens to issue\r\n    remaining = _funds;\r\n\r\n    uint256 available;  // var for available tokens at tier\r\n    uint256 spend; // amount spent at tier\r\n    uint256 affordable;  // var for # funds can pay for at tier\r\n    uint256 purchase; // var for # to purchase at tier\r\n\r\n    // for each tier starting at minimum\r\n    // draw from the sent funds and count tokens to issue\r\n    for (var i = _minimumTier; i < self.tiers.length && issue < _amount; i++) {\r\n      // get the available tokens left at each tier\r\n      available = self.tiers[i].available;\r\n\r\n      // compute the maximum tokens that the funds can pay for\r\n      affordable = _computeTokensPurchasedAtTier(self, i, remaining);\r\n\r\n      // either purchase what the funds can afford, or the whole supply\r\n      // at the tier\r\n      if (affordable < available) {\r\n        purchase = affordable;\r\n      } else {\r\n        purchase = available;\r\n      }\r\n\r\n      // limit the amount purchased up to specified amount\r\n      // use safemath here in case of unknown overflow risk\r\n      if (purchase.add(issue) > _amount) {\r\n        purchase = _amount.sub(issue);\r\n      }\r\n\r\n      spend = _computeCostForTokensAtTier(self, i, purchase);\r\n\r\n      // decrease available supply at tier\r\n      self.tiers[i].available -= purchase;\r\n\r\n      // increase tokens to issue\r\n      issue += purchase;\r\n\r\n      // decrement funds to proceed\r\n      remaining -= spend;\r\n    }\r\n\r\n    return (issue, remaining);\r\n  }\r\n\r\n\r\n  /**************************************************************************\r\n   * PRICE MATH\r\n   *************************************************************************/\r\n\r\n  // @return total number of tokens for an amount of wei, discount-adjusted\r\n  function _computeTokensPurchasedAtTier(\r\n    Collection storage self,\r\n    uint256 _tier,\r\n    uint256 _wei\r\n  )\r\n    private\r\n    view\r\n    returns (uint256)\r\n  {\r\n    var paidBasis = MAX_DISCOUNT.sub(self.tiers[_tier].discount);\r\n\r\n    return _wei.mul(self.baseRate).mul(MAX_DISCOUNT) / paidBasis;\r\n  }\r\n\r\n  // @return cost in wei for that many tokens\r\n  function _computeCostForTokensAtTier(\r\n    Collection storage self,\r\n    uint256 _tier,\r\n    uint256 _tokens\r\n  )\r\n    private\r\n    view\r\n    returns (uint256)\r\n  {\r\n    var paidBasis = MAX_DISCOUNT.sub(self.tiers[_tier].discount);\r\n\r\n    var numerator = _tokens.mul(paidBasis);\r\n    var denominator = MAX_DISCOUNT.mul(self.baseRate);\r\n\r\n    var floor = _tokens.mul(paidBasis).div(\r\n      MAX_DISCOUNT.mul(self.baseRate)\r\n    );\r\n\r\n    // must round up cost to next wei (cause token computation rounds down)\r\n    if (numerator % denominator != 0) {\r\n      floor = floor + 1;\r\n    }\r\n\r\n    return floor;\r\n  }\r\n}\r\n\r\n// File: contracts/Limits.sol\r\n\r\nlibrary Limits {\r\n  using SafeMath for uint256;\r\n\r\n  struct PurchaseRecord {\r\n    uint256 blockNumber;\r\n    uint256 amount;\r\n  }\r\n\r\n  struct Window {\r\n    uint256 amount;  // # of tokens\r\n    uint256 duration;  // # of blocks\r\n\r\n    mapping (address => PurchaseRecord) purchases;\r\n  }\r\n\r\n  /*\r\n   * Record a purchase towards a purchaser's cap limit\r\n   * @dev resets the purchaser's cap if the window duration has been met\r\n   * @param _participant - purchaser\r\n   * @param _amount - token amount of new purchase\r\n   */\r\n  function recordPurchase(\r\n    Window storage self,\r\n    address _participant,\r\n    uint256 _amount\r\n  )\r\n    internal\r\n  {\r\n    var blocksLeft = getBlocksUntilReset(self, _participant);\r\n    var record = self.purchases[_participant];\r\n\r\n    if (blocksLeft == 0) {\r\n      record.amount = _amount;\r\n      record.blockNumber = block.number;\r\n    } else {\r\n      record.amount = record.amount.add(_amount);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * Retrieve the current limit for a given participant, based on previous\r\n   * purchase history\r\n   * @param _participant - Purchaser\r\n   * @return amount of tokens left for participant with cap\r\n   */\r\n  function getLimit(Window storage self, address _participant)\r\n    public\r\n    view\r\n    returns (uint256 _amount)\r\n  {\r\n    var blocksLeft = getBlocksUntilReset(self, _participant);\r\n\r\n    if (blocksLeft == 0) {\r\n      return self.amount;\r\n    } else {\r\n      return self.amount.sub(self.purchases[_participant].amount);\r\n    }\r\n  }\r\n\r\n  function getBlocksUntilReset(Window storage self, address _participant)\r\n    public\r\n    view\r\n    returns (uint256 _blocks)\r\n  {\r\n    var expires = self.purchases[_participant].blockNumber + self.duration;\r\n    if (block.number > expires) {\r\n      return 0;\r\n    } else {\r\n      return expires - block.number;\r\n    }\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Claimable.sol\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n// File: contracts/SeeToken.sol\r\n\r\n/**\r\n * @title SEE Token\r\n * Not a full ERC20 token - prohibits transferring. Serves as a record of\r\n * account, to redeem for real tokens after launch.\r\n */\r\ncontract SeeToken is Claimable {\r\n  using SafeMath for uint256;\r\n\r\n  string public constant name = \"See Presale Token\";\r\n  string public constant symbol = \"SEE\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  uint256 public totalSupply;\r\n  mapping (address => uint256) balances;\r\n\r\n  event Issue(address to, uint256 amount);\r\n\r\n  /**\r\n   * @dev Issue new tokens\r\n   * @param _to The address that will receive the minted tokens\r\n   * @param _amount the amount of new tokens to issue\r\n   */\r\n  function issue(address _to, uint256 _amount) onlyOwner public {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n\r\n    Issue(_to, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the balance for a particular token holder\r\n   * @param _holder The token holder's address\r\n   * @return The holder's balance\r\n   */\r\n  function balanceOf(address _holder) public view returns (uint256 balance) {\r\n    balance = balances[_holder];\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/Presale.sol\r\n\r\ncontract Presale is Claimable, Pausable {\r\n  using Discounts for Discounts.Collection;\r\n  using Limits for Limits.Window;\r\n\r\n  struct Participant {\r\n    bool authorized;\r\n\r\n    uint256 minimumTier;\r\n  }\r\n\r\n\r\n  /**************************************************************************\r\n   * STORAGE / EVENTS\r\n   *************************************************************************/\r\n\r\n  SeeToken token;\r\n  Discounts.Collection discounts;\r\n  Limits.Window cap;\r\n\r\n  mapping (address => Participant) participants;\r\n\r\n\r\n  event Tier(uint256 discount, uint256 available);\r\n\r\n\r\n  /**************************************************************************\r\n   * CONSTRUCTOR / LIFECYCLE\r\n   *************************************************************************/\r\n\r\n  function Presale(address _token)\r\n    public\r\n  {\r\n    token = SeeToken(_token);\r\n\r\n    paused = true;\r\n  }\r\n\r\n  /*\r\n   * @dev (Done as part of migration) Claims ownership of token contract\r\n   */\r\n  function claimToken() public {\r\n    token.claimOwnership();\r\n  }\r\n\r\n  /*\r\n   * Allow purchase\r\n   * @dev while paused\r\n   */\r\n  function unpause()\r\n    onlyOwner\r\n    whenPaused\r\n    whenRateSet\r\n    whenCapped\r\n    whenOwnsToken\r\n    public\r\n  {\r\n    super.unpause();\r\n  }\r\n\r\n\r\n  /**************************************************************************\r\n   * ADMIN INTERFACE\r\n   *************************************************************************/\r\n\r\n  /*\r\n   * Set the base purchase rate for the token\r\n   * @param _purchaseRate - number of tokens granted per wei\r\n   */\r\n  function setRate(uint256 _purchaseRate)\r\n    onlyOwner\r\n    whenPaused\r\n    public\r\n  {\r\n    discounts.baseRate = _purchaseRate;\r\n  }\r\n\r\n  /*\r\n   * Specify purchasing limits for a single account: the limit of tokens\r\n   * that a participant may purchase in a set amount of time (blocks)\r\n   * @param _amount - Number of tokens\r\n   * @param _duration - Number of blocks\r\n   */\r\n  function limitPurchasing(uint256 _amount, uint256 _duration)\r\n    onlyOwner\r\n    whenPaused\r\n    public\r\n  {\r\n    cap.amount = _amount;\r\n    cap.duration = _duration;\r\n  }\r\n\r\n  /*\r\n   * Add a tier with a given discount and available supply\r\n   * @param _discount - Discount in basis points\r\n   * @param _available - Available supply at tier\r\n   */\r\n  function addTier(uint256 _discount, uint256 _available)\r\n    onlyOwner\r\n    whenPaused\r\n    public\r\n  {\r\n    discounts.addTier(_discount, _available);\r\n\r\n    Tier(_discount, _available);\r\n  }\r\n\r\n  /*\r\n   * Authorize a group of participants for a tier\r\n   * @param _minimumTier - minimum tier for list of participants\r\n   * @param _participants - array of authorized addresses\r\n   */\r\n  function authorizeForTier(uint256 _minimumTier, address[] _authorized)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < _authorized.length; i++) {\r\n      participants[_authorized[i]] = Participant({\r\n        authorized: true,\r\n        minimumTier: _minimumTier\r\n      });\r\n    }\r\n  }\r\n\r\n  /*\r\n   * Withdraw balance from presale\r\n   */\r\n  function withdraw()\r\n    onlyOwner\r\n    public\r\n  {\r\n    owner.transfer(this.balance);\r\n  }\r\n\r\n\r\n  /**************************************************************************\r\n   * PURCHASE INTERFACE\r\n   *************************************************************************/\r\n\r\n  /*\r\n   * Fallback (default) function.\r\n   * @dev Forwards to `purchaseTokens()`\r\n   */\r\n  function ()\r\n    public\r\n    payable\r\n  {\r\n    purchaseTokens();\r\n  }\r\n\r\n  /*\r\n   * Public purchase interface for authorized Dragon Holders\r\n   * @dev Purchases tokens starting in authorized minimum tier\r\n   */\r\n  function purchaseTokens()\r\n    onlyAuthorized\r\n    whenNotPaused\r\n    public\r\n    payable\r\n  {\r\n    var limit = cap.getLimit(msg.sender);\r\n\r\n    var (purchased, refund) = discounts.purchaseTokens(\r\n      limit,\r\n      msg.value,\r\n      participants[msg.sender].minimumTier\r\n    );\r\n\r\n    cap.recordPurchase(msg.sender, purchased);\r\n\r\n    // issue new tokens\r\n    token.issue(msg.sender, purchased);\r\n\r\n    // if there are funds left, send refund\r\n    if (refund > 0) {\r\n      msg.sender.transfer(refund);\r\n    }\r\n  }\r\n\r\n\r\n  /**************************************************************************\r\n   * PRICING / AVAILABILITY - VIEW INTERFACE\r\n   *************************************************************************/\r\n\r\n  /*\r\n   * Get terms for purchasing limit window\r\n   * @return number of tokens and duration in blocks\r\n   */\r\n  function getPurchaseLimit()\r\n    public\r\n    view\r\n    returns (uint256 _amount, uint256 _duration)\r\n  {\r\n    _amount = cap.amount;\r\n    _duration = cap.duration;\r\n  }\r\n\r\n  /*\r\n   * Get tiers currently set up, with discounts and available supplies\r\n   * @return array of tuples (discount, available)\r\n   */\r\n  function getTiers()\r\n    public\r\n    view\r\n    returns (uint256[2][])\r\n  {\r\n    var records = discounts.tiers;\r\n    uint256[2][] memory tiers = new uint256[2][](records.length);\r\n\r\n    for (uint256 i = 0; i < records.length; i++) {\r\n      tiers[i][0] = records[i].discount;\r\n      tiers[i][1] = records[i].available;\r\n    }\r\n\r\n    return tiers;\r\n  }\r\n\r\n  /*\r\n   * Get available supply for each tier for a given participant\r\n   * @dev starts at minimum tier for participant (requiring auth)\r\n   * @return available supply by tier index, zeroes for non-auth\r\n   */\r\n  function getAvailability(address _participant)\r\n    public\r\n    view\r\n    returns (uint256[])\r\n  {\r\n    var participant = participants[_participant];\r\n    uint256 minimumTier = participant.minimumTier;\r\n\r\n    // minor HACK - if the participant isn't authorized, just set the\r\n    // minimum tier above the bounds\r\n    if (!participant.authorized) {\r\n      minimumTier = discounts.tiers.length;\r\n    }\r\n\r\n    uint256[] memory tiers = new uint256[](discounts.tiers.length);\r\n\r\n    for (uint256 i = minimumTier; i < tiers.length; i++) {\r\n      tiers[i] = discounts.tiers[i].available;\r\n    }\r\n\r\n    return tiers;\r\n  }\r\n\r\n\r\n  /**************************************************************************\r\n   * MODIFIERS\r\n   *************************************************************************/\r\n\r\n  /*\r\n   * @dev require participant is whitelist-authorized\r\n   */\r\n  modifier onlyAuthorized() {\r\n    require(participants[msg.sender].authorized);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev baseRate will default to 0\r\n   */\r\n  modifier whenRateSet() {\r\n    require(discounts.baseRate != 0);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev to prevent accidentally capping at 0\r\n   */\r\n  modifier whenCapped() {\r\n    require(cap.amount != 0);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * @dev asserts zeppelin Claimable workflow is finalized\r\n   */\r\n  modifier whenOwnsToken() {\r\n    require(token.owner() == address(this));\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getPurchaseLimit\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"getAvailability\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_purchaseRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_discount\",\"type\":\"uint256\"},{\"name\":\"_available\",\"type\":\"uint256\"}],\"name\":\"addTier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"limitPurchasing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTiers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimumTier\",\"type\":\"uint256\"},{\"name\":\"_authorized\",\"type\":\"address[]\"}],\"name\":\"authorizeForTier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"discount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"Tier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Presale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006c78a953b5aad0bc991b234970d599e5101c6e5d","Library":"Limits:f446b831f4ebcc8777375592ba9f03124401f2e8","SwarmSource":"bzzr://8fcc31a9c37e86e65f81c61639d014235039b2d4625fb786bf2573855c97088f"}]}