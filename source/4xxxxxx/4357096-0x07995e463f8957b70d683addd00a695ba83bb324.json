{"status":"1","message":"OK","result":[{"SourceCode":"//! MultiCertifier contract.\r\n//! By Parity Technologies, 2017.\r\n//! Released under the Apache Licence 2.\r\n\r\npragma solidity ^0.4.16;\r\n\r\n// From Owned.sol\r\ncontract Owned {\r\n\tmodifier only_owner { if (msg.sender != owner) return; _; }\r\n\r\n\tevent NewOwner(address indexed old, address indexed current);\r\n\r\n\tfunction setOwner(address _new) public only_owner { NewOwner(owner, _new); owner = _new; }\r\n\r\n\taddress public owner = msg.sender;\r\n}\r\n\r\n// From Certifier.sol\r\ncontract Certifier {\r\n\tevent Confirmed(address indexed who);\r\n\tevent Revoked(address indexed who);\r\n\tfunction certified(address) public constant returns (bool);\r\n\tfunction get(address, string) public constant returns (bytes32);\r\n\tfunction getAddress(address, string) public constant returns (address);\r\n\tfunction getUint(address, string) public constant returns (uint);\r\n}\r\n\r\n/**\r\n * Contract to allow multiple parties to collaborate over a certification contract.\r\n * Each certified account is associated with the delegate who certified it.\r\n * Delegates can be added and removed only by the contract owner.\r\n */\r\ncontract MultiCertifier is Owned, Certifier {\r\n\tmodifier only_delegate { require (msg.sender == owner || delegates[msg.sender]); _; }\r\n\tmodifier only_certifier_of(address who) { require (msg.sender == owner || msg.sender == certs[who].certifier); _; }\r\n\tmodifier only_certified(address who) { require (certs[who].active); _; }\r\n\tmodifier only_uncertified(address who) { require (!certs[who].active); _; }\r\n\r\n\tevent Confirmed(address indexed who, address indexed by);\r\n\tevent Revoked(address indexed who, address indexed by);\r\n\r\n\tstruct Certification {\r\n\t\taddress certifier;\r\n\t\tbool active;\r\n\t}\r\n\r\n\tfunction certify(address _who)\r\n\t\tpublic\r\n\t\tonly_delegate\r\n\t\tonly_uncertified(_who)\r\n\t{\r\n\t\tcerts[_who].active = true;\r\n\t\tcerts[_who].certifier = msg.sender;\r\n\t\tConfirmed(_who, msg.sender);\r\n\t}\r\n\r\n\tfunction revoke(address _who)\r\n\t\tpublic\r\n\t\tonly_certifier_of(_who)\r\n\t\tonly_certified(_who)\r\n\t{\r\n\t\tcerts[_who].active = false;\r\n\t\tRevoked(_who, msg.sender);\r\n\t}\r\n\r\n\tfunction certified(address _who) public constant returns (bool) { return certs[_who].active; }\r\n\tfunction getCertifier(address _who) public constant returns (address) { return certs[_who].certifier; }\r\n\tfunction addDelegate(address _new) public only_owner { delegates[_new] = true; }\r\n\tfunction removeDelegate(address _old) public only_owner { delete delegates[_old]; }\r\n\r\n\tmapping (address => Certification) certs;\r\n\tmapping (address => bool) delegates;\r\n\r\n\t/// Unused interface methods.\r\n\tfunction get(address, string) public constant returns (bytes32) {}\r\n\tfunction getAddress(address, string) public constant returns (address) {}\r\n\tfunction getUint(address, string) public constant returns (uint) {}\r\n}\r\n\r\ncontract VouchFor {\r\n    \r\n    event Vouched(address who, bytes32 what);\r\n\r\n    function VouchFor(address _certifier) public {\r\n        certifier = Certifier(_certifier);\r\n    }\r\n    \r\n    function vouch(bytes32 _what)\r\n        public\r\n        only_certified\r\n    {\r\n        vouchers[_what].push(msg.sender);\r\n        Vouched(msg.sender, _what);\r\n    }\r\n    \r\n    function vouched(bytes32 _what, uint _index)\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return vouchers[_what][_index];\r\n    }\r\n    \r\n    function unvouch(bytes32 _what, uint _index)\r\n        public\r\n    {\r\n        uint count = vouchers[_what].length;\r\n        require (count > 0);\r\n        require (_index < count);\r\n        require (vouchers[_what][_index] == msg.sender);\r\n        if (_index != count - 1) {\r\n            vouchers[_what][_index] = vouchers[_what][count - 1];\r\n        }\r\n        delete vouchers[_what][count - 1];\r\n        vouchers[_what].length = count - 1;\r\n    }\r\n    \r\n    modifier only_certified {\r\n        require (certifier.certified(msg.sender));\r\n        _;\r\n    }\r\n    \r\n    mapping (bytes32 => address[]) public vouchers;\r\n    Certifier public certifier;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"certifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_what\",\"type\":\"bytes32\"}],\"name\":\"vouch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_what\",\"type\":\"bytes32\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"vouched\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_what\",\"type\":\"bytes32\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"unvouch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vouchers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_certifier\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"what\",\"type\":\"bytes32\"}],\"name\":\"Vouched\",\"type\":\"event\"}]","ContractName":"VouchFor","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001e2f058c43ac8965938f6e9ca286685a3e63f24e","Library":"","SwarmSource":"bzzr://64813ab37caf7328b1d5d50f7a01fdb590cea10b95783511731a4256e23279ac"}]}