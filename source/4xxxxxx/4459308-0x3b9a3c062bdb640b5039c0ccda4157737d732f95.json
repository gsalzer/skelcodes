{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/**\r\n * @title MultiSigStub  \r\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\r\n * @dev Contract that delegates calls to a library to build a full MultiSigWallet that is cheap to create. \r\n */\r\ncontract MultiSigStub {\r\n\r\n    address[] public owners;\r\n    address[] public tokens;\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n    \r\n    function MultiSigStub(address[] _owners, uint256 _required) {\r\n        //bytes4 sig = bytes4(sha3(\"constructor(address[],uint256)\"));\r\n        bytes4 sig = 0x36756a23;\r\n        uint argarraysize = (2 + _owners.length);\r\n        uint argsize = (1 + argarraysize) * 32;\r\n        uint size = 4 + argsize;\r\n        bytes32 mData = _malloc(size);\r\n\r\n        assembly {\r\n            mstore(mData, sig)\r\n            codecopy(add(mData, 0x4), sub(codesize, argsize), argsize)\r\n        }\r\n        _delegatecall(mData, size);\r\n    }\r\n    \r\n    modifier delegated {\r\n        uint size = msg.data.length;\r\n        bytes32 mData = _malloc(size);\r\n\r\n        assembly {\r\n            calldatacopy(mData, 0x0, size)\r\n        }\r\n\r\n        bytes32 mResult = _delegatecall(mData, size);\r\n        _;\r\n        assembly {\r\n            return(mResult, 0x20)\r\n        }\r\n    }\r\n    \r\n    function()\r\n        payable\r\n        delegated\r\n    {\r\n\r\n    }\r\n\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        delegated\r\n        returns (uint)\r\n    {\r\n        \r\n    }\r\n    \r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        delegated\r\n    {\r\n        \r\n    }\r\n    \r\n    function watch(address _tokenAddr)\r\n        public\r\n        delegated\r\n    {\r\n        \r\n    }\r\n    \r\n    function setMyTokenList(address[] _tokenList)  \r\n        public\r\n        delegated\r\n    {\r\n\r\n    }\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        delegated\r\n        returns (bool)\r\n    {\r\n\r\n    }\r\n    \r\n    /*\r\n    * Web3 call functions\r\n    */\r\n    function tokenBalances(address tokenAddress) \r\n        public\r\n        constant \r\n        delegated \r\n        returns (uint)\r\n    {\r\n\r\n    }\r\n\r\n\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        delegated\r\n        returns (uint)\r\n    {\r\n\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filters are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        delegated\r\n        returns (uint)\r\n    {\r\n\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns list of tokens.\r\n    /// @return List of token addresses.\r\n    function getTokenList()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return tokens;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = 0; i < owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        }\r\n        _confirmations = new address[](count);\r\n        for (i = 0; i < count; i++) {\r\n            _confirmations[i] = confirmationsTemp[i];\r\n        }\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = 0; i < transactionCount; i++) {\r\n            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i = from; i < to; i++) {\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n        }\r\n    }\r\n\r\n\r\n    function _malloc(uint size) \r\n        private \r\n        returns(bytes32 mData) \r\n    {\r\n        assembly {\r\n            mData := mload(0x40)\r\n            mstore(0x40, add(mData, size))\r\n        }\r\n    }\r\n\r\n    function _delegatecall(bytes32 mData, uint size) \r\n        private \r\n        returns(bytes32 mResult) \r\n    {\r\n        address target = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4; //Multinetwork\r\n        mResult = _malloc(32);\r\n        bool failed;\r\n\r\n        assembly {\r\n            failed := iszero(delegatecall(sub(gas, 10000), target, mData, size, mResult, 0x20))\r\n        }\r\n\r\n        assert(!failed);\r\n    }\r\n    \r\n}\r\n\r\ncontract MultiSigFactory {\r\n    \r\n    event Create(address indexed caller, address createdContract);\r\n\r\n    function create(address[] owners, uint256 required) returns (address wallet){\r\n        wallet = new MultiSigStub(owners, required); \r\n        Create(msg.sender, wallet);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owners\",\"type\":\"address[]\"},{\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"createdContract\",\"type\":\"address\"}],\"name\":\"Create\",\"type\":\"event\"}]","ContractName":"MultiSigFactory","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0ccf3b3fa467632d1b58fbbceff943c4811b152a9c35dc2431dfc39ffd7bd70f"}]}