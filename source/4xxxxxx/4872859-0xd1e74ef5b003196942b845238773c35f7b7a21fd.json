{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary itMaps {\r\n    \r\n    /* itMapAddressUint\r\n         address =>  Uint\r\n    */\r\n    struct entryAddressUint {\r\n        // Equal to the index of the key of this item in keys, plus 1.\r\n        uint keyIndex;\r\n        uint value;\r\n    }\r\n\r\n    struct itMapAddressUint {\r\n        mapping(address => entryAddressUint) data;\r\n        address[] keys;\r\n    }\r\n\r\n    function insert(itMapAddressUint storage self, address key, uint value) internal returns (bool replaced) {\r\n        entryAddressUint storage e = self.data[key];\r\n        e.value = value;\r\n        if (e.keyIndex > 0) {\r\n            return true;\r\n        } else {\r\n            e.keyIndex = ++self.keys.length;\r\n            self.keys[e.keyIndex - 1] = key;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function remove(itMapAddressUint storage self, address key) internal returns (bool sucacess) {\r\n        entryAddressUint storage e = self.data[key];\r\n        if (e.keyIndex == 0)\r\n            return false;\r\n\r\n        if (e.keyIndex <= self.keys.length) {\r\n            // Move an existing element into the vacated key slot.\r\n            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\r\n            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\r\n            self.keys.length -= 1;\r\n            delete self.data[key];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function destroy(itMapAddressUint storage self) internal  {\r\n        for (uint i; i<self.keys.length; i++) {\r\n          delete self.data[ self.keys[i]];\r\n        }\r\n        delete self.keys;\r\n        return ;\r\n    }\r\n\r\n    function contains(itMapAddressUint storage self, address key) internal constant returns (bool exists) {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n\r\n    function size(itMapAddressUint storage self) internal constant returns (uint) {\r\n        return self.keys.length;\r\n    }\r\n\r\n    function get(itMapAddressUint storage self, address key) internal constant returns (uint) {\r\n        return self.data[key].value;\r\n    }\r\n\r\n    function getKeyByIndex(itMapAddressUint storage self, uint idx) internal constant returns (address) {\r\n        return self.keys[idx];\r\n    }\r\n\r\n    function getValueByIndex(itMapAddressUint storage self, uint idx) internal constant returns (uint) {\r\n        return self.data[self.keys[idx]].value;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint256 supply);\r\n    function balanceOf(address who) public constant returns (uint value);\r\n    function allowance(address owner, address spender) public constant returns (uint _allowance);\r\n\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract AmirNessSpecial is ERC20{\r\n    using itMaps for itMaps.itMapAddressUint;\r\n   \r\n    \r\n    uint256 initialSupply = 30000;\r\nstring public constant name = \"AmirNessSpecial\";\r\nstring public constant symbol = \"Amir\";\r\nuint currentUSDExchangeRate = 1100;\r\nuint priceUSD = 1;\r\naddress AmirAddress;\r\nitMaps.itMapAddressUint balances;\r\nmapping (address => mapping (address => uint256)) allowed;\r\nmapping (address => uint256) approvedDividends;\r\n    event Burned(address indexed from, uint amount);\r\nevent DividendsTransfered(address to, uint amount);\r\n\r\nmodifier onlyOwner {\r\n   if (msg.sender == AmirAddress) {\r\n       _;\r\n   }\r\n}\r\n\r\nfunction totalSupply() public constant returns (uint256) {\r\nreturn initialSupply;\r\n    }\r\n    \r\n    function balanceOf(address tokenHolder) public view returns (uint256 balance) {\r\nreturn balances.get(tokenHolder);\r\n    }\r\n\r\nfunction allowance(address owner, address spender) public constant returns (uint256) {\r\nreturn allowed[owner][spender];\r\n    }\r\n\r\n\r\nfunction transfer(address to, uint value) public returns (bool success) {\r\nif (balances.get(msg.sender) >= value && value > 0) {\r\n   \r\n   balances.insert(msg.sender, balances.get(msg.sender)-value);\r\nif (balances.contains(to)) {\r\n   balances.insert(to, balances.get(to)+value);\r\n}\r\nelse {\r\n   balances.insert(to, value);\r\n}\r\nTransfer(msg.sender, to, value);\r\n        \r\nreturn true;\r\n} else return false;\r\n    }\r\n\r\nfunction transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\nif (balances.get(from) >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n \r\n uint amountToInsert = value;\r\n \r\n if (balances.contains(to))\r\n   amountToInsert = amountToInsert+balances.get(to);\r\n   \r\n balances.insert(to, amountToInsert);\r\n balances.insert(from, balances.get(from) - value);\r\n allowed[from][msg.sender] = allowed[from][msg.sender] - value;\r\n Transfer(from, to, value);\r\n return true;\r\n} else \r\n return false;\r\n}\r\n \r\nfunction approve(address spender, uint value) public returns (bool success) {\r\nif ((value != 0) && (balances.get(msg.sender) >= value)){\r\n    allowed[msg.sender][spender] = value;\r\n   \tApproval(msg.sender, spender, value);\r\n   return true;\r\n} else{\r\n   return false;\r\n}\r\n}\r\n\r\nfunction AmirNessSpecial() public {\r\n        AmirAddress = msg.sender;\r\n        balances.insert(AmirAddress, initialSupply);\r\n    }\r\n\r\nfunction setCurrentExchangeRate (uint rate) public onlyOwner{\r\ncurrentUSDExchangeRate = rate;\r\n}\r\n\r\nfunction () public payable{\r\n   uint amountInUSDollars = msg.value * currentUSDExchangeRate / 10**18;\r\n   uint valueToPass = amountInUSDollars / priceUSD;\r\n   \r\n   if (balances.get(AmirAddress) >= valueToPass) {\r\n            if (balances.contains(msg.sender)) {\r\n   balances.insert(msg.sender, balances.get(msg.sender)+valueToPass);\r\n}\r\nelse {\r\n   balances.insert(msg.sender, valueToPass);\r\n}\r\n            balances.insert(AmirAddress, balances.get(AmirAddress)-valueToPass);\r\n            Transfer(AmirAddress, msg.sender, valueToPass);\r\n        }\r\n}\r\n\r\nfunction approveDividends (uint totalDividendsAmount) public onlyOwner {\r\nuint256 dividendsPerToken = totalDividendsAmount*10**18 / initialSupply; \r\nfor (uint256 i = 0; i<balances.size(); i += 1) {\r\naddress tokenHolder = balances.getKeyByIndex(i);\r\nif (balances.get(tokenHolder)>0)\r\n   approvedDividends[tokenHolder] = balances.get(tokenHolder)*dividendsPerToken;\r\n}\r\n}\r\nfunction burnUnsold() public onlyOwner returns (bool success) {\r\n   uint burningAmount = balances.get(AmirAddress);\r\n    initialSupply -= burningAmount;\r\nbalances.insert(AmirAddress, 0);\r\nBurned(AmirAddress, burningAmount);\r\n        return true;\r\n    }\r\n\r\nfunction approvedDividendsOf(address tokenHolder) public view returns (uint256) {\r\n   return approvedDividends[tokenHolder];\r\n}\r\n\r\nfunction transferAllDividends() public onlyOwner{\r\nfor (uint256 i = 0; i< balances.size(); i += 1) {\r\naddress tokenHolder = balances.getKeyByIndex(i);\r\nif (approvedDividends[tokenHolder] > 0)\r\n{\r\n   tokenHolder.transfer(approvedDividends[tokenHolder]);\r\n   DividendsTransfered (tokenHolder, approvedDividends[tokenHolder]);\r\n   approvedDividends[tokenHolder] = 0;\r\n}\r\n}\r\n}\r\nfunction withdraw(uint amount) public onlyOwner{\r\n        AmirAddress.transfer(amount*10**18);\r\n}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"approvedDividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferAllDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setCurrentExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"totalDividendsAmount\",\"type\":\"uint256\"}],\"name\":\"approveDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnUnsold\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendsTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"AmirNessSpecial","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3b2213586c969b2e0ea53f04b573dd329967b7f55ac32e2b84b588fa0bee26ce"}]}