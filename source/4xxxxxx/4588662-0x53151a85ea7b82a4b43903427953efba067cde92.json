{"status":"1","message":"OK","result":[{"SourceCode":"contract SafeMath {\r\n    \r\n    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        require(x <= (MAX_UINT256 / y));\r\n        return x * y;\r\n    }\r\n}\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\ncontract Lockable is Owned {\r\n\r\n    uint256 public lockedUntilBlock;\r\n\r\n    event ContractLocked(uint256 _untilBlock, string _reason);\r\n\r\n    modifier lockAffected {\r\n        require(block.number > lockedUntilBlock);\r\n        _;\r\n    }\r\n\r\n    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }\r\n\r\n\r\n    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }\r\n}\r\ncontract ReentrancyHandlingContract{\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\ncontract tokenRecipientInterface {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\ncontract ERC20TokenInterface {\r\n  function totalSupply() public constant returns (uint256 _totalSupply);\r\n  function balanceOf(address _owner) public constant returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract SportifyTokenInterface {\r\n    function mint(address _to, uint256 _amount) public;\r\n}\r\n\r\ncontract Crowdsale is ReentrancyHandlingContract, Owned {\r\n\r\n  struct ContributorData {\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n  }\r\n\r\n  mapping(address => ContributorData) public contributorList;\r\n  uint nextContributorIndex;\r\n  mapping(uint => address) contributorIndexes;\r\n\r\n  state public crowdsaleState = state.pendingStart;\r\n  enum state { pendingStart, crowdsale, crowdsaleEnded }\r\n\r\n  uint public crowdsaleStartBlock;\r\n  uint public crowdsaleEndedBlock;\r\n\r\n  event CrowdsaleStarted(uint blockNumber);\r\n  event CrowdsaleEnded(uint blockNumber);\r\n  event ErrorSendingETH(address to, uint amount);\r\n  event MinCapReached(uint blockNumber);\r\n  event MaxCapReached(uint blockNumber);\r\n\r\n  address tokenAddress = 0x0;\r\n  uint decimals = 18;\r\n\r\n  uint ethToTokenConversion;\r\n\r\n  uint public minCap;\r\n  uint public maxCap;\r\n  uint public ethRaised;\r\n  uint public tokenTotalSupply = 200000000 * 10**decimals;\r\n\r\n  address public multisigAddress;\r\n  uint blocksInADay;\r\n\r\n  uint nextContributorToClaim;\r\n  mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n  uint crowdsaleTokenCap =          134000000 * 10**decimals;\r\n  uint foundersAndTeamTokens =       36000000 * 10**decimals;\r\n  uint advisorAndAmbassadorTokens =  20000000 * 10**decimals;\r\n  uint futurePromoEventTokens =      10000000 * 10**decimals;\r\n  bool foundersAndTeamTokensClaimed = false;\r\n  bool advisorAndAmbassadorTokensClaimed = false;\r\n  bool futurePromoEventTokensClaimed = false;\r\n\r\n  //\r\n  // Unnamed function that runs when eth is sent to the contract\r\n  //\r\n  function() noReentrancy payable public {\r\n    require(msg.value != 0);                        // Throw if value is 0\r\n    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n\r\n    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n\r\n    if (crowdsaleState == state.crowdsale) {\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    } else {\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }\r\n\r\n  //\r\n  // Check crowdsale state and calibrate it\r\n  //\r\n  function checkCrowdsaleState() internal returns (bool) {\r\n    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded) {                        // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      CrowdsaleEnded(block.number);                                                             // Raise event\r\n      return true;\r\n    }\r\n\r\n    if (block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {            // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.number);                                                         // Raise event\r\n        return true;\r\n      }\r\n    } else {\r\n      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.number);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //\r\n  // Decide if throw or only return ether\r\n  //\r\n  function refundTransaction(bool _stateChanged) internal {\r\n    if (_stateChanged) {\r\n      msg.sender.transfer(msg.value);\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\r\n    if (_blockNumber < crowdsaleStartBlock + blocksInADay * 3) {\r\n      return _eth * 3298;\r\n    }\r\n    if (_eth >= 100*10**decimals) {\r\n      return _eth * 3298;\r\n    }\r\n    if (_blockNumber > crowdsaleStartBlock) {\r\n      return _eth * 2998;\r\n    }\r\n  }\r\n\r\n  //\r\n  // Issue tokens and return if there is overflow\r\n  //\r\n  function processTransaction(address _contributor, uint _amount) internal{\r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n\r\n    if (_amount > (maxCap - ethRaised)) {                                          // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\r\n      returnAmount = _amount - contributionAmount;                                 // Calculate howmuch he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) {\r\n      MinCapReached(block.number);\r\n    }\r\n\r\n    if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap) {\r\n      MaxCapReached(block.number);\r\n    }\r\n\r\n    if (contributorList[_contributor].contributionAmount == 0) {\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex += 1;\r\n    }\r\n\r\n    contributorList[_contributor].contributionAmount += contributionAmount;\r\n    ethRaised += contributionAmount;                                              // Add to eth raised\r\n\r\n    uint tokenAmount = calculateEthToToken(contributionAmount, block.number);     // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0) {\r\n      SportifyTokenInterface(tokenAddress).mint(_contributor, tokenAmount);       // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n    if (returnAmount != 0) {\r\n      _contributor.transfer(returnAmount);\r\n    } \r\n  }\r\n\r\n  function pushAngelInvestmentData(address _address, uint _ethContributed) onlyOwner public {\r\n      assert(ethRaised + _ethContributed <= maxCap);\r\n      processTransaction(_address, _ethContributed);\r\n  }\r\n  function depositAngelInvestmentEth() payable onlyOwner public {}\r\n  \r\n\r\n  //\r\n  // Method is needed for recovering tokens accedentaly sent to token address\r\n  //\r\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n  }\r\n\r\n  //\r\n  // withdrawEth when minimum cap is reached\r\n  //\r\n  function withdrawEth() onlyOwner public {\r\n    require(this.balance != 0);\r\n    require(ethRaised >= minCap);\r\n\r\n    multisigAddress.transfer(this.balance);\r\n  }\r\n\r\n  //\r\n  // Users can claim their contribution if min cap is not raised\r\n  //\r\n  function claimEthIfFailed() public {\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\r\n    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\r\n    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\r\n\r\n    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\r\n    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\r\n    if (!msg.sender.send(ethContributed)) {                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }\r\n  }\r\n\r\n  //\r\n  // Owner can batch return contributors contributions(eth)\r\n  //\r\n  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\r\n    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) {\r\n        return;                                                                       // Check if all the participants were compensated\r\n      }\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }\r\n\r\n  //\r\n  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\r\n  //\r\n  function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\r\n    require(this.balance != 0);                                  // Check if there are any eth to claim\r\n    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\r\n    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\r\n    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\r\n  }\r\n\r\n  function claimTeamTokens(address _to, uint _choice) onlyOwner public {\r\n    require(crowdsaleState == state.crowdsaleEnded);\r\n    require(ethRaised >= minCap);\r\n\r\n    uint mintAmount;\r\n    if (_choice == 1) {\r\n      assert(!advisorAndAmbassadorTokensClaimed);\r\n      mintAmount = advisorAndAmbassadorTokens;\r\n      advisorAndAmbassadorTokensClaimed = true;\r\n    } else if (_choice == 2) {\r\n      assert(!futurePromoEventTokensClaimed);\r\n      mintAmount = futurePromoEventTokens;\r\n      futurePromoEventTokensClaimed = true;\r\n    } else if (_choice == 3) {\r\n      assert(!foundersAndTeamTokensClaimed);\r\n      assert(advisorAndAmbassadorTokensClaimed);\r\n      assert(futurePromoEventTokensClaimed);\r\n      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\r\n      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\r\n      foundersAndTeamTokensClaimed = true;\r\n    } else {\r\n      revert();\r\n    }\r\n    SportifyTokenInterface(tokenAddress).mint(_to, mintAmount);\r\n  }\r\n\r\n\r\n  //\r\n  // Owner can set multisig address for crowdsale\r\n  //\r\n  function setMultisigAddress(address _newAddress) onlyOwner public {\r\n    multisigAddress = _newAddress;\r\n  }\r\n\r\n  //\r\n  // Owner can set token address where mints will happen\r\n  //\r\n  function setToken(address _newAddress) onlyOwner public {\r\n    tokenAddress = _newAddress;\r\n  }\r\n\r\n  function getTokenAddress() constant public returns(address) {\r\n    return tokenAddress;\r\n  }\r\n\r\n  function investorCount() constant public returns(uint) {\r\n    return nextContributorIndex;\r\n  }\r\n}\r\n\r\ncontract SportifyCrowdsale is Crowdsale {\r\n  \r\n  function SportifyCrowdsale() { \r\n\r\n    crowdsaleStartBlock = 4595138;\r\n    crowdsaleEndedBlock = 4708120;\r\n\r\n    minCap = 4190000000000000000000;\r\n    maxCap = 40629000000000000000000;\r\n\r\n    blocksInADay = 6646;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMultisigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndedBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainingBalanceForManualRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"calculateEthToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_choice\",\"type\":\"uint256\"}],\"name\":\"claimTeamTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorList\",\"outputs\":[{\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"name\":\"tokensIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositAngelInvestmentEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_ethContributed\",\"type\":\"uint256\"}],\"name\":\"pushAngelInvestmentData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ErrorSendingETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MinCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MaxCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"SportifyCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dc7ca859c1b9f0a2d39ede808d7c10942a907750af9916839a1bdebf8287ab27"}]}