{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\ncontract FlightDelayControllerInterface {\r\n\r\n    function isOwner(address _addr) returns (bool _isOwner);\r\n\r\n    function selfRegister(bytes32 _id) returns (bool result);\r\n\r\n    function getContract(bytes32 _id) returns (address _addr);\r\n}\r\n\r\n\r\n\r\ncontract FlightDelayDatabaseModel {\r\n\r\n    // Ledger accounts.\r\n    enum Acc {\r\n        Premium,      // 0\r\n        RiskFund,     // 1\r\n        Payout,       // 2\r\n        Balance,      // 3\r\n        Reward,       // 4\r\n        OraclizeCosts // 5\r\n    }\r\n\r\n    // policy Status Codes and meaning:\r\n    //\r\n    // 00 = Applied:\t  the customer has payed a premium, but the oracle has\r\n    //\t\t\t\t\t        not yet checked and confirmed.\r\n    //\t\t\t\t\t        The customer can still revoke the policy.\r\n    // 01 = Accepted:\t  the oracle has checked and confirmed.\r\n    //\t\t\t\t\t        The customer can still revoke the policy.\r\n    // 02 = Revoked:\t  The customer has revoked the policy.\r\n    //\t\t\t\t\t        The premium minus cancellation fee is payed back to the\r\n    //\t\t\t\t\t        customer by the oracle.\r\n    // 03 = PaidOut:\t  The flight has ended with delay.\r\n    //\t\t\t\t\t        The oracle has checked and payed out.\r\n    // 04 = Expired:\t  The flight has endet with <15min. delay.\r\n    //\t\t\t\t\t        No payout.\r\n    // 05 = Declined:\t  The application was invalid.\r\n    //\t\t\t\t\t        The premium minus cancellation fee is payed back to the\r\n    //\t\t\t\t\t        customer by the oracle.\r\n    // 06 = SendFailed:\tDuring Revoke, Decline or Payout, sending ether failed\r\n    //\t\t\t\t\t        for unknown reasons.\r\n    //\t\t\t\t\t        The funds remain in the contracts RiskFund.\r\n\r\n\r\n    //                   00       01        02       03        04      05           06\r\n    enum policyState { Applied, Accepted, Revoked, PaidOut, Expired, Declined, SendFailed }\r\n\r\n    // oraclize callback types:\r\n    enum oraclizeState { ForUnderwriting, ForPayout }\r\n\r\n    //               00   01   02   03\r\n    enum Currency { ETH, EUR, USD, GBP }\r\n\r\n    // the policy structure: this structure keeps track of the individual parameters of a policy.\r\n    // typically customer address, premium and some status information.\r\n    struct Policy {\r\n        // 0 - the customer\r\n        address customer;\r\n\r\n        // 1 - premium\r\n        uint premium;\r\n        // risk specific parameters:\r\n        // 2 - pointer to the risk in the risks mapping\r\n        bytes32 riskId;\r\n        // custom payout pattern\r\n        // in future versions, customer will be able to tamper with this array.\r\n        // to keep things simple, we have decided to hard-code the array for all policies.\r\n        // uint8[5] pattern;\r\n        // 3 - probability weight. this is the central parameter\r\n        uint weight;\r\n        // 4 - calculated Payout\r\n        uint calculatedPayout;\r\n        // 5 - actual Payout\r\n        uint actualPayout;\r\n\r\n        // status fields:\r\n        // 6 - the state of the policy\r\n        policyState state;\r\n        // 7 - time of last state change\r\n        uint stateTime;\r\n        // 8 - state change message/reason\r\n        bytes32 stateMessage;\r\n        // 9 - TLSNotary Proof\r\n        bytes proof;\r\n        // 10 - Currency\r\n        Currency currency;\r\n        // 10 - External customer id\r\n        bytes32 customerExternalId;\r\n    }\r\n\r\n    // the risk structure; this structure keeps track of the risk-\r\n    // specific parameters.\r\n    // several policies can share the same risk structure (typically\r\n    // some people flying with the same plane)\r\n    struct Risk {\r\n        // 0 - Airline Code + FlightNumber\r\n        bytes32 carrierFlightNumber;\r\n        // 1 - scheduled departure and arrival time in the format /dep/YYYY/MM/DD\r\n        bytes32 departureYearMonthDay;\r\n        // 2 - the inital arrival time\r\n        uint arrivalTime;\r\n        // 3 - the final delay in minutes\r\n        uint delayInMinutes;\r\n        // 4 - the determined delay category (0-5)\r\n        uint8 delay;\r\n        // 5 - we limit the cumulated weighted premium to avoid cluster risks\r\n        uint cumulatedWeightedPremium;\r\n        // 6 - max cumulated Payout for this risk\r\n        uint premiumMultiplier;\r\n    }\r\n\r\n    // the oraclize callback structure: we use several oraclize calls.\r\n    // all oraclize calls will result in a common callback to __callback(...).\r\n    // to keep track of the different querys we have to introduce this struct.\r\n    struct OraclizeCallback {\r\n        // for which policy have we called?\r\n        uint policyId;\r\n        // for which purpose did we call? {ForUnderwrite | ForPayout}\r\n        oraclizeState oState;\r\n        // time\r\n        uint oraclizeTime;\r\n    }\r\n\r\n    struct Customer {\r\n        bytes32 customerExternalId;\r\n        bool identityConfirmed;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract FlightDelayControlledContract is FlightDelayDatabaseModel {\r\n\r\n    address public controller;\r\n    FlightDelayControllerInterface FD_CI;\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == controller);\r\n        _;\r\n    }\r\n\r\n    function setController(address _controller) internal returns (bool _result) {\r\n        controller = _controller;\r\n        FD_CI = FlightDelayControllerInterface(_controller);\r\n        _result = true;\r\n    }\r\n\r\n    function destruct() onlyController {\r\n        selfdestruct(controller);\r\n    }\r\n\r\n    function setContracts() onlyController {}\r\n\r\n    function getContract(bytes32 _id) internal returns (address _addr) {\r\n        _addr = FD_CI.getContract(_id);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract FlightDelayConstants {\r\n\r\n    /*\r\n    * General events\r\n    */\r\n\r\n// --> test-mode\r\n//        event LogUint(string _message, uint _uint);\r\n//        event LogUintEth(string _message, uint ethUint);\r\n//        event LogUintTime(string _message, uint timeUint);\r\n//        event LogInt(string _message, int _int);\r\n//        event LogAddress(string _message, address _address);\r\n//        event LogBytes32(string _message, bytes32 hexBytes32);\r\n//        event LogBytes(string _message, bytes hexBytes);\r\n//        event LogBytes32Str(string _message, bytes32 strBytes32);\r\n//        event LogString(string _message, string _string);\r\n//        event LogBool(string _message, bool _bool);\r\n//        event Log(address);\r\n// <-- test-mode\r\n\r\n    event LogPolicyApplied(\r\n        uint _policyId,\r\n        address _customer,\r\n        bytes32 strCarrierFlightNumber,\r\n        uint ethPremium\r\n    );\r\n    event LogPolicyAccepted(\r\n        uint _policyId,\r\n        uint _statistics0,\r\n        uint _statistics1,\r\n        uint _statistics2,\r\n        uint _statistics3,\r\n        uint _statistics4,\r\n        uint _statistics5\r\n    );\r\n    event LogPolicyPaidOut(\r\n        uint _policyId,\r\n        uint ethAmount\r\n    );\r\n    event LogPolicyExpired(\r\n        uint _policyId\r\n    );\r\n    event LogPolicyDeclined(\r\n        uint _policyId,\r\n        bytes32 strReason\r\n    );\r\n    event LogPolicyManualPayout(\r\n        uint _policyId,\r\n        bytes32 strReason\r\n    );\r\n    event LogSendFunds(\r\n        address _recipient,\r\n        uint8 _from,\r\n        uint ethAmount\r\n    );\r\n    event LogReceiveFunds(\r\n        address _sender,\r\n        uint8 _to,\r\n        uint ethAmount\r\n    );\r\n    event LogSendFail(\r\n        uint _policyId,\r\n        bytes32 strReason\r\n    );\r\n    event LogOraclizeCall(\r\n        uint _policyId,\r\n        bytes32 hexQueryId,\r\n        string _oraclizeUrl\r\n    );\r\n    event LogOraclizeCallback(\r\n        uint _policyId,\r\n        bytes32 hexQueryId,\r\n        string _result,\r\n        bytes hexProof\r\n    );\r\n    event LogSetState(\r\n        uint _policyId,\r\n        uint8 _policyState,\r\n        uint _stateTime,\r\n        bytes32 _stateMessage\r\n    );\r\n    event LogExternal(\r\n        uint256 _policyId,\r\n        address _address,\r\n        bytes32 _externalId\r\n    );\r\n\r\n    /*\r\n    * General constants\r\n    */\r\n\r\n    // minimum observations for valid prediction\r\n    uint constant MIN_OBSERVATIONS = 10;\r\n    // minimum premium to cover costs\r\n    uint constant MIN_PREMIUM = 50 finney;\r\n    // maximum premium\r\n    uint constant MAX_PREMIUM = 1 ether;\r\n    // maximum payout\r\n    uint constant MAX_PAYOUT = 1100 finney;\r\n\r\n    uint constant MIN_PREMIUM_EUR = 1500 wei;\r\n    uint constant MAX_PREMIUM_EUR = 29000 wei;\r\n    uint constant MAX_PAYOUT_EUR = 30000 wei;\r\n\r\n    uint constant MIN_PREMIUM_USD = 1700 wei;\r\n    uint constant MAX_PREMIUM_USD = 34000 wei;\r\n    uint constant MAX_PAYOUT_USD = 35000 wei;\r\n\r\n    uint constant MIN_PREMIUM_GBP = 1300 wei;\r\n    uint constant MAX_PREMIUM_GBP = 25000 wei;\r\n    uint constant MAX_PAYOUT_GBP = 270 wei;\r\n\r\n    // maximum cumulated weighted premium per risk\r\n    uint constant MAX_CUMULATED_WEIGHTED_PREMIUM = 300 ether;\r\n    // 1 percent for DAO, 1 percent for maintainer\r\n    uint8 constant REWARD_PERCENT = 2;\r\n    // reserve for tail risks\r\n    uint8 constant RESERVE_PERCENT = 1;\r\n    // the weight pattern; in future versions this may become part of the policy struct.\r\n    // currently can't be constant because of compiler restrictions\r\n    // WEIGHT_PATTERN[0] is not used, just to be consistent\r\n    uint8[6] WEIGHT_PATTERN = [\r\n        0,\r\n        10,\r\n        20,\r\n        30,\r\n        50,\r\n        50\r\n    ];\r\n\r\n// --> prod-mode\r\n    // DEFINITIONS FOR ROPSTEN AND MAINNET\r\n    // minimum time before departure for applying\r\n    uint constant MIN_TIME_BEFORE_DEPARTURE\t= 24 hours; // for production\r\n    // check for delay after .. minutes after scheduled arrival\r\n    uint constant CHECK_PAYOUT_OFFSET = 15 minutes; // for production\r\n// <-- prod-mode\r\n\r\n// --> test-mode\r\n//        // DEFINITIONS FOR LOCAL TESTNET\r\n//        // minimum time before departure for applying\r\n//        uint constant MIN_TIME_BEFORE_DEPARTURE = 1 seconds; // for testing\r\n//        // check for delay after .. minutes after scheduled arrival\r\n//        uint constant CHECK_PAYOUT_OFFSET = 1 seconds; // for testing\r\n// <-- test-mode\r\n\r\n    // maximum duration of flight\r\n    uint constant MAX_FLIGHT_DURATION = 2 days;\r\n    // Deadline for acceptance of policies: 31.12.2030 (Testnet)\r\n    uint constant CONTRACT_DEAD_LINE = 1922396399;\r\n\r\n    uint constant MIN_DEPARTURE_LIM = 1508198400;\r\n\r\n    uint constant MAX_DEPARTURE_LIM = 1509494400;\r\n\r\n    // gas Constants for oraclize\r\n    uint constant ORACLIZE_GAS = 1000000;\r\n\r\n\r\n    /*\r\n    * URLs and query strings for oraclize\r\n    */\r\n\r\n// --> prod-mode\r\n    // DEFINITIONS FOR ROPSTEN AND MAINNET\r\n    string constant ORACLIZE_RATINGS_BASE_URL =\r\n        // ratings api is v1, see https://developer.flightstats.com/api-docs/ratings/v1\r\n        \"[URL] json(https://api.flightstats.com/flex/ratings/rest/v1/json/flight/\";\r\n    string constant ORACLIZE_RATINGS_QUERY =\r\n        \"?${[decrypt] BDuCYocRMLSG1ps6CPtaKal1sRS+duDdEFlNoIro+789kuuKLR4nsoYqELn+G6OIGEY722F6PFw9Y5YW/NWLnOLYFdzSh+ulIZ7Uum736YAa6CuYSFZ/EQem6s1y8t+HKg4zfhVw84tY09xIFAM1+MywYvbg8lbm80bPjbWKvmDdx230oAbu}).ratings[0]['observations','late15','late30','late45','cancelled','diverted','arrivalAirportFsCode']\";\r\n    string constant ORACLIZE_STATUS_BASE_URL =\r\n        // flight status api is v2, see https://developer.flightstats.com/api-docs/flightstatus/v2/flight\r\n        \"[URL] json(https://api.flightstats.com/flex/flightstatus/rest/v2/json/flight/status/\";\r\n    string constant ORACLIZE_STATUS_QUERY =\r\n        // pattern:\r\n        \"?${[decrypt] BHAF1MKJcAev0j66Q9G2s/HrMJdmq8io30+miL89TSfv6GH+vtfMYudd34mLjVCJaORzHpB+WOQgN19maTA0Rza4aSpN4TxV7v+eATjUiXWp/VL/GNMu+ACE9OseA2QA+HNhrviWAQPzkmKEVJfKd9l/5p5TN0b93whYFL9KiTn1eO0m61Wi}&utc=true).flightStatuses[0]['status','delays','operationalTimes']\";\r\n// <-- prod-mode\r\n\r\n// --> test-mode\r\n//        // DEFINITIONS FOR LOCAL TESTNET\r\n//        string constant ORACLIZE_RATINGS_BASE_URL =\r\n//            // ratings api is v1, see https://developer.flightstats.com/api-docs/ratings/v1\r\n//            \"[URL] json(https://api-test.etherisc.com/flex/ratings/rest/v1/json/flight/\";\r\n//        string constant ORACLIZE_RATINGS_QUERY =\r\n//            // for testrpc:\r\n//            \").ratings[0]['observations','late15','late30','late45','cancelled','diverted','arrivalAirportFsCode']\";\r\n//        string constant ORACLIZE_STATUS_BASE_URL =\r\n//            // flight status api is v2, see https://developer.flightstats.com/api-docs/flightstatus/v2/flight\r\n//            \"[URL] json(https://api-test.etherisc.com/flex/flightstatus/rest/v2/json/flight/status/\";\r\n//        string constant ORACLIZE_STATUS_QUERY =\r\n//            // for testrpc:\r\n//            \"?utc=true).flightStatuses[0]['status','delays','operationalTimes']\";\r\n// <-- test-mode\r\n}\r\n\r\ncontract FlightDelayDatabaseInterface is FlightDelayDatabaseModel {\r\n\r\n    function setAccessControl(address _contract, address _caller, uint8 _perm);\r\n\r\n    function setAccessControl(\r\n        address _contract,\r\n        address _caller,\r\n        uint8 _perm,\r\n        bool _access\r\n    );\r\n\r\n    function getAccessControl(address _contract, address _caller, uint8 _perm) returns (bool _allowed);\r\n\r\n    function setLedger(uint8 _index, int _value);\r\n\r\n    function getLedger(uint8 _index) returns (int _value);\r\n\r\n    function getCustomerPremium(uint _policyId) returns (address _customer, uint _premium);\r\n\r\n    function getPolicyData(uint _policyId) returns (address _customer, uint _premium, uint _weight);\r\n\r\n    function getPolicyState(uint _policyId) returns (policyState _state);\r\n\r\n    function getRiskId(uint _policyId) returns (bytes32 _riskId);\r\n\r\n    function createPolicy(address _customer, uint _premium, Currency _currency, bytes32 _customerExternalId, bytes32 _riskId) returns (uint _policyId);\r\n\r\n    function setState(\r\n        uint _policyId,\r\n        policyState _state,\r\n        uint _stateTime,\r\n        bytes32 _stateMessage\r\n    );\r\n\r\n    function setWeight(uint _policyId, uint _weight, bytes _proof);\r\n\r\n    function setPayouts(uint _policyId, uint _calculatedPayout, uint _actualPayout);\r\n\r\n    function setDelay(uint _policyId, uint8 _delay, uint _delayInMinutes);\r\n\r\n    function getRiskParameters(bytes32 _riskId)\r\n        returns (bytes32 _carrierFlightNumber, bytes32 _departureYearMonthDay, uint _arrivalTime);\r\n\r\n    function getPremiumFactors(bytes32 _riskId)\r\n        returns (uint _cumulatedWeightedPremium, uint _premiumMultiplier);\r\n\r\n    function createUpdateRisk(bytes32 _carrierFlightNumber, bytes32 _departureYearMonthDay, uint _arrivalTime)\r\n        returns (bytes32 _riskId);\r\n\r\n    function setPremiumFactors(bytes32 _riskId, uint _cumulatedWeightedPremium, uint _premiumMultiplier);\r\n\r\n    function getOraclizeCallback(bytes32 _queryId)\r\n        returns (uint _policyId, uint _arrivalTime);\r\n\r\n    function getOraclizePolicyId(bytes32 _queryId)\r\n    returns (uint _policyId);\r\n\r\n    function createOraclizeCallback(\r\n        bytes32 _queryId,\r\n        uint _policyId,\r\n        oraclizeState _oraclizeState,\r\n        uint _oraclizeTime\r\n    );\r\n\r\n    function checkTime(bytes32 _queryId, bytes32 _riskId, uint _offset)\r\n        returns (bool _result);\r\n}\r\n\r\ncontract FlightDelayAccessControllerInterface {\r\n\r\n    function setPermissionById(uint8 _perm, bytes32 _id);\r\n\r\n    function setPermissionById(uint8 _perm, bytes32 _id, bool _access);\r\n\r\n    function setPermissionByAddress(uint8 _perm, address _addr);\r\n\r\n    function setPermissionByAddress(uint8 _perm, address _addr, bool _access);\r\n\r\n    function checkPermission(uint8 _perm, address _addr) returns (bool _success);\r\n}\r\n\r\n\r\ncontract FlightDelayLedgerInterface is FlightDelayDatabaseModel {\r\n\r\n    function receiveFunds(Acc _to) payable;\r\n\r\n    function sendFunds(address _recipient, Acc _from, uint _amount) returns (bool _success);\r\n\r\n    function bookkeeping(Acc _from, Acc _to, uint amount);\r\n}\r\n\r\ncontract FlightDelayUnderwriteInterface {\r\n\r\n    function scheduleUnderwriteOraclizeCall(uint _policyId, bytes32 _carrierFlightNumber);\r\n}\r\n\r\ncontract ConvertLib {\r\n\r\n    // .. since beginning of the year\r\n    uint16[12] days_since = [\r\n        11,\r\n        42,\r\n        70,\r\n        101,\r\n        131,\r\n        162,\r\n        192,\r\n        223,\r\n        254,\r\n        284,\r\n        315,\r\n        345\r\n    ];\r\n\r\n    function b32toString(bytes32 x) internal returns (string) {\r\n        // gas usage: about 1K gas per char.\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    function b32toHexString(bytes32 x) returns (string) {\r\n        bytes memory b = new bytes(64);\r\n        for (uint i = 0; i < 32; i++) {\r\n            uint8 by = uint8(uint(x) / (2**(8*(31 - i))));\r\n            uint8 high = by/16;\r\n            uint8 low = by - 16*high;\r\n            if (high > 9) {\r\n                high += 39;\r\n            }\r\n            if (low > 9) {\r\n                low += 39;\r\n            }\r\n            b[2*i] = byte(high+48);\r\n            b[2*i+1] = byte(low+48);\r\n        }\r\n\r\n        return string(b);\r\n    }\r\n\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i<bresult.length; i++) {\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)) {\r\n                if (decimals) {\r\n                    if (_b == 0) {\r\n                        break;\r\n                    } else {\r\n                        _b--;\r\n                    }\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) {\r\n                decimals = true;\r\n            }\r\n        }\r\n        if (_b > 0) {\r\n            mint *= 10**_b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    // the following function yields correct results in the time between 1.3.2016 and 28.02.2020,\r\n    // so within the validity of the contract its correct.\r\n    function toUnixtime(bytes32 _dayMonthYear) constant returns (uint unixtime) {\r\n        // _day_month_year = /dep/2016/09/10\r\n        bytes memory bDmy = bytes(b32toString(_dayMonthYear));\r\n        bytes memory temp2 = bytes(new string(2));\r\n        bytes memory temp4 = bytes(new string(4));\r\n\r\n        temp4[0] = bDmy[5];\r\n        temp4[1] = bDmy[6];\r\n        temp4[2] = bDmy[7];\r\n        temp4[3] = bDmy[8];\r\n        uint year = parseInt(string(temp4));\r\n\r\n        temp2[0] = bDmy[10];\r\n        temp2[1] = bDmy[11];\r\n        uint month = parseInt(string(temp2));\r\n\r\n        temp2[0] = bDmy[13];\r\n        temp2[1] = bDmy[14];\r\n        uint day = parseInt(string(temp2));\r\n\r\n        unixtime = ((year - 1970) * 365 + days_since[month-1] + day) * 86400;\r\n    }\r\n}\r\n\r\ncontract FlightDelayNewPolicy is FlightDelayControlledContract, FlightDelayConstants, ConvertLib {\r\n\r\n    FlightDelayAccessControllerInterface FD_AC;\r\n    FlightDelayDatabaseInterface FD_DB;\r\n    FlightDelayLedgerInterface FD_LG;\r\n    FlightDelayUnderwriteInterface FD_UW;\r\n\r\n    function FlightDelayNewPolicy(address _controller) {\r\n        setController(_controller);\r\n    }\r\n\r\n    function setContracts() onlyController {\r\n        FD_AC = FlightDelayAccessControllerInterface(getContract(\"FD.AccessController\"));\r\n        FD_DB = FlightDelayDatabaseInterface(getContract(\"FD.Database\"));\r\n        FD_LG = FlightDelayLedgerInterface(getContract(\"FD.Ledger\"));\r\n        FD_UW = FlightDelayUnderwriteInterface(getContract(\"FD.Underwrite\"));\r\n\r\n        FD_AC.setPermissionByAddress(101, 0x0);\r\n        FD_AC.setPermissionById(102, \"FD.Controller\");\r\n        FD_AC.setPermissionById(103, \"FD.Owner\");\r\n    }\r\n\r\n    function bookAndCalcRemainingPremium() internal returns (uint) {\r\n        uint v = msg.value;\r\n        uint reserve = v * RESERVE_PERCENT / 100;\r\n        uint remain = v - reserve;\r\n        uint reward = remain * REWARD_PERCENT / 100;\r\n\r\n        // FD_LG.bookkeeping(Acc.Balance, Acc.Premium, v);\r\n        FD_LG.bookkeeping(Acc.Premium, Acc.RiskFund, reserve);\r\n        FD_LG.bookkeeping(Acc.Premium, Acc.Reward, reward);\r\n\r\n        return (uint(remain - reward));\r\n    }\r\n\r\n    function maintenanceMode(bool _on) {\r\n        if (FD_AC.checkPermission(103, msg.sender)) {\r\n            FD_AC.setPermissionByAddress(101, 0x0, !_on);\r\n        }\r\n    }\r\n\r\n    // create new policy\r\n    function newPolicy(\r\n        bytes32 _carrierFlightNumber,\r\n        bytes32 _departureYearMonthDay,\r\n        uint256 _departureTime,\r\n        uint256 _arrivalTime,\r\n        Currency _currency,\r\n        bytes32 _customerExternalId) payable\r\n    {\r\n        // here we can switch it off.\r\n        require(FD_AC.checkPermission(101, 0x0));\r\n\r\n        require(uint256(_currency) <= 3);\r\n\r\n        uint8 paymentType = uint8(_currency);\r\n\r\n        if (paymentType == 0) {\r\n            // ETH\r\n            if (msg.value < MIN_PREMIUM || msg.value > MAX_PREMIUM) {\r\n                LogPolicyDeclined(0, \"Invalid premium value\");\r\n                FD_LG.sendFunds(msg.sender, Acc.Premium, msg.value);\r\n                return;\r\n            }\r\n        } else {\r\n            require(msg.sender == FD_CI.getContract(\"FD.CustomersAdmin\"));\r\n\r\n            if (paymentType == 1) {\r\n                // EUR\r\n                if (msg.value < MIN_PREMIUM_EUR || msg.value > MAX_PREMIUM_EUR) {\r\n                    LogPolicyDeclined(0, \"Invalid premium value\");\r\n                    FD_LG.sendFunds(msg.sender, Acc.Premium, msg.value);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (paymentType == 2) {\r\n                // USD\r\n                if (msg.value < MIN_PREMIUM_USD || msg.value > MAX_PREMIUM_USD) {\r\n                    LogPolicyDeclined(0, \"Invalid premium value\");\r\n                    FD_LG.sendFunds(msg.sender, Acc.Premium, msg.value);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (paymentType == 3) {\r\n                // GBP\r\n                if (msg.value < MIN_PREMIUM_GBP || msg.value > MAX_PREMIUM_GBP) {\r\n                    LogPolicyDeclined(0, \"Invalid premium value\");\r\n                    FD_LG.sendFunds(msg.sender, Acc.Premium, msg.value);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // forward premium\r\n        FD_LG.receiveFunds.value(msg.value)(Acc.Premium);\r\n\r\n\r\n        // don't Accept flights with departure time earlier than in 24 hours,\r\n        // or arrivalTime before departureTime,\r\n        // or departureTime after Mon, 26 Sep 2016 12:00:00 GMT\r\n        uint dmy = toUnixtime(_departureYearMonthDay);\r\n\r\n// --> debug-mode\r\n//            LogUintTime(\"NewPolicy: dmy: \", dmy);\r\n//            LogUintTime(\"NewPolicy: _departureTime: \", _departureTime);\r\n// <-- debug-mode\r\n\r\n        if (\r\n            _arrivalTime < _departureTime ||\r\n            _arrivalTime > _departureTime + MAX_FLIGHT_DURATION ||\r\n            _departureTime < now + MIN_TIME_BEFORE_DEPARTURE ||\r\n            _departureTime > CONTRACT_DEAD_LINE ||\r\n            _departureTime < dmy ||\r\n            _departureTime > dmy + 24 hours ||\r\n            _departureTime < MIN_DEPARTURE_LIM ||\r\n            _departureTime > MAX_DEPARTURE_LIM\r\n        ) {\r\n            LogPolicyDeclined(0, \"Invalid arrival/departure time\");\r\n            FD_LG.sendFunds(msg.sender, Acc.Premium, msg.value);\r\n            return;\r\n        }\r\n\r\n        bytes32 riskId = FD_DB.createUpdateRisk(_carrierFlightNumber, _departureYearMonthDay, _arrivalTime);\r\n\r\n        var (cumulatedWeightedPremium, premiumMultiplier) = FD_DB.getPremiumFactors(riskId);\r\n\r\n        // roughly check, whether MAX_CUMULATED_WEIGHTED_PREMIUM will be exceeded\r\n        // (we Accept the inAccuracy that the real remaining premium is 3% lower),\r\n        // but we are conservative;\r\n        // if this is the first policy, the left side will be 0\r\n        if (msg.value * premiumMultiplier + cumulatedWeightedPremium >= MAX_CUMULATED_WEIGHTED_PREMIUM) {\r\n            // Let's ingore MAX_CUMULATED_WEIGHTED_PREMIUM for Cancun\r\n\r\n            // LogPolicyDeclined(0, \"Cluster risk\");\r\n            // FD_LG.sendFunds(msg.sender, Acc.Premium, msg.value);\r\n            // return;\r\n        } else if (cumulatedWeightedPremium == 0) {\r\n            // at the first police, we set r.cumulatedWeightedPremium to the max.\r\n            // this prevents further polices to be Accepted, until the correct\r\n            // value is calculated after the first callback from the oracle.\r\n            FD_DB.setPremiumFactors(riskId, MAX_CUMULATED_WEIGHTED_PREMIUM, premiumMultiplier);\r\n        }\r\n\r\n        uint premium = bookAndCalcRemainingPremium();\r\n        uint policyId = FD_DB.createPolicy(msg.sender, premium, _currency, _customerExternalId, riskId);\r\n\r\n        if (premiumMultiplier > 0) {\r\n            FD_DB.setPremiumFactors(\r\n                riskId,\r\n                cumulatedWeightedPremium + premium * premiumMultiplier,\r\n                premiumMultiplier\r\n            );\r\n        }\r\n\r\n        // now we have successfully applied\r\n        FD_DB.setState(\r\n            policyId,\r\n            policyState.Applied,\r\n            now,\r\n            \"Policy applied by customer\"\r\n        );\r\n\r\n        LogPolicyApplied(\r\n            policyId,\r\n            msg.sender,\r\n            _carrierFlightNumber,\r\n            premium\r\n        );\r\n\r\n        LogExternal(\r\n            policyId,\r\n            msg.sender,\r\n            _customerExternalId\r\n        );\r\n\r\n        FD_UW.scheduleUnderwriteOraclizeCall(policyId, _carrierFlightNumber);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"destruct\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_on\",\"type\":\"bool\"}],\"name\":\"maintenanceMode\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"bytes32\"}],\"name\":\"b32toHexString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_dayMonthYear\",\"type\":\"bytes32\"}],\"name\":\"toUnixtime\",\"outputs\":[{\"name\":\"unixtime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setContracts\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_carrierFlightNumber\",\"type\":\"bytes32\"},{\"name\":\"_departureYearMonthDay\",\"type\":\"bytes32\"},{\"name\":\"_departureTime\",\"type\":\"uint256\"},{\"name\":\"_arrivalTime\",\"type\":\"uint256\"},{\"name\":\"_currency\",\"type\":\"uint8\"},{\"name\":\"_customerExternalId\",\"type\":\"bytes32\"}],\"name\":\"newPolicy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_customer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"strCarrierFlightNumber\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethPremium\",\"type\":\"uint256\"}],\"name\":\"LogPolicyApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_statistics0\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_statistics1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_statistics2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_statistics3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_statistics4\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_statistics5\",\"type\":\"uint256\"}],\"name\":\"LogPolicyAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"LogPolicyPaidOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"}],\"name\":\"LogPolicyExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"strReason\",\"type\":\"bytes32\"}],\"name\":\"LogPolicyDeclined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"strReason\",\"type\":\"bytes32\"}],\"name\":\"LogPolicyManualPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"LogSendFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"LogReceiveFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"strReason\",\"type\":\"bytes32\"}],\"name\":\"LogSendFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hexQueryId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_oraclizeUrl\",\"type\":\"string\"}],\"name\":\"LogOraclizeCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hexQueryId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_result\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"hexProof\",\"type\":\"bytes\"}],\"name\":\"LogOraclizeCallback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_policyState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_stateTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stateMessage\",\"type\":\"bytes32\"}],\"name\":\"LogSetState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_policyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_externalId\",\"type\":\"bytes32\"}],\"name\":\"LogExternal\",\"type\":\"event\"}]","ContractName":"FlightDelayNewPolicy","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f5c3086d42cb2857ad5f52c134fc3e698e8e9edd","Library":"","SwarmSource":"bzzr://7ee8b9edab5e39cdd51b89299897b485f22885e9ea93e82230f2a24f0683d88d"}]}