{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n/**\r\n * @title ERC20\r\n * @dev ERC20 interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n    address public controller;\r\n    function Controlled() public { controller = msg.sender;}\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n/**\r\n * @title MiniMe interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20MiniMe is ERC20, Controlled {\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool);\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint);\r\n    function totalSupplyAt(uint _blockNumber) public view returns(uint);\r\n    function createCloneToken(string _cloneTokenName, uint8 _cloneDecimalUnits, string _cloneTokenSymbol, uint _snapshotBlock, bool _transfersEnabled) public returns(address);\r\n    function generateTokens(address _owner, uint _amount) public returns (bool);\r\n    function destroyTokens(address _owner, uint _amount)  public returns (bool);\r\n    function enableTransfers(bool _transfersEnabled) public;\r\n    function isContract(address _addr) internal view returns(bool);\r\n    function claimTokens(address _token) public;\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n  // The token being sold\r\n  ERC20MiniMe public token;\r\n  // start and end timestamps where investments are allowed (both inclusive)\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  // address where funds are collected\r\n  address public wallet;\r\n  // how many token units a buyer gets per wei\r\n  uint256 public rate;\r\n  // amount of raised money in wei\r\n  uint256 public weiRaised;\r\n  /**\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {\r\n    require(_startTime >= now);\r\n    require(_endTime >= _startTime);\r\n    require(_rate > 0);\r\n    require(_wallet != 0x0);\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n  }\r\n  // fallback function can be used to buy tokens\r\n  function () payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n  // low level token purchase function\r\n  function buyTokens(address beneficiary) public payable {\r\n    buyTokens(beneficiary, msg.value);\r\n  }\r\n  // implementation of low level token purchase function\r\n  function buyTokens(address beneficiary, uint256 weiAmount) internal {\r\n    require(beneficiary != 0x0);\r\n    require(validPurchase(weiAmount));\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n    transferToken(beneficiary, weiAmount);\r\n    forwardFunds(weiAmount);\r\n  }\r\n  // low level transfer token\r\n  // override to create custom token transfer mechanism, eg. pull pattern\r\n  function transferToken(address beneficiary, uint256 weiAmount) internal {\r\n    // calculate token amount to be created\r\n    uint256 tokens = weiAmount.mul(rate);\r\n    token.generateTokens(beneficiary, tokens);\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n  }\r\n  // send ether to the fund collection wallet\r\n  // override to create custom fund forwarding mechanisms\r\n  function forwardFunds(uint256 weiAmount) internal {\r\n    wallet.transfer(weiAmount);\r\n  }\r\n  // @return true if the transaction can buy tokens\r\n  function validPurchase(uint256 weiAmount) internal view returns (bool) {\r\n    bool withinPeriod = now >= startTime && now <= endTime;\r\n    bool nonZeroPurchase = weiAmount != 0;\r\n    return withinPeriod && nonZeroPurchase;\r\n  }\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public view returns (bool) {\r\n    return now > endTime;\r\n  }\r\n  // @return true if crowdsale has started\r\n  function hasStarted() public view returns (bool) {\r\n    return now >= startTime;\r\n  }\r\n}\r\n/**\r\n * @title CappedCrowdsale\r\n * @dev Extension of Crowdsale with a max amount of funds raised\r\n */\r\ncontract CappedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n  uint256 public cap;\r\n  function CappedCrowdsale(uint256 _cap) {\r\n    require(_cap > 0);\r\n    cap = _cap;\r\n  }\r\n  // overriding Crowdsale#validPurchase to add extra cap logic\r\n  // @return true if investors can buy at the moment\r\n  function validPurchase(uint256 weiAmount) internal view returns (bool) {\r\n    return super.validPurchase(weiAmount) && !capReached();\r\n  }\r\n  // overriding Crowdsale#hasEnded to add cap logic\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public view returns (bool) {\r\n    return super.hasEnded() || capReached();\r\n  }\r\n  // @return true if cap has been reached\r\n  function capReached() internal view returns (bool) {\r\n   return weiRaised >= cap;\r\n  }\r\n  // overriding Crowdsale#buyTokens to add partial refund logic\r\n  function buyTokens(address beneficiary) public payable {\r\n     uint256 weiToCap = cap.sub(weiRaised);\r\n     uint256 weiAmount = weiToCap < msg.value ? weiToCap : msg.value;\r\n     buyTokens(beneficiary, weiAmount);\r\n     uint256 refund = msg.value.sub(weiAmount);\r\n     if (refund > 0) {\r\n       msg.sender.transfer(refund);\r\n     }\r\n   }\r\n}\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of Crowdsale where an owner can do extra work\r\n * after finishing.\r\n */\r\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\r\n  using SafeMath for uint256;\r\n  bool public isFinalized = false;\r\n  event Finalized();\r\n  /**\r\n   * @dev Must be called after crowdsale ends, to do some extra finalization\r\n   * work. Calls the contract's finalization function.\r\n   */\r\n  function finalize() onlyOwner public {\r\n    require(!isFinalized);\r\n    require(hasEnded());\r\n    finalization();\r\n    Finalized();\r\n    isFinalized = true;\r\n  }\r\n  /**\r\n   * @dev Can be overridden to add finalization logic. The overriding function\r\n   * should call super.finalization() to ensure the chain of finalization is\r\n   * executed entirely.\r\n   */\r\n  function finalization() internal {\r\n  }\r\n}\r\n/**\r\n * @title claim accidentally sent tokens\r\n */\r\ncontract HasNoTokens is Ownable {\r\n    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\r\n    /// @notice This method can be used to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    /// @param _claimer Address that tokens will be send to\r\n    function extractTokens(address _token, address _claimer) onlyOwner public {\r\n        if (_token == 0x0) {\r\n            _claimer.transfer(this.balance);\r\n            return;\r\n        }\r\n        ERC20 token = ERC20(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(_claimer, balance);\r\n        ExtractedTokens(_token, _claimer, balance);\r\n    }\r\n}\r\n/**\r\n * @title RefundVault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\n * and forwarding it if crowdsale is successful.\r\n */\r\ncontract RefundVault is Ownable, HasNoTokens {\r\n  using SafeMath for uint256;\r\n  enum State { Active, Refunding, Closed }\r\n  mapping (address => uint256) public deposited;\r\n  address public wallet;\r\n  State public state;\r\n  event Closed();\r\n  event RefundsEnabled();\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n  function RefundVault(address _wallet) {\r\n    require(_wallet != 0x0);\r\n    wallet = _wallet;\r\n    state = State.Active;\r\n  }\r\n  function deposit(address investor) onlyOwner public payable {\r\n    require(state == State.Active);\r\n    deposited[investor] = deposited[investor].add(msg.value);\r\n  }\r\n  function close() onlyOwner public {\r\n    require(state == State.Active);\r\n    state = State.Closed;\r\n    Closed();\r\n    wallet.transfer(this.balance);\r\n  }\r\n  function enableRefunds() onlyOwner public {\r\n    require(state == State.Active);\r\n    state = State.Refunding;\r\n    RefundsEnabled();\r\n  }\r\n  function refund(address investor) public {\r\n    require(state == State.Refunding);\r\n    uint256 depositedValue = deposited[investor];\r\n    deposited[investor] = 0;\r\n    investor.transfer(depositedValue);\r\n    Refunded(investor, depositedValue);\r\n  }\r\n}\r\n/**\r\n * @title RefundableCrowdsale\r\n * @dev Extension of Crowdsale contract that adds a funding goal, and\r\n * the possibility of users getting a refund if goal is not met.\r\n * Uses a RefundVault as the crowdsale's vault.\r\n */\r\ncontract RefundableCrowdsale is FinalizableCrowdsale {\r\n  using SafeMath for uint256;\r\n  // minimum amount of funds to be raised in weis\r\n  uint256 public goal;\r\n  // refund vault used to hold funds while crowdsale is running\r\n  RefundVault public vault;\r\n  function RefundableCrowdsale(uint256 _goal) {\r\n    require(_goal > 0);\r\n    vault = new RefundVault(wallet);\r\n    goal = _goal;\r\n  }\r\n  // We're overriding the fund forwarding from Crowdsale.\r\n  // If the goal is reached forward the fund to the wallet, \r\n  // otherwise in addition to sending the funds, we want to\r\n  // call the RefundVault deposit function\r\n  function forwardFunds(uint256 weiAmount) internal {\r\n    if (goalReached())\r\n      wallet.transfer(weiAmount);\r\n    else\r\n      vault.deposit.value(weiAmount)(msg.sender);\r\n  }\r\n  // if crowdsale is unsuccessful, investors can claim refunds here\r\n  function claimRefund() public {\r\n    require(isFinalized);\r\n    require(!goalReached());\r\n    vault.refund(msg.sender);\r\n  }\r\n  // vault finalization task, called when owner calls finalize()\r\n  function finalization() internal {\r\n    if (goalReached()) {\r\n      vault.close();\r\n    } else {\r\n      vault.enableRefunds();\r\n    }\r\n    super.finalization();\r\n  }\r\n  function goalReached() public view returns (bool) {\r\n    return weiRaised >= goal;\r\n  }\r\n}\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    ERC20MiniMe public ethealToken;\r\n    address public SALE; // address where sale tokens are located\r\n    /// @notice needed for hodler handling\r\n    function addHodlerStake(address _beneficiary, uint _stake) public;\r\n    function setHodlerStake(address _beneficiary, uint256 _stake) public;\r\n    function setHodlerTime(uint256 _time) public;\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\r\n}\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n  bool public paused = false;\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n/**\r\n * @title EthealPreSale\r\n * @author thesved\r\n * @notice Etheal Token Sale round one presale contract, with mincap (goal), softcap and hardcap (cap)\r\n * @dev This contract has to be finalized before refund or token claims are enabled\r\n */\r\ncontract EthealPreSale is Pausable, CappedCrowdsale, RefundableCrowdsale {\r\n    // the token is here\r\n    TokenController public ethealController;\r\n    // after reaching {weiRaised} >= {softCap}, there is {softCapTime} seconds until the sale closes\r\n    // {softCapClose} contains the closing time\r\n    uint256 public rate = 1250;\r\n    uint256 public goal = 333 ether;\r\n    uint256 public softCap = 3600 ether;\r\n    uint256 public softCapTime = 120 hours;\r\n    uint256 public softCapClose;\r\n    uint256 public cap = 7200 ether;\r\n    // how many token is sold and not claimed, used for refunding to token controller\r\n    uint256 public tokenBalance;\r\n    // total token sold\r\n    uint256 public tokenSold;\r\n    // contributing above {maxGasPrice} results in \r\n    // calculating stakes on {maxGasPricePenalty} / 100\r\n    // eg. 80 {maxGasPricePenalty} means 80%, sending 5 ETH with more than 100gwei gas price will be calculated as 4 ETH\r\n    uint256 public maxGasPrice = 100 * 10**9;\r\n    uint256 public maxGasPricePenalty = 80;\r\n    // minimum contribution, 0.1ETH\r\n    uint256 public minContribution = 0.1 ether;\r\n    // first {whitelistDayCount} days of token sale is exclusive for whitelisted addresses\r\n    // {whitelistDayMaxStake} contains the max stake limits per address for each whitelist sales day\r\n    // {whitelist} contains who can contribute during whitelist period\r\n    uint8 public whitelistDayCount;\r\n    mapping (address => bool) public whitelist;\r\n    mapping (uint8 => uint256) public whitelistDayMaxStake;\r\n    \r\n    // stakes contains contribution stake in wei\r\n    // contributed ETH is calculated on 80% when sending funds with gasprice above maxGasPrice\r\n    mapping (address => uint256) public stakes;\r\n    // addresses of contributors to handle finalization after token sale end (refunds or token claims)\r\n    address[] public contributorsKeys; \r\n    // events for token purchase during sale and claiming tokens after sale\r\n    event TokenClaimed(address indexed _claimer, address indexed _beneficiary, uint256 _stake, uint256 _amount);\r\n    event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _stake, uint256 _amount, uint256 _participants, uint256 _weiRaised);\r\n    event TokenGoalReached();\r\n    event TokenSoftCapReached(uint256 _closeTime);\r\n    // whitelist events for adding days with maximum stakes and addresses\r\n    event WhitelistAddressAdded(address indexed _whitelister, address indexed _beneficiary);\r\n    event WhitelistAddressRemoved(address indexed _whitelister, address indexed _beneficiary);\r\n    event WhitelistSetDay(address indexed _whitelister, uint8 _day, uint256 _maxStake);\r\n    ////////////////\r\n    // Constructor and inherited function overrides\r\n    ////////////////\r\n    /// @notice Constructor to create PreSale contract\r\n    /// @param _ethealController Address of ethealController\r\n    /// @param _startTime The start time of token sale in seconds.\r\n    /// @param _endTime The end time of token sale in seconds.\r\n    /// @param _minContribution The minimum contribution per transaction in wei (0.1 ETH)\r\n    /// @param _rate Number of HEAL tokens per 1 ETH\r\n    /// @param _goal Minimum funding in wei, below that EVERYONE gets back ALL their\r\n    ///  contributions regardless of maxGasPrice penalty. \r\n    ///  Eg. someone contributes with 5 ETH, but gets only 4 ETH stakes because\r\n    ///  sending funds with gasprice over 100Gwei, he will still get back >>5 ETH<<\r\n    ///  in case of unsuccessful token sale\r\n    /// @param _softCap Softcap in wei, reaching it ends the sale in _softCapTime seconds\r\n    /// @param _softCapTime Seconds until the sale remains open after reaching _softCap\r\n    /// @param _cap Maximum cap in wei, we can't raise more funds\r\n    /// @param _gasPrice Maximum gas price\r\n    /// @param _gasPenalty Penalty in percentage points for calculating stakes, eg. 80 means calculating \r\n    ///  stakes on 80% if gasprice was higher than _gasPrice\r\n    /// @param _wallet Address of multisig wallet, which will get all the funds after successful sale\r\n    function EthealPreSale(\r\n        address _ethealController,\r\n        uint256 _startTime, \r\n        uint256 _endTime, \r\n        uint256 _minContribution, \r\n        uint256 _rate, \r\n        uint256 _goal, \r\n        uint256 _softCap, \r\n        uint256 _softCapTime, \r\n        uint256 _cap, \r\n        uint256 _gasPrice, \r\n        uint256 _gasPenalty, \r\n        address _wallet\r\n    )\r\n        CappedCrowdsale(_cap)\r\n        FinalizableCrowdsale()\r\n        RefundableCrowdsale(_goal)\r\n        Crowdsale(_startTime, _endTime, _rate, _wallet)\r\n    {\r\n        // ethealController must be valid\r\n        require(_ethealController != address(0));\r\n        ethealController = TokenController(_ethealController);\r\n        // caps have to be consistent with each other\r\n        require(_goal <= _softCap && _softCap <= _cap);\r\n        softCap = _softCap;\r\n        softCapTime = _softCapTime;\r\n        // this is needed since super constructor wont overwite overriden variables\r\n        cap = _cap;\r\n        goal = _goal;\r\n        rate = _rate;\r\n        maxGasPrice = _gasPrice;\r\n        maxGasPricePenalty = _gasPenalty;\r\n        minContribution = _minContribution;\r\n    }\r\n    /// @dev Overriding Crowdsale#buyTokens to add partial refund and softcap logic \r\n    /// @param _beneficiary Beneficiary of the token purchase\r\n    function buyTokens(address _beneficiary) public payable whenNotPaused {\r\n        require(_beneficiary != address(0));\r\n        uint256 weiToCap = howMuchCanXContributeNow(_beneficiary);\r\n        uint256 weiAmount = uint256Min(weiToCap, msg.value);\r\n        // goal is reached\r\n        if (weiRaised < goal && weiRaised.add(weiAmount) >= goal) {\r\n            TokenGoalReached();\r\n        }\r\n        // call the Crowdsale#buyTokens internal function\r\n        buyTokens(_beneficiary, weiAmount);\r\n        // close sale in softCapTime seconds after reaching softCap\r\n        if (weiRaised >= softCap && softCapClose == 0) {\r\n            softCapClose = now.add(softCapTime);\r\n            TokenSoftCapReached(uint256Min(softCapClose, endTime));\r\n        }\r\n        // handle refund\r\n        uint256 refund = msg.value.sub(weiAmount);\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n    }\r\n    /// @dev Overriding Crowdsale#transferToken, which keeps track of contributions DURING token sale\r\n    /// @param _beneficiary Address of the recepient of the tokens\r\n    /// @param _weiAmount Contribution in wei\r\n    function transferToken(address _beneficiary, uint256 _weiAmount) internal {\r\n        require(_beneficiary != address(0));\r\n        uint256 weiAmount = _weiAmount;\r\n        // check maxGasPricePenalty\r\n        if (maxGasPrice > 0 && tx.gasprice > maxGasPrice) {\r\n            weiAmount = weiAmount.mul(maxGasPricePenalty).div(100);\r\n        }\r\n        // calculate tokens, so we can refund excess tokens to EthealController after token sale\r\n        uint256 tokens = weiAmount.mul(rate);\r\n        tokenBalance = tokenBalance.add(tokens);\r\n        if (stakes[_beneficiary] == 0) {\r\n            contributorsKeys.push(_beneficiary);\r\n        }\r\n        stakes[_beneficiary] = stakes[_beneficiary].add(weiAmount);\r\n        TokenPurchase(msg.sender, _beneficiary, _weiAmount, weiAmount, tokens, contributorsKeys.length, weiRaised);\r\n    }\r\n    /// @dev Overriding Crowdsale#validPurchase to add min contribution logic\r\n    /// @param _weiAmount Contribution amount in wei\r\n    /// @return true if contribution is okay\r\n    function validPurchase(uint256 _weiAmount) internal view returns (bool) {\r\n        return super.validPurchase(_weiAmount) && _weiAmount >= minContribution;\r\n    }\r\n    /// @dev Overriding Crowdsale#hasEnded to add soft cap logic\r\n    /// @return true if crowdsale event has ended or a softCapClose time is set and passed\r\n    function hasEnded() public view returns (bool) {\r\n        return super.hasEnded() || softCapClose > 0 && now > softCapClose;\r\n    }\r\n    /// @dev Overriding RefundableCrowdsale#claimRefund to enable anyone to call for any address\r\n    ///  which enables us to refund anyone and also anyone can refund themselves\r\n    function claimRefund() public {\r\n        claimRefundFor(msg.sender);\r\n    }\r\n    /// @dev Extending RefundableCrowdsale#finalization sending back excess tokens to ethealController\r\n    function finalization() internal {\r\n        uint256 _balance = getHealBalance();\r\n        // if token sale was successful send back excess funds\r\n        if (goalReached()) {\r\n            // saving token balance for future reference\r\n            tokenSold = tokenBalance; \r\n            // send back the excess token to ethealController\r\n            if (_balance > tokenBalance) {\r\n                ethealController.ethealToken().transfer(ethealController.SALE(), _balance.sub(tokenBalance));\r\n            }\r\n        } else if (!goalReached() && _balance > 0) {\r\n            // if token sale is failed, then send back all tokens to ethealController's sale address\r\n            tokenBalance = 0;\r\n            ethealController.ethealToken().transfer(ethealController.SALE(), _balance);\r\n        }\r\n        super.finalization();\r\n    }\r\n    ////////////////\r\n    // BEFORE token sale\r\n    ////////////////\r\n    /// @notice Modifier for before sale cases\r\n    modifier beforeSale() {\r\n        require(!hasStarted());\r\n        _;\r\n    }\r\n    /// @notice Sets whitelist\r\n    /// @dev The length of _whitelistLimits says that the first X days of token sale is \r\n    ///  closed, meaning only for whitelisted addresses.\r\n    /// @param _add Array of addresses to add to whitelisted ethereum accounts\r\n    /// @param _remove Array of addresses to remove to whitelisted ethereum accounts\r\n    /// @param _whitelistLimits Array of limits in wei, where _whitelistLimits[0] = 10 ETH means\r\n    ///  whitelisted addresses can contribute maximum 10 ETH stakes on the first day\r\n    ///  After _whitelistLimits.length days, there will be no limits per address (besides hard cap)\r\n    function setWhitelist(address[] _add, address[] _remove, uint256[] _whitelistLimits) public onlyOwner beforeSale {\r\n        uint256 i = 0;\r\n        uint8 j = 0; // access max daily stakes\r\n        // we override whiteListLimits only if it was supplied as an argument\r\n        if (_whitelistLimits.length > 0) {\r\n            // saving whitelist max stake limits for each day -> uint256 maxStakeLimit\r\n            whitelistDayCount = uint8(_whitelistLimits.length);\r\n            for (i = 0; i < _whitelistLimits.length; i++) {\r\n                j = uint8(i.add(1));\r\n                if (whitelistDayMaxStake[j] != _whitelistLimits[i]) {\r\n                    whitelistDayMaxStake[j] = _whitelistLimits[i];\r\n                    WhitelistSetDay(msg.sender, j, _whitelistLimits[i]);\r\n                }\r\n            }\r\n        }\r\n        // adding whitelist addresses\r\n        for (i = 0; i < _add.length; i++) {\r\n            require(_add[i] != address(0));\r\n            \r\n            if (!whitelist[_add[i]]) {\r\n                whitelist[_add[i]] = true;\r\n                WhitelistAddressAdded(msg.sender, _add[i]);\r\n            }\r\n        }\r\n        // removing whitelist addresses\r\n        for (i = 0; i < _remove.length; i++) {\r\n            require(_remove[i] != address(0));\r\n            \r\n            if (whitelist[_remove[i]]) {\r\n                whitelist[_remove[i]] = false;\r\n                WhitelistAddressRemoved(msg.sender, _remove[i]);\r\n            }\r\n        }\r\n    }\r\n    /// @notice Sets max gas price and penalty before sale\r\n    function setMaxGas(uint256 _maxGas, uint256 _penalty) public onlyOwner beforeSale {\r\n        maxGasPrice = _maxGas;\r\n        maxGasPricePenalty = _penalty;\r\n    }\r\n    /// @notice Sets min contribution before sale\r\n    function setMinContribution(uint256 _minContribution) public onlyOwner beforeSale {\r\n        minContribution = _minContribution;\r\n    }\r\n    /// @notice Sets minimum goal, soft cap and max cap\r\n    function setCaps(uint256 _goal, uint256 _softCap, uint256 _softCapTime, uint256 _cap) public onlyOwner beforeSale {\r\n        require(0 < _goal && _goal <= _softCap && _softCap <= _cap);\r\n        goal = _goal;\r\n        softCap = _softCap;\r\n        softCapTime = _softCapTime;\r\n        cap = _cap;\r\n    }\r\n    /// @notice Sets crowdsale start and end time\r\n    function setTimes(uint256 _startTime, uint256 _endTime) public onlyOwner beforeSale {\r\n        require(_startTime > now && _startTime < _endTime);\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n    /// @notice Set rate\r\n    function setRate(uint256 _rate) public onlyOwner beforeSale {\r\n        require(_rate > 0);\r\n        rate = _rate;\r\n    }\r\n    ////////////////\r\n    // AFTER token sale\r\n    ////////////////\r\n    /// @notice Modifier for cases where sale is failed\r\n    /// @dev It checks whether we haven't reach the minimum goal AND whether the contract is finalized\r\n    modifier afterSaleFail() {\r\n        require(!goalReached() && isFinalized);\r\n        _;\r\n    }\r\n    /// @notice Modifier for cases where sale is closed and was successful.\r\n    /// @dev It checks whether\r\n    ///  the sale has ended \r\n    ///  and we have reached our goal\r\n    ///  AND whether the contract is finalized\r\n    modifier afterSaleSuccess() {\r\n        require(goalReached() && isFinalized);\r\n        _;\r\n    }\r\n    /// @notice Modifier for after sale finalization\r\n    modifier afterSale() {\r\n        require(isFinalized);\r\n        _;\r\n    }\r\n    \r\n    /// @notice Refund an ethereum address\r\n    /// @param _beneficiary Address we want to refund\r\n    function claimRefundFor(address _beneficiary) public afterSaleFail whenNotPaused {\r\n        require(_beneficiary != address(0));\r\n        vault.refund(_beneficiary);\r\n    }\r\n    /// @notice Refund several addresses with one call\r\n    /// @param _beneficiaries Array of addresses we want to refund\r\n    function claimRefundsFor(address[] _beneficiaries) external afterSaleFail {\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n            claimRefundFor(_beneficiaries[i]);\r\n        }\r\n    }\r\n    /// @notice Claim token for msg.sender after token sale based on stake.\r\n    function claimToken() public afterSaleSuccess {\r\n        claimTokenFor(msg.sender);\r\n    }\r\n    /// @notice Claim token after token sale based on stake.\r\n    /// @dev Anyone can call this function and distribute tokens after successful token sale\r\n    /// @param _beneficiary Address of the beneficiary who gets the token\r\n    function claimTokenFor(address _beneficiary) public afterSaleSuccess whenNotPaused {\r\n        uint256 stake = stakes[_beneficiary];\r\n        require(stake > 0);\r\n        // set the stake 0 for beneficiary\r\n        stakes[_beneficiary] = 0;\r\n        // calculate token count\r\n        uint256 tokens = stake.mul(rate);\r\n        // decrease tokenBalance, to make it possible to withdraw excess HEAL funds\r\n        tokenBalance = tokenBalance.sub(tokens);\r\n        // distribute hodlr stake\r\n        ethealController.addHodlerStake(_beneficiary, tokens.mul(2));\r\n        // distribute token\r\n        require(ethealController.ethealToken().transfer(_beneficiary, tokens));\r\n        TokenClaimed(msg.sender, _beneficiary, stake, tokens);\r\n    }\r\n    /// @notice claimToken() for multiple addresses\r\n    /// @dev Anyone can call this function and distribute tokens after successful token sale\r\n    /// @param _beneficiaries Array of addresses for which we want to claim tokens\r\n    function claimTokensFor(address[] _beneficiaries) external afterSaleSuccess {\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n            claimTokenFor(_beneficiaries[i]);\r\n        }\r\n    }\r\n    /// @notice Get back accidentally sent token from the vault\r\n    function extractVaultTokens(address _token, address _claimer) public onlyOwner afterSale {\r\n        // it has to have a valid claimer, and either the goal has to be reached or the token can be 0 which means we can't extract ether if the goal is not reached\r\n        require(_claimer != address(0));\r\n        require(goalReached() || _token != address(0));\r\n        vault.extractTokens(_token, _claimer);\r\n    }\r\n    ////////////////\r\n    // Constant, helper functions\r\n    ////////////////\r\n    /// @notice How many wei can the msg.sender contribute now.\r\n    function howMuchCanIContributeNow() view public returns (uint256) {\r\n        return howMuchCanXContributeNow(msg.sender);\r\n    }\r\n    /// @notice How many wei can an ethereum address contribute now.\r\n    /// @dev This function can return 0 when the crowdsale is stopped\r\n    ///  or the address has maxed the current day's whitelist cap,\r\n    ///  it is possible, that next day he can contribute\r\n    /// @param _beneficiary Ethereum address\r\n    /// @return Number of wei the _beneficiary can contribute now.\r\n    function howMuchCanXContributeNow(address _beneficiary) view public returns (uint256) {\r\n        require(_beneficiary != address(0));\r\n        if (!hasStarted() || hasEnded()) {\r\n            return 0;\r\n        }\r\n        // wei to hard cap\r\n        uint256 weiToCap = cap.sub(weiRaised);\r\n        // if this is a whitelist limited period\r\n        uint8 _saleDay = getSaleDayNow();\r\n        if (_saleDay <= whitelistDayCount) {\r\n            // address can't contribute if\r\n            //  it is not whitelisted\r\n            if (!whitelist[_beneficiary]) {\r\n                return 0;\r\n            }\r\n            // personal cap is the daily whitelist limit minus the stakes the address already has\r\n            uint256 weiToPersonalCap = whitelistDayMaxStake[_saleDay].sub(stakes[_beneficiary]);\r\n            // calculate for maxGasPrice penalty\r\n            if (msg.value > 0 && maxGasPrice > 0 && tx.gasprice > maxGasPrice) {\r\n                weiToPersonalCap = weiToPersonalCap.mul(100).div(maxGasPricePenalty);\r\n            }\r\n            weiToCap = uint256Min(weiToCap, weiToPersonalCap);\r\n        }\r\n        return weiToCap;\r\n    }\r\n    /// @notice For a give date how many 24 hour blocks have ellapsed since token sale start\r\n    /// @dev _time has to be bigger than the startTime of token sale, otherwise SafeMath's div will throw.\r\n    ///  Within 24 hours of token sale it will return 1, \r\n    ///  between 24 and 48 hours it will return 2, etc.\r\n    /// @param _time Date in seconds for which we want to know which sale day it is\r\n    /// @return Number of 24 hour blocks ellapsing since token sale start starting from 1\r\n    function getSaleDay(uint256 _time) view public returns (uint8) {\r\n        return uint8(_time.sub(startTime).div(60*60*24).add(1));\r\n    }\r\n    /// @notice How many 24 hour blocks have ellapsed since token sale start\r\n    /// @return Number of 24 hour blocks ellapsing since token sale start starting from 1\r\n    function getSaleDayNow() view public returns (uint8) {\r\n        return getSaleDay(now);\r\n    }\r\n    /// @notice Minimum between two uint8 numbers\r\n    function uint8Min(uint8 a, uint8 b) pure internal returns (uint8) {\r\n        return a > b ? b : a;\r\n    }\r\n    /// @notice Minimum between two uint256 numbers\r\n    function uint256Min(uint256 a, uint256 b) pure internal returns (uint256) {\r\n        return a > b ? b : a;\r\n    }\r\n    ////////////////\r\n    // Test and contribution web app, NO audit is needed\r\n    ////////////////\r\n    /// @notice Was this token sale successful?\r\n    /// @return true if the sale is over and we have reached the minimum goal\r\n    function wasSuccess() view public returns (bool) {\r\n        return hasEnded() && goalReached();\r\n    }\r\n    /// @notice How many contributors we have.\r\n    /// @return Number of different contributor ethereum addresses\r\n    function getContributorsCount() view public returns (uint256) {\r\n        return contributorsKeys.length;\r\n    }\r\n    /// @notice Get contributor addresses to manage refunds or token claims.\r\n    /// @dev If the sale is not yet successful, then it searches in the RefundVault.\r\n    ///  If the sale is successful, it searches in contributors.\r\n    /// @param _pending If true, then returns addresses which didn't get refunded or their tokens distributed to them\r\n    /// @param _claimed If true, then returns already refunded or token distributed addresses\r\n    /// @return Array of addresses of contributors\r\n    function getContributors(bool _pending, bool _claimed) view public returns (address[] contributors) {\r\n        uint256 i = 0;\r\n        uint256 results = 0;\r\n        address[] memory _contributors = new address[](contributorsKeys.length);\r\n        // if we have reached our goal, then search in contributors, since this is what we want to monitor\r\n        if (goalReached()) {\r\n            for (i = 0; i < contributorsKeys.length; i++) {\r\n                if (_pending && stakes[contributorsKeys[i]] > 0 || _claimed && stakes[contributorsKeys[i]] == 0) {\r\n                    _contributors[results] = contributorsKeys[i];\r\n                    results++;\r\n                }\r\n            }\r\n        } else {\r\n            // otherwise search in the refund vault\r\n            for (i = 0; i < contributorsKeys.length; i++) {\r\n                if (_pending && vault.deposited(contributorsKeys[i]) > 0 || _claimed && vault.deposited(contributorsKeys[i]) == 0) {\r\n                    _contributors[results] = contributorsKeys[i];\r\n                    results++;\r\n                }\r\n            }\r\n        }\r\n        contributors = new address[](results);\r\n        for (i = 0; i < results; i++) {\r\n            contributors[i] = _contributors[i];\r\n        }\r\n        return contributors;\r\n    }\r\n    /// @notice How many HEAL tokens do this contract have\r\n    function getHealBalance() view public returns (uint256) {\r\n        return ethealController.ethealToken().balanceOf(address(this));\r\n    }\r\n    \r\n    \r\n    /// @notice Get current date for web3\r\n    function getNow() view public returns (uint256) {\r\n        return now;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"softCapTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPricePenalty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setTimes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHealBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_add\",\"type\":\"address[]\"},{\"name\":\"_remove\",\"type\":\"address[]\"},{\"name\":\"_whitelistLimits\",\"type\":\"uint256[]\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pending\",\"type\":\"bool\"},{\"name\":\"_claimed\",\"type\":\"bool\"}],\"name\":\"getContributors\",\"outputs\":[{\"name\":\"contributors\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributorsKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minContribution\",\"type\":\"uint256\"}],\"name\":\"setMinContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howMuchCanIContributeNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethealController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"claimRefundsFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_goal\",\"type\":\"uint256\"},{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_softCapTime\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setCaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"claimTokensFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistDayCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wasSuccess\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimRefundFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleDayNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapClose\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxGas\",\"type\":\"uint256\"},{\"name\":\"_penalty\",\"type\":\"uint256\"}],\"name\":\"setMaxGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"howMuchCanXContributeNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getSaleDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimTokenFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"whitelistDayMaxStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_claimer\",\"type\":\"address\"}],\"name\":\"extractVaultTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContributorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ethealController\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_minContribution\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_goal\",\"type\":\"uint256\"},{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_softCapTime\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"name\":\"_gasPenalty\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_participants\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_weiRaised\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokenGoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_closeTime\",\"type\":\"uint256\"}],\"name\":\"TokenSoftCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_whitelister\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"WhitelistAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_whitelister\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"WhitelistAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_whitelister\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_day\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_maxStake\",\"type\":\"uint256\"}],\"name\":\"WhitelistSetDay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"EthealPreSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b565726e2e44e4ae9e3ce750fc4ba8fa65e701e0000000000000000000000000000000000000000000000000000000005a1ea140000000000000000000000000000000000000000000000000000000005a33b940000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000000000000000004e20000000000000000000000000000000000000000000000120d4da7b0bd1400000000000000000000000000000000000000000000000000c328093e61ee400000000000000000000000000000000000000000000000000000000000000006978000000000000000000000000000000000000000000000018650127cc3dc8000000000000000000000000000000000000000000000000000000000002e90edd0000000000000000000000000000000000000000000000000000000000000000064000000000000000000000000fc5c6c8015962e7035f3bdc5fe7ec94bedc77833","Library":"","SwarmSource":"bzzr://a680884718c64dc508efeba22ef83e0f91940042954f8ba07b0258477de65d6a"}]}