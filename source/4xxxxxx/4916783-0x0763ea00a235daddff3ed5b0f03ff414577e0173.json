{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n * Library easily handles the cases of overflow as well as underflow. \r\n * Also ensures that balance does nto get naegative\r\n */\r\nlibrary SafeMath {\r\n\t// multiplies two values safely and returns result\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t// devides two values safely and returns result\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\t// subtracts two values safely and returns result\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t// adds two values safely and returns result\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\taddress public owner;\r\n\r\n\t// Event to log whenever the ownership is tranferred\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\tOwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n\tuint256 public totalSupply;\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value, bytes data);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) public view returns (uint256);\r\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\tfunction approve(address spender, uint256 value) public returns (bool);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) balances;\r\n\r\n\t/**\r\n\t* @dev transfer token for a specified address\r\n\t* @param _to The address to transfer to.\r\n\t* @param _value The amount to be transferred.\r\n\t*/\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\r\n\t\tbytes memory empty;\r\n\t\tTransfer(msg.sender, _to, _value, empty);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param _owner The address to query the the balance of.\r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t*/\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n\t// tracks the allowance of address. \r\n\tmapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\t/**\r\n\t * @dev Transfer tokens from one address to another\r\n\t * @param _from address The address which you want to send tokens from\r\n\t * @param _to address The address which you want to transfer to\r\n\t * @param _value uint256 the amount of tokens to be transferred\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[_from]);\r\n\t\trequire(_value <= allowed[_from][msg.sender]);\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n\t\tbytes memory empty;\r\n\t\tTransfer(_from, _to, _value, empty);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\t *\r\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _value The amount of tokens to be spent.\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t * @param _owner address The address which owns the funds.\r\n\t * @param _spender address The address which will spend the funds.\r\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\r\n\t */\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To increment\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _addedValue The amount of tokens to increase the allowance by.\r\n\t */\r\n\tfunction increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To decrement\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n\t */\r\n\tfunction decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title ERC23Receiver interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/223\r\n */\r\ncontract ERC223Receiver {\r\n\t \r\n\tstruct TokenStruct {\r\n\t\taddress sender;\r\n\t\tuint256 value;\r\n\t\tbytes data;\r\n\t\tbytes4 sig;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Fallback function. Our ICO contract should implement this contract to receve ERC23 compatible tokens.\r\n\t * ERC23 protocol checks if contract has implemented this fallback method or not. \r\n\t * If this method is not implemented then tokens are not sent.\r\n\t * This method is introduced to avoid loss of tokens \r\n\t *\r\n\t * @param _from The address which will transfer the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t */\r\n\tfunction tokenFallback(address _from, uint256 _value, bytes _data) public pure {\r\n\t\tTokenStruct memory tkn;\r\n\t\ttkn.sender = _from;\r\n\t\ttkn.value = _value;\r\n\t\ttkn.data = _data;\r\n\t\t// uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n\t\t// tkn.sig = bytes4(u);\r\n\t  \r\n\t\t/* tkn variable is analogue of msg variable of Ether transaction\r\n\t\t*  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\r\n\t\t*  tkn.value the number of tokens that were sent   (analogue of msg.value)\r\n\t\t*  tkn.data is data of token transaction   (analogue of msg.data)\r\n\t\t*  tkn.sig is 4 bytes signature of function\r\n\t\t*  if data of token transaction is a function execution\r\n\t\t*/\r\n\t}\r\n}\r\n\r\n/**\r\n * @title ERC23 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/223\r\n */\r\ncontract ERC223 {\r\n\tuint256 public totalSupply;\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tfunction transfer(address to, uint256 value, bytes data) public returns (bool);\r\n\tfunction transfer(address to, uint256 value, bytes data, string custom_fallback) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\r\n}\r\n\r\n/**\r\n * @title Standard ERC223Token token\r\n *\r\n * @dev Implementation of the ERC23 token.\r\n * @dev https://github.com/ethereum/EIPs/issues/223\r\n */\r\n\r\ncontract ERC223Token is ERC223, StandardToken {\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n\t * @dev Function that is called when a user or another contract wants to transfer funds .\r\n\t * This is method where you can supply fallback function name and that function will be triggered.\r\n\t * This method is added as part of ERC23 standard\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t * @param _custom_fallback Name of the method which should be called after transfer happens. If this method does not exists on contract then transaction will fail\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) {\r\n\t\t// check if receiving is contract\r\n\t\tif(isContract(_to)) {\r\n\t\t\t// validate the address and balance\r\n\t\t\trequire(_to != address(0));\r\n\t\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\r\n\t\t\t// invoke custom fallback function\t\t\t\r\n\t\t\tassert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\r\n\t\t\tTransfer(msg.sender, _to, _value, _data);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// receiver is not a contract so perform normal transfer to address\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n  \r\n\r\n\t/**\r\n\t * @dev Function that is called when a user or another contract wants to transfer funds .\r\n\t * You can pass extra data which can be tracked in event.\r\n\t * This method is added as part of ERC23 standard\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\r\n\t\t// check if receiver is contract address\r\n\t\tif(isContract(_to)) {\r\n\t\t\t// invoke transfer request to contract\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// invoke transfer request to normal user wallet address\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n  \r\n\t/**\r\n\t * @dev Standard function transfer similar to ERC20 transfer with no _data .\r\n\t * Added due to backwards compatibility reasons .\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t//standard function transfer similar to ERC20 transfer with no _data\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\r\n\t\t// check if receiver is contract address\r\n\t\tif(isContract(_to)) {\r\n\t\t\t// invoke transfer request to contract\r\n\t\t\treturn transferToContract(_to, _value, empty);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// invoke transfer request to normal user wallet address\r\n\t\t\treturn transferToAddress(_to, _value, empty);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n\t *\r\n\t * @param _addr The address which need to be checked if contract address or wallet address\r\n\t */\r\n\tfunction isContract(address _addr) private view returns (bool is_contract) {\r\n\t\tuint256 length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that is called when transaction target is an address. This is private method.\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t */\r\n\tfunction transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\r\n\t\t// validate the address and balance\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\r\n\t\t// Log the transfer event\r\n\t\tTransfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n  \r\n\t/**\r\n\t * @dev Function that is called when transaction target is a contract. This is private method.\r\n\t *\r\n\t * @param _to The address which will receive the tokens.\r\n\t * @param _value Amount of tokens received.\r\n\t * @param _data Data sent along with transfer request.\r\n\t */\r\n\tfunction transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\r\n\t\t// validate the address and balance\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\r\n\t\t// call fallback function of contract\r\n\t\tERC223Receiver receiver = ERC223Receiver(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\t\r\n\t\t// Log the transfer event\r\n\t\tTransfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n* @title PalestinoToken\r\n* @dev Very simple ERC23 Token example, where all tokens are pre-assigned to the creator.\r\n*/\r\ncontract PalestinoToken is ERC223Token, Ownable {\r\n\r\n\tstring public constant name = \"Palestino\";\r\n\tstring public constant symbol = \"PALE\";\r\n\tuint256 public constant decimals = 3;\r\n\r\n\tuint256 constant INITIAL_SUPPLY = 10000000 * 1E3;\r\n\t\r\n\t/**\r\n\t* @dev Constructor that gives msg.sender all of existing tokens.\r\n\t*/\r\n\tfunction PalestinoToken() public {\r\n\t\ttotalSupply = INITIAL_SUPPLY;\r\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev if ether is sent to this address, send it back.\r\n\t*/\r\n\tfunction () public {\r\n\t\trevert();\r\n\t}\r\n}\r\n\r\n/**\r\n* @title PalestinoTokenSale\r\n* @dev This is ICO Contract. \r\n* This class accepts the token address as argument to talk with contract.\r\n* Once contract is deployed, funds are transferred to ICO smart contract address and then distributed with investor.\r\n* Sending funds to this ensures that no more than desired tokens are sold.\r\n*/\r\ncontract PalestinoTokenSale is Ownable, ERC223Receiver {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// The token being sold, this holds reference to main token contract\r\n\tPalestinoToken public token;\r\n\r\n\t// timestamp when sale starts\r\n\tuint256 public startingTimestamp = 1515974400;\r\n\r\n\t// amount of token to be sold on sale\r\n\tuint256 public maxTokenForSale = 10000000 * 1E3;\r\n\r\n\t// amount of token sold so far\r\n\tuint256 public totalTokenSold;\r\n\r\n\t// amount of ether raised in sale\r\n\tuint256 public totalEtherRaised;\r\n\r\n\t// ether raised per wallet\r\n\tmapping(address => uint256) public etherRaisedPerWallet;\r\n\r\n\t// walle which will receive the ether funding\r\n\taddress public wallet;\r\n\r\n\t// is contract close and ended\r\n\tbool internal isClose = false;\r\n\r\n\tstruct RoundStruct {\r\n\t\tuint256 number;\r\n\t\tuint256 fromAmount;\r\n\t\tuint256 toAmount;\r\n\t\tuint256 price;\r\n\t}\r\n\r\n\tRoundStruct[9] public rounds;\r\n\r\n\t// token purchsae event\r\n\tevent TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount, uint256 _timestamp);\r\n\r\n\t// manual transfer by admin for external purchase\r\n\tevent TransferManual(address indexed _from, address indexed _to, uint256 _value, string _message);\r\n\r\n\t/**\r\n\t* @dev Constructor that initializes token contract with token address in parameter\r\n\t*/\r\n\tfunction PalestinoTokenSale(address _token, address _wallet) public {\r\n\t\t// set token\r\n\t\ttoken = PalestinoToken(_token);\r\n\r\n\t\t// set wallet\r\n\t\twallet = _wallet;\r\n\r\n\t\t// setup rounds\r\n\t\trounds[0] = RoundStruct(0, 0\t    ,  2500000E3, 0.01 ether);\r\n\t\trounds[1] = RoundStruct(1, 2500000E3,  3000000E3, 0.02 ether);\r\n\t\trounds[2] = RoundStruct(2, 3000000E3,  3500000E3, 0.03 ether);\r\n\t\trounds[3] = RoundStruct(3, 3500000E3,  4000000E3, 0.06 ether);\r\n\t\trounds[4] = RoundStruct(4, 4000000E3,  4500000E3, 0.10 ether);\r\n\t\trounds[5] = RoundStruct(5, 4500000E3,  5000000E3, 0.18 ether);\r\n\t\trounds[6] = RoundStruct(6, 5000000E3,  5500000E3, 0.32 ether);\r\n\t\trounds[7] = RoundStruct(7, 5500000E3,  6000000E3, 0.57 ether);\r\n\t\trounds[8] = RoundStruct(8, 6000000E3, 10000000E3, 1.01 ether);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that validates if the purchase is valid by verifying the parameters\r\n\t *\r\n\t * @param value Amount of ethers sent\r\n\t * @param amount Total number of tokens user is trying to buy.\r\n\t *\r\n\t * @return checks various conditions and returns the bool result indicating validity.\r\n\t */\r\n\tfunction isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {\r\n\t\t// check if timestamp is falling in the range\r\n\t\tbool validTimestamp = startingTimestamp <= block.timestamp;\r\n\r\n\t\t// check if value of the ether is valid\r\n\t\tbool validValue = value != 0;\r\n\r\n\t\t// check if the tokens available in contract for sale\r\n\t\tbool validAmount = maxTokenForSale.sub(totalTokenSold) >= amount && amount > 0;\r\n\r\n\t\t// validate if all conditions are met\r\n\t\treturn validTimestamp && validValue && validAmount && !isClose;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that returns the current round\r\n\t *\r\n\t * @return checks various conditions and returns the current round.\r\n\t */\r\n\tfunction getCurrentRound() public constant returns (RoundStruct) {\r\n\t\tfor(uint256 i = 0 ; i < rounds.length ; i ++) {\r\n\t\t\tif(rounds[i].fromAmount <= totalTokenSold && totalTokenSold < rounds[i].toAmount) {\r\n\t\t\t\treturn rounds[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that returns the estimate token round by sending amount\r\n\t *\r\n\t * @param amount Amount of tokens expected\r\n\t *\r\n\t * @return checks various conditions and returns the estimate token round.\r\n\t */\r\n\tfunction getEstimatedRound(uint256 amount) public constant returns (RoundStruct) {\r\n\t\tfor(uint256 i = 0 ; i < rounds.length ; i ++) {\r\n\t\t\tif(rounds[i].fromAmount > (totalTokenSold + amount)) {\r\n\t\t\t\treturn rounds[i - 1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn rounds[rounds.length - 1];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that returns the maximum token round by sending amount\r\n\t *\r\n\t * @param amount Amount of tokens expected\r\n\t *\r\n\t * @return checks various conditions and returns the maximum token round.\r\n\t */\r\n\tfunction getMaximumRound(uint256 amount) public constant returns (RoundStruct) {\r\n\t\tfor(uint256 i = 0 ; i < rounds.length ; i ++) {\r\n\t\t\tif((totalTokenSold + amount) <= rounds[i].toAmount) {\r\n\t\t\t\treturn rounds[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that calculates the tokens which should be given to user by iterating over rounds\r\n\t *\r\n\t * @param value Amount of ethers sent\r\n\t *\r\n\t * @return checks various conditions and returns the token amount.\r\n\t */\r\n\tfunction getTokenAmount(uint256 value) public constant returns (uint256 , uint256) {\r\n\t\t// assume we are sending no tokens\t\r\n\t\tuint256 totalAmount = 0;\r\n\r\n\t\t// interate until we have some value left for buying\r\n\t\twhile(value > 0) {\r\n\t\t\t\r\n\t\t\t// get current round by passing queue value also \r\n\t\t\tRoundStruct memory estimatedRound = getEstimatedRound(totalAmount);\r\n\t\t\t// find tokens left in current round.\r\n\t\t\tuint256 tokensLeft = estimatedRound.toAmount.sub(totalTokenSold.add(totalAmount));\r\n\r\n\t\t\t// derive tokens can be bought in current round with round price \r\n\t\t\tuint256 tokensBuys = value.mul(1E3).div(estimatedRound.price);\r\n\r\n\t\t\t// check if it is last round and still value left\r\n\t\t\tif(estimatedRound.number == rounds[rounds.length - 1].number) {\r\n\t\t\t\t// its last round \r\n\r\n\t\t\t\t// no tokens left in round and still got value \r\n\t\t\t\tif(tokensLeft == 0 && value > 0) {\r\n\t\t\t\t\treturn (totalAmount , value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if tokens left > tokens buy \r\n\t\t\tif(tokensLeft >= tokensBuys) {\r\n\t\t\t\ttotalAmount = totalAmount.add(tokensBuys);\r\n\t\t\t\tvalue = 0;\r\n\t\t\t\treturn (totalAmount , value);\r\n\t\t\t} else {\r\n\t\t\t\tuint256 tokensLeftValue = tokensLeft.mul(estimatedRound.price).div(1E3);\r\n\t\t\t\ttotalAmount = totalAmount.add(tokensLeft);\r\n\t\t\t\tvalue = value.sub(tokensLeftValue);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn (0 , value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Default fallback method which will be called when any ethers are sent to contract\r\n\t */\r\n\tfunction() public payable {\r\n\t\tbuyTokens(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function that is called either externally or by default payable method\r\n\t *\r\n\t * @param beneficiary who should receive tokens\r\n\t */\r\n\tfunction buyTokens(address beneficiary) public payable {\r\n\t\trequire(beneficiary != address(0));\r\n\r\n\t\t// value sent by buyer\r\n\t\tuint256 value = msg.value;\r\n\r\n\t\t// calculate token amount from the ethers sent\r\n\t\tvar (amount, leftValue) = getTokenAmount(value);\r\n\r\n\t\t// if there is any left value then return \r\n\t\tif(leftValue > 0) {\r\n\t\t\tvalue = value.sub(leftValue);\r\n\t\t\tmsg.sender.transfer(leftValue);\r\n\t\t}\r\n\r\n\t\t// validate the purchase\r\n\t\trequire(isValidPurchase(value , amount));\r\n\r\n\t\t// update the state to log the sold tokens and raised ethers.\r\n\t\ttotalTokenSold = totalTokenSold.add(amount);\r\n\t\ttotalEtherRaised = totalEtherRaised.add(value);\r\n\t\tetherRaisedPerWallet[msg.sender] = etherRaisedPerWallet[msg.sender].add(value);\r\n\r\n\t\t// transfer tokens from contract balance to beneficiary account. calling ERC223 method\r\n\t\tbytes memory empty;\r\n\t\ttoken.transfer(beneficiary, amount, empty);\r\n\t\t\r\n\t\t// log event for token purchase\r\n\t\tTokenPurchase(msg.sender, beneficiary, value, amount, now);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev transmit token for a specified address. \r\n\t* This is owner only method and should be called using web3.js if someone is trying to buy token using bitcoin or any other altcoin.\r\n\t* \r\n\t* @param _to The address to transmit to.\r\n\t* @param _value The amount to be transferred.\r\n\t* @param _message message to log after transfer.\r\n\t*/\r\n\tfunction transferManual(address _to, uint256 _value, string _message) onlyOwner public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\r\n\t\t// transfer tokens manually from contract balance\r\n\t\ttoken.transfer(_to , _value);\r\n\t\tTransferManual(msg.sender, _to, _value, _message);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner to change the wallet address\r\n\t*/\r\n\tfunction setWallet(address _wallet) onlyOwner public {\r\n\t\twallet = _wallet;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Method called by owner of contract to withdraw funds\r\n\t*/\r\n\tfunction withdraw() onlyOwner public {\r\n\t\twallet.transfer(this.balance);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev close contract \r\n\t* This will send remaining token balance to owner\r\n\t* This will distribute available funds across team members\r\n\t*/\t\r\n\tfunction close() onlyOwner public {\r\n\t\t// send remaining tokens back to owner.\r\n\t\tuint256 tokens = token.balanceOf(this); \r\n\t\ttoken.transfer(owner , tokens);\r\n\r\n\t\t// withdraw funds \r\n\t\twithdraw();\r\n\r\n\t\t// mark the flag to indicate closure of the contract\r\n\t\tisClose = true;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_custom_fallback\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"PalestinoToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://febfa5621a9bc9fad30cd252a76047c23491e57863ded86bf9a61b38cad8f4fd"}]}