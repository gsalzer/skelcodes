{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n// SafeMath Taken From FirstBlood\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n}\r\n\r\n// Ownership\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n    modifier onlyOwner { assert(msg.sender == owner); _; }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n// ERC20 Interface\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint _totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// ERC20Token\r\ncontract ERC20Token is ERC20, SafeMath {\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalTokens; \r\n    uint256 public contributorTokens; \r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        var _allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\n            balances[_from] = safeSub(balances[_from], _value);\r\n            allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract Wolk is ERC20Token, Owned {\r\n\r\n    // TOKEN INFO\r\n    string  public constant name = \"WOLK TOKEN\";\r\n    string  public constant symbol = \"WLK\";\r\n    uint256 public constant decimals = 18;\r\n\r\n    // RESERVE\r\n    uint256 public reserveBalance = 0; \r\n    uint8   public percentageETHReserve = 5;\r\n\r\n    // CONTRACT OWNER\r\n    address public wolkInc;\r\n\r\n    // TOKEN GENERATION CONTROL\r\n    bool    public allSaleCompleted = false;\r\n\r\n    modifier isTransferable { require(allSaleCompleted); _; }\r\n\r\n    // TOKEN GENERATION EVENTLOG\r\n    event WolkCreated(address indexed _to, uint256 _tokenCreated);\r\n    event WolkDestroyed(address indexed _from, uint256 _tokenDestroyed);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n}\r\n\r\ncontract WolkTGE is Wolk {\r\n\r\n    // TOKEN GENERATION EVENT\r\n    mapping (address => uint256) contribution;\r\n    mapping (address => bool) whitelistContributor;\r\n    \r\n    uint256 public constant tokenGenerationMin =   1 * 10**4 * 10**decimals;\r\n    uint256 public constant tokenGenerationMax = 175 * 10**5 * 10**decimals;\r\n    uint256 public start_block;\r\n    uint256 public end_time;\r\n    bool    kycRequirement = true;\r\n\r\n    // @param _startBlock\r\n    // @param _endTime\r\n    // @param _wolkinc - wolk inc tokens sent here\r\n    // @return success\r\n    // @dev Wolk Genesis Event [only accessible by Contract Owner]\r\n    function wolkGenesis(uint256 _startBlock, uint256 _endTime, address _wolkinc) onlyOwner returns (bool success){\r\n        require((totalTokens < 1) && (block.number <= _startBlock)); \r\n        start_block = _startBlock;\r\n        end_time = _endTime;\r\n        wolkInc = _wolkinc;\r\n        return true;\r\n    }\r\n    \r\n    // @param _participants\r\n    // @return success\r\n    function updateRequireKYC(bool _kycRequirement) onlyOwner returns (bool success) {\r\n        kycRequirement = _kycRequirement;\r\n        return true;\r\n    } \r\n    \r\n    // @param _participants\r\n    // @return success\r\n    function addParticipant(address[] _participants) onlyOwner returns (bool success) {\r\n        for (uint cnt = 0; cnt < _participants.length; cnt++){           \r\n            whitelistContributor[_participants[cnt]] = true;\r\n        }\r\n        return true;\r\n    } \r\n\r\n    // @param _participants\r\n    // @return success\r\n    // @dev Revoke designated contributors [only accessible by current Contract Owner]\r\n    function removeParticipant(address[] _participants) onlyOwner returns (bool success){         \r\n        for (uint cnt = 0; cnt < _participants.length; cnt++){           \r\n            whitelistContributor[_participants[cnt]] = false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // @param _participant\r\n    // @return status\r\n    // @dev return status of given address\r\n    function participantStatus(address _participant) constant returns (bool status) {\r\n        return(whitelistContributor[_participant]);\r\n    }    \r\n\r\n    // @param _participant\r\n    // @dev use tokenGenerationEvent to handle sale of WOLK\r\n    function tokenGenerationEvent(address _participant) payable external {\r\n        require( ( whitelistContributor[_participant] || whitelistContributor[msg.sender] || balances[_participant] > 0 || kycRequirement )  && !allSaleCompleted && ( block.timestamp <= end_time ) && msg.value > 0);\r\n    \r\n        uint256 rate = 1000;  // Default Rate\r\n        rate = safeDiv( 175 * 10**5 * 10**decimals, safeAdd( 875 * 10**1 * 10**decimals, safeDiv( totalTokens, 2 * 10**3)) );\r\n        if ( rate > 2000 ) rate = 2000;\r\n        if ( rate < 500 ) rate = 500;\r\n        require(block.number >= start_block) ;\r\n\r\n        uint256 tokens = safeMul(msg.value, rate);\r\n        uint256 checkedSupply = safeAdd(totalTokens, tokens);\r\n        require(checkedSupply <= tokenGenerationMax);\r\n\r\n        totalTokens = checkedSupply;\r\n        contributorTokens = safeAdd(contributorTokens, tokens);\r\n        \r\n        Transfer(address(this), _participant, tokens);\r\n        balances[_participant] = safeAdd(balances[_participant], tokens);\r\n        contribution[_participant] = safeAdd(contribution[_participant], msg.value);\r\n        WolkCreated(_participant, tokens); // logs token creation\r\n    }\r\n\r\n    function finalize() onlyOwner external {\r\n        require(!allSaleCompleted);\r\n        end_time = block.timestamp;\r\n\r\n        // 50MM Wolk allocated to Wolk Inc for development\r\n        uint256 wolkincTokens =  50 * 10**6 * 10**decimals;\r\n        balances[wolkInc] = wolkincTokens;\r\n        totalTokens = safeAdd(totalTokens, wolkincTokens);                 \r\n\r\n        WolkCreated(wolkInc, wolkincTokens); // logs token creation \r\n        allSaleCompleted = true;\r\n        reserveBalance = safeDiv(safeMul(contributorTokens, percentageETHReserve), 100000);\r\n        var withdrawalBalance = safeSub(this.balance, reserveBalance);\r\n        msg.sender.transfer(withdrawalBalance);\r\n    }\r\n\r\n    function refund() external {\r\n        require((contribution[msg.sender] > 0) && (!allSaleCompleted) && (block.timestamp > end_time)  && (totalTokens < tokenGenerationMin));\r\n        uint256 tokenBalance = balances[msg.sender];\r\n        uint256 refundBalance = contribution[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        contribution[msg.sender] = 0;\r\n        totalTokens = safeSub(totalTokens, tokenBalance);\r\n        WolkDestroyed(msg.sender, tokenBalance);\r\n        LogRefund(msg.sender, refundBalance);\r\n        msg.sender.transfer(refundBalance); \r\n    }\r\n\r\n    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) onlyOwner returns (bool success) {\r\n        return ERC20(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}\r\n\r\n// Taken from https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/BancorFormula.sol\r\ncontract IBancorFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\r\n}\r\n\r\ncontract WolkExchange is  WolkTGE {\r\n    address public exchangeFormula;\r\n    bool    public isPurchasePossible = false;\r\n    bool    public isSellPossible = false;\r\n\r\n    modifier isPurchasable { require(isPurchasePossible && allSaleCompleted); _; }\r\n    modifier isSellable { require(isSellPossible && allSaleCompleted); _; }\r\n    \r\n    // @param  _newExchangeformula\r\n    // @return success\r\n    // @dev Set the bancor formula to use -- only Wolk Inc can set this\r\n    function setExchangeFormula(address _newExchangeformula) onlyOwner returns (bool success){\r\n        require(sellWolkEstimate(10**decimals, _newExchangeformula) > 0);\r\n        require(purchaseWolkEstimate(10**decimals, _newExchangeformula) > 0);\r\n        isPurchasePossible = false;\r\n        isSellPossible = false;\r\n        exchangeFormula = _newExchangeformula;\r\n        return true;\r\n    }\r\n\r\n    // @param  _newReserveRatio\r\n    // @return success\r\n    // @dev Set the reserve ratio in case of emergency -- only Wolk Inc can set this\r\n    function updateReserveRatio(uint8 _newReserveRatio) onlyOwner returns (bool success) {\r\n        require(allSaleCompleted && ( _newReserveRatio > 1 ) && ( _newReserveRatio < 20 ) );\r\n        percentageETHReserve = _newReserveRatio;\r\n        return true;\r\n    }\r\n\r\n    // @param  _isRunning\r\n    // @return success\r\n    // @dev updating isPurchasePossible -- only Wolk Inc can set this\r\n    function updatePurchasePossible(bool _isRunning) onlyOwner returns (bool success){\r\n        if (_isRunning){\r\n            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);\r\n            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);   \r\n        }\r\n        isPurchasePossible = _isRunning;\r\n        return true;\r\n    }\r\n\r\n    // @param  _isRunning\r\n    // @return success\r\n    // @dev updating isSellPossible -- only Wolk Inc can set this\r\n    function updateSellPossible(bool _isRunning) onlyOwner returns (bool success){\r\n        if (_isRunning){\r\n            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);\r\n            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);   \r\n        }\r\n        isSellPossible = _isRunning;\r\n        return true;\r\n    }\r\n\r\n    function sellWolkEstimate(uint256 _wolkAmountest, address _formula) internal returns(uint256) {\r\n        uint256 ethReceivable =  IBancorFormula(_formula).calculateSaleReturn(contributorTokens, reserveBalance, percentageETHReserve, _wolkAmountest);\r\n        return ethReceivable;\r\n    }\r\n    \r\n    function purchaseWolkEstimate(uint256 _ethAmountest, address _formula) internal returns(uint256) {\r\n        uint256 wolkReceivable = IBancorFormula(_formula).calculatePurchaseReturn(contributorTokens, reserveBalance, percentageETHReserve, _ethAmountest);\r\n        return wolkReceivable;\r\n    }\r\n    \r\n    // @param _wolkAmount\r\n    // @return ethReceivable\r\n    // @dev send Wolk into contract in exchange for eth, at an exchange rate based on the Bancor Protocol derivation and decrease totalSupply accordingly\r\n    function sellWolk(uint256 _wolkAmount) isSellable() returns(uint256) {\r\n        require((balances[msg.sender] >= _wolkAmount));\r\n        uint256 ethReceivable = sellWolkEstimate(_wolkAmount,exchangeFormula);\r\n        require(this.balance > ethReceivable);\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\r\n        contributorTokens = safeSub(contributorTokens, _wolkAmount);\r\n        totalTokens = safeSub(totalTokens, _wolkAmount);\r\n        reserveBalance = safeSub(this.balance, ethReceivable);\r\n        WolkDestroyed(msg.sender, _wolkAmount);\r\n        Transfer(msg.sender, 0x00000000000000000000, _wolkAmount);\r\n        msg.sender.transfer(ethReceivable);\r\n        return ethReceivable;     \r\n    }\r\n\r\n    // @return wolkReceivable    \r\n    // @dev send eth into contract in exchange for Wolk tokens, at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly\r\n    function purchaseWolk(address _buyer) isPurchasable() payable returns(uint256){\r\n        require(msg.value > 0);\r\n        uint256 wolkReceivable = purchaseWolkEstimate(msg.value, exchangeFormula);\r\n        require(wolkReceivable > 0);\r\n\r\n        contributorTokens = safeAdd(contributorTokens, wolkReceivable);\r\n        totalTokens = safeAdd(totalTokens, wolkReceivable);\r\n        balances[_buyer] = safeAdd(balances[_buyer], wolkReceivable);\r\n        reserveBalance = safeAdd(reserveBalance, msg.value);\r\n        WolkCreated(_buyer, wolkReceivable);\r\n        Transfer(address(this),_buyer,wolkReceivable);\r\n        return wolkReceivable;\r\n    }\r\n\r\n    // @dev  fallback function for purchase\r\n    // @note Automatically fallback to tokenGenerationEvent before sale is completed. After the token generation event, fallback to purchaseWolk. Liquidity exchange will be enabled through updateExchangeStatus  \r\n    function () payable {\r\n        require(msg.value > 0);\r\n        if(!allSaleCompleted){\r\n            this.tokenGenerationEvent.value(msg.value)(msg.sender);\r\n        } else if ( block.timestamp >= end_time ){\r\n            this.purchaseWolk.value(msg.value)(msg.sender);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_wolkAmount\",\"type\":\"uint256\"}],\"name\":\"sellWolk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newExchangeformula\",\"type\":\"address\"}],\"name\":\"setExchangeFormula\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeFormula\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"purchaseWolk\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSellPossible\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kycRequirement\",\"type\":\"bool\"}],\"name\":\"updateRequireKYC\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGenerationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPurchasePossible\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentageETHReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_wolkinc\",\"type\":\"address\"}],\"name\":\"wolkGenesis\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributorTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"participantStatus\",\"outputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participants\",\"type\":\"address[]\"}],\"name\":\"addParticipant\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isRunning\",\"type\":\"bool\"}],\"name\":\"updateSellPossible\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGenerationMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allSaleCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wolkInc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isRunning\",\"type\":\"bool\"}],\"name\":\"updatePurchasePossible\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newReserveRatio\",\"type\":\"uint8\"}],\"name\":\"updateReserveRatio\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participants\",\"type\":\"address[]\"}],\"name\":\"removeParticipant\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"tokenGenerationEvent\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenCreated\",\"type\":\"uint256\"}],\"name\":\"WolkCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenDestroyed\",\"type\":\"uint256\"}],\"name\":\"WolkDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"WolkExchange","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9aaada50c1671511e7d4a6f65fcfba9395b602433a033c0d707bfb0dbd61a650"}]}