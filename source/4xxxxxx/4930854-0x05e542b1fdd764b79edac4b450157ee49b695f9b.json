{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/*\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\ncontract Controlled {\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() public { controller = msg.sender;}\r\n\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\ncontract TokenController {\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    function onApprove(address _owner, address _spender, uint _amount) public\r\n        returns(bool);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\r\n}\r\n\r\ncontract ERC223ReceivingContract {\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\ncontract SignalToken is Controlled {\r\n    string public name;                     // Full token name\r\n    uint8 public decimals;                  // Number of decimal places (usually 18)\r\n    string public symbol;                   // Token ticker symbol\r\n    string public version = \"STV_0.1\";      // Arbitrary versioning scheme\r\n    address public peg;                     // Address of peg contract (to reject direct transfers)\r\n\r\n    struct Checkpoint {\r\n        uint128 fromBlock;\r\n        uint128 value;\r\n    }\r\n\r\n    SignalToken public parentToken;\r\n    uint public parentSnapShotBlock;\r\n    uint public creationBlock;\r\n    mapping (address => Checkpoint[]) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    Checkpoint[] totalSupplyHistory;\r\n    bool public transfersEnabled;\r\n    SignalTokenFactory public tokenFactory;\r\n\r\n    function SignalToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled,\r\n        address _peg\r\n    ) public {\r\n        tokenFactory = SignalTokenFactory(_tokenFactory);\r\n        name = _tokenName;\r\n        decimals = _decimalUnits;\r\n        symbol = _tokenSymbol;\r\n        parentToken = SignalToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n        peg = _peg;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount, bytes _data) public returns (bool success) {\r\n        require(transfersEnabled);\r\n        doTransfer(msg.sender, _to, _amount, _data);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        bytes memory empty;\r\n        require(transfersEnabled);\r\n        doTransfer(msg.sender, _to, _amount, empty);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        bytes memory empty;\r\n        if (msg.sender != controller) {\r\n            require(transfersEnabled);\r\n\r\n            if (msg.sender != peg || _to != peg) {\r\n                require(allowed[_from][msg.sender] >= _amount);\r\n                allowed[_from][msg.sender] -= _amount;\r\n            }\r\n        }\r\n        doTransfer(_from, _to, _amount, empty);\r\n        return true;\r\n    }\r\n\r\n    function doTransfer(address _from, address _to, uint _amount, bytes _data) internal {\r\n           if (_amount == 0) {\r\n               Transfer(_from, _to, _amount);    // Follow the spec (fire event when transfer 0)\r\n               return;\r\n           }\r\n\r\n           require(parentSnapShotBlock < block.number);\r\n\r\n           require((_to != 0) && (_to != address(this)));\r\n\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           require(previousBalanceFrom >= _amount);\r\n\r\n           if (isContract(controller)) {\r\n               require(TokenController(controller).onTransfer(_from, _to, _amount));\r\n           }\r\n\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           require(previousBalanceTo + _amount >= previousBalanceTo);\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           if (isContract(_to)) {\r\n               ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n               receiver.tokenFallback(_from, _amount, _data);\r\n           }\r\n\r\n           Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\r\n        require(approve(_spender, _amount));\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {\r\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\r\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled,\r\n\t\taddress _peg\r\n        ) public returns(address) {\r\n        if (_snapshotBlock == 0) {\r\n\t\t\t_snapshotBlock = block.number;\r\n\t\t}\r\n        SignalToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled,\r\n\t\t\t_peg\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n    function generateTokens(address _owner, uint _amount\r\n    ) public onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply + _amount >= curTotalSupply);\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController public returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n    function enableTransfers(bool _transfersEnabled) public onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock) {\r\n            return checkpoints[checkpoints.length-1].value;\r\n\t\t}\r\n        if (_block < checkpoints[0].fromBlock) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function () public payable {\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }\r\n\r\n    function claimTokens(address _token) public onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        SignalToken token = SignalToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n\r\n}\r\n\r\ncontract SignalTokenFactory {\r\n\tevent NewTokenFromFactory(address indexed _tokenAddress, address _factoryAddress, uint _snapshotBlock);\r\n\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled,\r\n\t\taddress _peg\r\n    ) public returns (SignalToken) {\r\n        SignalToken newToken = new SignalToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled,\r\n            _peg\r\n            );\r\n\r\n        NewTokenFromFactory(newToken, this, _snapshotBlock);\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_parentToken\",\"type\":\"address\"},{\"name\":\"_snapshotBlock\",\"type\":\"uint256\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_decimalUnits\",\"type\":\"uint8\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_transfersEnabled\",\"type\":\"bool\"},{\"name\":\"_peg\",\"type\":\"address\"}],\"name\":\"createCloneToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_factoryAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_snapshotBlock\",\"type\":\"uint256\"}],\"name\":\"NewTokenFromFactory\",\"type\":\"event\"}]","ContractName":"SignalTokenFactory","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9ed108aea0bc781d335b0d1ce4a8744a761a1111ab2dd53d51a04a2001f0fb9e"}]}