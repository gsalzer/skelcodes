{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned - Ownership model with 2 phase transfers\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n// Implements a simple ownership model with 2-phase transfer.\r\ncontract Owned {\r\n\r\n   address public owner;\r\n   address public proposedOwner;\r\n\r\n   event OwnershipTransferInitiated(address indexed _proposedOwner);\r\n   event OwnershipTransferCompleted(address indexed _newOwner);\r\n   event OwnershipTransferCanceled();\r\n\r\n\r\n   function Owned() public\r\n   {\r\n      owner = msg.sender;\r\n   }\r\n\r\n\r\n   modifier onlyOwner() {\r\n      require(isOwner(msg.sender) == true);\r\n      _;\r\n   }\r\n\r\n\r\n   function isOwner(address _address) public view returns (bool) {\r\n      return (_address == owner);\r\n   }\r\n\r\n\r\n   function initiateOwnershipTransfer(address _proposedOwner) public onlyOwner returns (bool) {\r\n      require(_proposedOwner != address(0));\r\n      require(_proposedOwner != address(this));\r\n      require(_proposedOwner != owner);\r\n\r\n      proposedOwner = _proposedOwner;\r\n\r\n      OwnershipTransferInitiated(proposedOwner);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   function cancelOwnershipTransfer() public onlyOwner returns (bool) {\r\n      if (proposedOwner == address(0)) {\r\n         return true;\r\n      }\r\n\r\n      proposedOwner = address(0);\r\n\r\n      OwnershipTransferCanceled();\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   function completeOwnershipTransfer() public returns (bool) {\r\n      require(msg.sender == proposedOwner);\r\n\r\n      owner = msg.sender;\r\n      proposedOwner = address(0);\r\n\r\n      OwnershipTransferCompleted(owner);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// OpsManaged - Implements an Owner and Ops Permission Model\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\n//\r\n// Implements a security model with owner and ops.\r\n//\r\ncontract OpsManaged is Owned {\r\n\r\n   address public opsAddress;\r\n\r\n   event OpsAddressUpdated(address indexed _newAddress);\r\n\r\n\r\n   function OpsManaged() public\r\n      Owned()\r\n   {\r\n   }\r\n\r\n\r\n   modifier onlyOwnerOrOps() {\r\n      require(isOwnerOrOps(msg.sender));\r\n      _;\r\n   }\r\n\r\n\r\n   function isOps(address _address) public view returns (bool) {\r\n      return (opsAddress != address(0) && _address == opsAddress);\r\n   }\r\n\r\n\r\n   function isOwnerOrOps(address _address) public view returns (bool) {\r\n      return (isOwner(_address) || isOps(_address));\r\n   }\r\n\r\n\r\n   function setOpsAddress(address _newOpsAddress) public onlyOwner returns (bool) {\r\n      require(_newOpsAddress != owner);\r\n      require(_newOpsAddress != address(this));\r\n\r\n      opsAddress = _newOpsAddress;\r\n\r\n      OpsAddressUpdated(opsAddress);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Math - General Math Utility Library\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary Math {\r\n\r\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      uint256 r = a + b;\r\n\r\n      require(r >= a);\r\n\r\n      return r;\r\n   }\r\n\r\n\r\n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      require(a >= b);\r\n\r\n      return a - b;\r\n   }\r\n\r\n\r\n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      uint256 r = a * b;\r\n\r\n      require(a == 0 || r / a == b);\r\n\r\n      return r;\r\n   }\r\n\r\n\r\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      return a / b;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20Interface - Standard ERC20 Interface Definition\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n// Based on the final ERC20 specification at:\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n\r\n   event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n   function name() public view returns (string);\r\n   function symbol() public view returns (string);\r\n   function decimals() public view returns (uint8);\r\n   function totalSupply() public view returns (uint256);\r\n\r\n   function balanceOf(address _owner) public view returns (uint256 balance);\r\n   function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n   function transfer(address _to, uint256 _value) public returns (bool success);\r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n   function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20Token - Standard ERC20 Implementation\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ncontract ERC20Token is ERC20Interface {\r\n\r\n   using Math for uint256;\r\n\r\n   string  private tokenName;\r\n   string  private tokenSymbol;\r\n   uint8   private tokenDecimals;\r\n   uint256 internal tokenTotalSupply;\r\n\r\n   mapping(address => uint256) internal balances;\r\n   mapping(address => mapping (address => uint256)) allowed;\r\n\r\n\r\n   function ERC20Token(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, address _initialTokenHolder) public {\r\n      tokenName = _name;\r\n      tokenSymbol = _symbol;\r\n      tokenDecimals = _decimals;\r\n      tokenTotalSupply = _totalSupply;\r\n\r\n      // The initial balance of tokens is assigned to the given token holder address.\r\n      balances[_initialTokenHolder] = _totalSupply;\r\n\r\n      // Per EIP20, the constructor should fire a Transfer event if tokens are assigned to an account.\r\n      Transfer(0x0, _initialTokenHolder, _totalSupply);\r\n   }\r\n\r\n\r\n   function name() public view returns (string) {\r\n      return tokenName;\r\n   }\r\n\r\n\r\n   function symbol() public view returns (string) {\r\n      return tokenSymbol;\r\n   }\r\n\r\n\r\n   function decimals() public view returns (uint8) {\r\n      return tokenDecimals;\r\n   }\r\n\r\n\r\n   function totalSupply() public view returns (uint256) {\r\n      return tokenTotalSupply;\r\n   }\r\n\r\n\r\n   function balanceOf(address _owner) public view returns (uint256 balance) {\r\n      return balances[_owner];\r\n   }\r\n\r\n\r\n   function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n   }\r\n\r\n\r\n   function transfer(address _to, uint256 _value) public returns (bool success) {\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      balances[_to] = balances[_to].add(_value);\r\n\r\n      Transfer(msg.sender, _to, _value);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n      balances[_from] = balances[_from].sub(_value);\r\n      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n      balances[_to] = balances[_to].add(_value);\r\n\r\n      Transfer(_from, _to, _value);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   function approve(address _spender, uint256 _value) public returns (bool success) {\r\n      allowed[msg.sender][_spender] = _value;\r\n\r\n      Approval(msg.sender, _spender, _value);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Finalizable - Basic implementation of the finalization pattern\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\ncontract Finalizable is Owned {\r\n\r\n   bool public finalized;\r\n\r\n   event Finalized();\r\n\r\n\r\n   function Finalizable() public\r\n      Owned()\r\n   {\r\n      finalized = false;\r\n   }\r\n\r\n\r\n   function finalize() public onlyOwner returns (bool) {\r\n      require(!finalized);\r\n\r\n      finalized = true;\r\n\r\n      Finalized();\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// FinalizableToken - Extension to ERC20Token with ops and finalization\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\n//\r\n// ERC20 token with the following additions:\r\n//    1. Owner/Ops Ownership\r\n//    2. Finalization\r\n//\r\ncontract FinalizableToken is ERC20Token, OpsManaged, Finalizable {\r\n\r\n   using Math for uint256;\r\n\r\n\r\n   // The constructor will assign the initial token supply to the owner (msg.sender).\r\n   function FinalizableToken(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public\r\n      ERC20Token(_name, _symbol, _decimals, _totalSupply, msg.sender)\r\n      OpsManaged()\r\n      Finalizable()\r\n   {\r\n   }\r\n\r\n\r\n   function transfer(address _to, uint256 _value) public returns (bool success) {\r\n      validateTransfer(msg.sender, _to);\r\n\r\n      return super.transfer(_to, _value);\r\n   }\r\n\r\n\r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n      validateTransfer(msg.sender, _to);\r\n\r\n      return super.transferFrom(_from, _to, _value);\r\n   }\r\n\r\n\r\n   function validateTransfer(address _sender, address _to) private view {\r\n      require(_to != address(0));\r\n\r\n      // Once the token is finalized, everybody can transfer tokens.\r\n      if (finalized) {\r\n         return;\r\n      }\r\n\r\n      if (isOwner(_to)) {\r\n         return;\r\n      }\r\n\r\n      // Before the token is finalized, only owner and ops are allowed to initiate transfers.\r\n      // This allows them to move tokens while the sale is still ongoing for example.\r\n      require(isOwnerOrOps(_sender));\r\n   }\r\n}\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// FlexibleTokenSale - Token Sale Contract\r\n// Enuma Blockchain Platform\r\n//\r\n// Copyright (c) 2017 Enuma Technologies.\r\n// https://www.enuma.io/\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\ncontract FlexibleTokenSale is Finalizable, OpsManaged {\r\n\r\n   using Math for uint256;\r\n\r\n   //\r\n   // Lifecycle\r\n   //\r\n   uint256 public startTime;\r\n   uint256 public endTime;\r\n   bool public suspended;\r\n\r\n   //\r\n   // Pricing\r\n   //\r\n   uint256 public tokensPerKEther;\r\n   uint256 public bonus;\r\n   uint256 public maxTokensPerAccount;\r\n   uint256 public contributionMin;\r\n   uint256 public tokenConversionFactor;\r\n\r\n   //\r\n   // Wallets\r\n   //\r\n   address public walletAddress;\r\n\r\n   //\r\n   // Token\r\n   //\r\n   FinalizableToken public token;\r\n\r\n   //\r\n   // Counters\r\n   //\r\n   uint256 public totalTokensSold;\r\n   uint256 public totalEtherCollected;\r\n\r\n\r\n   //\r\n   // Events\r\n   //\r\n   event Initialized();\r\n   event TokensPerKEtherUpdated(uint256 _newValue);\r\n   event MaxTokensPerAccountUpdated(uint256 _newMax);\r\n   event BonusUpdated(uint256 _newValue);\r\n   event SaleWindowUpdated(uint256 _startTime, uint256 _endTime);\r\n   event WalletAddressUpdated(address _newAddress);\r\n   event SaleSuspended();\r\n   event SaleResumed();\r\n   event TokensPurchased(address _beneficiary, uint256 _cost, uint256 _tokens);\r\n   event TokensReclaimed(uint256 _amount);\r\n\r\n\r\n   function FlexibleTokenSale(uint256 _startTime, uint256 _endTime, address _walletAddress) public\r\n      OpsManaged()\r\n   {\r\n      require(_endTime > _startTime);\r\n\r\n      require(_walletAddress != address(0));\r\n      require(_walletAddress != address(this));\r\n\r\n      walletAddress = _walletAddress;\r\n\r\n      finalized = false;\r\n      suspended = false;\r\n\r\n      startTime = _startTime;\r\n      endTime   = _endTime;\r\n\r\n      // Use some defaults config values. Classes deriving from FlexibleTokenSale\r\n      // should set their own defaults\r\n      tokensPerKEther     = 100000;\r\n      bonus               = 0;\r\n      maxTokensPerAccount = 0;\r\n      contributionMin     = 0.1 ether;\r\n\r\n      totalTokensSold     = 0;\r\n      totalEtherCollected = 0;\r\n   }\r\n\r\n\r\n   function currentTime() public constant returns (uint256) {\r\n      return now;\r\n   }\r\n\r\n\r\n   // Initialize should be called by the owner as part of the deployment + setup phase.\r\n   // It will associate the sale contract with the token contract and perform basic checks.\r\n   function initialize(FinalizableToken _token) external onlyOwner returns(bool) {\r\n      require(address(token) == address(0));\r\n      require(address(_token) != address(0));\r\n      require(address(_token) != address(this));\r\n      require(address(_token) != address(walletAddress));\r\n      require(isOwnerOrOps(address(_token)) == false);\r\n\r\n      token = _token;\r\n\r\n      // This factor is used when converting cost <-> tokens.\r\n      // 18 is because of the ETH -> Wei conversion.\r\n      // 3 because prices are in K ETH instead of just ETH.\r\n      // 4 because bonuses are expressed as 0 - 10000 for 0.00% - 100.00% (with 2 decimals).\r\n      tokenConversionFactor = 10**(uint256(18).sub(_token.decimals()).add(3).add(4));\r\n      require(tokenConversionFactor > 0);\r\n\r\n      Initialized();\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   //\r\n   // Owner Configuation\r\n   //\r\n\r\n   // Allows the owner to change the wallet address which is used for collecting\r\n   // ether received during the token sale.\r\n   function setWalletAddress(address _walletAddress) external onlyOwner returns(bool) {\r\n      require(_walletAddress != address(0));\r\n      require(_walletAddress != address(this));\r\n      require(_walletAddress != address(token));\r\n      require(isOwnerOrOps(_walletAddress) == false);\r\n\r\n      walletAddress = _walletAddress;\r\n\r\n      WalletAddressUpdated(_walletAddress);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to set an optional limit on the amount of tokens that can be purchased\r\n   // by a contributor. It can also be set to 0 to remove limit.\r\n   function setMaxTokensPerAccount(uint256 _maxTokens) external onlyOwner returns(bool) {\r\n\r\n      maxTokensPerAccount = _maxTokens;\r\n\r\n      MaxTokensPerAccountUpdated(_maxTokens);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to specify the conversion rate for ETH -> tokens.\r\n   // For example, passing 1,000,000 would mean that 1 ETH would purchase 1000 tokens.\r\n   function setTokensPerKEther(uint256 _tokensPerKEther) external onlyOwner returns(bool) {\r\n      require(_tokensPerKEther > 0);\r\n\r\n      tokensPerKEther = _tokensPerKEther;\r\n\r\n      TokensPerKEtherUpdated(_tokensPerKEther);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to set a bonus to apply to all purchases.\r\n   // For example, setting it to 2000 means that instead of receiving 200 tokens,\r\n   // for a given price, contributors would receive 240 tokens (20.00% bonus).\r\n   function setBonus(uint256 _bonus) external onlyOwner returns(bool) {\r\n      require(_bonus <= 10000);\r\n\r\n      bonus = _bonus;\r\n\r\n      BonusUpdated(_bonus);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to set a sale window which will allow the sale (aka buyTokens) to\r\n   // receive contributions between _startTime and _endTime. Once _endTime is reached,\r\n   // the sale contract will automatically stop accepting incoming contributions.\r\n   function setSaleWindow(uint256 _startTime, uint256 _endTime) external onlyOwner returns(bool) {\r\n      require(_startTime > 0);\r\n      require(_endTime > _startTime);\r\n\r\n      startTime = _startTime;\r\n      endTime   = _endTime;\r\n\r\n      SaleWindowUpdated(_startTime, _endTime);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to suspend the sale until it is manually resumed at a later time.\r\n   function suspend() external onlyOwner returns(bool) {\r\n      if (suspended == true) {\r\n          return false;\r\n      }\r\n\r\n      suspended = true;\r\n\r\n      SaleSuspended();\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner to resume the sale.\r\n   function resume() external onlyOwner returns(bool) {\r\n      if (suspended == false) {\r\n          return false;\r\n      }\r\n\r\n      suspended = false;\r\n\r\n      SaleResumed();\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   //\r\n   // Contributions\r\n   //\r\n\r\n   // Default payable function which can be used to purchase tokens.\r\n   function () payable public {\r\n      buyTokens(msg.sender);\r\n   }\r\n\r\n\r\n   // Allows the caller to purchase tokens for a specific beneficiary (proxy purchase).\r\n   function buyTokens(address _beneficiary) public payable returns (uint256) {\r\n      return buyTokensInternal(_beneficiary, bonus);\r\n   }\r\n\r\n\r\n   function buyTokensInternal(address _beneficiary, uint256 _bonus) internal returns (uint256) {\r\n      require(!finalized);\r\n      require(!suspended);\r\n      require(currentTime() >= startTime);\r\n      require(currentTime() <= endTime);\r\n      require(msg.value >= contributionMin);\r\n      require(_beneficiary != address(0));\r\n      require(_beneficiary != address(this));\r\n      require(_beneficiary != address(token));\r\n\r\n      // We don't want to allow the wallet collecting ETH to\r\n      // directly be used to purchase tokens.\r\n      require(msg.sender != address(walletAddress));\r\n\r\n      // Check how many tokens are still available for sale.\r\n      uint256 saleBalance = token.balanceOf(address(this));\r\n      require(saleBalance > 0);\r\n\r\n      // Calculate how many tokens the contributor could purchase based on ETH received.\r\n      uint256 tokens = msg.value.mul(tokensPerKEther).mul(_bonus.add(10000)).div(tokenConversionFactor);\r\n      require(tokens > 0);\r\n\r\n      uint256 cost = msg.value;\r\n      uint256 refund = 0;\r\n\r\n      // Calculate what is the maximum amount of tokens that the contributor\r\n      // should be allowed to purchase\r\n      uint256 maxTokens = saleBalance;\r\n\r\n      if (maxTokensPerAccount > 0) {\r\n         // There is a maximum amount of tokens per account in place.\r\n         // Check if the user already hit that limit.\r\n         uint256 userBalance = getUserTokenBalance(_beneficiary);\r\n         require(userBalance < maxTokensPerAccount);\r\n\r\n         uint256 quotaBalance = maxTokensPerAccount.sub(userBalance);\r\n\r\n         if (quotaBalance < saleBalance) {\r\n            maxTokens = quotaBalance;\r\n         }\r\n      }\r\n\r\n      require(maxTokens > 0);\r\n\r\n      if (tokens > maxTokens) {\r\n         // The contributor sent more ETH than allowed to purchase.\r\n         // Limit the amount of tokens that they can purchase in this transaction.\r\n         tokens = maxTokens;\r\n\r\n         // Calculate the actual cost for that new amount of tokens.\r\n         cost = tokens.mul(tokenConversionFactor).div(tokensPerKEther.mul(_bonus.add(10000)));\r\n\r\n         if (msg.value > cost) {\r\n            // If the contributor sent more ETH than needed to buy the tokens,\r\n            // the balance should be refunded.\r\n            refund = msg.value.sub(cost);\r\n         }\r\n      }\r\n\r\n      // This is the actual amount of ETH that can be sent to the wallet.\r\n      uint256 contribution = msg.value.sub(refund);\r\n      walletAddress.transfer(contribution);\r\n\r\n      // Update our stats counters.\r\n      totalTokensSold     = totalTokensSold.add(tokens);\r\n      totalEtherCollected = totalEtherCollected.add(contribution);\r\n\r\n      // Transfer tokens to the beneficiary.\r\n      require(token.transfer(_beneficiary, tokens));\r\n\r\n      // Issue a refund for the excess ETH, as needed.\r\n      if (refund > 0) {\r\n         msg.sender.transfer(refund);\r\n      }\r\n\r\n      TokensPurchased(_beneficiary, cost, tokens);\r\n\r\n      return tokens;\r\n   }\r\n\r\n\r\n   // Returns the number of tokens that the user has purchased. Will be checked against the\r\n   // maximum allowed. Can be overriden in a sub class to change the calculations.\r\n   function getUserTokenBalance(address _beneficiary) internal view returns (uint256) {\r\n      return token.balanceOf(_beneficiary);\r\n   }\r\n\r\n\r\n   // Allows the owner to take back the tokens that are assigned to the sale contract.\r\n   function reclaimTokens() external onlyOwner returns (bool) {\r\n      uint256 tokens = token.balanceOf(address(this));\r\n\r\n      if (tokens == 0) {\r\n         return false;\r\n      }\r\n\r\n      address tokenOwner = token.owner();\r\n      require(tokenOwner != address(0));\r\n\r\n      require(token.transfer(tokenOwner, tokens));\r\n\r\n      TokensReclaimed(tokens);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BluzelleTokenConfig - Token Contract Configuration\r\n//\r\n// Copyright (c) 2017 Bluzelle Networks Pte Ltd.\r\n// http://www.bluzelle.com/\r\n//\r\n// The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ncontract BluzelleTokenConfig {\r\n\r\n    string  public constant TOKEN_SYMBOL      = \"BLZ\";\r\n    string  public constant TOKEN_NAME        = \"Bluzelle Token\";\r\n    uint8   public constant TOKEN_DECIMALS    = 18;\r\n\r\n    uint256 public constant DECIMALSFACTOR    = 10**uint256(TOKEN_DECIMALS);\r\n    uint256 public constant TOKEN_TOTALSUPPLY = 500000000 * DECIMALSFACTOR;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BluzelleTokenSaleConfig - Token Sale Configuration\r\n//\r\n// Copyright (c) 2017 Bluzelle Networks Pte Ltd.\r\n// http://www.bluzelle.com/\r\n//\r\n// The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\ncontract BluzelleTokenSaleConfig is BluzelleTokenConfig {\r\n\r\n    //\r\n    // Time\r\n    //\r\n    uint256 public constant INITIAL_STARTTIME      = 1516240800; // 2018-01-18, 02:00:00 UTC\r\n    uint256 public constant INITIAL_ENDTIME        = 1517536800; // 2018-02-02, 02:00:00 UTC\r\n    uint256 public constant INITIAL_STAGE          = 1;\r\n\r\n\r\n    //\r\n    // Purchases\r\n    //\r\n\r\n    // Minimum amount of ETH that can be used for purchase.\r\n    uint256 public constant CONTRIBUTION_MIN      = 0.1 ether;\r\n\r\n    // Price of tokens, based on the 1 ETH = 1700 BLZ conversion ratio.\r\n    uint256 public constant TOKENS_PER_KETHER     = 1700000;\r\n\r\n    // Amount of bonus applied to the sale. 2000 = 20.00% bonus, 750 = 7.50% bonus, 0 = no bonus.\r\n    uint256 public constant BONUS                 = 0;\r\n\r\n    // Maximum amount of tokens that can be purchased for each account.\r\n    uint256 public constant TOKENS_ACCOUNT_MAX    = 17000 * DECIMALSFACTOR;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BluzelleToken - ERC20 Compatible Token\r\n//\r\n// Copyright (c) 2017 Bluzelle Networks Pte Ltd.\r\n// http://www.bluzelle.com/\r\n//\r\n// The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// The Bluzelle token is a standard ERC20 token with the addition of a few\r\n// concepts such as:\r\n//\r\n// 1. Finalization\r\n// Tokens can only be transfered by contributors after the contract has\r\n// been finalized.\r\n//\r\n// 2. Ops Managed Model\r\n// In addition to owner, there is a ops role which is used during the sale,\r\n// by the sale contract, in order to transfer tokens.\r\n// ----------------------------------------------------------------------------\r\ncontract BluzelleToken is FinalizableToken, BluzelleTokenConfig {\r\n\r\n\r\n   event TokensReclaimed(uint256 _amount);\r\n\r\n\r\n   function BluzelleToken() public\r\n      FinalizableToken(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS, TOKEN_TOTALSUPPLY)\r\n   {\r\n   }\r\n\r\n\r\n   // Allows the owner to reclaim tokens that have been sent to the token address itself.\r\n   function reclaimTokens() public onlyOwner returns (bool) {\r\n\r\n      address account = address(this);\r\n      uint256 amount  = balanceOf(account);\r\n\r\n      if (amount == 0) {\r\n         return false;\r\n      }\r\n\r\n      balances[account] = balances[account].sub(amount);\r\n      balances[owner] = balances[owner].add(amount);\r\n\r\n      Transfer(account, owner, amount);\r\n\r\n      TokensReclaimed(amount);\r\n\r\n      return true;\r\n   }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BluzelleTokenSale - Token Sale Contract\r\n//\r\n// Copyright (c) 2017 Bluzelle Networks Pte Ltd.\r\n// http://www.bluzelle.com/\r\n//\r\n// The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n\r\ncontract BluzelleTokenSale is FlexibleTokenSale, BluzelleTokenSaleConfig {\r\n\r\n   //\r\n   // Whitelist\r\n   //\r\n\r\n   // This is the stage or whitelist group that is currently in effect.\r\n   // Everybody that's been whitelisted for earlier stages should be able to\r\n   // contribute in the current stage.\r\n   uint256 public currentStage;\r\n\r\n   // Keeps track of the amount of bonus to apply for a given stage. If set\r\n   // to 0, the base class bonus will be used.\r\n   mapping(uint256 => uint256) public stageBonus;\r\n\r\n   // Keeps track of the amount of tokens that a specific account has received.\r\n   mapping(address => uint256) public accountTokensPurchased;\r\n\r\n   // This a mapping of address -> stage that they are allowed to participate in.\r\n   // For example, if someone has been whitelisted for stage 2, they will be able\r\n   // to participate for stages 2 and above but they would not be able to participate\r\n   // in stage 1. A stage value of 0 means that the participant is not whitelisted.\r\n   mapping(address => uint256) public whitelist;\r\n\r\n\r\n   //\r\n   // Events\r\n   //\r\n   event CurrentStageUpdated(uint256 _newStage);\r\n   event StageBonusUpdated(uint256 _stage, uint256 _bonus);\r\n   event WhitelistedStatusUpdated(address indexed _address, uint256 _stage);\r\n\r\n\r\n   function BluzelleTokenSale(address wallet) public\r\n      FlexibleTokenSale(INITIAL_STARTTIME, INITIAL_ENDTIME, wallet)\r\n   {\r\n      currentStage        = INITIAL_STAGE;\r\n      tokensPerKEther     = TOKENS_PER_KETHER;\r\n      bonus               = BONUS;\r\n      maxTokensPerAccount = TOKENS_ACCOUNT_MAX;\r\n      contributionMin     = CONTRIBUTION_MIN;\r\n   }\r\n\r\n\r\n   // Allows the admin to determine what is the current stage for\r\n   // the sale. It can only move forward.\r\n   function setCurrentStage(uint256 _stage) public onlyOwner returns(bool) {\r\n      require(_stage > 0);\r\n\r\n      if (currentStage == _stage) {\r\n         return false;\r\n      }\r\n\r\n      currentStage = _stage;\r\n\r\n      CurrentStageUpdated(_stage);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the admin to set a bonus amount to apply for a specific stage.\r\n   function setStageBonus(uint256 _stage, uint256 _bonus) public onlyOwner returns(bool) {\r\n      require(_stage > 0);\r\n      require(_bonus <= 10000);\r\n\r\n      if (stageBonus[_stage] == _bonus) {\r\n         // Nothing to change.\r\n         return false;\r\n      }\r\n\r\n      stageBonus[_stage] = _bonus;\r\n\r\n      StageBonusUpdated(_stage, _bonus);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner or ops to add/remove people from the whitelist.\r\n   function setWhitelistedStatus(address _address, uint256 _stage) public onlyOwnerOrOps returns (bool) {\r\n      return setWhitelistedStatusInternal(_address, _stage);\r\n   }\r\n\r\n\r\n   function setWhitelistedStatusInternal(address _address, uint256 _stage) private returns (bool) {\r\n      require(_address != address(0));\r\n      require(_address != address(this));\r\n      require(_address != walletAddress);\r\n\r\n      whitelist[_address] = _stage;\r\n\r\n      WhitelistedStatusUpdated(_address, _stage);\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // Allows the owner or ops to add/remove people from the whitelist, in batches. This makes\r\n   // it easier/cheaper/faster to upload whitelist data in bulk. Note that the function is using an\r\n   // unbounded loop so the call should take care to not exceed the tx gas limit or block gas limit.\r\n   function setWhitelistedBatch(address[] _addresses, uint256 _stage) public onlyOwnerOrOps returns (bool) {\r\n      require(_addresses.length > 0);\r\n\r\n      for (uint256 i = 0; i < _addresses.length; i++) {\r\n         require(setWhitelistedStatusInternal(_addresses[i], _stage));\r\n      }\r\n\r\n      return true;\r\n   }\r\n\r\n\r\n   // This is an extension to the buyToken function in FlexibleTokenSale which also takes\r\n   // care of checking contributors against the whitelist. Since buyTokens supports proxy payments\r\n   // we check that both the sender and the beneficiary have been whitelisted.\r\n   function buyTokensInternal(address _beneficiary, uint256 _bonus) internal returns (uint256) {\r\n      require(whitelist[msg.sender] > 0);\r\n      require(whitelist[_beneficiary] > 0);\r\n      require(currentStage >= whitelist[msg.sender]);\r\n\r\n      uint256 _beneficiaryStage = whitelist[_beneficiary];\r\n      require(currentStage >= _beneficiaryStage);\r\n\r\n      uint256 applicableBonus = stageBonus[_beneficiaryStage];\r\n      if (applicableBonus == 0) {\r\n         applicableBonus = _bonus;\r\n      }\r\n\r\n      uint256 tokensPurchased = super.buyTokensInternal(_beneficiary, applicableBonus);\r\n\r\n      accountTokensPurchased[_beneficiary] = accountTokensPurchased[_beneficiary].add(tokensPurchased);\r\n\r\n      return tokensPurchased;\r\n   }\r\n\r\n\r\n   // Returns the number of tokens that the user has purchased. We keep a separate balance from\r\n   // the token contract in case we'd like to do additional sales with new purchase limits. This behavior\r\n   // is different from the base implementation which just checks the token balance from the token\r\n   // contract directly.\r\n   function getUserTokenBalance(address _beneficiary) internal view returns (uint256) {\r\n      return accountTokensPurchased[_beneficiary];\r\n   }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"setBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensPerKEther\",\"type\":\"uint256\"}],\"name\":\"setTokensPerKEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stageBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_ENDTIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint256\"}],\"name\":\"setCurrentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_stage\",\"type\":\"uint256\"}],\"name\":\"setWhitelistedBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenConversionFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_ACCOUNT_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_STARTTIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setSaleWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"suspended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOpsAddress\",\"type\":\"address\"}],\"name\":\"setOpsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_TOTALSUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALSFACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokensPerAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerKEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_stage\",\"type\":\"uint256\"}],\"name\":\"setWhitelistedStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"setWalletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwnerOrOps\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint256\"},{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"setStageBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRIBUTION_MIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"initiateOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_STAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountTokensPurchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"suspend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"completeOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOps\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxTokens\",\"type\":\"uint256\"}],\"name\":\"setMaxTokensPerAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_PER_KETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newStage\",\"type\":\"uint256\"}],\"name\":\"CurrentStageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_stage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"StageBonusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_stage\",\"type\":\"uint256\"}],\"name\":\"WhitelistedStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"TokensPerKEtherUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newMax\",\"type\":\"uint256\"}],\"name\":\"MaxTokensPerAccountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"BonusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"SaleWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"WalletAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleSuspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_cost\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"OpsAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipTransferCanceled\",\"type\":\"event\"}]","ContractName":"BluzelleTokenSale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e9638c2d07eac8774d46b85e47cf53f52d60239f","Library":"","SwarmSource":"bzzr://c8dbbe176deeed0a10c085b277755263dd5fa9e252d70dd1a0720fb7a5a0784d"}]}