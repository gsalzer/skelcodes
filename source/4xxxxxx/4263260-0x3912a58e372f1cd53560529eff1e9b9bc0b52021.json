{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n/* \r\n* From OpenZeppelin project: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n*/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool);\r\n  function transferFrom(address from, address to, uint value) returns (bool);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20 {\r\n\r\n  using SafeMath for uint;\r\n\r\n  /* Actual balances of token holders */\r\n  mapping (address => uint) balances;\r\n\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  /* Interface declaration */\r\n  function isToken() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http://vessenes.com/the-erc20-short-address-attack-explained/\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n    assert(msg.data.length >= size + 4);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool) {\r\n    require(balances[msg.sender] >= _value);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool) {\r\n    require(balances[_from] >= _value && allowed[_from][_to] >= _value);\r\n    allowed[_from][_to] = allowed[_from][_to].sub(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n  \r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner = msg.sender;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract EmeraldToken is StandardToken, Ownable {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals;\r\n\r\n  mapping (address => bool) public producers;\r\n\r\n  bool public released = false;\r\n\r\n  /*\r\n  * Only producer allowed\r\n  */\r\n  modifier onlyProducer() {\r\n    require(producers[msg.sender] == true);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Limit token transfer until the distribution is over.\r\n   * Owner can transfer tokens anytime\r\n   */\r\n  modifier canTransfer(address _sender) {\r\n    if (_sender != owner)\r\n      require(released);\r\n    _;\r\n  }\r\n\r\n  modifier inProduction() {\r\n    require(!released);\r\n    _;\r\n  }\r\n\r\n  function EmeraldToken(string _name, string _symbol, uint _decimals) {\r\n    require(_decimals > 0);\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n\r\n    // Make owner a producer of Emeralds\r\n    producers[msg.sender] = true;\r\n  }\r\n\r\n  /*\r\n  * Sets a producer's status\r\n  * Distribution contract can be a producer\r\n  */\r\n  function setProducer(address _addr, bool _status) onlyOwner {\r\n    producers[_addr] = _status;\r\n  }\r\n\r\n  /*\r\n  * Creates new Emeralds\r\n  */\r\n  function produceEmeralds(address _receiver, uint _amount) onlyProducer inProduction {\r\n    balances[_receiver] = balances[_receiver].add(_amount);\r\n    totalSupply = totalSupply.add(_amount);\r\n    Transfer(0, _receiver, _amount);\r\n  }\r\n\r\n  /**\r\n   * One way function to release the tokens to the wild. No more tokens can be created.\r\n   */\r\n  function releaseTokenTransfer() onlyOwner {\r\n    released = true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool) {\r\n    // Call StandardToken.transfer()\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool) {\r\n    // Call StandardToken.transferForm()\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Ownable {\r\n  bool public halted = false;\r\n\r\n  modifier stopInEmergency {\r\n    require(!halted);\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    require(halted);\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n* The main contract for the Token Distribution Event\r\n*/\r\n\r\ncontract TokenDistribution is Haltable {\r\n\r\n  using SafeMath for uint;\r\n\r\n  address public wallet;                // an account for withdrow\r\n  uint public presaleStart;             // presale start time\r\n  uint public start;                    // distribution start time\r\n  uint public end;                      // distribution end time\r\n  EmeraldToken public token;            // token contract address\r\n  uint public weiGoal;                  // minimum wei amount we want to get during token distribution\r\n  uint public weiPresaleMax;            // maximum wei amount we can get during presale\r\n  uint public contributorsCount = 0;    // number of contributors\r\n  uint public weiTotal = 0;             // total wei amount we have received\r\n  uint public weiDistributed = 0;       // total wei amount we have received in Distribution state\r\n  uint public maxCap;                   // maximum token supply\r\n  uint public tokensSold = 0;           // tokens sold\r\n  uint public loadedRefund = 0;         // wei amount for refund\r\n  uint public weiRefunded = 0;          // wei amount refunded\r\n  mapping (address => uint) public contributors;        // list of contributors\r\n  mapping (address => uint) public presale;             // list of presale contributors\r\n\r\n  enum States {Preparing, Presale, Waiting, Distribution, Success, Failure, Refunding}\r\n\r\n  event Contributed(address _contributor, uint _weiAmount, uint _tokenAmount);\r\n  event GoalReached(uint _weiAmount);\r\n  event LoadedRefund(address _address, uint _loadedRefund);\r\n  event Refund(address _contributor, uint _weiAmount);\r\n\r\n  modifier inState(States _state) {\r\n    require(getState() == _state);\r\n    _;\r\n  }\r\n\r\n  function TokenDistribution(EmeraldToken _token, address _wallet, uint _presaleStart, uint _start, uint _end, \r\n    uint _ethPresaleMaxNoDecimals, uint _ethGoalNoDecimals, uint _maxTokenCapNoDecimals) {\r\n    \r\n    require(_token != address(0) && _wallet != address(0) && _presaleStart > 0 && _start > _presaleStart && _end > _start && _ethPresaleMaxNoDecimals > 0 \r\n      && _ethGoalNoDecimals > _ethPresaleMaxNoDecimals && _maxTokenCapNoDecimals > 0);\r\n    require(_token.isToken());\r\n\r\n    token = _token;\r\n    wallet = _wallet;\r\n    presaleStart = _presaleStart;\r\n    start = _start;\r\n    end = _end;\r\n    weiPresaleMax = _ethPresaleMaxNoDecimals * 1 ether;\r\n    weiGoal = _ethGoalNoDecimals * 1 ether;\r\n    maxCap = _maxTokenCapNoDecimals * 10 ** token.decimals();\r\n  }\r\n\r\n  function() payable {\r\n    buy();\r\n  }\r\n\r\n  /*\r\n  * Contributors can make payment and receive their tokens\r\n  */\r\n  function buy() payable stopInEmergency {\r\n    require(getState() == States.Presale || getState() == States.Distribution);\r\n    require(msg.value > 0);\r\n    if (getState() == States.Presale)\r\n      presale[msg.sender] = presale[msg.sender].add(msg.value);\r\n    else {\r\n      contributors[msg.sender] = contributors[msg.sender].add(msg.value);\r\n      weiDistributed = weiDistributed.add(msg.value);\r\n    }\r\n    contributeInternal(msg.sender, msg.value, getTokenAmount(msg.value));\r\n  }\r\n\r\n  /*\r\n  * Preallocate tokens for reserve, bounties etc.\r\n  */\r\n  function preallocate(address _receiver, uint _tokenAmountNoDecimals) onlyOwner stopInEmergency {\r\n    require(getState() != States.Failure && getState() != States.Refunding && !token.released());\r\n    uint tokenAmount = _tokenAmountNoDecimals * 10 ** token.decimals();\r\n    contributeInternal(_receiver, 0, tokenAmount);\r\n  }\r\n\r\n  /*\r\n   * Allow load refunds back on the contract for the refunding.\r\n   */\r\n  function loadRefund() payable {\r\n    require(getState() == States.Failure || getState() == States.Refunding);\r\n    require(msg.value > 0);\r\n    loadedRefund = loadedRefund.add(msg.value);\r\n    LoadedRefund(msg.sender, msg.value);\r\n  }\r\n\r\n  /*\r\n  * Changes dates of token distribution event\r\n  */\r\n  function setDates(uint _presaleStart, uint _start, uint _end) onlyOwner {\r\n    require(_presaleStart > 0 && _start > _presaleStart && _end > _start);\r\n    presaleStart = _presaleStart;\r\n    start = _start;\r\n    end = _end;\r\n  }\r\n\r\n  /*\r\n  * Internal function that creates and distributes tokens\r\n  */\r\n  function contributeInternal(address _receiver, uint _weiAmount, uint _tokenAmount) internal {\r\n    require(token.totalSupply().add(_tokenAmount) <= maxCap);\r\n    token.produceEmeralds(_receiver, _tokenAmount);\r\n    if (_weiAmount > 0) \r\n      wallet.transfer(_weiAmount);\r\n    if (contributors[_receiver] == 0) contributorsCount++;\r\n    tokensSold = tokensSold.add(_tokenAmount);\r\n    weiTotal = weiTotal.add(_weiAmount);\r\n    Contributed(_receiver, _weiAmount, _tokenAmount);\r\n  }\r\n\r\n  /*\r\n   * Contributors can claim refund.\r\n   */\r\n  function refund() inState(States.Refunding) {\r\n    uint weiValue = contributors[msg.sender];\r\n    require(weiValue <= loadedRefund && weiValue <= this.balance);\r\n    msg.sender.transfer(weiValue);\r\n    contributors[msg.sender] = 0;\r\n    weiRefunded = weiRefunded.add(weiValue);\r\n    loadedRefund = loadedRefund.sub(weiValue);\r\n    Refund(msg.sender, weiValue);\r\n  }\r\n\r\n  /*\r\n  * State machine\r\n  */\r\n  function getState() constant returns (States) {\r\n    if (now < presaleStart) return States.Preparing;\r\n    if (now >= presaleStart && now < start && weiTotal < weiPresaleMax) return States.Presale;\r\n    if (now < start && weiTotal >= weiPresaleMax) return States.Waiting;\r\n    if (now >= start && now < end) return States.Distribution;\r\n    if (weiTotal >= weiGoal) return States.Success;\r\n    if (now >= end && weiTotal < weiGoal && loadedRefund == 0) return States.Failure;\r\n    if (loadedRefund > 0) return States.Refunding;\r\n  }\r\n\r\n  /*\r\n  * Calculating token price\r\n  */\r\n  function getTokenAmount(uint _weiAmount) internal constant returns (uint) {\r\n    uint rate = 1000 * 10 ** 18 / 10 ** token.decimals(); // 1000 EMR = 1 ETH\r\n    uint tokenAmount = _weiAmount * rate;\r\n    if (getState() == States.Presale)\r\n      tokenAmount *= 2;\r\n    return tokenAmount;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_presaleStart\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"setDates\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_tokenAmountNoDecimals\",\"type\":\"uint256\"}],\"name\":\"preallocate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loadedRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"loadRefund\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiPresaleMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"presale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_presaleStart\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_ethPresaleMaxNoDecimals\",\"type\":\"uint256\"},{\"name\":\"_ethGoalNoDecimals\",\"type\":\"uint256\"},{\"name\":\"_maxTokenCapNoDecimals\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Contributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_loadedRefund\",\"type\":\"uint256\"}],\"name\":\"LoadedRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"TokenDistribution","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ea3a23c53dbb15164bca835be54f6bb913333b790000000000000000000000007199aa85e124cf1a2a41c526ed6d0160b2a7eb4e0000000000000000000000000000000000000000000000000000000059b7da500000000000000000000000000000000000000000000000000000000059df6750000000000000000000000000000000000000000000000000000000005a0845d000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000c1c0000000000000000000000000000000000000000000000000000000005f5e100","Library":"","SwarmSource":"bzzr://71b0dd3836f850e3f2ccceb91aef17258334ea23e4f2abcf2fe329a7266bc0f6"}]}