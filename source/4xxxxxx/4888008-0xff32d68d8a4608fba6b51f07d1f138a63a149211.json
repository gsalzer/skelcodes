{"status":"1","message":"OK","result":[{"SourceCode":"// Copyright (c) 2017 Sweetbridge Stiftung (Sweetbridge Foundation)\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\").\r\n// You may not use this file except in compliance with the License.\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\nlibrary Math {\r\n\r\n    // standard uint256 functions\r\n    function add(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        z = x * y;\r\n        require((z == 0 && (x == 0 || y == 0)) || z >= (x > y ? x : y));\r\n    }\r\n\r\n    //division by zero is ignored and returns zero\r\n    function div(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        z = y > 0 ? x / y : 0;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    uint128 functions (h is for half)\r\n     */\r\n\r\n    function hadd(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        require((z = x * y) >= x);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        require(y > 0);\r\n        z = x / y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function hmax(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    int256 functions\r\n     */\r\n\r\n    function imin(int256 x, int256 y) pure internal returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int256 x, int256 y) pure internal returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    /*\r\n    WAD math\r\n     */\r\n\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wadd(uint128 x, uint128 y) pure internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) pure internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y / 2) / y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) pure internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n\r\n    function wmax(uint128 x, uint128 y) pure internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    /*\r\n    RAY math\r\n     */\r\n\r\n    uint128 constant RAY = 10 ** 27;\r\n\r\n    function radd(uint128 x, uint128 y) pure internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function rsub(uint128 x, uint128 y) pure internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function rmul(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\r\n    }\r\n\r\n    function rdiv(uint128 x, uint128 y) pure internal returns (uint128 z) {\r\n        z = cast((uint256(x) * RAY + y / 2) / y);\r\n    }\r\n\r\n    function rpow(uint128 x, uint64 n) pure internal returns (uint128 z) {\r\n        // This famous algorithm is called \"exponentiation by squaring\"\r\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n        //\r\n        // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n        //\r\n        // These facts are why it works:\r\n        //\r\n        //  If n is even, then x^n = (x^2)^(n/2).\r\n        //  If n is odd,  then x^n = x * x^(n-1),\r\n        //   and applying the equation for even x gives\r\n        //    x^n = x * (x^2)^((n-1) / 2).\r\n        //\r\n        //  Also, EVM division is flooring and\r\n        //    floor[(n-1) / 2] = floor[n / 2].\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmin(uint128 x, uint128 y) pure internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n\r\n    function rmax(uint128 x, uint128 y) pure internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) pure internal returns (uint128 z) {\r\n        require((z = uint128(x)) == x);\r\n    }\r\n}\r\n\r\ncontract OwnedEvents {\r\n    event LogSetOwner (address newOwner);\r\n}\r\n\r\n\r\ncontract Owned is OwnedEvents {\r\n    address public owner;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address owner_) public onlyOwner {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n}\r\n\r\ninterface SecuredWithRolesI {\r\n    function hasRole(string roleName) public view returns (bool);\r\n    function senderHasRole(string roleName) public view returns (bool);\r\n    function contractHash() public view returns (bytes32);\r\n}\r\n\r\n\r\ncontract SecuredWithRoles is Owned {\r\n    RolesI public roles;\r\n    bytes32 public contractHash;\r\n    bool public stopped = false;\r\n\r\n    function SecuredWithRoles(string contractName_, address roles_) public {\r\n        contractHash = keccak256(contractName_);\r\n        roles = RolesI(roles_);\r\n    }\r\n\r\n    modifier stoppable() {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n\r\n    modifier onlyRole(string role) {\r\n        require(senderHasRole(role));\r\n        _;\r\n    }\r\n\r\n    modifier roleOrOwner(string role) {\r\n        require(msg.sender == owner || senderHasRole(role));\r\n        _;\r\n    }\r\n\r\n    // returns true if the role has been defined for the contract\r\n    function hasRole(string roleName) public view returns (bool) {\r\n        return roles.knownRoleNames(contractHash, keccak256(roleName));\r\n    }\r\n\r\n    function senderHasRole(string roleName) public view returns (bool) {\r\n        return hasRole(roleName) && roles.roleList(contractHash, keccak256(roleName), msg.sender);\r\n    }\r\n\r\n    function stop() public roleOrOwner(\"stopper\") {\r\n        stopped = true;\r\n    }\r\n\r\n    function restart() public roleOrOwner(\"restarter\") {\r\n        stopped = false;\r\n    }\r\n\r\n    function setRolesContract(address roles_) public onlyOwner {\r\n        // it must not be possible to change the roles contract on the roles contract itself\r\n        require(this != address(roles));\r\n        roles = RolesI(roles_);\r\n    }\r\n\r\n}\r\n\r\n\r\ninterface RolesI {\r\n    function knownRoleNames(bytes32 contractHash, bytes32 nameHash) public view returns (bool);\r\n    function roleList(bytes32 contractHash, bytes32 nameHash, address member) public view returns (bool);\r\n\r\n    function addContractRole(bytes32 ctrct, string roleName) public;\r\n    function removeContractRole(bytes32 ctrct, string roleName) public;\r\n    function grantUserRole(bytes32 ctrct, string roleName, address user) public;\r\n    function revokeUserRole(bytes32 ctrct, string roleName, address user) public;\r\n}\r\n\r\n\r\ncontract RolesEvents {\r\n    event LogRoleAdded(bytes32 contractHash, string roleName);\r\n    event LogRoleRemoved(bytes32 contractHash, string roleName);\r\n    event LogRoleGranted(bytes32 contractHash, string roleName, address user);\r\n    event LogRoleRevoked(bytes32 contractHash, string roleName, address user);\r\n}\r\n\r\n\r\ncontract Roles is RolesEvents, SecuredWithRoles {\r\n    // mapping is contract -> role -> sender_address -> boolean\r\n    mapping(bytes32 => mapping (bytes32 => mapping (address => bool))) public roleList;\r\n    // the intention is\r\n    mapping (bytes32 => mapping (bytes32 => bool)) public knownRoleNames;\r\n\r\n    function Roles() SecuredWithRoles(\"RolesRepository\", this) public {}\r\n\r\n    function addContractRole(bytes32 ctrct, string roleName) public roleOrOwner(\"admin\") {\r\n        require(!knownRoleNames[ctrct][keccak256(roleName)]);\r\n        knownRoleNames[ctrct][keccak256(roleName)] = true;\r\n        LogRoleAdded(ctrct, roleName);\r\n    }\r\n\r\n    function removeContractRole(bytes32 ctrct, string roleName) public roleOrOwner(\"admin\") {\r\n        require(knownRoleNames[ctrct][keccak256(roleName)]);\r\n        delete knownRoleNames[ctrct][keccak256(roleName)];\r\n        LogRoleRemoved(ctrct, roleName);\r\n    }\r\n\r\n    function grantUserRole(bytes32 ctrct, string roleName, address user) public roleOrOwner(\"admin\") {\r\n        require(knownRoleNames[ctrct][keccak256(roleName)]);\r\n        roleList[ctrct][keccak256(roleName)][user] = true;\r\n        LogRoleGranted(ctrct, roleName, user);\r\n    }\r\n\r\n    function revokeUserRole(bytes32 ctrct, string roleName, address user) public roleOrOwner(\"admin\") {\r\n        delete roleList[ctrct][keccak256(roleName)][user];\r\n        LogRoleRevoked(ctrct, roleName, user);\r\n    }\r\n\r\n}\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Events {\r\n    event Transfer( address indexed from, address indexed to, uint256 value);\r\n    event Approval( address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() public view returns (uint256 supply);\r\n    function balanceOf( address who ) public  view returns (uint256 value);\r\n    function allowance( address owner, address spender ) public view returns (uint256 _allowance);\r\n\r\n    function transfer( address to, uint256 value) public returns (bool ok);\r\n    function transferFrom( address from, address to, uint256 value) public returns (bool ok);\r\n    function approve( address spender, uint256 value ) public returns (bool ok);\r\n\r\n}\r\n\r\ncontract TokenData is Owned {\r\n    uint256 public supply;\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public approvals;\r\n    address logic;\r\n\r\n    modifier onlyLogic {\r\n        assert(msg.sender == logic);\r\n        _;\r\n    }\r\n\r\n    function TokenData(address logic_, address owner_) public {\r\n        logic = logic_;\r\n        owner = owner_;\r\n        balances[owner] = supply;\r\n    }\r\n\r\n    function setTokenLogic(address logic_) public onlyLogic {\r\n        logic = logic_;\r\n    }\r\n\r\n    function setSupply(uint256 supply_) public onlyLogic {\r\n        supply = supply_;\r\n    }\r\n\r\n    function setBalances(address guy, uint256 balance) public onlyLogic {\r\n        balances[guy] = balance;\r\n    }\r\n\r\n    function setApprovals(address src, address guy, uint256 wad) public onlyLogic {\r\n        approvals[src][guy] = wad;\r\n    }\r\n\r\n\r\n}\r\n\r\ninterface TokenI {\r\n    function totalSupply() public view returns (uint256 supply);\r\n    function balanceOf( address who ) public  view returns (uint256 value);\r\n    function allowance( address owner, address spender ) public view returns (uint256 _allowance);\r\n\r\n    function triggerTransfer(address src, address dst, uint256 wad);\r\n    function transfer( address to, uint256 value) public returns (bool ok);\r\n    function transferFrom( address from, address to, uint256 value) public returns (bool ok);\r\n    function approve( address spender, uint256 value ) public returns (bool ok);\r\n\r\n    function mintFor(address recipient, uint256 wad) public;\r\n}\r\n\r\ninterface TokenLogicI {\r\n    // we have slightly different interface then ERC20, because\r\n    function totalSupply() public view returns (uint256 supply);\r\n    function balanceOf( address who ) public view returns (uint256 value);\r\n    function allowance( address owner, address spender ) public view returns (uint256 _allowance);\r\n    function transferFrom( address from, address to, uint256 value) public returns (bool ok);\r\n    // this two functions are different from ERC20. ERC20 assumes that msg.sender is the owner,\r\n    // but because logic contract is behind a proxy we need to add an owner parameter.\r\n    function transfer( address owner, address to, uint256 value) public returns (bool ok);\r\n    function approve( address owner, address spender, uint256 value ) public returns (bool ok);\r\n\r\n    function setToken(address token_) public;\r\n    function mintFor(address dest, uint256 wad) public;\r\n    function burn(address src, uint256 wad) public;\r\n}\r\n\r\n\r\ncontract TokenLogicEvents {\r\n    event WhiteListAddition(bytes32 listName);\r\n    event AdditionToWhiteList(bytes32 listName, address guy);\r\n    event WhiteListRemoval(bytes32 listName);\r\n    event RemovalFromWhiteList(bytes32 listName, address guy);\r\n}\r\n\r\n\r\ncontract TokenLogic is TokenLogicEvents, TokenLogicI, SecuredWithRoles {\r\n\r\n    TokenData public data;\r\n    Token public token;     // facade: Token.sol:Token\r\n\r\n    /* White lists are used to restrict who can transact with whom.\r\n     * Since we can't iterate over the mapping we need to store the keys separaterly in the\r\n     *   listNames\r\n     */\r\n    bytes32[] public listNames;\r\n    mapping (address => mapping (bytes32 => bool)) public whiteLists;\r\n    // by default there is no need for white listing addresses, anyone can transact freely\r\n    bool public freeTransfer = true;\r\n\r\n    function TokenLogic(\r\n        address token_,\r\n        address tokenData_,\r\n        address rolesContract) public SecuredWithRoles(\"TokenLogic\", rolesContract)\r\n    {\r\n        require(token_ != address(0x0));\r\n        require(rolesContract != address(0x0));\r\n\r\n        token = Token(token_);\r\n        if (tokenData_ == address(0x0)) {\r\n            data = new TokenData(this, msg.sender);\r\n        } else {\r\n            data = TokenData(tokenData_);\r\n        }\r\n    }\r\n\r\n    modifier tokenOnly {\r\n        assert(msg.sender == address(token));\r\n        _;\r\n    }\r\n\r\n    /* check that freeTransfer is true or that the owner is involved or both sender and recipient are in the same whitelist*/\r\n    modifier canTransfer(address src, address dst) {\r\n        require(freeTransfer || src == owner || dst == owner || sameWhiteList(src, dst));\r\n        _;\r\n    }\r\n\r\n    function sameWhiteList(address src, address dst) internal view returns(bool) {\r\n        for(uint8 i = 0; i < listNames.length; i++) {\r\n            bytes32 listName = listNames[i];\r\n            if(whiteLists[src][listName] && whiteLists[dst][listName]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function listNamesLen() public view returns (uint256) {\r\n        return listNames.length;\r\n    }\r\n\r\n    function listExists(bytes32 listName) public view returns (bool) {\r\n        var (, ok) = indexOf(listName);\r\n        return ok;\r\n    }\r\n\r\n    function indexOf(bytes32 listName) public view returns (uint8, bool) {\r\n        for(uint8 i = 0; i < listNames.length; i++) {\r\n            if(listNames[i] == listName) {\r\n                return (i, true);\r\n            }\r\n        }\r\n        return (0, false);\r\n    }\r\n\r\n    function replaceLogic(address newLogic) public onlyOwner {\r\n        token.setLogic(TokenLogicI(newLogic));\r\n        data.setTokenLogic(newLogic);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /* creating a removeWhiteList would be too onerous. Therefore it does not exist*/\r\n    function addWhiteList(bytes32 listName) public onlyRole(\"admin\") {\r\n        require(! listExists(listName));\r\n        require(listNames.length < 256);\r\n        listNames.push(listName);\r\n        WhiteListAddition(listName);\r\n    }\r\n\r\n    function removeWhiteList(bytes32 listName) public onlyRole(\"admin\") {\r\n        var (i, ok) = indexOf(listName);\r\n        require(ok);\r\n        if(i < listNames.length - 1) {\r\n            listNames[i] = listNames[listNames.length - 1];\r\n        }\r\n        delete listNames[listNames.length - 1];\r\n        --listNames.length;\r\n        WhiteListRemoval(listName);\r\n    }\r\n\r\n    function addToWhiteList(bytes32 listName, address guy) public onlyRole(\"userManager\") {\r\n        require(listExists(listName));\r\n\r\n        whiteLists[guy][listName] = true;\r\n        AdditionToWhiteList(listName, guy);\r\n    }\r\n\r\n    function removeFromWhiteList(bytes32 listName, address guy) public onlyRole(\"userManager\") {\r\n        require(listExists(listName));\r\n\r\n        whiteLists[guy][listName] = false;\r\n        RemovalFromWhiteList(listName, guy);\r\n    }\r\n\r\n    function setFreeTransfer(bool isFree) public onlyOwner {\r\n        freeTransfer = isFree;\r\n    }\r\n\r\n    function setToken(address token_) public onlyOwner {\r\n        token = Token(token_);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return data.supply();\r\n    }\r\n\r\n    function balanceOf(address src) public view returns (uint256) {\r\n        return data.balances(src);\r\n    }\r\n\r\n    function allowance(address src, address spender) public view returns (uint256) {\r\n        return data.approvals(src, spender);\r\n    }\r\n\r\n    function transfer(address src, address dst, uint256 wad) public tokenOnly canTransfer(src, dst)  returns (bool) {\r\n        // balance check is not needed because sub(a, b) will throw if a<b\r\n        data.setBalances(src, Math.sub(data.balances(src), wad));\r\n        data.setBalances(dst, Math.add(data.balances(dst), wad));\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 wad) public tokenOnly canTransfer(src, dst)  returns (bool) {\r\n        // balance and approval check is not needed because sub(a, b) will throw if a<b\r\n        data.setApprovals(src, dst, Math.sub(data.approvals(src, dst), wad));\r\n        data.setBalances(src, Math.sub(data.balances(src), wad));\r\n        data.setBalances(dst, Math.add(data.balances(dst), wad));\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address src, address dst, uint256 wad) public tokenOnly returns (bool) {\r\n        data.setApprovals(src, dst, wad);\r\n        return true;\r\n    }\r\n\r\n    function mintFor(address dst, uint256 wad) public tokenOnly {\r\n        data.setBalances(dst, Math.add(data.balances(dst), wad));\r\n        data.setSupply(Math.add(data.supply(), wad));\r\n    }\r\n\r\n    function burn(address src, uint256 wad) public tokenOnly {\r\n        data.setBalances(src, Math.sub(data.balances(src), wad));\r\n        data.setSupply(Math.sub(data.supply(), wad));\r\n    }\r\n}\r\n\r\ncontract TokenEvents {\r\n    event LogBurn(address indexed src, uint256 wad);\r\n    event LogMint(address indexed src, uint256 wad);\r\n    event LogLogicReplaced(address newLogic);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Contract that will work with ERC223 tokens.\r\n */\r\ninterface ERC223ReceivingContract {\r\n    /**\r\n     * @dev Standard ERC223 function that will handle incoming token transfers.\r\n     *\r\n     * @param src  Token sender address.\r\n     * @param wad  Amount of tokens.\r\n     * @param _data  Transaction metadata.\r\n     */\r\n    function tokenFallback(address src, uint wad, bytes _data) public;\r\n}\r\n\r\ncontract Token is TokenI, SecuredWithRoles, TokenEvents {\r\n    string public symbol;\r\n    string public name; // Optional token name\r\n    uint8 public decimals = 18; // standard token precision. override to customize\r\n    TokenLogicI public logic;\r\n\r\n    function Token(string name_, string symbol_, address rolesContract) public SecuredWithRoles(name_, rolesContract) {\r\n        // you can't create logic here, because this contract would be the owner.\r\n        name = name_;\r\n        symbol = symbol_;\r\n    }\r\n\r\n    modifier logicOnly {\r\n        require(address(logic) == address(0x0) || address(logic) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return logic.totalSupply();\r\n    }\r\n\r\n    function balanceOf( address who ) public view returns (uint256 value) {\r\n        return logic.balanceOf(who);\r\n    }\r\n\r\n    function allowance(address owner, address spender ) public view returns (uint256 _allowance) {\r\n        return logic.allowance(owner, spender);\r\n    }\r\n\r\n    function triggerTransfer(address src, address dst, uint256 wad) logicOnly {\r\n        Transfer(src, dst, wad);\r\n    }\r\n\r\n    function setLogic(address logic_) public logicOnly {\r\n        assert(logic_ != address(0));\r\n        logic = TokenLogicI(logic_);\r\n        LogLogicReplaced(logic);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer the specified amount of tokens to the specified address.\r\n     *      Invokes the `tokenFallback` function if the recipient is a contract.\r\n     *      The token transfer fails if the recipient is a contract\r\n     *      but does not implement the `tokenFallback` function\r\n     *      or the fallback function to receive funds.\r\n     */\r\n    function transfer(address dst, uint256 wad) public stoppable returns (bool) {\r\n        bool retVal = logic.transfer(msg.sender, dst, wad);\r\n        if (retVal) {\r\n            uint codeLength;\r\n            assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n                codeLength := extcodesize(dst)\r\n            }\r\n            if (codeLength>0) {\r\n                ERC223ReceivingContract receiver = ERC223ReceivingContract(dst);\r\n                bytes memory empty;\r\n                receiver.tokenFallback(msg.sender, wad, empty);\r\n            }\r\n\r\n            Transfer(msg.sender, dst, wad);\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 wad) public stoppable returns (bool) {\r\n        bool retVal = logic.transferFrom(src, dst, wad);\r\n        if (retVal) {\r\n            uint codeLength;\r\n            assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n                codeLength := extcodesize(dst)\r\n            }\r\n            if (codeLength>0) {\r\n                ERC223ReceivingContract receiver = ERC223ReceivingContract(dst);\r\n                bytes memory empty;\r\n                receiver.tokenFallback(src, wad, empty);\r\n            }\r\n\r\n            Transfer(src, dst, wad);\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    function approve(address guy, uint256 wad) public stoppable returns (bool) {\r\n        bool ok = logic.approve(msg.sender, guy, wad);\r\n        if (ok)\r\n            Approval(msg.sender, guy, wad);\r\n        return ok;\r\n    }\r\n\r\n    function pull(address src, uint256 wad) public stoppable returns (bool) {\r\n        return transferFrom(src, msg.sender, wad);\r\n    }\r\n\r\n    function mintFor(address recipient, uint256 wad) public stoppable onlyRole(\"minter\") {\r\n        logic.mintFor(recipient, wad);\r\n        LogMint(recipient, wad);\r\n        Transfer(address(0x0), recipient, wad);\r\n    }\r\n\r\n    function burn(uint256 wad) public stoppable {\r\n        logic.burn(msg.sender, wad);\r\n        LogBurn(msg.sender, wad);\r\n    }\r\n\r\n    function setName(string name_) public roleOrOwner(\"admin\") {\r\n        name = name_;\r\n    }\r\n}\r\n\r\ncontract SweetTokenLogic is TokenLogic {\r\n\r\n    function SweetTokenLogic(\r\n        address token_,\r\n        address tokenData_,\r\n        address rolesContract,\r\n        address[] initialWallets,\r\n        uint256[] initialBalances)\r\n    TokenLogic(token_, tokenData_, rolesContract) public\r\n    {\r\n        if (tokenData_ == address(0x0)) {\r\n            uint256 totalSupply;\r\n            require(initialBalances.length == initialWallets.length);\r\n            for (uint256 i = 0; i < initialWallets.length; i++) {\r\n                data.setBalances(initialWallets[i], initialBalances[i]);\r\n                token.triggerTransfer(address(0x0), initialWallets[i], initialBalances[i]);\r\n                totalSupply = Math.add(totalSupply, initialBalances[i]);\r\n            }\r\n            data.setSupply(totalSupply);\r\n        }\r\n    }\r\n\r\n    function mintFor(address, uint256) public tokenOnly {\r\n        // no more SweetTokens can be minted after the initial mint\r\n        assert(false);\r\n    }\r\n\r\n    function burn(address, uint256) public tokenOnly {\r\n        // burning is not possible\r\n        assert(false);\r\n    }\r\n}\r\n\r\n\r\ncontract SweetToken is Token {\r\n    function SweetToken(string name_, string symbol_, address rolesContract) public Token(name_, symbol_, rolesContract) {\r\n        // you shouldn't create logic here, because this contract would be the owner.\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"senderHasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roles\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"logic_\",\"type\":\"address\"}],\"name\":\"setLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roles_\",\"type\":\"address\"}],\"name\":\"setRolesContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name_\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mintFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_allowance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"triggerTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"pull\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name_\",\"type\":\"string\"},{\"name\":\"symbol_\",\"type\":\"string\"},{\"name\":\"rolesContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"LogBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"LogMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newLogic\",\"type\":\"address\"}],\"name\":\"LogLogicReplaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"SweetToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000faf52e46655b947841c0c3699b261ea5a805875e000000000000000000000000000000000000000000000000000000000000000a5377656574546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035357430000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://ffd348625cdca6e26266457481b24f94c1a36e63f08cfe41a77c2b569f4881a0"}]}