{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contracts that can have tokens approved, and then a function execute\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's Token Teleportation Service Interface v1.00\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\ncontract BTTSTokenInterface is ERC20Interface {\r\n    uint public constant bttsVersion = 100;\r\n\r\n    bytes public constant signingPrefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    bytes4 public constant signedTransferSig = \"\\x75\\x32\\xea\\xac\";\r\n    bytes4 public constant signedApproveSig = \"\\xe9\\xaf\\xa7\\xa1\";\r\n    bytes4 public constant signedTransferFromSig = \"\\x34\\x4b\\xcc\\x7d\";\r\n    bytes4 public constant signedApproveAndCallSig = \"\\xf1\\x6f\\x9b\\x53\";\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event MinterUpdated(address from, address to);\r\n    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\r\n    event MintingDisabled();\r\n    event TransfersEnabled();\r\n    event AccountUnlocked(address indexed tokenOwner);\r\n\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success);\r\n\r\n    // ------------------------------------------------------------------------\r\n    // signed{X} functions\r\n    // ------------------------------------------------------------------------\r\n    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\r\n    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\r\n    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\r\n\r\n    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\r\n    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\r\n    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\r\n\r\n    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\r\n    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\r\n    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\r\n\r\n    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce) public view returns (bytes32 hash);\r\n    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result);\r\n    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success);\r\n\r\n    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success);\r\n    function unlockAccount(address tokenOwner) public;\r\n    function disableMinting() public;\r\n    function enableTransfers() public;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // signed{X}Check return status\r\n    // ------------------------------------------------------------------------\r\n    enum CheckResult {\r\n        Success,                           // 0 Success\r\n        NotTransferable,                   // 1 Tokens not transferable yet\r\n        AccountLocked,                     // 2 Account locked\r\n        SignerMismatch,                    // 3 Mismatch in signing account\r\n        AlreadyExecuted,                   // 4 Transfer already executed\r\n        InsufficientApprovedTokens,        // 5 Insufficient approved tokens\r\n        InsufficientApprovedTokensForFees, // 6 Insufficient approved tokens for fees\r\n        InsufficientTokens,                // 7 Insufficient tokens\r\n        InsufficientTokensForFees,         // 8 Insufficient tokens for fees\r\n        OverflowError                      // 9 Overflow error\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's Token Teleportation Service Library v1.00\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\nlibrary BTTSLib {\r\n    struct Data {\r\n        // Ownership\r\n        address owner;\r\n        address newOwner;\r\n\r\n        // Minting and management\r\n        address minter;\r\n        bool mintable;\r\n        bool transferable;\r\n        mapping(address => bool) accountLocked;\r\n\r\n        // Token\r\n        string symbol;\r\n        string name;\r\n        uint8 decimals;\r\n        uint totalSupply;\r\n        mapping(address => uint) balances;\r\n        mapping(address => mapping(address => uint)) allowed;\r\n        mapping(address => mapping(bytes32 => bool)) executed;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constants\r\n    // ------------------------------------------------------------------------\r\n    uint public constant bttsVersion = 100;\r\n    bytes public constant signingPrefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    bytes4 public constant signedTransferSig = \"\\x75\\x32\\xea\\xac\";\r\n    bytes4 public constant signedApproveSig = \"\\xe9\\xaf\\xa7\\xa1\";\r\n    bytes4 public constant signedTransferFromSig = \"\\x34\\x4b\\xcc\\x7d\";\r\n    bytes4 public constant signedApproveAndCallSig = \"\\xf1\\x6f\\x9b\\x53\";\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Event\r\n    // ------------------------------------------------------------------------\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event MinterUpdated(address from, address to);\r\n    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\r\n    event MintingDisabled();\r\n    event TransfersEnabled();\r\n    event AccountUnlocked(address indexed tokenOwner);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Initialisation\r\n    // ------------------------------------------------------------------------\r\n    function init(Data storage self, address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {\r\n        require(self.owner == address(0));\r\n        self.owner = owner;\r\n        self.symbol = symbol;\r\n        self.name = name;\r\n        self.decimals = decimals;\r\n        if (initialSupply > 0) {\r\n            self.balances[owner] = initialSupply;\r\n            self.totalSupply = initialSupply;\r\n            Mint(self.owner, initialSupply, false);\r\n            Transfer(address(0), self.owner, initialSupply);\r\n        }\r\n        self.mintable = mintable;\r\n        self.transferable = transferable;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Safe maths\r\n    // ------------------------------------------------------------------------\r\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Ownership\r\n    // ------------------------------------------------------------------------\r\n    function transferOwnership(Data storage self, address newOwner) public {\r\n        require(msg.sender == self.owner);\r\n        self.newOwner = newOwner;\r\n    }\r\n    function acceptOwnership(Data storage self) public {\r\n        require(msg.sender == self.newOwner);\r\n        OwnershipTransferred(self.owner, self.newOwner);\r\n        self.owner = self.newOwner;\r\n        self.newOwner = address(0);\r\n    }\r\n    function transferOwnershipImmediately(Data storage self, address newOwner) public {\r\n        require(msg.sender == self.owner);\r\n        OwnershipTransferred(self.owner, newOwner);\r\n        self.owner = newOwner;\r\n        self.newOwner = address(0);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Minting and management\r\n    // ------------------------------------------------------------------------\r\n    function setMinter(Data storage self, address minter) public {\r\n        require(msg.sender == self.owner);\r\n        require(self.mintable);\r\n        MinterUpdated(self.minter, minter);\r\n        self.minter = minter;\r\n    }\r\n    function mint(Data storage self, address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {\r\n        require(self.mintable);\r\n        require(msg.sender == self.minter || msg.sender == self.owner);\r\n        if (lockAccount) {\r\n            self.accountLocked[tokenOwner] = true;\r\n        }\r\n        self.balances[tokenOwner] = safeAdd(self.balances[tokenOwner], tokens);\r\n        self.totalSupply = safeAdd(self.totalSupply, tokens);\r\n        Mint(tokenOwner, tokens, lockAccount);\r\n        Transfer(address(0), tokenOwner, tokens);\r\n        return true;\r\n    }\r\n    function unlockAccount(Data storage self, address tokenOwner) public {\r\n        require(msg.sender == self.owner);\r\n        require(self.accountLocked[tokenOwner]);\r\n        self.accountLocked[tokenOwner] = false;\r\n        AccountUnlocked(tokenOwner);\r\n    }\r\n    function disableMinting(Data storage self) public {\r\n        require(self.mintable);\r\n        require(msg.sender == self.minter || msg.sender == self.owner);\r\n        self.mintable = false;\r\n        if (self.minter != address(0)) {\r\n            MinterUpdated(self.minter, address(0));\r\n            self.minter = address(0);\r\n        }\r\n        MintingDisabled();\r\n    }\r\n    function enableTransfers(Data storage self) public {\r\n        require(msg.sender == self.owner);\r\n        require(!self.transferable);\r\n        self.transferable = true;\r\n        TransfersEnabled();\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Other functions\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(Data storage self, address tokenAddress, uint tokens) public returns (bool success) {\r\n        require(msg.sender == self.owner);\r\n        return ERC20Interface(tokenAddress).transfer(self.owner, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // ecrecover from a signature rather than the signature in parts [v, r, s]\r\n    // The signature format is a compact form {bytes32 r}{bytes32 s}{uint8 v}.\r\n    // Compact means, uint8 is not padded to 32 bytes.\r\n    //\r\n    // An invalid signature results in the address(0) being returned, make\r\n    // sure that the returned result is checked to be non-zero for validity\r\n    //\r\n    // Parts from https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n    // ------------------------------------------------------------------------\r\n    function ecrecoverFromSig(Data storage /*self*/, bytes32 hash, bytes sig) public pure returns (address recoveredAddress) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (sig.length != 65) return address(0);\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            // Here we are loading the last 32 bytes. We exploit the fact that 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]\r\n        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n          v += 27;\r\n        }\r\n        if (v != 27 && v != 28) return address(0);\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get CheckResult message\r\n    // ------------------------------------------------------------------------\r\n    function getCheckResultMessage(Data storage /*self*/, BTTSTokenInterface.CheckResult result) public pure returns (string) {\r\n        if (result == BTTSTokenInterface.CheckResult.Success) {\r\n            return \"Success\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.NotTransferable) {\r\n            return \"Tokens not transferable yet\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.AccountLocked) {\r\n            return \"Account locked\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.SignerMismatch) {\r\n            return \"Mismatch in signing account\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.AlreadyExecuted) {\r\n            return \"Transfer already executed\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.InsufficientApprovedTokens) {\r\n            return \"Insufficient approved tokens\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.InsufficientApprovedTokensForFees) {\r\n            return \"Insufficient approved tokens for fees\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.InsufficientTokens) {\r\n            return \"Insufficient tokens\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.InsufficientTokensForFees) {\r\n            return \"Insufficient tokens for fees\";\r\n        } else if (result == BTTSTokenInterface.CheckResult.OverflowError) {\r\n            return \"Overflow error\";\r\n        } else {\r\n            return \"Unknown error\";\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token functions\r\n    // ------------------------------------------------------------------------\r\n    function transfer(Data storage self, address to, uint tokens) public returns (bool success) {\r\n        // Owner and minter can move tokens before the tokens are transferable \r\n        require(self.transferable || (self.mintable && (msg.sender == self.owner  || msg.sender == self.minter)));\r\n        require(!self.accountLocked[msg.sender]);\r\n        self.balances[msg.sender] = safeSub(self.balances[msg.sender], tokens);\r\n        self.balances[to] = safeAdd(self.balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n    function approve(Data storage self, address spender, uint tokens) public returns (bool success) {\r\n        require(!self.accountLocked[msg.sender]);\r\n        self.allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n    function transferFrom(Data storage self, address from, address to, uint tokens) public returns (bool success) {\r\n        require(self.transferable);\r\n        require(!self.accountLocked[from]);\r\n        self.balances[from] = safeSub(self.balances[from], tokens);\r\n        self.allowed[from][msg.sender] = safeSub(self.allowed[from][msg.sender], tokens);\r\n        self.balances[to] = safeAdd(self.balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n    function approveAndCall(Data storage self, address tokenContract, address spender, uint tokens, bytes data) public returns (bool success) {\r\n        require(!self.accountLocked[msg.sender]);\r\n        self.allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, tokenContract, data);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Signed function\r\n    // ------------------------------------------------------------------------\r\n    function signedTransferHash(Data storage /*self*/, address tokenContract, address tokenOwner, address to, uint tokens, uint fee, uint nonce) public pure returns (bytes32 hash) {\r\n        hash = keccak256(signedTransferSig, tokenContract, tokenOwner, to, tokens, fee, nonce);\r\n    }\r\n    function signedTransferCheck(Data storage self, address tokenContract, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {\r\n        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;\r\n        bytes32 hash = signedTransferHash(self, tokenContract, tokenOwner, to, tokens, fee, nonce);\r\n        if (tokenOwner == address(0) || tokenOwner != ecrecoverFromSig(self, keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;\r\n        if (self.accountLocked[tokenOwner]) return BTTSTokenInterface.CheckResult.AccountLocked;\r\n        if (self.executed[tokenOwner][hash]) return BTTSTokenInterface.CheckResult.AlreadyExecuted;\r\n        uint total = safeAdd(tokens, fee);\r\n        if (self.balances[tokenOwner] < tokens) return BTTSTokenInterface.CheckResult.InsufficientTokens;\r\n        if (self.balances[tokenOwner] < total) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;\r\n        if (self.balances[to] + tokens < self.balances[to]) return BTTSTokenInterface.CheckResult.OverflowError;\r\n        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;\r\n        return BTTSTokenInterface.CheckResult.Success;\r\n    }\r\n    function signedTransfer(Data storage self, address tokenContract, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {\r\n        require(self.transferable);\r\n        bytes32 hash = signedTransferHash(self, tokenContract, tokenOwner, to, tokens, fee, nonce);\r\n        require(tokenOwner != address(0) && tokenOwner == ecrecoverFromSig(self, keccak256(signingPrefix, hash), sig));\r\n        require(!self.accountLocked[tokenOwner]);\r\n        require(!self.executed[tokenOwner][hash]);\r\n        self.executed[tokenOwner][hash] = true;\r\n        self.balances[tokenOwner] = safeSub(self.balances[tokenOwner], tokens);\r\n        self.balances[to] = safeAdd(self.balances[to], tokens);\r\n        Transfer(tokenOwner, to, tokens);\r\n        self.balances[tokenOwner] = safeSub(self.balances[tokenOwner], fee);\r\n        self.balances[feeAccount] = safeAdd(self.balances[feeAccount], fee);\r\n        Transfer(tokenOwner, feeAccount, fee);\r\n        return true;\r\n    }\r\n    function signedApproveHash(Data storage /*self*/, address tokenContract, address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public pure returns (bytes32 hash) {\r\n        hash = keccak256(signedApproveSig, tokenContract, tokenOwner, spender, tokens, fee, nonce);\r\n    }\r\n    function signedApproveCheck(Data storage self, address tokenContract, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {\r\n        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;\r\n        bytes32 hash = signedApproveHash(self, tokenContract, tokenOwner, spender, tokens, fee, nonce);\r\n        if (tokenOwner == address(0) || tokenOwner != ecrecoverFromSig(self, keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;\r\n        if (self.accountLocked[tokenOwner]) return BTTSTokenInterface.CheckResult.AccountLocked;\r\n        if (self.executed[tokenOwner][hash]) return BTTSTokenInterface.CheckResult.AlreadyExecuted;\r\n        if (self.balances[tokenOwner] < fee) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;\r\n        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;\r\n        return BTTSTokenInterface.CheckResult.Success;\r\n    }\r\n    function signedApprove(Data storage self, address tokenContract, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {\r\n        require(self.transferable);\r\n        bytes32 hash = signedApproveHash(self, tokenContract, tokenOwner, spender, tokens, fee, nonce);\r\n        require(tokenOwner != address(0) && tokenOwner == ecrecoverFromSig(self, keccak256(signingPrefix, hash), sig));\r\n        require(!self.accountLocked[tokenOwner]);\r\n        require(!self.executed[tokenOwner][hash]);\r\n        self.executed[tokenOwner][hash] = true;\r\n        self.allowed[tokenOwner][spender] = tokens;\r\n        Approval(tokenOwner, spender, tokens);\r\n        self.balances[tokenOwner] = safeSub(self.balances[tokenOwner], fee);\r\n        self.balances[feeAccount] = safeAdd(self.balances[feeAccount], fee);\r\n        Transfer(tokenOwner, feeAccount, fee);\r\n        return true;\r\n    }\r\n    function signedTransferFromHash(Data storage /*self*/, address tokenContract, address spender, address from, address to, uint tokens, uint fee, uint nonce) public pure returns (bytes32 hash) {\r\n        hash = keccak256(signedTransferFromSig, tokenContract, spender, from, to, tokens, fee, nonce);\r\n    }\r\n    function signedTransferFromCheck(Data storage self, address tokenContract, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {\r\n        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;\r\n        bytes32 hash = signedTransferFromHash(self, tokenContract, spender, from, to, tokens, fee, nonce);\r\n        if (spender == address(0) || spender != ecrecoverFromSig(self, keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;\r\n        if (self.accountLocked[from]) return BTTSTokenInterface.CheckResult.AccountLocked;\r\n        if (self.executed[spender][hash]) return BTTSTokenInterface.CheckResult.AlreadyExecuted;\r\n        uint total = safeAdd(tokens, fee);\r\n        if (self.allowed[from][spender] < tokens) return BTTSTokenInterface.CheckResult.InsufficientApprovedTokens;\r\n        if (self.allowed[from][spender] < total) return BTTSTokenInterface.CheckResult.InsufficientApprovedTokensForFees;\r\n        if (self.balances[from] < tokens) return BTTSTokenInterface.CheckResult.InsufficientTokens;\r\n        if (self.balances[from] < total) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;\r\n        if (self.balances[to] + tokens < self.balances[to]) return BTTSTokenInterface.CheckResult.OverflowError;\r\n        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;\r\n        return BTTSTokenInterface.CheckResult.Success;\r\n    }\r\n    function signedTransferFrom(Data storage self, address tokenContract, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {\r\n        require(self.transferable);\r\n        bytes32 hash = signedTransferFromHash(self, tokenContract, spender, from, to, tokens, fee, nonce);\r\n        require(spender != address(0) && spender == ecrecoverFromSig(self, keccak256(signingPrefix, hash), sig));\r\n        require(!self.accountLocked[from]);\r\n        require(!self.executed[spender][hash]);\r\n        self.executed[spender][hash] = true;\r\n        self.balances[from] = safeSub(self.balances[from], tokens);\r\n        self.allowed[from][spender] = safeSub(self.allowed[from][spender], tokens);\r\n        self.balances[to] = safeAdd(self.balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        self.balances[from] = safeSub(self.balances[from], fee);\r\n        self.allowed[from][spender] = safeSub(self.allowed[from][spender], fee);\r\n        self.balances[feeAccount] = safeAdd(self.balances[feeAccount], fee);\r\n        Transfer(from, feeAccount, fee);\r\n        return true;\r\n    }\r\n    function signedApproveAndCallHash(Data storage /*self*/, address tokenContract, address tokenOwner, address spender, uint tokens, bytes data, uint fee, uint nonce) public pure returns (bytes32 hash) {\r\n        hash = keccak256(signedApproveAndCallSig, tokenContract, tokenOwner, spender, tokens, data, fee, nonce);\r\n    }\r\n    function signedApproveAndCallCheck(Data storage self, address tokenContract, address tokenOwner, address spender, uint tokens, bytes data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (BTTSTokenInterface.CheckResult result) {\r\n        if (!self.transferable) return BTTSTokenInterface.CheckResult.NotTransferable;\r\n        bytes32 hash = signedApproveAndCallHash(self, tokenContract, tokenOwner, spender, tokens, data, fee, nonce);\r\n        if (tokenOwner == address(0) || tokenOwner != ecrecoverFromSig(self, keccak256(signingPrefix, hash), sig)) return BTTSTokenInterface.CheckResult.SignerMismatch;\r\n        if (self.accountLocked[tokenOwner]) return BTTSTokenInterface.CheckResult.AccountLocked;\r\n        if (self.executed[tokenOwner][hash]) return BTTSTokenInterface.CheckResult.AlreadyExecuted;\r\n        if (self.balances[tokenOwner] < fee) return BTTSTokenInterface.CheckResult.InsufficientTokensForFees;\r\n        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return BTTSTokenInterface.CheckResult.OverflowError;\r\n        return BTTSTokenInterface.CheckResult.Success;\r\n    }\r\n    function signedApproveAndCall(Data storage self, address tokenContract, address tokenOwner, address spender, uint tokens, bytes data, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {\r\n        require(self.transferable);\r\n        bytes32 hash = signedApproveAndCallHash(self, tokenContract, tokenOwner, spender, tokens, data, fee, nonce);\r\n        require(tokenOwner != address(0) && tokenOwner == ecrecoverFromSig(self, keccak256(signingPrefix, hash), sig));\r\n        require(!self.accountLocked[tokenOwner]);\r\n        require(!self.executed[tokenOwner][hash]);\r\n        self.executed[tokenOwner][hash] = true;\r\n        self.allowed[tokenOwner][spender] = tokens;\r\n        Approval(tokenOwner, spender, tokens);\r\n        self.balances[tokenOwner] = safeSub(self.balances[tokenOwner], fee);\r\n        self.balances[feeAccount] = safeAdd(self.balances[feeAccount], fee);\r\n        Transfer(tokenOwner, feeAccount, fee);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, tokenContract, data);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's Token Teleportation Service Token Factory v1.00\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\ncontract BTTSToken is BTTSTokenInterface {\r\n    using BTTSLib for BTTSLib.Data;\r\n\r\n    BTTSLib.Data data;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function BTTSToken(address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {\r\n        data.init(owner, symbol, name, decimals, initialSupply, mintable, transferable);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Ownership\r\n    // ------------------------------------------------------------------------\r\n    function owner() public view returns (address) {\r\n        return data.owner;\r\n    }\r\n    function newOwner() public view returns (address) {\r\n        return data.newOwner;\r\n    }\r\n    function transferOwnership(address _newOwner) public {\r\n        data.transferOwnership(_newOwner);\r\n    }\r\n    function acceptOwnership() public {\r\n        data.acceptOwnership();\r\n    }\r\n    function transferOwnershipImmediately(address _newOwner) public {\r\n        data.transferOwnershipImmediately(_newOwner);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token\r\n    // ------------------------------------------------------------------------\r\n    function symbol() public view returns (string) {\r\n        return data.symbol;\r\n    }\r\n    function name() public view returns (string) {\r\n        return data.name;\r\n    }\r\n    function decimals() public view returns (uint8) {\r\n        return data.decimals;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Minting and management\r\n    // ------------------------------------------------------------------------\r\n    function minter() public view returns (address) {\r\n        return data.minter;\r\n    }\r\n    function setMinter(address _minter) public {\r\n        data.setMinter(_minter);\r\n    }\r\n    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {\r\n        return data.mint(tokenOwner, tokens, lockAccount);\r\n    }\r\n    function unlockAccount(address tokenOwner) public {\r\n        return data.unlockAccount(tokenOwner);\r\n    }\r\n    function mintable() public view returns (bool) {\r\n        return data.mintable;\r\n    }\r\n    function transferable() public view returns (bool) {\r\n        return data.transferable;\r\n    }\r\n    function disableMinting() public {\r\n        data.disableMinting();\r\n    }\r\n    function enableTransfers() public {\r\n        data.enableTransfers();\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Other functions\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\r\n        return data.transferAnyERC20Token(tokenAddress, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ethers\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token functions\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return data.totalSupply - data.balances[address(0)];\r\n    }\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return data.balances[tokenOwner];\r\n    }\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return data.allowed[tokenOwner][spender];\r\n    }\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        return data.transfer(to, tokens);\r\n    }\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        return data.approve(spender, tokens);\r\n    }\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        return data.transferFrom(from, to, tokens);\r\n    }\r\n    function approveAndCall(address spender, uint tokens, bytes _data) public returns (bool success) {\r\n        success = data.approveAndCall(this, spender, tokens, _data);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Signed function\r\n    // ------------------------------------------------------------------------\r\n    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        return data.signedTransferHash(address(this), tokenOwner, to, tokens, fee, nonce);\r\n    }\r\n    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {\r\n        return data.signedTransferCheck(address(this), tokenOwner, to, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {\r\n        return data.signedTransfer(address(this), tokenOwner, to, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        return data.signedApproveHash(address(this), tokenOwner, spender, tokens, fee, nonce);\r\n    }\r\n    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {\r\n        return data.signedApproveCheck(address(this), tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {\r\n        return data.signedApprove(address(this), tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        return data.signedTransferFromHash(address(this), spender, from, to, tokens, fee, nonce);\r\n    }\r\n    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {\r\n        return data.signedTransferFromCheck(address(this), spender, from, to, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {\r\n        return data.signedTransferFrom(address(this), spender, from, to, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        return data.signedApproveAndCallHash(address(this), tokenOwner, spender, tokens, _data, fee, nonce);\r\n    }\r\n    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public view returns (CheckResult result) {\r\n        return data.signedApproveAndCallCheck(address(this), tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);\r\n    }\r\n    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes _data, uint fee, uint nonce, bytes sig, address feeAccount) public returns (bool success) {\r\n        return data.signedApproveAndCall(address(this), tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n    function transferOwnershipImmediately(address _newOwner) public onlyOwner {\r\n        OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's Token Teleportation Service Token Factory v1.00\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\ncontract BTTSTokenFactory is Owned {\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Internal data\r\n    // ------------------------------------------------------------------------\r\n    mapping(address => bool) _verify;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Event\r\n    // ------------------------------------------------------------------------\r\n    event BTTSTokenListing(address indexed ownerAddress,\r\n        address indexed bttsTokenAddress, \r\n        string symbol, string name, uint8 decimals, \r\n        uint initialSupply, bool mintable, bool transferable);\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Anyone can call this method to verify whether the bttsToken contract at\r\n    // the specified address was deployed using this factory\r\n    //\r\n    // Parameters:\r\n    //   tokenContract  the bttsToken contract address\r\n    //\r\n    // Return values:\r\n    //   valid          did this BTTSTokenFactory create the BTTSToken contract?\r\n    //   decimals       number of decimal places for the token contract\r\n    //   initialSupply  the token initial supply\r\n    //   mintable       is the token mintable after deployment?\r\n    //   transferable   are the tokens transferable after deployment?\r\n    // ------------------------------------------------------------------------\r\n    function verify(address tokenContract) public view returns (\r\n        bool    valid,\r\n        address owner,\r\n        uint    decimals,\r\n        bool    mintable,\r\n        bool    transferable\r\n    ) {\r\n        valid = _verify[tokenContract];\r\n        if (valid) {\r\n            BTTSToken t = BTTSToken(tokenContract);\r\n            owner        = t.owner();\r\n            decimals     = t.decimals();\r\n            mintable     = t.mintable();\r\n            transferable = t.transferable();\r\n        }\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Any account can call this method to deploy a new BTTSToken contract.\r\n    // The owner of the BTTSToken contract will be the calling account\r\n    //\r\n    // Parameters:\r\n    //   symbol         symbol\r\n    //   name           name\r\n    //   decimals       number of decimal places for the token contract\r\n    //   initialSupply  the token initial supply\r\n    //   mintable       is the token mintable after deployment?\r\n    //   transferable   are the tokens transferable after deployment?\r\n    //\r\n    // For example, deploying a BTTSToken contract with `initialSupply` of\r\n    // 1,000.000000000000000000 tokens:\r\n    //   symbol         \"ME\"\r\n    //   name           \"My Token\"\r\n    //   decimals       18\r\n    //   initialSupply  10000000000000000000000 = 1,000.000000000000000000\r\n    //                  tokens\r\n    //   mintable       can tokens be minted after deployment?\r\n    //   transferable   are the tokens transferable after deployment?\r\n    //\r\n    // The BTTSTokenListing() event is logged with the following parameters\r\n    //   owner          the account that execute this transaction\r\n    //   symbol         symbol\r\n    //   name           name\r\n    //   decimals       number of decimal places for the token contract\r\n    //   initialSupply  the token initial supply\r\n    //   mintable       can tokens be minted after deployment?\r\n    //   transferable   are the tokens transferable after deployment?\r\n    // ------------------------------------------------------------------------\r\n    function deployBTTSTokenContract(\r\n        string symbol,\r\n        string name,\r\n        uint8 decimals,\r\n        uint initialSupply,\r\n        bool mintable,\r\n        bool transferable\r\n    ) public returns (address bttsTokenAddress) {\r\n        bttsTokenAddress = new BTTSToken(\r\n            msg.sender,\r\n            symbol,\r\n            name,\r\n            decimals,\r\n            initialSupply,\r\n            mintable,\r\n            transferable);\r\n        // Record that this factory created the trader\r\n        _verify[bttsTokenAddress] = true;\r\n        BTTSTokenListing(msg.sender, bttsTokenAddress, symbol, name, decimals, \r\n            initialSupply, mintable, transferable);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Factory owner can transfer out any accidentally sent ERC20 tokens\r\n    //\r\n    // Parameters:\r\n    //   tokenAddress  contract address of the token contract being withdrawn\r\n    //                 from\r\n    //   tokens        number of tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ethers\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"signedApproveAndCallHash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"signedApproveHash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"signedTransferFromHash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signedApproveAndCallSig\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"signedTransferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signedTransferSig\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"signedTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"signedTransferCheck\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnershipImmediately\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bttsVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"unlockAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"signedApproveAndCallCheck\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"signedTransferHash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signedApproveSig\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signedTransferFromSig\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"signedApproveCheck\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"lockAccount\",\"type\":\"bool\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signingPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"signedApprove\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"signedApproveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"signedTransferFromCheck\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"mintable\",\"type\":\"bool\"},{\"name\":\"transferable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"MinterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockAccount\",\"type\":\"bool\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintingDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TransfersEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"AccountUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BTTSToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e796ad819e32846a7f2b28288a23f682eb4da9b400000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003475a450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000847617a65436f696e000000000000000000000000000000000000000000000000","Library":":BTTSLib:9bb2eae0be24460a1f8292fb2c48c300f5622e64","SwarmSource":"bzzr://4682545eb4351a060d0602ea3fcd7cc19f33db2437811765c875a59c14eb0f33"}]}