{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n /* \r\n This Consulteum token contract is based on the ERC20 token contract. Additional \r\n functionality has been integrated: \r\n * the contract Lockable, which is used as a parent of the Token contract \r\n * the function mintTokens(), which makes use of the currentSwapRate() and safeToAdd() helpers \r\n * the function disableTokenSwapLock() \r\n */ \r\n \r\n \r\n contract Lockable {  \r\n     uint public creationTime;\r\n     bool public tokenSwapLock; \r\n     \r\n     address public dev;\r\n \r\n     // This modifier should prevent tokens transfers while the tokenswap \r\n     // is still ongoing \r\n     modifier isTokenSwapOn { \r\n         if (tokenSwapLock) throw; \r\n        _;\r\n     }\r\n     \r\n  // This modifier should prevent ICO from being launched by an attacker\r\n     \r\n    modifier onlyDev{ \r\n       if (msg.sender != dev) throw; \r\n      _;\r\n   }\r\n\r\n     function Lockable() { \r\n       dev = msg.sender; \r\n     } \r\n } \r\n \r\n\r\n \r\n\r\n contract ERC20 { \r\n     function totalSupply() constant returns (uint); \r\n     function balanceOf(address who) constant returns (uint); \r\n     function allowance(address owner, address spender) constant returns (uint); \r\n \r\n\r\n     function transfer(address to, uint value) returns (bool ok); \r\n     function transferFrom(address from, address to, uint value) returns (bool ok); \r\n     function approve(address spender, uint value) returns (bool ok); \r\n \r\n     event Transfer(address indexed from, address indexed to, uint value); \r\n     event Approval(address indexed owner, address indexed spender, uint value); \r\n } \r\n \r\n \r\n contract Consulteth is ERC20, Lockable { \r\n \r\n\r\n   mapping( address => uint ) _balances; \r\n   mapping( address => mapping( address => uint ) ) _approvals; \r\n   \r\n   uint public foundationAsset;\r\n   uint public CTX_Cap;\r\n   uint _supply; \r\n   \r\n   address public wallet_Mini_Address;\r\n   address public wallet_Address;\r\n   \r\n   uint public factorial_ICO;\r\n   \r\n   event TokenMint(address newTokenHolder, uint amountOfTokens); \r\n   event TokenSwapOver(); \r\n \r\n   modifier onlyFromMiniWallet { \r\n       if (msg.sender != wallet_Mini_Address) throw;\r\n      _;\r\n   }\r\n   \r\n   modifier onlyFromWallet { \r\n       if (msg.sender != wallet_Address) throw; \r\n      _;\r\n   } \r\n \r\n  \r\n \r\n   function Consulteth(uint preMine, uint cap_CTX) { \r\n     _balances[msg.sender] = preMine; \r\n     foundationAsset = preMine;\r\n     CTX_Cap = cap_CTX;\r\n     \r\n     _supply += preMine;  \r\n      \r\n   } \r\n \r\n \r\n   function totalSupply() constant returns (uint supply) { \r\n     return _supply; \r\n   } \r\n\r\n\r\n \r\n   function balanceOf( address who ) constant returns (uint value) { \r\n     return _balances[who]; \r\n   } \r\n \r\n \r\n   function allowance(address owner, address spender) constant returns (uint _allowance) { \r\n     return _approvals[owner][spender]; \r\n   } \r\n \r\n \r\n   // A helper to notify if overflow occurs \r\n   function safeToAdd(uint a, uint b) internal returns (bool) { \r\n     return (a + b >= a && a + b >= b); \r\n   } \r\n \r\n \r\n   function transfer(address to, uint value) isTokenSwapOn returns (bool ok) { \r\n \r\n \r\n     if( _balances[msg.sender] < value ) { \r\n         throw; \r\n     } \r\n     if( !safeToAdd(_balances[to], value) ) { \r\n         throw; \r\n     } \r\n \r\n \r\n     _balances[msg.sender] -= value; \r\n     _balances[to] += value; \r\n     Transfer( msg.sender, to, value ); \r\n     return true; \r\n   } \r\n \r\n \r\n   function transferFrom(address from, address to, uint value) isTokenSwapOn returns (bool ok) { \r\n     // if you don't have enough balance, throw \r\n     if( _balances[from] < value ) { \r\n         throw; \r\n     } \r\n     // if you don't have approval, throw \r\n     if( _approvals[from][msg.sender] < value ) { \r\n         throw; \r\n     } \r\n     if( !safeToAdd(_balances[to], value) ) { \r\n         throw; \r\n     } \r\n     // transfer and return true \r\n     _approvals[from][msg.sender] -= value; \r\n     _balances[from] -= value; \r\n     _balances[to] += value; \r\n     Transfer( from, to, value ); \r\n     return true; \r\n   } \r\n \r\n   function approve(address spender, uint value) \r\n     isTokenSwapOn \r\n     returns (bool ok) { \r\n     _approvals[msg.sender][spender] = value; \r\n     Approval( msg.sender, spender, value ); \r\n     return true; \r\n   } \r\n \r\n \r\n   function kickStartMiniICO(address ico_Mini_Wallet) onlyDev  { \r\n    if (ico_Mini_Wallet == address(0x0)) throw; \r\n         // Allow setting only once \r\n    if (wallet_Mini_Address != address(0x0)) throw; \r\n         wallet_Mini_Address = ico_Mini_Wallet;\r\n         \r\n         creationTime = now; \r\n         tokenSwapLock = true;  \r\n   }\r\n \r\n   // The function preICOSwapRate() returns the current exchange rate \r\n   // between consulteum tokens and Ether during the pre-ICO token swap period \r\n   \r\n   function preICOSwapRate() constant returns(uint) { \r\n       if (creationTime + 1 weeks > now) { \r\n           return 1000; \r\n       } \r\n       else if (creationTime + 3 weeks > now) { \r\n           return 850; \r\n       } \r\n        \r\n       else { \r\n           return 0; \r\n       } \r\n   } \r\n   \r\n \r\n   \r\n   // The function mintMiniICOTokens is only usable by the chosen wallet \r\n   // contract to mint a number of tokens proportional to the \r\n   // amount of ether sent to the wallet contract. The function \r\n   // can only be called during the tokenswap period \r\n   \r\nfunction mintMiniICOTokens(address newTokenHolder, uint etherAmount) onlyFromMiniWallet\r\n    external { \r\n \r\n \r\n         uint tokensAmount = preICOSwapRate() * etherAmount; \r\n         \r\n         if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw; \r\n         if(!safeToAdd(_supply,tokensAmount)) throw; \r\n \r\n \r\n         _balances[newTokenHolder] += tokensAmount; \r\n         _supply += tokensAmount; \r\n \r\n \r\n         TokenMint(newTokenHolder, tokensAmount); \r\n   }\r\n   \r\n// The function disableMiniSwapLock() is called by the wallet \r\n   // contract once the token swap has reached its end conditions \r\n\r\n   function disableMiniSwapLock() onlyFromMiniWallet\r\n     external { \r\n         tokenSwapLock = false; \r\n         TokenSwapOver(); \r\n   }    \r\n  \r\n\r\n\r\nfunction kickStartICO(address ico_Wallet, uint mint_Factorial) onlyDev  { \r\n    if (ico_Wallet == address(0x0)) throw; \r\n         // Allow setting only once \r\n    if (wallet_Address != address(0x0)) throw; \r\n         \r\n         wallet_Address = ico_Wallet;\r\n         factorial_ICO = mint_Factorial;\r\n         \r\n         creationTime = now; \r\n         tokenSwapLock = true;  \r\n   }\r\n \r\n  \r\n   function ICOSwapRate() constant returns(uint) { \r\n       if (creationTime + 1 weeks > now) { \r\n           return factorial_ICO; \r\n       } \r\n       else if (creationTime + 2 weeks > now) { \r\n           return (factorial_ICO - 30); \r\n       } \r\n       else if (creationTime + 4 weeks > now) { \r\n           return (factorial_ICO - 70); \r\n       } \r\n       else { \r\n           return 0; \r\n       } \r\n   } \r\n \r\n\r\n \r\n   // The function mintICOTokens is only usable by the chosen wallet \r\n   // contract to mint a number of tokens proportional to the \r\n   // amount of ether sent to the wallet contract. The function \r\n   // can only be called during the tokenswap period \r\n   function mintICOTokens(address newTokenHolder, uint etherAmount) onlyFromWallet\r\n    external { \r\n \r\n \r\n         uint tokensAmount = ICOSwapRate() * etherAmount; \r\n\r\n         if((_supply + tokensAmount) > CTX_Cap) throw;\r\n         \r\n         if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw; \r\n         if(!safeToAdd(_supply,tokensAmount)) throw; \r\n \r\n \r\n         _balances[newTokenHolder] += tokensAmount; \r\n         _supply += tokensAmount; \r\n \r\n \r\n         TokenMint(newTokenHolder, tokensAmount); \r\n   } \r\n \r\n \r\n   // The function disableICOSwapLock() is called by the wallet \r\n   // contract once the token swap has reached its end conditions \r\n   function disableICOSwapLock() onlyFromWallet\r\n     external { \r\n         tokenSwapLock = false; \r\n         TokenSwapOver(); \r\n   } \r\n }","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ico_Mini_Wallet\",\"type\":\"address\"}],\"name\":\"kickStartMiniICO\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableICOSwapLock\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokenHolder\",\"type\":\"address\"},{\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"mintICOTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ico_Wallet\",\"type\":\"address\"},{\"name\":\"mint_Factorial\",\"type\":\"uint256\"}],\"name\":\"kickStartICO\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preICOSwapRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICOSwapRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_Mini_Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factorial_ICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CTX_Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableMiniSwapLock\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundationAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_allowance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSwapLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokenHolder\",\"type\":\"address\"},{\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"mintMiniICOTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"preMine\",\"type\":\"uint256\"},{\"name\":\"cap_CTX\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newTokenHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"TokenMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokenSwapOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Consulteth","CompilerVersion":"v0.4.0+commit.acd334c9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000b949d854f34fece0000000000000000000000000000000000000000000000004dc14635ef3f411e000000","Library":"","SwarmSource":""}]}