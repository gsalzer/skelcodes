{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n/**\r\n * @title ERC20\r\n * @dev ERC20 interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n    address public controller;\r\n    function Controlled() public { controller = msg.sender;}\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n/**\r\n * @title MiniMe interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20MiniMe is ERC20, Controlled {\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool);\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint);\r\n    function totalSupplyAt(uint _blockNumber) public view returns(uint);\r\n    function createCloneToken(string _cloneTokenName, uint8 _cloneDecimalUnits, string _cloneTokenSymbol, uint _snapshotBlock, bool _transfersEnabled) public returns(address);\r\n    function generateTokens(address _owner, uint _amount) public returns (bool);\r\n    function destroyTokens(address _owner, uint _amount)  public returns (bool);\r\n    function enableTransfers(bool _transfersEnabled) public;\r\n    function isContract(address _addr) internal view returns(bool);\r\n    function claimTokens(address _token) public;\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n}\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n  // The token being sold\r\n  ERC20MiniMe public token;\r\n  // start and end timestamps where investments are allowed (both inclusive)\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  // address where funds are collected\r\n  address public wallet;\r\n  // how many token units a buyer gets per wei\r\n  uint256 public rate;\r\n  // amount of raised money in wei\r\n  uint256 public weiRaised;\r\n  /**\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {\r\n    require(_startTime >= now);\r\n    require(_endTime >= _startTime);\r\n    require(_rate > 0);\r\n    require(_wallet != 0x0);\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n  }\r\n  // fallback function can be used to buy tokens\r\n  function () payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n  // low level token purchase function\r\n  function buyTokens(address beneficiary) public payable {\r\n    buyTokens(beneficiary, msg.value);\r\n  }\r\n  // implementation of low level token purchase function\r\n  function buyTokens(address beneficiary, uint256 weiAmount) internal {\r\n    require(beneficiary != 0x0);\r\n    require(validPurchase(weiAmount));\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n    transferToken(beneficiary, weiAmount);\r\n    forwardFunds(weiAmount);\r\n  }\r\n  // low level transfer token\r\n  // override to create custom token transfer mechanism, eg. pull pattern\r\n  function transferToken(address beneficiary, uint256 weiAmount) internal {\r\n    // calculate token amount to be created\r\n    uint256 tokens = weiAmount.mul(rate);\r\n    token.generateTokens(beneficiary, tokens);\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n  }\r\n  // send ether to the fund collection wallet\r\n  // override to create custom fund forwarding mechanisms\r\n  function forwardFunds(uint256 weiAmount) internal {\r\n    wallet.transfer(weiAmount);\r\n  }\r\n  // @return true if the transaction can buy tokens\r\n  function validPurchase(uint256 weiAmount) internal view returns (bool) {\r\n    bool withinPeriod = now >= startTime && now <= endTime;\r\n    bool nonZeroPurchase = weiAmount != 0;\r\n    return withinPeriod && nonZeroPurchase;\r\n  }\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public view returns (bool) {\r\n    return now > endTime;\r\n  }\r\n  // @return true if crowdsale has started\r\n  function hasStarted() public view returns (bool) {\r\n    return now >= startTime;\r\n  }\r\n}\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    ERC20MiniMe public ethealToken;\r\n    address public SALE; // address where sale tokens are located\r\n    /// @notice needed for hodler handling\r\n    function addHodlerStake(address _beneficiary, uint _stake) public;\r\n    function setHodlerStake(address _beneficiary, uint256 _stake) public;\r\n    function setHodlerTime(uint256 _time) public;\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\r\n}\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n  bool public paused = false;\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n/**\r\n * @title Hodler\r\n * @dev Handles hodler reward, TokenController should create and own it.\r\n */\r\ncontract Hodler is Ownable {\r\n    using SafeMath for uint;\r\n    // HODLER reward tracker\r\n    // stake amount per address\r\n    struct HODL {\r\n        uint256 stake;\r\n        // moving ANY funds invalidates hodling of the address\r\n        bool invalid;\r\n        bool claimed3M;\r\n        bool claimed6M;\r\n        bool claimed9M;\r\n    }\r\n    mapping (address => HODL) public hodlerStakes;\r\n    // total current staking value and hodler addresses\r\n    uint256 public hodlerTotalValue;\r\n    uint256 public hodlerTotalCount;\r\n    // store dates and total stake values for 3 - 6 - 9 months after normal sale\r\n    uint256 public hodlerTotalValue3M;\r\n    uint256 public hodlerTotalValue6M;\r\n    uint256 public hodlerTotalValue9M;\r\n    uint256 public hodlerTimeStart;\r\n    uint256 public hodlerTime3M;\r\n    uint256 public hodlerTime6M;\r\n    uint256 public hodlerTime9M;\r\n    // reward HEAL token amount\r\n    uint256 public TOKEN_HODL_3M;\r\n    uint256 public TOKEN_HODL_6M;\r\n    uint256 public TOKEN_HODL_9M;\r\n    // total amount of tokens claimed so far\r\n    uint256 public claimedTokens;\r\n    \r\n    event LogHodlSetStake(address indexed _setter, address indexed _beneficiary, uint256 _value);\r\n    event LogHodlClaimed(address indexed _setter, address indexed _beneficiary, uint256 _value);\r\n    event LogHodlStartSet(address indexed _setter, uint256 _time);\r\n    /// @dev Only before hodl is started\r\n    modifier beforeHodlStart() {\r\n        if (hodlerTimeStart == 0 || now <= hodlerTimeStart)\r\n            _;\r\n    }\r\n    /// @dev Contructor, it should be created by a TokenController\r\n    function Hodler(uint256 _stake3m, uint256 _stake6m, uint256 _stake9m) {\r\n        TOKEN_HODL_3M = _stake3m;\r\n        TOKEN_HODL_6M = _stake6m;\r\n        TOKEN_HODL_9M = _stake9m;\r\n    }\r\n    /// @notice Adding hodler stake to an account\r\n    /// @dev Only owner contract can call it and before hodling period starts\r\n    /// @param _beneficiary Recepient address of hodler stake\r\n    /// @param _stake Amount of additional hodler stake\r\n    function addHodlerStake(address _beneficiary, uint256 _stake) public onlyOwner beforeHodlStart {\r\n        // real change and valid _beneficiary is needed\r\n        if (_stake == 0 || _beneficiary == address(0))\r\n            return;\r\n        \r\n        // add stake and maintain count\r\n        if (hodlerStakes[_beneficiary].stake == 0)\r\n            hodlerTotalCount = hodlerTotalCount.add(1);\r\n        hodlerStakes[_beneficiary].stake = hodlerStakes[_beneficiary].stake.add(_stake);\r\n        hodlerTotalValue = hodlerTotalValue.add(_stake);\r\n        LogHodlSetStake(msg.sender, _beneficiary, hodlerStakes[_beneficiary].stake);\r\n    }\r\n    /// @notice Setting hodler stake of an account\r\n    /// @dev Only owner contract can call it and before hodling period starts\r\n    /// @param _beneficiary Recepient address of hodler stake\r\n    /// @param _stake Amount to set the hodler stake\r\n    function setHodlerStake(address _beneficiary, uint256 _stake) public onlyOwner beforeHodlStart {\r\n        // real change and valid _beneficiary is needed\r\n        if (hodlerStakes[_beneficiary].stake == _stake || _beneficiary == address(0))\r\n            return;\r\n        \r\n        // add stake and maintain count\r\n        if (hodlerStakes[_beneficiary].stake == 0 && _stake > 0) {\r\n            hodlerTotalCount = hodlerTotalCount.add(1);\r\n        } else if (hodlerStakes[_beneficiary].stake > 0 && _stake == 0) {\r\n            hodlerTotalCount = hodlerTotalCount.sub(1);\r\n        }\r\n        uint256 _diff = _stake > hodlerStakes[_beneficiary].stake ? _stake.sub(hodlerStakes[_beneficiary].stake) : hodlerStakes[_beneficiary].stake.sub(_stake);\r\n        if (_stake > hodlerStakes[_beneficiary].stake) {\r\n            hodlerTotalValue = hodlerTotalValue.add(_diff);\r\n        } else {\r\n            hodlerTotalValue = hodlerTotalValue.sub(_diff);\r\n        }\r\n        hodlerStakes[_beneficiary].stake = _stake;\r\n        LogHodlSetStake(msg.sender, _beneficiary, _stake);\r\n    }\r\n    /// @notice Setting hodler start period.\r\n    /// @param _time The time when hodler reward starts counting\r\n    function setHodlerTime(uint256 _time) public onlyOwner beforeHodlStart {\r\n        require(_time >= now);\r\n        hodlerTimeStart = _time;\r\n        hodlerTime3M = _time.add(90 days);\r\n        hodlerTime6M = _time.add(180 days);\r\n        hodlerTime9M = _time.add(270 days);\r\n        LogHodlStartSet(msg.sender, _time);\r\n    }\r\n    /// @notice Invalidates hodler account \r\n    /// @dev Gets called by EthealController#onTransfer before every transaction\r\n    function invalidate(address _account) public onlyOwner {\r\n        if (hodlerStakes[_account].stake > 0 && !hodlerStakes[_account].invalid) {\r\n            hodlerStakes[_account].invalid = true;\r\n            hodlerTotalValue = hodlerTotalValue.sub(hodlerStakes[_account].stake);\r\n            hodlerTotalCount = hodlerTotalCount.sub(1);\r\n        }\r\n        // update hodl total values \"automatically\" - whenever someone sends funds thus\r\n        updateAndGetHodlTotalValue();\r\n    }\r\n    /// @notice Claiming HODL reward for msg.sender\r\n    function claimHodlReward() public {\r\n        claimHodlRewardFor(msg.sender);\r\n    }\r\n    /// @notice Claiming HODL reward for an address\r\n    function claimHodlRewardFor(address _beneficiary) public {\r\n        // only when the address has a valid stake\r\n        require(hodlerStakes[_beneficiary].stake > 0 && !hodlerStakes[_beneficiary].invalid);\r\n        uint256 _stake = 0;\r\n        \r\n        // update hodl total values\r\n        updateAndGetHodlTotalValue();\r\n        // claim hodl if not claimed\r\n        if (!hodlerStakes[_beneficiary].claimed3M && now >= hodlerTime3M) {\r\n            _stake = _stake.add(hodlerStakes[_beneficiary].stake.mul(TOKEN_HODL_3M).div(hodlerTotalValue3M));\r\n            hodlerStakes[_beneficiary].claimed3M = true;\r\n        }\r\n        if (!hodlerStakes[_beneficiary].claimed6M && now >= hodlerTime6M) {\r\n            _stake = _stake.add(hodlerStakes[_beneficiary].stake.mul(TOKEN_HODL_6M).div(hodlerTotalValue6M));\r\n            hodlerStakes[_beneficiary].claimed6M = true;\r\n        }\r\n        if (!hodlerStakes[_beneficiary].claimed9M && now >= hodlerTime9M) {\r\n            _stake = _stake.add(hodlerStakes[_beneficiary].stake.mul(TOKEN_HODL_9M).div(hodlerTotalValue9M));\r\n            hodlerStakes[_beneficiary].claimed9M = true;\r\n        }\r\n        if (_stake > 0) {\r\n            // increasing claimed tokens\r\n            claimedTokens = claimedTokens.add(_stake);\r\n            // transferring tokens\r\n            require(TokenController(owner).ethealToken().transfer(_beneficiary, _stake));\r\n            // log\r\n            LogHodlClaimed(msg.sender, _beneficiary, _stake);\r\n        }\r\n    }\r\n    /// @notice claimHodlRewardFor() for multiple addresses\r\n    /// @dev Anyone can call this function and distribute hodl rewards\r\n    /// @param _beneficiaries Array of addresses for which we want to claim hodl rewards\r\n    function claimHodlRewardsFor(address[] _beneficiaries) external {\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++)\r\n            claimHodlRewardFor(_beneficiaries[i]);\r\n    }\r\n    /// @notice Setting 3 - 6 - 9 months total staking hodl value if time is come\r\n    function updateAndGetHodlTotalValue() public returns (uint) {\r\n        if (now >= hodlerTime3M && hodlerTotalValue3M == 0) {\r\n            hodlerTotalValue3M = hodlerTotalValue;\r\n        }\r\n        if (now >= hodlerTime6M && hodlerTotalValue6M == 0) {\r\n            hodlerTotalValue6M = hodlerTotalValue;\r\n        }\r\n        if (now >= hodlerTime9M && hodlerTotalValue9M == 0) {\r\n            hodlerTotalValue9M = hodlerTotalValue;\r\n            // since we can transfer more tokens to this contract, make it possible to retain more than the predefined limit\r\n            TOKEN_HODL_9M = TokenController(owner).ethealToken().balanceOf(this).sub(TOKEN_HODL_3M).sub(TOKEN_HODL_6M).add(claimedTokens);\r\n        }\r\n        return hodlerTotalValue;\r\n    }\r\n}\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting is Ownable {\r\n  using SafeMath for uint256;\r\n  event Released(uint256 amount);\r\n  event Revoked();\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n  uint256 public cliff;\r\n  uint256 public start;\r\n  uint256 public duration;\r\n  bool public revocable;\r\n  mapping (address => uint256) public released;\r\n  mapping (address => bool) public revoked;\r\n  /**\r\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n   * of the balance will have vested.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @param _revocable whether the vesting is revocable or not\r\n   */\r\n  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) {\r\n    require(_beneficiary != address(0));\r\n    require(_cliff <= _duration);\r\n    beneficiary = _beneficiary;\r\n    revocable = _revocable;\r\n    duration = _duration;\r\n    cliff = _start.add(_cliff);\r\n    start = _start;\r\n  }\r\n  /**\r\n   * @notice Transfers vested tokens to beneficiary.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function release(ERC20MiniMe token) public {\r\n    uint256 unreleased = releasableAmount(token);\r\n    require(unreleased > 0);\r\n    released[token] = released[token].add(unreleased);\r\n    require(token.transfer(beneficiary, unreleased));\r\n    Released(unreleased);\r\n  }\r\n  /**\r\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n   * remain in the contract, the rest are returned to the owner.\r\n   * @param token ERC20MiniMe token which is being vested\r\n   */\r\n  function revoke(ERC20MiniMe token) public onlyOwner {\r\n    require(revocable);\r\n    require(!revoked[token]);\r\n    uint256 balance = token.balanceOf(this);\r\n    uint256 unreleased = releasableAmount(token);\r\n    uint256 refund = balance.sub(unreleased);\r\n    revoked[token] = true;\r\n    require(token.transfer(owner, refund));\r\n    Revoked();\r\n  }\r\n  /**\r\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n   * @param token ERC20MiniMe token which is being vested\r\n   */\r\n  function releasableAmount(ERC20MiniMe token) public view returns (uint256) {\r\n    return vestedAmount(token).sub(released[token]);\r\n  }\r\n  /**\r\n   * @dev Calculates the amount that has already vested.\r\n   * @param token ERC20MiniMe token which is being vested\r\n   */\r\n  function vestedAmount(ERC20MiniMe token) public view returns (uint256) {\r\n    uint256 currentBalance = token.balanceOf(this);\r\n    uint256 totalBalance = currentBalance.add(released[token]);\r\n    if (now < cliff) {\r\n      return 0;\r\n    } else if (now >= start.add(duration) || revoked[token]) {\r\n      return totalBalance;\r\n    } else {\r\n      return totalBalance.mul(now.sub(start)).div(duration);\r\n    }\r\n  }\r\n}\r\n/**\r\n * @title claim accidentally sent tokens\r\n */\r\ncontract HasNoTokens is Ownable {\r\n    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\r\n    /// @notice This method can be used to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    /// @param _claimer Address that tokens will be send to\r\n    function extractTokens(address _token, address _claimer) onlyOwner public {\r\n        if (_token == 0x0) {\r\n            _claimer.transfer(this.balance);\r\n            return;\r\n        }\r\n        ERC20 token = ERC20(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(_claimer, balance);\r\n        ExtractedTokens(_token, _claimer, balance);\r\n    }\r\n}\r\n/**\r\n * @title EthealController\r\n * @author thesved\r\n * @notice Controller of the Etheal Token\r\n * @dev Crowdsale can be only replaced when no active crowdsale is running.\r\n *  The contract is paused by default. It has to be unpaused to enable token transfer.\r\n */\r\ncontract EthealController is Pausable, HasNoTokens, TokenController {\r\n    using SafeMath for uint;\r\n    // when migrating this contains the address of the new controller\r\n    TokenController public newController;\r\n    // token contract\r\n    ERC20MiniMe public ethealToken;\r\n    // distribution of tokens\r\n    uint256 public constant ETHEAL_UNIT = 10**18;\r\n    uint256 public constant THOUSAND = 10**3;\r\n    uint256 public constant MILLION = 10**6;\r\n    uint256 public constant TOKEN_SALE1_PRE = 9 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_SALE1_NORMAL = 20 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_SALE2 = 9 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_SALE3 = 5 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_HODL_3M = 1 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_HODL_6M = 2 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_HODL_9M = 7 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_REFERRAL = 2 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_BOUNTY = 1500 * THOUSAND * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_COMMUNITY = 20 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_TEAM = 14 * MILLION * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_FOUNDERS = 6500 * THOUSAND * ETHEAL_UNIT;\r\n    uint256 public constant TOKEN_INVESTORS = 3 * MILLION * ETHEAL_UNIT;\r\n    // addresses only SALE will remain, the others will be real eth addresses\r\n    address public SALE = 0X1;\r\n    address public FOUNDER1 = 0x296dD2A2879fEBe2dF65f413999B28C053397fC5;\r\n    address public FOUNDER2 = 0x0E2feF8e4125ed0f49eD43C94b2B001C373F74Bf;\r\n    address public INVESTOR1 = 0xAAd27eD6c93d91aa60Dc827bE647e672d15e761A;\r\n    address public INVESTOR2 = 0xb906665f4ef609189A31CE55e01C267EC6293Aa5;\r\n    // addresses for multisig and crowdsale\r\n    address public ethealMultisigWallet;\r\n    Crowdsale public crowdsale;\r\n    // hodler reward contract\r\n    Hodler public hodlerReward;\r\n    // token grants\r\n    TokenVesting[] public tokenGrants;\r\n    uint256 public constant VESTING_TEAM_CLIFF = 365 days;\r\n    uint256 public constant VESTING_TEAM_DURATION = 4 * 365 days;\r\n    uint256 public constant VESTING_ADVISOR_CLIFF = 3 * 30 days;\r\n    uint256 public constant VESTING_ADVISOR_DURATION = 6 * 30 days;\r\n    /// @dev only the crowdsale can call it\r\n    modifier onlyCrowdsale() {\r\n        require(msg.sender == address(crowdsale));\r\n        _;\r\n    }\r\n    /// @dev only the crowdsale can call it\r\n    modifier onlyEthealMultisig() {\r\n        require(msg.sender == address(ethealMultisigWallet));\r\n        _;\r\n    }\r\n    ////////////////\r\n    // Constructor, overrides\r\n    ////////////////\r\n    /// @notice Constructor for Etheal Controller\r\n    function EthealController(address _wallet) {\r\n        require(_wallet != address(0));\r\n        paused = true;\r\n        ethealMultisigWallet = _wallet;\r\n    }\r\n    /// @dev overrides HasNoTokens#extractTokens to make it possible to extract any tokens after migration or before that any tokens except etheal\r\n    function extractTokens(address _token, address _claimer) onlyOwner public {\r\n        require(newController != address(0) || _token != address(ethealToken));\r\n        super.extractTokens(_token, _claimer);\r\n    }\r\n    ////////////////\r\n    // Manage crowdsale\r\n    ////////////////\r\n    /// @notice Set crowdsale address and transfer HEAL tokens from ethealController's SALE address\r\n    /// @dev Crowdsale can be only set when the current crowdsale is not active and ethealToken is set\r\n    function setCrowdsaleTransfer(address _sale, uint256 _amount) public onlyOwner {\r\n        require (_sale != address(0) && !isCrowdsaleOpen() && address(ethealToken) != address(0));\r\n        crowdsale = Crowdsale(_sale);\r\n        // transfer HEAL tokens to crowdsale account from the account of controller\r\n        require(ethealToken.transferFrom(SALE, _sale, _amount));\r\n    }\r\n    /// @notice Is there a not ended crowdsale?\r\n    /// @return true if there is no crowdsale or the current crowdsale is not yet ended but started\r\n    function isCrowdsaleOpen() public view returns (bool) {\r\n        return address(crowdsale) != address(0) && !crowdsale.hasEnded() && crowdsale.hasStarted();\r\n    }\r\n    ////////////////\r\n    // Manage grants\r\n    ////////////////\r\n    /// @notice Grant vesting token to an address\r\n    function createGrant(address _beneficiary, uint256 _start, uint256 _amount, bool _revocable, bool _advisor) public onlyOwner {\r\n        require(_beneficiary != address(0) && _amount > 0 && _start >= now);\r\n        // create token grant\r\n        if (_advisor) {\r\n            tokenGrants.push(new TokenVesting(_beneficiary, _start, VESTING_ADVISOR_CLIFF, VESTING_ADVISOR_DURATION, _revocable));\r\n        } else {\r\n            tokenGrants.push(new TokenVesting(_beneficiary, _start, VESTING_TEAM_CLIFF, VESTING_TEAM_DURATION, _revocable));\r\n        }\r\n        // transfer funds to the grant\r\n        transferToGrant(tokenGrants.length.sub(1), _amount);\r\n    }\r\n    /// @notice Transfer tokens to a grant until it is starting\r\n    function transferToGrant(uint256 _id, uint256 _amount) public onlyOwner {\r\n        require(_id < tokenGrants.length && _amount > 0 && now <= tokenGrants[_id].start());\r\n        // transfer funds to the grant\r\n        require(ethealToken.transfer(address(tokenGrants[_id]), _amount));\r\n    }\r\n    /// @dev Revoking grant\r\n    function revokeGrant(uint256 _id) public onlyOwner {\r\n        require(_id < tokenGrants.length);\r\n        tokenGrants[_id].revoke(ethealToken);\r\n    }\r\n    /// @notice Returns the token grant count\r\n    function getGrantCount() view public returns (uint) {\r\n        return tokenGrants.length;\r\n    }\r\n    ////////////////\r\n    // BURN, handle ownership - only multsig can call these functions!\r\n    ////////////////\r\n    /// @notice contract can burn its own or its sale tokens\r\n    function burn(address _where, uint256 _amount) public onlyEthealMultisig {\r\n        require(_where == address(this) || _where == SALE);\r\n        require(ethealToken.destroyTokens(_where, _amount));\r\n    }\r\n    /// @notice replaces controller when it was not yet replaced, only multisig can do it\r\n    function setNewController(address _controller) public onlyEthealMultisig {\r\n        require(_controller != address(0) && newController == address(0));\r\n        newController = TokenController(_controller);\r\n        ethealToken.changeController(_controller);\r\n        hodlerReward.transferOwnership(_controller);\r\n        // send eth\r\n        uint256 _stake = this.balance;\r\n        if (_stake > 0) {\r\n            _controller.transfer(_stake);\r\n        }\r\n        // send tokens\r\n        _stake = ethealToken.balanceOf(this);\r\n        if (_stake > 0) {\r\n            ethealToken.transfer(_controller, _stake);\r\n        }\r\n    }\r\n    /// @notice Set new multisig wallet, to make it upgradable.\r\n    function setNewMultisig(address _wallet) public onlyEthealMultisig {\r\n        require(_wallet != address(0));\r\n        ethealMultisigWallet = _wallet;\r\n    }\r\n    ////////////////\r\n    // When PAUSED\r\n    ////////////////\r\n    /// @notice set the token, if no hodler provided then creates a hodler reward contract\r\n    function setEthealToken(address _token, address _hodler) public onlyOwner whenPaused {\r\n        require(_token != address(0));\r\n        ethealToken = ERC20MiniMe(_token);\r\n        \r\n        if (_hodler != address(0)) {\r\n            // set hodler reward contract if provided\r\n            hodlerReward = Hodler(_hodler);\r\n        } else if (hodlerReward == address(0)) {\r\n            // create hodler reward contract if not yet created\r\n            hodlerReward = new Hodler(TOKEN_HODL_3M, TOKEN_HODL_6M, TOKEN_HODL_9M);\r\n        }\r\n        // MINT tokens if not minted yet\r\n        if (ethealToken.totalSupply() == 0) {\r\n            // sale\r\n            ethealToken.generateTokens(SALE, TOKEN_SALE1_PRE.add(TOKEN_SALE1_NORMAL).add(TOKEN_SALE2).add(TOKEN_SALE3));\r\n            // hodler reward\r\n            ethealToken.generateTokens(address(hodlerReward), TOKEN_HODL_3M.add(TOKEN_HODL_6M).add(TOKEN_HODL_9M));\r\n            // bounty + referral\r\n            ethealToken.generateTokens(owner, TOKEN_BOUNTY.add(TOKEN_REFERRAL));\r\n            // community fund\r\n            ethealToken.generateTokens(address(ethealMultisigWallet), TOKEN_COMMUNITY);\r\n            // team -> grantable\r\n            ethealToken.generateTokens(address(this), TOKEN_FOUNDERS.add(TOKEN_TEAM));\r\n            // investors\r\n            ethealToken.generateTokens(INVESTOR1, TOKEN_INVESTORS.div(3).mul(2));\r\n            ethealToken.generateTokens(INVESTOR2, TOKEN_INVESTORS.div(3));\r\n        }\r\n    }\r\n    ////////////////\r\n    // Proxy for Hodler contract\r\n    ////////////////\r\n    \r\n    /// @notice Proxy call for setting hodler start time\r\n    function setHodlerTime(uint256 _time) public onlyCrowdsale {\r\n        hodlerReward.setHodlerTime(_time);\r\n    }\r\n    /// @notice Proxy call for adding hodler stake\r\n    function addHodlerStake(address _beneficiary, uint256 _stake) public onlyCrowdsale {\r\n        hodlerReward.addHodlerStake(_beneficiary, _stake);\r\n    }\r\n    /// @notice Proxy call for setting hodler stake\r\n    function setHodlerStake(address _beneficiary, uint256 _stake) public onlyCrowdsale {\r\n        hodlerReward.setHodlerStake(_beneficiary, _stake);\r\n    }\r\n    ////////////////\r\n    // MiniMe Controller functions\r\n    ////////////////\r\n    /// @notice No eth payment to the token contract\r\n    function proxyPayment(address _owner) payable public returns (bool) {\r\n        revert();\r\n    }\r\n    /// @notice Before transfers are enabled for everyone, only this and the crowdsale contract is allowed to distribute HEAL\r\n    function onTransfer(address _from, address _to, uint256 _amount) public returns (bool) {\r\n        // moving any funds makes hodl participation invalid\r\n        hodlerReward.invalidate(_from);\r\n        return !paused || _from == address(this) || _to == address(this) || _from == address(crowdsale) || _to == address(crowdsale);\r\n    }\r\n    function onApprove(address _owner, address _spender, uint256 _amount) public returns (bool) {\r\n        return !paused;\r\n    }\r\n    /// @notice Retrieve mistakenly sent tokens (other than the etheal token) from the token contract \r\n    function claimTokenTokens(address _token) public onlyOwner {\r\n        require(_token != address(ethealToken));\r\n        ethealToken.claimTokens(_token);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_stake\",\"type\":\"uint256\"}],\"name\":\"setHodlerStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SALE1_PRE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethealToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_HODL_6M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SALE2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"revokeGrant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_HODL_9M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_BOUNTY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_hodler\",\"type\":\"address\"}],\"name\":\"setEthealToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MILLION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_revocable\",\"type\":\"bool\"},{\"name\":\"_advisor\",\"type\":\"bool\"}],\"name\":\"createGrant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VESTING_ADVISOR_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VESTING_ADVISOR_CLIFF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VESTING_TEAM_CLIFF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setNewController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsaleOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_FOUNDERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenGrants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_REFERRAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SALE1_NORMAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGrantCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethealMultisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"THOUSAND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_TEAM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHEAL_UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_stake\",\"type\":\"uint256\"}],\"name\":\"addHodlerStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_where\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferToGrant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDER2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SALE3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setNewMultisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setHodlerTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VESTING_TEAM_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_INVESTORS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokenTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVESTOR2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_COMMUNITY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sale\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setCrowdsaleTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDER1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_claimer\",\"type\":\"address\"}],\"name\":\"extractTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"proxyPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVESTOR1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_HODL_3M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ExtractedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthealController","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fc5c6c8015962e7035f3bdc5fe7ec94bedc77833","Library":"","SwarmSource":"bzzr://92a1f27c76560e9a5c435886caece0a86173198ab75681be3e0196811ebb45d3"}]}