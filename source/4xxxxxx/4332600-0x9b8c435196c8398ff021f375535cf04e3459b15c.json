{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n// Minimum version requirement\r\n\r\n\r\n\r\ncontract MPY {\r\n\r\n  function getSupply() constant returns (uint256);\r\n\r\n  /// Return address balance of tokens\r\n  function balanceOf(address _owner) constant returns (uint256);\r\n\r\n}\r\n\r\n\r\n\r\ncontract MatchPay {\r\n    /* @title Master contract. MatchPay\r\n       @param msg.sender owner address\r\n    */\r\n\r\n    struct dividend_right {\r\n      uint _total_owed;\r\n      uint _period;\r\n    }\r\n\r\n    uint genesis_date;\r\n    uint current_period;\r\n\r\n    address master;\r\n    MPY token;\r\n\r\n    bool is_payday ;\r\n    uint dividends;\r\n    mapping (address => dividend_right) dividends_redeemed;\r\n\r\n    // -------------------------------------------------------------------------------------------\r\n\r\n    // Only owner modifier\r\n    modifier only_owner_once(address _who) { require(_who == master && token == address(0)); _; }\r\n\r\n    // Is window open (first month after each genesis anniversary)\r\n    modifier is_window_open() { require( (now - genesis_date) % 31536000 <= 2592000); _; }\r\n\r\n    // Is window close\r\n    modifier is_window_close() { require( (now - genesis_date) % 31536000 > 2592000); _; }\r\n\r\n    // -------------------------------------------------------------------------------------------\r\n\r\n    event Created(address indexed _who, address indexed _to_whom, address indexed _contract_address);\r\n\r\n    // -------------------------------------------------------------------------------------------\r\n\r\n\r\n    function MatchPay() {\r\n      master = msg.sender;\r\n      genesis_date = now;\r\n      current_period = 0;\r\n      is_payday = false;\r\n    }\r\n\r\n\r\n    // Sets token address (MPY)\r\n    function setTokenAddress(address _MPYAddress) only_owner_once(msg.sender) returns (bool) {\r\n      token = MPY(_MPYAddress);\r\n\r\n      return true;\r\n    }\r\n\r\n\r\n    // Redeem dividends\r\n    function redeem(uint _amount) is_window_open() returns (bool) {\r\n      // If payday isn't flagged, flag it and freeze the dividends\r\n      if (!is_payday) {\r\n        is_payday = true;\r\n        dividends = this.balance;\r\n      }\r\n\r\n      // Check balance of sender and total balance\r\n      uint256 tokenBalance = token.balanceOf(msg.sender);\r\n      if (tokenBalance == 0) return false;\r\n      uint256 tokenSupply = token.getSupply();\r\n\r\n      // Reset amount owed if necessary\r\n      if (dividends_redeemed[msg.sender]._period != current_period) {\r\n        dividends_redeemed[msg.sender]._total_owed = 0;\r\n        dividends_redeemed[msg.sender]._period = current_period;\r\n      }\r\n\r\n      // Add _amount to total owed\r\n      dividends_redeemed[msg.sender]._total_owed += _amount;\r\n\r\n      // If proposed amount is viable, then give it to the owner\r\n      if (dividends_redeemed[msg.sender]._total_owed * tokenSupply <= dividends * tokenBalance) {\r\n        if (!msg.sender.send(_amount)) {\r\n          dividends_redeemed[msg.sender]._total_owed -= _amount;\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n\r\n    // Redeem dividends\r\n    function switch_period() is_window_close() returns (bool) {\r\n      // If payday is flagged, unflag it and reset the dividends\r\n      if (is_payday) {\r\n        is_payday = false;\r\n        dividends = 0;\r\n        current_period += 1;\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n\r\n    // Collect fees\r\n    function() payable {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_MPYAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switch_period\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to_whom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_contract_address\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"}]","ContractName":"MatchPay","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8cd110de97f4a152168e0dee6330dd7182be5392f685db95ec822ac859fdb591"}]}