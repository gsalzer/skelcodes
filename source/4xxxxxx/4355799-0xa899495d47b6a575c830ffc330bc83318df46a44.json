{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\npragma solidity ^0.4.11;\r\n\r\ncontract StakeTreeMVP {\r\n  using SafeMath for uint256;\r\n\r\n  uint public version = 1;\r\n\r\n  struct Funder {\r\n    bool exists;\r\n    uint balance;\r\n    uint withdrawalEntry;\r\n  }\r\n  mapping(address => Funder) public funders;\r\n\r\n  bool public live = true; // For sunsetting contract\r\n  uint public totalCurrentFunders = 0; // Keeps track of total funders\r\n  uint public withdrawalCounter = 0; // Keeps track of how many withdrawals have taken place\r\n  uint public sunsetWithdrawDate;\r\n \r\n  address public beneficiary; // Address for beneficiary\r\n  uint public sunsetWithdrawalPeriod; // How long it takes for beneficiary to swipe contract when put into sunset mode\r\n  uint public withdrawalPeriod; // How long the beneficiary has to wait withdraw\r\n  uint public minimumFundingAmount; // Setting used for setting minimum amounts to fund contract with\r\n  uint public lastWithdrawal; // Last withdrawal time\r\n  uint public nextWithdrawal; // Next withdrawal time\r\n\r\n  uint public contractStartTime; // For accounting purposes\r\n\r\n  function StakeTreeMVP(\r\n    address beneficiaryAddress, \r\n    uint withdrawalPeriodInit, \r\n    uint withdrawalStart, \r\n    uint sunsetWithdrawPeriodInit,\r\n    uint minimumFundingAmountInit) {\r\n\r\n    beneficiary = beneficiaryAddress;\r\n    withdrawalPeriod = withdrawalPeriodInit;\r\n    sunsetWithdrawalPeriod = sunsetWithdrawPeriodInit;\r\n\r\n    lastWithdrawal = withdrawalStart; \r\n    nextWithdrawal = lastWithdrawal + withdrawalPeriod;\r\n\r\n    minimumFundingAmount = minimumFundingAmountInit;\r\n\r\n    contractStartTime = now;\r\n  }\r\n\r\n  // Modifiers\r\n  modifier onlyByBeneficiary() {\r\n    require(msg.sender == beneficiary);\r\n    _;\r\n  }\r\n\r\n  modifier onlyByFunder() {\r\n    require(isFunder(msg.sender));\r\n    _;\r\n  }\r\n\r\n  modifier onlyAfterNextWithdrawalDate() {\r\n    require(now >= nextWithdrawal);\r\n    _;\r\n  }\r\n\r\n  modifier onlyWhenLive() {\r\n    require(live);\r\n    _;\r\n  }\r\n\r\n  modifier onlyWhenSunset() {\r\n    require(!live);\r\n    _;\r\n  }\r\n\r\n  /*\r\n  * External accounts can pay directly to contract to fund it.\r\n  */\r\n  function () payable {\r\n    fund();\r\n  }\r\n\r\n  /*\r\n  * Additional api for contracts to use as well\r\n  * Can only happen when live and over a minimum amount set by the beneficiary\r\n  */\r\n\r\n  function fund() public payable onlyWhenLive {\r\n    require(msg.value >= minimumFundingAmount);\r\n\r\n    // Only increase total funders when we have a new funder\r\n    if(!isFunder(msg.sender)) {\r\n      totalCurrentFunders = totalCurrentFunders.add(1); // Increase total funder count\r\n\r\n      funders[msg.sender] = Funder({\r\n        exists: true,\r\n        balance: msg.value,\r\n        withdrawalEntry: withdrawalCounter // Set the withdrawal counter. Ie at which withdrawal the funder \"entered\" the patronage contract\r\n      });\r\n    }\r\n    else {\r\n      // If the funder is already in the pool let's update things while we're at it\r\n      // This calculates their actual balance left and adds their top up amount\r\n      funders[msg.sender].balance = getRefundAmountForFunder(msg.sender).add(msg.value);\r\n      // Reset withdrawal counter\r\n      funders[msg.sender].withdrawalEntry = withdrawalCounter;\r\n    }\r\n  }\r\n\r\n  // Pure functions\r\n\r\n  /*\r\n  * This function calculates how much the beneficiary can withdraw.\r\n  * Due to no floating points in Solidity, we will lose some fidelity\r\n  * if there's wei on the last digit. The beneficiary loses a neglibible amount\r\n  * to withdraw but this benefits the beneficiary again on later withdrawals.\r\n  * We multiply by 10 (which corresponds to the 10%) \r\n  * then divide by 100 to get the actual part.\r\n  */\r\n  function calculateWithdrawalAmount(uint startAmount) public returns (uint){\r\n    return startAmount.mul(10).div(100); // 10%\r\n  }\r\n\r\n  /*\r\n  * This function calculates the refund amount for the funder.\r\n  * Due to no floating points in Solidity, we will lose some fidelity.\r\n  * The funder loses a neglibible amount to refund. \r\n  * The left over wei gets pooled to the fund.\r\n  */\r\n  function calculateRefundAmount(uint amount, uint withdrawalTimes) public returns (uint) {    \r\n    for(uint i=0; i<withdrawalTimes; i++){\r\n      amount = amount.mul(9).div(10);\r\n    }\r\n    return amount;\r\n  }\r\n\r\n  // Getter functions\r\n\r\n  /*\r\n  * To calculate the refund amount we look at how many times the beneficiary\r\n  * has withdrawn since the funder added their funds. \r\n  * We use that deduct 10% for each withdrawal.\r\n  */\r\n\r\n  function getRefundAmountForFunder(address addr) public constant returns (uint) {\r\n    uint amount = funders[addr].balance;\r\n    uint withdrawalTimes = getHowManyWithdrawalsForFunder(addr);\r\n    return calculateRefundAmount(amount, withdrawalTimes);\r\n  }\r\n\r\n  function getBeneficiary() public constant returns (address) {\r\n    return beneficiary;\r\n  }\r\n\r\n  function getCurrentTotalFunders() public constant returns (uint) {\r\n    return totalCurrentFunders;\r\n  }\r\n\r\n  function getWithdrawalCounter() public constant returns (uint) {\r\n    return withdrawalCounter;\r\n  }\r\n\r\n  function getWithdrawalEntryForFunder(address addr) public constant returns (uint) {\r\n    return funders[addr].withdrawalEntry;\r\n  }\r\n\r\n  function getContractBalance() public constant returns (uint256 balance) {\r\n    balance = this.balance;\r\n  }\r\n\r\n  function getFunderBalance(address funder) public constant returns (uint256) {\r\n    return getRefundAmountForFunder(funder);\r\n  }\r\n\r\n  function isFunder(address addr) public constant returns (bool) {\r\n    return funders[addr].exists;\r\n  }\r\n\r\n  function getHowManyWithdrawalsForFunder(address addr) private constant returns (uint) {\r\n    return withdrawalCounter.sub(getWithdrawalEntryForFunder(addr));\r\n  }\r\n\r\n  // State changing functions\r\n  function setMinimumFundingAmount(uint amount) external onlyByBeneficiary {\r\n    require(amount > 0);\r\n    minimumFundingAmount = amount;\r\n  }\r\n\r\n  function withdraw() external onlyByBeneficiary onlyAfterNextWithdrawalDate onlyWhenLive  {\r\n    // Check\r\n    uint amount = calculateWithdrawalAmount(this.balance);\r\n\r\n    // Effects\r\n    withdrawalCounter = withdrawalCounter.add(1);\r\n    lastWithdrawal = now; // For tracking purposes\r\n    nextWithdrawal = nextWithdrawal + withdrawalPeriod; // Fixed period increase\r\n\r\n    // Interaction\r\n    beneficiary.transfer(amount);\r\n  }\r\n\r\n  // Refunding by funder\r\n  // Only funders can refund their own funding\r\n  // Can only be sent back to the same address it was funded with\r\n  // We also remove the funder if they succesfully exit with their funds\r\n  function refund() external onlyByFunder {\r\n    // Check\r\n    uint walletBalance = this.balance;\r\n    uint amount = getRefundAmountForFunder(msg.sender);\r\n    require(amount > 0);\r\n\r\n    // Effects\r\n    removeFunder();\r\n\r\n    // Interaction\r\n    msg.sender.transfer(amount);\r\n\r\n    // Make sure this worked as intended\r\n    assert(this.balance == walletBalance-amount);\r\n  }\r\n\r\n  // Used when the funder wants to remove themselves as a funder\r\n  // without refunding. Their eth stays in the pool\r\n  function removeFunder() public onlyByFunder {\r\n    delete funders[msg.sender];\r\n    totalCurrentFunders = totalCurrentFunders.sub(1);\r\n  }\r\n\r\n  /*\r\n  * The beneficiary can decide to stop using this contract.\r\n  * They use this sunset function to put it into sunset mode.\r\n  * The beneficiary can then swipe rest of the funds after a set time\r\n  * if funders have not withdrawn their funds.\r\n  */\r\n\r\n  function sunset() external onlyByBeneficiary onlyWhenLive {\r\n    sunsetWithdrawDate = now.add(sunsetWithdrawalPeriod);\r\n    live = false;\r\n  }\r\n\r\n  function swipe(address recipient) external onlyWhenSunset onlyByBeneficiary {\r\n    require(now >= sunsetWithdrawDate);\r\n\r\n    recipient.transfer(this.balance);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"sunset\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"funders\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"withdrawalEntry\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startAmount\",\"type\":\"uint256\"}],\"name\":\"calculateWithdrawalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isFunder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinimumFundingAmount\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawalCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sunsetWithdrawalPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTotalFunders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumFundingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getRefundAmountForFunder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWithdrawalEntryForFunder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCurrentFunders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"funder\",\"type\":\"address\"}],\"name\":\"getFunderBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"swipe\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeFunder\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"withdrawalTimes\",\"type\":\"uint256\"}],\"name\":\"calculateRefundAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sunsetWithdrawDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"beneficiaryAddress\",\"type\":\"address\"},{\"name\":\"withdrawalPeriodInit\",\"type\":\"uint256\"},{\"name\":\"withdrawalStart\",\"type\":\"uint256\"},{\"name\":\"sunsetWithdrawPeriodInit\",\"type\":\"uint256\"},{\"name\":\"minimumFundingAmountInit\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"StakeTreeMVP","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000054c069bdc7ea8af577a57bdafccb097235bf07be0000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000059ddcff500000000000000000000000000000000000000000000000000000000004f1a00000000000000000000000000000000000000000000000000002386f26fc10000","Library":"","SwarmSource":"bzzr://09d5e29d7d0fc1a01ec00cbfdb0ac99ba4a1b51952b5d27771ad9080d055933a"}]}