{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract ERC20_Transferable {\r\n    function balanceOf(address addr) public returns(uint);\r\n    function transfer(address to, uint value) public returns (bool);\r\n}\r\n\r\ncontract TimeLockedRewardFaucet {\r\n\r\n    // =========== CONFIG START =========== \r\n    address constant public MULTISIG_OWNER = 0xe18Af0dDA74fC4Ee90bCB37E45b4BD623dC6e099;\r\n    address constant public TEAM_WALLET = 0x008cdC9b89AD677CEf7F2C055efC97d3606a50Bd;\r\n\r\n    ERC20_Transferable public token = ERC20_Transferable(0x7C5A0CE9267ED19B22F8cae653F198e3E8daf098);\r\n    uint  public LOCK_RELASE_TIME = now + 15 minutes; //block.timestamp(4011221) == 1499846591\r\n    uint  public WITHDRAWAL_END_TIME = LOCK_RELASE_TIME + 10 minutes;\r\n    // =========== CONFIG END ===========\r\n\r\n    address[] public team_accounts;\r\n    uint      public locked_since = 0;\r\n    uint      amount_to_distribute;\r\n\r\n    function all_team_accounts() external constant returns(address[]) {\r\n        return team_accounts;\r\n    }\r\n\r\n    function timeToUnlockDDHHMM() external constant returns(uint[3]) {\r\n        if (LOCK_RELASE_TIME > now) {\r\n            uint diff = LOCK_RELASE_TIME - now;\r\n            uint dd = diff / 1 days;\r\n            uint hh = diff % 1 days / 1 hours;\r\n            uint mm = diff % 1 hours / 1 minutes;\r\n            return [dd,hh,mm];\r\n        } else {\r\n            return [uint(0), uint(0), uint(0)];\r\n        }\r\n    }\r\n\r\n    function start() external\r\n    only(MULTISIG_OWNER)\r\n    inState(State.INIT){\r\n        locked_since = now;\r\n    }\r\n\r\n    function () payable {\r\n        msg.sender.transfer(msg.value); //pay back whole amount sent\r\n\r\n        State state = _state();\r\n        if (state==State.INIT) {\r\n            //collect addresses for payout\r\n            require(indexOf(team_accounts,msg.sender)==-1);\r\n            team_accounts.push(msg.sender);\r\n        } else if (state==State.WITHDRAWAL) {\r\n            // setup amount to distribute\r\n            if (amount_to_distribute==0) amount_to_distribute = token.balanceOf(this);\r\n            //payout processing\r\n            require(indexOf(team_accounts, msg.sender)>=0);\r\n            token.transfer(msg.sender,  amount_to_distribute / team_accounts.length);\r\n        } else if (state==State.CLOSED) {\r\n            //collect unclaimed token to team wallet\r\n            require(msg.sender == TEAM_WALLET);\r\n            var balance = token.balanceOf(this);\r\n            token.transfer(msg.sender, balance);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    enum State {INIT, LOCKED, WITHDRAWAL, CLOSED}\r\n    string[4] labels = [\"INIT\", \"LOCKED\", \"WITHDRAWAL\", \"CLOSED\"];\r\n\r\n    function _state() internal returns(State) {\r\n        if (locked_since == 0)               return State.INIT;\r\n        else if (now < LOCK_RELASE_TIME)     return State.LOCKED;\r\n        else if (now < WITHDRAWAL_END_TIME)  return State.WITHDRAWAL;\r\n        else return State.CLOSED;\r\n    }\r\n\r\n    function state() constant public returns(string) {\r\n        return labels[uint(_state())];\r\n    }\r\n\r\n    function indexOf(address[] storage addrs, address addr) internal returns (int){\r\n         for(uint i=0; i<addrs.length; ++i) {\r\n            if (addr == addrs[i]) return int(i);\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    //fails if state dosn't match\r\n    modifier inState(State s) {\r\n        if (_state() != s) revert();\r\n        _;\r\n    }\r\n\r\n    modifier only(address allowed) {\r\n        if (msg.sender != allowed) revert();\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MULTISIG_OWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked_since\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCK_RELASE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeToUnlockDDHHMM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"team_accounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"all_team_accounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"TimeLockedRewardFaucet","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bc9fc26968436bd7e35aa046c9859b103f6061d61da5a88e44322dfe765630db"}]}