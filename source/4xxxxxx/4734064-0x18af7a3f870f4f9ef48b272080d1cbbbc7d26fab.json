{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n}\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n// Created using ICO Wizard https://github.com/oraclesorg/ico-wizard by Oracles Network\r\n\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Ownable {\r\n    bool public halted;\r\n\r\n    modifier stopInEmergency {\r\n        if (halted) throw;\r\n        _;\r\n    }\r\n\r\n    modifier stopNonOwnersInEmergency {\r\n        if (halted && msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyInEmergency {\r\n        if (!halted) throw;\r\n        _;\r\n    }\r\n\r\n    // called by the owner on emergency, triggers stopped state\r\n    function halt() external onlyOwner {\r\n        halted = true;\r\n    }\r\n\r\n    // called by the owner on end of emergency, returns to normal state\r\n    function unhalt() external onlyOwner onlyInEmergency {\r\n        halted = false;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n    /* Token supply got increased and a new owner received these tokens */\r\n    event Minted(address receiver, uint amount);\r\n\r\n    /* Actual balances of token holders */\r\n    mapping(address => uint) balances;\r\n\r\n    /* approve() allowances */\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    /* Interface declaration */\r\n    function isToken() public constant returns (bool weAre) {\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require ((_value != 0) && (allowed[msg.sender][_spender] != 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n\r\n/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new contract.\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n */\r\ncontract UpgradeAgent {\r\n\r\n    uint public originalSupply;\r\n\r\n    /** Interface marker */\r\n    function isUpgradeAgent() public constant returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n}\r\n\r\n\r\n/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n */\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n    /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\r\n    address public upgradeMaster;\r\n\r\n    /** The next contract where the tokens will be migrated. */\r\n    UpgradeAgent public upgradeAgent;\r\n\r\n    /** How many tokens we have upgraded by now. */\r\n    uint256 public totalUpgraded;\r\n\r\n    /**\r\n     * Upgrade states.\r\n     *\r\n     * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n     * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n     * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n     * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n     *\r\n     */\r\n    enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n    /**\r\n     * Somebody has upgraded some of his tokens.\r\n     */\r\n    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n     * New upgrade agent available.\r\n     */\r\n    event UpgradeAgentSet(address agent);\r\n\r\n    /**\r\n     * Do not allow construction without upgrade master set.\r\n     */\r\n    function UpgradeableToken(address _upgradeMaster) {\r\n        upgradeMaster = _upgradeMaster;\r\n    }\r\n\r\n    /**\r\n     * Allow the token holder to upgrade some of their tokens to a new contract.\r\n     */\r\n    function upgrade(uint256 value) public {\r\n\r\n        UpgradeState state = getUpgradeState();\r\n        require(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading));\r\n\r\n        // Validate input value.\r\n        require (value == 0);\r\n\r\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n\r\n        // Take tokens out from circulation\r\n        totalSupply = safeSub(totalSupply, value);\r\n        totalUpgraded = safeAdd(totalUpgraded, value);\r\n\r\n        // Upgrade agent reissues the tokens\r\n        upgradeAgent.upgradeFrom(msg.sender, value);\r\n        Upgrade(msg.sender, upgradeAgent, value);\r\n    }\r\n\r\n    /**\r\n     * Set an upgrade agent that handles\r\n     */\r\n    function setUpgradeAgent(address agent) external {\r\n\r\n        require(!canUpgrade()); // The token is not yet in a state that we could think upgrading;\r\n\r\n        require(agent == 0x0);\r\n        // Only a master can designate the next agent\r\n        require(msg.sender != upgradeMaster);\r\n        // Upgrade has already begun for an agent\r\n        require(getUpgradeState() == UpgradeState.Upgrading);\r\n\r\n        upgradeAgent = UpgradeAgent(agent);\r\n\r\n        // Bad interface\r\n        require(!upgradeAgent.isUpgradeAgent());\r\n        // Make sure that token supplies match in source and target\r\n        require(upgradeAgent.originalSupply() != totalSupply);\r\n\r\n        UpgradeAgentSet(upgradeAgent);\r\n    }\r\n\r\n    /**\r\n     * Get the state of the token upgrade.\r\n     */\r\n    function getUpgradeState() public constant returns(UpgradeState) {\r\n        if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n        else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n        else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n        else return UpgradeState.Upgrading;\r\n    }\r\n\r\n    /**\r\n     * Change the upgrade master.\r\n     *\r\n     * This allows us to set a new owner for the upgrade mechanism.\r\n     */\r\n    function setUpgradeMaster(address master) public {\r\n        require(master == 0x0);\r\n        require(msg.sender != upgradeMaster);\r\n        upgradeMaster = master;\r\n    }\r\n\r\n    /**\r\n     * Child contract can enable to provide the condition when the upgrade can begun.\r\n     */\r\n    function canUpgrade() public constant returns(bool) {\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n\r\n\r\n/**\r\n * A token that can increase its supply by another contract.\r\n *\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\n *\r\n */\r\ncontract MintableTokenExt is StandardToken, Ownable {\r\n\r\n    using SMathLib for uint;\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    /** List of agents that are allowed to create new tokens */\r\n    mapping (address => bool) public mintAgents;\r\n\r\n    event MintingAgentChanged(address addr, bool state  );\r\n\r\n    /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.\r\n    * For example, for reserved tokens in percents 2.54%\r\n    * inPercentageUnit = 254\r\n    * inPercentageDecimals = 2\r\n    */\r\n    struct ReservedTokensData {\r\n        uint inTokens;\r\n        uint inPercentageUnit;\r\n        uint inPercentageDecimals;\r\n    }\r\n\r\n    mapping (address => ReservedTokensData) public reservedTokensList;\r\n    address[] public reservedTokensDestinations;\r\n    uint public reservedTokensDestinationsLen = 0;\r\n\r\n    function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) onlyOwner {\r\n        reservedTokensDestinations.push(addr);\r\n        reservedTokensDestinationsLen++;\r\n        reservedTokensList[addr] = ReservedTokensData({inTokens:inTokens, inPercentageUnit:inPercentageUnit, inPercentageDecimals: inPercentageDecimals});\r\n    }\r\n\r\n    function getReservedTokensListValInTokens(address addr) constant returns (uint inTokens) {\r\n        return reservedTokensList[addr].inTokens;\r\n    }\r\n\r\n    function getReservedTokensListValInPercentageUnit(address addr) constant returns (uint inPercentageUnit) {\r\n        return reservedTokensList[addr].inPercentageUnit;\r\n    }\r\n\r\n    function getReservedTokensListValInPercentageDecimals(address addr) constant returns (uint inPercentageDecimals) {\r\n        return reservedTokensList[addr].inPercentageDecimals;\r\n    }\r\n\r\n    function setReservedTokensListMultiple(address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals) onlyOwner {\r\n        for (uint iterator = 0; iterator < addrs.length; iterator++) {\r\n            setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create new tokens and allocate them to an address..\r\n     *\r\n     * Only callably by a crowdsale contract (mint agent).\r\n     */\r\n    function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\n        totalSupply = totalSupply.plus(amount);\r\n        balances[receiver] = balances[receiver].plus(amount);\r\n\r\n        // This will make the mint transaction apper in EtherScan.io\r\n        // We can remove this after there is a standardized minting event\r\n        Transfer(0, receiver, amount);\r\n    }\r\n\r\n    /**\r\n     * Owner can allow a crowdsale contract to mint new tokens.\r\n     */\r\n    function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n        mintAgents[addr] = state;\r\n        MintingAgentChanged(addr, state);\r\n    }\r\n\r\n    modifier onlyMintAgent() {\r\n        // Only crowdsale contracts are allowed to mint new tokens\r\n        if(!mintAgents[msg.sender]) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /** Make sure we are not done yet. */\r\n    modifier canMint() {\r\n        if(mintingFinished) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n}\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n\r\n/**\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\n */\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n    /* The finalizer contract that allows unlift the transfer limits on this token */\r\n    address public releaseAgent;\r\n\r\n    /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\r\n    bool public released = false;\r\n\r\n    /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\r\n    mapping (address => bool) public transferAgents;\r\n\r\n    /**\r\n     * Limit token transfer until the crowdsale is over.\r\n     *\r\n     */\r\n    modifier canTransfer(address _sender) {\r\n\r\n        if(!released) {\r\n            if(!transferAgents[_sender]) {\r\n                revert();\r\n            }\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Set the contract that can call release and make the token transferable.\r\n     *\r\n     * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\n     */\r\n    function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n\r\n        // We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n        releaseAgent = addr;\r\n    }\r\n\r\n    /**\r\n     * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\n     */\r\n    function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n        transferAgents[addr] = state;\r\n    }\r\n\r\n    /**\r\n     * One way function to release the tokens to the wild.\r\n     *\r\n     * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\n     */\r\n    function releaseTokenTransfer() public onlyReleaseAgent {\r\n        released = true;\r\n    }\r\n\r\n    /** The function can be called only before or after the tokens have been releasesd */\r\n    modifier inReleaseState(bool releaseState) {\r\n        if(releaseState != released) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /** The function can be called only by a whitelisted release agent. */\r\n    modifier onlyReleaseAgent() {\r\n        if(msg.sender != releaseAgent) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\n        // Call StandardToken.transfer()\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\n        // Call StandardToken.transferForm()\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BurnableToken is StandardToken {\r\n\r\n    using SMathLib for uint;\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].minus(_value);\r\n        totalSupply = totalSupply.minus(_value);\r\n        Burn(burner, _value);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * A crowdsaled token.\r\n *\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\n *\r\n * - The token transfer() is disabled until the crowdsale is over\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\n *\r\n */\r\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, BurnableToken, UpgradeableToken {\r\n\r\n    /** Name and symbol were updated. */\r\n    event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint public decimals;\r\n\r\n    /* Minimum ammount of tokens every buyer can buy. */\r\n    uint public minCap;\r\n\r\n\r\n    /**\r\n     * Construct the token.\r\n     *\r\n     * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\n     *\r\n     * @param _name Token name\r\n     * @param _symbol Token symbol - should be all caps\r\n     * @param _initialSupply How many tokens we start with\r\n     * @param _decimals Number of decimal places\r\n     * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\r\n     */\r\n    function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\r\n    UpgradeableToken(msg.sender) {\r\n\r\n        // Create any address, can be transferred\r\n        // to team multisig via changeOwner(),\r\n        // also remember to call setUpgradeMaster()\r\n        owner = msg.sender;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        totalSupply = _initialSupply;\r\n\r\n        decimals = _decimals;\r\n\r\n        minCap = _globalMinCap;\r\n\r\n        // Create initially all balance on the team multisig\r\n        balances[owner] = totalSupply;\r\n\r\n        if(totalSupply > 0) {\r\n            Minted(owner, totalSupply);\r\n        }\r\n\r\n        // No more new supply allowed after the token creation\r\n        if(!_mintable) {\r\n            mintingFinished = true;\r\n            if(totalSupply == 0) {\r\n                revert(); // Cannot create a token without supply and no minting\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When token is released to be transferable, enforce no new tokens can be created.\r\n     */\r\n    function releaseTokenTransfer() public onlyReleaseAgent {\r\n        super.releaseTokenTransfer();\r\n    }\r\n\r\n    /**\r\n     * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\n     */\r\n    function canUpgrade() public constant returns(bool) {\r\n        return released && super.canUpgrade();\r\n    }\r\n\r\n    /**\r\n     * Owner can update token information here.\r\n     *\r\n     * It is often useful to conceal the actual token association, until\r\n     * the token operations, like central issuance or reissuance have been completed.\r\n     *\r\n     * This function allows the token owner to rename the token after the operations\r\n     * have been completed and then point the audience to use the token contract.\r\n     */\r\n    function setTokenInformation(string _name, string _symbol) onlyOwner {\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        UpdatedTokenInformation(name, symbol);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MjtToken is CrowdsaleTokenExt {\r\n\r\n    uint public ownersProductCommissionInPerc = 5;\r\n\r\n    uint public operatorProductCommissionInPerc = 25;\r\n\r\n    event IndependentSellerJoined(address sellerWallet, uint amountOfTokens, address operatorWallet);\r\n    event OwnersProductAdded(address ownersWallet, uint amountOfTokens, address operatorWallet);\r\n    event OperatorProductCommissionChanged(uint _value);\r\n    event OwnersProductCommissionChanged(uint _value);\r\n\r\n\r\n    function setOperatorCommission(uint _value) public onlyOwner {\r\n        require(_value >= 0);\r\n        operatorProductCommissionInPerc = _value;\r\n        OperatorProductCommissionChanged(_value);\r\n    }\r\n\r\n    function setOwnersCommission(uint _value) public onlyOwner {\r\n        require(_value >= 0);\r\n        ownersProductCommissionInPerc = _value;\r\n        OwnersProductCommissionChanged(_value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Method called when new seller joined the program\r\n     * To avoid value lost after division, amountOfTokens must be multiple of 100\r\n     */\r\n    function independentSellerJoined(address sellerWallet, uint amountOfTokens, address operatorWallet) public onlyOwner canMint {\r\n        require(amountOfTokens > 100);\r\n        require(sellerWallet != address(0));\r\n        require(operatorWallet != address(0));\r\n\r\n        uint operatorCommission = amountOfTokens.divides(100).times(operatorProductCommissionInPerc);\r\n        uint sellerAmount = amountOfTokens.minus(operatorCommission);\r\n\r\n        if (operatorCommission > 0) {\r\n            mint(operatorWallet, operatorCommission);\r\n        }\r\n\r\n        if (sellerAmount > 0) {\r\n            mint(sellerWallet, sellerAmount);\r\n        }\r\n        IndependentSellerJoined(sellerWallet, amountOfTokens, operatorWallet);\r\n    }\r\n\r\n\r\n    /**\r\n    * Method called when owners add their own product\r\n    * To avoid value lost after division, amountOfTokens must be multiple of 100\r\n    */\r\n    function ownersProductAdded(address ownersWallet, uint amountOfTokens, address operatorWallet) public onlyOwner canMint {\r\n        require(amountOfTokens > 100);\r\n        require(ownersWallet != address(0));\r\n        require(operatorWallet != address(0));\r\n\r\n        uint ownersComission = amountOfTokens.divides(100).times(ownersProductCommissionInPerc);\r\n        uint operatorAmount = amountOfTokens.minus(ownersComission);\r\n\r\n\r\n        if (ownersComission > 0) {\r\n            mint(ownersWallet, ownersComission);\r\n        }\r\n\r\n        if (operatorAmount > 0) {\r\n            mint(operatorWallet, operatorAmount);\r\n        }\r\n\r\n        OwnersProductAdded(ownersWallet, amountOfTokens, operatorWallet);\r\n    }\r\n\r\n    function MjtToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\r\n    CrowdsaleTokenExt(_name, _symbol, _initialSupply, _decimals, _mintable, _globalMinCap) {}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Finalize agent defines what happens at the end of succeseful crowdsale.\r\n *\r\n * - Allocate tokens for founders, bounties and community\r\n * - Make tokens transferable\r\n * - etc.\r\n */\r\ncontract FinalizeAgent {\r\n\r\n    function isFinalizeAgent() public constant returns(bool) {\r\n        return true;\r\n    }\r\n\r\n    /** Return true if we can run finalizeCrowdsale() properly.\r\n     *\r\n     * This is a safety check function that doesn't allow crowdsale to begin\r\n     * unless the finalizer has been set up properly.\r\n     */\r\n    function isSane() public constant returns (bool);\r\n\r\n    /** Called once by crowdsale finalize() if the sale was success. */\r\n    function finalizeCrowdsale();\r\n\r\n}\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n/**\r\n * Interface for defining crowdsale pricing.\r\n */\r\ncontract PricingStrategy {\r\n\r\n    /** Interface declaration. */\r\n    function isPricingStrategy() public constant returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /** Self check if all references are correctly set.\r\n     *\r\n     * Checks that pricing strategy matches crowdsale parameters.\r\n     */\r\n    function isSane(address crowdsale) public constant returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Pricing tells if this is a presale purchase or not.\r\n       @param purchaser Address of the purchaser\r\n       @return False by default, true if a presale purchaser\r\n     */\r\n    function isPresalePurchase(address purchaser) public constant returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\n     *\r\n     *\r\n     * @param value - What is the value of the transaction send in as wei\r\n     * @param tokensSold - how much tokens have been sold this far\r\n     * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale\r\n     * @param msgSender - who is the investor of this transaction\r\n     * @param decimals - how many decimal units the token has\r\n     * @return Amount of tokens the investor receives\r\n     */\r\n    function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\r\n}\r\n\r\n\r\n\r\n/// @dev Time milestone based pricing with special support for pre-ico deals.\r\ncontract MilestonePricing is PricingStrategy, Ownable {\r\n\r\n    using SMathLib for uint;\r\n\r\n    uint public constant MAX_MILESTONE = 10;\r\n\r\n    // This contains all pre-ICO addresses, and their prices (weis per token)\r\n    mapping (address => uint) public preicoAddresses;\r\n\r\n    /**\r\n    * Define pricing schedule using milestones.\r\n    */\r\n    struct Milestone {\r\n\r\n        // UNIX timestamp when this milestone kicks in\r\n        uint time;\r\n\r\n        // How many tokens per satoshi you will get after this milestone has been passed\r\n        uint price;\r\n    }\r\n\r\n    // Store milestones in a fixed array, so that it can be seen in a blockchain explorer\r\n    // Milestone 0 is always (0, 0)\r\n    // (TODO: change this when we confirm dynamic arrays are explorable)\r\n    Milestone[10] public milestones;\r\n\r\n    // How many active milestones we have\r\n    uint public milestoneCount;\r\n\r\n    /// @dev Contruction, creating a list of milestones\r\n    /// @param _milestones uint[] milestones Pairs of (time, price)\r\n    function MilestonePricing(uint[] _milestones) {\r\n        // Need to have tuples, length check\r\n        if(_milestones.length % 2 == 1 || _milestones.length >= MAX_MILESTONE*2) {\r\n            throw;\r\n        }\r\n\r\n        milestoneCount = _milestones.length / 2;\r\n\r\n        uint lastTimestamp = 0;\r\n\r\n        for(uint i=0; i<_milestones.length/2; i++) {\r\n            milestones[i].time = _milestones[i*2];\r\n            milestones[i].price = _milestones[i*2+1];\r\n\r\n            // No invalid steps\r\n            if((lastTimestamp != 0) && (milestones[i].time <= lastTimestamp)) {\r\n                throw;\r\n            }\r\n\r\n            lastTimestamp = milestones[i].time;\r\n        }\r\n\r\n        // Last milestone price must be zero, terminating the crowdale\r\n        if(milestones[milestoneCount-1].price != 0) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    /// @dev This is invoked once for every pre-ICO address, set pricePerToken\r\n    ///      to 0 to disable\r\n    /// @param preicoAddress PresaleFundCollector address\r\n    /// @param pricePerToken How many weis one token cost for pre-ico investors\r\n    function setPreicoAddress(address preicoAddress, uint pricePerToken)\r\n    public\r\n    onlyOwner\r\n    {\r\n        preicoAddresses[preicoAddress] = pricePerToken;\r\n    }\r\n\r\n    /// @dev Iterate through milestones. You reach end of milestones when price = 0\r\n    /// @return tuple (time, price)\r\n    function getMilestone(uint n) public constant returns (uint, uint) {\r\n        return (milestones[n].time, milestones[n].price);\r\n    }\r\n\r\n    function getFirstMilestone() private constant returns (Milestone) {\r\n        return milestones[0];\r\n    }\r\n\r\n    function getLastMilestone() private constant returns (Milestone) {\r\n        return milestones[milestoneCount-1];\r\n    }\r\n\r\n    function getPricingStartsAt() public constant returns (uint) {\r\n        return getFirstMilestone().time;\r\n    }\r\n\r\n    function getPricingEndsAt() public constant returns (uint) {\r\n        return getLastMilestone().time;\r\n    }\r\n\r\n    function isSane(address _crowdsale) public constant returns(bool) {\r\n        CrowdsaleExt crowdsale = CrowdsaleExt(_crowdsale);\r\n        return crowdsale.startsAt() == getPricingStartsAt() && crowdsale.endsAt() == getPricingEndsAt();\r\n    }\r\n\r\n    /// @dev Get the current milestone or bail out if we are not in the milestone periods.\r\n    /// @return {[type]} [description]\r\n    function getCurrentMilestone() private constant returns (Milestone) {\r\n        uint i;\r\n\r\n        for(i=0; i<milestones.length; i++) {\r\n            if(now < milestones[i].time) {\r\n                return milestones[i-1];\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Get the current price.\r\n    /// @return The current price or 0 if we are outside milestone period\r\n    function getCurrentPrice() public constant returns (uint result) {\r\n        return getCurrentMilestone().price;\r\n    }\r\n\r\n    /// @dev Calculate the current price for buy in amount.\r\n    function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) {\r\n\r\n        uint multiplier = 10 ** decimals;\r\n\r\n        // This investor is coming through pre-ico\r\n        if(preicoAddresses[msgSender] > 0) {\r\n            return value.times(multiplier) / preicoAddresses[msgSender];\r\n        }\r\n\r\n        uint price = getCurrentPrice();\r\n        return value.times(multiplier) / price;\r\n    }\r\n\r\n    function isPresalePurchase(address purchaser) public constant returns (bool) {\r\n        if(preicoAddresses[purchaser] > 0)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    function() payable {\r\n        throw; // No money on this contract\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * A token that defines fractional units as decimals.\r\n */\r\ncontract FractionalERC20Ext is ERC20 {\r\n\r\n    uint public decimals;\r\n    uint public minCap;\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * Abstract base contract for token sales.\r\n *\r\n * Handle\r\n * - start and end dates\r\n * - accepting investments\r\n * - minimum funding goal and refund\r\n * - various statistics during the crowdfund\r\n * - different pricing strategies\r\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\r\n *\r\n */\r\ncontract CrowdsaleExt is Haltable {\r\n\r\n    /* Max investment count when we are still allowed to change the multisig address */\r\n    uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\r\n\r\n    using SMathLib for uint;\r\n\r\n    /* The token we are selling */\r\n    FractionalERC20Ext public token;\r\n\r\n    /* How we are going to price our offering */\r\n    MilestonePricing public pricingStrategy;\r\n\r\n    /* Post-success callback */\r\n    FinalizeAgent public finalizeAgent;\r\n\r\n    /* tokens will be transfered from this address */\r\n    address public multisigWallet;\r\n\r\n    /* if the funding goal is not reached, investors may withdraw their funds */\r\n    uint public minimumFundingGoal;\r\n\r\n    /* the UNIX timestamp start date of the crowdsale */\r\n    uint public startsAt;\r\n\r\n    /* the UNIX timestamp end date of the crowdsale */\r\n    uint public endsAt;\r\n\r\n    /* the number of tokens already sold through this contract*/\r\n    uint public tokensSold = 0;\r\n\r\n    /* How many wei of funding we have raised */\r\n    uint public weiRaised = 0;\r\n\r\n    /* Calculate incoming funds from presale contracts and addresses */\r\n    uint public presaleWeiRaised = 0;\r\n\r\n    /* How many distinct addresses have invested */\r\n    uint public investorCount = 0;\r\n\r\n    /* How much wei we have returned back to the contract after a failed crowdfund. */\r\n    uint public loadedRefund = 0;\r\n\r\n    /* How much wei we have given back to investors.*/\r\n    uint public weiRefunded = 0;\r\n\r\n    /* Has this crowdsale been finalized */\r\n    bool public finalized;\r\n\r\n    /* Do we need to have unique contributor id for each customer */\r\n    bool public requireCustomerId;\r\n\r\n    bool public isWhiteListed;\r\n\r\n    address[] public joinedCrowdsales;\r\n    uint public joinedCrowdsalesLen = 0;\r\n\r\n    address public lastCrowdsale;\r\n\r\n    /**\r\n      * Do we verify that contributor has been cleared on the server side (accredited investors only).\r\n      * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web).\r\n      */\r\n    bool public requiredSignedAddress;\r\n\r\n    /* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale */\r\n    address public signerAddress;\r\n\r\n    /** How much ETH each address has invested to this crowdsale */\r\n    mapping (address => uint256) public investedAmountOf;\r\n\r\n    /** How much tokens this crowdsale has credited for each investor address */\r\n    mapping (address => uint256) public tokenAmountOf;\r\n\r\n    struct WhiteListData {\r\n        bool status;\r\n        uint minCap;\r\n        uint maxCap;\r\n    }\r\n\r\n    //is crowdsale updatable\r\n    bool public isUpdatable;\r\n\r\n    /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\r\n    mapping (address => WhiteListData) public earlyParticipantWhitelist;\r\n\r\n    /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\r\n    uint public ownerTestValue;\r\n\r\n    /** State machine\r\n     *\r\n     * - Preparing: All contract initialization calls and variables have not been set yet\r\n     * - Prefunding: We have not passed start time yet\r\n     * - Funding: Active crowdsale\r\n     * - Success: Minimum funding goal reached\r\n     * - Failure: Minimum funding goal not reached before ending time\r\n     * - Finalized: The finalized has been called and succesfully executed\r\n     * - Refunding: Refunds are loaded on the contract for reclaim.\r\n     */\r\n    enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\n\r\n    // A new investment was made\r\n    event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\n\r\n    // Refund was processed for a contributor\r\n    event Refund(address investor, uint weiAmount);\r\n\r\n    // The rules were changed what kind of investments we accept\r\n    event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\r\n\r\n    // Address early participation whitelist status changed\r\n    event Whitelisted(address addr, bool status);\r\n\r\n    // Crowdsale start time has been changed\r\n    event StartsAtChanged(uint newStartsAt);\r\n\r\n    // Crowdsale end time has been changed\r\n    event EndsAtChanged(uint newEndsAt);\r\n\r\n    function CrowdsaleExt(address _token, MilestonePricing _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\r\n\r\n        owner = msg.sender;\r\n\r\n        token = FractionalERC20Ext(_token);\r\n\r\n        setPricingStrategy(_pricingStrategy);\r\n\r\n        multisigWallet = _multisigWallet;\r\n        if(multisigWallet == 0) {\r\n            throw;\r\n        }\r\n\r\n        if(_start == 0) {\r\n            throw;\r\n        }\r\n\r\n        startsAt = _start;\r\n\r\n        if(_end == 0) {\r\n            throw;\r\n        }\r\n\r\n        endsAt = _end;\r\n\r\n        // Don't mess the dates\r\n        if(startsAt >= endsAt) {\r\n            throw;\r\n        }\r\n\r\n        // Minimum funding goal can be zero\r\n        minimumFundingGoal = _minimumFundingGoal;\r\n\r\n        isUpdatable = _isUpdatable;\r\n\r\n        isWhiteListed = _isWhiteListed;\r\n    }\r\n\r\n    /**\r\n     * Don't expect to just send in money and get tokens.\r\n     */\r\n    function() payable {\r\n        throw;\r\n    }\r\n\r\n    /**\r\n     * Make an investment.\r\n     *\r\n     * Crowdsale must be running for one to invest.\r\n     * We must have not pressed the emergency brake.\r\n     *\r\n     * @param receiver The Ethereum address who receives the tokens\r\n     * @param customerId (optional) UUID v4 to track the successful payments on the server side\r\n     *\r\n     */\r\n    function investInternal(address receiver, uint128 customerId) stopInEmergency private {\r\n\r\n        // Determine if it's a good time to accept investment from this participant\r\n        if(getState() == State.PreFunding) {\r\n            // Are we whitelisted for early deposit\r\n            throw;\r\n        } else if(getState() == State.Funding) {\r\n            // Retail participants can only come in when the crowdsale is running\r\n            // pass\r\n            if(isWhiteListed) {\r\n                if(!earlyParticipantWhitelist[receiver].status) {\r\n                    throw;\r\n                }\r\n            }\r\n        } else {\r\n            // Unwanted state\r\n            throw;\r\n        }\r\n\r\n        uint weiAmount = msg.value;\r\n\r\n        // Account presale sales separately, so that they do not count against pricing tranches\r\n        uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\r\n\r\n        if(tokenAmount == 0) {\r\n            // Dust transaction\r\n            throw;\r\n        }\r\n\r\n        if(isWhiteListed) {\r\n            if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\r\n                // tokenAmount < minCap for investor\r\n                throw;\r\n            }\r\n            if(tokenAmount > earlyParticipantWhitelist[receiver].maxCap) {\r\n                // tokenAmount > maxCap for investor\r\n                throw;\r\n            }\r\n\r\n            // Check that we did not bust the investor's cap\r\n            if (isBreakingInvestorCap(receiver, tokenAmount)) {\r\n                throw;\r\n            }\r\n        } else {\r\n            if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\r\n                throw;\r\n            }\r\n        }\r\n\r\n        if(investedAmountOf[receiver] == 0) {\r\n            // A new investor\r\n            investorCount++;\r\n        }\r\n\r\n        // Update investor\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\n\r\n        // Update totals\r\n        weiRaised = weiRaised.plus(weiAmount);\r\n        tokensSold = tokensSold.plus(tokenAmount);\r\n\r\n        if(pricingStrategy.isPresalePurchase(receiver)) {\r\n            presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\r\n        }\r\n\r\n        // Check that we did not bust the cap\r\n        if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\r\n            throw;\r\n        }\r\n\r\n        assignTokens(receiver, tokenAmount);\r\n\r\n        // Pocket the money\r\n        if(!multisigWallet.send(weiAmount)) throw;\r\n\r\n        if (isWhiteListed) {\r\n            uint num = 0;\r\n            for (var i = 0; i < joinedCrowdsalesLen; i++) {\r\n                if (this == joinedCrowdsales[i])\r\n                    num = i;\r\n            }\r\n\r\n            if (num + 1 < joinedCrowdsalesLen) {\r\n                for (var j = num + 1; j < joinedCrowdsalesLen; j++) {\r\n                    CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\r\n                    crowdsale.updateEarlyParicipantWhitelist(msg.sender, this, tokenAmount);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Tell us invest was success\r\n        Invested(receiver, weiAmount, tokenAmount, customerId);\r\n    }\r\n\r\n    /**\r\n     * Preallocate tokens for the early investors.\r\n     *\r\n     * Preallocated tokens have been sold before the actual crowdsale opens.\r\n     * This function mints the tokens and moves the crowdsale needle.\r\n     *\r\n     * Investor count is not handled; it is assumed this goes for multiple investors\r\n     * and the token distribution happens outside the smart contract flow.\r\n     *\r\n     * No money is exchanged, as the crowdsale team already have received the payment.\r\n     *\r\n     * @param fullTokens tokens as full tokens - decimal places added internally\r\n     * @param weiPrice Price of a single full token in wei\r\n     *\r\n     */\r\n    function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\r\n\r\n        uint tokenAmount = fullTokens * 10**token.decimals();\r\n        uint weiAmount = weiPrice * fullTokens; // This can be also 0, we give out tokens for free\r\n\r\n        weiRaised = weiRaised.plus(weiAmount);\r\n        tokensSold = tokensSold.plus(tokenAmount);\r\n\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\n\r\n        assignTokens(receiver, tokenAmount);\r\n\r\n        // Tell us invest was success\r\n        Invested(receiver, weiAmount, tokenAmount, 0);\r\n    }\r\n\r\n    /**\r\n     * Allow anonymous contributions to this crowdsale.\r\n     */\r\n    function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\n        bytes32 hash = sha256(addr);\r\n        if (ecrecover(hash, v, r, s) != signerAddress) throw;\r\n        if(customerId == 0) throw;  // UUIDv4 sanity check\r\n        investInternal(addr, customerId);\r\n    }\r\n\r\n    /**\r\n     * Track who is the customer making the payment so we can send thank you email.\r\n     */\r\n    function investWithCustomerId(address addr, uint128 customerId) public payable {\r\n        if(requiredSignedAddress) throw; // Crowdsale allows only server-side signed participants\r\n        if(customerId == 0) throw;  // UUIDv4 sanity check\r\n        investInternal(addr, customerId);\r\n    }\r\n\r\n    /**\r\n     * Allow anonymous contributions to this crowdsale.\r\n     */\r\n    function invest(address addr) public payable {\r\n        if(requireCustomerId) throw; // Crowdsale needs to track participants for thank you email\r\n        if(requiredSignedAddress) throw; // Crowdsale allows only server-side signed participants\r\n        investInternal(addr, 0);\r\n    }\r\n\r\n    /**\r\n     * Invest to tokens, recognize the payer and clear his address.\r\n     *\r\n     */\r\n    function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\r\n        investWithSignedAddress(msg.sender, customerId, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * Invest to tokens, recognize the payer.\r\n     *\r\n     */\r\n    function buyWithCustomerId(uint128 customerId) public payable {\r\n        investWithCustomerId(msg.sender, customerId);\r\n    }\r\n\r\n    /**\r\n     * The basic entry point to participate the crowdsale process.\r\n     *\r\n     * Pay for funding, get invested tokens back in the sender address.\r\n     */\r\n    function buy() public payable {\r\n        invest(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Finalize a succcesful crowdsale.\r\n     *\r\n     * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\r\n     */\r\n    function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\n\r\n        // Already finalized\r\n        if(finalized) {\r\n            throw;\r\n        }\r\n\r\n        // Finalizing is optional. We only call it if we are given a finalizing agent.\r\n        if(address(finalizeAgent) != 0) {\r\n            finalizeAgent.finalizeCrowdsale();\r\n        }\r\n\r\n        finalized = true;\r\n    }\r\n\r\n    /**\r\n     * Allow to (re)set finalize agent.\r\n     *\r\n     * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\r\n     */\r\n    function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\r\n        finalizeAgent = addr;\r\n\r\n        // Don't allow setting bad agent\r\n        if(!finalizeAgent.isFinalizeAgent()) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set policy do we need to have server-side customer ids for the investments.\r\n     *\r\n     */\r\n    function setRequireCustomerId(bool value) onlyOwner {\r\n        requireCustomerId = value;\r\n        InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n    }\r\n\r\n    /**\r\n     * Set policy if all investors must be cleared on the server side first.\r\n     *\r\n     * This is e.g. for the accredited investor clearing.\r\n     *\r\n     */\r\n    function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\r\n        requiredSignedAddress = value;\r\n        signerAddress = _signerAddress;\r\n        InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\r\n    }\r\n\r\n    /**\r\n     * Allow addresses to do early participation.\r\n     *\r\n     * TODO: Fix spelling error in the name\r\n     */\r\n    function setEarlyParicipantWhitelist(address addr, bool status, uint minCap, uint maxCap) onlyOwner {\r\n        if (!isWhiteListed) throw;\r\n        earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\r\n        Whitelisted(addr, status);\r\n    }\r\n\r\n    function setEarlyParicipantsWhitelist(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) onlyOwner {\r\n        if (!isWhiteListed) throw;\r\n        for (uint iterator = 0; iterator < addrs.length; iterator++) {\r\n            setEarlyParicipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\r\n        }\r\n    }\r\n\r\n    function updateEarlyParicipantWhitelist(address addr, address contractAddr, uint tokensBought) {\r\n        if (tokensBought < earlyParticipantWhitelist[addr].minCap) throw;\r\n        if (!isWhiteListed) throw;\r\n        if (addr != msg.sender && contractAddr != msg.sender) throw;\r\n        uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\r\n        newMaxCap = newMaxCap.minus(tokensBought);\r\n        earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\r\n    }\r\n\r\n    function updateJoinedCrowdsales(address addr) onlyOwner {\r\n        joinedCrowdsales[joinedCrowdsalesLen++] = addr;\r\n    }\r\n\r\n    function setLastCrowdsale(address addr) onlyOwner {\r\n        lastCrowdsale = addr;\r\n    }\r\n\r\n    function clearJoinedCrowdsales() onlyOwner {\r\n        joinedCrowdsalesLen = 0;\r\n    }\r\n\r\n    function updateJoinedCrowdsalesMultiple(address[] addrs) onlyOwner {\r\n        clearJoinedCrowdsales();\r\n        for (uint iter = 0; iter < addrs.length; iter++) {\r\n            if(joinedCrowdsalesLen == joinedCrowdsales.length) {\r\n                joinedCrowdsales.length += 1;\r\n            }\r\n            joinedCrowdsales[joinedCrowdsalesLen++] = addrs[iter];\r\n            if (iter == addrs.length - 1)\r\n                setLastCrowdsale(addrs[iter]);\r\n        }\r\n    }\r\n\r\n    function setStartsAt(uint time) onlyOwner {\r\n        if (finalized) throw;\r\n\r\n        if (!isUpdatable) throw;\r\n\r\n        if(now > time) {\r\n            throw; // Don't change past\r\n        }\r\n\r\n        if(time > endsAt) {\r\n            throw;\r\n        }\r\n\r\n        CrowdsaleExt lastCrowdsaleCntrct = CrowdsaleExt(lastCrowdsale);\r\n        if (lastCrowdsaleCntrct.finalized()) throw;\r\n\r\n        startsAt = time;\r\n        StartsAtChanged(startsAt);\r\n    }\r\n\r\n    /**\r\n     * Allow crowdsale owner to close early or extend the crowdsale.\r\n     *\r\n     * This is useful e.g. for a manual soft cap implementation:\r\n     * - after X amount is reached determine manual closing\r\n     *\r\n     * This may put the crowdsale to an invalid state,\r\n     * but we trust owners know what they are doing.\r\n     *\r\n     */\r\n    function setEndsAt(uint time) onlyOwner {\r\n        if (finalized) throw;\r\n\r\n        if (!isUpdatable) throw;\r\n\r\n        if(now > time) {\r\n            throw; // Don't change past\r\n        }\r\n\r\n        if(startsAt > time) {\r\n            throw;\r\n        }\r\n\r\n        CrowdsaleExt lastCrowdsaleCntrct = CrowdsaleExt(lastCrowdsale);\r\n        if (lastCrowdsaleCntrct.finalized()) throw;\r\n\r\n        uint num = 0;\r\n        for (var i = 0; i < joinedCrowdsalesLen; i++) {\r\n            if (this == joinedCrowdsales[i])\r\n                num = i;\r\n        }\r\n\r\n        if (num + 1 < joinedCrowdsalesLen) {\r\n            for (var j = num + 1; j < joinedCrowdsalesLen; j++) {\r\n                CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\r\n                if (time > crowdsale.startsAt()) throw;\r\n            }\r\n        }\r\n\r\n        endsAt = time;\r\n        EndsAtChanged(endsAt);\r\n    }\r\n\r\n    /**\r\n     * Allow to (re)set pricing strategy.\r\n     *\r\n     * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\n     */\r\n    function setPricingStrategy(MilestonePricing _pricingStrategy) onlyOwner {\r\n        pricingStrategy = _pricingStrategy;\r\n\r\n        // Don't allow setting bad agent\r\n        if(!pricingStrategy.isPricingStrategy()) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allow to change the team multisig address in the case of emergency.\r\n     *\r\n     * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\r\n     * (we have done only few test transactions). After the crowdsale is going\r\n     * then multisig address stays locked for the safety reasons.\r\n     */\r\n    function setMultisig(address addr) public onlyOwner {\r\n\r\n        // Change\r\n        if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\r\n            throw;\r\n        }\r\n\r\n        multisigWallet = addr;\r\n    }\r\n\r\n    /**\r\n     * Allow load refunds back on the contract for the refunding.\r\n     *\r\n     * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\n     */\r\n    function loadRefund() public payable inState(State.Failure) {\r\n        if(msg.value == 0) throw;\r\n        loadedRefund = loadedRefund.plus(msg.value);\r\n    }\r\n\r\n    /**\r\n     * Investors can claim refund.\r\n     *\r\n     * Note that any refunds from proxy buyers should be handled separately,\r\n     * and not through this contract.\r\n     */\r\n    function refund() public inState(State.Refunding) {\r\n        uint256 weiValue = investedAmountOf[msg.sender];\r\n        if (weiValue == 0) throw;\r\n        investedAmountOf[msg.sender] = 0;\r\n        weiRefunded = weiRefunded.plus(weiValue);\r\n        Refund(msg.sender, weiValue);\r\n        if (!msg.sender.send(weiValue)) throw;\r\n    }\r\n\r\n    /**\r\n     * @return true if the crowdsale has raised enough money to be a successful.\r\n     */\r\n    function isMinimumGoalReached() public constant returns (bool reached) {\r\n        return weiRaised >= minimumFundingGoal;\r\n    }\r\n\r\n    /**\r\n     * Check if the contract relationship looks good.\r\n     */\r\n    function isFinalizerSane() public constant returns (bool sane) {\r\n        return finalizeAgent.isSane();\r\n    }\r\n\r\n    /**\r\n     * Check if the contract relationship looks good.\r\n     */\r\n    function isPricingSane() public constant returns (bool sane) {\r\n        return pricingStrategy.isSane(address(this));\r\n    }\r\n\r\n    /**\r\n     * Crowdfund state machine management.\r\n     *\r\n     * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\r\n     */\r\n    function getState() public constant returns (State) {\r\n        if(finalized) return State.Finalized;\r\n        else if (address(finalizeAgent) == 0) return State.Preparing;\r\n        else if (!finalizeAgent.isSane()) return State.Preparing;\r\n        else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\r\n        else if (block.timestamp < startsAt) return State.PreFunding;\r\n        else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\n        else if (isMinimumGoalReached()) return State.Success;\r\n        else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\r\n        else return State.Failure;\r\n    }\r\n\r\n    /** This is for manual testing of multisig wallet interaction */\r\n    function setOwnerTestValue(uint val) onlyOwner {\r\n        ownerTestValue = val;\r\n    }\r\n\r\n    /** Interface marker. */\r\n    function isCrowdsale() public constant returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Modifiers\r\n    //\r\n\r\n    /** Modified allowing execution only if the crowdsale is currently running.  */\r\n    modifier inState(State state) {\r\n        if(getState() != state) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    //\r\n    // Abstract functions\r\n    //\r\n\r\n    /**\r\n     * Check if the current invested breaks our cap rules.\r\n     *\r\n     *\r\n     * The child contract must define their own cap setting rules.\r\n     * We allow a lot of flexibility through different capping strategies (ETH, token count)\r\n     * Called from invest().\r\n     *\r\n     * @param weiAmount The amount of wei the investor tries to invest in the current transaction\r\n     * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction\r\n     * @param weiRaisedTotal What would be our total raised balance after this transaction\r\n     * @param tokensSoldTotal What would be our total sold tokens count after this transaction\r\n     *\r\n     * @return true if taking this investment would break our cap rules\r\n     */\r\n    function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\r\n\r\n    function isBreakingInvestorCap(address receiver, uint tokenAmount) constant returns (bool limitBroken);\r\n\r\n    /**\r\n     * Check if the current crowdsale is full and we can no longer sell any tokens.\r\n     */\r\n    function isCrowdsaleFull() public constant returns (bool);\r\n\r\n    /**\r\n     * Create new tokens or transfer issued tokens to the investor depending on the cap model.\r\n     */\r\n    function assignTokens(address receiver, uint tokenAmount) private;\r\n}\r\n\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\r\n\r\n    /* Maximum amount of tokens this crowdsale can sell. */\r\n    uint public maximumSellableTokens;\r\n\r\n    function MintedTokenCappedCrowdsaleExt(address _token, MilestonePricing _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens, bool _isUpdatable, bool _isWhiteListed) CrowdsaleExt(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\r\n        maximumSellableTokens = _maximumSellableTokens;\r\n    }\r\n\r\n    // Crowdsale maximumSellableTokens has been changed\r\n    event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\r\n\r\n    /**\r\n     * Called from invest() to confirm if the curret investment does not break our cap rule.\r\n     */\r\n    function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\r\n        return tokensSoldTotal > maximumSellableTokens;\r\n    }\r\n\r\n    function isBreakingInvestorCap(address addr, uint tokenAmount) constant returns (bool limitBroken) {\r\n        if (!isWhiteListed) throw;\r\n        uint maxCap = earlyParticipantWhitelist[addr].maxCap;\r\n        return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\r\n    }\r\n\r\n    function isCrowdsaleFull() public constant returns (bool) {\r\n        return tokensSold >= maximumSellableTokens;\r\n    }\r\n\r\n    /**\r\n     * Dynamically create tokens and assign them to the investor.\r\n     */\r\n    function assignTokens(address receiver, uint tokenAmount) private {\r\n        CrowdsaleTokenExt mintableToken = CrowdsaleTokenExt(token);\r\n        mintableToken.mint(receiver, tokenAmount);\r\n    }\r\n\r\n    function setMaximumSellableTokens(uint tokens) onlyOwner {\r\n        if (finalized) throw;\r\n\r\n        if (!isUpdatable) throw;\r\n\r\n        CrowdsaleExt lastCrowdsaleCntrct = CrowdsaleExt(lastCrowdsale);\r\n        if (lastCrowdsaleCntrct.finalized()) throw;\r\n\r\n        maximumSellableTokens = tokens;\r\n        MaximumSellableTokensChanged(maximumSellableTokens);\r\n    }\r\n}\r\n\r\n/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n */\r\n\r\n\r\n\r\n/**\r\n * Safe unsigned safe math.\r\n *\r\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\n *\r\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\r\n *\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\n *\r\n */\r\nlibrary SMathLib {\r\n\r\n    function times(uint a, uint b) returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function divides(uint a, uint b) returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function minus(uint a, uint b) returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function plus(uint a, uint b) returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a);\r\n        return c;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ownerTestValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requireCustomerId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"isBreakingInvestorCap\",\"outputs\":[{\"name\":\"limitBroken\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"updateJoinedCrowdsalesMultiple\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPricingSane\",\"outputs\":[{\"name\":\"sane\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"},{\"name\":\"minCap\",\"type\":\"uint256\"},{\"name\":\"maxCap\",\"type\":\"uint256\"}],\"name\":\"setEarlyParicipantWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isUpdatable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumFundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFinalizeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"customerId\",\"type\":\"uint128\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"investWithSignedAddress\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setMaximumSellableTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"fullTokens\",\"type\":\"uint256\"},{\"name\":\"weiPrice\",\"type\":\"uint256\"}],\"name\":\"preallocate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumSellableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pricingStrategy\",\"type\":\"address\"}],\"name\":\"setPricingStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setLastCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setEndsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricingStrategy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loadedRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"statuses\",\"type\":\"bool[]\"},{\"name\":\"minCaps\",\"type\":\"uint256[]\"},{\"name\":\"maxCaps\",\"type\":\"uint256[]\"}],\"name\":\"setEarlyParicipantsWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinimumGoalReached\",\"outputs\":[{\"name\":\"reached\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setRequireCustomerId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clearJoinedCrowdsales\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"loadRefund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setOwnerTestValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"customerId\",\"type\":\"uint128\"}],\"name\":\"buyWithCustomerId\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"weiRaisedTotal\",\"type\":\"uint256\"},{\"name\":\"tokensSoldTotal\",\"type\":\"uint256\"}],\"name\":\"isBreakingCap\",\"outputs\":[{\"name\":\"limitBroken\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalizerSane\",\"outputs\":[{\"name\":\"sane\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"joinedCrowdsales\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setStartsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyParticipantWhitelist\",\"outputs\":[{\"name\":\"status\",\"type\":\"bool\"},{\"name\":\"minCap\",\"type\":\"uint256\"},{\"name\":\"maxCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requiredSignedAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"contractAddr\",\"type\":\"address\"},{\"name\":\"tokensBought\",\"type\":\"uint256\"}],\"name\":\"updateEarlyParicipantWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsaleFull\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"updateJoinedCrowdsales\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joinedCrowdsalesLen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"},{\"name\":\"_signerAddress\",\"type\":\"address\"}],\"name\":\"setRequireSignedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWhiteListed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"customerId\",\"type\":\"uint128\"}],\"name\":\"investWithCustomerId\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setMultisig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"customerId\",\"type\":\"uint128\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyWithSignedAddress\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_pricingStrategy\",\"type\":\"address\"},{\"name\":\"_multisigWallet\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_minimumFundingGoal\",\"type\":\"uint256\"},{\"name\":\"_maximumSellableTokens\",\"type\":\"uint256\"},{\"name\":\"_isUpdatable\",\"type\":\"bool\"},{\"name\":\"_isWhiteListed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMaximumSellableTokens\",\"type\":\"uint256\"}],\"name\":\"MaximumSellableTokensChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customerId\",\"type\":\"uint128\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequireCustomerId\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"newRequiredSignedAddress\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"newSignerAddress\",\"type\":\"address\"}],\"name\":\"InvestmentPolicyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newStartsAt\",\"type\":\"uint256\"}],\"name\":\"StartsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newEndsAt\",\"type\":\"uint256\"}],\"name\":\"EndsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MintedTokenCappedCrowdsaleExt","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003ef1d9870c18e24547aeb02461497fb052eff111000000000000000000000000e4794ce9a320e5af673c7900af6a497a3bd800b90000000000000000000000000620badf7df2b5f52738091436ef9614e7b4a38d000000000000000000000000000000000000000000000000000000005a39ee50000000000000000000000000000000000000000000000000000000005a7541d000000000000000000000000000000000000000000000a968163f0a57b4000000000000000000000000000000000000000000000000084595161401484a00000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000","Library":"SMathLib:cD1279F36dbfd19d7aD917F5D86e375a8d7C970d","SwarmSource":"bzzr://0126d7c3aeda1c9834c08929e214742203b5f118e707d4d5e9a06784ea024221"}]}