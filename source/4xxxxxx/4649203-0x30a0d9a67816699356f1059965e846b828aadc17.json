{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control \r\n * functions, this simplifies the implementation of \"user permissions\". \r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /** \r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner. \r\n   */\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to. \r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value);\r\n  function approve(address spender, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n\r\ncontract ACFToken is StandardToken {\r\n\r\n    string public name = \"ArtCoinFund\";\r\n    string public symbol = \"ACF\";\r\n    uint256 public decimals = 18;\r\n    uint256 public INITIAL_SUPPLY = 750000 * 10**18;\r\n\r\n    function ACFToken() {\r\n        totalSupply = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n    }\r\n\r\n}\r\n\r\npragma solidity ^0.4.11;\r\n\r\n\r\n\r\ncontract ACFSale is Ownable{\r\n\r\n    uint public startTime = 1512064800;   // unix ts in which the sale starts.\r\n    uint public endTime = 1517356800;     // unix ts in which the sale end.\r\n\r\n    address public ACFWallet;           // The address to hold the funds donated\r\n\r\n    uint public totalCollected = 0;     // In wei\r\n    bool public saleStopped = false;    // Has ACF  stopped the sale?\r\n    bool public saleFinalized = false;  // Has ACF  finalized the sale?\r\n\r\n    ACFToken public token;              // The token\r\n\r\n    uint constant public minInvestment = 0.1 ether;    // Minimum investment  0,1 ETH\r\n\r\n    /** Addresses that are allowed to invest even before ICO opens. For testing, for ICO partners, etc. */\r\n    mapping (address => bool) public whitelist;\r\n\r\n    event NewBuyer(address indexed holder, uint256 ACFAmount, uint256 amount);\r\n    // Address early participation whitelist status changed\r\n    event Whitelisted(address addr, bool status);\r\n\r\n\r\n    function ACFSale (\r\n    address _token,\r\n    address _ACFWallet\r\n    )\r\n    {\r\n        token = ACFToken(_token);\r\n        ACFWallet = _ACFWallet;\r\n        // add wallet as whitelisted\r\n        setWhitelistStatus(ACFWallet, true);\r\n        transferOwnership(ACFWallet);\r\n    }\r\n\r\n    // change whitelist status for a specific address\r\n    function setWhitelistStatus(address addr, bool status)\r\n    onlyOwner {\r\n        whitelist[addr] = status;\r\n        Whitelisted(addr, status);\r\n    }\r\n\r\n    // Get the rate for a ACF token 1 ACF = 0.05 ETH -> 20 ACF = 1 ETH\r\n    function getRate() constant public returns (uint256) {\r\n        return 10;\r\n    }\r\n\r\n    /**\r\n        * Get the amount of unsold tokens allocated to this contract;\r\n    */\r\n    function getTokensLeft() public constant returns (uint) {\r\n        return token.balanceOf(this);\r\n    }\r\n\r\n    function () public payable {\r\n        doPayment(msg.sender);\r\n    }\r\n\r\n    function doPayment(address _owner)\r\n    only_during_sale_period_or_whitelisted(_owner)\r\n    only_sale_not_stopped\r\n    non_zero_address(_owner)\r\n    minimum_value(minInvestment)\r\n    internal {\r\n\r\n        uint256 tokensLeft = getTokensLeft();\r\n\r\n        if(tokensLeft <= 0) throw;\r\n\r\n        // Calculate how many tokens at current price\r\n        uint256 tokenAmount = SafeMath.mul(msg.value, getRate());\r\n        // do not allow selling more than what we have\r\n        if(tokenAmount > tokensLeft) throw;\r\n\r\n        if (!ACFWallet.send(msg.value)) throw;\r\n\r\n        // transfer token (it will throw error if transaction is not valid)\r\n        token.transfer(_owner, tokenAmount);\r\n\r\n        // record total selling\r\n        totalCollected = SafeMath.add(totalCollected, msg.value);\r\n\r\n        NewBuyer(_owner, tokenAmount, msg.value);\r\n    }\r\n\r\n    //  Function to stop sale for an emergency.\r\n    //  Only ACF can do it after it has been activated.\r\n    function emergencyStopSale()\r\n    only_sale_not_stopped\r\n    onlyOwner\r\n    public {\r\n        saleStopped = true;\r\n    }\r\n\r\n    //  Function to restart stopped sale.\r\n    //  Only ACF  can do it after it has been disabled and sale is ongoing.\r\n    function restartSale()\r\n    only_during_sale_period\r\n    only_sale_stopped\r\n    onlyOwner\r\n    public {\r\n        saleStopped = false;\r\n    }\r\n\r\n\r\n    function finalizeSale()\r\n    only_after_sale\r\n    onlyOwner\r\n    public {\r\n        doFinalizeSale();\r\n    }\r\n\r\n    function doFinalizeSale()\r\n    internal {\r\n\r\n        // move all remaining eth in the sale contract to ACFWallet\r\n        if (!ACFWallet.send(this.balance)) throw;\r\n\r\n        // transfer remaining tokens to ACFWallet\r\n        token.transfer(ACFWallet, getTokensLeft());\r\n\r\n        saleFinalized = true;\r\n        saleStopped = true;\r\n    }\r\n\r\n\r\n    function getNow() internal constant returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    modifier only(address x) {\r\n        if (msg.sender != x) throw;\r\n        _;\r\n    }\r\n\r\n    modifier only_during_sale_period {\r\n        if (getNow() < startTime) throw;\r\n        if (getNow() >= endTime) throw;\r\n        _;\r\n    }\r\n\r\n    // valid only during sale or before sale if the sender is whitelisted\r\n    modifier only_during_sale_period_or_whitelisted(address x) {\r\n        if (getNow() < startTime && !whitelist[x]) throw;\r\n        if (getNow() >= endTime) throw;\r\n        _;\r\n    }\r\n\r\n    modifier only_after_sale {\r\n        if (getNow() < endTime) throw;\r\n        _;\r\n    }\r\n\r\n    modifier only_sale_stopped {\r\n        if (!saleStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier only_sale_not_stopped {\r\n        if (saleStopped) throw;\r\n        _;\r\n    }\r\n\r\n    modifier non_zero_address(address x) {\r\n        if (x == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier minimum_value(uint256 x) {\r\n        if (msg.value < x) throw;\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setWhitelistStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStopSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ACFWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_ACFWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ACFAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"}]","ContractName":"ACFSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005ee430fd04cae74dd2717c76652e3766adb460590000000000000000000000002657cafb39b331c4b16ecd929d875ded8a602f53","Library":"","SwarmSource":"bzzr://d769379fd8729f2d0d7812d368b7c17e26a6faac2716df276dc7a8a73d6a61f3"}]}