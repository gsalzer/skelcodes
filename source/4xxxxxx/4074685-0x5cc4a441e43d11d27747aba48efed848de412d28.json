{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract Prover {\r\n    \r\n    struct Entry {\r\n        bool exists;\r\n        uint256 time;\r\n        uint256 value;\r\n    }\r\n    \r\n    // {address: {dataHash1: Entry1, dataHash2: Entry2, ...}, ...}\r\n    mapping (address => mapping (bytes32 => Entry)) public ledger;\r\n    \r\n    // public functions for adding and deleting entries\r\n    function addEntry(bytes32 dataHash) payable {\r\n        _addEntry(dataHash);\r\n    }\r\n    function addEntry(string dataString) payable {\r\n        _addEntry(sha3(dataString));\r\n    }\r\n    function deleteEntry(bytes32 dataHash) {\r\n        _deleteEntry(dataHash);\r\n    }\r\n    function deleteEntry(string dataString) {\r\n        _deleteEntry(sha3(dataString));\r\n    }\r\n    \r\n    // internals for adding and deleting entries\r\n    function _addEntry(bytes32 dataHash) internal {\r\n        // check that the entry doesn't exist\r\n        assert(!ledger[msg.sender][dataHash].exists);\r\n        // initialize values\r\n        ledger[msg.sender][dataHash].exists = true;\r\n        ledger[msg.sender][dataHash].time = now;\r\n        ledger[msg.sender][dataHash].value = msg.value;\r\n    }\r\n    function _deleteEntry(bytes32 dataHash) internal {\r\n        // check that the entry exists\r\n        assert(ledger[msg.sender][dataHash].exists);\r\n        uint256 rebate = ledger[msg.sender][dataHash].value;\r\n        delete ledger[msg.sender][dataHash];\r\n        if (rebate > 0) {\r\n            msg.sender.transfer(rebate);\r\n        }\r\n    }\r\n    \r\n    // prove functions\r\n    function proveIt(address claimant, bytes32 dataHash) constant\r\n            returns (bool proved, uint256 time, uint256 value) {\r\n        return status(claimant, dataHash);\r\n    }\r\n    function proveIt(address claimant, string dataString) constant\r\n            returns (bool proved, uint256 time, uint256 value) {\r\n        // compute hash of the string\r\n        return status(claimant, sha3(dataString));\r\n    }\r\n    function proveIt(bytes32 dataHash) constant\r\n            returns (bool proved, uint256 time, uint256 value) {\r\n        return status(msg.sender, dataHash);\r\n    }\r\n    function proveIt(string dataString) constant\r\n            returns (bool proved, uint256 time, uint256 value) {\r\n        // compute hash of the string\r\n        return status(msg.sender, sha3(dataString));\r\n    }\r\n    \r\n    // internal for returning status of arbitrary entries\r\n    function status(address claimant, bytes32 dataHash) internal constant\r\n            returns (bool, uint256, uint256) {\r\n        // if entry exists\r\n        if (ledger[claimant][dataHash].exists) {\r\n            return (true, ledger[claimant][dataHash].time,\r\n                    ledger[claimant][dataHash].value);\r\n        }\r\n        else {\r\n            return (false, 0, 0);\r\n        }\r\n    }\r\n\r\n    // raw eth transactions will be returned\r\n    function () {\r\n        revert();\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"dataString\",\"type\":\"string\"}],\"name\":\"deleteEntry\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataString\",\"type\":\"string\"}],\"name\":\"addEntry\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"addEntry\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"claimant\",\"type\":\"address\"},{\"name\":\"dataString\",\"type\":\"string\"}],\"name\":\"proveIt\",\"outputs\":[{\"name\":\"proved\",\"type\":\"bool\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"proveIt\",\"outputs\":[{\"name\":\"proved\",\"type\":\"bool\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"claimant\",\"type\":\"address\"},{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"proveIt\",\"outputs\":[{\"name\":\"proved\",\"type\":\"bool\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dataString\",\"type\":\"string\"}],\"name\":\"proveIt\",\"outputs\":[{\"name\":\"proved\",\"type\":\"bool\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ledger\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"deleteEntry\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"payable\":false,\"type\":\"fallback\"}]","ContractName":"Prover","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://41acfb0bb18d288b97146dafefa582e91ade0ce5385043d1b15d7eafb6d7b137"}]}