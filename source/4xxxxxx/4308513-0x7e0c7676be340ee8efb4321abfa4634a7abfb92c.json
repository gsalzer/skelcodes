{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/* TODO: change this to an interface definition as soon as truffle accepts it. See https://github.com/trufflesuite/truffle/issues/560 */\r\ncontract ITransferable {\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\n/**\r\n@title PLAY Token\r\n\r\nERC20 Token with additional mint functionality.\r\nA \"controller\" (initialized to the contract creator) has exclusive permission to mint.\r\nThe controller address can be changed until locked.\r\n\r\nImplementation based on https://github.com/ConsenSys/Tokens\r\n*/\r\ncontract PlayToken {\r\n    uint256 public totalSupply = 0;\r\n    string public name = \"PLAY\";\r\n    uint8 public decimals = 18;\r\n    string public symbol = \"PLY\";\r\n    string public version = '1';\r\n\r\n    address public controller;\r\n    bool public controllerLocked = false;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == controller);\r\n        _;\r\n    }\r\n\r\n    /** @dev constructor */\r\n    function PlayToken(address _controller) {\r\n        controller = _controller;\r\n    }\r\n\r\n    /** Sets a new controller address if the current controller isn't locked */\r\n    function setController(address _newController) onlyController {\r\n        require(! controllerLocked);\r\n        controller = _newController;\r\n    }\r\n\r\n    /** Locks the current controller address forever */\r\n    function lockController() onlyController {\r\n        controllerLocked = true;\r\n    }\r\n\r\n    /**\r\n    Creates new tokens for the given receiver.\r\n    Can be called only by the contract creator.\r\n    */\r\n    function mint(address _receiver, uint256 _value) onlyController {\r\n        balances[_receiver] += _value;\r\n        totalSupply += _value;\r\n        // (probably) recommended by the standard, see https://github.com/ethereum/EIPs/pull/610/files#diff-c846f31381e26d8beeeae24afcdf4e3eR99\r\n        Transfer(0, _receiver, _value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        /* Additional Restriction: don't accept token payments to the contract itself and to address 0 in order to avoid most\r\n         token losses by mistake - as is discussed in https://github.com/ethereum/EIPs/issues/223 */\r\n        require((_to != 0) && (_to != address(this)));\r\n\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        /* call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. */\r\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    Withdraws tokens held by the contract to a given account.\r\n    Motivation: see https://github.com/ethereum/EIPs/issues/223#issuecomment-317987571\r\n    */\r\n    function withdrawTokens(ITransferable _token, address _to, uint256 _amount) onlyController {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n}\r\n\r\n/** @title P4P Donation Pool\r\n\r\nContract which receives donations for privacy projects.\r\nDonators will be rewarded with PLAY tokens.\r\n\r\nThe donation process is 2-phased.\r\nDonations of the first round will be weighted twice as much compared to later donations.\r\n\r\nThe received Ether funds will not be accessible during the donation period.\r\nDonated Eth can be retrieved only after the donation rounds are over and the set unlock timestamp is reached.\r\nIn order to never own the funds, the contract owner can set and lock the receiver address beforehand.\r\nThe receiver address can be an external account or a distribution contract.\r\n\r\nNote that there's no way for the owner to withdraw tokens assigned to donators which aren't withdrawn.\r\nIn case destroy() is invoked, they will effectively be burned.\r\n*/\r\ncontract P4PPool {\r\n    address public owner;\r\n    PlayToken public playToken;\r\n\r\n    uint8 public currentState = 0;\r\n    // valid states (not using enum in order to be able to simply increment in startNextPhase()):\r\n    uint8 public constant STATE_NOT_STARTED = 0;\r\n    uint8 public constant STATE_DONATION_ROUND_1 = 1;\r\n    uint8 public constant STATE_PLAYING = 2;\r\n    uint8 public constant STATE_DONATION_ROUND_2 = 3;\r\n    uint8 public constant STATE_PAYOUT = 4;\r\n\r\n    uint256 public tokenPerEth; // calculated after finishing donation rounds\r\n\r\n    mapping(address => uint256) round1Donations;\r\n    mapping(address => uint256) round2Donations;\r\n\r\n    // glitch: forgot to rename those from \"phase\" to \"round\" too\r\n    uint256 public totalPhase1Donations = 0;\r\n    uint256 public totalPhase2Donations = 0;\r\n\r\n    // 1509494400 = 2017 Nov 01, 00:00 (UTC)\r\n    uint32 public donationUnlockTs = uint32(now); //1509494400;\r\n\r\n    // share of the pooled tokens the owner (developers) gets in percent\r\n    uint8 public constant ownerTokenSharePct = 20;\r\n\r\n    address public donationReceiver;\r\n    bool public donationReceiverLocked = false;\r\n\r\n    event StateChanged(uint8 newState);\r\n    event DonatedEthPayout(address receiver, uint256 amount);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDuringDonationRounds() {\r\n        require(currentState == STATE_DONATION_ROUND_1 || currentState == STATE_DONATION_ROUND_2);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfPayoutUnlocked() {\r\n        require(currentState == STATE_PAYOUT);\r\n        require(uint32(now) >= donationUnlockTs);\r\n        _;\r\n    }\r\n\r\n    /** @dev constructor */\r\n    function P4PPool(address _tokenAddr) {\r\n        owner = msg.sender;\r\n        playToken = PlayToken(_tokenAddr);\r\n    }\r\n\r\n    /** So called \"fallback function\" which handles incoming Ether payments\r\n    Remembers which address payed how much, doubling round 1 contributions.\r\n    */\r\n    function () payable onlyDuringDonationRounds {\r\n        donateForImpl(msg.sender);\r\n    }\r\n\r\n    /** Receives Eth on behalf of somebody else\r\n    Can be used for proxy payments.\r\n    */\r\n    function donateFor(address _donor) payable onlyDuringDonationRounds {\r\n        donateForImpl(_donor);\r\n    }\r\n\r\n    function startNextPhase() onlyOwner {\r\n        require(currentState <= STATE_PAYOUT);\r\n        currentState++;\r\n        if(currentState == STATE_PAYOUT) {\r\n            // donation ended. Calculate and persist the distribution key:\r\n            tokenPerEth = calcTokenPerEth();\r\n        }\r\n        StateChanged(currentState);\r\n    }\r\n\r\n    function setDonationUnlockTs(uint32 _newTs) onlyOwner {\r\n        require(_newTs > donationUnlockTs);\r\n        donationUnlockTs = _newTs;\r\n    }\r\n\r\n    function setDonationReceiver(address _receiver) onlyOwner {\r\n        require(! donationReceiverLocked);\r\n        donationReceiver = _receiver;\r\n    }\r\n\r\n    function lockDonationReceiver() onlyOwner {\r\n        require(donationReceiver != 0);\r\n        donationReceiverLocked = true;\r\n    }\r\n\r\n    // this could be left available to everybody instead of owner only\r\n    function payoutDonations() onlyOwner onlyIfPayoutUnlocked {\r\n        require(donationReceiver != 0);\r\n        var amount = this.balance;\r\n        require(donationReceiver.send(amount));\r\n        DonatedEthPayout(donationReceiver, amount);\r\n    }\r\n\r\n    /** Emergency fallback for retrieving funds\r\n    In case something goes horribly wrong, this allows to retrieve Eth from the contract.\r\n    Becomes available at March 1 2018.\r\n    If called, all tokens still owned by the contract (not withdrawn by anybody) are burned.\r\n    */\r\n    function destroy() onlyOwner {\r\n        require(currentState == STATE_PAYOUT);\r\n        require(now > 1519862400);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /** Allows donators to withdraw the share of tokens they are entitled to */\r\n    function withdrawTokenShare() {\r\n        require(tokenPerEth > 0); // this implies that donation rounds have closed\r\n        require(playToken.transfer(msg.sender, calcTokenShareOf(msg.sender)));\r\n        round1Donations[msg.sender] = 0;\r\n        round2Donations[msg.sender] = 0;\r\n    }\r\n\r\n    // ######### INTERNAL FUNCTIONS ##########\r\n\r\n    function calcTokenShareOf(address _addr) constant internal returns(uint256) {\r\n        if(_addr == owner) {\r\n            // TODO: this could probably be simplified. But does the job without requiring additional storage\r\n            var virtualEthBalance = (((totalPhase1Donations*2 + totalPhase2Donations) * 100) / (100 - ownerTokenSharePct) + 1);\r\n            return ((tokenPerEth * virtualEthBalance) * ownerTokenSharePct) / (100 * 1E18);\r\n        } else {\r\n            return (tokenPerEth * (round1Donations[_addr]*2 + round2Donations[_addr])) / 1E18;\r\n        }\r\n    }\r\n\r\n    // Will throw if no donations were received.\r\n    function calcTokenPerEth() constant internal returns(uint256) {\r\n        var tokenBalance = playToken.balanceOf(this);\r\n        // the final + 1 makes sure we're not running out of tokens due to rounding artifacts.\r\n        // that would otherwise be (theoretically, if all tokens are withdrawn) possible,\r\n        // because this number acts as divisor for the return value.\r\n        var virtualEthBalance = (((totalPhase1Donations*2 + totalPhase2Donations) * 100) / (100 - ownerTokenSharePct) + 1);\r\n        // use 18 decimals precision. No danger of overflow with 256 bits.\r\n        return tokenBalance * 1E18 / (virtualEthBalance);\r\n    }\r\n\r\n    function donateForImpl(address _donor) internal onlyDuringDonationRounds {\r\n        if(currentState == STATE_DONATION_ROUND_1) {\r\n            round1Donations[_donor] += msg.value;\r\n            totalPhase1Donations += msg.value;\r\n        } else if(currentState == STATE_DONATION_ROUND_2) {\r\n            round2Donations[_donor] += msg.value;\r\n            totalPhase2Donations += msg.value;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_donor\",\"type\":\"address\"}],\"name\":\"donateFor\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationReceiverLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTs\",\"type\":\"uint32\"}],\"name\":\"setDonationUnlockTs\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_PLAYING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_DONATION_ROUND_1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationUnlockTs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_DONATION_ROUND_2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockDonationReceiver\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payoutDonations\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"setDonationReceiver\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerTokenSharePct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPhase1Donations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNextPhase\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokenShare\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPhase2Donations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_PAYOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STATE_NOT_STARTED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonatedEthPayout\",\"type\":\"event\"}]","ContractName":"P4PPool","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000fb41f7b63c8e84f4ba1ecd4d393fd9daa5d14d61","Library":"","SwarmSource":"bzzr://18fd40ff5ad498c90a05383d54b62e2ce01fdbfff5534da58ccdf1deb5324340"}]}