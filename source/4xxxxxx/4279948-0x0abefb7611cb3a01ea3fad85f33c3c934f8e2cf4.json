{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright (C) Virtue Fintech FZ-LLC, Dubai\r\n * All rights reserved.\r\n * Author: mhi@virtue.finance\r\n *\r\n * This code is adapted from OpenZeppelin Project.\r\n * more at http://openzeppelin.org.\r\n *\r\n * MIT License\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy \r\n * of this software and associated documentation files (the \"\"Software\"\"), to \r\n * deal in the Software without restriction, including without limitation the \r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or \r\n * sell copies of the Software, and to permit persons to whom the Software is \r\n * furnished to do so, subject to the following conditions: \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \r\n * THE SOFTWARE.\r\n *\r\n */\r\npragma solidity ^0.4.11;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Guarded {\r\n\r\n    modifier isValidAmount(uint256 _amount) { \r\n        require(_amount > 0); \r\n        _; \r\n    }\r\n\r\n    // ensure address not null, and not this contract address\r\n    modifier isValidAddress(address _address) {\r\n        require(_address != 0x0 && _address != address(this));\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /** \r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner. \r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to. \r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract Claimable is Ownable {\r\n    address public pendingOwner;\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner. \r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address. \r\n     * @param newOwner The address to transfer ownership to. \r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() onlyPendingOwner {\r\n        owner = pendingOwner;\r\n        pendingOwner = 0x0;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    \r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract ERC20Token is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public standard = 'Cryptoken 0.1.1';\r\n\r\n    string public name = '';            // the token name\r\n    string public symbol = '';          // the token symbol\r\n    uint8 public decimals = 0;          // the number of decimals\r\n\r\n    // mapping of our users to balance\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    // our constructor. We have fixed everything above, and not as \r\n    // parameters in the constructor.\r\n    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    // get token balance\r\n    function balanceOf(address _owner) \r\n        public constant \r\n        returns (uint256 balance) \r\n    {\r\n        return balances[_owner];\r\n    }    \r\n\r\n    /**\r\n     * make a transfer. This can be called from the token holder.\r\n     * e.g. Token holder Alice, can issue somethign like this to Bob\r\n     *      Alice.transfer(Bob, 200);     // to transfer 200 to Bob\r\n     */\r\n    /// Initiate a transfer to `_to` with value `_value`?\r\n    function transfer(address _to, uint256 _value) \r\n        public returns (bool success) \r\n    {\r\n        // sanity check\r\n        require(_to != address(this));\r\n\r\n        // // check for overflows\r\n        // require(_value > 0 &&\r\n        //   balances[msg.sender] < _value &&\r\n        //   balances[_to] + _value < balances[_to]);\r\n\r\n        // \r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        \r\n        // emit transfer event\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * make an approved transfer to another account from vault. This operation\r\n     * should be called after approved operation below.\r\n     * .e.g Alice allow Bob to spend 30 by doing:\r\n     *      Alice.approve(Bob, 30);                 // allow 30 to Bob\r\n     *\r\n     * and Bob can claim, say 10, from that by doing\r\n     *      Bob.transferFrom(Alice, Bob, 10);       // spend only 10\r\n     * and Bob's balance shall be 20 in the allowance.\r\n     */\r\n    /// Initiate a transfer of `_value` from `_from` to `_to`\r\n    function transferFrom(address _from, address _to, uint256 _value)         \r\n        public returns (bool success) \r\n    {    \r\n        // sanity check\r\n        require(_to != 0x0 && _from != 0x0);\r\n        require(_from != _to && _to != address(this));\r\n\r\n        // check for overflows\r\n        // require(_value > 0 &&\r\n        //   balances[_from] >= _value &&\r\n        //   allowed[_from][_to] <= _value &&\r\n        //   balances[_to] + _value < balances[_to]);\r\n\r\n        // update public balance\r\n        allowed[_from][_to] = allowed[_from][_to].sub(_value);        \r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        // emit transfer event\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This method is explained further in https://goo.gl/iaqxBa on the\r\n     * possible attacks. As such, we have to make sure the value is\r\n     * drained, before any Alice/Bob can approve each other to\r\n     * transfer on their behalf.\r\n     * @param _spender  - the recipient of the value\r\n     * @param _value    - the value allowed to be spent \r\n     *\r\n     * This can be called by the token holder\r\n     * e.g. Alice can allow Bob to spend 30 on her behalf\r\n     *      Alice.approve(Bob, 30);     // gives 30 to Bob.\r\n     */\r\n    /// Approve `_spender` to claim/spend `_value`?\r\n    function approve(address _spender, uint256 _value)          \r\n        public returns (bool success) \r\n    {\r\n        // sanity check\r\n        require(_spender != 0x0 && _spender != address(this));            \r\n\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent \r\n        // an allowance change immediately after withdrawal\r\n        require(allowed[msg.sender][_spender] == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Check the allowance that has been approved previously by owner.\r\n     */\r\n    /// check allowance approved from `_owner` to `_spender`?\r\n    function allowance(address _owner, address _spender)          \r\n        public constant returns (uint remaining) \r\n    {\r\n        // sanity check\r\n        require(_spender != 0x0 && _owner != 0x0);\r\n        require(_owner != _spender && _spender != address(this));            \r\n\r\n        // constant op. Just return the balance.\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract FaradCryptoken is ERC20Token, Guarded, Claimable {\r\n\r\n    uint256 public SUPPLY = 1600000000 ether;   // 1.6b ether;\r\n\r\n    // our constructor, just supply the total supply.\r\n    function FaradCryptoken() \r\n        ERC20Token('FARAD', 'FRD', 18) \r\n    {\r\n        totalSupply = SUPPLY;\r\n        balances[msg.sender] = SUPPLY;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FaradCryptoken","CompilerVersion":"v0.4.12+commit.194ff033","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5b460ef952616fb15bcb7cda2d08cf0272a9180657b3bdda02fc4f17ca629f3a"}]}