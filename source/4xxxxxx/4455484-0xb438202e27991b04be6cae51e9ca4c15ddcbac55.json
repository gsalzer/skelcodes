{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n/// @title MilestoneTracker Contract\r\n/// @author Jordi Baylina\r\n/// @dev This contract tracks the\r\n\r\n\r\n/// is rules the relation betwen a donor and a recipient\r\n///  in order to guaranty to the donor that the job will be done and to guaranty\r\n///  to the recipient that he will be paid\r\n\r\n\r\n/// @dev We use the RLP library to decode RLP so that the donor can approve one\r\n///  set of milestone changes at a time.\r\n///  https://github.com/androlo/standard-contracts/blob/master/contracts/src/codec/RLP.sol\r\n\r\n\r\n/**\r\n* @title RLPReader\r\n*\r\n* RLPReader is used to read and parse RLP encoded data in memory.\r\n*\r\n* @author Andreas Olofsson (androlo1980@gmail.com)\r\n*/\r\nlibrary RLP {\r\n\r\n uint constant DATA_SHORT_START = 0x80;\r\n uint constant DATA_LONG_START = 0xB8;\r\n uint constant LIST_SHORT_START = 0xC0;\r\n uint constant LIST_LONG_START = 0xF8;\r\n\r\n uint constant DATA_LONG_OFFSET = 0xB7;\r\n uint constant LIST_LONG_OFFSET = 0xF7;\r\n\r\n\r\n struct RLPItem {\r\n     uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\r\n     uint _unsafe_length;    // Number of bytes. This is the full length of the string.\r\n }\r\n\r\n struct Iterator {\r\n     RLPItem _unsafe_item;   // Item that's being iterated over.\r\n     uint _unsafe_nextPtr;   // Position of the next item in the list.\r\n }\r\n\r\n /* Iterator */\r\n\r\n function next(Iterator memory self) internal constant returns (RLPItem memory subItem) {\r\n     if(hasNext(self)) {\r\n         var ptr = self._unsafe_nextPtr;\r\n         var itemLength = _itemLength(ptr);\r\n         subItem._unsafe_memPtr = ptr;\r\n         subItem._unsafe_length = itemLength;\r\n         self._unsafe_nextPtr = ptr + itemLength;\r\n     }\r\n     else\r\n         throw;\r\n }\r\n\r\n function next(Iterator memory self, bool strict) internal constant returns (RLPItem memory subItem) {\r\n     subItem = next(self);\r\n     if(strict && !_validate(subItem))\r\n         throw;\r\n     return;\r\n }\r\n\r\n function hasNext(Iterator memory self) internal constant returns (bool) {\r\n     var item = self._unsafe_item;\r\n     return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\r\n }\r\n\r\n /* RLPItem */\r\n\r\n /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n /// @param self The RLP encoded bytes.\r\n /// @return An RLPItem\r\n function toRLPItem(bytes memory self) internal constant returns (RLPItem memory) {\r\n     uint len = self.length;\r\n     if (len == 0) {\r\n         return RLPItem(0, 0);\r\n     }\r\n     uint memPtr;\r\n     assembly {\r\n         memPtr := add(self, 0x20)\r\n     }\r\n     return RLPItem(memPtr, len);\r\n }\r\n\r\n /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n /// @param self The RLP encoded bytes.\r\n /// @param strict Will throw if the data is not RLP encoded.\r\n /// @return An RLPItem\r\n function toRLPItem(bytes memory self, bool strict) internal constant returns (RLPItem memory) {\r\n     var item = toRLPItem(self);\r\n     if(strict) {\r\n         uint len = self.length;\r\n         if(_payloadOffset(item) > len)\r\n             throw;\r\n         if(_itemLength(item._unsafe_memPtr) != len)\r\n             throw;\r\n         if(!_validate(item))\r\n             throw;\r\n     }\r\n     return item;\r\n }\r\n\r\n /// @dev Check if the RLP item is null.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is null.\r\n function isNull(RLPItem memory self) internal constant returns (bool ret) {\r\n     return self._unsafe_length == 0;\r\n }\r\n\r\n /// @dev Check if the RLP item is a list.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is a list.\r\n function isList(RLPItem memory self) internal constant returns (bool ret) {\r\n     if (self._unsafe_length == 0)\r\n         return false;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\r\n     }\r\n }\r\n\r\n /// @dev Check if the RLP item is data.\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is data.\r\n function isData(RLPItem memory self) internal constant returns (bool ret) {\r\n     if (self._unsafe_length == 0)\r\n         return false;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         ret := lt(byte(0, mload(memPtr)), 0xC0)\r\n     }\r\n }\r\n\r\n /// @dev Check if the RLP item is empty (string or list).\r\n /// @param self The RLP item.\r\n /// @return 'true' if the item is null.\r\n function isEmpty(RLPItem memory self) internal constant returns (bool ret) {\r\n     if(isNull(self))\r\n         return false;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\r\n }\r\n\r\n /// @dev Get the number of items in an RLP encoded list.\r\n /// @param self The RLP item.\r\n /// @return The number of items.\r\n function items(RLPItem memory self) internal constant returns (uint) {\r\n     if (!isList(self))\r\n         return 0;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     uint pos = memPtr + _payloadOffset(self);\r\n     uint last = memPtr + self._unsafe_length - 1;\r\n     uint itms;\r\n     while(pos <= last) {\r\n         pos += _itemLength(pos);\r\n         itms++;\r\n     }\r\n     return itms;\r\n }\r\n\r\n /// @dev Create an iterator.\r\n /// @param self The RLP item.\r\n /// @return An 'Iterator' over the item.\r\n function iterator(RLPItem memory self) internal constant returns (Iterator memory it) {\r\n     if (!isList(self))\r\n         throw;\r\n     uint ptr = self._unsafe_memPtr + _payloadOffset(self);\r\n     it._unsafe_item = self;\r\n     it._unsafe_nextPtr = ptr;\r\n }\r\n\r\n /// @dev Return the RLP encoded bytes.\r\n /// @param self The RLPItem.\r\n /// @return The bytes.\r\n function toBytes(RLPItem memory self) internal constant returns (bytes memory bts) {\r\n     var len = self._unsafe_length;\r\n     if (len == 0)\r\n         return;\r\n     bts = new bytes(len);\r\n     _copyToBytes(self._unsafe_memPtr, bts, len);\r\n }\r\n\r\n /// @dev Decode an RLPItem into bytes. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toData(RLPItem memory self) internal constant returns (bytes memory bts) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     bts = new bytes(len);\r\n     _copyToBytes(rStartPos, bts, len);\r\n }\r\n\r\n /// @dev Get the list of sub-items from an RLP encoded list.\r\n /// Warning: This is inefficient, as it requires that the list is read twice.\r\n /// @param self The RLP item.\r\n /// @return Array of RLPItems.\r\n function toList(RLPItem memory self) internal constant returns (RLPItem[] memory list) {\r\n     if(!isList(self))\r\n         throw;\r\n     var numItems = items(self);\r\n     list = new RLPItem[](numItems);\r\n     var it = iterator(self);\r\n     uint idx;\r\n     while(hasNext(it)) {\r\n         list[idx] = next(it);\r\n         idx++;\r\n     }\r\n }\r\n\r\n /// @dev Decode an RLPItem into an ascii string. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toAscii(RLPItem memory self) internal constant returns (string memory str) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     bytes memory bts = new bytes(len);\r\n     _copyToBytes(rStartPos, bts, len);\r\n     str = string(bts);\r\n }\r\n\r\n /// @dev Decode an RLPItem into a uint. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toUint(RLPItem memory self) internal constant returns (uint data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len > 32 || len == 0)\r\n         throw;\r\n     assembly {\r\n         data := div(mload(rStartPos), exp(256, sub(32, len)))\r\n     }\r\n }\r\n\r\n /// @dev Decode an RLPItem into a boolean. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toBool(RLPItem memory self) internal constant returns (bool data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 1)\r\n         throw;\r\n     uint temp;\r\n     assembly {\r\n         temp := byte(0, mload(rStartPos))\r\n     }\r\n     if (temp > 1)\r\n         throw;\r\n     return temp == 1 ? true : false;\r\n }\r\n\r\n /// @dev Decode an RLPItem into a byte. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toByte(RLPItem memory self) internal constant returns (byte data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 1)\r\n         throw;\r\n     uint temp;\r\n     assembly {\r\n         temp := byte(0, mload(rStartPos))\r\n     }\r\n     return byte(temp);\r\n }\r\n\r\n /// @dev Decode an RLPItem into an int. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toInt(RLPItem memory self) internal constant returns (int data) {\r\n     return int(toUint(self));\r\n }\r\n\r\n /// @dev Decode an RLPItem into a bytes32. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toBytes32(RLPItem memory self) internal constant returns (bytes32 data) {\r\n     return bytes32(toUint(self));\r\n }\r\n\r\n /// @dev Decode an RLPItem into an address. This will not work if the\r\n /// RLPItem is a list.\r\n /// @param self The RLPItem.\r\n /// @return The decoded string.\r\n function toAddress(RLPItem memory self) internal constant returns (address data) {\r\n     if(!isData(self))\r\n         throw;\r\n     var (rStartPos, len) = _decode(self);\r\n     if (len != 20)\r\n         throw;\r\n     assembly {\r\n         data := div(mload(rStartPos), exp(256, 12))\r\n     }\r\n }\r\n\r\n // Get the payload offset.\r\n function _payloadOffset(RLPItem memory self) private constant returns (uint) {\r\n     if(self._unsafe_length == 0)\r\n         return 0;\r\n     uint b0;\r\n     uint memPtr = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     if(b0 < DATA_SHORT_START)\r\n         return 0;\r\n     if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n         return 1;\r\n     if(b0 < LIST_SHORT_START)\r\n         return b0 - DATA_LONG_OFFSET + 1;\r\n     return b0 - LIST_LONG_OFFSET + 1;\r\n }\r\n\r\n // Get the full length of an RLP item.\r\n function _itemLength(uint memPtr) private constant returns (uint len) {\r\n     uint b0;\r\n     assembly {\r\n         b0 := byte(0, mload(memPtr))\r\n     }\r\n     if (b0 < DATA_SHORT_START)\r\n         len = 1;\r\n     else if (b0 < DATA_LONG_START)\r\n         len = b0 - DATA_SHORT_START + 1;\r\n     else if (b0 < LIST_SHORT_START) {\r\n         assembly {\r\n             let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\r\n             let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n             len := add(1, add(bLen, dLen)) // total length\r\n         }\r\n     }\r\n     else if (b0 < LIST_LONG_START)\r\n         len = b0 - LIST_SHORT_START + 1;\r\n     else {\r\n         assembly {\r\n             let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\r\n             let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\r\n             len := add(1, add(bLen, dLen)) // total length\r\n         }\r\n     }\r\n }\r\n\r\n // Get start position and length of the data.\r\n function _decode(RLPItem memory self) private constant returns (uint memPtr, uint len) {\r\n     if(!isData(self))\r\n         throw;\r\n     uint b0;\r\n     uint start = self._unsafe_memPtr;\r\n     assembly {\r\n         b0 := byte(0, mload(start))\r\n     }\r\n     if (b0 < DATA_SHORT_START) {\r\n         memPtr = start;\r\n         len = 1;\r\n         return;\r\n     }\r\n     if (b0 < DATA_LONG_START) {\r\n         len = self._unsafe_length - 1;\r\n         memPtr = start + 1;\r\n     } else {\r\n         uint bLen;\r\n         assembly {\r\n             bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n         }\r\n         len = self._unsafe_length - 1 - bLen;\r\n         memPtr = start + bLen + 1;\r\n     }\r\n     return;\r\n }\r\n\r\n // Assumes that enough memory has been allocated to store in target.\r\n function _copyToBytes(uint btsPtr, bytes memory tgt, uint btsLen) private constant {\r\n     // Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n     // we can write entire words, and just overwrite any excess.\r\n     assembly {\r\n         {\r\n                 let i := 0 // Start at arr + 0x20\r\n                 let words := div(add(btsLen, 31), 32)\r\n                 let rOffset := btsPtr\r\n                 let wOffset := add(tgt, 0x20)\r\n             tag_loop:\r\n                 jumpi(end, eq(i, words))\r\n                 {\r\n                     let offset := mul(i, 0x20)\r\n                     mstore(add(wOffset, offset), mload(add(rOffset, offset)))\r\n                     i := add(i, 1)\r\n                 }\r\n                 jump(tag_loop)\r\n             end:\r\n                 mstore(add(tgt, add(0x20, mload(tgt))), 0)\r\n         }\r\n     }\r\n }\r\n\r\n // Check that an RLP item is valid.\r\n     function _validate(RLPItem memory self) private constant returns (bool ret) {\r\n         // Check that RLP is well-formed.\r\n         uint b0;\r\n         uint b1;\r\n         uint memPtr = self._unsafe_memPtr;\r\n         assembly {\r\n             b0 := byte(0, mload(memPtr))\r\n             b1 := byte(1, mload(memPtr))\r\n         }\r\n         if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\r\n             return false;\r\n         return true;\r\n     }\r\n}\r\n\r\n\r\n\r\n/// @dev This contract allows for `recipient` to set and modify milestones\r\ncontract MilestoneTracker {\r\n    using RLP for RLP.RLPItem;\r\n    using RLP for RLP.Iterator;\r\n    using RLP for bytes;\r\n\r\n    struct Milestone {\r\n        string description;     // Description of this milestone\r\n        string url;             // A link to more information (swarm gateway)\r\n        uint minCompletionDate; // Earliest UNIX time the milestone can be paid\r\n        uint maxCompletionDate; // Latest UNIX time the milestone can be paid\r\n        address milestoneLeadLink;\r\n                                // Similar to `recipient`but for this milestone\r\n        address reviewer;       // Can reject the completion of this milestone\r\n        uint reviewTime;        // How many seconds the reviewer has to review\r\n        address paymentSource;  // Where the milestone payment is sent from\r\n        bytes payData;          // Data defining how much ether is sent where\r\n\r\n        MilestoneStatus status; // Current status of the milestone\r\n                                // (Completed, AuthorizedForPayment...)\r\n        uint doneTime;          // UNIX time when the milestone was marked DONE\r\n    }\r\n\r\n    // The list of all the milestones.\r\n    Milestone[] public milestones;\r\n\r\n    address public recipient;   // Calls functions in the name of the recipient\r\n    address public donor;       // Calls functions in the name of the donor\r\n    address public arbitrator;  // Calls functions in the name of the arbitrator\r\n\r\n    enum MilestoneStatus {\r\n        AcceptedAndInProgress,\r\n        Completed,\r\n        AuthorizedForPayment,\r\n        Canceled\r\n    }\r\n\r\n    // True if the campaign has been canceled\r\n    bool public campaignCanceled;\r\n\r\n    // True if an approval on a change to `milestones` is a pending\r\n    bool public changingMilestones;\r\n\r\n    // The pending change to `milestones` encoded in RLP\r\n    bytes public proposedMilestones;\r\n\r\n\r\n    /// @dev The following modifiers only allow specific roles to call functions\r\n    /// with these modifiers\r\n    modifier onlyRecipient { if (msg.sender !=  recipient) throw; _; }\r\n    modifier onlyArbitrator { if (msg.sender != arbitrator) throw; _; }\r\n    modifier onlyDonor { if (msg.sender != donor) throw; _; }\r\n\r\n    /// @dev The following modifiers prevent functions from being called if the\r\n    /// campaign has been canceled or if new milestones are being proposed\r\n    modifier campaignNotCanceled { if (campaignCanceled) throw; _; }\r\n    modifier notChanging { if (changingMilestones) throw; _; }\r\n\r\n // @dev Events to make the payment movements easy to find on the blockchain\r\n    event NewMilestoneListProposed();\r\n    event NewMilestoneListUnproposed();\r\n    event NewMilestoneListAccepted();\r\n    event ProposalStatusChanged(uint idProposal, MilestoneStatus newProposal);\r\n    event CampaignCanceled();\r\n\r\n\r\n///////////\r\n// Constructor\r\n///////////\r\n\r\n    /// @notice The Constructor creates the Milestone contract on the blockchain\r\n    /// @param _arbitrator Address assigned to be the arbitrator\r\n    /// @param _donor Address assigned to be the donor\r\n    /// @param _recipient Address assigned to be the recipient\r\n    function MilestoneTracker (\r\n        address _arbitrator,\r\n        address _donor,\r\n        address _recipient\r\n    ) {\r\n        arbitrator = _arbitrator;\r\n        donor = _donor;\r\n        recipient = _recipient;\r\n    }\r\n\r\n\r\n/////////\r\n// Helper functions\r\n/////////\r\n\r\n    /// @return The number of milestones ever created even if they were canceled\r\n    function numberOfMilestones() constant returns (uint) {\r\n        return milestones.length;\r\n    }\r\n\r\n\r\n////////\r\n// Change players\r\n////////\r\n\r\n    /// @notice `onlyArbitrator` Reassigns the arbitrator to a new address\r\n    /// @param _newArbitrator The new arbitrator\r\n    function changeArbitrator(address _newArbitrator) onlyArbitrator {\r\n        arbitrator = _newArbitrator;\r\n    }\r\n\r\n    /// @notice `onlyDonor` Reassigns the `donor` to a new address\r\n    /// @param _newDonor The new donor\r\n    function changeDonor(address _newDonor) onlyDonor {\r\n        donor = _newDonor;\r\n    }\r\n\r\n    /// @notice `onlyRecipient` Reassigns the `recipient` to a new address\r\n    /// @param _newRecipient The new recipient\r\n    function changeRecipient(address _newRecipient) onlyRecipient {\r\n        recipient = _newRecipient;\r\n    }\r\n\r\n\r\n////////////\r\n// Creation and modification of Milestones\r\n////////////\r\n\r\n    /// @notice `onlyRecipient` Proposes new milestones or changes old\r\n    ///  milestones, this will require a user interface to be built up to\r\n    ///  support this functionality as asks for RLP encoded bytecode to be\r\n    ///  generated, until this interface is built you can use this script:\r\n    ///  https://github.com/Giveth/milestonetracker/blob/master/js/milestonetracker_helper.js\r\n    ///  the functions milestones2bytes and bytes2milestones will enable the\r\n    ///  recipient to encode and decode a list of milestones, also see\r\n    ///  https://github.com/Giveth/milestonetracker/blob/master/README.md\r\n    /// @param _newMilestones The RLP encoded list of milestones; each milestone\r\n    ///  has these fields:\r\n    ///       string description,\r\n    ///       string url,\r\n    ///       uint minCompletionDate,  // seconds since 1/1/1970 (UNIX time)\r\n    ///       uint maxCompletionDate,  // seconds since 1/1/1970 (UNIX time)\r\n    ///       address milestoneLeadLink,\r\n    ///       address reviewer,\r\n    ///       uint reviewTime\r\n    ///       address paymentSource,\r\n    ///       bytes payData,\r\n    function proposeMilestones(bytes _newMilestones\r\n    ) onlyRecipient campaignNotCanceled {\r\n        proposedMilestones = _newMilestones;\r\n        changingMilestones = true;\r\n        NewMilestoneListProposed();\r\n    }\r\n\r\n\r\n////////////\r\n// Normal actions that will change the state of the milestones\r\n////////////\r\n\r\n    /// @notice `onlyRecipient` Cancels the proposed milestones and reactivates\r\n    ///  the previous set of milestones\r\n    function unproposeMilestones() onlyRecipient campaignNotCanceled {\r\n        delete proposedMilestones;\r\n        changingMilestones = false;\r\n        NewMilestoneListUnproposed();\r\n    }\r\n\r\n    /// @notice `onlyDonor` Approves the proposed milestone list\r\n    /// @param _hashProposals The sha3() of the proposed milestone list's\r\n    ///  bytecode; this confirms that the `donor` knows the set of milestones\r\n    ///  they are approving\r\n    function acceptProposedMilestones(bytes32 _hashProposals\r\n    ) onlyDonor campaignNotCanceled {\r\n\r\n        uint i;\r\n\r\n        if (!changingMilestones) throw;\r\n        if (sha3(proposedMilestones) != _hashProposals) throw;\r\n\r\n        // Cancel all the unfinished milestones\r\n        for (i=0; i<milestones.length; i++) {\r\n            if (milestones[i].status != MilestoneStatus.AuthorizedForPayment) {\r\n                milestones[i].status = MilestoneStatus.Canceled;\r\n            }\r\n        }\r\n        // Decode the RLP encoded milestones and add them to the milestones list\r\n        bytes memory mProposedMilestones = proposedMilestones;\r\n\r\n        var itmProposals = mProposedMilestones.toRLPItem(true);\r\n\r\n        if (!itmProposals.isList()) throw;\r\n\r\n        var itrProposals = itmProposals.iterator();\r\n\r\n        while(itrProposals.hasNext()) {\r\n\r\n\r\n            var itmProposal = itrProposals.next();\r\n\r\n            Milestone milestone = milestones[milestones.length ++];\r\n\r\n            if (!itmProposal.isList()) throw;\r\n\r\n            var itrProposal = itmProposal.iterator();\r\n\r\n            milestone.description = itrProposal.next().toAscii();\r\n            milestone.url = itrProposal.next().toAscii();\r\n            milestone.minCompletionDate = itrProposal.next().toUint();\r\n            milestone.maxCompletionDate = itrProposal.next().toUint();\r\n            milestone.milestoneLeadLink = itrProposal.next().toAddress();\r\n            milestone.reviewer = itrProposal.next().toAddress();\r\n            milestone.reviewTime = itrProposal.next().toUint();\r\n            milestone.paymentSource = itrProposal.next().toAddress();\r\n            milestone.payData = itrProposal.next().toData();\r\n\r\n            milestone.status = MilestoneStatus.AcceptedAndInProgress;\r\n\r\n        }\r\n\r\n        delete proposedMilestones;\r\n        changingMilestones = false;\r\n        NewMilestoneListAccepted();\r\n    }\r\n\r\n    /// @notice `onlyRecipientOrLeadLink`Marks a milestone as DONE and\r\n    ///  ready for review\r\n    /// @param _idMilestone ID of the milestone that has been completed\r\n    function markMilestoneComplete(uint _idMilestone)\r\n        campaignNotCanceled notChanging\r\n    {\r\n        if (_idMilestone >= milestones.length) throw;\r\n        Milestone milestone = milestones[_idMilestone];\r\n        if (  (msg.sender != milestone.milestoneLeadLink)\r\n            &&(msg.sender != recipient))\r\n            throw;\r\n        if (milestone.status != MilestoneStatus.AcceptedAndInProgress) throw;\r\n        if (now < milestone.minCompletionDate) throw;\r\n        if (now > milestone.maxCompletionDate) throw;\r\n        milestone.status = MilestoneStatus.Completed;\r\n        milestone.doneTime = now;\r\n        ProposalStatusChanged(_idMilestone, milestone.status);\r\n    }\r\n\r\n    /// @notice `onlyReviewer` Approves a specific milestone\r\n    /// @param _idMilestone ID of the milestone that is approved\r\n    function approveCompletedMilestone(uint _idMilestone)\r\n        campaignNotCanceled notChanging\r\n    {\r\n        if (_idMilestone >= milestones.length) throw;\r\n        Milestone milestone = milestones[_idMilestone];\r\n        if ((msg.sender != milestone.reviewer) ||\r\n            (milestone.status != MilestoneStatus.Completed)) throw;\r\n\r\n        authorizePayment(_idMilestone);\r\n    }\r\n\r\n    /// @notice `onlyReviewer` Rejects a specific milestone's completion and\r\n    ///  reverts the `milestone.status` back to the `AcceptedAndInProgress`\r\n    ///  state\r\n    /// @param _idMilestone ID of the milestone that is being rejected\r\n    function rejectMilestone(uint _idMilestone)\r\n        campaignNotCanceled notChanging\r\n    {\r\n        if (_idMilestone >= milestones.length) throw;\r\n        Milestone milestone = milestones[_idMilestone];\r\n        if ((msg.sender != milestone.reviewer) ||\r\n            (milestone.status != MilestoneStatus.Completed)) throw;\r\n\r\n        milestone.status = MilestoneStatus.AcceptedAndInProgress;\r\n        ProposalStatusChanged(_idMilestone, milestone.status);\r\n    }\r\n\r\n    /// @notice `onlyRecipientOrLeadLink` Sends the milestone payment as\r\n    ///  specified in `payData`; the recipient can only call this after the\r\n    ///  `reviewTime` has elapsed\r\n    /// @param _idMilestone ID of the milestone to be paid out\r\n    function requestMilestonePayment(uint _idMilestone\r\n        ) campaignNotCanceled notChanging {\r\n        if (_idMilestone >= milestones.length) throw;\r\n        Milestone milestone = milestones[_idMilestone];\r\n        if (  (msg.sender != milestone.milestoneLeadLink)\r\n            &&(msg.sender != recipient))\r\n            throw;\r\n        if  ((milestone.status != MilestoneStatus.Completed) ||\r\n             (now < milestone.doneTime + milestone.reviewTime))\r\n            throw;\r\n\r\n        authorizePayment(_idMilestone);\r\n    }\r\n\r\n    /// @notice `onlyRecipient` Cancels a previously accepted milestone\r\n    /// @param _idMilestone ID of the milestone to be canceled\r\n    function cancelMilestone(uint _idMilestone)\r\n        onlyRecipient campaignNotCanceled notChanging\r\n    {\r\n        if (_idMilestone >= milestones.length) throw;\r\n        Milestone milestone = milestones[_idMilestone];\r\n        if  ((milestone.status != MilestoneStatus.AcceptedAndInProgress) &&\r\n             (milestone.status != MilestoneStatus.Completed))\r\n            throw;\r\n\r\n        milestone.status = MilestoneStatus.Canceled;\r\n        ProposalStatusChanged(_idMilestone, milestone.status);\r\n    }\r\n\r\n    /// @notice `onlyArbitrator` Forces a milestone to be paid out as long as it\r\n    /// has not been paid or canceled\r\n    /// @param _idMilestone ID of the milestone to be paid out\r\n    function arbitrateApproveMilestone(uint _idMilestone\r\n    ) onlyArbitrator campaignNotCanceled notChanging {\r\n        if (_idMilestone >= milestones.length) throw;\r\n        Milestone milestone = milestones[_idMilestone];\r\n        if  ((milestone.status != MilestoneStatus.AcceptedAndInProgress) &&\r\n             (milestone.status != MilestoneStatus.Completed))\r\n           throw;\r\n        authorizePayment(_idMilestone);\r\n    }\r\n\r\n    /// @notice `onlyArbitrator` Cancels the entire campaign voiding all\r\n    ///  milestones vo\r\n    function arbitrateCancelCampaign() onlyArbitrator campaignNotCanceled {\r\n        campaignCanceled = true;\r\n        CampaignCanceled();\r\n    }\r\n\r\n    // @dev This internal function is executed when the milestone is paid out\r\n    function authorizePayment(uint _idMilestone) internal {\r\n        if (_idMilestone >= milestones.length) throw;\r\n        Milestone milestone = milestones[_idMilestone];\r\n        // Recheck again to not pay twice\r\n        if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;\r\n        milestone.status = MilestoneStatus.AuthorizedForPayment;\r\n        if (!milestone.paymentSource.call.value(0)(milestone.payData))\r\n            throw;\r\n        ProposalStatusChanged(_idMilestone, milestone.status);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"proposedMilestones\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"changingMilestones\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"campaignCanceled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unproposeMilestones\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hashProposals\",\"type\":\"bytes32\"}],\"name\":\"acceptProposedMilestones\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idMilestone\",\"type\":\"uint256\"}],\"name\":\"approveCompletedMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMilestones\",\"type\":\"bytes\"}],\"name\":\"proposeMilestones\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbitrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"arbitrateCancelCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRecipient\",\"type\":\"address\"}],\"name\":\"changeRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idMilestone\",\"type\":\"uint256\"}],\"name\":\"requestMilestonePayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfMilestones\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idMilestone\",\"type\":\"uint256\"}],\"name\":\"rejectMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDonor\",\"type\":\"address\"}],\"name\":\"changeDonor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"milestones\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"minCompletionDate\",\"type\":\"uint256\"},{\"name\":\"maxCompletionDate\",\"type\":\"uint256\"},{\"name\":\"milestoneLeadLink\",\"type\":\"address\"},{\"name\":\"reviewer\",\"type\":\"address\"},{\"name\":\"reviewTime\",\"type\":\"uint256\"},{\"name\":\"paymentSource\",\"type\":\"address\"},{\"name\":\"payData\",\"type\":\"bytes\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"doneTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idMilestone\",\"type\":\"uint256\"}],\"name\":\"markMilestoneComplete\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idMilestone\",\"type\":\"uint256\"}],\"name\":\"arbitrateApproveMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idMilestone\",\"type\":\"uint256\"}],\"name\":\"cancelMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newArbitrator\",\"type\":\"address\"}],\"name\":\"changeArbitrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_arbitrator\",\"type\":\"address\"},{\"name\":\"_donor\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewMilestoneListProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewMilestoneListUnproposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewMilestoneListAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"idProposal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newProposal\",\"type\":\"uint8\"}],\"name\":\"ProposalStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CampaignCanceled\",\"type\":\"event\"}]","ContractName":"MilestoneTracker","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dda882a62600c452419145781e45052fdc06382c000000000000000000000000b8bed6a570ca87d03e4e386f27d14822179d10f9000000000000000000000000839395e20bbb182fa440d08f850e6c7a8f6f0780","Library":"","SwarmSource":"bzzr://596fbc138602853c00a5d4143ce9979663cc367ea22684dac309f3bb4738f79d"}]}