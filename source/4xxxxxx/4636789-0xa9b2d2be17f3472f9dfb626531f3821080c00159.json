{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract token {\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function setStartTime(uint _startTime) external;\r\n}\r\n\r\n/**\r\n * @title BitDegree Crowdsale\r\n */\r\ncontract BitDegreeCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    // Investor contributions\r\n    mapping(address => uint256) balances;\r\n\r\n    // The token being sold\r\n    token public reward;\r\n\r\n    // Owner of the token\r\n    address public owner;\r\n\r\n    // Start and end timestamps\r\n    uint public startTime;\r\n    uint public endTime;\r\n\r\n    // Address where funds are collected\r\n    address public wallet;\r\n\r\n    // Amount of tokens that were sold\r\n    uint256 public tokensSold;\r\n\r\n    // Soft cap in BDG tokens\r\n    uint256 constant public softCap = 6250000 * (10**18);\r\n\r\n    // Hard cap in BDG tokens\r\n    uint256 constant public hardCap = 336600000 * (10**18);\r\n\r\n    // Switched to true once token contract is notified of when to enable token transfers\r\n    bool private isStartTimeSet = false;\r\n\r\n    /**\r\n     * @dev Event for token purchase logging\r\n     * @param purchaser Address that paid for the tokens\r\n     * @param beneficiary Address that got the tokens\r\n     * @param value The amount that was paid (in wei)\r\n     * @param amount The amount of tokens that were bought\r\n     */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    /**\r\n     * @dev Event for refund logging\r\n     * @param receiver The address that received the refund\r\n     * @param amount The amount that is being refunded (in wei)\r\n     */\r\n    event Refund(address indexed receiver, uint256 amount);\r\n\r\n    /**\r\n     * @param _startTime Unix timestamp for the start of the token sale\r\n     * @param _endTime Unix timestamp for the end of the token sale\r\n     * @param _wallet Ethereum address to which the invested funds are forwarded\r\n     * @param _token Address of the token that will be rewarded for the investors\r\n     * @param _owner Address of the owner of the smart contract who can execute restricted functions\r\n     */\r\n    function BitDegreeCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _owner)  public {\r\n        require(_startTime >= now);\r\n        require(_endTime >= _startTime);\r\n        require(_wallet != address(0));\r\n        require(_token != address(0));\r\n        require(_owner != address(0));\r\n\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        wallet = _wallet;\r\n        owner = _owner;\r\n        reward = token(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that can be used to buy tokens. Or in case of the owner, return ether to allow refunds.\r\n     */\r\n    function () external payable {\r\n        if(msg.sender == wallet) {\r\n            require(hasEnded() && tokensSold < softCap);\r\n        } else {\r\n            buyTokens(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function for buying tokens\r\n     * @param beneficiary The address that should receive bought tokens\r\n     */\r\n    function buyTokens(address beneficiary) public payable {\r\n        require(beneficiary != address(0));\r\n        require(validPurchase());\r\n\r\n        uint256 weiAmount = msg.value;\r\n        uint256 returnToSender = 0;\r\n\r\n        // Retrieve the current token rate\r\n        uint256 rate = getRate();\r\n\r\n        // Calculate token amount to be transferred\r\n        uint256 tokens = weiAmount.mul(rate);\r\n\r\n        // Distribute only the remaining tokens if final contribution exceeds hard cap\r\n        if(tokensSold.add(tokens) > hardCap) {\r\n            tokens = hardCap.sub(tokensSold);\r\n            weiAmount = tokens.div(rate);\r\n            returnToSender = msg.value.sub(weiAmount);\r\n        }\r\n\r\n        // update state\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        // update balance\r\n        balances[beneficiary] = balances[beneficiary].add(weiAmount);\r\n\r\n        assert(reward.transferFrom(owner, beneficiary, tokens));\r\n        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n\r\n        // Forward funds\r\n        wallet.transfer(weiAmount);\r\n\r\n        // Allow transfers 2 weeks after hard cap is reached\r\n        if(tokensSold == hardCap) {\r\n            reward.setStartTime(now + 2 weeks);\r\n        }\r\n\r\n        // Notify token contract about sale end time\r\n        if(!isStartTimeSet) {\r\n            isStartTimeSet = true;\r\n            reward.setStartTime(endTime + 2 weeks);\r\n        }\r\n\r\n        // Return funds that are over hard cap\r\n        if(returnToSender > 0) {\r\n            msg.sender.transfer(returnToSender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that is used to determine the current rate for token / ETH conversion\r\n     * @return The current token rate\r\n     */\r\n    function getRate() internal constant returns (uint256) {\r\n        if(now < (startTime + 1 weeks)) {\r\n            return 11500;\r\n        }\r\n\r\n        if(now < (startTime + 2 weeks)) {\r\n            return 11000;\r\n        }\r\n\r\n        if(now < (startTime + 3 weeks)) {\r\n            return 10500;\r\n        }\r\n\r\n        return 10000;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that is used to check if the incoming purchase should be accepted.\r\n     * @return True if the transaction can buy tokens\r\n     */\r\n    function validPurchase() internal constant returns (bool) {\r\n        bool withinPeriod = now >= startTime && now <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        bool hardCapNotReached = tokensSold < hardCap;\r\n        return withinPeriod && nonZeroPurchase && hardCapNotReached;\r\n    }\r\n\r\n    /**\r\n     * @return True if crowdsale event has ended\r\n     */\r\n    function hasEnded() public constant returns (bool) {\r\n        return now > endTime || tokensSold >= hardCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns ether to token holders in case soft cap is not reached.\r\n     */\r\n    function claimRefund() external {\r\n        require(hasEnded());\r\n        require(tokensSold < softCap);\r\n\r\n        uint256 amount = balances[msg.sender];\r\n\r\n        if(address(this).balance >= amount) {\r\n            balances[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                msg.sender.transfer(amount);\r\n                Refund(msg.sender, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) external constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"reward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"BitDegreeCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a215250000000000000000000000000000000000000000000000000000000005a464a6000000000000000000000000001de7a62197aab2a6a3a3ab8003671a2b261bdfd0000000000000000000000001961b3331969ed52770751fc718ef530838b6dee000000000000000000000000e259ece17feef05bdead9689c6f1bc8e778c517b","Library":"","SwarmSource":"bzzr://d7b8d7a4754fcfe3d595a9e7f6f55b286be25c5e992db066e52e598339738896"}]}