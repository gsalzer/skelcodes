{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n/*\r\n\r\n  Ziber.io Contract\r\n  ========================\r\n  Buys ZBR tokens from the DAO crowdsale on your behalf.\r\n  Author: /u/Leo\r\n\r\n*/\r\n\r\n\r\n// Interface to ZBR ICO Contract\r\ncontract DaoToken {\r\n  uint256 public CAP;\r\n  uint256 public totalEthers;\r\n  function proxyPayment(address participant) payable;\r\n  function transfer(address _to, uint _amount) returns (bool success);\r\n}\r\n\r\ncontract ZiberToken {\r\n  // Store the amount of ETH deposited by each account.\r\n  mapping (address => uint256) public balances;\r\n  // Store whether or not each account would have made it into the crowdsale.\r\n  mapping (address => bool) public checked_in;\r\n  // Bounty for executing buy.\r\n  uint256 public bounty;\r\n  // Track whether the contract has bought the tokens yet.\r\n  bool public bought_tokens;\r\n  // Record the time the contract bought the tokens.\r\n  uint256 public time_bought;\r\n  // Emergency kill switch in case a critical bug is found.\r\n  bool public kill_switch;\r\n  \r\n  /* Public variables of the token */\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  \r\n  // Ratio of ZBR tokens received to ETH contributed\r\n  // 1.000.000 BGP = 80.000.000 ZBR\r\n  // 1ETH = 218 BGP (03.07.2017: https://www.coingecko.com/en/price_charts/ethereum/gbp)\r\n  // 1 ETH = 17440 ZBR\r\n  uint256 ZBR_per_eth = 17440;\r\n  //Total ZBR Tokens Reserve\r\n  uint256 ZBR_total_reserve = 100000000;\r\n  // ZBR Tokens for Developers\r\n  uint256 ZBR_dev_reserved = 10000000;\r\n  // ZBR Tokens for Selling over ICO\r\n  uint256 ZBR_for_selling = 80000000;\r\n  // ZBR Tokens for Bounty\r\n  uint256 ZBR_for_bounty= 10000000;\r\n  // ETH for activate kill-switch in contract\r\n  uint256 ETH_to_end = 50000 ether;\r\n  uint registredTo;\r\n  uint256 loadedRefund;\r\n  uint256 _supply;\r\n  string _name;\r\n  string _symbol;\r\n  uint8 _decimals;\r\n\r\n  // The ZBR Token address and sale address are the same.\r\n  DaoToken public token = DaoToken(0xa9d585CE3B227d69985c3F7A866fE7d0e510da50);\r\n  // The developer address.\r\n  address developer_address = 0x650887B33BFA423240ED7Bc4BD26c66075E3bEaf;\r\n\r\n\r\n  /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    \r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function ZiberToken() {\r\n        /* if supply not given then generate 100 million of the smallest unit of the token */\r\n        _supply = 10000000000;\r\n        \r\n        /* Unless you add other functions these variables will never change */\r\n        balanceOf[msg.sender] = _supply;\r\n        name = \"ZIBER CW Tokens\";     \r\n        symbol = \"ZBR\";\r\n        \r\n        /* If you want a divisible token then add the amount of decimals the base unit has  */\r\n        decimals = 2;\r\n    }\r\n\r\n\r\n    /// SafeMath contract - math operations with safety checks\r\n    /// @author dev@smartcontracteam.com\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n      uint c = a * b;\r\n      assert(a == 0 || c / a == b);\r\n      return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n      assert(b > 0);\r\n      uint c = a / b;\r\n      assert(a == b * c + a % b);\r\n      return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n      uint c = a + b;\r\n      assert(c>=a && c>=b);\r\n      return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n      return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n      return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n      return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n      return a < b ? a : b;\r\n    }\r\n\r\n    function assert(bool assertion) internal {\r\n      if (!assertion) {\r\n        throw;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n    * Allow load refunds back on the contract for the refunding.\r\n    *\r\n    * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\n    */\r\n    function loadRefund() payable {\r\n      if(msg.value == 0) throw;\r\n      loadedRefund = safeAdd(loadedRefund, msg.value);\r\n    }\r\n\r\n    /**\r\n    * Investors can claim refund.\r\n    */\r\n    function refund() private  {\r\n      uint256 weiValue = this.balance;\r\n      if (weiValue == 0) throw;\r\n      uint256 weiRefunded;\r\n      weiRefunded = safeAdd(weiRefunded, weiValue);\r\n      refund();\r\n      if (!msg.sender.send(weiValue)) throw;\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        /* if the sender doenst have enough balance then stop */\r\n        if (balanceOf[msg.sender] < _value) throw;\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\r\n        \r\n        /* Add and subtract new balances */\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        \r\n        /* Notifiy anyone listening that this transfer took place */\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n  \r\n  // Allows the developer to shut down everything except withdrawals in emergencies.\r\n  function activate_kill_switch() {\r\n    // Only allow the developer to activate the kill switch.\r\n    if (msg.sender != developer_address) throw;\r\n    // Irreversibly activate the kill switch.\r\n    kill_switch = true;\r\n  }\r\n  \r\n  // Withdraws all ETH deposited or ZBR purchased by the sender.\r\n  function withdraw(){\r\n    // If called before the ICO, cancel caller's participation in the sale.\r\n    if (!bought_tokens) {\r\n      // Store the user's balance prior to withdrawal in a temporary variable.\r\n      uint256 eth_amount = balances[msg.sender];\r\n      // Update the user's balance prior to sending ETH to prevent recursive call.\r\n      balances[msg.sender] = 0;\r\n      // Return the user's funds.  Throws on failure to prevent loss of funds.\r\n      msg.sender.transfer(eth_amount);\r\n    }\r\n    // Withdraw the sender's tokens if the contract has already purchased them.\r\n    else {\r\n      // Store the user's ZBR balance in a temporary variable (1 ETHWei -> 2000 ZBRWei).\r\n      uint256 ZBR_amount = balances[msg.sender] * ZBR_per_eth;\r\n      // Update the user's balance prior to sending ZBR to prevent recursive call.\r\n      balances[msg.sender] = 0;\r\n      // No fee for withdrawing if the user would have made it into the crowdsale alone.\r\n      uint256 fee = 0;\r\n      // 1% fee if the user didn't check in during the crowdsale.\r\n      if (!checked_in[msg.sender]) {\r\n        fee = ZBR_amount / 100;\r\n        // Send any non-zero fees to developer.\r\n        if(!token.transfer(developer_address, fee)) throw;\r\n      }\r\n      // Send the user their tokens.  Throws if the crowdsale isn't over.\r\n      if(!token.transfer(msg.sender, ZBR_amount - fee)) throw;\r\n    }\r\n  }\r\n  \r\n  // Allow developer to add ETH to the buy execution bounty.\r\n  function add_to_bounty() payable {\r\n    // Only allow the developer to contribute to the buy execution bounty.\r\n    if (msg.sender != developer_address) throw;\r\n    // Disallow adding to bounty if kill switch is active.\r\n    if (kill_switch) throw;\r\n    // Disallow adding to the bounty if contract has already bought the tokens.\r\n    if (bought_tokens) throw;\r\n    // Update bounty to include received amount.\r\n    bounty += msg.value;\r\n  }\r\n  \r\n  // Buys tokens in the crowdsale and rewards the caller, callable by anyone.\r\n  function claim_bounty(){\r\n    // Short circuit to save gas if the contract has already bought tokens.\r\n    if (bought_tokens) return;\r\n    // Disallow buying into the crowdsale if kill switch is active.\r\n    if (kill_switch) throw;\r\n    // Record that the contract has bought the tokens.\r\n    bought_tokens = true;\r\n    // Record the time the contract bought the tokens.\r\n    time_bought = now + 1 days;\r\n    // Transfer all the funds (less the bounty) to the ZBR crowdsale contract\r\n    // to buy tokens.  Throws if the crowdsale hasn't started yet or has\r\n    // already completed, preventing loss of funds.\r\n    token.proxyPayment.value(this.balance - bounty)(address(this));\r\n    // Send the caller their bounty for buying tokens for the contract.\r\n    if(this.balance > ETH_to_end)\r\n    {\r\n        msg.sender.transfer(bounty);\r\n    }\r\n    else {\r\n        time_bought = now +  1 days * 9;\r\n        if(this.balance > ETH_to_end) {\r\n          msg.sender.transfer(bounty);\r\n        }\r\n      }\r\n  }\r\n\r\n    //Check is msg_sender is contract dev\r\n  modifier onlyOwner() {\r\n    if (msg.sender != developer_address) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n  \r\n  // Send fund when ico end\r\n  function withdrawEth() onlyOwner {        \r\n        msg.sender.transfer(this.balance);\r\n  }\r\n  \r\n  //Kill contract\r\n  function kill() onlyOwner {        \r\n        selfdestruct(developer_address);\r\n  }\r\n  \r\n  // A helper function for the default function, allowing contracts to interact.\r\n  function default_helper() payable {\r\n    // Treat near-zero ETH transactions as check ins and withdrawal requests.\r\n    if (msg.value <= 1 finney) {\r\n      // Check in during the crowdsale.\r\n      if (bought_tokens) {\r\n        // Only allow checking in before the crowdsale has reached the cap.\r\n        if (token.totalEthers() >= token.CAP()) throw;\r\n        // Mark user as checked in, meaning they would have been able to enter alone.\r\n        checked_in[msg.sender] = true;\r\n      }\r\n      // Withdraw funds if the crowdsale hasn't begun yet or is already over.\r\n      else {\r\n        withdraw();\r\n      }\r\n    }\r\n    // Deposit the user's funds for use in purchasing tokens.\r\n    else {\r\n      // Disallow deposits if kill switch is active.\r\n      if (kill_switch) throw;\r\n      // Only allow deposits if the contract hasn't already purchased the tokens.\r\n      if (bought_tokens) throw;\r\n      // Update records of deposited ETH to include the received amount.\r\n      balances[msg.sender] += msg.value;\r\n    }\r\n  }\r\n  \r\n  // Default function.  Called when a user sends ETH to the contract.\r\n  function () payable {\r\n    // Delegate to the helper function.\r\n    default_helper();\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"claim_bounty\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"checked_in\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"default_helper\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"add_to_bounty\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bought_tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate_kill_switch\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"loadRefund\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kill_switch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"time_bought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"ZiberToken","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b3b86b6cf7f0a32a9ca1bf3ecefc1f91c55b890a15f2fc70456df640f90005d4"}]}