{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract Fibonzi{\r\n    \r\n    address owner;\r\n    uint8 poolCount = 0;\r\n    uint8 playerCount = 0;\r\n    uint8 poolJoinedCount = 0;\r\n    uint fiboIndex = 0;\r\n    uint poolToCreate = 0;\r\n    uint8 tokenCount = 0;\r\n    uint8 tokenUsed = 0;\r\n    uint8 fiboMax = 0;\r\n    uint8 tokenToReward = 0;\r\n    uint currentShare = 0;\r\n    \r\n    struct Player{\r\n        uint8 playerId;\r\n        address wallet;\r\n        uint playerBalance;\r\n    }\r\n    \r\n    struct Pool{\r\n        uint8 poolId;\r\n        uint price;\r\n        uint8 owner;\r\n    }\r\n    \r\n    struct Token{\r\n        uint8 tokenId;\r\n        uint8 playerId;\r\n        bool used;\r\n    }\r\n\r\n    mapping(uint8 => Player) players;\r\n    mapping(uint8 => Pool) pools;\r\n    mapping(address => uint8) playersWallets;\r\n    mapping(address => Token[]) playersToken;\r\n    mapping(address => uint) playersBalance;\r\n    \r\n    event PlayerCreated(uint8 indexed playerId, address indexed wallet,uint timestamp);\r\n    event PlayerBalance(uint8 indexed playerId, uint playerBalance, uint timestamp);\r\n    event PoolCreated(uint8 indexed poolId,uint price, uint timestamp);\r\n    event PoolJoined(uint8 indexed poolId, uint8 indexed playerId, uint256 price, uint timestamp);\r\n    event PoolPrize(uint8 indexed poolId, uint8 indexed playerId, uint prize, uint timestamp);\r\n    event TokenCreated(uint8 indexed tokenId, uint8 indexed playerId);\r\n    event TokenUsed(uint8 indexed tokenId, uint8 indexed playerId);\r\n    \r\n    function Fibonzi(){\r\n        owner = msg.sender;\r\n        createPlayer();\r\n        createPool();\r\n        fiboIndex++;\r\n        fiboMax = 18;\r\n    }\r\n    \r\n    function openPool(uint8 poolId) payable{\r\n        assert(poolCount >= poolId);\r\n        assert(playersWallets[msg.sender] > 0);\r\n        assert(msg.sender == players[playersWallets[msg.sender]].wallet);\r\n        assert(msg.value >= pools[poolId].price);\r\n        assert(getPlayerUsableTokensCount() > 0);\r\n        assert(usePlayerToken());\r\n        \r\n        var price = pools[poolId].price;\r\n        owner.transfer(price);\r\n        PoolPrize(poolId,pools[poolId].owner,2*price,now);\r\n        //change the owner of the pool as the current player\r\n        pools[poolId].owner = players[playersWallets[msg.sender]].playerId;\r\n        \r\n        //return the change if any\r\n        if(msg.value > pools[poolId].price){\r\n            players[playersWallets[msg.sender]].wallet.transfer(msg.value - pools[poolId].price);\r\n        }\r\n        \r\n        //double the price of the pool\r\n        pools[poolId].price = 2*price;\r\n        PoolJoined(poolId,playersWallets[msg.sender],pools[poolId].price,now);\r\n        poolJoinedCount++;\r\n        \r\n        if(fiboIndex <= fiboMax){\r\n            createPoolIfNeeded();\r\n        }\r\n    }\r\n    \r\n    function joinPool(uint8 poolId) payable{\r\n        assert(poolCount >= poolId);\r\n        assert(playersWallets[msg.sender] > 0);\r\n        assert(msg.sender == players[playersWallets[msg.sender]].wallet);\r\n        assert(players[playersWallets[msg.sender]].playerId != pools[poolId].owner);\r\n        assert(msg.value >= pools[poolId].price);\r\n        assert( (pools[poolId].owner == owner && poolCount == 1) || (pools[poolId].owner != players[0].playerId));\r\n        \r\n        //send the amount to the owner\r\n        uint price = pools[poolId].price;\r\n        players[pools[poolId].owner].wallet.transfer((price * 80)/100);\r\n        //distribute the 20% to all token holders\r\n        distributeReward(price);\r\n        \r\n        PoolPrize(poolId,pools[poolId].owner,2*price,now);\r\n        //change the owner of the pool as the current player\r\n        pools[poolId].owner = players[playersWallets[msg.sender]].playerId;\r\n        \r\n        //return the change if any\r\n        if(msg.value > pools[poolId].price){\r\n            players[playersWallets[msg.sender]].wallet.transfer(msg.value - pools[poolId].price);\r\n        }\r\n        \r\n        //double the price of the pool\r\n        pools[poolId].price = 2*price;\r\n        PoolJoined(poolId,playersWallets[msg.sender],pools[poolId].price,now);\r\n        poolJoinedCount++;\r\n        \r\n        if(fiboIndex <= fiboMax){\r\n            createPoolIfNeeded();\r\n        }\r\n        //give token to the current player\r\n        createPlayerToken();\r\n    }\r\n    \r\n    function distributeReward(uint price) internal{\r\n        if(tokenCount - tokenUsed > 0){\r\n            tokenToReward = tokenCount - tokenUsed;\r\n            uint share = (price*20/100)/(tokenCount - tokenUsed);\r\n            currentShare = share;\r\n            for(uint8 i=0; i< playerCount;i++){\r\n                uint count = 0;\r\n                for(uint8 j=0;j< playersToken[players[i+1].wallet].length;j++){\r\n                    if(!playersToken[players[i+1].wallet][j].used){\r\n                       count++; \r\n                    }\r\n                }\r\n                if(count > 0){\r\n                    players[i+1].playerBalance += share*count;\r\n                    playersBalance[players[i+1].wallet] = players[i+1].playerBalance;\r\n                    PlayerBalance(players[i+1].playerId,players[i+1].playerBalance,now);   \r\n                }\r\n            }\r\n        }\r\n        else{\r\n            // no token owner => send to owner\r\n            players[playersWallets[owner]].playerBalance += (price*20/100);\r\n            playersBalance[owner] = players[playersWallets[owner]].playerBalance;\r\n            PlayerBalance(players[playersWallets[owner]].playerId,players[playersWallets[owner]].playerBalance,now);   \r\n        }\r\n    }\r\n    \r\n    function withdraw(){\r\n        assert(playersWallets[msg.sender] > 0);\r\n        assert(getPlayerUsableTokensCount()>10);\r\n        assert(playersBalance[msg.sender] >0);\r\n        \r\n        players[playersWallets[msg.sender]].wallet.transfer(playersBalance[msg.sender]);\r\n        for(uint i=0;i<10;i++){\r\n            usePlayerToken();\r\n        }\r\n        players[playersWallets[msg.sender]].playerBalance = 0;\r\n        playersBalance[players[playersWallets[msg.sender]].wallet] = 0;\r\n        PlayerBalance(players[playersWallets[msg.sender]].playerId,0,now);   \r\n    }\r\n    \r\n    //someone has to call create pool\r\n    function createPool() internal{\r\n        poolCount++;\r\n        pools[poolCount] = Pool(poolCount,1e16,players[1].playerId);\r\n        PoolCreated(poolCount,1e16,now);\r\n        \r\n    }\r\n    \r\n    function createPlayer() returns (uint256){\r\n        for(uint8 i=0; i< playerCount;i++){\r\n            assert(players[i+1].wallet != msg.sender);\r\n        }\r\n        \r\n        playerCount++;\r\n        players[playerCount] = Player(playerCount,msg.sender,0);\r\n        playersWallets[msg.sender] = playerCount;\r\n        PlayerCreated(playersWallets[msg.sender],msg.sender,now);\r\n        return playerCount;\r\n    }\r\n    \r\n    function createPoolIfNeeded() internal{\r\n        var currentFibo = getFibo(fiboIndex);\r\n        if(poolJoinedCount > currentFibo){\r\n            fiboIndex++;\r\n            createPoolIfNeeded();\r\n        }\r\n        else if(poolJoinedCount == currentFibo){\r\n            if(currentFibo > poolCount){\r\n                poolToCreate = currentFibo - poolCount;\r\n                for(uint i=0; i< poolToCreate; i++){\r\n                    createPool();\r\n                    //add Token to the player who generates the pools\r\n                    createPlayerToken();\r\n                }\r\n                poolToCreate = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function createPlayerToken() internal{\r\n        tokenCount++;\r\n        playersToken[msg.sender].push(Token(tokenCount,players[playersWallets[msg.sender]].playerId,false));\r\n        TokenCreated(tokenCount,players[playersWallets[msg.sender]].playerId);\r\n        if(tokenCount % 9 == 0){\r\n            tokenCount++;\r\n            playersToken[owner].push(Token(tokenCount,players[playersWallets[owner]].playerId,false));\r\n            TokenCreated(tokenCount,players[playersWallets[owner]].playerId);\r\n        }\r\n    }\r\n    \r\n    function getFibo(uint n) internal returns (uint){\r\n        if(n<=1){\r\n            return n;\r\n        }\r\n        else{\r\n            return getFibo(n-1) + getFibo(n-2);\r\n        }\r\n    }\r\n    \r\n    function getPlayerUsableTokensCount() internal returns (uint8){\r\n        uint8 count = 0;\r\n        for(uint8 i=0;i< playersToken[msg.sender].length;i++){\r\n            if(!playersToken[msg.sender][i].used){\r\n               count++; \r\n            }\r\n        }\r\n        return count;\r\n    }\r\n    \r\n    function usePlayerToken() internal returns (bool){\r\n        var used = false;\r\n        for(uint8 i=0;i< playersToken[msg.sender].length;i++){\r\n            if(!playersToken[msg.sender][i].used && !used){\r\n                playersToken[msg.sender][i].used = true;\r\n                used = true;\r\n                tokenUsed++;\r\n                TokenUsed(playersToken[msg.sender][i].tokenId,playersToken[msg.sender][i].playerId);\r\n            }\r\n        }\r\n        return used;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"poolId\",\"type\":\"uint8\"}],\"name\":\"joinPool\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"poolId\",\"type\":\"uint8\"}],\"name\":\"openPool\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PlayerCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"playerBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PlayerBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"playerId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PoolJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poolId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"playerId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PoolPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"playerId\",\"type\":\"uint8\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"playerId\",\"type\":\"uint8\"}],\"name\":\"TokenUsed\",\"type\":\"event\"}]","ContractName":"Fibonzi","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2546cf0d8283bcae92712e67e0ca983590ecee3f371a75372c87cc61594d734a"}]}