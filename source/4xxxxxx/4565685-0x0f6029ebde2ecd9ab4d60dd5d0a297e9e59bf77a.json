{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Drainable is Ownable {\r\n\tfunction withdrawToken(address tokenaddr) \r\n\t\tonlyOwner \r\n\t{\r\n\t\tERC20 token = ERC20(tokenaddr);\r\n\t\tuint bal = token.balanceOf(address(this));\r\n\t\ttoken.transfer(msg.sender, bal);\r\n\t}\r\n\r\n\tfunction withdrawEther() \r\n\t\tonlyOwner\r\n\t{\r\n\t    require(msg.sender.send(this.balance));\r\n\t}\r\n}\r\n\r\n\r\ncontract ADXRegistry is Ownable, Drainable {\r\n\tstring public name = \"AdEx Registry\";\r\n\r\n\t// Structure:\r\n\t// AdUnit (advertiser) - a unit of a single advertisement\r\n\t// AdSlot (publisher) - a particular property (slot) that can display an ad unit\r\n\t// Campaign (advertiser) - group of ad units ; not vital\r\n\t// Channel (publisher) - group of properties ; not vital\r\n\t// Each Account is linked to all the items they own through the Account struct\r\n\r\n\tmapping (address => Account) public accounts;\r\n\r\n\t// XXX: mostly unused, because solidity does not allow mapping with enum as primary type.. :( we just use uint\r\n\tenum ItemType { AdUnit, AdSlot, Campaign, Channel }\r\n\r\n\t// uint here corresponds to the ItemType\r\n\tmapping (uint => uint) public counts;\r\n\tmapping (uint => mapping (uint => Item)) public items;\r\n\r\n\t// Publisher or Advertiser (could be both)\r\n\tstruct Account {\t\t\r\n\t\taddress addr;\r\n\t\taddress wallet;\r\n\r\n\t\tbytes32 ipfs; // ipfs addr for additional (larger) meta\r\n\t\tbytes32 name; // name\r\n\t\tbytes32 meta; // metadata, can be JSON, can be other format, depends on the high-level implementation\r\n\r\n\t\tbytes32 signature; // signature in the off-blockchain state channel\r\n\t\t\r\n\t\t// Items, by type, then in an array of numeric IDs\t\r\n\t\tmapping (uint => uint[]) items;\r\n\t}\r\n\r\n\t// Sub-item, such as AdUnit, AdSlot, Campaign, Channel\r\n\tstruct Item {\r\n\t\tuint id;\r\n\t\taddress owner;\r\n\r\n\t\tItemType itemType;\r\n\r\n\t\tbytes32 ipfs; // ipfs addr for additional (larger) meta\r\n\t\tbytes32 name; // name\r\n\t\tbytes32 meta; // metadata, can be JSON, can be other format, depends on the high-level implementation\r\n\t}\r\n\r\n\tmodifier onlyRegistered() {\r\n\t\tvar acc = accounts[msg.sender];\r\n\t\trequire(acc.addr != 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t// can be called over and over to update the data\r\n\t// XXX consider entrance barrier, such as locking in some ADX\r\n\tfunction register(bytes32 _name, address _wallet, bytes32 _ipfs, bytes32 _sig, bytes32 _meta)\r\n\t\texternal\r\n\t{\r\n\t\trequire(_wallet != 0);\r\n\t\t// XXX should we ensure _sig is not 0? if so, also add test\r\n\t\t\r\n\t\trequire(_name != 0);\r\n\r\n\t\tvar isNew = accounts[msg.sender].addr == 0;\r\n\r\n\t\tvar acc = accounts[msg.sender];\r\n\r\n\t\tif (!isNew) require(acc.signature == _sig);\r\n\t\telse acc.signature = _sig;\r\n\r\n\t\tacc.addr = msg.sender;\r\n\t\tacc.wallet = _wallet;\r\n\t\tacc.ipfs = _ipfs;\r\n\t\tacc.name = _name;\r\n\t\tacc.meta = _meta;\r\n\r\n\t\tif (isNew) LogAccountRegistered(acc.addr, acc.wallet, acc.ipfs, acc.name, acc.meta, acc.signature);\r\n\t\telse LogAccountModified(acc.addr, acc.wallet, acc.ipfs, acc.name, acc.meta, acc.signature);\r\n\t}\r\n\r\n\t// use _id = 0 to create a new item, otherwise modify existing\r\n\tfunction registerItem(uint _type, uint _id, bytes32 _ipfs, bytes32 _name, bytes32 _meta)\r\n\t\tonlyRegistered\r\n\t{\r\n\t\t// XXX _type sanity check?\r\n\t\tvar item = items[_type][_id];\r\n\r\n\t\tif (_id != 0)\r\n\t\t\trequire(item.owner == msg.sender);\r\n\t\telse {\r\n\t\t\t// XXX: what about overflow here?\r\n\t\t\tvar newId = ++counts[_type];\r\n\r\n\t\t\titem = items[_type][newId];\r\n\t\t\titem.id = newId;\r\n\t\t\titem.itemType = ItemType(_type);\r\n\t\t\titem.owner = msg.sender;\r\n\r\n\t\t\taccounts[msg.sender].items[_type].push(item.id);\r\n\t\t}\r\n\r\n\t\titem.name = _name;\r\n\t\titem.meta = _meta;\r\n\t\titem.ipfs = _ipfs;\r\n\r\n\t\tif (_id == 0) LogItemRegistered(\r\n\t\t\titem.owner, uint(item.itemType), item.id, item.ipfs, item.name, item.meta\r\n\t\t);\r\n\t\telse LogItemModified(\r\n\t\t\titem.owner, uint(item.itemType), item.id, item.ipfs, item.name, item.meta\r\n\t\t);\r\n\t}\r\n\r\n\t// NOTE\r\n\t// There's no real point of un-registering items\r\n\t// Campaigns need to be kept anyway, as well as ad units\r\n\t// END NOTE\r\n\r\n\t//\r\n\t// Constant functions\r\n\t//\r\n\tfunction isRegistered(address who)\r\n\t\tpublic \r\n\t\tconstant\r\n\t\treturns (bool)\r\n\t{\r\n\t\tvar acc = accounts[who];\r\n\t\treturn acc.addr != 0;\r\n\t}\r\n\r\n\t// Functions exposed for web3 interface\r\n\t// NOTE: this is sticking to the policy of keeping static-sized values at the left side of tuples\r\n\tfunction getAccount(address _acc)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (address, bytes32, bytes32, bytes32)\r\n\t{\r\n\t\tvar acc = accounts[_acc];\r\n\t\trequire(acc.addr != 0);\r\n\t\treturn (acc.wallet, acc.ipfs, acc.name, acc.meta);\r\n\t}\r\n\r\n\tfunction getAccountItems(address _acc, uint _type)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (uint[])\r\n\t{\r\n\t\tvar acc = accounts[_acc];\r\n\t\trequire(acc.addr != 0);\r\n\t\treturn acc.items[_type];\r\n\t}\r\n\r\n\tfunction getItem(uint _type, uint _id) \r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (address, bytes32, bytes32, bytes32)\r\n\t{\r\n\t\tvar item = items[_type][_id];\r\n\t\trequire(item.id != 0);\r\n\t\treturn (item.owner, item.ipfs, item.name, item.meta);\r\n\t}\r\n\r\n\tfunction hasItem(uint _type, uint _id)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (bool)\r\n\t{\r\n\t\tvar item = items[_type][_id];\r\n\t\treturn item.id != 0;\r\n\t}\r\n\r\n\t// Events\r\n\tevent LogAccountRegistered(address addr, address wallet, bytes32 ipfs, bytes32 accountName, bytes32 meta, bytes32 signature);\r\n\tevent LogAccountModified(address addr, address wallet, bytes32 ipfs, bytes32 accountName, bytes32 meta, bytes32 signature);\r\n\t\r\n\tevent LogItemRegistered(address owner, uint itemType, uint id, bytes32 ipfs, bytes32 itemName, bytes32 meta);\r\n\tevent LogItemModified(address owner, uint itemType, uint id, bytes32 ipfs, bytes32 itemName, bytes32 meta);\r\n}\r\n\r\n\r\ncontract ADXExchange is Ownable, Drainable {\r\n\tstring public name = \"AdEx Exchange\";\r\n\r\n\tERC20 public token;\r\n\tADXRegistry public registry;\r\n\r\n\tuint public bidsCount;\r\n\r\n\tmapping (uint => Bid) bidsById;\r\n\tmapping (uint => uint[]) bidsByAdunit; // bids set out by ad unit\r\n\tmapping (uint => uint[]) bidsByAdslot; // accepted by publisher, by ad slot\r\n\r\n\t// TODO: some properties in the bid structure - achievedPoints/peers for example - are not used atm\r\n\t\r\n\t// CONSIDER: the bid having a adunitType so that this can be filtered out\r\n\t// WHY IT'S NOT IMPORTANT: you can get bids by ad units / ad slots, which is filter enough already considering we know their types\r\n\r\n\t// CONSIDER: locking ad units / ad slots or certain properties from them so that bids cannot be ruined by editing them\r\n\t// WHY IT'S NOT IMPORTANT: from a game theoretical point of view there's no incentive to do that\r\n\r\n\t// corresponds to enum types in ADXRegistry\r\n\tuint constant ADUNIT = 0;\r\n\tuint constant ADSLOT = 1;\r\n\r\n\tenum BidState { \r\n\t\tOpen, \r\n\t\tAccepted, // in progress\r\n\r\n\t\t// the following states MUST unlock the ADX amount (return to advertiser)\r\n\t\t// fail states\r\n\t\tCanceled,\r\n\t\tExpired,\r\n\r\n\t\t// success states\r\n\t\tCompleted,\r\n\t\tClaimed\r\n\t}\r\n\r\n\tstruct Bid {\r\n\t\tuint id;\r\n\t\tBidState state;\r\n\r\n\t\t// ADX reward amount\r\n\t\tuint amount;\r\n\r\n\t\t// Links on advertiser side\r\n\t\taddress advertiser;\r\n\t\taddress advertiserWallet;\r\n\t\tuint adUnit;\r\n\t\tbytes32 adUnitIpfs;\r\n\t\tbytes32 advertiserPeer;\r\n\r\n\t\t// Links on publisher side\r\n\t\taddress publisher;\r\n\t\taddress publisherWallet;\r\n\t\tuint adSlot;\r\n\t\tbytes32 adSlotIpfs;\r\n\t\tbytes32 publisherPeer;\r\n\r\n\t\tuint acceptedTime; // when was it accepted by a publisher\r\n\r\n\t\t// Requirements\r\n\r\n\t\t//RequirementType type;\r\n\t\tuint requiredPoints; // how many impressions/clicks/conversions have to be done\r\n\t\tuint requiredExecTime; // essentially a timeout\r\n\r\n\t\t// Results\r\n\t\tbool confirmedByPublisher;\r\n\t\tbool confirmedByAdvertiser;\r\n\r\n\t\t// IPFS links to result reports \r\n\t\tbytes32 publisherReportIpfs;\r\n\t\tbytes32 advertiserReportIpfs;\r\n\t}\r\n\r\n\t//\r\n\t// MODIFIERS\r\n\t//\r\n\tmodifier onlyRegisteredAcc() {\r\n\t\trequire(registry.isRegistered(msg.sender));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyBidOwner(uint _bidId) {\r\n\t\trequire(msg.sender == bidsById[_bidId].advertiser);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyBidAceptee(uint _bidId) {\r\n\t\trequire(msg.sender == bidsById[_bidId].publisher);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyBidState(uint _bidId, BidState _state) {\r\n\t\trequire(bidsById[_bidId].id != 0);\r\n\t\trequire(bidsById[_bidId].state == _state);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyExistingBid(uint _bidId) {\r\n\t\trequire(bidsById[_bidId].id != 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Functions\r\n\r\n\tfunction ADXExchange(address _token, address _registry)\r\n\t{\r\n\t\ttoken = ERC20(_token);\r\n\t\tregistry = ADXRegistry(_registry);\r\n\t}\r\n\r\n\t//\r\n\t// Bid actions\r\n\t// \r\n\r\n\t// the bid is placed by the advertiser\r\n\tfunction placeBid(uint _adunitId, uint _target, uint _rewardAmount, uint _timeout, bytes32 _peer)\r\n\t\tonlyRegisteredAcc\r\n\t{\r\n\t\tbytes32 adIpfs;\r\n\t\taddress advertiser;\r\n\t\taddress advertiserWallet;\r\n\r\n\t\t// NOTE: those will throw if the ad or respectively the account do not exist\r\n\t\t(advertiser,adIpfs,,) = registry.getItem(ADUNIT, _adunitId);\r\n\t\t(advertiserWallet,,,) = registry.getAccount(advertiser);\r\n\r\n\t\t// XXX: maybe it could be a feature to allow advertisers bidding on other advertisers' ad units, but it will complicate things...\r\n\t\trequire(advertiser == msg.sender);\r\n\r\n\t\tBid memory bid;\r\n\r\n\t\tbid.id = ++bidsCount; // start from 1, so that 0 is not a valid ID\r\n\t\tbid.state = BidState.Open; // XXX redundant, but done for code clarity\r\n\r\n\t\tbid.amount = _rewardAmount;\r\n\r\n\t\tbid.advertiser = advertiser;\r\n\t\tbid.advertiserWallet = advertiserWallet;\r\n\r\n\t\tbid.adUnit = _adunitId;\r\n\t\tbid.adUnitIpfs = adIpfs;\r\n\r\n\t\tbid.requiredPoints = _target;\r\n\t\tbid.requiredExecTime = _timeout;\r\n\r\n\t\tbid.advertiserPeer = _peer;\r\n\r\n\t\tbidsById[bid.id] = bid;\r\n\t\tbidsByAdunit[_adunitId].push(bid.id);\r\n\r\n\t\trequire(token.transferFrom(advertiserWallet, address(this), _rewardAmount));\r\n\r\n\t\tLogBidOpened(bid.id, advertiser, _adunitId, adIpfs, _target, _rewardAmount, _timeout, _peer);\r\n\t}\r\n\r\n\t// the bid is canceled by the advertiser\r\n\tfunction cancelBid(uint _bidId)\r\n\t\tonlyRegisteredAcc\r\n\t\tonlyExistingBid(_bidId)\r\n\t\tonlyBidOwner(_bidId)\r\n\t\tonlyBidState(_bidId, BidState.Open)\r\n\t{\r\n\t\tBid storage bid = bidsById[_bidId];\r\n\t\tbid.state = BidState.Canceled;\r\n\t\trequire(token.transfer(bid.advertiserWallet, bid.amount));\r\n\r\n\t\tLogBidCanceled(bid.id);\r\n\t}\r\n\r\n\t// a bid is accepted by a publisher for a given ad slot\r\n\tfunction acceptBid(uint _bidId, uint _slotId, bytes32 _peer) \r\n\t\tonlyRegisteredAcc \r\n\t\tonlyExistingBid(_bidId) \r\n\t\tonlyBidState(_bidId, BidState.Open)\r\n\t{\r\n\t\taddress publisher;\r\n\t\taddress publisherWallet;\r\n\t\tbytes32 adSlotIpfs;\r\n\r\n\t\t// NOTE: those will throw if the ad slot or respectively the account do not exist\r\n\t\t(publisher,adSlotIpfs,,) = registry.getItem(ADSLOT, _slotId);\r\n\t\t(publisherWallet,,,) = registry.getAccount(publisher);\r\n\r\n\t\trequire(publisher == msg.sender);\r\n\r\n\t\tBid storage bid = bidsById[_bidId];\r\n\r\n\t\t// should not happen when bid.state is BidState.Open, but just in case\r\n\t\trequire(bid.publisher == 0);\r\n\r\n\t\tbid.state = BidState.Accepted;\r\n\t\t\r\n\t\tbid.publisher = publisher;\r\n\t\tbid.publisherWallet = publisherWallet;\r\n\r\n\t\tbid.adSlot = _slotId;\r\n\t\tbid.adSlotIpfs = adSlotIpfs;\r\n\r\n\t\tbid.publisherPeer = _peer;\r\n\r\n\t\tbid.acceptedTime = now;\r\n\r\n\t\tbidsByAdslot[_slotId].push(_bidId);\r\n\r\n\t\tLogBidAccepted(bid.id, publisher, _slotId, adSlotIpfs, bid.acceptedTime, bid.publisherPeer);\r\n\t}\r\n\r\n\t// the bid is given up by the publisher, therefore canceling it and returning the funds to the advertiser\r\n\t// same logic as cancelBid(), but different permissions\r\n\tfunction giveupBid(uint _bidId)\r\n\t\tonlyRegisteredAcc\r\n\t\tonlyExistingBid(_bidId)\r\n\t\tonlyBidAceptee(_bidId)\r\n\t\tonlyBidState(_bidId, BidState.Accepted)\r\n\t{\r\n\t\tvar bid = bidsById[_bidId];\r\n\t\tbid.state = BidState.Canceled;\r\n\t\trequire(token.transfer(bid.advertiserWallet, bid.amount));\r\n\r\n\t\tLogBidCanceled(bid.id);\r\n\t}\r\n\r\n\t// both publisher and advertiser have to call this for a bid to be considered verified\r\n\tfunction verifyBid(uint _bidId, bytes32 _report)\r\n\t\tonlyRegisteredAcc\r\n\t\tonlyExistingBid(_bidId)\r\n\t\tonlyBidState(_bidId, BidState.Accepted)\r\n\t{\r\n\t\tBid storage bid = bidsById[_bidId];\r\n\r\n\t\trequire(bid.publisher == msg.sender || bid.advertiser == msg.sender);\r\n\r\n\t\tif (bid.publisher == msg.sender) {\r\n\t\t\tbid.confirmedByPublisher = true;\r\n\t\t\tbid.publisherReportIpfs = _report;\r\n\t\t}\r\n\r\n\t\tif (bid.advertiser == msg.sender) {\r\n\t\t\tbid.confirmedByAdvertiser = true;\r\n\t\t\tbid.advertiserReportIpfs = _report;\r\n\t\t}\r\n\r\n\t\tif (bid.confirmedByAdvertiser && bid.confirmedByPublisher) {\r\n\t\t\tbid.state = BidState.Completed;\r\n\t\t\tLogBidCompleted(bid.id, bid.advertiserReportIpfs, bid.publisherReportIpfs);\r\n\t\t}\r\n\t}\r\n\r\n\t// now, claim the reward; callable by the publisher;\r\n\t// claimBidReward is a separate function so as to define clearly who pays the gas for transfering the reward \r\n\tfunction claimBidReward(uint _bidId)\r\n\t\tonlyRegisteredAcc\r\n\t\tonlyExistingBid(_bidId)\r\n\t\tonlyBidAceptee(_bidId)\r\n\t\tonlyBidState(_bidId, BidState.Completed)\r\n\t{\r\n\t\tBid storage bid = bidsById[_bidId];\r\n\t\t\r\n\t\tbid.state = BidState.Claimed;\r\n\r\n\t\trequire(token.transfer(bid.publisherWallet, bid.amount));\r\n\r\n\t\tLogBidRewardClaimed(bid.id, bid.publisherWallet, bid.amount);\r\n\t}\r\n\r\n\t// This can be done if a bid is accepted, but expired\r\n\t// This is essentially the protection from never settling on verification, or from publisher not executing the bid within a reasonable time\r\n\tfunction refundBid(uint _bidId)\r\n\t\tonlyRegisteredAcc\r\n\t\tonlyExistingBid(_bidId)\r\n\t\tonlyBidOwner(_bidId)\r\n\t\tonlyBidState(_bidId, BidState.Accepted)\r\n\t{\r\n\t\tBid storage bid = bidsById[_bidId];\r\n\t\trequire(bid.requiredExecTime > 0); // you can't refund if you haven't set a timeout\r\n\t\trequire(SafeMath.add(bid.acceptedTime, bid.requiredExecTime) < now);\r\n\r\n\t\tbid.state = BidState.Expired;\r\n\t\trequire(token.transfer(bid.advertiserWallet, bid.amount));\r\n\r\n\t\tLogBidExpired(bid.id);\r\n\t}\r\n\r\n\t//\r\n\t// Public constant functions\r\n\t//\r\n\r\n\tfunction getBidsFromArr(uint[] arr, uint _state) \r\n\t\tinternal\r\n\t\treturns (uint[] _all)\r\n\t{\r\n\t\tBidState state = BidState(_state);\r\n\r\n\t\t// separate array is needed because of solidity stupidity (pun intended ))) )\r\n\t\tuint[] memory all = new uint[](arr.length);\r\n\r\n\t\tuint count = 0;\r\n\t\tuint i;\r\n\r\n\t\tfor (i = 0; i < arr.length; i++) {\r\n\t\t\tvar id = arr[i];\r\n\t\t\tvar bid = bidsById[id];\r\n\t\t\tif (bid.state == state) {\r\n\t\t\t\tall[count] = id;\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_all = new uint[](count);\r\n\t\tfor (i = 0; i < count; i++) _all[i] = all[i];\r\n\t}\r\n\r\n\tfunction getAllBidsByAdunit(uint _adunitId) \r\n\t\tconstant \r\n\t\texternal\r\n\t\treturns (uint[])\r\n\t{\r\n\t\treturn bidsByAdunit[_adunitId];\r\n\t}\r\n\r\n\tfunction getBidsByAdunit(uint _adunitId, uint _state)\r\n\t\tconstant\r\n\t\texternal\r\n\t\treturns (uint[])\r\n\t{\r\n\t\treturn getBidsFromArr(bidsByAdunit[_adunitId], _state);\r\n\t}\r\n\r\n\tfunction getAllBidsByAdslot(uint _adslotId) \r\n\t\tconstant \r\n\t\texternal\r\n\t\treturns (uint[])\r\n\t{\r\n\t\treturn bidsByAdslot[_adslotId];\r\n\t}\r\n\r\n\tfunction getBidsByAdslot(uint _adslotId, uint _state)\r\n\t\tconstant\r\n\t\texternal\r\n\t\treturns (uint[])\r\n\t{\r\n\t\treturn getBidsFromArr(bidsByAdslot[_adslotId], _state);\r\n\t}\r\n\r\n\tfunction getBid(uint _bidId) \r\n\t\tonlyExistingBid(_bidId)\r\n\t\tconstant\r\n\t\texternal\r\n\t\treturns (\r\n\t\t\tuint, uint, uint, uint, uint, \r\n\t\t\t// advertiser (ad unit, ipfs, peer)\r\n\t\t\tuint, bytes32, bytes32,\r\n\t\t\t// publisher (ad slot, ipfs, peer)\r\n\t\t\tuint, bytes32, bytes32\r\n\t\t)\r\n\t{\r\n\t\tvar bid = bidsById[_bidId];\r\n\t\treturn (\r\n\t\t\tuint(bid.state), bid.requiredPoints, bid.requiredExecTime, bid.amount, bid.acceptedTime,\r\n\t\t\tbid.adUnit, bid.adUnitIpfs, bid.advertiserPeer,\r\n\t\t\tbid.adSlot, bid.adSlotIpfs, bid.publisherPeer\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getBidReports(uint _bidId)\r\n\t\tonlyExistingBid(_bidId)\r\n\t\tconstant\r\n\t\texternal\r\n\t\treturns (\r\n\t\t\tbytes32, // advertiser report\r\n\t\t\tbytes32 // publisher report\r\n\t\t)\r\n\t{\r\n\t\tvar bid = bidsById[_bidId];\r\n\t\treturn (bid.advertiserReportIpfs, bid.publisherReportIpfs);\r\n\t}\r\n\r\n\t//\r\n\t// Events\r\n\t//\r\n\tevent LogBidOpened(uint bidId, address advertiser, uint adunitId, bytes32 adunitIpfs, uint target, uint rewardAmount, uint timeout, bytes32 advertiserPeer);\r\n\tevent LogBidAccepted(uint bidId, address publisher, uint adslotId, bytes32 adslotIpfs, uint acceptedTime, bytes32 publisherPeer);\r\n\tevent LogBidCanceled(uint bidId);\r\n\tevent LogBidExpired(uint bidId);\r\n\tevent LogBidCompleted(uint bidId, bytes32 advReport, bytes32 pubReport);\r\n\tevent LogBidRewardClaimed(uint _bidId, address _wallet, uint _amount);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint256\"},{\"name\":\"_slotId\",\"type\":\"uint256\"},{\"name\":\"_peer\",\"type\":\"bytes32\"}],\"name\":\"acceptBid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adunitId\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"uint256\"},{\"name\":\"_rewardAmount\",\"type\":\"uint256\"},{\"name\":\"_timeout\",\"type\":\"uint256\"},{\"name\":\"_peer\",\"type\":\"bytes32\"}],\"name\":\"placeBid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint256\"}],\"name\":\"refundBid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_adunitId\",\"type\":\"uint256\"}],\"name\":\"getAllBidsByAdunit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_adslotId\",\"type\":\"uint256\"},{\"name\":\"_state\",\"type\":\"uint256\"}],\"name\":\"getBidsByAdslot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint256\"}],\"name\":\"giveupBid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint256\"}],\"name\":\"getBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_adunitId\",\"type\":\"uint256\"},{\"name\":\"_state\",\"type\":\"uint256\"}],\"name\":\"getBidsByAdunit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenaddr\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint256\"},{\"name\":\"_report\",\"type\":\"bytes32\"}],\"name\":\"verifyBid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint256\"}],\"name\":\"cancelBid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint256\"}],\"name\":\"getBidReports\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint256\"}],\"name\":\"claimBidReward\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_adslotId\",\"type\":\"uint256\"}],\"name\":\"getAllBidsByAdslot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"advertiser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"adunitId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"adunitIpfs\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"advertiserPeer\",\"type\":\"bytes32\"}],\"name\":\"LogBidOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"publisher\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"adslotId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"adslotIpfs\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"acceptedTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"publisherPeer\",\"type\":\"bytes32\"}],\"name\":\"LogBidAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"uint256\"}],\"name\":\"LogBidCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"uint256\"}],\"name\":\"LogBidExpired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"advReport\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"pubReport\",\"type\":\"bytes32\"}],\"name\":\"LogBidCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_bidId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LogBidRewardClaimed\",\"type\":\"event\"}]","ContractName":"ADXExchange","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004470BB87d77b963A013DB939BE332f927f2b992e000000000000000000000000eaf503fd64d0cf9278f29775b78c6f31001ffebc","Library":"","SwarmSource":"bzzr://1c90a25e64c5eacd887a92a41c94990a69c22233ffdac2c7af5462bd6a2a7df5"}]}