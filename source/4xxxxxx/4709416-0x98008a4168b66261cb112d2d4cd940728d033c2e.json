{"status":"1","message":"OK","result":[{"SourceCode":"contract Ownable {\r\n  address public contractOwner;\r\n\r\n  function Ownable() {\r\n    contractOwner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == contractOwner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      contractOwner = newOwner;\r\n    }\r\n  }\r\n}\r\n\r\ncontract ERC721 {\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address tokenOwner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address tokenOwner, address approved, uint256 tokenId);\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract DragonBase is Ownable {\r\n    event Birth(address tokenOwner, uint256 dragonId);\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    struct Dragon {\r\n      // uint256 genes; TODO\r\n      // string name; TODO\r\n      uint8 attack;\r\n      uint8 defence;\r\n      uint8 color;\r\n      uint8 bodyType;\r\n      uint8 eyesType;\r\n      uint8 mouthType;\r\n      uint8 hornsType;\r\n      uint8 wingsType;\r\n      uint16 health;\r\n      uint256 price;\r\n\r\n      uint256 points;\r\n    }\r\n\r\n    Dragon[] dragons;\r\n\r\n    uint256 dragonsOnSaleCount = 0;\r\n\r\n    mapping (uint256 => address) public dragonIndexToOwner;\r\n    mapping (address => uint256) ownershipTokenCount;\r\n    mapping (uint256 => address) public dragonIndexToApproved;\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        ownershipTokenCount[_to]++;\r\n        dragonIndexToOwner[_tokenId] = _to;\r\n\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n            delete dragonIndexToApproved[_tokenId];\r\n        }\r\n\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _createDragon (\r\n        uint8 _attack,\r\n        uint8 _defence,\r\n        uint8 _color,\r\n        uint8 _bodyType,\r\n        uint8 _eyesType,\r\n        uint8 _mouthType,\r\n        uint8 _hornsType,\r\n        uint8 _wingsType,\r\n        uint16 _health,\r\n        uint256 _price\r\n      ) internal returns (uint) {\r\n        Dragon memory _dragon = Dragon({\r\n          attack: _attack,\r\n          defence: _defence,\r\n          color: _color,\r\n          bodyType: _bodyType,\r\n          eyesType: _eyesType,\r\n          mouthType: _mouthType,\r\n          hornsType: _hornsType,\r\n          wingsType: _wingsType,\r\n          health: _health,\r\n          price: _price,\r\n          points: 0\r\n        });\r\n\r\n        uint256 newDragonId = dragons.push(_dragon) - 1;\r\n\r\n        require(newDragonId == uint256(uint32(newDragonId)));\r\n\r\n        dragonsOnSaleCount++;\r\n\r\n        return newDragonId;\r\n    }\r\n}\r\n\r\ncontract ERC721Metadata {\r\n    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\r\n        if (_tokenId == 1) {\r\n            buffer[0] = \"Hello World! :D\";\r\n            count = 15;\r\n        } else if (_tokenId == 2) {\r\n            buffer[0] = \"I would definitely choose a medi\";\r\n            buffer[1] = \"um length string.\";\r\n            count = 49;\r\n        } else if (_tokenId == 3) {\r\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\r\n            buffer[2] = \" tristique vestibulum id, libero\";\r\n            buffer[3] = \" suscipit varius sapien aliquam.\";\r\n            count = 128;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract DragonOwnership is DragonBase, ERC721 {\r\n    string public constant name = \"DragonBit\";\r\n    string public constant symbol = \"DB\";\r\n    ERC721Metadata public erc721Metadata;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('transfer(address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('tokensOfOwner(address)')) ^\r\n        bytes4(keccak256('tokenMetadata(uint256,string)'));\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    function setMetadataAddress(address _contractAddress) public onlyOwner {\r\n        erc721Metadata = ERC721Metadata(_contractAddress);\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return dragonIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return dragonIndexToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        dragonIndexToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_owns(msg.sender, _tokenId));\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function approve(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n    {\r\n        require(_owns(msg.sender, _tokenId));\r\n        _approve(_tokenId, _to);\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return dragons.length;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address tokenOwner)\r\n    {\r\n        tokenOwner = dragonIndexToOwner[_tokenId];\r\n\r\n        require(tokenOwner != address(0));\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalDragons = totalSupply();\r\n            uint256 resultIndex = 0;\r\n            uint256 dragonId;\r\n\r\n            for (dragonId = 0; dragonId < totalDragons; dragonId++) {\r\n                if (_owns(_owner, dragonId)) {\r\n                    result[resultIndex] = dragonId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function tokensOnSale() external view returns(uint256[] availableTokens) {\r\n        if (dragonsOnSaleCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](dragonsOnSaleCount);\r\n            uint256 totalDragons = totalSupply();\r\n            uint256 resultIndex = 0;\r\n            uint256 dragonId;\r\n\r\n            for (dragonId = 0; dragonId < totalDragons; dragonId++) {\r\n                if (_owns(address(0), dragonId)) {\r\n                    result[resultIndex] = dragonId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function tokensForFight() external view returns(uint256[] availableTokens) {\r\n        uint256 dragonsForFightCount = dragons.length - dragonsOnSaleCount - ownershipTokenCount[msg.sender];\r\n\r\n        if (dragonsForFightCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](dragonsForFightCount);\r\n            uint256 totalDragons = totalSupply();\r\n            uint256 resultIndex = 0;\r\n            uint256 dragonId;\r\n\r\n            for (dragonId = 0; dragonId < totalDragons; dragonId++) {\r\n                if (!_owns(address(0), dragonId) && !_owns(address(msg.sender), dragonId)) {\r\n                    result[resultIndex] = dragonId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function _memcpy(uint _dest, uint _src, uint _len) private view {\r\n        // Copy word-length chunks while possible\r\n        for(; _len >= 32; _len -= 32) {\r\n            assembly {\r\n                mstore(_dest, mload(_src))\r\n            }\r\n            _dest += 32;\r\n            _src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint256 mask = 256 ** (32 - _len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(_src), not(mask))\r\n            let destpart := and(mload(_dest), mask)\r\n            mstore(_dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\r\n        var outputString = new string(_stringLength);\r\n        uint256 outputPtr;\r\n        uint256 bytesPtr;\r\n\r\n        assembly {\r\n            outputPtr := add(outputString, 32)\r\n            bytesPtr := _rawBytes\r\n        }\r\n\r\n        _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n        return outputString;\r\n    }\r\n\r\n    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\r\n        require(erc721Metadata != address(0));\r\n        bytes32[4] memory buffer;\r\n        uint256 count;\r\n        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\r\n\r\n        return _toString(buffer, count);\r\n    }\r\n}\r\n\r\ncontract DragonCore is DragonOwnership {\r\n    function getDragon(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n          uint8 attack,\r\n          uint8 defence,\r\n          uint8 color,\r\n          uint8 bodyType,\r\n          uint8 eyesType,\r\n          uint8 mouthType,\r\n          uint8 hornsType,\r\n          uint8 wingsType,\r\n          uint16 health,\r\n          uint256 price,\r\n          uint256 points\r\n    ) {\r\n        Dragon memory d = dragons[_id];\r\n\r\n        attack = d.attack;\r\n        defence = d.defence;\r\n        color = d.color;\r\n        bodyType = d.bodyType;\r\n        eyesType = d.eyesType;\r\n        mouthType = d.mouthType;\r\n        hornsType = d.hornsType;\r\n        wingsType = d.wingsType;\r\n        health = d.health;\r\n        price = d.price;\r\n        points = d.points;\r\n    }\r\n\r\n    function createDragon(\r\n        uint8 _attack,\r\n        uint8 _defence,\r\n        uint8 _color,\r\n        uint8 _bodyType,\r\n        uint8 _eyesType,\r\n        uint8 _mouthType,\r\n        uint8 _hornsType,\r\n        uint8 _wingsType,\r\n        uint16 _health,\r\n        uint16 _price\r\n      ) external onlyOwner returns (uint) {\r\n        return _createDragon(\r\n          _attack,\r\n          _defence,\r\n          _color,\r\n          _bodyType,\r\n          _eyesType,\r\n          _mouthType,\r\n          _hornsType,\r\n          _wingsType,\r\n          _health,\r\n          _price\r\n        );\r\n    }\r\n\r\n    function buyDragon(uint256 _id) payable {\r\n      Dragon memory d = dragons[_id];\r\n      address dragonOwner = dragonIndexToOwner[_id];\r\n\r\n      require(dragonOwner == address(0));\r\n      require(msg.value >= d.price);\r\n\r\n      Birth(msg.sender, _id);\r\n\r\n      dragonsOnSaleCount--;\r\n\r\n      _transfer(0, msg.sender, _id);\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner {\r\n        uint256 balance = this.balance;\r\n        contractOwner.transfer(balance);\r\n    }\r\n}\r\n\r\ncontract Random {\r\n  uint64 _seed = 0;\r\n\r\n  // return a pseudo random number between lower and upper bounds\r\n  // given the number of previous blocks it should hash.\r\n  function random(uint64 upper, uint8 step) public returns (uint64 randomNumber) {\r\n    _seed = uint64(keccak256(keccak256(block.blockhash(block.number - step), _seed), now));\r\n\r\n    return _seed % upper;\r\n  }\r\n}\r\n\r\ncontract DragonFight is DragonCore, Random {\r\n\r\n    event Fight(uint256 _ownerDragonId,\r\n                uint256 _opponentDragonId,\r\n                bool firstAttack,\r\n                bool secondAttack);\r\n\r\n    function fight(uint256 _ownerDragonId, uint256 _opponentDragonId) external returns(\r\n        bool attack1,\r\n        bool attack2,\r\n        bool attack3,\r\n        bool attack4\r\n      ) {\r\n        require(_owns(msg.sender, _ownerDragonId));\r\n        require(!_owns(msg.sender, _opponentDragonId));\r\n        require(!_owns(address(0), _opponentDragonId));\r\n\r\n        Dragon memory ownerDragon = dragons[_ownerDragonId];\r\n        Dragon memory opponentDragon = dragons[_opponentDragonId];\r\n\r\n        attack1 = _randomAttack(ownerDragon.attack, opponentDragon.defence, 1);\r\n        attack2 = _randomAttack(ownerDragon.defence, opponentDragon.attack, 2);\r\n        attack3 = _randomAttack(ownerDragon.attack, opponentDragon.defence, 3);\r\n        attack4 = _randomAttack(ownerDragon.defence, opponentDragon.attack, 4);\r\n\r\n        uint8 points = (attack1 ? 1 : 0) + (attack2 ? 1 : 0) + (attack3 ? 1 : 0) + (attack4 ? 1 : 0);\r\n\r\n        ownerDragon.points += points;\r\n\r\n        Fight(_ownerDragonId, _opponentDragonId, attack1, attack2);\r\n    }\r\n\r\n    function _randomAttack(uint8 _ownerDragonAmount, uint8 _opponentDragonAmount, uint8 _step) private\r\n    returns(bool result) {\r\n        uint64 ownerValue = random(uint64(_ownerDragonAmount), _step);\r\n        uint64 opponentValue = random(uint64(_opponentDragonAmount), _step);\r\n\r\n        return ownerValue > opponentValue;\r\n    }\r\n}\r\n\r\ncontract DragonTest is DragonFight {\r\n\r\n    function createTestData() public onlyOwner {\r\n        // 0.001 eth\r\n        uint256 price = 1000000000000000;\r\n\r\n        uint newDragon1Id = _createDragon(1, 2, 1, 1, 1, 1, 1, 1, 1, price);\r\n        _transfer(0, msg.sender, newDragon1Id);\r\n        dragonsOnSaleCount--;\r\n\r\n        uint newDragon2Id = _createDragon(2, 6, 2, 2, 2, 2, 2, 2, 2, price);\r\n        _transfer(0, msg.sender, newDragon2Id);\r\n        dragonsOnSaleCount--;\r\n\r\n        // Free dragons\r\n        _createDragon(3, 2, 3, 3, 3, 1, 3, 3, 3, price);\r\n        _createDragon(4, 4, 4, 4, 2, 2, 2, 4, 4, price);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensOnSale\",\"outputs\":[{\"name\":\"availableTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dragonIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dragonIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForFight\",\"outputs\":[{\"name\":\"availableTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"buyDragon\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTestData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_attack\",\"type\":\"uint8\"},{\"name\":\"_defence\",\"type\":\"uint8\"},{\"name\":\"_color\",\"type\":\"uint8\"},{\"name\":\"_bodyType\",\"type\":\"uint8\"},{\"name\":\"_eyesType\",\"type\":\"uint8\"},{\"name\":\"_mouthType\",\"type\":\"uint8\"},{\"name\":\"_hornsType\",\"type\":\"uint8\"},{\"name\":\"_wingsType\",\"type\":\"uint8\"},{\"name\":\"_health\",\"type\":\"uint16\"},{\"name\":\"_price\",\"type\":\"uint16\"}],\"name\":\"createDragon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerDragonId\",\"type\":\"uint256\"},{\"name\":\"_opponentDragonId\",\"type\":\"uint256\"}],\"name\":\"fight\",\"outputs\":[{\"name\":\"attack1\",\"type\":\"bool\"},{\"name\":\"attack2\",\"type\":\"bool\"},{\"name\":\"attack3\",\"type\":\"bool\"},{\"name\":\"attack4\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"upper\",\"type\":\"uint64\"},{\"name\":\"step\",\"type\":\"uint8\"}],\"name\":\"random\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDragon\",\"outputs\":[{\"name\":\"attack\",\"type\":\"uint8\"},{\"name\":\"defence\",\"type\":\"uint8\"},{\"name\":\"color\",\"type\":\"uint8\"},{\"name\":\"bodyType\",\"type\":\"uint8\"},{\"name\":\"eyesType\",\"type\":\"uint8\"},{\"name\":\"mouthType\",\"type\":\"uint8\"},{\"name\":\"hornsType\",\"type\":\"uint8\"},{\"name\":\"wingsType\",\"type\":\"uint8\"},{\"name\":\"health\",\"type\":\"uint16\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"points\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ownerDragonId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_opponentDragonId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"firstAttack\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"secondAttack\",\"type\":\"bool\"}],\"name\":\"Fight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dragonId\",\"type\":\"uint256\"}],\"name\":\"Birth\",\"type\":\"event\"}]","ContractName":"DragonTest","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a973514e24cf38ece0d9372b7cc451fa28eb1436705f4f9eb8486033012877a7"}]}