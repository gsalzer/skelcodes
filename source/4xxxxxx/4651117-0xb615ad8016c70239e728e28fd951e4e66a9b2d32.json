{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Written by Jesse Busman (info@jesbus.com) on 2017-11-30.\r\n * This software is provided as-is without warranty of any kind, express or implied.\r\n * This software is provided without any limitation to use, copy modify or distribute.\r\n * The user takes sole and complete responsibility for the consequences of this software's use.\r\n * Github repository: https://github.com/JesseBusman/SoliditySet\r\n */\r\n\r\npragma solidity ^0.4.18;\r\n\r\nlibrary SetLibrary\r\n{\r\n    struct ArrayIndexAndExistsFlag\r\n    {\r\n        uint256 index;\r\n        bool exists;\r\n    }\r\n    struct Set\r\n    {\r\n        mapping(uint256 => ArrayIndexAndExistsFlag) valuesMapping;\r\n        uint256[] values;\r\n    }\r\n    function add(Set storage self, uint256 value) public returns (bool added)\r\n    {\r\n        // If the value is already in the set, we don't need to do anything\r\n        if (self.valuesMapping[value].exists == true) return false;\r\n        \r\n        // Remember that the value is in the set, and remember the value's array index\r\n        self.valuesMapping[value] = ArrayIndexAndExistsFlag({index: self.values.length, exists: true});\r\n        \r\n        // Add the value to the array of unique values\r\n        self.values.push(value);\r\n        \r\n        return true;\r\n    }\r\n    function contains(Set storage self, uint256 value) public view returns (bool contained)\r\n    {\r\n        return self.valuesMapping[value].exists;\r\n    }\r\n    function remove(Set storage self, uint256 value) public returns (bool removed)\r\n    {\r\n        // If the value is not in the set, we don't need to do anything\r\n        if (self.valuesMapping[value].exists == false) return false;\r\n        \r\n        // Remember that the value is not in the set\r\n        self.valuesMapping[value].exists = false;\r\n        \r\n        // Now we need to remove the value from the array. To prevent leaking\r\n        // storage space, we move the last value in the array into the spot that\r\n        // contains the element we're removing.\r\n        if (self.valuesMapping[value].index < self.values.length-1)\r\n        {\r\n            uint256 valueToMove = self.values[self.values.length-1];\r\n            uint256 indexToMoveItTo = self.valuesMapping[value].index;\r\n            self.values[indexToMoveItTo] = valueToMove;\r\n            self.valuesMapping[valueToMove].index = indexToMoveItTo;\r\n        }\r\n        \r\n        // Now we remove the last element from the array, because we just duplicated it.\r\n        // We don't free the storage allocation of the removed last element,\r\n        // because it will most likely be used again by a call to add().\r\n        // De-allocating and re-allocating storage space costs more gas than\r\n        // just keeping it allocated and unused.\r\n        \r\n        // Uncomment this line to save gas if your use case does not call add() after remove():\r\n        // delete self.values[self.values.length-1];\r\n        self.values.length--;\r\n        \r\n        // We do free the storage allocation in the mapping, because it is\r\n        // less likely that the exact same value will added again.\r\n        delete self.valuesMapping[value];\r\n        \r\n        return true;\r\n    }\r\n    function size(Set storage self) public view returns (uint256 amountOfValues)\r\n    {\r\n        return self.values.length;\r\n    }\r\n    \r\n    // Also accept address and bytes32 types, so the user doesn't have to cast.\r\n    function add(Set storage self, address value) public returns (bool added) { return add(self, uint256(value)); }\r\n    function add(Set storage self, bytes32 value) public returns (bool added) { return add(self, uint256(value)); }\r\n    function contains(Set storage self, address value) public view returns (bool contained) { return contains(self, uint256(value)); }\r\n    function contains(Set storage self, bytes32 value) public view returns (bool contained) { return contains(self, uint256(value)); }\r\n    function remove(Set storage self, address value) public returns (bool removed) { return remove(self, uint256(value)); }\r\n    function remove(Set storage self, bytes32 value) public returns (bool removed) { return remove(self, uint256(value)); }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"contains\",\"outputs\":[{\"name\":\"contained\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[{\"name\":\"added\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[{\"name\":\"added\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"add\",\"outputs\":[{\"name\":\"added\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[{\"name\":\"removed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"}],\"name\":\"size\",\"outputs\":[{\"name\":\"amountOfValues\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[{\"name\":\"removed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"remove\",\"outputs\":[{\"name\":\"removed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"contains\",\"outputs\":[{\"name\":\"contained\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"SetLibrary.Set storage\"},{\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"contains\",\"outputs\":[{\"name\":\"contained\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SetLibrary","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8df781b5b5396b95923667b5e9f05718802ce6d5bc5e8f629e55b5db7ad3be95"}]}