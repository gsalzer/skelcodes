{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Safe Math Smart Contract.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.4.16;\r\n\r\n/**\r\n * Provides methods to safely add, subtract and multiply uint256 numbers.\r\n */\r\ncontract SafeMath {\r\n  uint256 constant private MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Add two uint256 values, throw in case of overflow.\r\n   *\r\n   * @param x first value to add\r\n   * @param y second value to add\r\n   * @return x + y\r\n   */\r\n  function safeAdd (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    assert (x <= MAX_UINT256 - y);\r\n    return x + y;\r\n  }\r\n\r\n  /**\r\n   * Subtract one uint256 value from another, throw in case of underflow.\r\n   *\r\n   * @param x value to subtract from\r\n   * @param y value to subtract\r\n   * @return x - y\r\n   */\r\n  function safeSub (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    assert (x >= y);\r\n    return x - y;\r\n  }\r\n\r\n  /**\r\n   * Multiply two uint256 values, throw in case of overflow.\r\n   *\r\n   * @param x first value to multiply\r\n   * @param y second value to multiply\r\n   * @return x * y\r\n   */\r\n  function safeMul (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    if (y == 0) return 0; // Prevent division by zero at the next line\r\n    assert (x <= MAX_UINT256 / y);\r\n    return x * y;\r\n  }\r\n} \r\n\r\n/*\r\n * ERC-20 Standard Token Smart Contract Interface.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.4.16;\r\n\r\n/**\r\n * ERC-20 standard token interface, as defined\r\n * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>.\r\n */\r\ncontract Token {\r\n  /**\r\n   * Get total number of tokens in circulation.\r\n   *\r\n   * @return total number of tokens in circulation\r\n   */\r\n  function totalSupply () constant returns (uint256 supply);\r\n\r\n  /**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n   *        owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   */\r\n  function balanceOf (address _owner) constant returns (uint256 balance);\r\n\r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transfer (address _to, uint256 _value) returns (bool success);\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transferFrom (address _from, address _to, uint256 _value)\r\n  returns (bool success);\r\n\r\n  /**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   *\r\n   * @param _spender address to allow the owner of to transfer tokens from\r\n   *        message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   */\r\n  function approve (address _spender, uint256 _value) returns (bool success);\r\n\r\n  /**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   */\r\n  function allowance (address _owner, address _spender) constant\r\n  returns (uint256 remaining);\r\n\r\n  /**\r\n   * Logged when tokens were transferred from one owner to another.\r\n   *\r\n   * @param _from address of the owner, tokens were transferred from\r\n   * @param _to address of the owner, tokens were transferred to\r\n   * @param _value number of tokens transferred\r\n   */\r\n  event Transfer (address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * Logged when owner approved his tokens to be transferred by some spender.\r\n   *\r\n   * @param _owner owner who approved his tokens to be transferred\r\n   * @param _spender spender who were allowed to transfer the tokens belonging\r\n   *        to the owner\r\n   * @param _value number of tokens belonging to the owner, approved to be\r\n   *        transferred by the spender\r\n   */\r\n  event Approval (\r\n    address indexed _owner, address indexed _spender, uint256 _value);\r\n} \r\n\r\n/*\r\n * Abstract base contract for Token Smart Contracts that may create snapshots of\r\n * token holder balances.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.4.16;\r\n\r\n\r\n/**\r\n * Abstract base contract Token Smart Contracts that support snapshots of token\r\n * holder balances.\r\n */\r\ncontract AbstractSnapshottableToken is SafeMath, Token {\r\n  /**\r\n   * Maximum number of tokens in circulation (2^256 - 1).\r\n   */\r\n  uint256 constant MAX_TOKENS = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Maximum value of uint256 type, i.e. 2^256-1.\r\n   */\r\n  uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Maximum value of address represented as uint256, i.e. 2^160-1.\r\n   */\r\n  uint256 constant MAX_ADDRESS = 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * 2^160.\r\n   */\r\n  uint256 constant TWO_160 = 0x00010000000000000000000000000000000000000000;\r\n\r\n  /**\r\n   * Create new Abstract Snapshottable Token smart contract.\r\n   */\r\n  function AbstractSnapshottableToken () {\r\n    snapshots.length = 1; // Reserve zero ID.\r\n  }\r\n\r\n  /**\r\n   * Get total number of tokens in circulation.\r\n   *\r\n   * @return total number of tokens in circulation\r\n   */\r\n  function totalSupply () constant returns (uint256 supply) {\r\n    return tokensCount;\r\n  }\r\n\r\n  /**\r\n   * Get total number of tokens in circulation as is was at the moment when\r\n   * snapshot with given index was created.\r\n   *\r\n   * @param _index index of the snapshot to get total number of tokens in\r\n   *        circulation at the moment of\r\n   * @return total number of tokens in circulation at the moment snapshot with\r\n   *         given index was created\r\n   */\r\n  function totalSupplyAt (uint256 _index) constant returns (uint256 supply) {\r\n    require (_index > 0);\r\n    require (_index < snapshots.length);\r\n\r\n    return snapshots [_index].tokensCount;\r\n  }\r\n\r\n  /**\r\n   * Get number of tokens currently belonging to the owner of given address.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n   *        owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   */\r\n  function balanceOf (address _owner) constant returns (uint256 balance) {\r\n    return accounts [_owner].balance;\r\n  }\r\n\r\n  /**\r\n   * Get number of tokens owner of the given address had at the moment when\r\n   * snapshot with given index was created.\r\n   *\r\n   * @param _owner address to get number of tokens for the owner of\r\n   * @param _index index of the snapshot to get number of tokens at the time of\r\n   * @return number of tokens owner of the given address had at the moment the\r\n   *         snapshot with given index was created\r\n   */\r\n  function balanceOfAt (address _owner, uint256 _index)\r\n    constant returns (uint256 balance) {\r\n    require (_index > 0);\r\n    require (_index < snapshots.length);\r\n\r\n    if (_index > accounts [_owner].lastSnapshotIndex)\r\n      return accounts [_owner].balance;\r\n    else {\r\n      uint8 level = 0;\r\n      while (_index > 0) {\r\n        uint256 v = historicalBalances [_owner][level][_index];\r\n        if (v != 0) return v;\r\n\r\n        _index >>= 1;\r\n        level += 1; // Overflow is possible here, but is harmless\r\n      }\r\n\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get first address that probably had non-zero token balance at the moment\r\n   * snapshot with given index was created.\r\n   *\r\n   * @param _index index of the snapshot to get first address the probably had\r\n   *        non-zero token balance at the moment of\r\n   * @return flag that tells whether there is at least one address that probably\r\n   *         had non-zero token balance at the moment of snapshot with given\r\n   *         index (hasResult); and the fist address that probably had non-zero\r\n   *         token balance at the moment snapshot with given index was created\r\n   *         or zero if there are no such addresses (result)\r\n   */\r\n  function firstAddressAt (uint256 _index)\r\n    constant returns (bool hasResult, address result) {\r\n    require (_index > 0);\r\n    require (_index < snapshots.length);\r\n    uint256 rawFirstAddress = snapshots [_index].firstAddress;\r\n    hasResult = rawFirstAddress != MAX_UINT256;\r\n    result = hasResult ?\r\n      address (rawFirstAddress & MAX_ADDRESS) :\r\n        0;\r\n  }\r\n\r\n  /**\r\n   * Get next address that probably had non-zero token balance at the moment\r\n   * certain snapshot was created.\r\n   *\r\n   * @param _address previous address that probably had non-zero token balance\r\n   *        at the moment of certain snapshot\r\n   * @return flag that tells whether there is next address that probably had\r\n   *         non-zero token balance at the moment of snapshot with given index\r\n   *         (hasResult); and the next address that probably had non-zero\r\n   *         token balance at the moment of snapshot with given index was\r\n   *         created or zero if there are no such addresses (result)\r\n   */\r\n  function nextAddress (address _address)\r\n    constant returns (bool hasResult, address result) {\r\n    uint256 rawNextAddress = nextAddresses [_address];\r\n    require (rawNextAddress != 0);\r\n    hasResult = rawNextAddress != MAX_UINT256;\r\n    result = hasResult ?\r\n      address (rawNextAddress & MAX_ADDRESS) :\r\n        0;\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transfer (address _to, uint256 _value) returns (bool success) {\r\n    return doTransfer (msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transferFrom (address _from, address _to, uint256 _value)\r\n  returns (bool success) {\r\n    if (_value > approved [_from][msg.sender]) return false;\r\n    else if (doTransfer (_from, _to, _value)) {\r\n      approved [_from][msg.sender] =\r\n        safeSub (approved[_from][msg.sender], _value);\r\n      return true;\r\n    } else return false;\r\n  }\r\n\r\n  /**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   *\r\n   * @param _spender address to allow the owner of to transfer tokens from\r\n   *        message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   */\r\n  function approve (address _spender, uint256 _value) returns (bool success) {\r\n    approved [msg.sender][_spender] = _value;\r\n    Approval (msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   */\r\n  function allowance (address _owner, address _spender) constant\r\n  returns (uint256 remaining) {\r\n    return approved [_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * Create snapshot of token holder balances.\r\n   *\r\n   * @return index of new created snapshot\r\n   */\r\n  function snapshot () returns (uint256 index) {\r\n    index = snapshots.length++;\r\n    snapshots [index].tokensCount = tokensCount;\r\n    snapshots [index].firstAddress = firstAddress;\r\n    Snapshot (index);\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from the owner of given from address to the\r\n   * owner of given to address.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function doTransfer (address _from, address _to, uint256 _value)\r\n    internal returns (bool success) {\r\n    if (_value > accounts [_from].balance) return false;\r\n    else if (_value > 0 && _from != _to) {\r\n      saveAddress (_to);\r\n      updateHistoricalBalances (_from);\r\n      updateHistoricalBalances (_to);\r\n      accounts [_from].balance = safeSub (accounts [_from].balance, _value);\r\n      accounts [_to].balance = safeAdd (accounts [_to].balance, _value);\r\n      Transfer (_from, _to, _value);\r\n      return true;\r\n    } else return true;\r\n  }\r\n\r\n  /**\r\n   * Create given number of tokens and give them to message sender.\r\n   *\r\n   * @param _value number of tokens to create\r\n   * @return true on success, false on error\r\n   */\r\n  function doCreateTokens (uint256 _value) internal returns (bool success) {\r\n    if (_value > safeSub (MAX_TOKENS, tokensCount)) return false;\r\n    else if (_value > 0) {\r\n      saveAddress (msg.sender);\r\n      updateHistoricalBalances (msg.sender);\r\n      accounts [msg.sender].balance =\r\n        safeAdd (accounts [msg.sender].balance, _value);\r\n      tokensCount = safeAdd (tokensCount, _value);\r\n      return true;\r\n    } else return true;\r\n  }\r\n\r\n  /**\r\n   * Update historical balances for given token owner.\r\n   *\r\n   * @param _owner token owner to update historical balances for\r\n   */\r\n  function updateHistoricalBalances (address _owner) internal {\r\n    uint256 balance = accounts [_owner].balance;\r\n    uint256 nextSnapshotIndex = snapshots.length;\r\n    uint256 lastNextSnapshotIndex =\r\n      safeAdd (accounts [_owner].lastSnapshotIndex, 1);\r\n    if (nextSnapshotIndex > lastNextSnapshotIndex) {\r\n      if (balance > 0) {\r\n        setHistoricalBalance (\r\n          _owner, lastNextSnapshotIndex, nextSnapshotIndex, balance);\r\n      }\r\n      accounts [_owner].lastSnapshotIndex =\r\n        safeSub (nextSnapshotIndex, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set historical balance for the owner of given address as it was at the\r\n   * moments of snapshots with indexes in given range.\r\n   *\r\n   * @param _owner address to set the historical balance for the owner of\r\n   * @param _from beginning of the snapshot index range (inclusive)\r\n   * @param _to end of the snapshot index range (exclusive)\r\n   * @param _balance value to set balance to\r\n   */\r\n  function setHistoricalBalance (\r\n    address _owner, uint256 _from, uint256 _to, uint256 _balance)\r\n    internal {\r\n    assert (_from > 0);\r\n    assert (_to >= _from);\r\n    assert (_balance > 0);\r\n\r\n    uint8 level = 0;\r\n    while (_from < _to) {\r\n      if (_from & 1 == 1) {\r\n        // Overflow is not possible here because _from < _to\r\n        historicalBalances [_owner][level][_from++] = _balance;\r\n      }\r\n\r\n      if (_to & 1 == 1) {\r\n        // Underflow is not possible here, because _to & 1 == 1\r\n        historicalBalances [_owner][level][--_to] = _balance;\r\n      }\r\n\r\n      _from >>= 1;\r\n      _to >>= 1;\r\n      level += 1; // Even for snapshot index range 1..2^256-1 overflow will\r\n                  // not happen here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add address to the list of addresses that ever had non-zero token balance.\r\n   *\r\n   * @param _address address to be added to the list of addresses that ever had\r\n   *        non-zero token balance\r\n   */\r\n  function saveAddress (address _address) internal {\r\n    if (nextAddresses [_address] == 0) {\r\n      nextAddresses [_address] = firstAddress;\r\n      firstAddress = TWO_160 | uint256(_address);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Total number of tokens in circulation.\r\n   */\r\n  uint256 tokensCount;\r\n\r\n  /**\r\n   * All snapshots ever created.\r\n   */\r\n  SnapshotInfo [] snapshots;\r\n\r\n  /**\r\n   * Maps addresses of token owners to states of their accounts.\r\n   */\r\n  mapping (address => Account) accounts;\r\n\r\n  /**\r\n   * First address that ever had non-zero token balance plus 2^160, or 2^256-1\r\n   * if there are no such addresses.\r\n   */\r\n  uint256 firstAddress = MAX_UINT256;\r\n\r\n  /**\r\n   * Mapping from address that ever had non-zero token balance to the next\r\n   * address that ever had non-zero token balance plus 2^160 or 2^256-1 if there\r\n   * are no more such addresses.\r\n   */\r\n  mapping (address => uint256) nextAddresses;\r\n\r\n  /**\r\n   * Historical balances of token owners.  If for some address, level and index,\r\n   * where level >= 0 and index > 0, historicalBalances[address][level][index]\r\n   * is non-zero, then owner of given address had this many tokens at the\r\n   * time moments of snapshots with indexes from (index * 2^level) to\r\n   * ((index + 1) * 2^level - 1) inclusive.\r\n   * For each snapshot, there should be at most one level with non-zero\r\n   * value at corresponding index.\r\n   */\r\n  mapping (address => mapping (uint8 => mapping (uint256 => uint256)))\r\n    historicalBalances;\r\n\r\n  /**\r\n   * Maps addresses of token owners to mappings from addresses of spenders to\r\n   * how many tokens belonging to the owner, the spender is currently allowed to\r\n   * transfer.\r\n   */\r\n  mapping (address => mapping (address => uint256)) approved;\r\n\r\n  /**\r\n   * Encapsulates information about snapshot.\r\n   */\r\n  struct SnapshotInfo {\r\n    /**\r\n     * Total number of tokens in circulation at the moment of snapshot.\r\n     */\r\n    uint256 tokensCount;\r\n\r\n    /**\r\n     * Value of firstAddress field at the moment of snapshot.\r\n     */\r\n    uint256 firstAddress;\r\n  }\r\n\r\n  /**\r\n   * Encapsulates information about token owner's balance.\r\n   */\r\n  struct Account {\r\n    /**\r\n     * Number of tokens currently belonging to the token owner.\r\n     */\r\n    uint256 balance;\r\n\r\n    /**\r\n     * Index of the last snapshot before the moment historical balances were\r\n     * last updated for this token owner.\r\n     */\r\n    uint256 lastSnapshotIndex;\r\n  }\r\n\r\n  /**\r\n   * Logged when new snapshot was created.\r\n   *\r\n   * @param _index index of the new snapshot\r\n   */\r\n  event Snapshot (uint256 indexed _index);\r\n}\r\n\r\n\r\n/*\r\n * Standard Snapshottable Token Smart Contract.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\n\r\n/**\r\n * Standard Snapshottable Token Smart Contract.\r\n */\r\ncontract StandardSnapshottableToken is AbstractSnapshottableToken {\r\n  /**\r\n   * Create new Standard Snapshottable Token Smart Contract and make\r\n   * message sender the owner of the smart contract.\r\n   */\r\n  function StandardSnapshottableToken ()\r\n    AbstractSnapshottableToken () {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transfer (address _to, uint256 _value) returns (bool success) {\r\n    if (frozen) return false;\r\n    else return AbstractSnapshottableToken.transfer (_to, _value);\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transferFrom (address _from, address _to, uint256 _value)\r\n  returns (bool success) {\r\n    if (frozen) return false;\r\n    else\r\n      return AbstractSnapshottableToken.transferFrom (_from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * Create given number of tokens and give them to message sender.  May only be\r\n   * called by the owner of the smart contract.\r\n   *\r\n   * @param _value number of tokens to create\r\n   * @return true on success, false on error\r\n   */\r\n  function createTokens (uint256 _value) returns (bool success) {\r\n    require (msg.sender == owner);\r\n\r\n    return doCreateTokens (_value);\r\n  }\r\n\r\n  /**\r\n   * Freeze token transfers.  May only be called by the owner of the smart\r\n   * contract.\r\n   */\r\n  function freezeTransfers () {\r\n    require (msg.sender == owner);\r\n\r\n    if (!frozen)\r\n    {\r\n      frozen = true;\r\n      Freeze ();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unfreeze token transfers.  May only be called by the owner of the smart\r\n   * contract.\r\n   */\r\n  function unfreezeTransfers () {\r\n    require (msg.sender == owner);\r\n\r\n    if (frozen) {\r\n      frozen = false;\r\n      Unfreeze ();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set new owner address.  May only be called by the owner of the smart\r\n   * contract.\r\n   *\r\n   * @param _newOwner new owner address\r\n   */\r\n  function setOwner (address _newOwner) {\r\n    require (msg.sender == owner);\r\n\r\n    owner = _newOwner;\r\n  }\r\n\r\n  /**\r\n   * Owner of this smart contract.\r\n   */\r\n  address owner;\r\n\r\n  /**\r\n   * Whether token transfers are currently frozen.\r\n   */\r\n  bool frozen;\r\n\r\n  /**\r\n   * Logged when token transfers were frozen.\r\n   */\r\n  event Freeze ();\r\n\r\n  /**\r\n   * Logged when token transfers were unfrozen.\r\n   */\r\n  event Unfreeze ();\r\n}\r\n\r\n\r\n/*\r\n * Science Blockchain Token Smart Contract.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\n\r\n/**\r\n * Science Blockchain Token Smart Contract.\r\n */\r\ncontract ScienceBlockchainToken is StandardSnapshottableToken {\r\n  /**\r\n   * Create new Science Blockchain Token smart contract and make message sender\r\n   * to be the owner of smart contract and to be a snapshot creator.\r\n   */\r\n  function ScienceBlockchainToken ()\r\n    StandardSnapshottableToken () {\r\n    snapshotCreator = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * Create snapshot of token holder balances.\r\n   *\r\n   * @return index of new created snapshot\r\n   */\r\n  function snapshot () returns (uint256 index) {\r\n    require (msg.sender == snapshotCreator);\r\n    return AbstractSnapshottableToken.snapshot ();\r\n  }\r\n\r\n  /**\r\n   * Get name of this token.\r\n   *\r\n   * @return name of this token\r\n   */\r\n  function name () constant returns (string result) {\r\n    return \"SCIENCE BLOCKCHAIN\";\r\n  }\r\n\r\n  /**\r\n   * Get symbol of this token.\r\n   *\r\n   * @return symbol of this token\r\n   */\r\n  function symbol () constant returns (string result) {\r\n    return \"SCI\";\r\n  }\r\n\r\n  /**\r\n   * Get number of decimals for this token.\r\n   *\r\n   * @return number of decimals for this token\r\n   */\r\n  function decimals () constant returns (uint8 result) {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Burn given number of tokens belonging to message sender.\r\n   *\r\n   * @param _value number of tokens to burn\r\n   * @return true if tokens were burned successfully, false otherwise\r\n   */\r\n  function burnTokens (uint256 _value) returns (bool success) {\r\n    uint256 balance = accounts [msg.sender].balance;\r\n    if (_value > balance) return false;\r\n    if (_value > 0) {\r\n      updateHistoricalBalances (msg.sender);\r\n      accounts [msg.sender].balance = safeSub (balance, _value);\r\n      tokensCount = safeSub (tokensCount, _value);\r\n      return true;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Set new snapshot creator address.\r\n   *\r\n   * @param _snapshotCreator new snapshot creator address\r\n   */\r\n  function setSnapshotCreator (address _snapshotCreator) {\r\n    require (msg.sender == owner);\r\n    snapshotCreator = _snapshotCreator;\r\n  }\r\n\r\n  /**\r\n   * Address of snapshot creator, i.e. the one allowed to create snapshots.\r\n   */\r\n  address snapshotCreator;\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"freezeTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"result\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreezeTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"firstAddressAt\",\"outputs\":[{\"name\":\"hasResult\",\"type\":\"bool\"},{\"name\":\"result\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_snapshotCreator\",\"type\":\"address\"}],\"name\":\"setSnapshotCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"createTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"result\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"snapshot\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"nextAddress\",\"outputs\":[{\"name\":\"hasResult\",\"type\":\"bool\"},{\"name\":\"result\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"Snapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ScienceBlockchainToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://71702e78d22ba963c26375689926cdce2ee288ee9dd4c5f0b6a5e82c2f4dc5c2"}]}