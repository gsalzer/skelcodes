{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\n\r\ncontract owned {\r\n\taddress public owner;\r\n\r\n\tfunction owned() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tfunction changeOwner(address newOwner) onlyOwner {\r\n\t\towner = newOwner;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n\r\ncontract tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);}\r\n\r\n\r\ncontract Utils {\r\n\t/**\r\n\t\tconstructor\r\n\t*/\r\n\tfunction Utils() {\r\n\t}\r\n\r\n\t// validates an address - currently only checks that it isn't null\r\n\tmodifier validAddress(address _address) {\r\n\t\trequire(_address != 0x0);\r\n\t\t_;\r\n\t}\r\n\r\n\t// verifies that the address is different than this contract address\r\n\tmodifier notThis(address _address) {\r\n\t\trequire(_address != address(this));\r\n\t\t_;\r\n\t}\r\n\r\n\t// Overflow protected math functions\r\n\r\n\t/**\r\n\t\t@dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n\t\t@param _x   value 1\r\n\t\t@param _y   value 2\r\n\r\n\t\t@return sum\r\n\t*/\r\n\tfunction safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n\t\tuint256 z = _x + _y;\r\n\t\tassert(z >= _x);\r\n\t\treturn z;\r\n\t}\r\n\r\n\t/**\r\n\t\t@dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n\t\t@param _x   minuend\r\n\t\t@param _y   subtrahend\r\n\r\n\t\t@return difference\r\n\t*/\r\n\tfunction safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n\t\tassert(_x >= _y);\r\n\t\treturn _x - _y;\r\n\t}\r\n}\r\n\r\n\r\ncontract CSToken is owned, Utils {\r\n\tstruct Dividend {uint256 time; uint256 tenThousandth; uint256 countComplete;}\r\n\r\n\t/* Public variables of the token */\r\n\tstring public standard = 'Token 0.1';\r\n\r\n\tstring public name = 'KickCoin';\r\n\r\n\tstring public symbol = 'KICK';\r\n\r\n\tuint8 public decimals = 8;\r\n\r\n\tuint256 _totalSupply = 0;\r\n\r\n\t/* Is allowed to burn tokens */\r\n\tbool public allowManuallyBurnTokens = true;\r\n\r\n\t/* This creates an array with all balances */\r\n\tmapping (address => uint256) balances;\r\n\r\n\tmapping (address => mapping (uint256 => uint256)) public agingBalanceOf;\r\n\r\n\tuint[] agingTimes;\r\n\r\n\tDividend[] dividends;\r\n\r\n\tmapping (address => mapping (address => uint256)) allowed;\r\n\t/* This generates a public event on the blockchain that will notify clients */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\tevent AgingTransfer(address indexed from, address indexed to, uint256 value, uint256 agingTime);\r\n\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\t// triggered when the total supply is increased\r\n\tevent Issuance(uint256 _amount);\r\n\t// triggered when the total supply is decreased\r\n\tevent Destruction(uint256 _amount);\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\r\n\taddress[] public addressByIndex;\r\n\r\n\tmapping (address => bool) addressAddedToIndex;\r\n\r\n\tmapping (address => uint) agingTimesForPools;\r\n\r\n\tuint16 currentDividendIndex = 1;\r\n\r\n\tmapping (address => uint) calculatedDividendsIndex;\r\n\r\n\tbool public transfersEnabled = true;\r\n\r\n\tevent NewSmartToken(address _token);\r\n\r\n\t/* Initializes contract with initial supply tokens to the creator of the contract */\r\n\tfunction CSToken() {\r\n\t\towner = msg.sender;\r\n\t\t// So that the index starts with 1\r\n\t\tdividends.push(Dividend(0, 0, 0));\r\n\t\t// 31.10.2017 09:00:00\r\n\t\tdividends.push(Dividend(1509440400, 30, 0));\r\n\t\t// 30.11.2017 09:00:00\r\n\t\tdividends.push(Dividend(1512032400, 20, 0));\r\n\t\t// 31.12.2017 09:00:00\r\n\t\tdividends.push(Dividend(1514710800, 10, 0));\r\n\t\t// 31.01.2018 09:00:00\r\n\t\tdividends.push(Dividend(1517389200, 5, 0));\r\n\t\t// 28.02.2018 09:00:00\r\n\t\tdividends.push(Dividend(1519808400, 10, 0));\r\n\t\t// 31.03.2018 09:00:00\r\n\t\tdividends.push(Dividend(1522486800, 20, 0));\r\n\t\t// 30.04.2018 09:00:00\r\n\t\tdividends.push(Dividend(1525078800, 30, 0));\r\n\t\t// 31.05.2018 09:00:00\r\n\t\tdividends.push(Dividend(1527757200, 50, 0));\r\n\t\t// 30.06.2018 09:00:00\r\n\t\tdividends.push(Dividend(1530349200, 30, 0));\r\n\t\t// 31.07.2018 09:00:00\r\n\t\tdividends.push(Dividend(1533027600, 20, 0));\r\n\t\t// 31.08.2018 09:00:00\r\n\t\tdividends.push(Dividend(1535706000, 10, 0));\r\n\t\t// 30.09.2018 09:00:00\r\n\t\tdividends.push(Dividend(1538298000, 5, 0));\r\n\t\t// 31.10.2018 09:00:00\r\n\t\tdividends.push(Dividend(1540976400, 10, 0));\r\n\t\t// 30.11.2018 09:00:00\r\n\t\tdividends.push(Dividend(1543568400, 20, 0));\r\n\t\t// 31.12.2018 09:00:00\r\n\t\tdividends.push(Dividend(1546246800, 30, 0));\r\n\t\t// 31.01.2019 09:00:00\r\n\t\tdividends.push(Dividend(1548925200, 60, 0));\r\n\t\t// 28.02.2019 09:00:00\r\n\t\tdividends.push(Dividend(1551344400, 30, 0));\r\n\t\t// 31.03.2019 09:00:00\r\n\t\tdividends.push(Dividend(1554022800, 20, 0));\r\n\t\t// 30.04.2019 09:00:00\r\n\t\tdividends.push(Dividend(1556614800, 10, 0));\r\n\t\t// 31.05.2019 09:00:00\r\n\t\tdividends.push(Dividend(1559307600, 20, 0));\r\n\t\t// 30.06.2019 09:00:00\r\n\t\tdividends.push(Dividend(1561885200, 30, 0));\r\n\t\t// 31.07.2019 09:00:00\r\n\t\tdividends.push(Dividend(1564563600, 20, 0));\r\n\t\t// 31.08.2019 09:00:00\r\n\t\tdividends.push(Dividend(1567242000, 10, 0));\r\n\t\t// 30.09.2019 09:00:00\r\n\t\tdividends.push(Dividend(1569834000, 5, 0));\r\n\r\n\t\tNewSmartToken(address(this));\r\n\t}\r\n\r\n\tmodifier transfersAllowed {\r\n\t\tassert(transfersEnabled);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction totalSupply() constant returns (uint256 totalSupply) {\r\n\t\ttotalSupply = _totalSupply;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\tbool allAgingTimesHasBeenAdded = false;\r\n\tfunction addAgingTime(uint256 time) onlyOwner {\r\n\t\trequire(!allAgingTimesHasBeenAdded);\r\n\t\tagingTimes.push(time);\r\n\t}\r\n\r\n\tfunction allAgingTimesAdded() onlyOwner {\r\n\t\tallAgingTimesHasBeenAdded = true;\r\n\t}\r\n\r\n\tfunction calculateDividends(uint256 limit) {\r\n\t\trequire(now >= dividends[currentDividendIndex].time);\r\n\t\trequire(limit > 0);\r\n\r\n\t\tlimit = safeAdd(dividends[currentDividendIndex].countComplete, limit);\r\n\r\n\t\tif (limit > addressByIndex.length) {\r\n\t\t\tlimit = addressByIndex.length;\r\n\t\t}\r\n\r\n\t\tfor (uint256 i = dividends[currentDividendIndex].countComplete; i < limit; i++) {\r\n\t\t\t_addDividendsForAddress(addressByIndex[i]);\r\n\t\t}\r\n\t\tif (limit == addressByIndex.length) {\r\n\t\t\tcurrentDividendIndex++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdividends[currentDividendIndex].countComplete = limit;\r\n\t\t}\r\n\t}\r\n\r\n\t/* User can himself receive dividends without waiting for a global accruals */\r\n\tfunction receiveDividends() public {\r\n\t\trequire(now >= dividends[currentDividendIndex].time);\r\n\t\tassert(_addDividendsForAddress(msg.sender));\r\n\t}\r\n\r\n\tfunction _addDividendsForAddress(address _address) internal returns (bool success) {\r\n\t\t// skip calculating dividends, if already calculated for this address\r\n\t\tif (calculatedDividendsIndex[_address] >= currentDividendIndex) return false;\r\n\r\n\t\tuint256 add = balances[_address] * dividends[currentDividendIndex].tenThousandth / 1000;\r\n\t\tbalances[_address] = safeAdd(balances[_address], add);\r\n\t\tTransfer(this, _address, add);\r\n\t\tIssuance(add);\r\n\t\t_totalSupply = safeAdd(_totalSupply, add);\r\n\r\n\t\tif (agingBalanceOf[_address][0] > 0) {\r\n\t\t\tagingBalanceOf[_address][0] = safeAdd(agingBalanceOf[_address][0], agingBalanceOf[_address][0] * dividends[currentDividendIndex].tenThousandth / 1000);\r\n\t\t\tfor (uint256 k = 0; k < agingTimes.length; k++) {\r\n\t\t\t\tagingBalanceOf[_address][agingTimes[k]] = safeAdd(agingBalanceOf[_address][agingTimes[k]], agingBalanceOf[_address][agingTimes[k]] * dividends[currentDividendIndex].tenThousandth / 1000);\r\n\t\t\t}\r\n\t\t}\r\n\t\tcalculatedDividendsIndex[_address] = currentDividendIndex;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* Send coins */\r\n\tfunction transfer(address _to, uint256 _value) transfersAllowed returns (bool success) {\r\n\t\t_checkMyAging(msg.sender);\r\n\t\tif (currentDividendIndex < dividends.length && now >= dividends[currentDividendIndex].time) {\r\n\t\t\t_addDividendsForAddress(msg.sender);\r\n\t\t\t_addDividendsForAddress(_to);\r\n\t\t}\r\n\r\n\t\trequire(accountBalance(msg.sender) >= _value);\r\n\r\n\t\t// Subtract from the sender\r\n\t\tbalances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n\r\n\t\tif (agingTimesForPools[msg.sender] > 0 && agingTimesForPools[msg.sender] > now) {\r\n\t\t\t_addToAging(msg.sender, _to, agingTimesForPools[msg.sender], _value);\r\n\t\t}\r\n\r\n\t\tbalances[_to] = safeAdd(balances[_to], _value);\r\n\r\n\t\t_addIndex(_to);\r\n\t\tTransfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction mintToken(address target, uint256 mintedAmount, uint256 agingTime) onlyOwner {\r\n\t\tif (agingTime > now) {\r\n\t\t\t_addToAging(owner, target, agingTime, mintedAmount);\r\n\t\t}\r\n\r\n\t\tbalances[target] = safeAdd(balances[target], mintedAmount);\r\n\r\n\t\t_totalSupply = safeAdd(_totalSupply, mintedAmount);\r\n\t\tIssuance(mintedAmount);\r\n\t\t_addIndex(target);\r\n\t\tTransfer(this, target, mintedAmount);\r\n\t}\r\n\r\n\tfunction _addIndex(address _address) internal {\r\n\t\tif (!addressAddedToIndex[_address]) {\r\n\t\t\taddressAddedToIndex[_address] = true;\r\n\t\t\taddressByIndex.push(_address);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _addToAging(address from, address target, uint256 agingTime, uint256 amount) internal {\r\n\t\tagingBalanceOf[target][0] = safeAdd(agingBalanceOf[target][0], amount);\r\n\t\tagingBalanceOf[target][agingTime] = safeAdd(agingBalanceOf[target][agingTime], amount);\r\n\t\tAgingTransfer(from, target, amount, agingTime);\r\n\t}\r\n\r\n\t/* Allow another contract to spend some tokens in your behalf */\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* Approve and then communicate the approved contract in a single tx */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n\t\ttokenRecipient spender = tokenRecipient(_spender);\r\n\t\tif (approve(_spender, _value)) {\r\n\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/* A contract attempts to get the coins */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) transfersAllowed returns (bool success) {\r\n\t\t_checkMyAging(_from);\r\n\t\tif (currentDividendIndex < dividends.length && now >= dividends[currentDividendIndex].time) {\r\n\t\t\t_addDividendsForAddress(_from);\r\n\t\t\t_addDividendsForAddress(_to);\r\n\t\t}\r\n\t\t// Check if the sender has enough\r\n\t\trequire(accountBalance(_from) >= _value);\r\n\r\n\t\t// Check allowed\r\n\t\trequire(_value <= allowed[_from][msg.sender]);\r\n\r\n\t\t// Subtract from the sender\r\n\t\tbalances[_from] = safeSub(balances[_from], _value);\r\n\t\t// Add the same to the recipient\r\n\t\tbalances[_to] = safeAdd(balances[_to], _value);\r\n\r\n\t\tallowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n\r\n\t\tif (agingTimesForPools[_from] > 0 && agingTimesForPools[_from] > now) {\r\n\t\t\t_addToAging(_from, _to, agingTimesForPools[_from], _value);\r\n\t\t}\r\n\r\n\t\t_addIndex(_to);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* This unnamed function is called whenever someone tries to send ether to it */\r\n\tfunction() {\r\n\t\trevert();\r\n\t\t// Prevents accidental sending of ether\r\n\t}\r\n\r\n\tfunction _checkMyAging(address sender) internal {\r\n\t\tif (agingBalanceOf[sender][0] == 0) return;\r\n\r\n\t\tfor (uint256 k = 0; k < agingTimes.length; k++) {\r\n\t\t\tif (agingTimes[k] < now) {\r\n\t\t\t\tagingBalanceOf[sender][0] = safeSub(agingBalanceOf[sender][0], agingBalanceOf[sender][agingTimes[k]]);\r\n\t\t\t\tagingBalanceOf[sender][agingTimes[k]] = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addAgingTimesForPool(address poolAddress, uint256 agingTime) onlyOwner {\r\n\t\tagingTimesForPools[poolAddress] = agingTime;\r\n\t}\r\n\r\n\tfunction countAddresses() constant returns (uint256 length) {\r\n\t\treturn addressByIndex.length;\r\n\t}\r\n\r\n\tfunction accountBalance(address _address) constant returns (uint256 balance) {\r\n\t\treturn safeSub(balances[_address], agingBalanceOf[_address][0]);\r\n\t}\r\n\r\n\tfunction disableTransfers(bool _disable) public onlyOwner {\r\n\t\ttransfersEnabled = !_disable;\r\n\t}\r\n\r\n\tfunction issue(address _to, uint256 _amount) public onlyOwner validAddress(_to) notThis(_to) {\r\n\t\t_totalSupply = safeAdd(_totalSupply, _amount);\r\n\t\tbalances[_to] = safeAdd(balances[_to], _amount);\r\n\r\n\t\t_addIndex(_to);\r\n\t\tIssuance(_amount);\r\n\t\tTransfer(this, _to, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t * Remove `_value` tokens from the system irreversibly\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value) returns (bool success) {\r\n\t\tdestroy(msg.sender, _value);\r\n\t\tBurn(msg.sender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t * Remove `_amount` tokens from the system irreversibly\r\n\t * @param _from the address from which tokens will be burnt\r\n\t * @param _amount the amount of money to burn\r\n\t */\r\n\tfunction destroy(address _from, uint256 _amount) public {\r\n\t\t_checkMyAging(_from);\r\n\t\t// validate input\r\n\t\trequire((msg.sender == _from && allowManuallyBurnTokens) || msg.sender == owner);\r\n\t\trequire(accountBalance(_from) >= _amount);\r\n\r\n\t\tbalances[_from] = safeSub(balances[_from], _amount);\r\n\t\t_totalSupply = safeSub(_totalSupply, _amount);\r\n\r\n\t\tTransfer(_from, this, _amount);\r\n\t\tDestruction(_amount);\r\n\t}\r\n\r\n\tfunction disableManuallyBurnTokens(bool _disable) public onlyOwner {\r\n\t\tallowManuallyBurnTokens = !_disable;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"allAgingTimesAdded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"calculateDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowManuallyBurnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableManuallyBurnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"addAgingTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"accountBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"agingBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"poolAddress\",\"type\":\"address\"},{\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"addAgingTimesForPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countAddresses\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"AgingTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"NewSmartToken\",\"type\":\"event\"}]","ContractName":"CSToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://126d7a02e20e4d8fd7cebb056e932b30c5973dbea8d0c8f9031aeb5846936a0b"}]}