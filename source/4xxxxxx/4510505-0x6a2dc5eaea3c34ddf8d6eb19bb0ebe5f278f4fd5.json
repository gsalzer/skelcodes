{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.16;\r\n\r\ncontract Token {\r\n\r\n    /* Total amount of tokens */\r\n    uint256 public totalSupply;\r\n\r\n    /*\r\n     * Events\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n\r\n    /// @notice send `value` token to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint value) public returns (bool);\r\n\r\n    /// @notice send `value` token to `to` from `from` on the condition it is approved by `from`\r\n    /// @param from The address of the sender\r\n    /// @param to The address of the recipient\r\n    /// @param value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `value` tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address spender, uint value) public returns (bool);\r\n\r\n    /// @param owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address owner) public constant returns (uint);\r\n\r\n    /// @param owner The address of the account owning tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address owner, address spender) public constant returns (uint);\r\n}\r\n\r\ncontract StandardToken is Token {\r\n    /*\r\n     *  Storage\r\n    */\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowances;\r\n\r\n    /*\r\n     *  Public functions\r\n    */\r\n\r\n    function transfer(address to, uint value) public returns (bool) {\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((to != 0x0) && (to != address(this)));\r\n        if (balances[msg.sender] < value)\r\n            revert();  // Balance too low\r\n        balances[msg.sender] -= value;\r\n        balances[to] += value;\r\n        Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) public returns (bool) {\r\n        // Do not allow transfer to 0x0 or the token contract itself\r\n        require((to != 0x0) && (to != address(this)));\r\n        if (balances[from] < value || allowances[from][msg.sender] < value)\r\n            revert(); // Balance or allowance too low\r\n        balances[to] += value;\r\n        balances[from] -= value;\r\n        allowances[from][msg.sender] -= value;\r\n        Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint value) public returns (bool) {\r\n        allowances[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public constant returns (uint) {\r\n        return allowances[owner][spender];\r\n    }\r\n\r\n    function balanceOf(address owner) public constant returns (uint) {\r\n        return balances[owner];\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n      uint256 c = a * b;\r\n      assert(a == 0 || c / a == b);\r\n      return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n      uint256 c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n      return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n      uint256 c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n    }\r\n}\r\n\r\ncontract ShitToken is StandardToken {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n    *  Metadata\r\n    */\r\n    string public constant name = \"Shit Utility Token\";\r\n    string public constant symbol = \"SHIT\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant tokenUnit = 10 ** uint256(decimals);\r\n\r\n    /*\r\n    *  Contract owner (Shit International)\r\n    */\r\n    address public owner;\r\n\r\n    /*\r\n    *  Hardware wallets\r\n    */\r\n    address public ethFundAddress;  // Address for ETH owned by Shit International\r\n    address public shitFundAddress;  // Address for SHIT allocated to Shit International\r\n\r\n    /*\r\n    *  List of registered participants\r\n    */\r\n    mapping (address => bool) public registered;\r\n\r\n    /*\r\n    *  List of token purchases per address\r\n    *  Same as balances[], except used for individual cap calculations, \r\n    *  because users can transfer tokens out during sale and reset token count in balances.\r\n    */\r\n    mapping (address => uint) public purchases;\r\n\r\n    /*\r\n    *  Crowdsale parameters\r\n    */\r\n    bool public isFinalized;\r\n    bool public isStopped;\r\n    uint256 public startBlock;  // Block number when sale period begins\r\n    uint256 public endBlock;  // Block number when sale period ends\r\n    uint256 public firstCapEndingBlock;  // Block number when first individual user cap period ends\r\n    uint256 public secondCapEndingBlock;  // Block number when second individual user cap period ends\r\n    uint256 public assignedSupply;  // Total SHIT tokens currently assigned\r\n    uint256 public tokenExchangeRate;  // Units of SHIT per ETH\r\n    uint256 public baseTokenCapPerAddress;  // Base user cap in SHIT tokens\r\n    uint256 public constant baseEthCapPerAddress = 1000000 ether;  // Base user cap in ETH\r\n    uint256 public constant blocksInFirstCapPeriod = 1;  // Block length for first cap period\r\n    uint256 public constant blocksInSecondCapPeriod = 1;  // Block length for second cap period\r\n    uint256 public constant gasLimitInWei = 51000000000 wei; //  Gas price limit during individual cap period \r\n    uint256 public constant shitFund = 100 * (10**6) * tokenUnit;  // 100M SHIT reserved for development and user growth fund \r\n    uint256 public constant minCap = 1 * tokenUnit;  // 100M min cap to be sold during sale\r\n\r\n    /*\r\n    *  Events\r\n    */\r\n    event RefundSent(address indexed _to, uint256 _value);\r\n    event ClaimSHIT(address indexed _to, uint256 _value);\r\n\r\n    modifier onlyBy(address _account){\r\n        require(msg.sender == _account);  \r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) onlyBy(owner) external {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    modifier minCapReached() {\r\n        require(assignedSupply >= minCap);\r\n        _;\r\n    }\r\n\r\n    modifier minCapNotReached() {\r\n        require(assignedSupply < minCap);\r\n        _;\r\n    }\r\n\r\n    modifier respectTimeFrame() {\r\n        require(block.number >= startBlock && block.number < endBlock);\r\n        _;\r\n    }\r\n\r\n    modifier salePeriodCompleted() {\r\n        require(block.number >= endBlock || assignedSupply.add(shitFund) == totalSupply);\r\n        _;\r\n    }\r\n\r\n    modifier isValidState() {\r\n        require(!isFinalized && !isStopped);\r\n        _;\r\n    }\r\n\r\n    /*\r\n    *  Constructor\r\n    */\r\n    function ShitToken(\r\n        address _ethFundAddress,\r\n        address _shitFundAddress,\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _tokenExchangeRate) \r\n        public \r\n    {\r\n        require(_shitFundAddress != 0x0);\r\n        require(_ethFundAddress != 0x0);\r\n        require(_startBlock < _endBlock && _startBlock > block.number);\r\n\r\n        owner = msg.sender; // Creator of contract is owner\r\n        isFinalized = false; // Controls pre-sale state through crowdsale state\r\n        isStopped = false;  // Circuit breaker (only to be used by contract owner in case of emergency)\r\n        ethFundAddress = _ethFundAddress;\r\n        shitFundAddress = _shitFundAddress;\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        tokenExchangeRate = _tokenExchangeRate;\r\n        baseTokenCapPerAddress = baseEthCapPerAddress.mul(tokenExchangeRate);\r\n        firstCapEndingBlock = startBlock.add(blocksInFirstCapPeriod);\r\n        secondCapEndingBlock = firstCapEndingBlock.add(blocksInSecondCapPeriod);\r\n        totalSupply = 1000 * (10**6) * tokenUnit;  // 1B total SHIT tokens\r\n        assignedSupply = 0;  // Set starting assigned supply to 0\r\n    }\r\n\r\n    /// @notice Stop sale in case of emergency (i.e. circuit breaker)\r\n    /// @dev Only allowed to be called by the owner\r\n    function stopSale() onlyBy(owner) external {\r\n        isStopped = true;\r\n    }\r\n\r\n    /// @notice Restart sale in case of an emergency stop\r\n    /// @dev Only allowed to be called by the owner\r\n    function restartSale() onlyBy(owner) external {\r\n        isStopped = false;\r\n    }\r\n\r\n    /// @dev Fallback function can be used to buy tokens\r\n    function () payable public {\r\n        claimTokens();\r\n    }\r\n\r\n    /// @notice Create `msg.value` ETH worth of SHIT\r\n    /// @dev Only allowed to be called within the timeframe of the sale period\r\n    function claimTokens() respectTimeFrame isValidState payable public {\r\n        require(msg.value > 0);\r\n\r\n        uint256 tokens = msg.value.mul(tokenExchangeRate);\r\n\r\n        require(isWithinCap(tokens));\r\n\r\n        // Check that we're not over totals\r\n        uint256 checkedSupply = assignedSupply.add(tokens);\r\n\r\n        // Return money if we're over total token supply\r\n        require(checkedSupply.add(shitFund) <= totalSupply); \r\n\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        purchases[msg.sender] = purchases[msg.sender].add(tokens);\r\n\r\n        assignedSupply = checkedSupply;\r\n        ClaimSHIT(msg.sender, tokens);  // Logs token creation for UI purposes\r\n        // As per ERC20 spec, a token contract which creates new tokens SHOULD trigger a Transfer event with the _from address\r\n        // set to 0x0 when tokens are created (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md)\r\n        Transfer(0x0, msg.sender, tokens);\r\n    }\r\n\r\n    /// @dev Checks if transaction meets individual cap requirements\r\n    function isWithinCap(uint256 tokens) internal view returns (bool) {\r\n        // Return true if we've passed the cap period\r\n        if (block.number >= secondCapEndingBlock) {\r\n            return true;\r\n        }\r\n\r\n        // Ensure user is under gas limit\r\n        require(tx.gasprice <= gasLimitInWei);\r\n        \r\n        // Ensure user is not purchasing more tokens than allowed\r\n        if (block.number < firstCapEndingBlock) {\r\n            return purchases[msg.sender].add(tokens) <= baseTokenCapPerAddress;\r\n        } else {\r\n            return purchases[msg.sender].add(tokens) <= baseTokenCapPerAddress.mul(4);\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Updates registration status of an address for sale participation\r\n    /// @param target Address that will be registered or deregistered\r\n    /// @param isRegistered New registration status of address\r\n    function changeRegistrationStatus(address target, bool isRegistered) public onlyBy(owner) {\r\n        registered[target] = isRegistered;\r\n    }\r\n\r\n    /// @notice Updates registration status for multiple addresses for participation\r\n    /// @param targets Addresses that will be registered or deregistered\r\n    /// @param isRegistered New registration status of addresses\r\n    function changeRegistrationStatuses(address[] targets, bool isRegistered) public onlyBy(owner) {\r\n        for (uint i = 0; i < targets.length; i++) {\r\n            changeRegistrationStatus(targets[i], isRegistered);\r\n        }\r\n    }\r\n\r\n    /// @notice Sends the ETH to ETH fund wallet and finalizes the token sale\r\n    function finalize() minCapReached salePeriodCompleted isValidState onlyBy(owner) external {\r\n        // Upon successful completion of sale, send tokens to SHIT fund\r\n        balances[shitFundAddress] = balances[shitFundAddress].add(shitFund);\r\n        assignedSupply = assignedSupply.add(shitFund);\r\n        ClaimSHIT(shitFundAddress, shitFund);   // Log tokens claimed by SHIT International SHIT fund\r\n        Transfer(0x0, shitFundAddress, shitFund);\r\n        \r\n        // In the case where not all 100M Shit allocated to crowdfund participants\r\n        // is sold, send the remaining unassigned supply to Shit fund address,\r\n        // which will then be used to fund the user growth pool.\r\n        if (assignedSupply < totalSupply) {\r\n            uint256 unassignedSupply = totalSupply.sub(assignedSupply);\r\n            balances[shitFundAddress] = balances[shitFundAddress].add(unassignedSupply);\r\n            assignedSupply = assignedSupply.add(unassignedSupply);\r\n\r\n            ClaimSHIT(shitFundAddress, unassignedSupply);  // Log tokens claimed by Shit International SHIT fund\r\n            Transfer(0x0, shitFundAddress, unassignedSupply);\r\n        }\r\n\r\n        ethFundAddress.transfer(this.balance);\r\n\r\n        isFinalized = true; // Finalize sale\r\n    }\r\n\r\n    /// @notice Allows contributors to recover their ETH in the case of a failed token sale\r\n    /// @dev Only allowed to be called once sale period is over IF the min cap is not reached\r\n    /// @return bool True if refund successfully sent, false otherwise\r\n    function refund() minCapNotReached salePeriodCompleted isValidState external {\r\n        require(msg.sender != shitFundAddress);  // Shit International not entitled to a refund\r\n\r\n        uint256 shitVal = balances[msg.sender];\r\n        require(shitVal > 0); // Prevent refund if sender Shit balance is 0\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(shitVal);\r\n        assignedSupply = assignedSupply.sub(shitVal); // Adjust assigned supply to account for refunded amount\r\n        \r\n        uint256 ethVal = shitVal.div(tokenExchangeRate); // Covert Shit to ETH\r\n\r\n        msg.sender.transfer(ethVal);\r\n        \r\n        RefundSent(msg.sender, ethVal);  // Log successful refund \r\n    }\r\n\r\n    /*\r\n        NOTE: We explicitly do not define a fallback function, in order to prevent \r\n        receiving Ether for no reason. As noted in Solidity documentation, contracts \r\n        that receive Ether directly (without a function call, i.e. using send or transfer)\r\n        but do not define a fallback function throw an exception, sending back the Ether (this was different before Solidity v0.4.0).\r\n    */\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondCapEndingBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseTokenCapPerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shitFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksInSecondCapPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targets\",\"type\":\"address[]\"},{\"name\":\"isRegistered\",\"type\":\"bool\"}],\"name\":\"changeRegistrationStatuses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assignedSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksInFirstCapPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseEthCapPerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstCapEndingBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shitFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"isRegistered\",\"type\":\"bool\"}],\"name\":\"changeRegistrationStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasLimitInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ethFundAddress\",\"type\":\"address\"},{\"name\":\"_shitFundAddress\",\"type\":\"address\"},{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_tokenExchangeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"RefundSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ClaimSHIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ShitToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007ca9b63184bed3fad3417e74a2eab5428479ee4e00000000000000000000000030b9e1fb20a948f0eb47adaa0e520813aea884010000000000000000000000000000000000000000000000000000000000452f9c00000000000000000000000000000000000000000000000000000000004838960000000000000000000000000000000000000000000000000000000000000064","Library":"","SwarmSource":"bzzr://e7a7ddb172e5c39c904e8768888a7f0efef30a2d46272d84f11b10af4d14e2c8"}]}