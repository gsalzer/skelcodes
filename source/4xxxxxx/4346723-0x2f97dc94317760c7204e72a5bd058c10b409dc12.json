{"status":"1","message":"OK","result":[{"SourceCode":"/*************************************************************************\r\n * This contract has been merged with solidify\r\n * https://github.com/tiesnetwork/solidify\r\n *************************************************************************/\r\n \r\n pragma solidity ^0.4.10;\r\n\r\n/*************************************************************************\r\n * import \"../token/ITokenPool.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"./ERC20StandardToken.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"./IERC20Token.sol\" : start\r\n *************************************************************************/\r\n\r\n/**@dev ERC20 compliant token interface. \r\nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \r\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\r\ncontract IERC20Token {\r\n\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \r\n    function name() public constant returns (string _name) { _name; }\r\n    function symbol() public constant returns (string _symbol) { _symbol; }\r\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\r\n    \r\n    function totalSupply() constant returns (uint total) {total;}\r\n    function balanceOf(address _owner) constant returns (uint balance) {_owner; balance;}    \r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {_owner; _spender; remaining;}\r\n\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    \r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n/*************************************************************************\r\n * import \"./IERC20Token.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../common/SafeMath.sol\" : start\r\n *************************************************************************/\r\n\r\n/**dev Utility methods for overflow-proof arithmetic operations \r\n*/\r\ncontract SafeMath {\r\n\r\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\r\n    function safeAdd(uint256 a, uint256 b) internal returns (uint256) {        \r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\r\n    function safeSub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0) || (z / x == y));\r\n        return z;\r\n    }\r\n\r\n    function safeDiv(uint256 x, uint256 y) internal returns (uint256) {\r\n        assert(y != 0);\r\n        return x / y;\r\n    }\r\n}/*************************************************************************\r\n * import \"../common/SafeMath.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Standard ERC20 compliant token implementation */\r\ncontract ERC20StandardToken is IERC20Token, SafeMath {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    //tokens already issued\r\n    uint256 tokensIssued;\r\n    //balances for each account\r\n    mapping (address => uint256) balances;\r\n    //one account approves the transfer of an amount to another account\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function ERC20StandardToken() {\r\n     \r\n    }    \r\n\r\n    //\r\n    //IERC20Token implementation\r\n    // \r\n\r\n    function totalSupply() constant returns (uint total) {\r\n        total = tokensIssued;\r\n    }\r\n \r\n    function balanceOf(address _owner) constant returns (uint balance) {\r\n        balance = balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        // safeSub inside doTransfer will throw if there is not enough balance.\r\n        doTransfer(msg.sender, _to, _value);        \r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n        require(_to != address(0));\r\n        \r\n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \r\n        // safeSub inside doTransfer will throw if there is not enough balance.\r\n        doTransfer(_from, _to, _value);        \r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        remaining = allowed[_owner][_spender];\r\n    }    \r\n\r\n    //\r\n    // Additional functions\r\n    //\r\n    /**@dev Gets real token amount in the smallest token units */\r\n    function getRealTokenAmount(uint256 tokens) constant returns (uint256) {\r\n        return tokens * (uint256(10) ** decimals);\r\n    }\r\n\r\n    //\r\n    // Internal functions\r\n    //    \r\n    \r\n    function doTransfer(address _from, address _to, uint256 _value) internal {\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n    }\r\n}/*************************************************************************\r\n * import \"./ERC20StandardToken.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Token pool that manages its tokens by designating trustees */\r\ncontract ITokenPool {    \r\n\r\n    /**@dev Token to be managed */\r\n    ERC20StandardToken public token;\r\n\r\n    /**@dev Changes trustee state */\r\n    function setTrustee(address trustee, bool state);\r\n\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    /**@dev Returns remaining token amount */\r\n    function getTokenAmount() constant returns (uint256 tokens) {tokens;}\r\n}/*************************************************************************\r\n * import \"../token/ITokenPool.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../token/ReturnTokenAgent.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../common/Manageable.sol\" : start\r\n *************************************************************************/\r\n\r\n/*************************************************************************\r\n * import \"../common/Owned.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\ncontract Owned {\r\n    address public owner;        \r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**@dev allows transferring the contract ownership. */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n/*************************************************************************\r\n * import \"../common/Owned.sol\" : end\r\n *************************************************************************/\r\n\r\n///A token that have an owner and a list of managers that can perform some operations\r\n///Owner is always a manager too\r\ncontract Manageable is Owned {\r\n\r\n    event ManagerSet(address manager, bool state);\r\n\r\n    mapping (address => bool) public managers;\r\n\r\n    function Manageable() Owned() {\r\n        managers[owner] = true;\r\n    }\r\n\r\n    /**@dev Allows execution by managers only */\r\n    modifier managerOnly {\r\n        assert(managers[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        super.transferOwnership(_newOwner);\r\n\r\n        managers[_newOwner] = true;\r\n        managers[msg.sender] = false;\r\n    }\r\n\r\n    function setManager(address manager, bool state) ownerOnly {\r\n        managers[manager] = state;\r\n        ManagerSet(manager, state);\r\n    }\r\n}/*************************************************************************\r\n * import \"../common/Manageable.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"../token/ReturnableToken.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n\r\n\r\n///Token that when sent to specified contract (returnAgent) invokes additional actions\r\ncontract ReturnableToken is Manageable, ERC20StandardToken {\r\n\r\n    /**@dev List of return agents */\r\n    mapping (address => bool) public returnAgents;\r\n\r\n    function ReturnableToken() {}    \r\n    \r\n    /**@dev Sets new return agent */\r\n    function setReturnAgent(ReturnTokenAgent agent) managerOnly {\r\n        returnAgents[address(agent)] = true;\r\n    }\r\n\r\n    /**@dev Removes return agent from list */\r\n    function removeReturnAgent(ReturnTokenAgent agent) managerOnly {\r\n        returnAgents[address(agent)] = false;\r\n    }\r\n\r\n    function doTransfer(address _from, address _to, uint256 _value) internal {\r\n        super.doTransfer(_from, _to, _value);\r\n        if (returnAgents[_to]) {\r\n            ReturnTokenAgent(_to).returnToken(_from, _value);                \r\n        }\r\n    }\r\n}/*************************************************************************\r\n * import \"../token/ReturnableToken.sol\" : end\r\n *************************************************************************/\r\n\r\n///Returnable tokens receiver\r\ncontract ReturnTokenAgent is Manageable {\r\n    //ReturnableToken public returnableToken;\r\n\r\n    /**@dev List of returnable tokens in format token->flag  */\r\n    mapping (address => bool) public returnableTokens;\r\n\r\n    /**@dev Allows only token to execute method */\r\n    //modifier returnableTokenOnly {require(msg.sender == address(returnableToken)); _;}\r\n    modifier returnableTokenOnly {require(returnableTokens[msg.sender]); _;}\r\n\r\n    /**@dev Executes when tokens are transferred to this */\r\n    function returnToken(address from, uint256 amountReturned);\r\n\r\n    /**@dev Sets token that can call returnToken method */\r\n    function setReturnableToken(ReturnableToken token) managerOnly {\r\n        returnableTokens[address(token)] = true;\r\n    }\r\n\r\n    /**@dev Removes token that can call returnToken method */\r\n    function removeReturnableToken(ReturnableToken token) managerOnly {\r\n        returnableTokens[address(token)] = false;\r\n    }\r\n}/*************************************************************************\r\n * import \"../token/ReturnTokenAgent.sol\" : end\r\n *************************************************************************/\r\n\r\n\r\n/*************************************************************************\r\n * import \"./IInvestRestrictions.sol\" : start\r\n *************************************************************************/\r\n\r\n\r\n\r\n/** @dev Restrictions on investment */\r\ncontract IInvestRestrictions is Manageable {\r\n    /**@dev Returns true if investmet is allowed */\r\n    function canInvest(address investor, uint amount, uint tokensLeft) constant returns (bool result) {\r\n        investor; amount; result; tokensLeft;\r\n    }\r\n\r\n    /**@dev Called when investment was made */\r\n    function investHappened(address investor, uint amount) managerOnly {}    \r\n}/*************************************************************************\r\n * import \"./IInvestRestrictions.sol\" : end\r\n *************************************************************************/\r\n/*************************************************************************\r\n * import \"./ICrowdsaleFormula.sol\" : start\r\n *************************************************************************/\r\n\r\n/**@dev Abstraction of crowdsale token calculation function */\r\ncontract ICrowdsaleFormula {\r\n\r\n    /**@dev Returns amount of tokens that can be bought with given weiAmount */\r\n    function howManyTokensForEther(uint256 weiAmount) constant returns(uint256 tokens, uint256 excess) {\r\n        weiAmount; tokens; excess;\r\n    }\r\n\r\n    /**@dev Returns how many tokens left for sale */\r\n    function tokensLeft() constant returns(uint256 _left) { _left;}    \r\n}/*************************************************************************\r\n * import \"./ICrowdsaleFormula.sol\" : end\r\n *************************************************************************/\r\n\r\n/**@dev Crowdsale base contract, used for PRE-TGE and TGE stages\r\n* Token holder should also be the owner of this contract */\r\ncontract BCSCrowdsale is ICrowdsaleFormula, Manageable, SafeMath {\r\n\r\n    enum State {Unknown, BeforeStart, Active, FinishedSuccess, FinishedFailure}\r\n    \r\n    ITokenPool public tokenPool;\r\n    IInvestRestrictions public restrictions; //restrictions on investment\r\n    address public beneficiary; //address of contract to collect ether\r\n    uint256 public startTime; //unit timestamp of start time\r\n    uint256 public endTime; //unix timestamp of end date\r\n    uint256 public minimumGoalInWei; //TODO or in tokens\r\n    uint256 public tokensForOneEther; //how many tokens can you buy for 1 ether   \r\n    uint256 realAmountForOneEther; //how many tokens can you buy for 1 ether * 10**decimals   \r\n    uint256 bonusPct;   //additional percent of tokens    \r\n    bool public withdrew; //true if beneficiary already withdrew\r\n\r\n    uint256 public weiCollected;\r\n    uint256 public tokensSold;\r\n\r\n    bool public failure; //true if some error occurred during crowdsale\r\n\r\n    mapping (address => uint256) public investedFrom; //how many wei specific address invested\r\n    mapping (address => uint256) public tokensSoldTo; //how many tokens sold to specific addreess\r\n    mapping (address => uint256) public overpays;     //overpays for send value excesses\r\n\r\n    // A new investment was made\r\n    event Invested(address investor, uint weiAmount, uint tokenAmount);\r\n    // Refund was processed for a contributor\r\n    event Refund(address investor, uint weiAmount);\r\n    // Overpay refund was processed for a contributor\r\n    event OverpayRefund(address investor, uint weiAmount);\r\n\r\n    /**@dev Crowdsale constructor, can specify startTime as 0 to start crowdsale immediately \r\n    _tokensForOneEther - doesn't depend on token decimals   */ \r\n    function BCSCrowdsale(        \r\n        ITokenPool _tokenPool,\r\n        IInvestRestrictions _restrictions,\r\n        address _beneficiary, \r\n        uint256 _startTime, \r\n        uint256 _durationInHours, \r\n        uint256 _goalInWei,\r\n        uint256 _tokensForOneEther,\r\n        uint256 _bonusPct) \r\n    {\r\n        require(_beneficiary != 0x0);\r\n        require(address(_tokenPool) != 0x0);\r\n        require(_durationInHours > 0);\r\n        require(_tokensForOneEther > 0); \r\n        \r\n        tokenPool = _tokenPool;\r\n        beneficiary = _beneficiary;\r\n        restrictions = _restrictions;\r\n        \r\n        if (_startTime == 0) {\r\n            startTime = now;\r\n        } else {\r\n            startTime = _startTime;\r\n        }\r\n        endTime = (_durationInHours * 1 hours) + startTime;        \r\n        \r\n        tokensForOneEther = _tokensForOneEther;\r\n        minimumGoalInWei = _goalInWei;\r\n        bonusPct = _bonusPct;\r\n\r\n        weiCollected = 0;\r\n        tokensSold = 0;\r\n        failure = false;\r\n        withdrew = false;\r\n\r\n        realAmountForOneEther = tokenPool.token().getRealTokenAmount(tokensForOneEther);\r\n    }\r\n\r\n    function() payable {\r\n        invest();\r\n    }\r\n\r\n    function invest() payable {\r\n        require(canInvest(msg.sender, msg.value));\r\n        \r\n        uint256 excess;\r\n        uint256 weiPaid = msg.value;\r\n        uint256 tokensToBuy;\r\n        (tokensToBuy, excess) = howManyTokensForEther(weiPaid);\r\n\r\n        require(tokensToBuy <= tokensLeft() && tokensToBuy > 0);\r\n\r\n        if (excess > 0) {\r\n            overpays[msg.sender] = safeAdd(overpays[msg.sender], excess);\r\n            weiPaid = safeSub(weiPaid, excess);\r\n        }\r\n        \r\n        investedFrom[msg.sender] = safeAdd(investedFrom[msg.sender], weiPaid);      \r\n        tokensSoldTo[msg.sender] = safeAdd(tokensSoldTo[msg.sender], tokensToBuy);\r\n        \r\n        tokensSold = safeAdd(tokensSold, tokensToBuy);\r\n        weiCollected = safeAdd(weiCollected, weiPaid);\r\n\r\n        if(address(restrictions) != 0x0) {\r\n            restrictions.investHappened(msg.sender, msg.value);\r\n        }\r\n        \r\n        require(tokenPool.token().transferFrom(tokenPool, msg.sender, tokensToBuy));\r\n\r\n        Invested(msg.sender, weiPaid, tokensToBuy);\r\n    }\r\n\r\n    /**@dev Returns true if it is possible to invest */\r\n    function canInvest(address investor, uint256 amount) constant returns(bool) {\r\n        return getState() == State.Active &&\r\n                    (address(restrictions) == 0x0 || \r\n                    restrictions.canInvest(investor, amount, tokensLeft()));\r\n    }\r\n\r\n    /**@dev ICrowdsaleFormula override */\r\n    function howManyTokensForEther(uint256 weiAmount) constant returns(uint256 tokens, uint256 excess) {        \r\n        uint256 bpct = getCurrentBonusPct();        \r\n        uint256 maxTokens = (tokensLeft() * 100) / (100 + bpct);\r\n\r\n        tokens = weiAmount * realAmountForOneEther / 1 ether;\r\n        if (tokens > maxTokens) {\r\n            tokens = maxTokens;\r\n        }\r\n\r\n        excess = weiAmount - tokens * 1 ether / realAmountForOneEther;\r\n\r\n        tokens = (tokens * 100 + tokens * bpct) / 100;\r\n    }\r\n\r\n    /**@dev Returns current bonus percent [0-100] */\r\n    function getCurrentBonusPct() constant returns (uint256) {\r\n        return bonusPct;\r\n    }\r\n    \r\n    /**@dev Returns how many tokens left for sale */\r\n    function tokensLeft() constant returns(uint256) {        \r\n        return tokenPool.getTokenAmount();\r\n    }\r\n\r\n    /**@dev Returns funds that should be sent to beneficiary */\r\n    function amountToBeneficiary() constant returns (uint256) {\r\n        return weiCollected;\r\n    } \r\n\r\n    /**@dev Returns crowdsale current state */\r\n    function getState() constant returns (State) {\r\n        if (failure) {\r\n            return State.FinishedFailure;\r\n        }\r\n        \r\n        if (now < startTime) {\r\n            return State.BeforeStart;\r\n        } else if (now < endTime && tokensLeft() > 0) {\r\n            return State.Active;\r\n        } else if (weiCollected >= minimumGoalInWei || tokensLeft() <= 0) {\r\n            return State.FinishedSuccess;\r\n        } else {\r\n            return State.FinishedFailure;\r\n        }\r\n    }\r\n\r\n    /**@dev Allows investors to withdraw funds and overpays in case of crowdsale failure */\r\n    function refund() {\r\n        require(getState() == State.FinishedFailure);\r\n\r\n        uint amount = investedFrom[msg.sender];        \r\n\r\n        if (amount > 0) {\r\n            investedFrom[msg.sender] = 0;\r\n            weiCollected = safeSub(weiCollected, amount);            \r\n            msg.sender.transfer(amount);\r\n            \r\n            Refund(msg.sender, amount);            \r\n        }\r\n    }    \r\n\r\n    /**@dev Allows investor to withdraw overpay */\r\n    function withdrawOverpay() {\r\n        uint amount = overpays[msg.sender];\r\n        overpays[msg.sender] = 0;        \r\n\r\n        if (amount > 0) {\r\n            if (msg.sender.send(amount)) {\r\n                OverpayRefund(msg.sender, amount);\r\n            } else {\r\n                overpays[msg.sender] = amount; //restore funds in case of failed send\r\n            }\r\n        }\r\n    }\r\n\r\n    /**@dev Transfers all collected funds to beneficiary*/\r\n    function transferToBeneficiary() {\r\n        require(getState() == State.FinishedSuccess && !withdrew);\r\n        \r\n        withdrew = true;\r\n        uint256 amount = amountToBeneficiary();\r\n\r\n        beneficiary.transfer(amount);\r\n        Refund(beneficiary, amount);\r\n    }\r\n\r\n    /**@dev Makes crowdsale failed/ok, for emergency reasons */\r\n    function makeFailed(bool state) managerOnly {\r\n        failure = state;\r\n    }\r\n\r\n    /**@dev Sets new beneficiary */\r\n    function changeBeneficiary(address newBeneficiary) managerOnly {\r\n        beneficiary = newBeneficiary;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"howManyTokensForEther\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"excess\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawOverpay\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumGoalInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBonusPct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensSoldTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"overpays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"failure\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForOneEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferToBeneficiary\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restrictions\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"makeFailed\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountToBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"changeBeneficiary\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrew\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenPool\",\"type\":\"address\"},{\"name\":\"_restrictions\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_durationInHours\",\"type\":\"uint256\"},{\"name\":\"_goalInWei\",\"type\":\"uint256\"},{\"name\":\"_tokensForOneEther\",\"type\":\"uint256\"},{\"name\":\"_bonusPct\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"OverpayRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"ManagerSet\",\"type\":\"event\"}]","ContractName":"BCSCrowdsale","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a5ab0ef3ef3711d8ecfe0a7ba42745cbcfb549cc000000000000000000000000b7f78e6016cd45a448d3703ab1b4f5b5e5d41e69000000000000000000000000b9c5f14e5e460ef926e5772783992f686fc2d3c40000000000000000000000000000000000000000000000000000000059daf4400000000000000000000000000000000000000000000000000000000000000648000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000032","Library":"","SwarmSource":"bzzr://315d1d1d6f2987766ee3220671abb2f42fe0ab2ec5a6e14479178597acbd19d9"}]}