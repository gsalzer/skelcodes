{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _newOwner) onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Prealloc\r\n * @dev Pre-alloc storage vars, to flatten gas usage in future operations.\r\n */\r\nlibrary Prealloc {\r\n    struct UINT256 {\r\n        uint256 value_;\r\n    }\r\n\r\n    function set(UINT256 storage i, uint256 value) internal {\r\n        i.value_ = ~value;\r\n    }\r\n\r\n    function get(UINT256 storage i) internal constant returns (uint256) {\r\n        return ~i.value_;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ncontract Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\n/// VEN token, ERC20 compliant\r\ncontract VEN is Token, Owned {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name    = \"VeChain Token\";  //The Token's name\r\n    uint8 public constant decimals = 18;               //Number of decimals of the smallest unit\r\n    string public constant symbol  = \"VEN\";            //An identifier    \r\n\r\n    struct Account {\r\n        uint256 balance;\r\n        // raw token can be transformed into balance with bonus\r\n        uint256 rawTokens;\r\n    }\r\n\r\n    // Balances for each account\r\n    mapping(address => Account) accounts;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    // every buying will update this var. \r\n    // pre-alloc to make first buying cost no much more gas than subsequent\r\n    using Prealloc for Prealloc.UINT256;\r\n    Prealloc.UINT256 rawTokensSupplied;\r\n\r\n    // bonus that can be shared by raw tokens\r\n    uint256 bonusOffered;\r\n\r\n    // Constructor\r\n    function VEN() {\r\n        rawTokensSupplied.set(0);\r\n    }\r\n\r\n    // Send back ether sent to me\r\n    function () {\r\n        revert();\r\n    }\r\n\r\n    // If sealed, transfer is enabled and mint is disabled\r\n    function isSealed() constant returns (bool) {\r\n        return owner == 0;\r\n    }\r\n\r\n    // Claim bonus by raw tokens\r\n    function claimBonus(address _owner) internal{      \r\n        require(isSealed());\r\n        if (accounts[_owner].rawTokens != 0) {\r\n            accounts[_owner].balance = balanceOf(_owner);\r\n            accounts[_owner].rawTokens = 0;\r\n        }\r\n    }\r\n\r\n    // What is the balance of a particular account?\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        if (accounts[_owner].rawTokens == 0)\r\n            return accounts[_owner].balance;\r\n\r\n        if (isSealed()) {\r\n            uint256 bonus = \r\n                 accounts[_owner].rawTokens\r\n                .mul(bonusOffered)\r\n                .div(rawTokensSupplied.get());\r\n\r\n            return accounts[_owner].balance\r\n                    .add(accounts[_owner].rawTokens)\r\n                    .add(bonus);\r\n        }\r\n        \r\n        return accounts[_owner].balance.add(accounts[_owner].rawTokens);\r\n    }\r\n\r\n    // Transfer the balance from owner's account to another account\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\n        require(isSealed());\r\n\r\n        // implicitly claim bonus for both sender and receiver\r\n        claimBonus(msg.sender);\r\n        claimBonus(_to);\r\n\r\n        if (accounts[msg.sender].balance >= _amount\r\n            && _amount > 0\r\n            && accounts[_to].balance + _amount > accounts[_to].balance) {\r\n            accounts[msg.sender].balance -= _amount;\r\n            accounts[_to].balance += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    // fees in sub-currencies; the command should fail unless the _from account has\r\n    // deliberately authorized the sender of the message via some mechanism; we propose\r\n    // these standardized APIs for approval:\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) returns (bool success) {\r\n        require(isSealed());\r\n\r\n        // implicitly claim bonus for both sender and receiver\r\n        claimBonus(_from);\r\n        claimBonus(_to);\r\n\r\n        if (accounts[_from].balance >= _amount\r\n            && allowed[_from][msg.sender] >= _amount\r\n            && _amount > 0\r\n            && accounts[_to].balance + _amount > accounts[_to].balance) {\r\n            accounts[_from].balance -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            accounts[_to].balance += _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        //if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\r\n        ApprovalReceiver(_spender).receiveApproval(msg.sender, _value, this, _extraData);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Mint tokens and assign to some one\r\n    function mint(address _owner, uint256 _amount, bool _isRaw) onlyOwner{\r\n        if (_isRaw) {\r\n            accounts[_owner].rawTokens = accounts[_owner].rawTokens.add(_amount);\r\n            rawTokensSupplied.set(rawTokensSupplied.get().add(_amount));\r\n        } else {\r\n            accounts[_owner].balance = accounts[_owner].balance.add(_amount);\r\n        }\r\n\r\n        totalSupply = totalSupply.add(_amount);\r\n        Transfer(0, _owner, _amount);\r\n    }\r\n    \r\n    // Offer bonus to raw tokens holder\r\n    function offerBonus(uint256 _bonus) onlyOwner {\r\n        bonusOffered = bonusOffered.add(_bonus);\r\n    }\r\n\r\n    // Set owner to zero address, to disable mint, and enable token transfer\r\n    function seal() onlyOwner {\r\n        setOwner(0);\r\n\r\n        totalSupply = totalSupply.add(bonusOffered);\r\n        Transfer(0, address(-1), bonusOffered);\r\n    }\r\n}\r\n\r\ncontract ApprovalReceiver {\r\n    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData);\r\n}\r\n\r\n\r\n// Contract to sell and distribute VEN tokens\r\ncontract VENSale is Owned{\r\n\r\n    /// chart of stage transition \r\n    ///\r\n    /// deploy   initialize      startTime                            endTime                 finalize\r\n    ///                              | <-earlyStageLasts-> |             | <- closedStageLasts -> |\r\n    ///  O-----------O---------------O---------------------O-------------O------------------------O------------>\r\n    ///     Created     Initialized           Early             Normal             Closed            Finalized\r\n    enum Stage {\r\n        NotCreated,\r\n        Created,\r\n        Initialized,\r\n        Early,\r\n        Normal,\r\n        Closed,\r\n        Finalized\r\n    }\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 public constant totalSupply         = (10 ** 9) * (10 ** 18); // 1 billion VEN, decimals set to 18\r\n\r\n    uint256 constant privateSupply              = totalSupply * 9 / 100;  // 9% for private ICO\r\n    uint256 constant commercialPlan             = totalSupply * 23 / 100; // 23% for commercial plan\r\n    uint256 constant reservedForTeam            = totalSupply * 5 / 100;  // 5% for team\r\n    uint256 constant reservedForOperations      = totalSupply * 22 / 100; // 22 for operations\r\n\r\n    // 59%\r\n    uint256 public constant nonPublicSupply     = privateSupply + commercialPlan + reservedForTeam + reservedForOperations;\r\n    // 41%\r\n    uint256 public constant publicSupply = totalSupply - nonPublicSupply;\r\n\r\n    uint256 public officialLimit;\r\n    uint256 public channelsLimit;\r\n\r\n    using Prealloc for Prealloc.UINT256;\r\n    Prealloc.UINT256 officialSold_; // amount of tokens officially sold out\r\n\r\n    uint256 public channelsSold;    // amount of tokens sold out via channels\r\n    \r\n    uint256 constant venPerEth = 3500;  // normal exchange rate\r\n    uint256 constant venPerEthEarlyStage = venPerEth + venPerEth * 15 / 100;  // early stage has 15% reward\r\n   \r\n    VEN ven; // VEN token contract follows ERC20 standard\r\n\r\n    address ethVault; // the account to keep received ether\r\n    address venVault; // the account to keep non-public offered VEN tokens\r\n\r\n    uint public startTime; // time to start sale\r\n    uint public endTime;   // tiem to close sale\r\n    uint public earlyStageLasts; // early bird stage lasts in seconds\r\n\r\n    bool initialized;\r\n    bool finalized;\r\n\r\n    function VENSale() {\r\n        officialSold_.set(0);\r\n    }    \r\n\r\n    /// @notice calculte exchange rate according to current stage\r\n    /// @return exchange rate. zero if not in sale.\r\n    function exchangeRate() constant returns (uint256){\r\n        if (stage() == Stage.Early) {\r\n            return venPerEthEarlyStage;\r\n        }\r\n        if (stage() == Stage.Normal) {\r\n            return venPerEth;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /// @notice for test purpose\r\n    function blockTime() constant returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /// @notice estimate stage\r\n    /// @return current stage\r\n    function stage() constant returns (Stage) { \r\n        if (finalized) {\r\n            return Stage.Finalized;\r\n        }\r\n\r\n        if (!initialized) {\r\n            // deployed but not initialized\r\n            return Stage.Created;\r\n        }\r\n\r\n        if (blockTime() < startTime) {\r\n            // not started yet\r\n            return Stage.Initialized;\r\n        }\r\n\r\n        if (officialSold_.get().add(channelsSold) >= publicSupply) {\r\n            // all sold out\r\n            return Stage.Closed;\r\n        }\r\n\r\n        if (blockTime() < endTime) {\r\n            // in sale            \r\n            if (blockTime() < startTime.add(earlyStageLasts)) {\r\n                // early bird stage\r\n                return Stage.Early;\r\n            }\r\n            // normal stage\r\n            return Stage.Normal;\r\n        }\r\n\r\n        // closed\r\n        return Stage.Closed;\r\n    }\r\n\r\n    /// @notice entry to buy tokens\r\n    function () payable {        \r\n        buy();\r\n    }\r\n\r\n    /// @notice entry to buy tokens\r\n    function buy() payable {\r\n        require(msg.value >= 0.01 ether);\r\n\r\n        uint256 rate = exchangeRate();\r\n        // here don't need to check stage. rate is only valid when in sale\r\n        require(rate > 0);\r\n\r\n        uint256 remained = officialLimit.sub(officialSold_.get());\r\n        uint256 requested = msg.value.mul(rate);\r\n        if (requested > remained) {\r\n            //exceed remained\r\n            requested = remained;\r\n        }\r\n\r\n        uint256 ethCost = requested.div(rate);\r\n        if (requested > 0) {\r\n            ven.mint(msg.sender, requested, true);\r\n            // transfer ETH to vault\r\n            ethVault.transfer(ethCost);\r\n\r\n            officialSold_.set(officialSold_.get().add(requested));\r\n            onSold(msg.sender, requested, ethCost);        \r\n        }\r\n\r\n        uint256 toReturn = msg.value.sub(ethCost);\r\n        if(toReturn > 0) {\r\n            // return over payed ETH\r\n            msg.sender.transfer(toReturn);\r\n        }        \r\n    }\r\n\r\n    /// @notice calculate tokens sold officially\r\n    function officialSold() constant returns (uint256) {\r\n        return officialSold_.get();\r\n    }\r\n\r\n    /// @notice manually offer tokens to channels\r\n    function offerToChannels(uint256 _venAmount) onlyOwner {\r\n        Stage stg = stage();\r\n        // since the settlement may be delayed, so it's allowed in closed stage\r\n        require(stg == Stage.Early || stg == Stage.Normal || stg == Stage.Closed);\r\n\r\n        channelsSold = channelsSold.add(_venAmount);\r\n\r\n        //should not exceed limit\r\n        require(channelsSold <= channelsLimit);\r\n\r\n        ven.mint(\r\n            venVault,\r\n            _venAmount,\r\n            true  // unsold tokens can be claimed by channels portion\r\n            );\r\n\r\n        onSold(venVault, _venAmount, 0);\r\n    }\r\n\r\n    /// @notice initialize to prepare for sale\r\n    /// @param _ven The address VEN token contract following ERC20 standard\r\n    /// @param _ethVault The place to store received ETH\r\n    /// @param _venVault The place to store non-publicly supplied VEN tokens\r\n    /// @param _channelsLimit The hard limit for channels sale\r\n    /// @param _startTime The time when sale starts\r\n    /// @param _endTime The time when sale ends\r\n    /// @param _earlyStageLasts duration of early stage\r\n    function initialize(\r\n        VEN _ven,\r\n        address _ethVault,\r\n        address _venVault,\r\n        uint256 _channelsLimit,\r\n        uint _startTime,\r\n        uint _endTime,\r\n        uint _earlyStageLasts) onlyOwner {\r\n        require(stage() == Stage.Created);\r\n\r\n        // ownership of token contract should already be this\r\n        require(_ven.owner() == address(this));\r\n\r\n        require(address(_ethVault) != 0);\r\n        require(address(_venVault) != 0);\r\n\r\n        require(_startTime > blockTime());\r\n        require(_startTime.add(_earlyStageLasts) < _endTime);        \r\n\r\n        ven = _ven;\r\n        \r\n        ethVault = _ethVault;\r\n        venVault = _venVault;\r\n\r\n        channelsLimit = _channelsLimit;\r\n        officialLimit = publicSupply.sub(_channelsLimit);\r\n\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        earlyStageLasts = _earlyStageLasts;        \r\n        \r\n        ven.mint(\r\n            venVault,\r\n            reservedForTeam.add(reservedForOperations),\r\n            false // team and operations reserved portion can't share unsold tokens\r\n        );\r\n\r\n        ven.mint(\r\n            venVault,\r\n            privateSupply.add(commercialPlan),\r\n            true // private ICO and commercial plan can share unsold tokens\r\n        );\r\n\r\n        initialized = true;\r\n        onInitialized();\r\n    }\r\n\r\n    /// @notice finalize\r\n    function finalize() onlyOwner {\r\n        // only after closed stage\r\n        require(stage() == Stage.Closed);       \r\n\r\n        uint256 unsold = publicSupply.sub(officialSold_.get()).sub(channelsSold);\r\n\r\n        if (unsold > 0) {\r\n            // unsold VEN as bonus\r\n            ven.offerBonus(unsold);        \r\n        }\r\n        ven.seal();\r\n\r\n        finalized = true;\r\n        onFinalized();\r\n    }\r\n\r\n    event onInitialized();\r\n    event onFinalized();\r\n\r\n    event onSold(address indexed buyer, uint256 venAmount, uint256 ethCost);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"seal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"offerBonus\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSealed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_isRaw\",\"type\":\"bool\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"VEN","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://25b056fd26f4d32c925e02b86f9e46f76cf66650f7b88d6d8cd684ddf9dee692"}]}