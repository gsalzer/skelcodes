{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function minimum( uint a, uint b) internal returns ( uint result) {\r\n    if ( a <= b ) {\r\n      result = a;\r\n    }\r\n    else {\r\n      result = b;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract DRTCoin is StandardToken, Ownable {\r\n    /* Overriding some ERC20 variables */\r\n    string public constant name = \"DomRaiderToken\";\r\n    string public constant symbol = \"DRT\";\r\n    uint256 public constant decimals = 8;\r\n\r\n    /* DRT specific variables */\r\n    // Max amount of tokens minted - Exact value input with stretch goals and before deploying contract\r\n    uint256 public constant MAX_SUPPLY_OF_TOKEN = 1300000000 * 10 ** decimals;\r\n\r\n    // Freeze duration for advisors accounts\r\n    uint public constant START_ICO_TIMESTAMP = 1507622400;\r\n    uint public constant DEFROST_PERIOD = 43200; // month in minutes  (1 month = 43200 min)\r\n    uint public constant DEFROST_MONTHLY_PERCENT_OWNER = 5; // 5% per month is automatically defrosted\r\n    uint public constant DEFROST_INITIAL_PERCENT_OWNER = 10; // 90% locked\r\n    uint public constant DEFROST_MONTHLY_PERCENT = 10; // 10% per month is automatically defrosted\r\n    uint public constant DEFROST_INITIAL_PERCENT = 20; // 80% locked\r\n\r\n    // Fields that can be changed by functions\r\n    address[] icedBalances;\r\n    mapping (address => uint256) icedBalances_frosted;\r\n    mapping (address => uint256) icedBalances_defrosted;\r\n\r\n    uint256 ownerFrosted;\r\n    uint256 ownerDefrosted;\r\n\r\n    // Variable useful for verifying that the assignedSupply matches that totalSupply\r\n    uint256 public assignedSupply;\r\n    //Boolean to allow or not the initial assignment of token (batch)\r\n    bool public batchAssignStopped = false;\r\n\r\n    /**\r\n     * @dev Constructor that gives msg.sender all of existing tokens.\r\n     */\r\n    function DRTCoin() {\r\n        owner = msg.sender;\r\n        uint256 amount = 545000000 * 10 ** decimals;\r\n        uint256 amount2assign = amount * DEFROST_INITIAL_PERCENT_OWNER / 100;\r\n        balances[owner] = amount2assign;\r\n        ownerDefrosted = amount2assign;\r\n        ownerFrosted = amount - amount2assign;\r\n        totalSupply = MAX_SUPPLY_OF_TOKEN;\r\n        assignedSupply = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens in batches (of addresses)\r\n     * @param _vaddr address The address which you want to send tokens from\r\n     * @param _vamounts address The address which you want to transfer to\r\n     */\r\n    function batchAssignTokens(address[] _vaddr, uint[] _vamounts, bool[] _vIcedBalance) onlyOwner {\r\n        require(batchAssignStopped == false);\r\n        require(_vaddr.length == _vamounts.length);\r\n        //Looping into input arrays to assign target amount to each given address\r\n        for (uint index = 0; index < _vaddr.length; index++) {\r\n            address toAddress = _vaddr[index];\r\n            uint amount = _vamounts[index] * 10 ** decimals;\r\n            bool isIced = _vIcedBalance[index];\r\n            if (balances[toAddress] == 0) {\r\n                // In case it's filled two times, it only increments once\r\n                // Assigns the balance\r\n                assignedSupply += amount;\r\n                if (isIced == false) {\r\n                    // Normal account\r\n                    balances[toAddress] = amount;\r\n                }\r\n                else {\r\n                    // Iced account. The balance is not affected here\r\n                    icedBalances.push(toAddress);\r\n                    uint256 amount2assign = amount * DEFROST_INITIAL_PERCENT / 100;\r\n                    balances[toAddress] = amount2assign;\r\n                    icedBalances_defrosted[toAddress] = amount2assign;\r\n                    icedBalances_frosted[toAddress] = amount - amount2assign;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function canDefrost() onlyOwner constant returns (bool bCanDefrost){\r\n        bCanDefrost = now > START_ICO_TIMESTAMP;\r\n    }\r\n\r\n    function getBlockTimestamp() constant returns (uint256){\r\n        return now;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Defrost token (for advisors)\r\n     * Method called by the owner once per defrost period (1 month)\r\n     */\r\n    function defrostToken() onlyOwner {\r\n        require(now > START_ICO_TIMESTAMP);\r\n        // Looping into the iced accounts\r\n        for (uint index = 0; index < icedBalances.length; index++) {\r\n            address currentAddress = icedBalances[index];\r\n            uint256 amountTotal = icedBalances_frosted[currentAddress] + icedBalances_defrosted[currentAddress];\r\n            uint256 targetDeFrosted = (SafeMath.minimum(100, DEFROST_INITIAL_PERCENT + elapsedMonthsFromICOStart() * DEFROST_MONTHLY_PERCENT)) * amountTotal / 100;\r\n            uint256 amountToRelease = targetDeFrosted - icedBalances_defrosted[currentAddress];\r\n            if (amountToRelease > 0) {\r\n                icedBalances_frosted[currentAddress] = icedBalances_frosted[currentAddress] - amountToRelease;\r\n                icedBalances_defrosted[currentAddress] = icedBalances_defrosted[currentAddress] + amountToRelease;\r\n                balances[currentAddress] = balances[currentAddress] + amountToRelease;\r\n            }\r\n        }\r\n\r\n    }\r\n    /**\r\n     * Defrost for the owner of the contract\r\n     */\r\n    function defrostOwner() onlyOwner {\r\n        if (now < START_ICO_TIMESTAMP) {\r\n            return;\r\n        }\r\n        uint256 amountTotal = ownerFrosted + ownerDefrosted;\r\n        uint256 targetDeFrosted = (SafeMath.minimum(100, DEFROST_INITIAL_PERCENT_OWNER + elapsedMonthsFromICOStart() * DEFROST_MONTHLY_PERCENT_OWNER)) * amountTotal / 100;\r\n        uint256 amountToRelease = targetDeFrosted - ownerDefrosted;\r\n        if (amountToRelease > 0) {\r\n            ownerFrosted = ownerFrosted - amountToRelease;\r\n            ownerDefrosted = ownerDefrosted + amountToRelease;\r\n            balances[owner] = balances[owner] + amountToRelease;\r\n        }\r\n    }\r\n\r\n    function elapsedMonthsFromICOStart() constant returns (uint elapsed) {\r\n        elapsed = ((now - START_ICO_TIMESTAMP) / 60) / DEFROST_PERIOD;\r\n    }\r\n\r\n    function stopBatchAssign() onlyOwner {\r\n        require(batchAssignStopped == false);\r\n        batchAssignStopped = true;\r\n    }\r\n\r\n    function getAddressBalance(address addr) constant returns (uint256 balance)  {\r\n        balance = balances[addr];\r\n    }\r\n\r\n    function getAddressAndBalance(address addr) constant returns (address _address, uint256 _amount)  {\r\n        _address = addr;\r\n        _amount = balances[addr];\r\n    }\r\n\r\n    function getIcedAddresses() constant returns (address[] vaddr)  {\r\n        vaddr = icedBalances;\r\n    }\r\n\r\n    function getIcedInfos(address addr) constant returns (address icedaddr, uint256 balance, uint256 frosted, uint256 defrosted)  {\r\n        icedaddr = addr;\r\n        balance = balances[addr];\r\n        frosted = icedBalances_frosted[addr];\r\n        defrosted = icedBalances_defrosted[addr];\r\n    }\r\n\r\n    function getOwnerInfos() constant returns (address owneraddr, uint256 balance, uint256 frosted, uint256 defrosted)  {\r\n        owneraddr = owner;\r\n        balance = balances[owneraddr];\r\n        frosted = ownerFrosted;\r\n        defrosted = ownerDefrosted;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"DEFROST_MONTHLY_PERCENT_OWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFROST_INITIAL_PERCENT_OWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"batchAssignStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopBatchAssign\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAddressBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"elapsedMonthsFromICOStart\",\"outputs\":[{\"name\":\"elapsed\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canDefrost\",\"outputs\":[{\"name\":\"bCanDefrost\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFROST_INITIAL_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_ICO_TIMESTAMP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwnerInfos\",\"outputs\":[{\"name\":\"owneraddr\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"frosted\",\"type\":\"uint256\"},{\"name\":\"defrosted\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFROST_MONTHLY_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SUPPLY_OF_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assignedSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFROST_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"defrostToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getIcedInfos\",\"outputs\":[{\"name\":\"icedaddr\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"frosted\",\"type\":\"uint256\"},{\"name\":\"defrosted\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAddressAndBalance\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIcedAddresses\",\"outputs\":[{\"name\":\"vaddr\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vaddr\",\"type\":\"address[]\"},{\"name\":\"_vamounts\",\"type\":\"uint256[]\"},{\"name\":\"_vIcedBalance\",\"type\":\"bool[]\"}],\"name\":\"batchAssignTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"defrostOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"DRTCoin","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://149cbc4f34b50bf9938e2d5d60b99a0ac353e18728cddbf2dfec0004d243263d"}]}