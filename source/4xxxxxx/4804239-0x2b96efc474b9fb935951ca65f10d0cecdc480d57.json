{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary CSCLib {\r\n\r\n\tuint constant MILLION = 1000000;\r\n\tuint constant GASLIMIT = 65000;\r\n\r\n\r\n\tstruct Split {\r\n\t\taddress to;\r\n\t\tuint ppm;\r\n\t}\r\n\r\n\tstruct CSCStorage {\r\n\t\tmapping(address => uint) lastUserClaim;\r\n\t\tuint[] deposits;\r\n\t\tbool isClaimable;\r\n\r\n\t\taddress developer;\r\n\t\tuint dev_fee;\r\n\t\tuint refer_fee;\r\n\t\tSplit[] splits;\r\n\t\tmapping(address => uint) userSplit;\r\n\t}\r\n\r\n\tevent SplitTransfer(address to, uint amount, uint balance);\r\n\r\n\t/*\r\n\tself: a storage pointer\r\n\r\n\tmembers: an array of addresses\r\n\r\n\tppms: an array of integers that should sum to 1 million.\r\n\t\tRepresents how much ether a user should get\r\n\r\n\trefer: the address of a referral contract that referred this user.\r\n\t\tReferral contract should be a claimable contract\r\n\r\n\t*/\r\n\tfunction init(CSCStorage storage self,  address[] members, uint[] ppms, address refer) internal {\r\n\t\tuint shift_amt = self.dev_fee / members.length;\r\n\t\tuint remainder = self.dev_fee % members.length * members.length / 10;\r\n\t\tuint dev_total = self.dev_fee + remainder;\r\n\t\tself.deposits.push(0);\r\n\t\tif(refer != 0x0){\r\n\t\t\taddSplit(self, Split({to: self.developer, ppm: dev_total - self.refer_fee}));\r\n\t\t\taddSplit(self, Split({to: refer, ppm: self.refer_fee}));\r\n\t\t} else {\r\n\t\t\taddSplit(self, Split({to: self.developer, ppm: dev_total}));\r\n\t\t}\r\n\r\n\t\tuint sum = 0;\r\n\t\tfor(uint index = 0; index < members.length; index++) {\r\n\t\t\tsum += ppms[index];\r\n\t\t\taddSplit(self, Split({to: members[index], ppm: ppms[index] - shift_amt}));\r\n\t\t}\r\n\t\trequire(sum >= MILLION - 1 && sum < MILLION + 1 );\r\n\t}\r\n\r\n\tfunction addSplit(CSCStorage storage self, Split newSplit) internal {\r\n\t\trequire(newSplit.ppm > 0);\r\n\t\tuint index = self.userSplit[newSplit.to];\r\n\t\tif(index > 0) {\r\n\t\t\tnewSplit.ppm += self.splits[index].ppm;\r\n\t\t\tself.splits[index] = newSplit;\r\n\t\t} else {\r\n\t\t\tself.userSplit[newSplit.to] = self.splits.length;\r\n\t\t\tself.lastUserClaim[newSplit.to] = self.deposits.length;\r\n\t\t\tself.splits.push(newSplit);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction payAll(CSCStorage storage self) internal {\r\n\t\tfor(uint index = 0; index < self.splits.length; index++) {\r\n\t\t\tuint value = (msg.value) * self.splits[index].ppm / MILLION;\r\n\t\t\tif(value > 0 ) {\r\n\t\t\t\trequire(self.splits[index].to.call.gas(GASLIMIT).value(value)());\r\n\t\t\t\tSplitTransfer(self.splits[index].to, value, this.balance);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getSplit(CSCStorage storage self, uint index) internal view returns (Split) {\r\n\t\treturn self.splits[index];\r\n\t}\r\n\r\n\tfunction getSplitCount(CSCStorage storage self) internal view returns (uint count) {\r\n\t\treturn self.splits.length;\r\n\t}\r\n\r\n\tfunction claimFor(CSCStorage storage self, address user) internal {\r\n\t\trequire(self.isClaimable);\r\n\t\tuint sum = getClaimableBalanceFor(self, user);\r\n\t\tuint splitIndex = self.userSplit[user];\r\n\t\tself.lastUserClaim[user] = self.deposits.length;\r\n\t\tif(sum > 0) {\r\n\t\t\trequire(self.splits[splitIndex].to.call.gas(GASLIMIT).value(sum)());\r\n\t\t\tSplitTransfer(self.splits[splitIndex].to, sum, this.balance);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction claim(CSCStorage storage self)  internal {\r\n\t\treturn claimFor(self, msg.sender);\r\n\t}\r\n\r\n\tfunction getClaimableBalanceFor(CSCStorage storage self, address user) internal view returns (uint balance) {\r\n\t\tuint splitIndex = self.userSplit[user];\r\n\t\tuint lastClaimIndex = self.lastUserClaim[user];\r\n\t\tuint unclaimed = 0;\r\n\t\tif(self.splits[splitIndex].to == user) {\r\n\t\t\tfor(uint depositIndex = lastClaimIndex; depositIndex < self.deposits.length; depositIndex++) {\r\n\t\t\t\tuint value = self.deposits[depositIndex] * self.splits[splitIndex].ppm / MILLION;\r\n\t\t\t\tunclaimed += value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn unclaimed;\r\n\t}\r\n\r\n\tfunction getClaimableBalance(CSCStorage storage self)  internal view returns (uint balance) {\r\n\t\treturn getClaimableBalanceFor(self, msg.sender);\r\n\t}\r\n\r\n\tfunction transfer(CSCStorage storage self, address to, uint ppm) internal {\r\n\t\trequire(getClaimableBalanceFor(self, msg.sender) == 0.0);\r\n\t\trequire(getClaimableBalanceFor(self, to) == 0.0);\r\n\t\trequire(ppm > 0);\r\n\t\t// neither user can have a pending balance to use transfer\r\n\t\tuint splitIndex = self.userSplit[msg.sender];\r\n\t\tif(splitIndex > 0 && self.splits[splitIndex].to == msg.sender && self.splits[splitIndex].ppm >= ppm) {\r\n\t\t\tself.splits[splitIndex].ppm -= ppm;\r\n\t\t\taddSplit(self, Split({to: to, ppm: ppm}));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction pay(CSCStorage storage self) internal {\r\n\t\tif(self.isClaimable) {\r\n\t\t\tself.deposits.push(msg.value);\r\n\t\t} else {\r\n\t\t\tpayAll(self);\r\n\t\t}\r\n\t}\r\n}\r\ncontract ClaimableSplitCoin {\r\n\r\n\tusing CSCLib for CSCLib.CSCStorage;\r\n\r\n\tCSCLib.CSCStorage csclib;\r\n\r\n\tfunction ClaimableSplitCoin(address[] members, uint[] ppms, address refer, bool claimable) public {\r\n\t\tcsclib.isClaimable = claimable;\r\n\t\tcsclib.dev_fee = 2500;\r\n\t\tcsclib.developer = 0xaB48Dd4b814EBcb4e358923bd719Cd5cd356eA16;\r\n\t\tcsclib.refer_fee = 250;\r\n\t\tcsclib.init(members, ppms, refer);\r\n\t}\r\n\r\n\tfunction () public payable {\r\n\t\tcsclib.pay();\r\n\t}\r\n\r\n\tfunction developer() public view returns(address) {\r\n\t\treturn csclib.developer;\r\n\t}\r\n\r\n\tfunction getSplitCount() public view returns (uint count) {\r\n\t\treturn csclib.getSplitCount();\r\n\t}\r\n\r\n\tfunction splits(uint index) public view returns (address to, uint ppm) {\r\n\t\treturn (csclib.splits[index].to, csclib.splits[index].ppm);\r\n\t}\r\n\r\n\tfunction isClaimable() public view returns (bool) {\r\n\t\treturn csclib.isClaimable;\r\n\t}\r\n\r\n\tevent SplitTransfer(address to, uint amount, uint balance);\r\n\r\n\tfunction claimFor(address user) public {\r\n\t\tcsclib.claimFor(user);\r\n\t}\r\n\r\n\tfunction claim() public {\r\n\t\tcsclib.claimFor(msg.sender);\r\n\t}\r\n\r\n\tfunction getClaimableBalanceFor(address user) public view returns (uint balance) {\r\n\t\treturn csclib.getClaimableBalanceFor(user);\r\n\t}\r\n\r\n\tfunction getClaimableBalance() public view returns (uint balance) {\r\n\t\treturn csclib.getClaimableBalanceFor(msg.sender);\r\n\t}\r\n\r\n\tfunction transfer(address to, uint ppm) public {\r\n\t\tcsclib.transfer(to, ppm);\r\n\t}\r\n}\r\ncontract SplitCoinFactory {\r\n  mapping(address => address[]) public contracts;\r\n  mapping(address => uint) public referralContracts;\r\n  mapping(address => address) public referredBy;\r\n  mapping(address => address[]) public referrals;\r\n  address[] public deployed;\r\n  event Deployed (\r\n    address _deployed\r\n  );\r\n\r\n\r\n  function make(address[] users, uint[] ppms, address refer, bool claimable) public returns (address) {\r\n    address referContract = referredBy[msg.sender];\r\n    if(refer != 0x0 && referContract == 0x0 && contracts[refer].length > 0 ) {\r\n      uint referContractIndex = referralContracts[refer] - 1;\r\n      if(referContractIndex >= 0 && refer != msg.sender) {\r\n        referContract = contracts[refer][referContractIndex];\r\n        referredBy[msg.sender] = referContract;\r\n        referrals[refer].push(msg.sender);\r\n      }\r\n    }\r\n    address sc = new ClaimableSplitCoin(users, ppms, referContract, claimable);\r\n    contracts[msg.sender].push(sc);\r\n    deployed.push(sc);\r\n    Deployed(sc);\r\n    return sc;\r\n  }\r\n\r\n  function generateReferralAddress(address refer) public returns (address) {\r\n    uint[] memory ppms = new uint[](1);\r\n    address[] memory users = new address[](1);\r\n    ppms[0] = 1000000;\r\n    users[0] = msg.sender;\r\n\r\n    address referralContract = make(users, ppms, refer, true);\r\n    if(referralContract != 0x0) {\r\n      uint index = contracts[msg.sender].length;\r\n      referralContracts[msg.sender] = index;\r\n    }\r\n    return referralContract;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"ppms\",\"type\":\"uint256[]\"},{\"name\":\"refer\",\"type\":\"address\"},{\"name\":\"claimable\",\"type\":\"bool\"}],\"name\":\"make\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deployed\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"refer\",\"type\":\"address\"}],\"name\":\"generateReferralAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referredBy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_deployed\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"}]","ContractName":"SplitCoinFactory","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dbe3255f754a4a5b98f91a9cd01b512edc376405e4a39a9ee2d25018e68f431a"}]}