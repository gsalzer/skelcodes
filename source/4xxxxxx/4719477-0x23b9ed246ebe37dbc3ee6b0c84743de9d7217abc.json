{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Restriction {\r\n    mapping (address => bool) internal accesses;\r\n\r\n    function Restriction() public {\r\n        accesses[msg.sender] = true;\r\n    }\r\n\r\n    function giveAccess(address _addr) public restricted {\r\n        accesses[_addr] = true;\r\n    }\r\n\r\n    function removeAccess(address _addr) public restricted {\r\n        delete accesses[_addr];\r\n    }\r\n\r\n    function hasAccess() public constant returns (bool) {\r\n        return accesses[msg.sender];\r\n    }\r\n\r\n    modifier restricted() {\r\n        require(hasAccess());\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DreamConstants {\r\n    uint constant MINIMAL_DREAM = 3 ether;\r\n    uint constant TICKET_PRICE = 0.1 ether;\r\n    uint constant MAX_TICKETS = 2**32;\r\n    uint constant MAX_AMOUNT = 2**32 * TICKET_PRICE;\r\n    uint constant DREAM_K = 2;\r\n    uint constant ACCURACY = 10**18;\r\n    uint constant REFUND_AFTER = 90 days;\r\n}\r\n\r\ncontract TicketHolder is Restriction, DreamConstants {\r\n    struct Ticket {\r\n        uint32 ticketAmount;\r\n        uint32 playerIndex;\r\n        uint dreamAmount;\r\n    }\r\n\r\n    uint64 public totalTickets;\r\n    uint64 public maxTickets;\r\n\r\n    mapping (address => Ticket) internal tickets;\r\n\r\n    address[] internal players;\r\n\r\n    function TicketHolder(uint _maxTickets) {\r\n        maxTickets = uint64(_maxTickets);\r\n    }\r\n\r\n    /**\r\n     * @dev Issue tickets for the specified address.\r\n     * @param _addr Receiver address.\r\n     * @param _ticketAmount Amount of tickets to issue.\r\n     * @param _dreamAmount Amount of dream or zero, if use previous.\r\n     */\r\n    function issueTickets(address _addr, uint _ticketAmount, uint _dreamAmount) public restricted {\r\n        require(_ticketAmount <= MAX_TICKETS);\r\n        require(totalTickets <= maxTickets);\r\n        Ticket storage ticket = tickets[_addr];\r\n\r\n        // if fist issue for this user\r\n        if (ticket.ticketAmount == 0) {\r\n            require(_dreamAmount >= MINIMAL_DREAM);\r\n            ticket.dreamAmount = _dreamAmount;\r\n            ticket.playerIndex = uint32(players.length);\r\n            players.push(_addr);\r\n        }\r\n\r\n\r\n        // add new ticket amount\r\n        ticket.ticketAmount += uint32(_ticketAmount);\r\n        // check to overflow\r\n        require(ticket.ticketAmount >= _ticketAmount);\r\n\r\n        // cal total\r\n        totalTickets += uint64(_ticketAmount);\r\n        // check to overflow\r\n        require(totalTickets >= _ticketAmount);\r\n    }\r\n\r\n    function setWinner(address _addr) public restricted {\r\n        Ticket storage ticket = tickets[_addr];\r\n        require(ticket.ticketAmount != 0);\r\n        ticket.ticketAmount = 0;\r\n    }\r\n\r\n    function getTickets(uint index) public constant returns (address addr, uint ticketAmount, uint dreamAmount) {\r\n        if (players.length == 0) {\r\n            return;\r\n        }\r\n        if (index > players.length - 1) {\r\n            return;\r\n        }\r\n\r\n        addr = players[index];\r\n        Ticket storage ticket = tickets[addr];\r\n        ticketAmount = ticket.ticketAmount;\r\n        dreamAmount = ticket.dreamAmount;\r\n    }\r\n\r\n    function getTicketsByAddress(address _addr) public constant returns (uint playerIndex, uint ticketAmount, uint dreamAmount) {\r\n        Ticket storage ticket = tickets[_addr];\r\n        playerIndex = ticket.playerIndex;\r\n        ticketAmount = ticket.ticketAmount;\r\n        dreamAmount = ticket.dreamAmount;\r\n    }\r\n\r\n    function getPlayersCount() public constant returns (uint) {\r\n        return players.length;\r\n    }\r\n}\r\n\r\ncontract Fund is Restriction, DreamConstants {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint) public balances;\r\n\r\n    event Pay(address receiver, uint amount);\r\n    event Refund(address receiver, uint amount);\r\n\r\n    // how many funds are collected\r\n    uint public totalAmount;\r\n    // how many funds are payed as prize\r\n    uint internal totalPrizeAmount;\r\n    // absolute refund date\r\n    uint32 internal refundDate;\r\n    // user who will receive all funds\r\n    address internal beneficiary;\r\n\r\n    function Fund(uint _absoluteRefundDate, address _beneficiary) public {\r\n        refundDate = uint32(_absoluteRefundDate);\r\n        beneficiary = _beneficiary;\r\n    }\r\n\r\n    function deposit(address _addr) public payable restricted {\r\n        uint balance = balances[_addr];\r\n\r\n        balances[_addr] = balance.add(msg.value);\r\n        totalAmount = totalAmount.add(msg.value);\r\n    }\r\n\r\n    function withdraw(uint amount) public restricted {\r\n        beneficiary.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Pay from fund to the specified address only if not payed already.\r\n     * @param _addr Address to pay.\r\n     * @param _amountWei Amount to pay.\r\n     */\r\n    function pay(address _addr, uint _amountWei) public restricted {\r\n        // we have enough funds\r\n        require(this.balance >= _amountWei);\r\n        require(balances[_addr] != 0);\r\n        delete balances[_addr];\r\n        totalPrizeAmount = totalPrizeAmount.add(_amountWei);\r\n        // send funds\r\n        _addr.transfer(_amountWei);\r\n        Pay(_addr, _amountWei);\r\n    }\r\n\r\n    /**\r\n     * @dev If funds already payed to the specified address.\r\n     * @param _addr Address to check.\r\n     */\r\n    function isPayed(address _addr) public constant returns (bool) {\r\n        return balances[_addr] == 0;\r\n    }\r\n\r\n    function enableRefund() public restricted {\r\n        require(refundDate > uint32(block.timestamp));\r\n        refundDate = uint32(block.timestamp);\r\n    }\r\n\r\n    function refund(address _addr) public restricted {\r\n        require(refundDate >= uint32(block.timestamp));\r\n        require(balances[_addr] != 0);\r\n        uint amount = refundAmount(_addr);\r\n        delete balances[_addr];\r\n        _addr.transfer(amount);\r\n        Refund(_addr, amount);\r\n    }\r\n\r\n    function refundAmount(address _addr) public constant returns (uint) {\r\n        uint balance = balances[_addr];\r\n        uint restTotal = totalAmount.sub(totalPrizeAmount);\r\n        uint share = balance.mul(ACCURACY).div(totalAmount);\r\n        return restTotal.mul(share).div(ACCURACY);\r\n    }\r\n}\r\n\r\ncontract RandomOraclizeProxyI {\r\n    function requestRandom(function (bytes32) external callback, uint _gasLimit) public payable;\r\n    function getRandomPrice(uint _gasLimit) public constant returns (uint);\r\n}\r\ncontract CompaniesManagerInterface {\r\n    function processing(address player, uint amount, uint ticketCount, uint totalTickets) public;\r\n}\r\n\r\n\r\n\r\ncontract TicketSale is Restriction, DreamConstants {\r\n    using SafeMath for uint256;\r\n    uint constant RANDOM_GAS = 1000000;\r\n\r\n    TicketHolder public ticketHolder;\r\n    Fund public fund;\r\n    RandomOraclizeProxyI private proxy;\r\n    CompaniesManagerInterface public companiesManager;\r\n    bytes32[] public randomNumbers;\r\n\r\n    uint32 public endDate;\r\n\r\n    function TicketSale(uint _endDate, address _proxy, address _beneficiary, uint _maxTickets) public {\r\n        require(_endDate > block.timestamp);\r\n        require(_beneficiary != 0);\r\n        uint refundDate = block.timestamp + REFUND_AFTER;\r\n        // end date mist be less then refund\r\n        require(_endDate < refundDate);\r\n\r\n        ticketHolder = new TicketHolder(_maxTickets);\r\n        ticketHolder.giveAccess(msg.sender);\r\n\r\n        fund = new Fund(refundDate, _beneficiary);\r\n        fund.giveAccess(msg.sender);\r\n\r\n        endDate = uint32(_endDate);\r\n        proxy = RandomOraclizeProxyI(_proxy);\r\n    }\r\n\r\n    function buyTickets(uint _dreamAmount) public payable {\r\n        buyTicketsInternal(msg.sender, msg.value, _dreamAmount);\r\n    }\r\n\r\n    function buyTicketsFor(address _addr, uint _dreamAmount) public payable {\r\n        buyTicketsInternal(_addr, msg.value, _dreamAmount);\r\n    }\r\n\r\n    function buyTicketsInternal(address _addr, uint _valueWei, uint _dreamAmount) internal notEnded {\r\n        require(_valueWei >= TICKET_PRICE);\r\n        require(checkDream(_dreamAmount));\r\n\r\n        uint change = _valueWei % TICKET_PRICE;\r\n        uint weiAmount = _valueWei - change;\r\n        uint ticketCount = weiAmount.div(TICKET_PRICE);\r\n\r\n        if (address(companiesManager) != 0) {\r\n            uint totalTickets = ticketHolder.totalTickets();\r\n            companiesManager.processing(_addr, weiAmount, ticketCount, totalTickets);\r\n        }\r\n\r\n        // issue right amount of tickets\r\n        ticketHolder.issueTickets(_addr, ticketCount, _dreamAmount);\r\n\r\n        // transfer to fund\r\n        fund.deposit.value(weiAmount)(_addr);\r\n\r\n        // return change\r\n        if (change != 0) {\r\n            msg.sender.transfer(change);\r\n        }\r\n    }\r\n\r\n    // server integration methods\r\n\r\n    function refund() public {\r\n        fund.refund(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Send funds to player by index. In case server calculate all.\r\n     * @param _playerIndex The winner player index.\r\n     * @param _amountWei Amount of prize in wei.\r\n     */\r\n    function payout(uint _playerIndex, uint _amountWei) public restricted ended {\r\n        address playerAddress;\r\n        uint ticketAmount;\r\n        uint dreamAmount;\r\n        (playerAddress, ticketAmount, dreamAmount) = ticketHolder.getTickets(_playerIndex);\r\n        require(playerAddress != 0);\r\n\r\n        // pay the player's dream\r\n        fund.pay(playerAddress, _amountWei);\r\n    }\r\n\r\n    /**\r\n     * @dev If funds already payed to the specified player by index.\r\n     * @param _playerIndex Player index.\r\n     */\r\n    function isPayed(uint _playerIndex) public constant returns (bool) {\r\n        address playerAddress;\r\n        uint ticketAmount;\r\n        uint dreamAmount;\r\n        (playerAddress, ticketAmount, dreamAmount) = ticketHolder.getTickets(_playerIndex);\r\n        require(playerAddress != 0);\r\n        return fund.isPayed(playerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Server method. Finish lottery (force finish if required), enable refund.\r\n     */\r\n    function finish() public restricted {\r\n        // force end\r\n        if (endDate > uint32(block.timestamp)) {\r\n            endDate = uint32(block.timestamp);\r\n        }\r\n    }\r\n\r\n    // random integration\r\n    function requestRandom() public payable restricted {\r\n        uint price = proxy.getRandomPrice(RANDOM_GAS);\r\n        require(msg.value >= price);\r\n        uint change = msg.value - price;\r\n        proxy.requestRandom.value(price)(this.random_callback, RANDOM_GAS);\r\n        if (change > 0) {\r\n            msg.sender.transfer(change);\r\n        }\r\n    }\r\n\r\n    function random_callback(bytes32 _randomNumbers) external {\r\n        require(msg.sender == address(proxy));\r\n        randomNumbers.push(_randomNumbers);\r\n    }\r\n\r\n    // companies integration\r\n    function setCompanyManager(address _addr) public restricted {\r\n        companiesManager = CompaniesManagerInterface(_addr);\r\n    }\r\n\r\n    // constant methods\r\n    function isEnded() public constant returns (bool) {\r\n        return block.timestamp > endDate;\r\n    }\r\n\r\n    function checkDream(uint _dreamAmount) internal constant returns (bool) {\r\n        return\r\n            _dreamAmount == 0 ||\r\n            _dreamAmount == 3 ether ||\r\n            _dreamAmount == 5 ether ||\r\n            _dreamAmount == 7 ether ||\r\n            _dreamAmount == 10 ether ||\r\n            _dreamAmount == 15 ether ||\r\n            _dreamAmount == 20 ether ||\r\n            _dreamAmount == 30 ether ||\r\n            _dreamAmount == 40 ether ||\r\n            _dreamAmount == 50 ether ||\r\n            _dreamAmount == 75 ether ||\r\n            _dreamAmount == 100 ether ||\r\n            _dreamAmount == 150 ether ||\r\n            _dreamAmount == 200 ether ||\r\n            _dreamAmount == 300 ether ||\r\n            _dreamAmount == 400 ether ||\r\n            _dreamAmount == 500 ether ||\r\n            _dreamAmount == 750 ether ||\r\n            _dreamAmount == 1000 ether ||\r\n            _dreamAmount == 1500 ether ||\r\n            _dreamAmount == 2000 ether ||\r\n            _dreamAmount == 2500 ether;\r\n    }\r\n\r\n    modifier notEnded() {\r\n        require(!isEnded());\r\n        _;\r\n    }\r\n\r\n    modifier ended() {\r\n        require(isEnded());\r\n        _;\r\n    }\r\n\r\n    function randomCount() public constant returns (uint) {\r\n        return randomNumbers.length;\r\n    }\r\n\r\n    function getRandomPrice() public constant returns (uint) {\r\n        return proxy.getRandomPrice(RANDOM_GAS);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isPayed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasAccess\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"refundAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_amountWei\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"giveAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_absoluteRefundDate\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Pay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"Fund","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005AA65D3E000000000000000000000000b42bebff7a077358da8ba3035faf989552d7ad44","Library":"","SwarmSource":"bzzr://8b80d8879600561ff43e453cfc02ad0e063a7e8bff3a8dfc80cf3b6489b77344"}]}