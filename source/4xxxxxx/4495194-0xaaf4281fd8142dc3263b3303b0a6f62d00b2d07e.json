{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/**\r\n * @title IWingsAdapter\r\n * \r\n * WINGS DAO Price Discovery & Promotion Pre-Beta https://www.wings.ai\r\n *\r\n * #created 04/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IWingsAdapter {\r\n\r\n\r\n    /**\r\n     * Get the total raised amount of Ether\r\n     *\r\n     * Can only increase, meaning if you withdraw ETH from the wallet, it should be not modified (you can use two fields \r\n     * to keep one with a total accumulated amount) amount of ETH in contract and totalCollected for total amount of ETH collected\r\n     *\r\n     * @return Total raised Ether amount\r\n     */\r\n    function totalCollected() constant returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title IWhitelist \r\n *\r\n * Whitelist authentication interface\r\n *\r\n * #created 04/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IWhitelist {\r\n    \r\n\r\n    /**\r\n     * Authenticate \r\n     *\r\n     * Returns whether `_account` is on the whitelist\r\n     *\r\n     * @param _account The account to authenticate\r\n     * @return whether `_account` is successfully authenticated\r\n     */\r\n    function authenticate(address _account) constant returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title Token retrieve interface\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITokenRetreiver {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retreiveTokens(address _tokenContract);\r\n}\r\n\r\n\r\ncontract Owned {\r\n\r\n    // The address of the account that is the current owner \r\n    address internal owner;\r\n\r\n\r\n    /**\r\n     * The publisher is the inital owner\r\n     */\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * Access is restricted to the current owner\r\n     */\r\n    modifier only_owner() {\r\n        require(msg.sender == owner);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 compatible token interface\r\n *\r\n * Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\n * - Short address attack fix\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IToken { \r\n\r\n    /** \r\n     * Get the total supply of tokens\r\n     * \r\n     * @return The total supply\r\n     */\r\n    function totalSupply() constant returns (uint);\r\n\r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title ManagedToken interface\r\n *\r\n * Adds the following functionallity to the basic ERC20 token\r\n * - Locking\r\n * - Issuing\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IManagedToken is IToken { \r\n\r\n    /** \r\n     * Returns true if the token is locked\r\n     * \r\n     * @return Whether the token is locked\r\n     */\r\n    function isLocked() constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Unlocks the token so that the transferring of value is enabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function unlock() returns (bool);\r\n\r\n\r\n    /**\r\n     * Issues `_value` new tokens to `_to`\r\n     *\r\n     * @param _to The address to which the tokens will be issued\r\n     * @param _value The amount of new tokens to issue\r\n     * @return Whether the tokens where sucessfully issued or not\r\n     */\r\n    function issue(address _to, uint _value) returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title ICrowdsale\r\n *\r\n * Base crowdsale interface to manage the sale of \r\n * an ERC20 token\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ICrowdsale {\r\n\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the presale phase\r\n     *\r\n     * @return True if in presale phase\r\n     */\r\n    function isInPresalePhase() constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns true if `_beneficiary` has a balance allocated\r\n     *\r\n     * @param _beneficiary The account that the balance is allocated for\r\n     * @param _releaseDate The date after which the balance can be withdrawn\r\n     * @return True if there is a balance that belongs to `_beneficiary`\r\n     */\r\n    function hasBalance(address _beneficiary, uint _releaseDate) constant returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the allocated token balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated token balance will be retrieved\r\n     * @return The allocated token balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint);\r\n\r\n\r\n    /** \r\n     * Get the allocated eth balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated eth balance will be retrieved\r\n     * @return The allocated eth balance\r\n     */\r\n    function ethBalanceOf(address _owner) constant returns (uint);\r\n\r\n\r\n    /** \r\n     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\r\n     * \r\n     * @param _owner The address from which the refundable balance will be retrieved\r\n     * @return The invested refundable balance\r\n     */\r\n    function refundableEthBalanceOf(address _owner) constant returns (uint);\r\n\r\n\r\n    /**\r\n     * Returns the rate and bonus release date\r\n     *\r\n     * @param _phase The phase to use while determining the rate\r\n     * @param _volume The amount wei used to determine what volume multiplier to use\r\n     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\r\n     */\r\n    function getRate(uint _phase, uint _volume) constant returns (uint);\r\n\r\n\r\n    /**\r\n     * Convert `_wei` to an amount in tokens using \r\n     * the `_rate`\r\n     *\r\n     * @param _wei amount of wei to convert\r\n     * @param _rate rate to use for the conversion\r\n     * @return Amount in tokens\r\n     */\r\n    function toTokens(uint _wei, uint _rate) constant returns (uint);\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     */\r\n    function withdrawTokens();\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     */\r\n    function withdrawEther();\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     */\r\n    function refund();\r\n\r\n\r\n    /**\r\n     * Receive Eth and issue tokens to the sender\r\n     */\r\n    function () payable;\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n *\r\n * Abstract base crowdsale contract that manages the sale of \r\n * an ERC20 token\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract Crowdsale is ICrowdsale, Owned {\r\n\r\n    enum Stages {\r\n        Deploying,\r\n        Deployed,\r\n        InProgress,\r\n        Ended\r\n    }\r\n\r\n    struct Balance {\r\n        uint eth;\r\n        uint tokens;\r\n        uint index;\r\n    }\r\n\r\n    struct Percentage {\r\n        uint eth;\r\n        uint tokens;\r\n        bool overwriteReleaseDate;\r\n        uint fixedReleaseDate;\r\n        uint index; \r\n    }\r\n\r\n    struct Payout {\r\n        uint percentage;\r\n        uint vestingPeriod;\r\n    }\r\n\r\n    struct Phase {\r\n        uint rate;\r\n        uint end;\r\n        uint bonusReleaseDate;\r\n        bool useVolumeMultiplier;\r\n    }\r\n\r\n    struct VolumeMultiplier {\r\n        uint rateMultiplier;\r\n        uint bonusReleaseDateMultiplier;\r\n    }\r\n\r\n    // Crowdsale details\r\n    uint public baseRate;\r\n    uint public minAmount; \r\n    uint public maxAmount; \r\n    uint public minAcceptedAmount;\r\n    uint public minAmountPresale; \r\n    uint public maxAmountPresale;\r\n    uint public minAcceptedAmountPresale;\r\n\r\n    // Company address\r\n    address public beneficiary; \r\n\r\n    // Denominators\r\n    uint internal percentageDenominator;\r\n    uint internal tokenDenominator;\r\n\r\n    // Crowdsale state\r\n    uint public start;\r\n    uint public presaleEnd;\r\n    uint public crowdsaleEnd;\r\n    uint public raised;\r\n    uint public allocatedEth;\r\n    uint public allocatedTokens;\r\n    Stages public stage;\r\n\r\n    // Token contract\r\n    IManagedToken public token;\r\n\r\n    // Invested balances\r\n    mapping (address => uint) private balances;\r\n\r\n    // Alocated balances\r\n    mapping (address => mapping(uint => Balance)) private allocated;\r\n    mapping(address => uint[]) private allocatedIndex;\r\n\r\n    // Stakeholders\r\n    mapping (address => Percentage) private stakeholderPercentages;\r\n    address[] private stakeholderPercentagesIndex;\r\n    Payout[] private stakeholdersPayouts;\r\n\r\n    // Crowdsale phases\r\n    Phase[] private phases;\r\n\r\n    // Volume multipliers\r\n    mapping (uint => VolumeMultiplier) private volumeMultipliers;\r\n    uint[] private volumeMultiplierThresholds;\r\n\r\n    \r\n    /**\r\n     * Throw if at stage other than current stage\r\n     * \r\n     * @param _stage expected stage to test for\r\n     */\r\n    modifier at_stage(Stages _stage) {\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Only after crowdsaleEnd plus `_time`\r\n     * \r\n     * @param _time Time to pass\r\n     */\r\n    modifier only_after(uint _time) {\r\n        require(now > crowdsaleEnd + _time);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Only after crowdsale\r\n     */\r\n    modifier only_after_crowdsale() {\r\n        require(now > crowdsaleEnd);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Throw if sender is not beneficiary\r\n     */\r\n    modifier only_beneficiary() {\r\n        require(beneficiary == msg.sender);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Start in the deployed stage\r\n     */\r\n    function Crowdsale() {\r\n        stage = Stages.Deploying;\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup the crowdsale\r\n     *\r\n     * @param _start The timestamp of the start date\r\n     * @param _token The token that is sold\r\n     * @param _tokenDenominator The token amount of decimals that the token uses\r\n     * @param _percentageDenominator The percision of percentages\r\n     * @param _minAmount The min cap for the ICO\r\n     * @param _maxAmount The max cap for the ICO\r\n     * @param _minAcceptedAmount The lowest accepted amount during the ICO phase\r\n     * @param _minAmountPresale The min cap for the presale\r\n     * @param _maxAmountPresale The max cap for the presale\r\n     * @param _minAcceptedAmountPresale The lowest accepted amount during the presale phase\r\n     */\r\n    function setup(uint _start, address _token, uint _tokenDenominator, uint _percentageDenominator, uint _minAmount, uint _maxAmount, uint _minAcceptedAmount, uint _minAmountPresale, uint _maxAmountPresale, uint _minAcceptedAmountPresale) public only_owner at_stage(Stages.Deploying) {\r\n        token = IManagedToken(_token);\r\n        tokenDenominator = _tokenDenominator;\r\n        percentageDenominator = _percentageDenominator;\r\n        start = _start;\r\n        minAmount = _minAmount;\r\n        maxAmount = _maxAmount;\r\n        minAcceptedAmount = _minAcceptedAmount;\r\n        minAmountPresale = _minAmountPresale;\r\n        maxAmountPresale = _maxAmountPresale;\r\n        minAcceptedAmountPresale = _minAcceptedAmountPresale;\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup rates and phases\r\n     *\r\n     * @param _baseRate The rate without bonus\r\n     * @param _phaseRates The rates for each phase\r\n     * @param _phasePeriods The periods that each phase lasts (first phase is the presale phase)\r\n     * @param _phaseBonusLockupPeriods The lockup period that each phase lasts\r\n     * @param _phaseUsesVolumeMultiplier Wheter or not volume bonusses are used in the respective phase\r\n     */\r\n    function setupPhases(uint _baseRate, uint[] _phaseRates, uint[] _phasePeriods, uint[] _phaseBonusLockupPeriods, bool[] _phaseUsesVolumeMultiplier) public only_owner at_stage(Stages.Deploying) {\r\n        baseRate = _baseRate;\r\n        presaleEnd = start + _phasePeriods[0]; // First phase is expected to be the presale phase\r\n        crowdsaleEnd = start; // Plus the sum of the rate phases\r\n\r\n        for (uint i = 0; i < _phaseRates.length; i++) {\r\n            crowdsaleEnd += _phasePeriods[i];\r\n            phases.push(Phase(_phaseRates[i], crowdsaleEnd, 0, _phaseUsesVolumeMultiplier[i]));\r\n        }\r\n\r\n        for (uint ii = 0; ii < _phaseRates.length; ii++) {\r\n            if (_phaseBonusLockupPeriods[ii] > 0) {\r\n                phases[ii].bonusReleaseDate = crowdsaleEnd + _phaseBonusLockupPeriods[ii];\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup stakeholders\r\n     *\r\n     * @param _stakeholders The addresses of the stakeholders (first stakeholder is the beneficiary)\r\n     * @param _stakeholderEthPercentages The eth percentages of the stakeholders\r\n     * @param _stakeholderTokenPercentages The token percentages of the stakeholders\r\n     * @param _stakeholderTokenPayoutOverwriteReleaseDates Wheter the vesting period is overwritten for the respective stakeholder\r\n     * @param _stakeholderTokenPayoutFixedReleaseDates The vesting period after which the whole percentage of the tokens is released to the respective stakeholder\r\n     * @param _stakeholderTokenPayoutPercentages The percentage of the tokens that is released at the respective date\r\n     * @param _stakeholderTokenPayoutVestingPeriods The vesting period after which the respective percentage of the tokens is released\r\n     */\r\n    function setupStakeholders(address[] _stakeholders, uint[] _stakeholderEthPercentages, uint[] _stakeholderTokenPercentages, bool[] _stakeholderTokenPayoutOverwriteReleaseDates, uint[] _stakeholderTokenPayoutFixedReleaseDates, uint[] _stakeholderTokenPayoutPercentages, uint[] _stakeholderTokenPayoutVestingPeriods) public only_owner at_stage(Stages.Deploying) {\r\n        beneficiary = _stakeholders[0]; // First stakeholder is expected to be the beneficiary\r\n        for (uint i = 0; i < _stakeholders.length; i++) {\r\n            stakeholderPercentagesIndex.push(_stakeholders[i]);\r\n            stakeholderPercentages[_stakeholders[i]] = Percentage(\r\n                _stakeholderEthPercentages[i], \r\n                _stakeholderTokenPercentages[i], \r\n                _stakeholderTokenPayoutOverwriteReleaseDates[i],\r\n                _stakeholderTokenPayoutFixedReleaseDates[i], i);\r\n        }\r\n\r\n        // Percentages add up to 100\r\n        for (uint ii = 0; ii < _stakeholderTokenPayoutPercentages.length; ii++) {\r\n            stakeholdersPayouts.push(Payout(_stakeholderTokenPayoutPercentages[ii], _stakeholderTokenPayoutVestingPeriods[ii]));\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * Setup volume multipliers\r\n     *\r\n     * @param _volumeMultiplierRates The rates will be multiplied by this value (denominated by 4)\r\n     * @param _volumeMultiplierLockupPeriods The lockup periods will be multiplied by this value (denominated by 4)\r\n     * @param _volumeMultiplierThresholds The volume thresholds for each respective multiplier\r\n     */\r\n    function setupVolumeMultipliers(uint[] _volumeMultiplierRates, uint[] _volumeMultiplierLockupPeriods, uint[] _volumeMultiplierThresholds) public only_owner at_stage(Stages.Deploying) {\r\n        require(phases.length > 0);\r\n        volumeMultiplierThresholds = _volumeMultiplierThresholds;\r\n        for (uint i = 0; i < volumeMultiplierThresholds.length; i++) {\r\n            volumeMultipliers[volumeMultiplierThresholds[i]] = VolumeMultiplier(_volumeMultiplierRates[i], _volumeMultiplierLockupPeriods[i]);\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * After calling the deploy function the crowdsale\r\n     * rules become immutable \r\n     */\r\n    function deploy() public only_owner at_stage(Stages.Deploying) {\r\n        require(phases.length > 0);\r\n        require(stakeholderPercentagesIndex.length > 0);\r\n        stage = Stages.Deployed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Prove that beneficiary is able to sign transactions \r\n     * and start the crowdsale\r\n     */\r\n    function confirmBeneficiary() public only_beneficiary at_stage(Stages.Deployed) {\r\n        stage = Stages.InProgress;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the presale phase\r\n     *\r\n     * @return True if in presale phase\r\n     */\r\n    function isInPresalePhase() public constant returns (bool) {\r\n        return stage == Stages.InProgress && now >= start && now <= presaleEnd;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_beneficiary` has a balance allocated\r\n     *\r\n     * @param _beneficiary The account that the balance is allocated for\r\n     * @param _releaseDate The date after which the balance can be withdrawn\r\n     * @return True if there is a balance that belongs to `_beneficiary`\r\n     */\r\n    function hasBalance(address _beneficiary, uint _releaseDate) public constant returns (bool) {\r\n        return allocatedIndex[_beneficiary].length > 0 && _releaseDate == allocatedIndex[_beneficiary][allocated[_beneficiary][_releaseDate].index];\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the allocated token balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated token balance will be retrieved\r\n     * @return The allocated token balance\r\n     */\r\n    function balanceOf(address _owner) public constant returns (uint) {\r\n        uint sum = 0;\r\n        for (uint i = 0; i < allocatedIndex[_owner].length; i++) {\r\n            sum += allocated[_owner][allocatedIndex[_owner][i]].tokens;\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the allocated eth balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated eth balance will be retrieved\r\n     * @return The allocated eth balance\r\n     */\r\n    function ethBalanceOf(address _owner) public constant returns (uint) {\r\n        uint sum = 0;\r\n        for (uint i = 0; i < allocatedIndex[_owner].length; i++) {\r\n            sum += allocated[_owner][allocatedIndex[_owner][i]].eth;\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n\r\n    /** \r\n     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\r\n     * \r\n     * @param _owner The address from which the refundable balance will be retrieved\r\n     * @return The invested refundable balance\r\n     */\r\n    function refundableEthBalanceOf(address _owner) public constant returns (uint) {\r\n        return now > crowdsaleEnd && raised < minAmount ? balances[_owner] : 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the current phase based on the current time\r\n     *\r\n     * @return The index of the current phase\r\n     */\r\n    function getCurrentPhase() public constant returns (uint) {\r\n        for (uint i = 0; i < phases.length; i++) {\r\n            if (now <= phases[i].end) {\r\n                return i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return phases.length; // Does not exist\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the rate and bonus release date\r\n     *\r\n     * @param _phase The phase to use while determining the rate\r\n     * @param _volume The amount wei used to determin what volume multiplier to use\r\n     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\r\n     */\r\n    function getRate(uint _phase, uint _volume) public constant returns (uint) {\r\n        uint rate = 0;\r\n        if (stage == Stages.InProgress && now >= start) {\r\n            Phase storage phase = phases[_phase];\r\n            rate = phase.rate;\r\n\r\n            // Find volume multiplier\r\n            if (phase.useVolumeMultiplier && volumeMultiplierThresholds.length > 0 && _volume >= volumeMultiplierThresholds[0]) {\r\n                for (uint i = volumeMultiplierThresholds.length; i > 0; i--) {\r\n                    if (_volume >= volumeMultiplierThresholds[i - 1]) {\r\n                        VolumeMultiplier storage multiplier = volumeMultipliers[volumeMultiplierThresholds[i - 1]];\r\n                        rate += phase.rate * multiplier.rateMultiplier / percentageDenominator;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return rate;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get distribution data based on the current phase and \r\n     * the volume in wei that is being distributed\r\n     * \r\n     * @param _phase The current crowdsale phase\r\n     * @param _volume The amount wei used to determine what volume multiplier to use\r\n     * @return Volumes and corresponding release dates\r\n     */\r\n    function getDistributionData(uint _phase, uint _volume) internal constant returns (uint[], uint[]) {\r\n        Phase storage phase = phases[_phase];\r\n        uint remainingVolume = _volume;\r\n\r\n        bool usingMultiplier = false;\r\n        uint[] memory volumes = new uint[](1);\r\n        uint[] memory releaseDates = new uint[](1);\r\n\r\n        // Find volume multipliers\r\n        if (phase.useVolumeMultiplier && volumeMultiplierThresholds.length > 0 && _volume >= volumeMultiplierThresholds[0]) {\r\n            uint phaseReleasePeriod = phase.bonusReleaseDate - crowdsaleEnd;\r\n            for (uint i = volumeMultiplierThresholds.length; i > 0; i--) {\r\n                if (_volume >= volumeMultiplierThresholds[i - 1]) {\r\n                    if (!usingMultiplier) {\r\n                        volumes = new uint[](i + 1);\r\n                        releaseDates = new uint[](i + 1);\r\n                        usingMultiplier = true;\r\n                    }\r\n\r\n                    VolumeMultiplier storage multiplier = volumeMultipliers[volumeMultiplierThresholds[i - 1]];\r\n                    uint releaseDate = phase.bonusReleaseDate + phaseReleasePeriod * multiplier.bonusReleaseDateMultiplier / percentageDenominator;\r\n                    uint volume = remainingVolume - volumeMultiplierThresholds[i - 1];\r\n\r\n                    // Store increment\r\n                    volumes[i] = volume;\r\n                    releaseDates[i] = releaseDate;\r\n\r\n                    remainingVolume -= volume;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store increment\r\n        volumes[0] = remainingVolume;\r\n        releaseDates[0] = phase.bonusReleaseDate;\r\n\r\n        return (volumes, releaseDates);\r\n    }\r\n\r\n\r\n    /**\r\n     * Convert `_wei` to an amount in tokens using \r\n     * the `_rate`\r\n     *\r\n     * @param _wei amount of wei to convert\r\n     * @param _rate rate to use for the conversion\r\n     * @return Amount in tokens\r\n     */\r\n    function toTokens(uint _wei, uint _rate) public constant returns (uint) {\r\n        return _wei * _rate * tokenDenominator / 1 ether;\r\n    }\r\n\r\n\r\n    /**\r\n     * Function to end the crowdsale by setting \r\n     * the stage to Ended\r\n     */\r\n    function endCrowdsale() public at_stage(Stages.InProgress) {\r\n        require(now > crowdsaleEnd || raised >= maxAmount);\r\n        require(raised >= minAmount);\r\n        stage = Stages.Ended;\r\n\r\n        // Unlock token\r\n        if (!token.unlock()) {\r\n            revert();\r\n        }\r\n\r\n        // Allocate tokens (no allocation can be done after this period)\r\n        uint totalTokenSupply = token.totalSupply() + allocatedTokens;\r\n        for (uint i = 0; i < stakeholdersPayouts.length; i++) {\r\n            Payout storage p = stakeholdersPayouts[i];\r\n            _allocateStakeholdersTokens(totalTokenSupply * p.percentage / percentageDenominator, now + p.vestingPeriod);\r\n        }\r\n\r\n        // Allocate remaining ETH\r\n        _allocateStakeholdersEth(this.balance - allocatedEth, 0);\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     */\r\n    function withdrawTokens() public {\r\n        uint tokensToSend = 0;\r\n        for (uint i = 0; i < allocatedIndex[msg.sender].length; i++) {\r\n            uint releaseDate = allocatedIndex[msg.sender][i];\r\n            if (releaseDate <= now) {\r\n                Balance storage b = allocated[msg.sender][releaseDate];\r\n                tokensToSend += b.tokens;\r\n                b.tokens = 0;\r\n            }\r\n        }\r\n\r\n        if (tokensToSend > 0) {\r\n            allocatedTokens -= tokensToSend;\r\n            if (!token.issue(msg.sender, tokensToSend)) {\r\n                revert();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     */\r\n    function withdrawEther() public {\r\n        uint ethToSend = 0;\r\n        for (uint i = 0; i < allocatedIndex[msg.sender].length; i++) {\r\n            uint releaseDate = allocatedIndex[msg.sender][i];\r\n            if (releaseDate <= now) {\r\n                Balance storage b = allocated[msg.sender][releaseDate];\r\n                ethToSend += b.eth;\r\n                b.eth = 0;\r\n            }\r\n        }\r\n\r\n        if (ethToSend > 0) {\r\n            allocatedEth -= ethToSend;\r\n            if (!msg.sender.send(ethToSend)) {\r\n                revert();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     */\r\n    function refund() public only_after_crowdsale at_stage(Stages.InProgress) {\r\n        require(raised < minAmount);\r\n\r\n        uint receivedAmount = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n\r\n        if (receivedAmount > 0 && !msg.sender.send(receivedAmount)) {\r\n            balances[msg.sender] = receivedAmount;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe and clean-up mechanism\r\n     */\r\n    function destroy() public only_beneficiary only_after(2 years) {\r\n        selfdestruct(beneficiary);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive Eth and issue tokens to the sender\r\n     */\r\n    function contribute() public payable {\r\n        _handleTransaction(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive Eth and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () payable {\r\n        require(msg.sender == tx.origin);\r\n        _handleTransaction(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Handle incoming transactions\r\n     * \r\n     * @param _sender Transaction sender\r\n     * @param _received \r\n     */\r\n    function _handleTransaction(address _sender, uint _received) internal at_stage(Stages.InProgress) {\r\n\r\n        // Crowdsale is active\r\n        require(now >= start && now <= crowdsaleEnd);\r\n\r\n        // Whitelist check\r\n        require(isAcceptedContributor(_sender));\r\n\r\n        // When in presale phase\r\n        bool presalePhase = isInPresalePhase();\r\n        require(!presalePhase || _received >= minAcceptedAmountPresale);\r\n        require(!presalePhase || raised < maxAmountPresale);\r\n\r\n        // When in ico phase\r\n        require(presalePhase || _received >= minAcceptedAmount);\r\n        require(presalePhase || raised >= minAmountPresale);\r\n        require(presalePhase || raised < maxAmount);\r\n\r\n        uint acceptedAmount;\r\n        if (presalePhase && raised + _received > maxAmountPresale) {\r\n            acceptedAmount = maxAmountPresale - raised;\r\n        } else if (raised + _received > maxAmount) {\r\n            acceptedAmount = maxAmount - raised;\r\n        } else {\r\n            acceptedAmount = _received;\r\n        }\r\n\r\n        raised += acceptedAmount;\r\n        \r\n        if (presalePhase) {\r\n            // During the presale phase - Non refundable\r\n            _allocateStakeholdersEth(acceptedAmount, 0); \r\n        } else {\r\n            // During the ICO phase - 100% refundable\r\n            balances[_sender] += acceptedAmount; \r\n        }\r\n\r\n        // Distribute tokens\r\n        uint tokensToIssue = 0;\r\n        uint phase = getCurrentPhase();\r\n        var rate = getRate(phase, acceptedAmount);\r\n        if (rate == 0) {\r\n            revert(); // Paused phase\r\n        }\r\n\r\n        var (volumes, releaseDates) = getDistributionData(\r\n            phase, acceptedAmount);\r\n        \r\n        // Allocate tokens\r\n        for (uint i = 0; i < volumes.length; i++) {\r\n            var tokensAtCurrentRate = toTokens(volumes[i], rate);\r\n            if (rate > baseRate && releaseDates[i] > now) {\r\n                uint bonusTokens = tokensAtCurrentRate * (rate - baseRate) / rate;\r\n                _allocateTokens(_sender, bonusTokens, releaseDates[i]);\r\n\r\n                tokensToIssue += tokensAtCurrentRate - bonusTokens;\r\n            } else {\r\n                tokensToIssue += tokensAtCurrentRate;\r\n            }\r\n        }\r\n\r\n        // Issue tokens\r\n        if (tokensToIssue > 0 && !token.issue(_sender, tokensToIssue)) {\r\n            revert();\r\n        }\r\n\r\n        // Refund due to max cap hit\r\n        if (_received - acceptedAmount > 0 && !_sender.send(_received - acceptedAmount)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Allocate ETH\r\n     *\r\n     * @param _beneficiary The account to alocate the eth for\r\n     * @param _amount The amount of ETH to allocate\r\n     * @param _releaseDate The date after which the eth can be withdrawn\r\n     */    \r\n    function _allocateEth(address _beneficiary, uint _amount, uint _releaseDate) internal {\r\n        if (hasBalance(_beneficiary, _releaseDate)) {\r\n            allocated[_beneficiary][_releaseDate].eth += _amount;\r\n        } else {\r\n            allocated[_beneficiary][_releaseDate] = Balance(\r\n                _amount, 0, allocatedIndex[_beneficiary].push(_releaseDate) - 1);\r\n        }\r\n\r\n        allocatedEth += _amount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allocate Tokens\r\n     *\r\n     * @param _beneficiary The account to allocate the tokens for\r\n     * @param _amount The amount of tokens to allocate\r\n     * @param _releaseDate The date after which the tokens can be withdrawn\r\n     */    \r\n    function _allocateTokens(address _beneficiary, uint _amount, uint _releaseDate) internal {\r\n        if (hasBalance(_beneficiary, _releaseDate)) {\r\n            allocated[_beneficiary][_releaseDate].tokens += _amount;\r\n        } else {\r\n            allocated[_beneficiary][_releaseDate] = Balance(\r\n                0, _amount, allocatedIndex[_beneficiary].push(_releaseDate) - 1);\r\n        }\r\n\r\n        allocatedTokens += _amount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allocate ETH for stakeholders\r\n     *\r\n     * @param _amount The amount of ETH to allocate\r\n     * @param _releaseDate The date after which the eth can be withdrawn\r\n     */    \r\n    function _allocateStakeholdersEth(uint _amount, uint _releaseDate) internal {\r\n        for (uint i = 0; i < stakeholderPercentagesIndex.length; i++) {\r\n            Percentage storage p = stakeholderPercentages[stakeholderPercentagesIndex[i]];\r\n            if (p.eth > 0) {\r\n                _allocateEth(stakeholderPercentagesIndex[i], _amount * p.eth / percentageDenominator, _releaseDate);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Allocate Tokens for stakeholders\r\n     *\r\n     * @param _amount The amount of tokens created\r\n     * @param _releaseDate The date after which the tokens can be withdrawn (unless overwitten)\r\n     */    \r\n    function _allocateStakeholdersTokens(uint _amount, uint _releaseDate) internal {\r\n        for (uint i = 0; i < stakeholderPercentagesIndex.length; i++) {\r\n            Percentage storage p = stakeholderPercentages[stakeholderPercentagesIndex[i]];\r\n            if (p.tokens > 0) {\r\n                _allocateTokens(\r\n                    stakeholderPercentagesIndex[i], \r\n                    _amount * p.tokens / percentageDenominator, \r\n                    p.overwriteReleaseDate ? p.fixedReleaseDate : _releaseDate);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows the implementing contract to validate a \r\n     * contributing account\r\n     *\r\n     * @param _contributor Address that is being validated\r\n     * @return Wheter the contributor is accepted or not\r\n     */\r\n    function isAcceptedContributor(address _contributor) internal constant returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title GLACrowdsale\r\n *\r\n * Gladius is the decentralized solution to protect against DDoS attacks by allowing you to connect \r\n * with protection pools near you to provide better protection and accelerate your content. With an easy \r\n * to use interface as well as powerful insight tools, Gladius enables anyone to protect and accelerate \r\n * their website. Visit https://gladius.io/ \r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract GLACrowdsale is Crowdsale, ITokenRetreiver, IWingsAdapter {\r\n\r\n    // Whitelist used for authentication\r\n    IWhitelist private whitelist;\r\n\r\n    // Presale\r\n    bool private presaleAttached;\r\n    IToken private presaleToken;\r\n    ICrowdsale private presale;\r\n    mapping(address => bool) private presaleConversions;\r\n\r\n\r\n    /**\r\n     * Setup the whitelist\r\n     *\r\n     * @param _whitelist The address of the whitelist authenticator\r\n     */\r\n    function setupWhitelist(address _whitelist) public only_owner at_stage(Stages.Deploying) {\r\n        whitelist = IWhitelist(_whitelist);\r\n    }\r\n\r\n\r\n    /**\r\n     * Wings integration - Get the total raised amount of Ether\r\n     *\r\n     * Can only increased, means if you withdraw ETH from the wallet, should be not modified (you can use two fields \r\n     * to keep one with a total accumulated amount) amount of ETH in contract and totalCollected for total amount of ETH collected\r\n     *\r\n     * @return Total raised Ether amount\r\n     */\r\n    function totalCollected() public constant returns (uint) {\r\n        return raised;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows the implementing contract to validate a \r\n     * contributing account\r\n     *\r\n     * @param _contributor Address that is being validated\r\n     * @return Wheter the contributor is accepted or not\r\n     */\r\n    function isAcceptedContributor(address _contributor) internal constant returns (bool) {\r\n        return whitelist.authenticate(_contributor);\r\n    }\r\n\r\n\r\n    /**\r\n     * Attach the presale contracts\r\n     *\r\n     * @param _presale The address of the private presale contract\r\n     * @param _presaleToken The token used in the private presale \r\n     */\r\n    function attachPresale(address _presale, address _presaleToken) public only_owner at_stage(Stages.Deploying) {\r\n        presaleToken = IToken(_presaleToken);\r\n        presale = ICrowdsale(_presale);\r\n        presaleAttached = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allow investors that contributed in the private presale \r\n     * to generate the same amount of tokens in the actual crowdsale\r\n     *\r\n     * @param _contributor Account that contributed in the presale\r\n     */\r\n    function importPresaleContribution(address _contributor) public {\r\n        require(presaleAttached);\r\n        require(!presaleConversions[_contributor]);\r\n        presaleConversions[_contributor] = true;\r\n\r\n        // Read amounts from private presale\r\n        uint distributedPresaleTokens = presaleToken.balanceOf(_contributor);\r\n\r\n        // If this is zero _contributor did not contribute anything\r\n        require(distributedPresaleTokens > 0);\r\n        \r\n        // Allocate tokens\r\n        uint allocatedPresaleTokens = presale.balanceOf(_contributor);\r\n        _allocateTokens(_contributor, allocatedPresaleTokens, crowdsaleEnd + 30 days);\r\n\r\n        // Issue tokens\r\n        if (!token.issue(_contributor, distributedPresaleTokens)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe mechanism\r\n     * \r\n     * Allows beneficary to retreive tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retreiveTokens(address _tokenContract) public only_beneficiary {\r\n        IToken tokenInstance = IToken(_tokenContract);\r\n\r\n        // Retreive tokens from our token contract\r\n        ITokenRetreiver(token).retreiveTokens(_tokenContract);\r\n\r\n        // Retreive tokens from crowdsale contract\r\n        uint tokenBalance = tokenInstance.balanceOf(this);\r\n        if (tokenBalance > 0) {\r\n            tokenInstance.transfer(beneficiary, tokenBalance);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"allocatedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmountPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_phase\",\"type\":\"uint256\"},{\"name\":\"_volume\",\"type\":\"uint256\"}],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseRate\",\"type\":\"uint256\"},{\"name\":\"_phaseRates\",\"type\":\"uint256[]\"},{\"name\":\"_phasePeriods\",\"type\":\"uint256[]\"},{\"name\":\"_phaseBonusLockupPeriods\",\"type\":\"uint256[]\"},{\"name\":\"_phaseUsesVolumeMultiplier\",\"type\":\"bool[]\"}],\"name\":\"setupPhases\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wei\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"toTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokenDenominator\",\"type\":\"uint256\"},{\"name\":\"_percentageDenominator\",\"type\":\"uint256\"},{\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"name\":\"_minAcceptedAmount\",\"type\":\"uint256\"},{\"name\":\"_minAmountPresale\",\"type\":\"uint256\"},{\"name\":\"_maxAmountPresale\",\"type\":\"uint256\"},{\"name\":\"_minAcceptedAmountPresale\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ethBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAcceptedAmountPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeholders\",\"type\":\"address[]\"},{\"name\":\"_stakeholderEthPercentages\",\"type\":\"uint256[]\"},{\"name\":\"_stakeholderTokenPercentages\",\"type\":\"uint256[]\"},{\"name\":\"_stakeholderTokenPayoutOverwriteReleaseDates\",\"type\":\"bool[]\"},{\"name\":\"_stakeholderTokenPayoutFixedReleaseDates\",\"type\":\"uint256[]\"},{\"name\":\"_stakeholderTokenPayoutPercentages\",\"type\":\"uint256[]\"},{\"name\":\"_stakeholderTokenPayoutVestingPeriods\",\"type\":\"uint256[]\"}],\"name\":\"setupStakeholders\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"refundableEthBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"retreiveTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_volumeMultiplierRates\",\"type\":\"uint256[]\"},{\"name\":\"_volumeMultiplierLockupPeriods\",\"type\":\"uint256[]\"},{\"name\":\"_volumeMultiplierThresholds\",\"type\":\"uint256[]\"}],\"name\":\"setupVolumeMultipliers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmBeneficiary\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocatedEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAmountPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_releaseDate\",\"type\":\"uint256\"}],\"name\":\"hasBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presale\",\"type\":\"address\"},{\"name\":\"_presaleToken\",\"type\":\"address\"}],\"name\":\"attachPresale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"importPresaleContribution\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAcceptedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInPresalePhase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address\"}],\"name\":\"setupWhitelist\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"GLACrowdsale","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7079464f88d6844a993195b4b25d0e0f044454e7eda4243a5e19fed601563b1e"}]}