{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title EvenDistroCrowdsaleLib\r\n * @author Modular Inc, https://modular.network\r\n *\r\n * version 2.1.0\r\n * Copyright (c) 2017 Majoolr, LLC\r\n * The MIT License (MIT)\r\n * https://github.com/Modular-Network/ethereum-libraries/blob/master/LICENSE\r\n *\r\n * The EvenDistroCrowdsale Library provides functionality to create a initial coin offering\r\n * for a standard token sale with high demand where the amount of ether a single address\r\n * can contribute is calculated by dividing the sale's contribution cap by the number\r\n * of addresses who register before the sale starts\r\n *\r\n * Modular provides smart contract services and security reviews for contract\r\n * deployments in addition to working on open source projects in the Ethereum\r\n * community. Our purpose is to test, document, and deploy reusable code onto the\r\n * blockchain and improve both security and usability. We also educate non-profits,\r\n * schools, and other community members about the application of blockchain\r\n * technology. For further information: modular.network\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nlibrary EvenDistroCrowdsaleLib {\r\n  using BasicMathLib for uint256;\r\n  using CrowdsaleLib for CrowdsaleLib.CrowdsaleStorage;\r\n\r\n  struct EvenDistroCrowdsaleStorage {\r\n\r\n  \tCrowdsaleLib.CrowdsaleStorage base; // base storage from CrowdsaleLib\r\n\r\n    // mapping showing which addresses have registered for the sale. can only be changed by the owner\r\n    mapping (address => bool) isRegistered;\r\n\r\n    // tracks the total number of tokens bought for each address\r\n    mapping(address => uint256) tokensBought;\r\n\r\n    uint256 numRegistered; // records how many addresses have registered\r\n    uint256 addressTokenCap; // cap on how much wei an address can contribute in the sale\r\n    bool staticCap; // true if the given address cap amounts are set on initialization\r\n  }\r\n\r\n\r\n  event LogTokensBought(address buyer, uint256 amount);\r\n  event LogTokenPriceChange(uint256 amount, string Msg);\r\n  event LogErrorMsg(uint256 amount, string Msg);\r\n\r\n  // Logs when a user is registered in the system before the sale\r\n  event LogUserRegistered(address registrant);\r\n\r\n  // Logs when a user is unregistered from the system before the sale\r\n  event LogUserUnRegistered(address registrant);\r\n\r\n  // Logs when there is an error with user registration\r\n  event LogRegError(address user, string Msg);\r\n\r\n  // Logs when there is an increase in the contribution cap per address\r\n  event LogAddressTokenCapChange(uint256 amount, string Msg);\r\n\r\n  // Logs when the address cap is initially calculated\r\n  event LogAddressTokenCapCalculated(uint256 saleCap, uint256 numRegistered, uint256 cap, string Msg);\r\n\r\n  /// @dev Called by a crowdsale contract upon creation.\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @param _owner Address of crowdsale owner\r\n  /// @param _saleData Array of 3 item sets such that, in each 3 element\r\n  /// set, 1 is timestamp, 2 is price in cents at that time,\r\n  /// 3 is address purchase cap at that time, 0 if no address cap\r\n  /// @param _fallbackExchangeRate Exchange rate of cents/ETH\r\n  /// @param _capAmountInCents Total to be raised in cents\r\n  /// @param _endTime Timestamp of sale end time\r\n  /// @param _percentBurn Percentage of extra tokens to burn\r\n  /// @param _staticCap Whether or not the address cap is going to be static\r\n  /// @param _token Token being sold\r\n  function init(EvenDistroCrowdsaleStorage storage self,\r\n                address _owner,\r\n                uint256[] _saleData,\r\n                uint256 _fallbackExchangeRate,\r\n                uint256 _capAmountInCents,\r\n                uint256 _endTime,\r\n                uint8 _percentBurn,\r\n                uint256 _initialAddressTokenCap,\r\n                bool _staticCap,\r\n                CrowdsaleToken _token)\r\n                public\r\n  {\r\n  \tself.base.init(_owner,\r\n                   _saleData,\r\n                   _fallbackExchangeRate,\r\n                   _capAmountInCents,\r\n                   _endTime,\r\n                   _percentBurn,\r\n                   _token);\r\n\r\n    self.addressTokenCap = _initialAddressTokenCap;\r\n    self.staticCap = _staticCap;\r\n  }\r\n\r\n  /// @dev register user function. can only be called by the owner when a user registers on the web app.\r\n  /// puts their address in the registered mapping and increments the numRegistered\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @param _registrant address to be registered for the sale\r\n  function registerUser(EvenDistroCrowdsaleStorage storage self, address _registrant)\r\n                        public\r\n                        returns (bool)\r\n  {\r\n    require((msg.sender == self.base.owner) || (msg.sender == address(this)));\r\n    // if the change interval is 0, then registration is allowed throughout the\r\n    // sale since a cap doesn't need to be calculated\r\n    if ((!self.staticCap) && (now >= self.base.startTime - 2 hours)) {\r\n      LogRegError(_registrant, \"Can only register users earlier than 2 hours before the sale!\");\r\n      return false;\r\n    }\r\n    if(self.isRegistered[_registrant]) {\r\n      LogRegError(_registrant, \"Registrant address is already registered for the sale!\");\r\n      return false;\r\n    }\r\n\r\n    uint256 result;\r\n    bool err;\r\n\r\n    self.isRegistered[_registrant] = true;\r\n    (err,result) = self.numRegistered.plus(1);\r\n    require(!err);\r\n    self.numRegistered = result;\r\n\r\n    LogUserRegistered(_registrant);\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @dev registers multiple users at the same time\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @param _registrants addresses to register for the sale\r\n  function registerUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)\r\n                         public\r\n                         returns (bool)\r\n  {\r\n    require(msg.sender == self.base.owner);\r\n\r\n    for (uint256 i = 0; i < _registrants.length; i++) {\r\n      registerUser(self,_registrants[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /// @dev Cancels a user's registration status can only be called by the owner when a user cancels their registration.\r\n  /// sets their address field in the registered mapping to false and decrements the numRegistered\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  function unregisterUser(EvenDistroCrowdsaleStorage storage self, address _registrant)\r\n                          public\r\n                          returns (bool)\r\n  {\r\n    require((msg.sender == self.base.owner) || (msg.sender == address(this)));\r\n    if ((!self.staticCap) && (now >= self.base.startTime - 2 hours)) {\r\n      LogRegError(_registrant, \"Can only unregister users earlier than 2 hours before the sale!\");\r\n      return false;\r\n    }\r\n    if(!self.isRegistered[_registrant]) {\r\n      LogRegError(_registrant, \"Registrant address not registered for the sale!\");\r\n      return false;\r\n    }\r\n\r\n    uint256 result;\r\n    bool err;\r\n\r\n    self.isRegistered[_registrant] = false;\r\n    (err,result) = self.numRegistered.minus(1);\r\n    require(!err);\r\n    self.numRegistered = result;\r\n\r\n    LogUserUnRegistered(_registrant);\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @dev unregisters multiple users at the same time\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @param _registrants addresses to unregister for the sale\r\n  function unregisterUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)\r\n                           public\r\n                           returns (bool)\r\n  {\r\n    require(msg.sender == self.base.owner);\r\n\r\n    for (uint256 i = 0; i < _registrants.length; i++) {\r\n      unregisterUser(self,_registrants[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /// @dev function that calculates address cap from the number of users registered\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  function calculateAddressTokenCap(EvenDistroCrowdsaleStorage storage self)\r\n                                    internal\r\n                                    returns (bool)\r\n  {\r\n    require(self.numRegistered > 0);\r\n    require(self.base.token.balanceOf(this) > 0);\r\n\r\n    if (self.staticCap)  {\r\n      return false;\r\n    }\r\n    require(!self.base.rateSet);  // makes sure this can only be called once\r\n\r\n    uint256 _baseCap;\r\n    uint256 _calcCap;\r\n    bool err;\r\n\r\n    _baseCap = (self.base.token.balanceOf(this))/self.numRegistered; // numRegistered required to be > 0\r\n\r\n    for(uint256 i = 0; i < self.base.milestoneTimes.length; i++){\r\n      (err,_calcCap) = self.base.saleData[self.base.milestoneTimes[i]][1].times(_baseCap);\r\n      require(!err);\r\n      self.base.saleData[self.base.milestoneTimes[i]][1] = _calcCap/100;\r\n    }\r\n\r\n    self.addressTokenCap = self.base.saleData[self.base.milestoneTimes[0]][1];\r\n    LogAddressTokenCapCalculated(self.base.capAmount, self.numRegistered, self.addressTokenCap, \"Address cap was Calculated!\");\r\n  }\r\n\r\n  /// @dev utility function for the receivePurchase function. returns the lower number\r\n  /// @param a first argument\r\n  /// @param b second argument\r\n  function getMin(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a<b) { return a; } else { return b; }\r\n  }\r\n\r\n\r\n  /// @dev Called when an address wants to purchase tokens\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @param _amount amound of wei that the buyer is sending\r\n  /// @return true on succesful purchase\r\n  function receivePurchase(EvenDistroCrowdsaleStorage storage self, uint256 _amount)\r\n                           public\r\n                           returns (bool)\r\n  {\r\n    require(msg.sender != self.base.owner);\r\n    require(self.base.validPurchase());\r\n    require(self.isRegistered[msg.sender]);\r\n\r\n  \t// if the address cap increase interval has passed, update the current day and change the address cap\r\n  \tif ((self.base.milestoneTimes.length > self.base.currentMilestone + 1) &&\r\n        (now > self.base.milestoneTimes[self.base.currentMilestone + 1]))\r\n    {\r\n      while((self.base.milestoneTimes.length > self.base.currentMilestone + 1) &&\r\n            (now > self.base.milestoneTimes[self.base.currentMilestone + 1]))\r\n      {\r\n        self.base.currentMilestone += 1;\r\n      }\r\n\r\n      self.addressTokenCap = self.base.saleData[self.base.milestoneTimes[self.base.currentMilestone]][1];\r\n\r\n      self.base.changeTokenPrice(self.base.saleData[self.base.milestoneTimes[self.base.currentMilestone]][0]);\r\n\r\n      LogAddressTokenCapChange(self.addressTokenCap, \"Address cap has increased!\");\r\n      LogTokenPriceChange(self.base.tokensPerEth,\"Token Price has changed!\");\r\n  \t}\r\n\r\n    uint256 _numTokens; //number of tokens that will be purchased\r\n    uint256 _newBalance; //the new balance of the owner of the crowdsale\r\n    uint256 _weiTokens; //temp calc holder\r\n    uint256 _leftoverWei; //wei change for purchaser\r\n    uint256 _remainder; //temp calc holder\r\n    uint256 _allowedWei;  // tells how much more the buyer can contribute up to their cap\r\n    bool err;\r\n\r\n    if((self.base.ownerBalance + _amount) > self.base.capAmount){\r\n      _leftoverWei = (self.base.ownerBalance + _amount) - self.base.capAmount;\r\n      _amount = _amount - _leftoverWei;\r\n    }\r\n\r\n    if(self.addressTokenCap > 0) {\r\n      //_allowedWei represents tokens first, recycle variable to prevent stack depth issues\r\n      _allowedWei = self.addressTokenCap - self.tokensBought[msg.sender];\r\n\r\n      (err, _allowedWei) = _allowedWei.times(1000000000000000000);\r\n      require(!err);\r\n\r\n      _allowedWei = _allowedWei/self.base.tokensPerEth;\r\n    } else {\r\n      // if addressTokenCap is zero then there is no cap\r\n      _allowedWei = _amount;\r\n    }\r\n    require(_allowedWei > 0);\r\n    _allowedWei = getMin(_amount,_allowedWei);\r\n    _leftoverWei = _leftoverWei + (_amount - _allowedWei);\r\n\r\n    // Find the number of tokens as a function in wei\r\n    (err,_weiTokens) = _allowedWei.times(self.base.tokensPerEth);\r\n    require(!err);\r\n\r\n    _numTokens = _weiTokens / 1000000000000000000;\r\n    _remainder = _weiTokens % 1000000000000000000;\r\n    _remainder = _remainder / self.base.tokensPerEth;\r\n    _leftoverWei = _leftoverWei + _remainder;\r\n    _amount = _amount - _remainder;\r\n    self.base.leftoverWei[msg.sender] += _leftoverWei;\r\n\r\n    // can't overflow because it is under the cap\r\n    self.base.hasContributed[msg.sender] += _allowedWei - _remainder;\r\n\r\n    assert(_numTokens <= self.base.token.balanceOf(this));\r\n\r\n    // calculate the amount of ether in the owners balance\r\n    (err,_newBalance) = self.base.ownerBalance.plus(_amount);\r\n    require(!err);\r\n\r\n    self.base.ownerBalance = _newBalance;   // \"deposit\" the amount\r\n\r\n    // can't overflow because it will be under the cap\r\n    self.base.withdrawTokensMap[msg.sender] += _numTokens;\r\n    self.tokensBought[msg.sender] += _numTokens;\r\n\r\n    //subtract tokens from owner's share\r\n    (err,_remainder) = self.base.withdrawTokensMap[self.base.owner].minus(_numTokens);\r\n    require(!err);\r\n    self.base.withdrawTokensMap[self.base.owner] = _remainder;\r\n\r\n    LogTokensBought(msg.sender, _numTokens);\r\n\r\n    return true;\r\n  }\r\n\r\n  /*Functions \"inherited\" from CrowdsaleLib library*/\r\n\r\n  function setTokenExchangeRate(EvenDistroCrowdsaleStorage storage self, uint256 _exchangeRate)\r\n                                public\r\n                                returns (bool)\r\n  {\r\n    bool ok = calculateAddressTokenCap(self);\r\n    return self.base.setTokenExchangeRate(_exchangeRate) && ok;\r\n  }\r\n\r\n  function setTokens(EvenDistroCrowdsaleStorage storage self) public returns (bool) {\r\n    bool ok = calculateAddressTokenCap(self);\r\n    return self.base.setTokens();\r\n  }\r\n\r\n  function withdrawTokens(EvenDistroCrowdsaleStorage storage self) public returns (bool) {\r\n    return self.base.withdrawTokens();\r\n  }\r\n\r\n  function withdrawLeftoverWei(EvenDistroCrowdsaleStorage storage self) public returns (bool) {\r\n    return self.base.withdrawLeftoverWei();\r\n  }\r\n\r\n  function withdrawOwnerEth(EvenDistroCrowdsaleStorage storage self) public returns (bool) {\r\n    return self.base.withdrawOwnerEth();\r\n  }\r\n\r\n  function getSaleData(EvenDistroCrowdsaleStorage storage self, uint256 timestamp)\r\n                       public\r\n                       view\r\n                       returns (uint256[3])\r\n  {\r\n    return self.base.getSaleData(timestamp);\r\n  }\r\n\r\n  function getTokensSold(EvenDistroCrowdsaleStorage storage self) public view returns (uint256) {\r\n    return self.base.getTokensSold();\r\n  }\r\n\r\n  function crowdsaleActive(EvenDistroCrowdsaleStorage storage self) public view returns (bool) {\r\n    return self.base.crowdsaleActive();\r\n  }\r\n\r\n  function crowdsaleEnded(EvenDistroCrowdsaleStorage storage self) public view returns (bool) {\r\n    return self.base.crowdsaleEnded();\r\n  }\r\n}\r\n\r\nlibrary CrowdsaleLib {\r\n  using BasicMathLib for uint256;\r\n\r\n  struct CrowdsaleStorage {\r\n  \taddress owner;     //owner of the crowdsale\r\n\r\n  \tuint256 tokensPerEth;  //number of tokens received per ether\r\n  \tuint256 capAmount; //Maximum amount to be raised in wei\r\n  \tuint256 startTime; //ICO start time, timestamp\r\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\r\n    uint256 exchangeRate; //cents/ETH exchange rate at the time of the sale\r\n    uint256 ownerBalance; //owner wei Balance\r\n    uint256 startingTokenBalance; //initial amount of tokens for sale\r\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\r\n    uint8 currentMilestone; //Pointer to the current milestone\r\n    uint8 tokenDecimals; //stored token decimals for calculation later\r\n    uint8 percentBurn; //percentage of extra tokens to burn\r\n    bool tokensSet; //true if tokens have been prepared for crowdsale\r\n    bool rateSet; //true if exchange rate has been set\r\n\r\n    //Maps timestamp to token price and address purchase cap starting at that time\r\n    mapping (uint256 => uint256[2]) saleData;\r\n\r\n    //shows how much wei an address has contributed\r\n  \tmapping (address => uint256) hasContributed;\r\n\r\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\r\n  \tmapping (address => uint256) withdrawTokensMap;\r\n\r\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\r\n    mapping (address => uint256) leftoverWei;\r\n\r\n  \tCrowdsaleToken token; //token being sold\r\n  }\r\n\r\n  // Indicates when an address has withdrawn their supply of tokens\r\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\r\n\r\n  // Indicates when an address has withdrawn their supply of extra wei\r\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\r\n\r\n  // Logs when owner has pulled eth\r\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\r\n\r\n  // Generic Notice message that includes and address and number\r\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\r\n\r\n  // Indicates when an error has occurred in the execution of a function\r\n  event LogErrorMsg(uint256 amount, string Msg);\r\n\r\n  /// @dev Called by a crowdsale contract upon creation.\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @param _owner Address of crowdsale owner\r\n  /// @param _saleData Array of 3 item sets such that, in each 3 element\r\n  /// set, 1 is timestamp, 2 is price in cents at that time,\r\n  /// 3 is address token purchase cap at that time, 0 if no address cap\r\n  /// @param _fallbackExchangeRate Exchange rate of cents/ETH\r\n  /// @param _capAmountInCents Total to be raised in cents\r\n  /// @param _endTime Timestamp of sale end time\r\n  /// @param _percentBurn Percentage of extra tokens to burn\r\n  /// @param _token Token being sold\r\n  function init(CrowdsaleStorage storage self,\r\n                address _owner,\r\n                uint256[] _saleData,\r\n                uint256 _fallbackExchangeRate,\r\n                uint256 _capAmountInCents,\r\n                uint256 _endTime,\r\n                uint8 _percentBurn,\r\n                CrowdsaleToken _token)\r\n                public\r\n  {\r\n  \trequire(self.capAmount == 0);\r\n  \trequire(self.owner == 0);\r\n    require(_saleData.length > 0);\r\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\r\n    require(_saleData[0] > (now + 2 hours));\r\n    require(_endTime > _saleData[0]);\r\n    require(_capAmountInCents > 0);\r\n    require(_owner > 0);\r\n    require(_fallbackExchangeRate > 0);\r\n    require(_percentBurn <= 100);\r\n    self.owner = _owner;\r\n    self.capAmount = ((_capAmountInCents/_fallbackExchangeRate) + 1)*(10**18);\r\n    self.startTime = _saleData[0];\r\n    self.endTime = _endTime;\r\n    self.token = _token;\r\n    self.tokenDecimals = _token.decimals();\r\n    self.percentBurn = _percentBurn;\r\n    self.exchangeRate = _fallbackExchangeRate;\r\n\r\n    uint256 _tempTime;\r\n    for(uint256 i = 0; i < _saleData.length; i += 3){\r\n      require(_saleData[i] > _tempTime);\r\n      require(_saleData[i + 1] > 0);\r\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\r\n      self.milestoneTimes.push(_saleData[i]);\r\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\r\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\r\n      _tempTime = _saleData[i];\r\n    }\r\n    changeTokenPrice(self, _saleData[1]);\r\n  }\r\n\r\n  /// @dev function to check if the crowdsale is currently active\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @return success\r\n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\r\n  \treturn (now >= self.startTime && now <= self.endTime);\r\n  }\r\n\r\n  /// @dev function to check if the crowdsale has ended\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @return success\r\n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\r\n  \treturn now > self.endTime;\r\n  }\r\n\r\n  /// @dev function to check if a purchase is valid\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @return true if the transaction can buy tokens\r\n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\r\n    bool nonZeroPurchase = msg.value != 0;\r\n    if (crowdsaleActive(self) && nonZeroPurchase) {\r\n      return true;\r\n    } else {\r\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /// @dev Function called by purchasers to pull tokens\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @return true if tokens were withdrawn\r\n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\r\n    bool ok;\r\n\r\n    if (self.withdrawTokensMap[msg.sender] == 0) {\r\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\r\n      return false;\r\n    }\r\n\r\n    if (msg.sender == self.owner) {\r\n      if(!crowdsaleEnded(self)){\r\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\r\n        return false;\r\n      } else {\r\n        if(self.percentBurn > 0){\r\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\r\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\r\n          ok = self.token.burnToken(_burnAmount);\r\n          require(ok);\r\n        }\r\n      }\r\n    }\r\n\r\n    var total = self.withdrawTokensMap[msg.sender];\r\n    self.withdrawTokensMap[msg.sender] = 0;\r\n    ok = self.token.transfer(msg.sender, total);\r\n    require(ok);\r\n    LogTokensWithdrawn(msg.sender, total);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Function called by purchasers to pull leftover wei from their purchases\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @return true if wei was withdrawn\r\n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\r\n    if (self.leftoverWei[msg.sender] == 0) {\r\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\r\n      return false;\r\n    }\r\n\r\n    var total = self.leftoverWei[msg.sender];\r\n    self.leftoverWei[msg.sender] = 0;\r\n    msg.sender.transfer(total);\r\n    LogWeiWithdrawn(msg.sender, total);\r\n    return true;\r\n  }\r\n\r\n  /// @dev send ether from the completed crowdsale to the owners wallet address\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @return true if owner withdrew eth\r\n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\r\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\r\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\r\n      return false;\r\n    }\r\n\r\n    require(msg.sender == self.owner);\r\n    require(self.ownerBalance > 0);\r\n\r\n    uint256 amount = self.ownerBalance;\r\n    self.ownerBalance = 0;\r\n    self.owner.transfer(amount);\r\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @dev Function to change the price of the token\r\n  /// @param self Stored crowdsale from crowdsale contract\r\n  /// @param _newPrice new token price (amount of tokens per ether)\r\n  /// @return true if the token price changed successfully\r\n  function changeTokenPrice(CrowdsaleStorage storage self,\r\n                            uint256 _newPrice)\r\n                            internal\r\n                            returns (bool)\r\n  {\r\n  \trequire(_newPrice > 0);\r\n\r\n    bool err;\r\n    uint256 result;\r\n\r\n    (err, result) = self.exchangeRate.times(10**uint256(self.tokenDecimals));\r\n    require(!err);\r\n\r\n    self.tokensPerEth = result / _newPrice;\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @dev function that is called three days before the sale to set the token and price\r\n  /// @param self Stored Crowdsale from crowdsale contract\r\n  /// @param _exchangeRate  ETH exchange rate expressed in cents/ETH\r\n  /// @return true if the exchange rate has been set\r\n  function setTokenExchangeRate(CrowdsaleStorage storage self, uint256 _exchangeRate)\r\n                                public\r\n                                returns (bool)\r\n  {\r\n    require(msg.sender == self.owner);\r\n    require((now > (self.startTime - 3 days)) && (now < (self.startTime)));\r\n    require(!self.rateSet);   // the exchange rate can only be set once!\r\n    require(self.token.balanceOf(this) > 0);\r\n    require(_exchangeRate > 0);\r\n\r\n    uint256 _capAmountInCents;\r\n    bool err;\r\n\r\n    (err, _capAmountInCents) = self.exchangeRate.times(self.capAmount);\r\n    require(!err);\r\n\r\n    self.exchangeRate = _exchangeRate;\r\n    self.capAmount = (_capAmountInCents/_exchangeRate) + 1;\r\n    changeTokenPrice(self,self.saleData[self.milestoneTimes[0]][0]);\r\n    self.rateSet = true;\r\n\r\n    err = !(setTokens(self));\r\n    require(!err);\r\n\r\n    LogNoticeMsg(msg.sender,self.tokensPerEth,\"Owner has set the exchange Rate and tokens bought per ETH!\");\r\n    return true;\r\n  }\r\n\r\n  /// @dev fallback function to set tokens if the exchange rate function was not called\r\n  /// @param self Stored Crowdsale from crowdsale contract\r\n  /// @return true if tokens set successfully\r\n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\r\n    require((msg.sender == self.owner) || (msg.sender == address(this)));\r\n    require(!self.tokensSet);\r\n\r\n    uint256 _tokenBalance;\r\n\r\n    _tokenBalance = self.token.balanceOf(this);\r\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\r\n    self.startingTokenBalance = _tokenBalance;\r\n    self.tokensSet = true;\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @dev Gets the price and buy cap for individual addresses at the given milestone index\r\n  /// @param self Stored Crowdsale from crowdsale contract\r\n  /// @param timestamp Time during sale for which data is requested\r\n  /// @return A 3-element array with 0 the timestamp, 1 the price in cents, 2 the address cap\r\n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\r\n                       public\r\n                       view\r\n                       returns (uint256[3])\r\n  {\r\n    uint256[3] memory _thisData;\r\n    uint256 index;\r\n\r\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\r\n      index++;\r\n    }\r\n    if(index == 0)\r\n      index++;\r\n\r\n    _thisData[0] = self.milestoneTimes[index - 1];\r\n    _thisData[1] = self.saleData[_thisData[0]][0];\r\n    _thisData[2] = self.saleData[_thisData[0]][1];\r\n    return _thisData;\r\n  }\r\n\r\n  /// @dev Gets the number of tokens sold thus far\r\n  /// @param self Stored Crowdsale from crowdsale contract\r\n  /// @return Number of tokens sold\r\n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\r\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\r\n  }\r\n}\r\n\r\nlibrary TokenLib {\r\n  using BasicMathLib for uint256;\r\n\r\n  struct TokenStorage {\r\n    bool initialized;\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    string name;\r\n    string symbol;\r\n    uint256 totalSupply;\r\n    uint256 initialSupply;\r\n    address owner;\r\n    uint8 decimals;\r\n    bool stillMinting;\r\n  }\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event OwnerChange(address from, address to);\r\n  event Burn(address indexed burner, uint256 value);\r\n  event MintingClosed(bool mintingClosed);\r\n\r\n  /// @dev Called by the Standard Token upon creation.\r\n  /// @param self Stored token from token contract\r\n  /// @param _name Name of the new token\r\n  /// @param _symbol Symbol of the new token\r\n  /// @param _decimals Decimal places for the token represented\r\n  /// @param _initial_supply The initial token supply\r\n  /// @param _allowMinting True if additional tokens can be created, false otherwise\r\n  function init(TokenStorage storage self,\r\n                address _owner,\r\n                string _name,\r\n                string _symbol,\r\n                uint8 _decimals,\r\n                uint256 _initial_supply,\r\n                bool _allowMinting)\r\n                public\r\n  {\r\n    require(!self.initialized);\r\n    self.initialized = true;\r\n    self.name = _name;\r\n    self.symbol = _symbol;\r\n    self.totalSupply = _initial_supply;\r\n    self.initialSupply = _initial_supply;\r\n    self.decimals = _decimals;\r\n    self.owner = _owner;\r\n    self.stillMinting = _allowMinting;\r\n    self.balances[_owner] = _initial_supply;\r\n  }\r\n\r\n  /// @dev Transfer tokens from caller's account to another account.\r\n  /// @param self Stored token from token contract\r\n  /// @param _to Address to send tokens\r\n  /// @param _value Number of tokens to send\r\n  /// @return True if completed\r\n  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    bool err;\r\n    uint256 balance;\r\n\r\n    (err,balance) = self.balances[msg.sender].minus(_value);\r\n    require(!err);\r\n    self.balances[msg.sender] = balance;\r\n    //It's not possible to overflow token supply\r\n    self.balances[_to] = self.balances[_to] + _value;\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Authorized caller transfers tokens from one account to another\r\n  /// @param self Stored token from token contract\r\n  /// @param _from Address to send tokens from\r\n  /// @param _to Address to send tokens to\r\n  /// @param _value Number of tokens to send\r\n  /// @return True if completed\r\n  function transferFrom(TokenStorage storage self,\r\n                        address _from,\r\n                        address _to,\r\n                        uint256 _value)\r\n                        public\r\n                        returns (bool)\r\n  {\r\n    var _allowance = self.allowed[_from][msg.sender];\r\n    bool err;\r\n    uint256 balanceOwner;\r\n    uint256 balanceSpender;\r\n\r\n    (err,balanceOwner) = self.balances[_from].minus(_value);\r\n    require(!err);\r\n\r\n    (err,balanceSpender) = _allowance.minus(_value);\r\n    require(!err);\r\n\r\n    self.balances[_from] = balanceOwner;\r\n    self.allowed[_from][msg.sender] = balanceSpender;\r\n    self.balances[_to] = self.balances[_to] + _value;\r\n\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Retrieve token balance for an account\r\n  /// @param self Stored token from token contract\r\n  /// @param _owner Address to retrieve balance of\r\n  /// @return balance The number of tokens in the subject account\r\n  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\r\n    return self.balances[_owner];\r\n  }\r\n\r\n  /// @dev Authorize an account to send tokens on caller's behalf\r\n  /// @param self Stored token from token contract\r\n  /// @param _spender Address to authorize\r\n  /// @param _value Number of tokens authorized account may send\r\n  /// @return True if completed\r\n  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\r\n    // must set to zero before changing approval amount in accordance with spec\r\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\r\n\r\n    self.allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Remaining tokens third party spender has to send\r\n  /// @param self Stored token from token contract\r\n  /// @param _owner Address of token holder\r\n  /// @param _spender Address of authorized spender\r\n  /// @return remaining Number of tokens spender has left in owner's account\r\n  function allowance(TokenStorage storage self, address _owner, address _spender)\r\n                     public\r\n                     view\r\n                     returns (uint256 remaining) {\r\n    return self.allowed[_owner][_spender];\r\n  }\r\n\r\n  /// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it\r\n  /// @param self Stored token from token contract\r\n  /// @param _spender Address to authorize\r\n  /// @param _valueChange Increase or decrease in number of tokens authorized account may send\r\n  /// @param _increase True if increasing allowance, false if decreasing allowance\r\n  /// @return True if completed\r\n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\r\n                          public returns (bool)\r\n  {\r\n    uint256 _newAllowed;\r\n    bool err;\r\n\r\n    if(_increase) {\r\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\r\n      require(!err);\r\n\r\n      self.allowed[msg.sender][_spender] = _newAllowed;\r\n    } else {\r\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\r\n        self.allowed[msg.sender][_spender] = 0;\r\n      } else {\r\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\r\n        self.allowed[msg.sender][_spender] = _newAllowed;\r\n      }\r\n    }\r\n\r\n    Approval(msg.sender, _spender, _newAllowed);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Change owning address of the token contract, specifically for minting\r\n  /// @param self Stored token from token contract\r\n  /// @param _newOwner Address for the new owner\r\n  /// @return True if completed\r\n  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\r\n    require((self.owner == msg.sender) && (_newOwner > 0));\r\n\r\n    self.owner = _newOwner;\r\n    OwnerChange(msg.sender, _newOwner);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Mints additional tokens, new tokens go to owner\r\n  /// @param self Stored token from token contract\r\n  /// @param _amount Number of tokens to mint\r\n  /// @return True if completed\r\n  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\r\n    require((self.owner == msg.sender) && self.stillMinting);\r\n    uint256 _newAmount;\r\n    bool err;\r\n\r\n    (err, _newAmount) = self.totalSupply.plus(_amount);\r\n    require(!err);\r\n\r\n    self.totalSupply =  _newAmount;\r\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\r\n    Transfer(0x0, self.owner, _amount);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Permanent stops minting\r\n  /// @param self Stored token from token contract\r\n  /// @return True if completed\r\n  function closeMint(TokenStorage storage self) public returns (bool) {\r\n    require(self.owner == msg.sender);\r\n\r\n    self.stillMinting = false;\r\n    MintingClosed(true);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Permanently burn tokens\r\n  /// @param self Stored token from token contract\r\n  /// @param _amount Amount of tokens to burn\r\n  /// @return True if completed\r\n  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\r\n      uint256 _newBalance;\r\n      bool err;\r\n\r\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\r\n      require(!err);\r\n\r\n      self.balances[msg.sender] = _newBalance;\r\n      self.totalSupply = self.totalSupply - _amount;\r\n      Burn(msg.sender, _amount);\r\n      Transfer(msg.sender, 0x0, _amount);\r\n      return true;\r\n  }\r\n}\r\n\r\nlibrary BasicMathLib {\r\n  /// @dev Multiplies two numbers and checks for overflow before returning.\r\n  /// Does not throw.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is overflow\r\n  /// @return res The product of a and b, or 0 if there is overflow\r\n  function times(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\r\n    assembly{\r\n      res := mul(a,b)\r\n      switch or(iszero(b), eq(div(res,b), a))\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Divides two numbers but checks for 0 in the divisor first.\r\n  /// Does not throw.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if `b` is 0\r\n  /// @return res The quotient of a and b, or 0 if `b` is 0\r\n  function dividedBy(uint256 a, uint256 b) public view returns (bool err,uint256 i) {\r\n    uint256 res;\r\n    assembly{\r\n      switch iszero(b)\r\n      case 0 {\r\n        res := div(a,b)\r\n        let loc := mload(0x40)\r\n        mstore(add(loc,0x20),res)\r\n        i := mload(add(loc,0x20))\r\n      }\r\n      default {\r\n        err := 1\r\n        i := 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Adds two numbers and checks for overflow before returning.\r\n  /// Does not throw.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is overflow\r\n  /// @return res The sum of a and b, or 0 if there is overflow\r\n  function plus(uint256 a, uint256 b) public view returns (bool err, uint256 res) {\r\n    assembly{\r\n      res := add(a,b)\r\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Subtracts two numbers and checks for underflow before returning.\r\n  /// Does not throw but rather logs an Err event if there is underflow.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is underflow\r\n  /// @return res The difference between a and b, or 0 if there is underflow\r\n  function minus(uint256 a, uint256 b) public view returns (bool err,uint256 res) {\r\n    assembly{\r\n      res := sub(a,b)\r\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ncontract CrowdsaleToken {\r\n  using TokenLib for TokenLib.TokenStorage;\r\n\r\n  TokenLib.TokenStorage public token;\r\n\r\n  function CrowdsaleToken(address owner,\r\n                                   string name,\r\n                                   string symbol,\r\n                                   uint8 decimals,\r\n                                   uint256 initialSupply,\r\n                                   bool allowMinting)\r\n                                   public\r\n  {\r\n    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\r\n  }\r\n\r\n  function name() public view returns (string) {\r\n    return token.name;\r\n  }\r\n\r\n  function symbol() public view returns (string) {\r\n    return token.symbol;\r\n  }\r\n\r\n  function decimals() public view returns (uint8) {\r\n    return token.decimals;\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return token.totalSupply;\r\n  }\r\n\r\n  function initialSupply() public view returns (uint256) {\r\n    return token.initialSupply;\r\n  }\r\n\r\n  function balanceOf(address who) public view returns (uint256) {\r\n    return token.balanceOf(who);\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view returns (uint256) {\r\n    return token.allowance(owner, spender);\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool ok) {\r\n    return token.transfer(to, value);\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint value) public returns (bool ok) {\r\n    return token.transferFrom(from, to, value);\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public returns (bool ok) {\r\n    return token.approve(spender, value);\r\n  }\r\n\r\n  function approveChange(address spender, uint256 valueChange, bool increase)\r\n                         public\r\n                         returns (bool)\r\n  {\r\n    return token.approveChange(spender, valueChange, increase);\r\n  }\r\n\r\n  function changeOwner(address newOwner) public returns (bool ok) {\r\n    return token.changeOwner(newOwner);\r\n  }\r\n\r\n  function burnToken(uint256 amount) public returns (bool ok) {\r\n    return token.burnToken(amount);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"}],\"name\":\"crowdsaleActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"}],\"name\":\"withdrawOwnerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"}],\"name\":\"crowdsaleEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"}],\"name\":\"setTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"},{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"setTokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"},{\"name\":\"_registrants\",\"type\":\"address[]\"}],\"name\":\"registerUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"receivePurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_saleData\",\"type\":\"uint256[]\"},{\"name\":\"_fallbackExchangeRate\",\"type\":\"uint256\"},{\"name\":\"_capAmountInCents\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_percentBurn\",\"type\":\"uint8\"},{\"name\":\"_initialAddressTokenCap\",\"type\":\"uint256\"},{\"name\":\"_staticCap\",\"type\":\"bool\"},{\"name\":\"_token\",\"type\":\"CrowdsaleToken\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"}],\"name\":\"getTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"},{\"name\":\"_registrant\",\"type\":\"address\"}],\"name\":\"unregisterUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getSaleData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"}],\"name\":\"withdrawLeftoverWei\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"},{\"name\":\"_registrants\",\"type\":\"address[]\"}],\"name\":\"unregisterUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"EvenDistroCrowdsaleLib.EvenDistroCrowdsaleStorage storage\"},{\"name\":\"_registrant\",\"type\":\"address\"}],\"name\":\"registerUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogTokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Msg\",\"type\":\"string\"}],\"name\":\"LogTokenPriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Msg\",\"type\":\"string\"}],\"name\":\"LogErrorMsg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registrant\",\"type\":\"address\"}],\"name\":\"LogUserRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registrant\",\"type\":\"address\"}],\"name\":\"LogUserUnRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Msg\",\"type\":\"string\"}],\"name\":\"LogRegError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Msg\",\"type\":\"string\"}],\"name\":\"LogAddressTokenCapChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"saleCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numRegistered\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Msg\",\"type\":\"string\"}],\"name\":\"LogAddressTokenCapCalculated\",\"type\":\"event\"}]","ContractName":"EvenDistroCrowdsaleLib","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"BasicMathLib:01671229bbf99b30203f9807c5a577a7b8c358fc;CrowdsaleLib:7494BDd21Ea41BA8271098BEDB9b75454B0B3260","SwarmSource":"bzzr://685d92b45e503c03154e1a80d185432ea3501e857a4bdc52d7e453036a3a1d06"}]}