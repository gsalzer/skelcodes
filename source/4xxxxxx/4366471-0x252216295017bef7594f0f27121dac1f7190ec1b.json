{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n/** @title owned. */\r\ncontract owned  {\r\n  address owner;\r\n  function owned() {\r\n    owner = msg.sender;\r\n  }\r\n  function changeOwner(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n  modifier onlyOwner() {\r\n    if (msg.sender==owner) \r\n    _;\r\n  }\r\n}\r\n\r\n/** @title mortal. */\r\ncontract mortal is owned() {\r\n  function kill() onlyOwner {\r\n    if (msg.sender == owner) selfdestruct(owner);\r\n  }\r\n}\r\n \r\n\r\n// <ORACLIZE_API>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\n/** @title OraclizeI. */\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n    function randomDS_getSessionPubKeyHash() returns(bytes32);\r\n}\r\n/** @title OraclizeAddrResolverI. */\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\n/** @title usingOraclize. */\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofType_Android = 0x20;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork();\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork() internal returns(bool){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            oraclize_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            oraclize_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            oraclize_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            oraclize_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n   function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n       return oraclize.getPrice(datasource);\r\n   }\r\n\r\n   function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n       return oraclize.getPrice(datasource, gaslimit);\r\n   }\r\n   \r\n\tfunction oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { \r\n        return oraclize.setCustomGasPrice(gasPrice); \r\n\t}     \r\n\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n\r\n\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n        \r\n    string oraclize_network_name;\r\n    function oraclize_setNetworkName(string _network_name) internal {\r\n        oraclize_network_name = _network_name;\r\n    }\r\n    \r\n    function oraclize_getNetworkName() internal returns (string) {\r\n        return oraclize_network_name;\r\n    }\r\n        \r\n}\r\n// </ORACLIZE_API>\r\n\r\n/** @title DSParser. */\r\ncontract DSParser{\r\n    uint8 constant WAD_Dec=18;\r\n    uint128 constant WAD = 10 ** 18;\r\n    function parseInt128(string _a)  constant  returns (uint128) { \r\n\t\treturn cast(parseInt( _a, WAD_Dec));\r\n    }\r\n    function cast(uint256 x) constant internal returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n    function parseInt(string _a, uint _b)  \r\n\t\t\tconstant \r\n\t\t\treturns (uint) { \r\n\t\t/** @dev Turns a string into a number with _b places\r\n          * @param _a String to be processed, e.g. \"0.002\"\r\n          * @param _b number of decimal places\r\n          * @return uint of the decimal representation\r\n        */\r\n\t\t\tbytes memory bresult = bytes(_a);\r\n            uint mint = 0;\r\n            bool decimals = false;\r\n            for (uint i=0; i<bresult.length; i++){\r\n                if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                    if (decimals){\r\n                       if (_b == 0){\r\n                        //Round up if next value is 5 or greater\r\n                        if(uint(bresult[i])- 48>4){\r\n                            mint = mint+1;\r\n                        }    \r\n                        break;\r\n                       }\r\n                       else _b--;\r\n                    }\r\n                    mint *= 10;\r\n                    mint += uint(bresult[i]) - 48;\r\n                } else if (bresult[i] == 46||bresult[i] == 44) { // cope with euro decimals using commas\r\n                    decimals = true;\r\n                }\r\n            }\r\n            if (_b > 0) mint *= 10**_b;\r\n           return mint;\r\n    }\r\n\t\r\n}\r\n\r\n/** @title I_minter. */\r\ncontract I_minter { \r\n    event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \r\n    event EventBankrupt();\r\n\t\r\n    function Leverage() constant returns (uint128)  {}\r\n    function RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) constant returns (uint128 price)  {}\r\n    function RiskPrice(uint128 _currentPrice) constant returns (uint128 price)  {}     \r\n    function PriceReturn(uint _TransID,uint128 _Price) {}\r\n    function NewStatic() external payable returns (uint _TransID)  {}\r\n    function NewStaticAdr(address _Risk) external payable returns (uint _TransID)  {}\r\n    function NewRisk() external payable returns (uint _TransID)  {}\r\n    function NewRiskAdr(address _Risk) external payable returns (uint _TransID)  {}\r\n    function RetRisk(uint128 _Quantity) external payable returns (uint _TransID)  {}\r\n    function RetStatic(uint128 _Quantity) external payable returns (uint _TransID)  {}\r\n    function Strike() constant returns (uint128)  {}\r\n}\r\n\r\n/** @title I_Pricer. */\r\ncontract I_Pricer {\r\n    uint128 public lastPrice;\r\n    uint public constant DELAY = 1 days;// this needs to be a day on the mainnet\r\n    I_minter public mint;\r\n    string public sURL;//=\"json(https://api.kraken.com/0/public/Ticker?pair=ETHEUR).result.XETHZEUR.p.1\";\r\n    mapping (bytes32 => uint) RevTransaction;\r\n    function setMinter(address _newAddress) {}\r\n    function __callback(bytes32 myid, string result) {}\r\n    function queryCost() constant returns (uint128 _value) {}\r\n    function QuickPrice() payable {}\r\n    function requestPrice(uint _actionID) payable returns (uint _TrasID){}\r\n    function collectFee() returns(bool) {}\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        revert();\r\n    }\r\n}\r\n\r\n/** @title Pricer. */\r\ncontract Pricer is I_Pricer, \r\n\tmortal, \r\n\tusingOraclize, \r\n\tDSParser {\r\n\t// <pair_name> = pair name\r\n    // a = ask array(<price>, <whole lot volume>, <lot volume>),\r\n    // b = bid array(<price>, <whole lot volume>, <lot volume>),\r\n    // c = last trade closed array(<price>, <lot volume>),\r\n    // v = volume array(<today>, <last 24 hours>),\r\n    // p = volume weighted average price array(<today>, <last 24 hours>),\r\n    // t = number of trades array(<today>, <last 24 hours>),\r\n    // l = low array(<today>, <last 24 hours>),\r\n    // h = high array(<today>, <last 24 hours>),\r\n    // o = today's opening price\r\n\t\r\n    function Pricer(string _URL) {\r\n\t\t/** @dev Constructor, allows the pricer URL to be set\r\n          * @param _URL of the web query\r\n          * @return nothing\r\n        */\r\n\t\toraclize_setNetwork();\r\n\t\tsURL=_URL;\r\n    }\r\n\r\n\tfunction () {\r\n        //if ether is sent to this address, send it back.\r\n        revert();\r\n    }\r\n\r\n    function setMinter(address _newAddress) \r\n\t\tonlyOwner {\r\n\t\t/** @dev Allows the address of the minter to be set\r\n          * @param _newAddress Address of the minter\r\n          * @return nothing\r\n        */\r\n        mint=I_minter(_newAddress);\r\n    }\r\n\r\n    function queryCost() \r\n\t\tconstant \r\n\t\treturns (uint128 _value) {\r\n\t\t/** @dev ETH cost of calling the oraclize \r\n          * @param _newAddress Address of the minter\r\n          * @return nothing\r\n        */\r\n\t\treturn cast(oraclize_getPrice(\"URL\")); \r\n    }\r\n\r\n    function QuickPrice() \r\n\t\tpayable {\r\n\t\t/** @dev Gets the latest price.  Be careful, All eth sent is kept by the contract.\r\n          * @return nothing, but the new price will be stored in variable lastPrice\r\n        */\r\n        bytes32 TrasID =oraclize_query(1, \"URL\", sURL);\r\n        RevTransaction[TrasID]=0;\r\n    }\r\n\t\r\n    function __callback(bytes32 myid, string result) {\r\n\t\t/** @dev ORACLIZE standard callback function-\r\n          * @param myid Pricer transaction ID\r\n\t\t  * @param result Address of the minter\r\n          * @return calls minter.PriceReturn() with the price\r\n        */\r\n        if (msg.sender != oraclize_cbAddress()) revert(); // Only oraclize\r\n        bytes memory tempEmptyStringTest = bytes(result); // Array uses memory\r\n        if (tempEmptyStringTest.length == 0) {\r\n             lastPrice =  0;  //0 is taken to be an error by the minter contract\r\n        } else {\r\n            lastPrice =  parseInt128(result);  //convert the string into a 18 decimal place number\r\n        }\r\n        if(RevTransaction[myid]>0){  //if it's not from QuickPrice\r\n            mint.PriceReturn(RevTransaction[myid],lastPrice);  //Call the minter\r\n        }\r\n        delete RevTransaction[myid]; // free up the memory\r\n    }\r\n\r\n\tfunction setGas(uint gasPrice) \r\n\t\tonlyOwner \r\n\t\treturns(bool) {\r\n\t\t/** @dev Allows oraclize gas cost to be changed\r\n          * @return True if sucessful\r\n        */\r\n\t\toraclize_setCustomGasPrice(gasPrice);\r\n\t\treturn true;\r\n    }\r\n\t\r\n\tfunction collectFee() \r\n\t\tonlyOwner \r\n\t\treturns(bool) {\r\n\t\t/** @dev Allows ETH to be removed from this contract (only this one, not the minter)\r\n          * @return True if sucessful\r\n        */\r\n        return owner.send(this.balance);\r\n\t\treturn true;\r\n    }\r\n\t\r\n\tmodifier onlyminter() {\r\n      if (msg.sender==address(mint)) \r\n      _;\r\n    }\r\n\r\n    function requestPrice(uint _actionID) \r\n\t\tpayable \r\n\t\tonlyminter \r\n\t\treturns (uint _TrasID){\r\n\t\t/** @dev Minter only functuon.  Needs to be called with enough eth\r\n          * @param _actionID Pricer transaction ID\r\n          * @return calls minter.PriceReturn() with the price\r\n        */\r\n        // \r\n        bytes32 TrasID;\r\n        TrasID=oraclize_query(DELAY, \"URL\", sURL);\r\n        RevTransaction[TrasID]=_actionID;\r\n\t\treturn _TrasID;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sURL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DELAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"},{\"name\":\"_b\",\"type\":\"uint256\"}],\"name\":\"parseInt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_actionID\",\"type\":\"uint256\"}],\"name\":\"requestPrice\",\"outputs\":[{\"name\":\"_TrasID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"QuickPrice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"setGas\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"}],\"name\":\"parseInt128\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryCost\",\"outputs\":[{\"name\":\"_value\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_URL\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"Pricer","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004c6a736f6e2868747470733a2f2f6170692e6b72616b656e2e636f6d2f302f7075626c69632f5469636b65723f706169723d455448555344292e726573756c742e584554485a5553442e702e310000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://1727e8482e3b747c81bad607720be594600054e9aabec36ad23fd90d21d8b162"}]}