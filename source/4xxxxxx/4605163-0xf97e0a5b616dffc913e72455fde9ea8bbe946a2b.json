{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n\r\n/// @title GeneScience implements the trait calculation for new kitties\r\n/// @author Axiom Zen, Dieter Shirley <dete@axiomzen.co> (https://github.com/dete), Fabiano P. Soriani <fabianosoriani@gmail.com> (https://github.com/flockonus), Jordan Schalm <jordan.schalm@gmail.com> (https://github.com/jordanschalm)\r\ncontract GeneScience {\r\n    bool public isGeneScience = true;\r\n\r\n    uint256 internal constant maskLast8Bits = uint256(0xff);\r\n    uint256 internal constant maskFirst248Bits = uint256(~0xff);\r\n\r\n    function GeneScience() public {}\r\n\r\n    /// @dev given a characteristic and 2 genes (unsorted) - returns > 0 if the genes ascended, that's the value\r\n    /// @param trait1 any trait of that characteristic\r\n    /// @param trait2 any trait of that characteristic\r\n    /// @param rand is expected to be a 3 bits number (0~7)\r\n    /// @return -1 if didnt match any ascention, OR a number from 0 to 30 for the ascended trait\r\n    function _ascend(uint8 trait1, uint8 trait2, uint256 rand) internal pure returns(uint8 ascension) {\r\n        ascension = 0;\r\n\r\n        uint8 smallT = trait1;\r\n        uint8 bigT = trait2;\r\n\r\n        if (smallT > bigT) {\r\n            bigT = trait1;\r\n            smallT = trait2;\r\n        }\r\n\r\n        // https://github.com/axiomzen/cryptokitties/issues/244\r\n        if ((bigT - smallT == 1) && smallT % 2 == 0) {\r\n\r\n            // The rand argument is expected to be a random number 0-7.\r\n            // 1st and 2nd tier: 1/4 chance (rand is 0 or 1)\r\n            // 3rd and 4th tier: 1/8 chance (rand is 0)\r\n\r\n            // must be at least this much to ascend\r\n            uint256 maxRand;\r\n            if (smallT < 23) maxRand = 1;\r\n            else maxRand = 0;\r\n\r\n            if (rand <= maxRand ) {\r\n                ascension = (smallT / 2) + 16;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev given a number get a slice of any bits, at certain offset\r\n    /// @param _n a number to be sliced\r\n    /// @param _nbits how many bits long is the new number\r\n    /// @param _offset how many bits to skip\r\n    function _sliceNumber(uint256 _n, uint256 _nbits, uint256 _offset) private pure returns (uint256) {\r\n        // mask is made by shifting left an offset number of times\r\n        uint256 mask = uint256((2**_nbits) - 1) << _offset;\r\n        // AND n with mask, and trim to max of _nbits bits\r\n        return uint256((_n & mask) >> _offset);\r\n    }\r\n\r\n    /// @dev Get a 5 bit slice from an input as a number\r\n    /// @param _input bits, encoded as uint\r\n    /// @param _slot from 0 to 50\r\n    function _get5Bits(uint256 _input, uint256 _slot) internal pure returns(uint8) {\r\n        return uint8(_sliceNumber(_input, uint256(5), _slot * 5));\r\n    }\r\n\r\n    /// @dev Parse a kitten gene and returns all of 12 \"trait stack\" that makes the characteristics\r\n    /// @param _genes kitten gene\r\n    /// @return the 48 traits that composes the genetic code, logically divided in stacks of 4, where only the first trait of each stack may express\r\n    function decode(uint256 _genes) public pure returns(uint8[]) {\r\n        uint8[] memory traits = new uint8[](48);\r\n        uint256 i;\r\n        for(i = 0; i < 48; i++) {\r\n            traits[i] = _get5Bits(_genes, i);\r\n        }\r\n        return traits;\r\n    }\r\n\r\n    /// @dev Given an array of traits return the number that represent genes\r\n    function encode(uint8[] _traits) public pure returns (uint256 _genes) {\r\n        _genes = 0;\r\n        for(uint256 i = 0; i < 48; i++) {\r\n            _genes = _genes << 5;\r\n            // bitwise OR trait with _genes\r\n            _genes = _genes | _traits[47 - i];\r\n        }\r\n        return _genes;\r\n    }\r\n\r\n    /// @dev return the expressing traits\r\n    /// @param _genes the long number expressing cat genes\r\n    function expressingTraits(uint256 _genes) public pure returns(uint8[12]) {\r\n        uint8[12] memory express;\r\n        for(uint256 i = 0; i < 12; i++) {\r\n            express[i] = _get5Bits(_genes, i * 4);\r\n        }\r\n        return express;\r\n    }\r\n\r\n    /// @dev the function as defined in the breeding contract - as defined in CK bible\r\n    function mixGenes(uint256 _genes1, uint256 _genes2, uint256 _targetBlock) public returns (uint256) {\r\n        require(block.number > _targetBlock);\r\n\r\n        // Try to grab the hash of the \"target block\". This should be available the vast\r\n        // majority of the time (it will only fail if no-one calls giveBirth() within 256\r\n        // blocks of the target block, which is about 40 minutes. Since anyone can call\r\n        // giveBirth() and they are rewarded with ether if it succeeds, this is quite unlikely.)\r\n        uint256 randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n        if (randomN == 0) {\r\n            // We don't want to completely bail if the target block is no-longer available,\r\n            // nor do we want to just use the current block's hash (since it could allow a\r\n            // caller to game the random result). Compute the most recent block that has the\r\n            // the same value modulo 256 as the target block. The hash for this block will\r\n            // still be available, and – while it can still change as time passes – it will\r\n            // only change every 40 minutes. Again, someone is very likely to jump in with\r\n            // the giveBirth() call before it can cycle too many times.\r\n            _targetBlock = (block.number & maskFirst248Bits) + (_targetBlock & maskLast8Bits);\r\n\r\n            // The computation above could result in a block LARGER than the current block,\r\n            // if so, subtract 256.\r\n            if (_targetBlock >= block.number) _targetBlock -= 256;\r\n\r\n            randomN = uint256(block.blockhash(_targetBlock));\r\n\r\n            // DEBUG ONLY\r\n            // assert(block.number != _targetBlock);\r\n            // assert((block.number - _targetBlock) <= 256);\r\n            // assert(randomN != 0);\r\n        }\r\n\r\n        // generate 256 bits of random, using as much entropy as we can from\r\n        // sources that can't change between calls.\r\n        randomN = uint256(keccak256(randomN, _genes1, _genes2, _targetBlock));\r\n        uint256 randomIndex = 0;\r\n\r\n        uint8[] memory genes1Array = decode(_genes1);\r\n        uint8[] memory genes2Array = decode(_genes2);\r\n        // All traits that will belong to baby\r\n        uint8[] memory babyArray = new uint8[](48);\r\n        // A pointer to the trait we are dealing with currently\r\n        uint256 traitPos;\r\n        // Trait swap value holder\r\n        uint8 swap;\r\n        // iterate all 12 characteristics\r\n        for(uint256 i = 0; i < 12; i++) {\r\n            // pick 4 traits for characteristic i\r\n            uint256 j;\r\n            // store the current random value\r\n            uint256 rand;\r\n            for(j = 3; j >= 1; j--) {\r\n                traitPos = (i * 4) + j;\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                // 1/4 of a chance of gene swapping forward towards expressing.\r\n                if (rand == 0) {\r\n                    // do it for parent 1\r\n                    swap = genes1Array[traitPos];\r\n                    genes1Array[traitPos] = genes1Array[traitPos - 1];\r\n                    genes1Array[traitPos - 1] = swap;\r\n\r\n                }\r\n\r\n                rand = _sliceNumber(randomN, 2, randomIndex); // 0~3\r\n                randomIndex += 2;\r\n\r\n                if (rand == 0) {\r\n                    // do it for parent 2\r\n                    swap = genes2Array[traitPos];\r\n                    genes2Array[traitPos] = genes2Array[traitPos - 1];\r\n                    genes2Array[traitPos - 1] = swap;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // DEBUG ONLY - We should have used 72 2-bit slices above for the swapping\r\n        // which will have consumed 144 bits.\r\n        // assert(randomIndex == 144);\r\n\r\n        // We have 256 - 144 = 112 bits of randomness left at this point. We will use up to\r\n        // four bits for the first slot of each trait (three for the possible ascension, one\r\n        // to pick between mom and dad if the ascension fails, for a total of 48 bits. The other\r\n        // traits use one bit to pick between parents (36 gene pairs, 36 genes), leaving us\r\n        // well within our entropy budget.\r\n\r\n        // done shuffling parent genes, now let's decide on choosing trait and if ascending.\r\n        // NOTE: Ascensions ONLY happen in the \"top slot\" of each characteristic. This saves\r\n        //  gas and also ensures ascensions only happen when they're visible.\r\n        for(traitPos = 0; traitPos < 48; traitPos++) {\r\n\r\n            // See if this trait pair should ascend\r\n            uint8 ascendedTrait = 0;\r\n\r\n            // There are two checks here. The first is straightforward, only the trait\r\n            // in the first slot can ascend. The first slot is zero mod 4.\r\n            //\r\n            // The second check is more subtle: Only values that are one apart can ascend,\r\n            // which is what we check inside the _ascend method. However, this simple mask\r\n            // and compare is very cheap (9 gas) and will filter out about half of the\r\n            // non-ascending pairs without a function call.\r\n            //\r\n            // The comparison itself just checks that one value is even, and the other\r\n            // is odd.\r\n            if ((traitPos % 4 == 0) && (genes1Array[traitPos] & 1) != (genes2Array[traitPos] & 1)) {\r\n                rand = _sliceNumber(randomN, 3, randomIndex);\r\n                randomIndex += 3;\r\n\r\n                ascendedTrait = _ascend(genes1Array[traitPos], genes2Array[traitPos], rand);\r\n            }\r\n\r\n            if (ascendedTrait > 0) {\r\n                babyArray[traitPos] = uint8(ascendedTrait);\r\n            } else {\r\n                // did not ascend, pick one of the parent's traits for the baby\r\n                // We use the top bit of rand for this (the bottom three bits were used\r\n                // to check for the ascension itself).\r\n                rand = _sliceNumber(randomN, 1, randomIndex);\r\n                randomIndex += 1;\r\n\r\n                if (rand == 0) {\r\n                    babyArray[traitPos] = uint8(genes1Array[traitPos]);\r\n                } else {\r\n                    babyArray[traitPos] = uint8(genes2Array[traitPos]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return encode(babyArray);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_genes1\",\"type\":\"uint256\"},{\"name\":\"_genes2\",\"type\":\"uint256\"},{\"name\":\"_targetBlock\",\"type\":\"uint256\"}],\"name\":\"mixGenes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_traits\",\"type\":\"uint8[]\"}],\"name\":\"encode\",\"outputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isGeneScience\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"decode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"expressingTraits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[12]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"GeneScience","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://02483cc8ee323961b70a731235c3564df45a0ae6eb45983dc9e88e1c38063578"}]}