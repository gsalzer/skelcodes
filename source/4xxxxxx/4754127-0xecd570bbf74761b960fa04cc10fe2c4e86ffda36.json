{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/// Implements ERC20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20Token {\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n    function approve(address _spender, uint _value) public returns (bool);\r\n    function balanceOf(address _owner) public view returns (uint);\r\n    function allowance(address _owner, address _spender) public view returns (uint);    \r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable()\r\n        public\r\n    {        \r\n        owner = msg.sender;\r\n    }\r\n \r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);    \r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        owner = newOwner;\r\n    } \r\n}\r\n\r\n\r\ncontract Freezable is Ownable {\r\n\r\n    mapping (address => bool) public frozenAccount;      \r\n    \r\n    modifier onlyUnfrozen(address _target) {\r\n        assert(!isFrozen(_target));\r\n        _;\r\n    }\r\n    \r\n    // @dev Owners funds are frozen on token creation\r\n    function isFrozen(address _target)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return frozenAccount[_target];\r\n    }\r\n}\r\n\r\ncontract Token is ERC20Token, Freezable {\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowances; \r\n    mapping (address => string) public data;\r\n    uint    public totalSupply;\r\n    uint    public timeTransferbleUntil = 1538262000;                        // Transferable until 29/09/2018 23:00 pm UTC\r\n    bool    public stopped = false;\r\n \r\n    event Burn(address indexed from, uint256 value, string data);\r\n    event LogStop();\r\n\r\n    modifier transferable() {\r\n        assert(!stopped);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Transfers sender's tokens to a given address. Returns success\r\n    /// @param _to Address of token receiver\r\n    /// @param _value Number of tokens to transfer\r\n    /// @return Returns success of function call\r\n    function transfer(address _to, uint _value)\r\n        public      \r\n        onlyUnfrozen(msg.sender)                                           \r\n        transferable()\r\n        returns (bool)        \r\n    {                         \r\n        assert(_to != 0x0);                                                // Prevent transfer to 0x0 address. Use burn() instead\r\n        assert(balances[msg.sender] >= _value);                            // Check if the sender has enough\r\n        assert(!isFrozen(_to));                                            // Do not allow transfers to frozen accounts\r\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); // Subtract from the sender\r\n        balances[_to] = SafeMath.add(balances[_to], _value);               // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                                 // Notify anyone listening that this transfer took place\r\n        return true;       \r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success\r\n    /// @param _from Address from where tokens are withdrawn\r\n    /// @param _to Address to where tokens are sent\r\n    /// @param _value Number of tokens to transfer\r\n    /// @return Returns success of function call\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public    \r\n        onlyUnfrozen(_from)                                               // Owners can never transfer funds\r\n        transferable()                 \r\n        returns (bool)\r\n    {        \r\n        assert(_to != 0x0);                                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        assert(balances[_from] >= _value);                                // Check if the sender has enough\r\n        assert(_value <= allowances[_from][msg.sender]);                  // Check allowance\r\n        assert(!isFrozen(_to));                                           // Do not allow transfers to frozen accounts\r\n        balances[_from] = SafeMath.sub(balances[_from], _value);          // Subtract from the sender\r\n        balances[_to] = SafeMath.add(balances[_to], _value);              // Add the same to the recipient\r\n        allowances[_from][msg.sender] = SafeMath.sub(allowances[_from][msg.sender], _value); \r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success\r\n    /// @param _spender Address of allowed account\r\n    /// @param _value Number of approved tokens\r\n    /// @return Returns success of function call    \r\n    function approve(address _spender, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowances[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns number of allowed tokens for given address\r\n    /// @param _owner Address of token owner\r\n    /// @param _spender Address of token spender\r\n    /// @return Returns remaining allowance for spender    \r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address\r\n    /// @param _owner Address of token owner\r\n    /// @return Returns balance of owner    \r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // @title Burns tokens\r\n    // @dev remove `_value` tokens from the system irreversibly     \r\n    // @param _value the amount of tokens to burn   \r\n    function burn(uint256 _value, string _data) \r\n        public \r\n        returns (bool success) \r\n    {\r\n        assert(_value > 0);                                                // Amount must be greater than zero\r\n        assert(balances[msg.sender] >= _value);                            // Check if the sender has enough\r\n        uint previousTotal = totalSupply;                                  // Start integrity check\r\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); // Subtract from the sender\r\n        data[msg.sender] = _data;                                          // Additional data\r\n        totalSupply = SafeMath.sub(totalSupply, _value);                   // Updates totalSupply\r\n        assert(previousTotal - _value == totalSupply);                     // End integrity check \r\n        Burn(msg.sender, _value, _data);\r\n        return true;\r\n    }\r\n\r\n    // Anyone can freeze the token after transfer time has expired\r\n    function stop() \r\n        public\r\n    {\r\n        assert(now > timeTransferbleUntil);\r\n        stopped = true;\r\n        LogStop();\r\n    }\r\n\r\n    function totalSupply() \r\n        constant public \r\n        returns (uint) \r\n    {\r\n        return totalSupply;\r\n    }\r\n\r\n    function getData(address addr) \r\n        public \r\n        view\r\n        returns (string) \r\n    {\r\n        return data[addr];\r\n    }    \r\n}\r\n\r\n\r\n// Contract Owner 0xb42db275AdCCd23e2cB52CfFc2D4Fe984fbF53B2     \r\ncontract STP is Token {\r\n    string  public name = \"STASHPAY\";\r\n    string  public symbol = \"STP\";\r\n    uint8   public decimals = 8;\r\n    uint8   public publicKeySize = 65;\r\n    address public sale = 0xB155c16c13FC1eD2F015e24D6C7Ae8Cc38cea74E;\r\n    address public adviserAndBounty = 0xf40bF198eD3bE9d3E1312d2717b964b377135728;    \r\n    mapping (address => string) public publicKeys;\r\n    uint256 constant D160 = 0x0010000000000000000000000000000000000000000;    \r\n\r\n    event RegisterKey(address indexed _from, string _publicKey);\r\n    event ModifyPublicKeySize(uint8 _size);\r\n\r\n    function STP()\r\n    public \r\n    {             \r\n        uint256[29] memory owners = [\r\n            uint256(0xb5e620f480007f0dfc26a56b0f7ccd8100eaf31b75dd40bae01f),\r\n            uint256(0x162b3f376600078c63f73a2f46c19a4cd91e700203bbbe4084093),\r\n            uint256(0x16bcc41e900004ae21e3c9b0e63dbc2832f1fa3e6e4dd60f42ae1),\r\n            uint256(0x1c6bf52634000b9b206c23965553889ebdaee326d4da4a457b9b1),\r\n            uint256(0x16bcc41e90000d26061a8d47cc712c61a8fa23ce21d593e50f668),\r\n            uint256(0x110d9316ec000d69106be0299d0a83b9a9e32f2df85ec7739fa59),\r\n            uint256(0x16bcc41e90000d6d813fd0394bfec48996e20d8fbcf55a003c19a),\r\n            uint256(0x1c6bf52634000e34dc2c4481561224114ad004c824b1f9e142e31),\r\n            uint256(0x110d9316ec0006e19b79b974fa039c1356f6814da22b0a04e8d29),\r\n            uint256(0x16bcc41e900005d2f999136e12e54f4a9a873a9d9ab7407591249),\r\n            uint256(0x110d9316ec0002b0013a364a997b9856127fd0ababef72baec159),\r\n            uint256(0x16bcc41e90000db46260f78efa6c904d7dafc5c584ca34d5234be),\r\n            uint256(0x1c6bf5263400073a4077adf235164f4944f138fc9d982ea549eba),\r\n            uint256(0x9184e72a0003617280cabfe0356a2af3cb4f652c3aca3ab8216),\r\n            uint256(0xb5e620f480003d106c1220c49f75ddb8a475b73a1517cef163f6),\r\n            uint256(0x9184e72a000d6aaf14fee58fd90e6518179e94f02b5e0098a78),\r\n            uint256(0x162b3f37660009c98c23e430b4270f47685e46d651b9150272b16),\r\n            uint256(0xb5e620f48000cc3e7d55bba108b07c08d014f13fe0ee5c09ec08),\r\n            uint256(0x110d9316ec000e4a92d9c2c31789250956b1b0b439cf72baf8a27),\r\n            uint256(0x16bcc41e900002edc2b7f7191cf9414d9bf8febdd165b0cd91ee1),\r\n            uint256(0x110d9316ec000332f79ebb69d00cb3f13fcb2be185ed944f64298),\r\n            uint256(0x221b262dd80005594aae7ae31a3316691ab7a11de3ddee2f015e0),\r\n            uint256(0x1c6bf52634000c08b91c50ed4303d1b90ffd47237195e4bfc165e),\r\n            uint256(0x110d9316ec000bf6f7c6a13b9629b673c023e54fba4c2cd4ccbba),\r\n            uint256(0x16bcc41e90000629048b47ed4fb881bacfb7ca85e7275cd663cf7),\r\n            uint256(0x110d9316ec000451861e95aa32ce053f15f6ae013d1eface88e9e),\r\n            uint256(0x16bcc41e9000094d79beb8c57e54ff3fce49ae35078c6df228b9c),\r\n            uint256(0x1c6bf52634000e2b1430b79b5be8bf3c7d70eb4faf36926b369f3),\r\n            uint256(0xb5e620f4800025b772bda67719d2ba404c04fa4390443bf993ed)\r\n        ];\r\n\r\n        /* \r\n            Token Distrubution\r\n            -------------------\r\n            500M Total supply\r\n            72% Token Sale\r\n            20% Founders (frozen for entire duration of contract)\r\n            8% Bounty and advisters\r\n        */\r\n\r\n        totalSupply = 500000000 * 10**uint256(decimals); \r\n        balances[sale] = 360000000 * 10**uint256(decimals); \r\n        balances[adviserAndBounty] = 40000000 * 10**uint256(decimals);\r\n            \r\n        Transfer(0, sale, balances[sale]);\r\n        Transfer(0, adviserAndBounty, balances[adviserAndBounty]);\r\n        \r\n        /* \r\n            Founders are provably frozen for duration of contract            \r\n        */\r\n        uint assignedTokens = balances[sale] + balances[adviserAndBounty];\r\n        for (uint i = 0; i < owners.length; i++) {\r\n            address addr = address(owners[i] & (D160 - 1));                    // get address\r\n            uint256 amount = owners[i] / D160;                                 // get amount\r\n            balances[addr] = SafeMath.add(balances[addr], amount);             // update balance            \r\n            assignedTokens = SafeMath.add(assignedTokens, amount);             // keep track of total assigned\r\n            frozenAccount[addr] = true;                                        // Owners funds are provably frozen for duration of contract\r\n            Transfer(0, addr, amount);                                         // transfer the tokens\r\n        }        \r\n        /*\r\n            balance check \r\n        */\r\n        require(assignedTokens == totalSupply);             \r\n    }  \r\n    \r\n    function registerKey(string publicKey)\r\n    public\r\n    transferable\r\n    { \r\n        assert(balances[msg.sender] > 0);\r\n        assert(bytes(publicKey).length <= publicKeySize);\r\n              \r\n        publicKeys[msg.sender] = publicKey; \r\n        RegisterKey(msg.sender, publicKey);    \r\n    }           \r\n  \r\n    function modifyPublicKeySize(uint8 _publicKeySize)\r\n    public\r\n    onlyOwner\r\n    { \r\n        publicKeySize = _publicKeySize;\r\n    }\r\n\r\n    function multiDistribute(uint256[] data) \r\n    public\r\n    onlyUnfrozen(sale)\r\n    onlyOwner \r\n    {\r\n      for (uint256 i = 0; i < data.length; i++) {\r\n        address addr = address(data[i] & (D160 - 1));\r\n        uint256 amount = data[i] / D160;\r\n        balances[sale] -= amount;                        \r\n        balances[addr] += amount;                                       \r\n        Transfer(sale, addr, amount);    \r\n      }\r\n    }\r\n\r\n    function multiDistributeAdviserBounty(uint256[] data, bool freeze) \r\n    public\r\n    onlyOwner\r\n    {\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            address addr = address(data[i] & (D160 - 1));\r\n            uint256 amount = data[i] / D160;\r\n            distributeAdviserBounty(addr, amount, freeze);\r\n        }\r\n    }\r\n   \r\n    function distributeAdviserBounty(address addr, uint256 amount, bool freeze)\r\n    public        \r\n    onlyOwner \r\n    {   \r\n        // can only freeze when no balance exists        \r\n        frozenAccount[addr] = freeze && balances[addr] == 0;\r\n\r\n        balances[addr] = SafeMath.add(balances[addr], amount);\r\n        balances[adviserAndBounty] = SafeMath.sub(balances[adviserAndBounty], amount);\r\n        Transfer(adviserAndBounty, addr, amount);           \r\n    }\r\n\r\n    /// @dev when token distrubution is complete freeze any remaining tokens\r\n    function distributionComplete()\r\n    public\r\n    onlyOwner\r\n    {\r\n        frozenAccount[sale] = true;\r\n    }\r\n\r\n    function setName(string _name)\r\n    public \r\n    onlyOwner \r\n    {\r\n        name = _name;\r\n    }\r\n\r\n    function setSymbol(string _symbol)\r\n    public \r\n    onlyOwner \r\n    {\r\n        symbol = _symbol;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributionComplete\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicKeySize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getData\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"distributeAdviserBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"publicKey\",\"type\":\"string\"}],\"name\":\"registerKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeTransferbleUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"string\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"uint256[]\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"multiDistributeAdviserBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"publicKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_publicKeySize\",\"type\":\"uint8\"}],\"name\":\"modifyPublicKeySize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"data\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adviserAndBounty\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"isFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"multiDistribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_publicKey\",\"type\":\"string\"}],\"name\":\"RegisterKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_size\",\"type\":\"uint8\"}],\"name\":\"ModifyPublicKeySize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"string\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"STP","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://98f22befa23d6ae2884fe3342f5ad8588b96f2ccff65732e834b1b8c192be9bf"}]}