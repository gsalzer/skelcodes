{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\ncontract Storage {\r\n    struct Crate {\r\n        mapping(bytes32 => uint256) uints;\r\n        mapping(bytes32 => address) addresses;\r\n        mapping(bytes32 => bool) bools;\r\n        mapping(address => uint256) bals;\r\n    }\r\n\r\n    mapping(bytes32 => Crate) crates;\r\n\r\n    function setUInt(bytes32 _crate, bytes32 _key, uint256 _value)  {\r\n        crates[_crate].uints[_key] = _value;\r\n    }\r\n\r\n    function getUInt(bytes32 _crate, bytes32 _key) constant returns(uint256) {\r\n        return crates[_crate].uints[_key];\r\n    }\r\n\r\n    function setAddress(bytes32 _crate, bytes32 _key, address _value)  {\r\n        crates[_crate].addresses[_key] = _value;\r\n    }\r\n\r\n    function getAddress(bytes32 _crate, bytes32 _key) constant returns(address) {\r\n        return crates[_crate].addresses[_key];\r\n    }\r\n\r\n    function setBool(bytes32 _crate, bytes32 _key, bool _value)  {\r\n        crates[_crate].bools[_key] = _value;\r\n    }\r\n\r\n    function getBool(bytes32 _crate, bytes32 _key) constant returns(bool) {\r\n        return crates[_crate].bools[_key];\r\n    }\r\n\r\n    function setBal(bytes32 _crate, address _key, uint256 _value)  {\r\n        crates[_crate].bals[_key] = _value;\r\n    }\r\n\r\n    function getBal(bytes32 _crate, address _key) constant returns(uint256) {\r\n        return crates[_crate].bals[_key];\r\n    }\r\n}\r\n\r\ncontract StorageEnabled {\r\n\r\n  // satelite contract addresses\r\n  address public storageAddr;\r\n\r\n  function StorageEnabled(address _storageAddr) {\r\n    storageAddr = _storageAddr;\r\n  }\r\n\r\n\r\n  // ############################################\r\n  // ########### NUTZ FUNCTIONS  ################\r\n  // ############################################\r\n\r\n\r\n  // all Nutz balances\r\n  function babzBalanceOf(address _owner) constant returns (uint256) {\r\n    return Storage(storageAddr).getBal('Nutz', _owner);\r\n  }\r\n  function _setBabzBalanceOf(address _owner, uint256 _newValue) internal {\r\n    Storage(storageAddr).setBal('Nutz', _owner, _newValue);\r\n  }\r\n  // active supply - sum of balances above\r\n  function activeSupply() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Nutz', 'activeSupply');\r\n  }\r\n  function _setActiveSupply(uint256 _newActiveSupply) internal {\r\n    Storage(storageAddr).setUInt('Nutz', 'activeSupply', _newActiveSupply);\r\n  }\r\n  // burn pool - inactive supply\r\n  function burnPool() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Nutz', 'burnPool');\r\n  }\r\n  function _setBurnPool(uint256 _newBurnPool) internal {\r\n    Storage(storageAddr).setUInt('Nutz', 'burnPool', _newBurnPool);\r\n  }\r\n  // power pool - inactive supply\r\n  function powerPool() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Nutz', 'powerPool');\r\n  }\r\n  function _setPowerPool(uint256 _newPowerPool) internal {\r\n    Storage(storageAddr).setUInt('Nutz', 'powerPool', _newPowerPool);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  // ############################################\r\n  // ########### POWER   FUNCTIONS  #############\r\n  // ############################################\r\n\r\n  // all power balances\r\n  function powerBalanceOf(address _owner) constant returns (uint256) {\r\n    return Storage(storageAddr).getBal('Power', _owner);\r\n  }\r\n\r\n  function _setPowerBalanceOf(address _owner, uint256 _newValue) internal {\r\n    Storage(storageAddr).setBal('Power', _owner, _newValue);\r\n  }\r\n\r\n  function outstandingPower() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Power', 'outstandingPower');\r\n  }\r\n\r\n  function _setOutstandingPower(uint256 _newOutstandingPower) internal {\r\n    Storage(storageAddr).setUInt('Power', 'outstandingPower', _newOutstandingPower);\r\n  }\r\n\r\n  function authorizedPower() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Power', 'authorizedPower');\r\n  }\r\n\r\n  function _setAuthorizedPower(uint256 _newAuthorizedPower) internal {\r\n    Storage(storageAddr).setUInt('Power', 'authorizedPower', _newAuthorizedPower);\r\n  }\r\n\r\n\r\n  function downs(address _user) constant public returns (uint256 total, uint256 left, uint256 start) {\r\n    uint256 rawBytes = Storage(storageAddr).getBal('PowerDown', _user);\r\n    start = uint64(rawBytes);\r\n    left = uint96(rawBytes >> (64));\r\n    total = uint96(rawBytes >> (96 + 64));\r\n    return;\r\n  }\r\n\r\n  function _setDownRequest(address _holder, uint256 total, uint256 left, uint256 start) internal {\r\n    uint256 result = uint64(start) + (left << 64) + (total << (96 + 64));\r\n    Storage(storageAddr).setBal('PowerDown', _holder, result);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Governable {\r\n\r\n  // list of admins, council at first spot\r\n  address[] public admins;\r\n\r\n  function Governable() {\r\n    admins.length = 1;\r\n    admins[0] = msg.sender;\r\n  }\r\n\r\n  modifier onlyAdmins() {\r\n    bool isAdmin = false;\r\n    for (uint256 i = 0; i < admins.length; i++) {\r\n      if (msg.sender == admins[i]) {\r\n        isAdmin = true;\r\n      }\r\n    }\r\n    require(isAdmin == true);\r\n    _;\r\n  }\r\n\r\n  function addAdmin(address _admin) public onlyAdmins {\r\n    for (uint256 i = 0; i < admins.length; i++) {\r\n      require(_admin != admins[i]);\r\n    }\r\n    require(admins.length < 10);\r\n    admins[admins.length++] = _admin;\r\n  }\r\n\r\n  function removeAdmin(address _admin) public onlyAdmins {\r\n    uint256 pos = admins.length;\r\n    for (uint256 i = 0; i < admins.length; i++) {\r\n      if (_admin == admins[i]) {\r\n        pos = i;\r\n      }\r\n    }\r\n    require(pos < admins.length);\r\n    // if not last element, switch with last\r\n    if (pos < admins.length - 1) {\r\n      admins[pos] = admins[admins.length - 1];\r\n    }\r\n    // then cut off the tail\r\n    admins.length--;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Governable {\r\n\r\n  bool public paused = true;\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyAdmins whenNotPaused {\r\n    paused = true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyAdmins whenPaused {\r\n    //TODO: do some checks\r\n    paused = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract NutzEnabled is Pausable, StorageEnabled {\r\n  using SafeMath for uint;\r\n\r\n  // satelite contract addresses\r\n  address public nutzAddr;\r\n\r\n\r\n  modifier onlyNutz() {\r\n    require(msg.sender == nutzAddr);\r\n    _;\r\n  }\r\n\r\n  function NutzEnabled(address _nutzAddr, address _storageAddr)\r\n    StorageEnabled(_storageAddr) {\r\n    nutzAddr = _nutzAddr;\r\n  }\r\n\r\n  // ############################################\r\n  // ########### NUTZ FUNCTIONS  ################\r\n  // ############################################\r\n\r\n  // total supply\r\n  function totalSupply() constant returns (uint256) {\r\n    return activeSupply().add(powerPool()).add(burnPool());\r\n  }\r\n\r\n  // allowances according to ERC20\r\n  // not written to storage, as not very critical\r\n  mapping (address => mapping (address => uint)) internal allowed;\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  function approve(address _owner, address _spender, uint256 _amountBabz) public onlyNutz whenNotPaused {\r\n    require(_owner != _spender);\r\n    allowed[_owner][_spender] = _amountBabz;\r\n  }\r\n\r\n  function _transfer(address _from, address _to, uint256 _amountBabz, bytes _data) internal {\r\n    require(_to != address(this));\r\n    require(_to != address(0));\r\n    require(_amountBabz > 0);\r\n    require(_from != _to);\r\n    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\r\n    _setBabzBalanceOf(_to, babzBalanceOf(_to).add(_amountBabz));\r\n  }\r\n\r\n  function transfer(address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused {\r\n    _transfer(_from, _to, _amountBabz, _data);\r\n  }\r\n\r\n  function transferFrom(address _sender, address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused {\r\n    allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz);\r\n    _transfer(_from, _to, _amountBabz, _data);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments.\r\n */\r\ncontract PullPayment {\r\n\r\n  modifier onlyNutz() {\r\n      _;\r\n  }\r\n  \r\nmodifier onlyOwner() {\r\n      _;\r\n  }\r\n\r\n  modifier whenNotPaused () {_;}\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 value);\r\n\r\n  function paymentOf(address _owner) constant returns (uint256 value, uint256 date) ;\r\n\r\n  /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\r\n  /// @param _dailyLimit Amount in wei.\r\n  function changeDailyLimit(uint _dailyLimit) public ;\r\n\r\n  function changeWithdrawalDate(address _owner, uint256 _newDate)  public ;\r\n\r\n  function asyncSend(address _dest) public payable ;\r\n\r\n\r\n  function withdraw() public ;\r\n\r\n  /*\r\n   * Internal functions\r\n   */\r\n  /// @dev Returns if amount is within daily limit and resets spentToday after one day.\r\n  /// @param amount Amount to withdraw.\r\n  /// @return Returns if amount is under daily limit.\r\n  function isUnderLimit(uint amount) internal returns (bool);\r\n\r\n}\r\n\r\n\r\n/**\r\n * Nutz implements a price floor and a price ceiling on the token being\r\n * sold. It is based of the zeppelin token contract.\r\n */\r\ncontract Nutz {\r\n\r\n\r\n  // returns balances of active holders\r\n  function balanceOf(address _owner) constant returns (uint);\r\n\r\n  function totalSupply() constant returns (uint256);\r\n\r\n  function activeSupply() constant returns (uint256);\r\n\r\n  // return remaining allowance\r\n  // if calling return allowed[address(this)][_spender];\r\n  // returns balance of ether parked to be withdrawn\r\n  function allowance(address _owner, address _spender) constant returns (uint256);\r\n\r\n  // returns either the salePrice, or if reserve does not suffice\r\n  // for active supply, returns maxFloor\r\n  function floor() constant returns (uint256);\r\n\r\n  // returns either the salePrice, or if reserve does not suffice\r\n  // for active supply, returns maxFloor\r\n  function ceiling() constant returns (uint256);\r\n\r\n  function powerPool() constant returns (uint256);\r\n\r\n\r\n  function _checkDestination(address _from, address _to, uint256 _value, bytes _data) internal;\r\n\r\n\r\n\r\n  // ############################################\r\n  // ########### ADMIN FUNCTIONS ################\r\n  // ############################################\r\n\r\n  function powerDown(address powerAddr, address _holder, uint256 _amountBabz) public ;\r\n\r\n\r\n  function asyncSend(address _pullAddr, address _dest, uint256 _amountWei) public ;\r\n\r\n\r\n  // ############################################\r\n  // ########### PUBLIC FUNCTIONS ###############\r\n  // ############################################\r\n\r\n  function approve(address _spender, uint256 _amountBabz) public;\r\n\r\n  function transfer(address _to, uint256 _amountBabz, bytes _data) public returns (bool);\r\n\r\n  function transfer(address _to, uint256 _amountBabz) public returns (bool);\r\n\r\n  function transData(address _to, uint256 _amountBabz, bytes _data) public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _amountBabz, bytes _data) public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _amountBabz);\r\n\r\n  function () public payable;\r\n\r\n  function purchase(uint256 _price) public payable;\r\n\r\n  function sell(uint256 _price, uint256 _amountBabz);\r\n\r\n  function powerUp(uint256 _amountBabz) public;\r\n\r\n}\r\n\r\n\r\ncontract MarketEnabled is NutzEnabled {\r\n\r\n  uint256 constant INFINITY = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n  // address of the pull payemnt satelite\r\n  address public pullAddr;\r\n\r\n  // the Token sale mechanism parameters:\r\n  // purchasePrice is the number of NTZ received for purchase with 1 ETH\r\n  uint256 internal purchasePrice;\r\n\r\n  // floor is the number of NTZ needed, to receive 1 ETH in sell\r\n  uint256 internal salePrice;\r\n\r\n  function MarketEnabled(address _pullAddr, address _storageAddr, address _nutzAddr)\r\n    NutzEnabled(_nutzAddr, _storageAddr) {\r\n    pullAddr = _pullAddr;\r\n  }\r\n\r\n\r\n  function ceiling() constant returns (uint256) {\r\n    return purchasePrice;\r\n  }\r\n\r\n  // returns either the salePrice, or if reserve does not suffice\r\n  // for active supply, returns maxFloor\r\n  function floor() constant returns (uint256) {\r\n    if (nutzAddr.balance == 0) {\r\n      return INFINITY;\r\n    }\r\n    uint256 maxFloor = activeSupply().mul(1000000).div(nutzAddr.balance); // 1,000,000 WEI, used as price factor\r\n    // return max of maxFloor or salePrice\r\n    return maxFloor >= salePrice ? maxFloor : salePrice;\r\n  }\r\n\r\n  function moveCeiling(uint256 _newPurchasePrice) public onlyAdmins {\r\n    require(_newPurchasePrice <= salePrice);\r\n    purchasePrice = _newPurchasePrice;\r\n  }\r\n\r\n  function moveFloor(uint256 _newSalePrice) public onlyAdmins {\r\n    require(_newSalePrice >= purchasePrice);\r\n    // moveFloor fails if the administrator tries to push the floor so low\r\n    // that the sale mechanism is no longer able to buy back all tokens at\r\n    // the floor price if those funds were to be withdrawn.\r\n    if (_newSalePrice < INFINITY) {\r\n      require(nutzAddr.balance >= activeSupply().mul(1000000).div(_newSalePrice)); // 1,000,000 WEI, used as price factor\r\n    }\r\n    salePrice = _newSalePrice;\r\n  }\r\n\r\n  function purchase(address _sender, uint256 _value, uint256 _price) public onlyNutz whenNotPaused returns (uint256) {\r\n    // disable purchases if purchasePrice set to 0\r\n    require(purchasePrice > 0);\r\n    require(_price == purchasePrice);\r\n\r\n    uint256 amountBabz = purchasePrice.mul(_value).div(1000000); // 1,000,000 WEI, used as price factor\r\n    // avoid deposits that issue nothing\r\n    // might happen with very high purchase price\r\n    require(amountBabz > 0);\r\n\r\n    // make sure power pool grows proportional to economy\r\n    uint256 activeSup = activeSupply();\r\n    uint256 powPool = powerPool();\r\n    if (powPool > 0) {\r\n      uint256 powerShare = powPool.mul(amountBabz).div(activeSup.add(burnPool()));\r\n      _setPowerPool(powPool.add(powerShare));\r\n    }\r\n    _setActiveSupply(activeSup.add(amountBabz));\r\n    _setBabzBalanceOf(_sender, babzBalanceOf(_sender).add(amountBabz));\r\n    return amountBabz;\r\n  }\r\n\r\n  function sell(address _from, uint256 _price, uint256 _amountBabz) public onlyNutz whenNotPaused {\r\n    uint256 effectiveFloor = floor();\r\n    require(_amountBabz != 0);\r\n    require(effectiveFloor != INFINITY);\r\n    require(_price == effectiveFloor);\r\n\r\n    uint256 amountWei = _amountBabz.mul(1000000).div(effectiveFloor);  // 1,000,000 WEI, used as price factor\r\n    require(amountWei > 0);\r\n    // make sure power pool shrinks proportional to economy\r\n    uint256 powPool = powerPool();\r\n    uint256 activeSup = activeSupply();\r\n    if (powPool > 0) {\r\n      uint256 powerShare = powPool.mul(_amountBabz).div(activeSup);\r\n      _setPowerPool(powPool.sub(powerShare));\r\n    }\r\n    _setActiveSupply(activeSup.sub(_amountBabz));\r\n    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\r\n    Nutz(nutzAddr).asyncSend(pullAddr, _from, amountWei);\r\n  }\r\n\r\n\r\n  // withdraw excessive reserve - i.e. milestones\r\n  function allocateEther(uint256 _amountWei, address _beneficiary) public onlyAdmins {\r\n    require(_amountWei > 0);\r\n    // allocateEther fails if allocating those funds would mean that the\r\n    // sale mechanism is no longer able to buy back all tokens at the floor\r\n    // price if those funds were to be withdrawn.\r\n    require(nutzAddr.balance.sub(_amountWei) >= activeSupply().mul(1000000).div(salePrice)); // 1,000,000 WEI, used as price factor\r\n    Nutz(nutzAddr).asyncSend(pullAddr, _beneficiary, _amountWei);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract Power {\r\n\r\n\r\n\r\n  function balanceOf(address _holder) constant returns (uint256);\r\n\r\n  function totalSupply() constant returns (uint256);\r\n\r\n  function activeSupply() constant returns (uint256);\r\n\r\n\r\n  // ############################################\r\n  // ########### ADMIN FUNCTIONS ################\r\n  // ############################################\r\n\r\n  function slashPower(address _holder, uint256 _value, bytes32 _data) public ;\r\n\r\n  function powerUp(address _holder, uint256 _value) public ;\r\n\r\n  // ############################################\r\n  // ########### PUBLIC FUNCTIONS ###############\r\n  // ############################################\r\n\r\n  // registers a powerdown request\r\n  function transfer(address _to, uint256 _amountPower) public returns (bool success);\r\n\r\n  function downtime() public returns (uint256);\r\n\r\n  function downTick(address _owner) public;\r\n\r\n  function downs(address _owner) constant public returns (uint256, uint256, uint256);\r\n\r\n}\r\n\r\n\r\ncontract PowerEnabled is MarketEnabled {\r\n\r\n  // satelite contract addresses\r\n  address public powerAddr;\r\n\r\n  // maxPower is a limit of total power that can be outstanding\r\n  // maxPower has a valid value between outstandingPower and authorizedPow/2\r\n  uint256 public maxPower = 0;\r\n\r\n  // time it should take to power down\r\n  uint256 public downtime;\r\n\r\n  modifier onlyPower() {\r\n    require(msg.sender == powerAddr);\r\n    _;\r\n  }\r\n\r\n  function PowerEnabled(address _powerAddr, address _pullAddr, address _storageAddr, address _nutzAddr)\r\n    MarketEnabled(_pullAddr, _nutzAddr, _storageAddr) {\r\n    powerAddr = _powerAddr;\r\n  }\r\n\r\n  function setMaxPower(uint256 _maxPower) public onlyAdmins {\r\n    require(outstandingPower() <= _maxPower && _maxPower < authorizedPower());\r\n    maxPower = _maxPower;\r\n  }\r\n\r\n  function setDowntime(uint256 _downtime) public onlyAdmins {\r\n    downtime = _downtime;\r\n  }\r\n\r\n  // this is called when NTZ are deposited into the burn pool\r\n  function dilutePower(uint256 _amountBabz, uint256 _amountPower) public onlyAdmins {\r\n    uint256 authorizedPow = authorizedPower();\r\n    uint256 totalBabz = totalSupply();\r\n    if (authorizedPow == 0) {\r\n      // during the first capital increase, set value directly as authorized shares\r\n      _setAuthorizedPower((_amountPower > 0) ? _amountPower : _amountBabz.add(totalBabz));\r\n    } else {\r\n      // in later increases, expand authorized shares at same rate like economy\r\n      _setAuthorizedPower(authorizedPow.mul(totalBabz.add(_amountBabz)).div(totalBabz));\r\n    }\r\n    _setBurnPool(burnPool().add(_amountBabz));\r\n  }\r\n\r\n  function _slashPower(address _holder, uint256 _value, bytes32 _data) internal {\r\n    uint256 previouslyOutstanding = outstandingPower();\r\n    _setOutstandingPower(previouslyOutstanding.sub(_value));\r\n    // adjust size of power pool\r\n    uint256 powPool = powerPool();\r\n    uint256 slashingBabz = _value.mul(powPool).div(previouslyOutstanding);\r\n    _setPowerPool(powPool.sub(slashingBabz));\r\n    // put event into satelite contract\r\n    Power(powerAddr).slashPower(_holder, _value, _data);\r\n  }\r\n\r\n  function slashPower(address _holder, uint256 _value, bytes32 _data) public onlyAdmins {\r\n    _setPowerBalanceOf(_holder, powerBalanceOf(_holder).sub(_value));\r\n    _slashPower(_holder, _value, _data);\r\n  }\r\n\r\n  function slashDownRequest(uint256 _pos, address _holder, uint256 _value, bytes32 _data) public onlyAdmins {\r\n    var (total, left, start) = downs(_holder);\r\n    left = left.sub(_value);\r\n    _setDownRequest(_holder, total, left, start);\r\n    _slashPower(_holder, _value, _data);\r\n  }\r\n\r\n  // this is called when NTZ are deposited into the power pool\r\n  function powerUp(address _sender, address _from, uint256 _amountBabz) public onlyNutz whenNotPaused {\r\n    uint256 authorizedPow = authorizedPower();\r\n    require(authorizedPow != 0);\r\n    require(_amountBabz != 0);\r\n    uint256 totalBabz = totalSupply();\r\n    require(totalBabz != 0);\r\n    uint256 amountPow = _amountBabz.mul(authorizedPow).div(totalBabz);\r\n    // check pow limits\r\n    uint256 outstandingPow = outstandingPower();\r\n    require(outstandingPow.add(amountPow) <= maxPower);\r\n\r\n    if (_sender != _from) {\r\n      allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz);\r\n    }\r\n\r\n    _setOutstandingPower(outstandingPow.add(amountPow));\r\n\r\n    uint256 powBal = powerBalanceOf(_from).add(amountPow);\r\n    require(powBal >= authorizedPow.div(10000)); // minShare = 10000\r\n    _setPowerBalanceOf(_from, powBal);\r\n    _setActiveSupply(activeSupply().sub(_amountBabz));\r\n    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\r\n    _setPowerPool(powerPool().add(_amountBabz));\r\n    Power(powerAddr).powerUp(_from, amountPow);\r\n  }\r\n\r\n  function powerTotalSupply() constant returns (uint256) {\r\n    uint256 issuedPower = authorizedPower().div(2);\r\n    // return max of maxPower or issuedPower\r\n    return maxPower >= issuedPower ? maxPower : issuedPower;\r\n  }\r\n\r\n  function _vestedDown(uint256 _total, uint256 _left, uint256 _start, uint256 _now) internal constant returns (uint256) {\r\n    if (_now <= _start) {\r\n      return 0;\r\n    }\r\n    // calculate amountVested\r\n    // amountVested is amount that can be withdrawn according to time passed\r\n    uint256 timePassed = _now.sub(_start);\r\n    if (timePassed > downtime) {\r\n     timePassed = downtime;\r\n    }\r\n    uint256 amountVested = _total.mul(timePassed).div(downtime);\r\n    uint256 amountFrozen = _total.sub(amountVested);\r\n    if (_left <= amountFrozen) {\r\n      return 0;\r\n    }\r\n    return _left.sub(amountFrozen);\r\n  }\r\n\r\n  function createDownRequest(address _owner, uint256 _amountPower) public onlyPower whenNotPaused {\r\n    // prevent powering down tiny amounts\r\n    // when powering down, at least totalSupply/minShare Power should be claimed\r\n    require(_amountPower >= authorizedPower().div(10000)); // minShare = 10000;\r\n    _setPowerBalanceOf(_owner, powerBalanceOf(_owner).sub(_amountPower));\r\n\r\n    var (, left, ) = downs(_owner);\r\n    uint256 total = _amountPower.add(left);\r\n    _setDownRequest(_owner, total, total, now);\r\n  }\r\n\r\n  // executes a powerdown request\r\n  function downTick(address _holder, uint256 _now) public onlyPower whenNotPaused {\r\n    var (total, left, start) = downs(_holder);\r\n    uint256 amountPow = _vestedDown(total, left, start, _now);\r\n\r\n    // prevent power down in tiny steps\r\n    uint256 minStep = total.div(10);\r\n    require(left <= minStep || minStep <= amountPow);\r\n\r\n    // calculate token amount representing share of power\r\n    uint256 amountBabz = amountPow.mul(totalSupply()).div(authorizedPower());\r\n\r\n    // transfer power and tokens\r\n    _setOutstandingPower(outstandingPower().sub(amountPow));\r\n    left = left.sub(amountPow);\r\n    _setPowerPool(powerPool().sub(amountBabz));\r\n    _setActiveSupply(activeSupply().add(amountBabz));\r\n    _setBabzBalanceOf(_holder, babzBalanceOf(_holder).add(amountBabz));\r\n    // down request completed\r\n    if (left == 0) {\r\n      start = 0;\r\n      total = 0;\r\n    }\r\n    // TODO\r\n    _setDownRequest(_holder, total, left, start);\r\n    Nutz(nutzAddr).powerDown(powerAddr, _holder, amountBabz);\r\n  }\r\n}\r\n\r\n\r\ncontract Controller is PowerEnabled {\r\n\r\n  function Controller(address _powerAddr, address _pullAddr, address _nutzAddr, address _storageAddr) \r\n    PowerEnabled(_powerAddr, _pullAddr, _nutzAddr, _storageAddr) {\r\n  }\r\n\r\n  function setContracts(address _storageAddr, address _nutzAddr, address _powerAddr, address _pullAddr) public onlyAdmins whenPaused {\r\n    storageAddr = _storageAddr;\r\n    nutzAddr = _nutzAddr;\r\n    powerAddr = _powerAddr;\r\n    pullAddr = _pullAddr;\r\n  }\r\n\r\n  function changeDailyLimit(uint256 _dailyLimit) public onlyAdmins {\r\n    PullPayment(pullAddr).changeDailyLimit(_dailyLimit);\r\n  }\r\n\r\n  function kill(address _newController) public onlyAdmins whenPaused {\r\n    if (powerAddr != address(0)) { Ownable(powerAddr).transferOwnership(msg.sender); }\r\n    if (pullAddr != address(0)) { Ownable(pullAddr).transferOwnership(msg.sender); }\r\n    if (nutzAddr != address(0)) { Ownable(nutzAddr).transferOwnership(msg.sender); }\r\n    if (storageAddr != address(0)) { Ownable(storageAddr).transferOwnership(msg.sender); }\r\n    selfdestruct(_newController);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"nutzAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amountBabz\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"powerBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"slashPower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"powerPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"floor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountWei\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"allocateEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"downs\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"left\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"powerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amountBabz\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pullAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxPower\",\"type\":\"uint256\"}],\"name\":\"setMaxPower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pos\",\"type\":\"uint256\"},{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"slashDownRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_amountBabz\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPurchasePrice\",\"type\":\"uint256\"}],\"name\":\"moveCeiling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_amountPower\",\"type\":\"uint256\"}],\"name\":\"createDownRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceiling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountBabz\",\"type\":\"uint256\"},{\"name\":\"_amountPower\",\"type\":\"uint256\"}],\"name\":\"dilutePower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amountBabz\",\"type\":\"uint256\"}],\"name\":\"powerUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"storageAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"downTick\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"powerTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"babzBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_downtime\",\"type\":\"uint256\"}],\"name\":\"setDowntime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_storageAddr\",\"type\":\"address\"},{\"name\":\"_nutzAddr\",\"type\":\"address\"},{\"name\":\"_powerAddr\",\"type\":\"address\"},{\"name\":\"_pullAddr\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dailyLimit\",\"type\":\"uint256\"}],\"name\":\"changeDailyLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSalePrice\",\"type\":\"uint256\"}],\"name\":\"moveFloor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amountBabz\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"outstandingPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorizedPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"downtime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_powerAddr\",\"type\":\"address\"},{\"name\":\"_pullAddr\",\"type\":\"address\"},{\"name\":\"_nutzAddr\",\"type\":\"address\"},{\"name\":\"_storageAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Controller","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000014b233a46cd4bdfdb7ca29aa0fd2406f667f8ff600000000000000000000000069cca8df17623f18a001b96ba4d958ce72bc6bdc000000000000000000000000e1eda226759825e236831714bcdc0ca0b21fd862000000000000000000000000965757249ED04f11F3180170dC5Edf4341189DE7","Library":"","SwarmSource":"bzzr://a97995ef644c8b7ff20c7991754aa3c2c239c860d7ce4588602f1acc4c94d7c2"}]}