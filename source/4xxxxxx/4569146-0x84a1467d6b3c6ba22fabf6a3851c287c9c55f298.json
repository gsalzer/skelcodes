{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n\r\ncontract PullPayInterface {\r\n  function asyncSend(address _dest) public payable;\r\n}\r\n\r\ncontract Governable {\r\n\r\n  // list of admins, council at first spot\r\n  address[] public admins;\r\n\r\n  function Governable() {\r\n    admins.length = 1;\r\n    admins[0] = msg.sender;\r\n  }\r\n\r\n  modifier onlyAdmins() {\r\n    bool isAdmin = false;\r\n    for (uint256 i = 0; i < admins.length; i++) {\r\n      if (msg.sender == admins[i]) {\r\n        isAdmin = true;\r\n      }\r\n    }\r\n    require(isAdmin == true);\r\n    _;\r\n  }\r\n\r\n  function addAdmin(address _admin) public onlyAdmins {\r\n    for (uint256 i = 0; i < admins.length; i++) {\r\n      require(_admin != admins[i]);\r\n    }\r\n    require(admins.length < 10);\r\n    admins[admins.length++] = _admin;\r\n  }\r\n\r\n  function removeAdmin(address _admin) public onlyAdmins {\r\n    uint256 pos = admins.length;\r\n    for (uint256 i = 0; i < admins.length; i++) {\r\n      if (_admin == admins[i]) {\r\n        pos = i;\r\n      }\r\n    }\r\n    require(pos < admins.length);\r\n    // if not last element, switch with last\r\n    if (pos < admins.length - 1) {\r\n      admins[pos] = admins[admins.length - 1];\r\n    }\r\n    // then cut off the tail\r\n    admins.length--;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract StorageEnabled {\r\n\r\n  // satelite contract addresses\r\n  address public storageAddr;\r\n\r\n  function StorageEnabled(address _storageAddr) {\r\n    storageAddr = _storageAddr;\r\n  }\r\n\r\n\r\n  // ############################################\r\n  // ########### NUTZ FUNCTIONS  ################\r\n  // ############################################\r\n\r\n\r\n  // all Nutz balances\r\n  function babzBalanceOf(address _owner) constant returns (uint256) {\r\n    return Storage(storageAddr).getBal('Nutz', _owner);\r\n  }\r\n  function _setBabzBalanceOf(address _owner, uint256 _newValue) internal {\r\n    Storage(storageAddr).setBal('Nutz', _owner, _newValue);\r\n  }\r\n  // active supply - sum of balances above\r\n  function activeSupply() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Nutz', 'activeSupply');\r\n  }\r\n  function _setActiveSupply(uint256 _newActiveSupply) internal {\r\n    Storage(storageAddr).setUInt('Nutz', 'activeSupply', _newActiveSupply);\r\n  }\r\n  // burn pool - inactive supply\r\n  function burnPool() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Nutz', 'burnPool');\r\n  }\r\n  function _setBurnPool(uint256 _newBurnPool) internal {\r\n    Storage(storageAddr).setUInt('Nutz', 'burnPool', _newBurnPool);\r\n  }\r\n  // power pool - inactive supply\r\n  function powerPool() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Nutz', 'powerPool');\r\n  }\r\n  function _setPowerPool(uint256 _newPowerPool) internal {\r\n    Storage(storageAddr).setUInt('Nutz', 'powerPool', _newPowerPool);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  // ############################################\r\n  // ########### POWER   FUNCTIONS  #############\r\n  // ############################################\r\n\r\n  // all power balances\r\n  function powerBalanceOf(address _owner) constant returns (uint256) {\r\n    return Storage(storageAddr).getBal('Power', _owner);\r\n  }\r\n\r\n  function _setPowerBalanceOf(address _owner, uint256 _newValue) internal {\r\n    Storage(storageAddr).setBal('Power', _owner, _newValue);\r\n  }\r\n\r\n  function outstandingPower() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Power', 'outstandingPower');\r\n  }\r\n\r\n  function _setOutstandingPower(uint256 _newOutstandingPower) internal {\r\n    Storage(storageAddr).setUInt('Power', 'outstandingPower', _newOutstandingPower);\r\n  }\r\n\r\n  function authorizedPower() constant returns (uint256) {\r\n    return Storage(storageAddr).getUInt('Power', 'authorizedPower');\r\n  }\r\n\r\n  function _setAuthorizedPower(uint256 _newAuthorizedPower) internal {\r\n    Storage(storageAddr).setUInt('Power', 'authorizedPower', _newAuthorizedPower);\r\n  }\r\n\r\n\r\n  function downs(address _user) constant public returns (uint256 total, uint256 left, uint256 start) {\r\n    uint256 rawBytes = Storage(storageAddr).getBal('PowerDown', _user);\r\n    start = uint64(rawBytes);\r\n    left = uint96(rawBytes >> (64));\r\n    total = uint96(rawBytes >> (96 + 64));\r\n    return;\r\n  }\r\n\r\n  function _setDownRequest(address _holder, uint256 total, uint256 left, uint256 start) internal {\r\n    uint256 result = uint64(start) + (left << 64) + (total << (96 + 64));\r\n    Storage(storageAddr).setBal('PowerDown', _holder, result);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Governable {\r\n\r\n  bool public paused = true;\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyAdmins whenNotPaused {\r\n    paused = true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyAdmins whenPaused {\r\n    //TODO: do some checks\r\n    paused = false;\r\n  }\r\n\r\n}\r\n\r\n\r\n/*\r\n * ERC20Basic\r\n * Simpler version of ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() constant returns (uint256);\r\n  function balanceOf(address _owner) constant returns (uint256);\r\n  function transfer(address _to, uint256 _value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC223Basic is ERC20Basic {\r\n    function transfer(address to, uint value, bytes data) returns (bool);\r\n}\r\n\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC223Basic {\r\n  // active supply of tokens\r\n  function activeSupply() constant returns (uint256);\r\n  function allowance(address _owner, address _spender) constant returns (uint256);\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool);\r\n  function approve(address _spender, uint256 _value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Power is Ownable, ERC20Basic {\r\n\r\n  event Slashing(address indexed holder, uint value, bytes32 data);\r\n\r\n  string public name = \"Acebusters Power\";\r\n  string public symbol = \"ABP\";\r\n  uint256 public decimals = 12;\r\n\r\n\r\n  function balanceOf(address _holder) constant returns (uint256) {\r\n    return ControllerInterface(owner).powerBalanceOf(_holder);\r\n  }\r\n\r\n  function totalSupply() constant returns (uint256) {\r\n    return ControllerInterface(owner).powerTotalSupply();\r\n  }\r\n\r\n  function activeSupply() constant returns (uint256) {\r\n    return ControllerInterface(owner).outstandingPower();\r\n  }\r\n\r\n\r\n  // ############################################\r\n  // ########### ADMIN FUNCTIONS ################\r\n  // ############################################\r\n\r\n  function slashPower(address _holder, uint256 _value, bytes32 _data) public onlyOwner {\r\n    Slashing(_holder, _value, _data);\r\n  }\r\n\r\n  function powerUp(address _holder, uint256 _value) public onlyOwner {\r\n    // NTZ transfered from user's balance to power pool\r\n    Transfer(address(0), _holder, _value);\r\n  }\r\n\r\n  // ############################################\r\n  // ########### PUBLIC FUNCTIONS ###############\r\n  // ############################################\r\n\r\n  // registers a powerdown request\r\n  function transfer(address _to, uint256 _amountPower) public returns (bool success) {\r\n    // make Power not transferable\r\n    require(_to == address(0));\r\n    ControllerInterface(owner).createDownRequest(msg.sender, _amountPower);\r\n    Transfer(msg.sender, address(0), _amountPower);\r\n    return true;\r\n  }\r\n\r\n  function downtime() public returns (uint256) {\r\n    ControllerInterface(owner).downtime;\r\n  }\r\n\r\n  function downTick(address _owner) public {\r\n    ControllerInterface(owner).downTick(_owner, now);\r\n  }\r\n\r\n  function downs(address _owner) constant public returns (uint256, uint256, uint256) {\r\n    return ControllerInterface(owner).downs(_owner);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Storage is Ownable {\r\n    struct Crate {\r\n        mapping(bytes32 => uint256) uints;\r\n        mapping(bytes32 => address) addresses;\r\n        mapping(bytes32 => bool) bools;\r\n        mapping(address => uint256) bals;\r\n    }\r\n\r\n    mapping(bytes32 => Crate) crates;\r\n\r\n    function setUInt(bytes32 _crate, bytes32 _key, uint256 _value) onlyOwner {\r\n        crates[_crate].uints[_key] = _value;\r\n    }\r\n\r\n    function getUInt(bytes32 _crate, bytes32 _key) constant returns(uint256) {\r\n        return crates[_crate].uints[_key];\r\n    }\r\n\r\n    function setAddress(bytes32 _crate, bytes32 _key, address _value) onlyOwner {\r\n        crates[_crate].addresses[_key] = _value;\r\n    }\r\n\r\n    function getAddress(bytes32 _crate, bytes32 _key) constant returns(address) {\r\n        return crates[_crate].addresses[_key];\r\n    }\r\n\r\n    function setBool(bytes32 _crate, bytes32 _key, bool _value) onlyOwner {\r\n        crates[_crate].bools[_key] = _value;\r\n    }\r\n\r\n    function getBool(bytes32 _crate, bytes32 _key) constant returns(bool) {\r\n        return crates[_crate].bools[_key];\r\n    }\r\n\r\n    function setBal(bytes32 _crate, address _key, uint256 _value) onlyOwner {\r\n        crates[_crate].bals[_key] = _value;\r\n    }\r\n\r\n    function getBal(bytes32 _crate, address _key) constant returns(uint256) {\r\n        return crates[_crate].bals[_key];\r\n    }\r\n}\r\n\r\n\r\ncontract NutzEnabled is Pausable, StorageEnabled {\r\n  using SafeMath for uint;\r\n\r\n  // satelite contract addresses\r\n  address public nutzAddr;\r\n\r\n\r\n  modifier onlyNutz() {\r\n    require(msg.sender == nutzAddr);\r\n    _;\r\n  }\r\n\r\n  function NutzEnabled(address _nutzAddr, address _storageAddr)\r\n    StorageEnabled(_storageAddr) {\r\n    nutzAddr = _nutzAddr;\r\n  }\r\n\r\n  // ############################################\r\n  // ########### NUTZ FUNCTIONS  ################\r\n  // ############################################\r\n\r\n  // total supply(modified for etherscan display)\r\n  function totalSupply() constant returns (uint256) {\r\n    return activeSupply();\r\n  }\r\n\r\n  // total supply(for internal calculations)\r\n  function completeSupply() constant returns (uint256) {\r\n    return activeSupply().add(powerPool()).add(burnPool());\r\n  }\r\n\r\n  // allowances according to ERC20\r\n  // not written to storage, as not very critical\r\n  mapping (address => mapping (address => uint)) internal allowed;\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  function approve(address _owner, address _spender, uint256 _amountBabz) public onlyNutz whenNotPaused {\r\n    require(_owner != _spender);\r\n    allowed[_owner][_spender] = _amountBabz;\r\n  }\r\n\r\n  function _transfer(address _from, address _to, uint256 _amountBabz, bytes _data) internal {\r\n    require(_to != address(this));\r\n    require(_to != address(0));\r\n    require(_amountBabz > 0);\r\n    require(_from != _to);\r\n    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\r\n    _setBabzBalanceOf(_to, babzBalanceOf(_to).add(_amountBabz));\r\n  }\r\n\r\n  function transfer(address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused {\r\n    _transfer(_from, _to, _amountBabz, _data);\r\n  }\r\n\r\n  function transferFrom(address _sender, address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused {\r\n    allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz);\r\n    _transfer(_from, _to, _amountBabz, _data);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n /*\r\n * Contract that is working with ERC223 tokens\r\n */\r\n \r\ncontract ERC223ReceivingContract {\r\n    function tokenFallback(address _from, uint _value, bytes _data);\r\n}\r\n\r\n\r\ncontract ControllerInterface {\r\n\r\n\r\n  // State Variables\r\n  bool public paused;\r\n  address public nutzAddr;\r\n\r\n  // Nutz functions\r\n  function babzBalanceOf(address _owner) constant returns (uint256);\r\n  function activeSupply() constant returns (uint256);\r\n  function burnPool() constant returns (uint256);\r\n  function powerPool() constant returns (uint256);\r\n  function totalSupply() constant returns (uint256);\r\n  function completeSupply() constant returns (uint256);\r\n  function allowance(address _owner, address _spender) constant returns (uint256);\r\n\r\n  function approve(address _owner, address _spender, uint256 _amountBabz) public;\r\n  function transfer(address _from, address _to, uint256 _amountBabz, bytes _data) public;\r\n  function transferFrom(address _sender, address _from, address _to, uint256 _amountBabz, bytes _data) public;\r\n\r\n  // Market functions\r\n  function floor() constant returns (uint256);\r\n  function ceiling() constant returns (uint256);\r\n\r\n  function purchase(address _sender, uint256 _value, uint256 _price) public returns (uint256);\r\n  function sell(address _from, uint256 _price, uint256 _amountBabz);\r\n\r\n  // Power functions\r\n  function powerBalanceOf(address _owner) constant returns (uint256);\r\n  function outstandingPower() constant returns (uint256);\r\n  function authorizedPower() constant returns (uint256);\r\n  function powerTotalSupply() constant returns (uint256);\r\n\r\n  function powerUp(address _sender, address _from, uint256 _amountBabz) public;\r\n  function downTick(address _owner, uint256 _now) public;\r\n  function createDownRequest(address _owner, uint256 _amountPower) public;\r\n  function downs(address _owner) constant public returns(uint256, uint256, uint256);\r\n  function downtime() constant returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments.\r\n */\r\ncontract PullPayment is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n\r\n  uint public dailyLimit = 1000000000000000000000;  // 1 ETH\r\n  uint public lastDay;\r\n  uint public spentToday;\r\n\r\n  // 8bytes date, 24 bytes value\r\n  mapping(address => uint256) internal payments;\r\n\r\n  modifier onlyNutz() {\r\n    require(msg.sender == ControllerInterface(owner).nutzAddr());\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPaused () {\r\n    require(!ControllerInterface(owner).paused());\r\n     _;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 value) {\r\n    return uint192(payments[_owner]);\r\n  }\r\n\r\n  function paymentOf(address _owner) constant returns (uint256 value, uint256 date) {\r\n    value = uint192(payments[_owner]);\r\n    date = (payments[_owner] >> 192);\r\n    return;\r\n  }\r\n\r\n  /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\r\n  /// @param _dailyLimit Amount in wei.\r\n  function changeDailyLimit(uint _dailyLimit) public onlyOwner {\r\n      dailyLimit = _dailyLimit;\r\n  }\r\n\r\n  function changeWithdrawalDate(address _owner, uint256 _newDate)  public onlyOwner {\r\n    // allow to withdraw immediately\r\n    // move witdrawal date more days into future\r\n    payments[_owner] = (_newDate << 192) + uint192(payments[_owner]);\r\n  }\r\n\r\n  function asyncSend(address _dest) public payable onlyNutz {\r\n    require(msg.value > 0);\r\n    uint256 newValue = msg.value.add(uint192(payments[_dest]));\r\n    uint256 newDate;\r\n    if (isUnderLimit(msg.value)) {\r\n      uint256 date = payments[_dest] >> 192;\r\n      newDate = (date > now) ? date : now;\r\n    } else {\r\n      newDate = now.add(3 days);\r\n    }\r\n    spentToday = spentToday.add(msg.value);\r\n    payments[_dest] = (newDate << 192) + uint192(newValue);\r\n  }\r\n\r\n\r\n  function withdraw() public whenNotPaused {\r\n    address untrustedRecipient = msg.sender;\r\n    uint256 amountWei = uint192(payments[untrustedRecipient]);\r\n\r\n    require(amountWei != 0);\r\n    require(now >= (payments[untrustedRecipient] >> 192));\r\n    require(this.balance >= amountWei);\r\n\r\n    payments[untrustedRecipient] = 0;\r\n\r\n    assert(untrustedRecipient.call.gas(1000).value(amountWei)());\r\n  }\r\n\r\n  /*\r\n   * Internal functions\r\n   */\r\n  /// @dev Returns if amount is within daily limit and resets spentToday after one day.\r\n  /// @param amount Amount to withdraw.\r\n  /// @return Returns if amount is under daily limit.\r\n  function isUnderLimit(uint amount) internal returns (bool) {\r\n    if (now > lastDay.add(24 hours)) {\r\n      lastDay = now;\r\n      spentToday = 0;\r\n    }\r\n    // not using safe math because we don't want to throw;\r\n    if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Nutz implements a price floor and a price ceiling on the token being\r\n * sold. It is based of the zeppelin token contract.\r\n */\r\ncontract Nutz is Ownable, ERC20 {\r\n\r\n  event Sell(address indexed seller, uint256 value);\r\n\r\n  string public name = \"Acebusters Nutz\";\r\n  // acebusters units:\r\n  // 10^12 - Nutz   (NTZ)\r\n  // 10^9 - Jonyz\r\n  // 10^6 - Helcz\r\n  // 10^3 - Pascalz\r\n  // 10^0 - Babz\r\n  string public symbol = \"NTZ\";\r\n  uint256 public decimals = 12;\r\n\r\n  // returns balances of active holders\r\n  function balanceOf(address _owner) constant returns (uint) {\r\n    return ControllerInterface(owner).babzBalanceOf(_owner);\r\n  }\r\n\r\n  function totalSupply() constant returns (uint256) {\r\n    return ControllerInterface(owner).totalSupply();\r\n  }\r\n\r\n  function activeSupply() constant returns (uint256) {\r\n    return ControllerInterface(owner).activeSupply();\r\n  }\r\n\r\n  // return remaining allowance\r\n  // if calling return allowed[address(this)][_spender];\r\n  // returns balance of ether parked to be withdrawn\r\n  function allowance(address _owner, address _spender) constant returns (uint256) {\r\n    return ControllerInterface(owner).allowance(_owner, _spender);\r\n  }\r\n\r\n  // returns either the salePrice, or if reserve does not suffice\r\n  // for active supply, returns maxFloor\r\n  function floor() constant returns (uint256) {\r\n    return ControllerInterface(owner).floor();\r\n  }\r\n\r\n  // returns either the salePrice, or if reserve does not suffice\r\n  // for active supply, returns maxFloor\r\n  function ceiling() constant returns (uint256) {\r\n    return ControllerInterface(owner).ceiling();\r\n  }\r\n\r\n  function powerPool() constant returns (uint256) {\r\n    return ControllerInterface(owner).powerPool();\r\n  }\r\n\r\n\r\n  function _checkDestination(address _from, address _to, uint256 _value, bytes _data) internal {\r\n    // erc223: Retrieve the size of the code on target address, this needs assembly .\r\n    uint256 codeLength;\r\n    assembly {\r\n      codeLength := extcodesize(_to)\r\n    }\r\n    if(codeLength>0) {\r\n      ERC223ReceivingContract untrustedReceiver = ERC223ReceivingContract(_to);\r\n      // untrusted contract call\r\n      untrustedReceiver.tokenFallback(_from, _value, _data);\r\n    }\r\n  }\r\n\r\n\r\n\r\n  // ############################################\r\n  // ########### ADMIN FUNCTIONS ################\r\n  // ############################################\r\n\r\n  function powerDown(address powerAddr, address _holder, uint256 _amountBabz) public onlyOwner {\r\n    bytes memory empty;\r\n    _checkDestination(powerAddr, _holder, _amountBabz, empty);\r\n    // NTZ transfered from power pool to user's balance\r\n    Transfer(powerAddr, _holder, _amountBabz);\r\n  }\r\n\r\n\r\n  function asyncSend(address _pullAddr, address _dest, uint256 _amountWei) public onlyOwner {\r\n    assert(_amountWei <= this.balance);\r\n    PullPayInterface(_pullAddr).asyncSend.value(_amountWei)(_dest);\r\n  }\r\n\r\n\r\n  // ############################################\r\n  // ########### PUBLIC FUNCTIONS ###############\r\n  // ############################################\r\n\r\n  function approve(address _spender, uint256 _amountBabz) public {\r\n    ControllerInterface(owner).approve(msg.sender, _spender, _amountBabz);\r\n    Approval(msg.sender, _spender, _amountBabz);\r\n  }\r\n\r\n  function transfer(address _to, uint256 _amountBabz, bytes _data) public returns (bool) {\r\n    ControllerInterface(owner).transfer(msg.sender, _to, _amountBabz, _data);\r\n    Transfer(msg.sender, _to, _amountBabz);\r\n    _checkDestination(msg.sender, _to, _amountBabz, _data);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _amountBabz) public returns (bool) {\r\n    bytes memory empty;\r\n    return transfer(_to, _amountBabz, empty);\r\n  }\r\n\r\n  function transData(address _to, uint256 _amountBabz, bytes _data) public returns (bool) {\r\n    return transfer(_to, _amountBabz, _data);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _amountBabz, bytes _data) public returns (bool) {\r\n    ControllerInterface(owner).transferFrom(msg.sender, _from, _to, _amountBabz, _data);\r\n    Transfer(_from, _to, _amountBabz);\r\n    _checkDestination(_from, _to, _amountBabz, _data);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _amountBabz) public returns (bool) {\r\n    bytes memory empty;\r\n    return transferFrom(_from, _to, _amountBabz, empty);\r\n  }\r\n\r\n  function () public payable {\r\n    uint256 price = ControllerInterface(owner).ceiling();\r\n    purchase(price);\r\n    require(msg.value > 0);\r\n  }\r\n\r\n  function purchase(uint256 _price) public payable {\r\n    require(msg.value > 0);\r\n    uint256 amountBabz = ControllerInterface(owner).purchase(msg.sender, msg.value, _price);\r\n    Transfer(owner, msg.sender, amountBabz);\r\n    bytes memory empty;\r\n    _checkDestination(address(this), msg.sender, amountBabz, empty);\r\n  }\r\n\r\n  function sell(uint256 _price, uint256 _amountBabz) public {\r\n    require(_amountBabz != 0);\r\n    ControllerInterface(owner).sell(msg.sender, _price, _amountBabz);\r\n    Sell(msg.sender, _amountBabz);\r\n  }\r\n\r\n  function powerUp(uint256 _amountBabz) public {\r\n    Transfer(msg.sender, owner, _amountBabz);\r\n    ControllerInterface(owner).powerUp(msg.sender, msg.sender, _amountBabz);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract MarketEnabled is NutzEnabled {\r\n\r\n  uint256 constant INFINITY = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n  // address of the pull payemnt satelite\r\n  address public pullAddr;\r\n\r\n  // the Token sale mechanism parameters:\r\n  // purchasePrice is the number of NTZ received for purchase with 1 ETH\r\n  uint256 internal purchasePrice;\r\n\r\n  // floor is the number of NTZ needed, to receive 1 ETH in sell\r\n  uint256 internal salePrice;\r\n\r\n  function MarketEnabled(address _pullAddr, address _storageAddr, address _nutzAddr)\r\n    NutzEnabled(_nutzAddr, _storageAddr) {\r\n    pullAddr = _pullAddr;\r\n  }\r\n\r\n\r\n  function ceiling() constant returns (uint256) {\r\n    return purchasePrice;\r\n  }\r\n\r\n  // returns either the salePrice, or if reserve does not suffice\r\n  // for active supply, returns maxFloor\r\n  function floor() constant returns (uint256) {\r\n    if (nutzAddr.balance == 0) {\r\n      return INFINITY;\r\n    }\r\n    uint256 maxFloor = activeSupply().mul(1000000).div(nutzAddr.balance); // 1,000,000 WEI, used as price factor\r\n    // return max of maxFloor or salePrice\r\n    return maxFloor >= salePrice ? maxFloor : salePrice;\r\n  }\r\n\r\n  function moveCeiling(uint256 _newPurchasePrice) public onlyAdmins {\r\n    require(_newPurchasePrice <= salePrice);\r\n    purchasePrice = _newPurchasePrice;\r\n  }\r\n\r\n  function moveFloor(uint256 _newSalePrice) public onlyAdmins {\r\n    require(_newSalePrice >= purchasePrice);\r\n    // moveFloor fails if the administrator tries to push the floor so low\r\n    // that the sale mechanism is no longer able to buy back all tokens at\r\n    // the floor price if those funds were to be withdrawn.\r\n    if (_newSalePrice < INFINITY) {\r\n      require(nutzAddr.balance >= activeSupply().mul(1000000).div(_newSalePrice)); // 1,000,000 WEI, used as price factor\r\n    }\r\n    salePrice = _newSalePrice;\r\n  }\r\n\r\n  function purchase(address _sender, uint256 _value, uint256 _price) public onlyNutz whenNotPaused returns (uint256) {\r\n    // disable purchases if purchasePrice set to 0\r\n    require(purchasePrice > 0);\r\n    require(_price == purchasePrice);\r\n\r\n    uint256 amountBabz = purchasePrice.mul(_value).div(1000000); // 1,000,000 WEI, used as price factor\r\n    // avoid deposits that issue nothing\r\n    // might happen with very high purchase price\r\n    require(amountBabz > 0);\r\n\r\n    // make sure power pool grows proportional to economy\r\n    uint256 activeSup = activeSupply();\r\n    uint256 powPool = powerPool();\r\n    if (powPool > 0) {\r\n      uint256 powerShare = powPool.mul(amountBabz).div(activeSup.add(burnPool()));\r\n      _setPowerPool(powPool.add(powerShare));\r\n    }\r\n    _setActiveSupply(activeSup.add(amountBabz));\r\n    _setBabzBalanceOf(_sender, babzBalanceOf(_sender).add(amountBabz));\r\n    return amountBabz;\r\n  }\r\n\r\n  function sell(address _from, uint256 _price, uint256 _amountBabz) public onlyNutz whenNotPaused {\r\n    uint256 effectiveFloor = floor();\r\n    require(_amountBabz != 0);\r\n    require(effectiveFloor != INFINITY);\r\n    require(_price == effectiveFloor);\r\n\r\n    uint256 amountWei = _amountBabz.mul(1000000).div(effectiveFloor);  // 1,000,000 WEI, used as price factor\r\n    require(amountWei > 0);\r\n    // make sure power pool shrinks proportional to economy\r\n    uint256 powPool = powerPool();\r\n    uint256 activeSup = activeSupply();\r\n    if (powPool > 0) {\r\n      uint256 powerShare = powPool.mul(_amountBabz).div(activeSup.add(burnPool()));\r\n      _setPowerPool(powPool.sub(powerShare));\r\n    }\r\n    _setActiveSupply(activeSup.sub(_amountBabz));\r\n    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\r\n    Nutz(nutzAddr).asyncSend(pullAddr, _from, amountWei);\r\n  }\r\n\r\n\r\n  // withdraw excessive reserve - i.e. milestones\r\n  function allocateEther(uint256 _amountWei, address _beneficiary) public onlyAdmins {\r\n    require(_amountWei > 0);\r\n    // allocateEther fails if allocating those funds would mean that the\r\n    // sale mechanism is no longer able to buy back all tokens at the floor\r\n    // price if those funds were to be withdrawn.\r\n    require(nutzAddr.balance.sub(_amountWei) >= activeSupply().mul(1000000).div(salePrice)); // 1,000,000 WEI, used as price factor\r\n    Nutz(nutzAddr).asyncSend(pullAddr, _beneficiary, _amountWei);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract PowerEnabled is MarketEnabled {\r\n\r\n  // satelite contract addresses\r\n  address public powerAddr;\r\n\r\n  // maxPower is a limit of total power that can be outstanding\r\n  // maxPower has a valid value between outstandingPower and authorizedPow/2\r\n  uint256 public maxPower = 0;\r\n\r\n  // time it should take to power down\r\n  uint256 public downtime;\r\n\r\n  uint public constant MIN_SHARE_OF_POWER = 100000;\r\n\r\n  modifier onlyPower() {\r\n    require(msg.sender == powerAddr);\r\n    _;\r\n  }\r\n\r\n  function PowerEnabled(address _powerAddr, address _pullAddr, address _storageAddr, address _nutzAddr)\r\n    MarketEnabled(_pullAddr, _nutzAddr, _storageAddr) {\r\n    powerAddr = _powerAddr;\r\n  }\r\n\r\n  function setMaxPower(uint256 _maxPower) public onlyAdmins {\r\n    require(outstandingPower() <= _maxPower && _maxPower < authorizedPower());\r\n    maxPower = _maxPower;\r\n  }\r\n\r\n  function setDowntime(uint256 _downtime) public onlyAdmins {\r\n    downtime = _downtime;\r\n  }\r\n\r\n  function minimumPowerUpSizeBabz() public constant returns (uint256) {\r\n    uint256 completeSupplyBabz = completeSupply();\r\n    if (completeSupplyBabz == 0) {\r\n      return INFINITY;\r\n    }\r\n    return completeSupplyBabz.div(MIN_SHARE_OF_POWER);\r\n  }\r\n\r\n  // this is called when NTZ are deposited into the burn pool\r\n  function dilutePower(uint256 _amountBabz, uint256 _amountPower) public onlyAdmins {\r\n    uint256 authorizedPow = authorizedPower();\r\n    uint256 totalBabz = completeSupply();\r\n    if (authorizedPow == 0) {\r\n      // during the first capital increase, set value directly as authorized shares\r\n      _setAuthorizedPower((_amountPower > 0) ? _amountPower : _amountBabz.add(totalBabz));\r\n    } else {\r\n      // in later increases, expand authorized shares at same rate like economy\r\n      _setAuthorizedPower(authorizedPow.mul(totalBabz.add(_amountBabz)).div(totalBabz));\r\n    }\r\n    _setBurnPool(burnPool().add(_amountBabz));\r\n  }\r\n\r\n  function _slashPower(address _holder, uint256 _value, bytes32 _data) internal {\r\n    uint256 previouslyOutstanding = outstandingPower();\r\n    _setOutstandingPower(previouslyOutstanding.sub(_value));\r\n    // adjust size of power pool\r\n    uint256 powPool = powerPool();\r\n    uint256 slashingBabz = _value.mul(powPool).div(previouslyOutstanding);\r\n    _setPowerPool(powPool.sub(slashingBabz));\r\n    // put event into satelite contract\r\n    Power(powerAddr).slashPower(_holder, _value, _data);\r\n  }\r\n\r\n  function slashPower(address _holder, uint256 _value, bytes32 _data) public onlyAdmins {\r\n    _setPowerBalanceOf(_holder, powerBalanceOf(_holder).sub(_value));\r\n    _slashPower(_holder, _value, _data);\r\n  }\r\n\r\n  function slashDownRequest(uint256 _pos, address _holder, uint256 _value, bytes32 _data) public onlyAdmins {\r\n    var (total, left, start) = downs(_holder);\r\n    left = left.sub(_value);\r\n    _setDownRequest(_holder, total, left, start);\r\n    _slashPower(_holder, _value, _data);\r\n  }\r\n\r\n  // this is called when NTZ are deposited into the power pool\r\n  function powerUp(address _sender, address _from, uint256 _amountBabz) public onlyNutz whenNotPaused {\r\n    uint256 authorizedPow = authorizedPower();\r\n    require(authorizedPow != 0);\r\n    require(_amountBabz != 0);\r\n    uint256 totalBabz = completeSupply();\r\n    require(totalBabz != 0);\r\n    uint256 amountPow = _amountBabz.mul(authorizedPow).div(totalBabz);\r\n    // check pow limits\r\n    uint256 outstandingPow = outstandingPower();\r\n    require(outstandingPow.add(amountPow) <= maxPower);\r\n    uint256 powBal = powerBalanceOf(_from).add(amountPow);\r\n    require(powBal >= authorizedPow.div(MIN_SHARE_OF_POWER));\r\n\r\n    if (_sender != _from) {\r\n      allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz);\r\n    }\r\n\r\n    _setOutstandingPower(outstandingPow.add(amountPow));\r\n    _setPowerBalanceOf(_from, powBal);\r\n    _setActiveSupply(activeSupply().sub(_amountBabz));\r\n    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\r\n    _setPowerPool(powerPool().add(_amountBabz));\r\n    Power(powerAddr).powerUp(_from, amountPow);\r\n  }\r\n\r\n  function powerTotalSupply() constant returns (uint256) {\r\n    uint256 issuedPower = authorizedPower().div(2);\r\n    // return max of maxPower or issuedPower\r\n    return maxPower >= issuedPower ? maxPower : issuedPower;\r\n  }\r\n\r\n  function _vestedDown(uint256 _total, uint256 _left, uint256 _start, uint256 _now) internal constant returns (uint256) {\r\n    if (_now <= _start) {\r\n      return 0;\r\n    }\r\n    // calculate amountVested\r\n    // amountVested is amount that can be withdrawn according to time passed\r\n    uint256 timePassed = _now.sub(_start);\r\n    if (timePassed > downtime) {\r\n     timePassed = downtime;\r\n    }\r\n    uint256 amountVested = _total.mul(timePassed).div(downtime);\r\n    uint256 amountFrozen = _total.sub(amountVested);\r\n    if (_left <= amountFrozen) {\r\n      return 0;\r\n    }\r\n    return _left.sub(amountFrozen);\r\n  }\r\n\r\n  function createDownRequest(address _owner, uint256 _amountPower) public onlyPower whenNotPaused {\r\n    // prevent powering down tiny amounts\r\n    // when powering down, at least completeSupply/minShare Power should be claimed\r\n    require(_amountPower >= authorizedPower().div(MIN_SHARE_OF_POWER));\r\n    _setPowerBalanceOf(_owner, powerBalanceOf(_owner).sub(_amountPower));\r\n\r\n    var (, left, ) = downs(_owner);\r\n    uint256 total = _amountPower.add(left);\r\n    _setDownRequest(_owner, total, total, now);\r\n  }\r\n\r\n  // executes a powerdown request\r\n  function downTick(address _holder, uint256 _now) public onlyPower whenNotPaused {\r\n    var (total, left, start) = downs(_holder);\r\n    uint256 amountPow = _vestedDown(total, left, start, _now);\r\n\r\n    // prevent power down in tiny steps\r\n    uint256 minStep = total.div(10);\r\n    require(left <= minStep || minStep <= amountPow);\r\n\r\n    // calculate token amount representing share of power\r\n    uint256 amountBabz = amountPow.mul(completeSupply()).div(authorizedPower());\r\n\r\n    // transfer power and tokens\r\n    _setOutstandingPower(outstandingPower().sub(amountPow));\r\n    left = left.sub(amountPow);\r\n    _setPowerPool(powerPool().sub(amountBabz));\r\n    _setActiveSupply(activeSupply().add(amountBabz));\r\n    _setBabzBalanceOf(_holder, babzBalanceOf(_holder).add(amountBabz));\r\n    // down request completed\r\n    if (left == 0) {\r\n      start = 0;\r\n      total = 0;\r\n    }\r\n    // TODO\r\n    _setDownRequest(_holder, total, left, start);\r\n    Nutz(nutzAddr).powerDown(powerAddr, _holder, amountBabz);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Controller is PowerEnabled {\r\n\r\n  function Controller(address _powerAddr, address _pullAddr, address _nutzAddr, address _storageAddr) \r\n    PowerEnabled(_powerAddr, _pullAddr, _nutzAddr, _storageAddr) {\r\n  }\r\n\r\n  function setContracts(address _storageAddr, address _nutzAddr, address _powerAddr, address _pullAddr) public onlyAdmins whenPaused {\r\n    storageAddr = _storageAddr;\r\n    nutzAddr = _nutzAddr;\r\n    powerAddr = _powerAddr;\r\n    pullAddr = _pullAddr;\r\n  }\r\n\r\n  function changeDailyLimit(uint256 _dailyLimit) public onlyAdmins {\r\n    PullPayment(pullAddr).changeDailyLimit(_dailyLimit);\r\n  }\r\n\r\n  function kill(address _newController) public onlyAdmins whenPaused {\r\n    if (powerAddr != address(0)) { Ownable(powerAddr).transferOwnership(msg.sender); }\r\n    if (pullAddr != address(0)) { Ownable(pullAddr).transferOwnership(msg.sender); }\r\n    if (nutzAddr != address(0)) { Ownable(nutzAddr).transferOwnership(msg.sender); }\r\n    if (storageAddr != address(0)) { Ownable(storageAddr).transferOwnership(msg.sender); }\r\n    selfdestruct(_newController);\r\n  }\r\n\r\n}\r\n\r\ncontract UpgradeEventCompact {\r\n  using SafeMath for uint;\r\n\r\n  // states\r\n  //  - verifying, initial state\r\n  //  - controlling, after verifying, before complete\r\n  //  - complete, after controlling\r\n  enum EventState { Verifying, Complete }\r\n  EventState public state;\r\n\r\n  // Terms\r\n  address public nextController;\r\n  address public oldController;\r\n  address public council;\r\n\r\n  // Params\r\n  address nextPullPayment;\r\n  address storageAddr;\r\n  address nutzAddr;\r\n  address powerAddr;\r\n  uint256 maxPower;\r\n  uint256 downtime;\r\n  uint256 purchasePrice;\r\n  uint256 salePrice;\r\n\r\n  function UpgradeEventCompact(address _oldController, address _nextController, address _nextPullPayment) {\r\n    state = EventState.Verifying;\r\n    nextController = _nextController;\r\n    oldController = _oldController;\r\n    nextPullPayment = _nextPullPayment; //the ownership of this satellite should be with oldController\r\n    council = msg.sender;\r\n  }\r\n\r\n  modifier isState(EventState _state) {\r\n    require(state == _state);\r\n    _;\r\n  }\r\n\r\n  function upgrade() isState(EventState.Verifying) {\r\n    // check old controller\r\n    var old = Controller(oldController);\r\n    old.pause();\r\n    require(old.admins(1) == address(this));\r\n    require(old.paused() == true);\r\n    // check next controller\r\n    var next = Controller(nextController);\r\n    require(next.admins(1) == address(this));\r\n    require(next.paused() == true);\r\n    // kill old one, and transfer ownership\r\n    // transfer ownership of payments and storage to here\r\n    storageAddr = old.storageAddr();\r\n    nutzAddr = old.nutzAddr();\r\n    powerAddr = old.powerAddr();\r\n    maxPower = old.maxPower();\r\n    downtime = old.downtime();\r\n    purchasePrice = old.ceiling();\r\n    salePrice = old.floor();\r\n    uint newPowerPool = (old.outstandingPower()).mul(old.activeSupply().add(old.burnPool())).div(old.authorizedPower().sub(old.outstandingPower()));\r\n    //set pull payment contract in old controller\r\n    old.setContracts(powerAddr, nextPullPayment, nutzAddr, storageAddr);\r\n    // kill old controller, sending all ETH to new controller\r\n    old.kill(nextController);\r\n    // transfer ownership of Nutz/Power contracts to next controller\r\n    Ownable(nutzAddr).transferOwnership(nextController);\r\n    Ownable(powerAddr).transferOwnership(nextController);\r\n    // transfer ownership of storage to next controller\r\n    Storage(storageAddr).setUInt('Nutz', 'powerPool', newPowerPool);\r\n    Ownable(storageAddr).transferOwnership(nextController);\r\n    // if intended, transfer ownership of pull payment account\r\n    Ownable(nextPullPayment).transferOwnership(nextController);\r\n    // resume next controller\r\n    if (maxPower > 0) {\r\n      next.setMaxPower(maxPower);\r\n    }\r\n    next.setDowntime(downtime);\r\n    next.moveFloor(salePrice);\r\n    next.moveCeiling(purchasePrice);\r\n    next.unpause();\r\n    // remove access\r\n    next.removeAdmin(address(this));\r\n    // set state\r\n    state = EventState.Complete;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"oldController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"council\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_oldController\",\"type\":\"address\"},{\"name\":\"_nextController\",\"type\":\"address\"},{\"name\":\"_nextPullPayment\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"}]","ContractName":"UpgradeEventCompact","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000faac705fb942836070fd11c6fb1bd784e9ce48a5000000000000000000000000e7dc501cb9ca414cf9211af214d5065ca3a3076800000000000000000000000069cCa8df17623f18a001b96Ba4d958cE72Bc6BDC","Library":"","SwarmSource":"bzzr://e3b2f2b812548334c943c6fc132cfba7f90dd1f8b5ec0058ed21c0ee573a60cd"}]}