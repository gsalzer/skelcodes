{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract BowdenCoin {\r\n\r\n  uint8 Decimals = 6;\r\n  uint256 total_supply = 100 * 10**6;\r\n  address owner;\r\n  uint creation_block;\r\n\r\n  function BowdenCoin() public{\r\n    owner = msg.sender;\r\n    balanceOf[msg.sender] = total_supply;\r\n    creation_block = block.number;\r\n  }\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 value);\r\n  event DoubleSend(address indexed sender, address indexed recipient, uint256 value);\r\n  event NextDouble(address indexed _owner, uint256 date);\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  mapping (address => uint256) public balanceOf;\r\n  mapping (address => mapping (address => uint)) public allowance;\r\n  mapping (address => uint256) public nextDouble;\r\n\r\n\r\n  function name() pure public returns (string _name){\r\n    return \"BowdenCoin\";\r\n  }\r\n\r\n  function symbol() pure public returns (string _symbol){\r\n    return \"BDC\";\r\n  }\r\n\r\n  function decimals() view public returns (uint8 _decimals){\r\n    return Decimals;\r\n  }\r\n\r\n  function totalSupply() public constant returns (uint256 total){\r\n      return total_supply;\r\n  }\r\n\r\n  function balanceOf(address tokenOwner) public constant returns (uint256 balance){\r\n    return balanceOf[tokenOwner];\r\n  }\r\n\r\n  function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining){\r\n    return allowance[tokenOwner][spender];\r\n  }\r\n\r\n  function transfer(address recipient, uint256 value) public returns (bool success){\r\n    require(balanceOf[msg.sender] >= value);\r\n    require(balanceOf[recipient] + value >= balanceOf[recipient]);\r\n    balanceOf[msg.sender] -= value;\r\n    balanceOf[recipient] += value;\r\n    Transfer(msg.sender, recipient, value);\r\n\r\n    if(nextDouble[msg.sender] > block.number && nextDouble[msg.sender] > nextDouble[recipient]){\r\n      nextDouble[recipient] = nextDouble[msg.sender];\r\n      NextDouble(recipient, nextDouble[recipient]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint256 value) public returns (bool success){\r\n    allowance[msg.sender][spender] = value;\r\n    Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address recipient, uint256 value) public\r\n      returns (bool success){\r\n    require(balanceOf[from] >= value);                                          //ensure from address has available balance\r\n    require(balanceOf[recipient] + value >= balanceOf[recipient]);              //stop overflow\r\n    require(value <= allowance[from][msg.sender]);                              //ensure msg.sender has enough allowance\r\n    balanceOf[from] -= value;\r\n    balanceOf[recipient] += value;\r\n    allowance[from][msg.sender] -= value;\r\n    Transfer(from, recipient, value);\r\n\r\n    if(nextDouble[from] > block.number && nextDouble[from] > nextDouble[recipient]){\r\n      nextDouble[recipient] = nextDouble[from];\r\n      NextDouble(recipient, nextDouble[recipient]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function getDoublePeriod() view public returns (uint blocks){\r\n    require(block.number >= creation_block);\r\n    uint dp = ((block.number-creation_block)/60+1)*8;                           //goes up by 8 blocks every 60 blocks. Stars at 8\r\n    if(dp > 2 days) return 2 days;                                              //equivalent to one months worth of blocks since there is 1 block every 15 seconds\r\n    return dp;\r\n  }\r\n\r\n  function canDouble(address tokenOwner) view public returns (bool can_double){\r\n    return nextDouble[tokenOwner] <= block.number;\r\n  }\r\n\r\n  function remainingDoublePeriod(uint blockNum) view internal returns (uint){\r\n    if(blockNum <= block.number) return 0;\r\n    return blockNum - block.number;\r\n  }\r\n\r\n  function getNextDouble(address tokenOwner) view public returns (uint256 blockHeight){\r\n    return nextDouble[tokenOwner];\r\n  }\r\n\r\n  function doubleSend(uint256 value, address recipient) public\r\n      returns(bool success){\r\n    uint half_value = value/2;\r\n    require(total_supply + half_value + half_value >= total_supply);                      //totalSupply overflow check\r\n    require(balanceOf[msg.sender] + half_value >= balanceOf[msg.sender]);            //owner overflow check\r\n    require(balanceOf[recipient] + half_value >= balanceOf[recipient]);              //recipient overflow check\r\n    require(balanceOf[msg.sender] >= half_value);                            //ensure that owner has enough balance to double\r\n    require(canDouble(msg.sender));                                             //ensure that owner has the right to double\r\n    require(msg.sender != recipient);                                           //cant double and send to yourself\r\n\r\n    balanceOf[msg.sender] += half_value;                                             //increase the balance of the function caller\r\n    balanceOf[recipient] += half_value;                                              //increase the balance of the recipient\r\n    DoubleSend(msg.sender, recipient, half_value);                                   //log the double send\r\n    total_supply += half_value + half_value;                                              //increase the total supply to match the new amount\r\n\r\n    nextDouble[msg.sender] = block.number + getDoublePeriod();                  //set the time of next doubling to the current block plus the current delay\r\n    NextDouble(msg.sender, nextDouble[msg.sender]);                             //log the next doubling for msg.sender\r\n    nextDouble[recipient] = block.number + getDoublePeriod() + remainingDoublePeriod(nextDouble[recipient]);  //set the time of next doubling to the same as the msg.sender, plus any excess that was tied to the recipient\r\n    NextDouble(recipient, nextDouble[recipient]);                               //log\r\n\r\n    return true;\r\n  }\r\n\r\n  function withdrawEth() public returns(bool success){\r\n    require(msg.sender == owner);                                               //ensure the owner can only use this\r\n    owner.transfer(this.balance);                                               //transfer all eth to owner (failsafe incase eth is sent to this address)\r\n    return true;\r\n  }\r\n\r\n  function burnToken(uint256 value) public returns (bool success){\r\n    require(balanceOf[msg.sender] >= value);                                    //must have enough in account to burn\r\n    require(total_supply - value <= total_supply);                              //check for underflow\r\n    balanceOf[msg.sender] -= value;\r\n    total_supply -= value;\r\n    Burn(msg.sender,value);\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDoublePeriod\",\"outputs\":[{\"name\":\"blocks\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"doubleSend\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextDouble\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"canDouble\",\"outputs\":[{\"name\":\"can_double\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"getNextDouble\",\"outputs\":[{\"name\":\"blockHeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DoubleSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"NextDouble\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"BowdenCoin","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8417e99852d04ff3d28a178d290ed13ec2d92e6949a77ca9eda5e6b5a8f1c6f5"}]}