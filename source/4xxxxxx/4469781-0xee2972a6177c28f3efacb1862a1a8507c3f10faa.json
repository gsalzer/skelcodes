{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/**\r\n * @title Ownership interface\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IOwnership {\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() constant returns (address);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract Ownership is IOwnership {\r\n\r\n    // Owner\r\n    address internal owner;\r\n\r\n\r\n    /**\r\n     * The publisher is the inital owner\r\n     */\r\n    function Ownership() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * Access is restricted to the current owner\r\n     */\r\n    modifier only_owner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public constant returns (bool) {\r\n        return _account == owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public constant returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Transferable ownership interface\r\n *\r\n * Enhances ownership by allowing the current owner to \r\n * transfer ownership to a new owner\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITransferableOwnership {\r\n    \r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner);\r\n}\r\n\r\n\r\n/**\r\n * @title Transferable ownership\r\n *\r\n * Enhances ownership by allowing the current owner to \r\n * transfer ownership to a new owner\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TransferableOwnership is ITransferableOwnership, Ownership {\r\n\r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner) public only_owner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable interface\r\n *\r\n * Simple interface to pause and resume \r\n *\r\n * #created 11/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IPausable {\r\n\r\n    /**\r\n     * Returns whether the implementing contract is \r\n     * currently paused or not\r\n     *\r\n     * @return Whether the paused state is active\r\n     */\r\n    function isPaused() constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Change the state to paused\r\n     */\r\n    function pause();\r\n\r\n\r\n    /**\r\n     * Change the state to resume, undo the effects \r\n     * of calling pause\r\n     */\r\n    function resume();\r\n}\r\n\r\n\r\n/**\r\n * @title IAuthenticationManager \r\n *\r\n * Allows the authentication process to be enabled and disabled\r\n *\r\n * #created 15/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IAuthenticationManager {\r\n    \r\n\r\n    /**\r\n     * Returns true if authentication is enabled and false \r\n     * otherwise\r\n     *\r\n     * @return Whether the converter is currently authenticating or not\r\n     */\r\n    function isAuthenticating() constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Enable authentication\r\n     */\r\n    function enableAuthentication();\r\n\r\n\r\n    /**\r\n     * Disable authentication\r\n     */\r\n    function disableAuthentication();\r\n}\r\n\r\n\r\n/**\r\n * @title IAuthenticator \r\n *\r\n * Authenticator interface\r\n *\r\n * #created 15/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IAuthenticator {\r\n    \r\n\r\n    /**\r\n     * Authenticate \r\n     *\r\n     * Returns whether `_account` is authenticated or not\r\n     *\r\n     * @param _account The account to authenticate\r\n     * @return whether `_account` is successfully authenticated\r\n     */\r\n    function authenticate(address _account) constant returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title IWhitelist \r\n *\r\n * Whitelist authentication interface\r\n *\r\n * #created 04/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IWhitelist is IAuthenticator {\r\n    \r\n\r\n    /**\r\n     * Returns whether an entry exists for `_account`\r\n     *\r\n     * @param _account The account to check\r\n     * @return whether `_account` is has an entry in the whitelist\r\n     */\r\n    function hasEntry(address _account) constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Add `_account` to the whitelist\r\n     *\r\n     * If an account is currently disabled, the account is reenabled, otherwise \r\n     * a new entry is created\r\n     *\r\n     * @param _account The account to add\r\n     */\r\n    function add(address _account);\r\n\r\n\r\n    /**\r\n     * Remove `_account` from the whitelist\r\n     *\r\n     * Will not actually remove the entry but disable it by updating\r\n     * the accepted record\r\n     *\r\n     * @param _account The account to remove\r\n     */\r\n    function remove(address _account);\r\n}\r\n\r\n\r\n/**\r\n * @title Token retrieve interface\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract);\r\n}\r\n\r\n\r\n/**\r\n * @title Token retrieve\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 18/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenRetriever is ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public {\r\n        IToken tokenInstance = IToken(_tokenContract);\r\n        uint tokenBalance = tokenInstance.balanceOf(this);\r\n        if (tokenBalance > 0) {\r\n            tokenInstance.transfer(msg.sender, tokenBalance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Token observer interface\r\n *\r\n * Allows a token smart-contract to notify observers \r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITokenObserver {\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value);\r\n}\r\n\r\n\r\n/**\r\n * @title Abstract token observer\r\n *\r\n * Allows observers to be notified by an observed token smart-contract\r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenObserver is ITokenObserver {\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value) public {\r\n        onTokensReceived(msg.sender, _from, _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler\r\n     * \r\n     * Called by `_token` when a token amount is received\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal;\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 compatible token interface\r\n *\r\n * - Implements ERC 20 Token standard\r\n * - Implements short address attack fix\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IToken { \r\n\r\n    /** \r\n     * Get the total supply of tokens\r\n     * \r\n     * @return The total supply\r\n     */\r\n    function totalSupply() constant returns (uint);\r\n\r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title ManagedToken interface\r\n *\r\n * Adds the following functionality to the basic ERC20 token\r\n * - Locking\r\n * - Issuing\r\n * - Burning \r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IManagedToken is IToken { \r\n\r\n    /** \r\n     * Returns true if the token is locked\r\n     * \r\n     * @return Whether the token is locked\r\n     */\r\n    function isLocked() constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Locks the token so that the transfering of value is disabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function lock() returns (bool);\r\n\r\n\r\n    /**\r\n     * Unlocks the token so that the transfering of value is enabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function unlock() returns (bool);\r\n\r\n\r\n    /**\r\n     * Issues `_value` new tokens to `_to`\r\n     *\r\n     * @param _to The address to which the tokens will be issued\r\n     * @param _value The amount of new tokens to issue\r\n     * @return Whether the tokens where sucessfully issued or not\r\n     */\r\n    function issue(address _to, uint _value) returns (bool);\r\n\r\n\r\n    /**\r\n     * Burns `_value` tokens of `_from`\r\n     *\r\n     * @param _from The address that owns the tokens to be burned\r\n     * @param _value The amount of tokens to be burned\r\n     * @return Whether the tokens where sucessfully burned or not \r\n     */\r\n    function burn(address _from, uint _value) returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title Token Changer interface\r\n *\r\n * Basic token changer public interface \r\n *\r\n * #created 06/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITokenChanger {\r\n\r\n    /**\r\n     * Returns true if '_token' is on of the tokens that are \r\n     * managed by this token changer\r\n     * \r\n     * @param _token The address being tested\r\n     * @return Whether the '_token' is part of this token changer\r\n     */\r\n    function isToken(address _token) constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns the address of the left token\r\n     *\r\n     * @return Left token address\r\n     */\r\n    function getLeftToken() constant returns (address);\r\n\r\n\r\n    /**\r\n     * Returns the address of the right token\r\n     *\r\n     * @return Right token address\r\n     */\r\n    function getRightToken() constant returns (address);\r\n\r\n\r\n    /**\r\n     * Returns the fee that is paid in tokens when using \r\n     * the token changer\r\n     *\r\n     * @return The percentage of tokens that is charged\r\n     */\r\n    function getFee() constant returns (uint);\r\n\r\n    \r\n    /**\r\n     * Returns the rate that is used to change between tokens\r\n     *\r\n     * @return The rate used when changing tokens\r\n     */\r\n    function getRate() constant returns (uint);\r\n\r\n\r\n    /**\r\n     * Returns the precision of the rate and fee params\r\n     *\r\n     * @return The amount of decimals used\r\n     */\r\n    function getPrecision() constant returns (uint);\r\n\r\n\r\n    /**\r\n     * Calculates and returns the fee based on `_value` of tokens\r\n     *\r\n     * @return The actual fee\r\n     */\r\n    function calculateFee(uint _value) constant returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title Token Changer\r\n *\r\n * Provides a generic way to convert between two tokens using a fixed \r\n * ratio and an optional fee.\r\n *\r\n * #created 06/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenChanger is ITokenChanger, IPausable {\r\n\r\n    IManagedToken private tokenLeft; // tokenLeft = tokenRight * rate / precision\r\n    IManagedToken private tokenRight; // tokenRight = tokenLeft / rate * precision\r\n\r\n    uint private rate; // Ratio between tokens\r\n    uint private fee; // Percentage lost in transfer\r\n    uint private precision; // Precision \r\n    bool private paused; // Paused state\r\n    bool private burn; // Whether the changer should burn tokens\r\n\r\n\r\n    /**\r\n     * Only if '_token' is the left or right token \r\n     * that of the token changer\r\n     */\r\n    modifier is_token(address _token) {\r\n        require(_token == address(tokenLeft) || _token == address(tokenRight));\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Construct token changer\r\n     *\r\n     * @param _tokenLeft Ref to the 'left' token smart-contract\r\n     * @param _tokenRight Ref to the 'right' token smart-contract\r\n     * @param _rate The rate used when changing tokens\r\n     * @param _fee The percentage of tokens that is charged\r\n     * @param _decimals The amount of decimals used for _rate and _fee\r\n     * @param _paused Whether the token changer starts in the paused state or not\r\n     * @param _burn Whether the changer should burn tokens or not\r\n     */\r\n    function TokenChanger(address _tokenLeft, address _tokenRight, uint _rate, uint _fee, uint _decimals, bool _paused, bool _burn) {\r\n        tokenLeft = IManagedToken(_tokenLeft);\r\n        tokenRight = IManagedToken(_tokenRight);\r\n        rate = _rate;\r\n        fee = _fee;\r\n        precision = _decimals > 0 ? 10**_decimals : 1;\r\n        paused = _paused;\r\n        burn = _burn;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Returns true if '_token' is on of the tokens that are \r\n     * managed by this token changer\r\n     * \r\n     * @param _token The address being tested\r\n     * @return Whether the '_token' is part of this token changer\r\n     */\r\n    function isToken(address _token) public constant returns (bool) {\r\n        return _token == address(tokenLeft) || _token == address(tokenRight);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the address of the left token\r\n     *\r\n     * @return Left token address\r\n     */\r\n    function getLeftToken() public constant returns (address) {\r\n        return tokenLeft;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the address of the right token\r\n     *\r\n     * @return Right token address\r\n     */\r\n    function getRightToken() public constant returns (address) {\r\n        return tokenRight;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the fee that is paid in tokens when using \r\n     * the token changer\r\n     *\r\n     * @return The percentage of tokens that is charged\r\n     */\r\n    function getFee() public constant returns (uint) {\r\n        return fee;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the rate that is used to change between tokens\r\n     *\r\n     * @return The rate used when changing tokens\r\n     */\r\n    function getRate() public constant returns (uint) {\r\n        return rate;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the precision of the rate and fee params\r\n     *\r\n     * @return The amount of decimals used\r\n     */\r\n    function getPrecision() public constant returns (uint) {\r\n        return precision;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns whether the token changer is currently \r\n     * paused or not. While being in the paused state \r\n     * the contract should revert the transaction instead \r\n     * of converting tokens\r\n     *\r\n     * @return Whether the token changer is in the paused state\r\n     */\r\n    function isPaused() public constant returns (bool) {\r\n        return paused;\r\n    }\r\n\r\n\r\n    /**\r\n     * Pause the token changer making the contract \r\n     * revert the transaction instead of converting \r\n     */\r\n    function pause() public {\r\n        paused = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Resume the token changer making the contract \r\n     * convert tokens instead of reverting the transaction \r\n     */\r\n    function resume() public {\r\n        paused = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Calculates and returns the fee based on `_value` of tokens\r\n     *\r\n     * @param _value The amount of tokens that is being converted\r\n     * @return The actual fee\r\n     */\r\n    function calculateFee(uint _value) public constant returns (uint) {\r\n        return fee == 0 ? 0 : _value * fee / precision;\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts tokens by burning the tokens received at the token smart-contact \r\n     * located at `_from` and by issuing tokens at the opposite token smart-contract\r\n     *\r\n     * @param _from The token smart-contract that received the tokens\r\n     * @param _sender The account that send the tokens (token owner)\r\n     * @param _value The amount of tokens that where received\r\n     */\r\n    function convert(address _from, address _sender, uint _value) internal {\r\n        require(!paused);\r\n        require(_value > 0);\r\n\r\n        uint amountToIssue;\r\n        if (_from == address(tokenLeft)) {\r\n            amountToIssue = _value * rate / precision;\r\n            tokenRight.issue(_sender, amountToIssue - calculateFee(amountToIssue));\r\n            if (burn) {\r\n                tokenLeft.burn(this, _value);\r\n            }   \r\n        } \r\n        \r\n        else if (_from == address(tokenRight)) {\r\n            amountToIssue = _value * precision / rate;\r\n            tokenLeft.issue(_sender, amountToIssue - calculateFee(amountToIssue));\r\n            if (burn) {\r\n                tokenRight.burn(this, _value);\r\n            } \r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title DRPU Converter\r\n *\r\n * Will allow DRP token holders to convert their DRP Balance into DRPU at the ratio of 1:2, locking all recieved DRP into the converter.\r\n *\r\n * DRPU as indicated by its ‘U’ designation is Dcorp’s utility token for those who are under strict \r\n * compliance within their country of residence, and does not entitle holders to profit sharing.\r\n *\r\n * https://www.dcorp.it/drpu\r\n *\r\n * #created 11/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract DRPUTokenConverter is TokenChanger, IAuthenticationManager, TransferableOwnership, TokenRetriever {\r\n\r\n    // Authentication\r\n    IWhitelist private whitelist;\r\n    bool private requireAuthentication;\r\n\r\n\r\n    /**\r\n     * Construct drp - drpu token changer\r\n     *\r\n     * Rate is multiplied by 10**6 taking into account the difference in \r\n     * decimals between (old) DRP (2) and DRPU (8)\r\n     *\r\n     * @param _whitelist The address of the whitelist authenticator\r\n     * @param _drp Ref to the (old) DRP token smart-contract\r\n     * @param _drpu Ref to the DRPU token smart-contract https://www.dcorp.it/drpu\r\n     */\r\n    function DRPUTokenConverter(address _whitelist, address _drp, address _drpu) \r\n        TokenChanger(_drp, _drpu, 2 * 10**6, 0, 0, false, false) {\r\n        whitelist = IWhitelist(_whitelist);\r\n        requireAuthentication = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if authentication is enabled and false \r\n     * otherwise\r\n     *\r\n     * @return Whether the converter is currently authenticating or not\r\n     */\r\n    function isAuthenticating() public constant returns (bool) {\r\n        return requireAuthentication;\r\n    }\r\n\r\n\r\n    /**\r\n     * Enable authentication\r\n     */\r\n    function enableAuthentication() public only_owner {\r\n        requireAuthentication = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Disable authentication\r\n     */\r\n    function disableAuthentication() public only_owner {\r\n        requireAuthentication = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Pause the token changer making the contract \r\n     * revert the transaction instead of converting \r\n     */\r\n    function pause() public only_owner {\r\n        super.pause();\r\n    }\r\n\r\n\r\n    /**\r\n     * Resume the token changer making the contract \r\n     * convert tokens instead of reverting the transaction \r\n     */\r\n    function resume() public only_owner {\r\n        super.resume();\r\n    }\r\n\r\n\r\n    /**\r\n     * Request that the (old) drp smart-contract transfers `_value` worth \r\n     * of (old) drp to the drpu token converter to be converted\r\n     * \r\n     * Note! This function requires the drpu token converter smart-contract \r\n     * to be approved to spend at least `_value` worth of (old) drp by the \r\n     * owner of the tokens by calling the approve() function in the (old) \r\n     * dpr token smart-contract\r\n     *\r\n     * @param _value The amount of tokens to transfer and convert\r\n     */\r\n    function requestConversion(uint _value) public {\r\n        require(_value > 0);\r\n        address sender = msg.sender;\r\n\r\n        // Authenticate\r\n        require(!requireAuthentication || whitelist.authenticate(sender));\r\n\r\n        IToken drpToken = IToken(getLeftToken());\r\n        drpToken.transferFrom(sender, this, _value); // Transfer old drp from sender to converter \r\n        convert(drpToken, sender, _value); // Convert to drps\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe mechanism\r\n     * \r\n     * Allows the owner to retrieve tokens from the contract that \r\n     * might have been send there by accident\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public only_owner {\r\n        require(getLeftToken() != _tokenContract); // Ensure that the (old) drp token stays locked\r\n        super.retrieveTokens(_tokenContract);\r\n    }\r\n\r\n\r\n    /**\r\n     * Prevents the accidental sending of ether\r\n     */\r\n    function () payable {\r\n        revert();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLeftToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRightToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAuthenticating\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableAuthentication\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrecision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableAuthentication\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"requestConversion\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address\"},{\"name\":\"_drp\",\"type\":\"address\"},{\"name\":\"_drpu\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]","ContractName":"DRPUTokenConverter","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dd5cec9019ec8449a5d01d0d8175e6519530d276000000000000000000000000621d78f2ef2fd937bfca696cabaf9a779f59b3ed000000000000000000000000e30e02f049957e2a5907589e06ba646fb2c321ba","Library":"","SwarmSource":"bzzr://fbc3f6d904c0f39582ff2a653015a709440025df842c84d572adb13f23dfe73e"}]}