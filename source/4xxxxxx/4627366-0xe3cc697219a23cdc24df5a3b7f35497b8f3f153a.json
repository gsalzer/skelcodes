{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * IOwnership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IOwnership {\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public view returns (address);\r\n}\r\n\r\n\r\n/**\r\n * Ownership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract Ownership is IOwnership {\r\n\r\n    // Owner\r\n    address internal owner;\r\n\r\n\r\n    /**\r\n     * Access is restricted to the current owner\r\n     */\r\n    modifier only_owner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * The publisher is the inital owner\r\n     */\r\n    function Ownership() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool) {\r\n        return _account == owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ITransferableOwnership\r\n *\r\n * Enhances ownership by allowing the current owner to \r\n * transfer ownership to a new owner\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ITransferableOwnership {\r\n    \r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner) public;\r\n}\r\n\r\n\r\n\r\n/**\r\n * TransferableOwnership\r\n *\r\n * Enhances ownership by allowing the current owner to \r\n * transfer ownership to a new owner\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TransferableOwnership is ITransferableOwnership, Ownership {\r\n\r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner) public only_owner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * IAuthenticator \r\n *\r\n * Authenticator interface\r\n *\r\n * #created 15/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IAuthenticator {\r\n    \r\n\r\n    /**\r\n     * Authenticate \r\n     *\r\n     * Returns whether `_account` is authenticated or not\r\n     *\r\n     * @param _account The account to authenticate\r\n     * @return whether `_account` is successfully authenticated\r\n     */\r\n    function authenticate(address _account) public view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * IAuthenticationManager \r\n *\r\n * Allows the authentication process to be enabled and disabled\r\n *\r\n * #created 15/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IAuthenticationManager {\r\n    \r\n\r\n    /**\r\n     * Returns true if authentication is enabled and false \r\n     * otherwise\r\n     *\r\n     * @return Whether the converter is currently authenticating or not\r\n     */\r\n    function isAuthenticating() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Enable authentication\r\n     */\r\n    function enableAuthentication() public;\r\n\r\n\r\n    /**\r\n     * Disable authentication\r\n     */\r\n    function disableAuthentication() public;\r\n}\r\n\r\n\r\n/**\r\n * ERC20 compatible token interface\r\n *\r\n * - Implements ERC 20 Token standard\r\n * - Implements short address attack fix\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IToken { \r\n\r\n    /** \r\n     * Get the total supply of tokens\r\n     * \r\n     * @return The total supply\r\n     */\r\n    function totalSupply() public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * IManagedToken\r\n *\r\n * Adds the following functionality to the basic ERC20 token\r\n * - Locking\r\n * - Issuing\r\n * - Burning \r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IManagedToken { \r\n\r\n    /** \r\n     * Returns true if the token is locked\r\n     * \r\n     * @return Whether the token is locked\r\n     */\r\n    function isLocked() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Locks the token so that the transfering of value is disabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function lock() public returns (bool);\r\n\r\n\r\n    /**\r\n     * Unlocks the token so that the transfering of value is enabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function unlock() public returns (bool);\r\n\r\n\r\n    /**\r\n     * Issues `_value` new tokens to `_to`\r\n     *\r\n     * @param _to The address to which the tokens will be issued\r\n     * @param _value The amount of new tokens to issue\r\n     * @return Whether the tokens where sucessfully issued or not\r\n     */\r\n    function issue(address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /**\r\n     * Burns `_value` tokens of `_from`\r\n     *\r\n     * @param _from The address that owns the tokens to be burned\r\n     * @param _value The amount of tokens to be burned\r\n     * @return Whether the tokens where sucessfully burned or not \r\n     */\r\n    function burn(address _from, uint _value) public returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * ITokenRetriever\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public;\r\n}\r\n\r\n\r\n/**\r\n * TokenRetriever\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 18/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenRetriever is ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public {\r\n        IToken tokenInstance = IToken(_tokenContract);\r\n        uint tokenBalance = tokenInstance.balanceOf(this);\r\n        if (tokenBalance > 0) {\r\n            tokenInstance.transfer(msg.sender, tokenBalance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ITokenObserver\r\n *\r\n * Allows a token smart-contract to notify observers \r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ITokenObserver {\r\n\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value) public;\r\n}\r\n\r\n\r\n/**\r\n * TokenObserver\r\n *\r\n * Allows observers to be notified by an observed token smart-contract\r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenObserver is ITokenObserver {\r\n\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value) public {\r\n        onTokensReceived(msg.sender, _from, _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler\r\n     * \r\n     * Called by `_token` when a token amount is received\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal;\r\n}\r\n\r\n\r\n/**\r\n * IPausable\r\n *\r\n * Simple interface to pause and resume \r\n *\r\n * #created 11/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IPausable {\r\n\r\n\r\n    /**\r\n     * Returns whether the implementing contract is \r\n     * currently paused or not\r\n     *\r\n     * @return Whether the paused state is active\r\n     */\r\n    function isPaused() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Change the state to paused\r\n     */\r\n    function pause() public;\r\n\r\n\r\n    /**\r\n     * Change the state to resume, undo the effects \r\n     * of calling pause\r\n     */\r\n    function resume() public;\r\n}\r\n\r\n\r\n/**\r\n * ITokenChanger\r\n *\r\n * Basic token changer public interface \r\n *\r\n * #created 06/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ITokenChanger {\r\n\r\n\r\n    /**\r\n     * Returns true if '_token' is on of the tokens that are \r\n     * managed by this token changer\r\n     * \r\n     * @param _token The address being tested\r\n     * @return Whether the '_token' is part of this token changer\r\n     */\r\n    function isToken(address _token) public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns the address of the left token\r\n     *\r\n     * @return Left token address\r\n     */\r\n    function getLeftToken() public view returns (address);\r\n\r\n\r\n    /**\r\n     * Returns the address of the right token\r\n     *\r\n     * @return Right token address\r\n     */\r\n    function getRightToken() public view returns (address);\r\n\r\n\r\n    /**\r\n     * Returns the fee that is paid in tokens when using \r\n     * the token changer\r\n     *\r\n     * @return The percentage of tokens that is charged\r\n     */\r\n    function getFee() public view returns (uint);\r\n\r\n    \r\n    /**\r\n     * Returns the rate that is used to change between tokens\r\n     *\r\n     * @return The rate used when changing tokens\r\n     */\r\n    function getRate() public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Returns the precision of the rate and fee params\r\n     *\r\n     * @return The amount of decimals used\r\n     */\r\n    function getPrecision() public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Calculates and returns the fee based on `_value` of tokens\r\n     *\r\n     * @return The actual fee\r\n     */\r\n    function calculateFee(uint _value) public view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * TokenChanger\r\n *\r\n * Provides a generic way to convert between two tokens using a fixed \r\n * ratio and an optional fee.\r\n *\r\n * #created 06/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenChanger is ITokenChanger, IPausable {\r\n\r\n    IManagedToken private tokenLeft; // tokenLeft = tokenRight * rate / precision\r\n    IManagedToken private tokenRight; // tokenRight = tokenLeft / rate * precision\r\n\r\n    uint private rate; // Ratio between tokens\r\n    uint private fee; // Percentage lost in transfer\r\n    uint private precision; // Precision \r\n    bool private paused; // Paused state\r\n    bool private burn; // Whether the changer should burn tokens\r\n\r\n\r\n    /**\r\n     * Only if '_token' is the left or right token \r\n     * that of the token changer\r\n     */\r\n    modifier is_token(address _token) {\r\n        require(_token == address(tokenLeft) || _token == address(tokenRight));\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Construct token changer\r\n     *\r\n     * @param _tokenLeft Ref to the 'left' token smart-contract\r\n     * @param _tokenRight Ref to the 'right' token smart-contract\r\n     * @param _rate The rate used when changing tokens\r\n     * @param _fee The percentage of tokens that is charged\r\n     * @param _decimals The amount of decimals used for _rate and _fee\r\n     * @param _paused Whether the token changer starts in the paused state or not\r\n     * @param _burn Whether the changer should burn tokens or not\r\n     */\r\n    function TokenChanger(address _tokenLeft, address _tokenRight, uint _rate, uint _fee, uint _decimals, bool _paused, bool _burn) public {\r\n        tokenLeft = IManagedToken(_tokenLeft);\r\n        tokenRight = IManagedToken(_tokenRight);\r\n        rate = _rate;\r\n        fee = _fee;\r\n        precision = _decimals > 0 ? 10**_decimals : 1;\r\n        paused = _paused;\r\n        burn = _burn;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Returns true if '_token' is on of the tokens that are \r\n     * managed by this token changer\r\n     * \r\n     * @param _token The address being tested\r\n     * @return Whether the '_token' is part of this token changer\r\n     */\r\n    function isToken(address _token) public view returns (bool) {\r\n        return _token == address(tokenLeft) || _token == address(tokenRight);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the address of the left token\r\n     *\r\n     * @return Left token address\r\n     */\r\n    function getLeftToken() public view returns (address) {\r\n        return tokenLeft;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the address of the right token\r\n     *\r\n     * @return Right token address\r\n     */\r\n    function getRightToken() public view returns (address) {\r\n        return tokenRight;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the fee that is paid in tokens when using \r\n     * the token changer\r\n     *\r\n     * @return The percentage of tokens that is charged\r\n     */\r\n    function getFee() public view returns (uint) {\r\n        return fee;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the rate that is used to change between tokens\r\n     *\r\n     * @return The rate used when changing tokens\r\n     */\r\n    function getRate() public view returns (uint) {\r\n        return rate;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the precision of the rate and fee params\r\n     *\r\n     * @return The amount of decimals used\r\n     */\r\n    function getPrecision() public view returns (uint) {\r\n        return precision;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns whether the token changer is currently \r\n     * paused or not. While being in the paused state \r\n     * the contract should revert the transaction instead \r\n     * of converting tokens\r\n     *\r\n     * @return Whether the token changer is in the paused state\r\n     */\r\n    function isPaused() public view returns (bool) {\r\n        return paused;\r\n    }\r\n\r\n\r\n    /**\r\n     * Pause the token changer making the contract \r\n     * revert the transaction instead of converting \r\n     */\r\n    function pause() public {\r\n        paused = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Resume the token changer making the contract \r\n     * convert tokens instead of reverting the transaction \r\n     */\r\n    function resume() public {\r\n        paused = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Calculates and returns the fee based on `_value` of tokens\r\n     *\r\n     * @param _value The amount of tokens that is being converted\r\n     * @return The actual fee\r\n     */\r\n    function calculateFee(uint _value) public view returns (uint) {\r\n        return fee == 0 ? 0 : _value * fee / precision;\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts tokens by burning the tokens received at the token smart-contact \r\n     * located at `_from` and by issuing tokens at the opposite token smart-contract\r\n     *\r\n     * @param _from The token smart-contract that received the tokens\r\n     * @param _sender The account that send the tokens (token owner)\r\n     * @param _value The amount of tokens that where received\r\n     */\r\n    function convert(address _from, address _sender, uint _value) internal {\r\n        require(!paused);\r\n        require(_value > 0);\r\n\r\n        uint amountToIssue;\r\n        if (_from == address(tokenLeft)) {\r\n            amountToIssue = _value * rate / precision;\r\n            tokenRight.issue(_sender, amountToIssue - calculateFee(amountToIssue));\r\n            if (burn) {\r\n                tokenLeft.burn(this, _value);\r\n            }   \r\n        } \r\n        \r\n        else if (_from == address(tokenRight)) {\r\n            amountToIssue = _value * precision / rate;\r\n            tokenLeft.issue(_sender, amountToIssue - calculateFee(amountToIssue));\r\n            if (burn) {\r\n                tokenRight.burn(this, _value);\r\n            } \r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ATM Token Changer\r\n *\r\n * This contract of this token changer will allow anyone with a current balance of ATM, \r\n * to deposit it and in return receive KATX, or KATM.\r\n *\r\n * KATM maintaining the primary security functions of the KATM token as \r\n * outlined within the whitepaper.\r\n *\r\n * KATX as indicated by its ‘X’ designation is the utility token for those who are under strict \r\n * compliance within their country of residence, and does not entitle holders to profit sharing.\r\n *\r\n * #created 30/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract KATMTokenChanger is TokenChanger, TokenObserver, TransferableOwnership, TokenRetriever, IAuthenticationManager {\r\n\r\n    enum Stages {\r\n        Deploying,\r\n        Deployed\r\n    }\r\n\r\n    Stages public stage;\r\n\r\n    // Authentication\r\n    IAuthenticator private authenticator;\r\n    bool private requireAuthentication;\r\n\r\n\r\n    /**\r\n     * Throw if at stage other than current stage\r\n     * \r\n     * @param _stage expected stage to test for\r\n     */\r\n    modifier at_stage(Stages _stage) {\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Throw if not authenticated\r\n     * \r\n     * @param _account The account that is authenticated\r\n     */\r\n    modifier authenticate(address _account) {\r\n        require(!requireAuthentication || authenticator.authenticate(_account));\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Construct Security - Utility token changer\r\n     *\r\n     * @param _security Ref to the Security token smart-contract\r\n     * @param _utility Ref to the Utiltiy token smart-contract\r\n     */\r\n    function KATMTokenChanger(address _security, address _utility) public\r\n        TokenChanger(_security, _utility, 8000, 500, 4, false, true) {\r\n        stage = Stages.Deploying;\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup authentication\r\n     *\r\n     * @param _authenticator The address of the authenticator (whitelist)\r\n     * @param _requireAuthentication Wether the crowdale requires contributors to be authenticated\r\n     */\r\n    function setupWhitelist(address _authenticator, bool _requireAuthentication) public only_owner at_stage(Stages.Deploying) {\r\n        authenticator = IAuthenticator(_authenticator);\r\n        requireAuthentication = _requireAuthentication;\r\n    }\r\n\r\n\r\n    /**\r\n     * After calling the deploy function the crowdsale\r\n     * rules become immutable \r\n     */\r\n    function deploy() public only_owner at_stage(Stages.Deploying) {\r\n        stage = Stages.Deployed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if authentication is enabled and false \r\n     * otherwise\r\n     *\r\n     * @return Whether the converter is currently authenticating or not\r\n     */\r\n    function isAuthenticating() public view returns (bool) {\r\n        return requireAuthentication;\r\n    }\r\n\r\n\r\n    /**\r\n     * Enable authentication\r\n     */\r\n    function enableAuthentication() public only_owner {\r\n        requireAuthentication = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Disable authentication\r\n     */\r\n    function disableAuthentication() public only_owner {\r\n        requireAuthentication = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Pause the token changer making the contract \r\n     * revert the transaction instead of converting \r\n     */\r\n    function pause() public only_owner {\r\n        super.pause();\r\n    }\r\n\r\n\r\n    /**\r\n     * Resume the token changer making the contract \r\n     * convert tokens instead of reverting the transaction \r\n     */\r\n    function resume() public only_owner {\r\n        super.resume();\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler that initializes the token conversion\r\n     * \r\n     * Called by `_token` when a token amount is received on \r\n     * the address of this token changer\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal is_token(_token) authenticate(_from) at_stage(Stages.Deployed) {\r\n        require(_token == msg.sender);\r\n        \r\n        // Convert tokens\r\n        convert(_token, _from, _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe mechanism\r\n     * \r\n     * Allows the owner to retrieve tokens from the contract that \r\n     * might have been send there by accident\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public only_owner {\r\n        super.retrieveTokens(_tokenContract);\r\n    }\r\n\r\n\r\n    /**\r\n     * Prevents the accidental sending of ether\r\n     */\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLeftToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRightToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"notifyTokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAuthenticating\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableAuthentication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrecision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authenticator\",\"type\":\"address\"},{\"name\":\"_requireAuthentication\",\"type\":\"bool\"}],\"name\":\"setupWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableAuthentication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_security\",\"type\":\"address\"},{\"name\":\"_utility\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"KATMTokenChanger","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009c0e795ddf3b0655ab378a3551b36a036e93dc180000000000000000000000005fc5e27d5f22e609d80fd4b5df02740f73c57fe4","Library":"","SwarmSource":"bzzr://0ea6972166ded9c87491406cb8e854cd094a4b719b9524deadb81d2562bb03c0"}]}