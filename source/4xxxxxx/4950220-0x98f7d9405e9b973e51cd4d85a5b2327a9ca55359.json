{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n//Slightly modified SafeMath library - includes a min function\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n//ERC20 function interface\r\ninterface ERC20_Interface {\r\n  function totalSupply() public constant returns (uint total_supply);\r\n  function balanceOf(address _owner) public constant returns (uint balance);\r\n  function transfer(address _to, uint _amount) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint _amount) public returns (bool success);\r\n  function approve(address _spender, uint _amount) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public constant returns (uint amount);\r\n}\r\n\r\n//Swap factory functions - descriptions can be found in Factory.sol\r\ninterface Factory_Interface {\r\n  function createToken(uint _supply, address _party, bool _long, uint _start_date) public returns (address created, uint token_ratio);\r\n  function payToken(address _party, address _token_add) public;\r\n  function deployContract(uint _start_date) public payable returns (address created);\r\n   function getBase() public view returns(address _base1, address base2);\r\n  function getVariables() public view returns (address oracle_addr, uint swap_duration, uint swap_multiplier, address token_a_addr, address token_b_addr);\r\n}\r\n\r\n\r\n//DRCT_Token functions - descriptions can be found in DRCT_Token.sol\r\ninterface DRCT_Token_Interface {\r\n  function addressCount(address _swap) public constant returns (uint count);\r\n  function getHolderByIndex(uint _ind, address _swap) public constant returns (address holder);\r\n  function getBalanceByIndex(uint _ind, address _swap) public constant returns (uint bal);\r\n  function getIndexByAddress(address _owner, address _swap) public constant returns (uint index);\r\n  function createToken(uint _supply, address _owner, address _swap) public;\r\n  function pay(address _party, address _swap) public;\r\n  function partyCount(address _swap) public constant returns(uint count);\r\n}\r\n\r\n\r\n//Swap Oracle functions - descriptions can be found in Oracle.sol\r\ninterface Oracle_Interface{\r\n  function RetrieveData(uint _date) public view returns (uint data);\r\n}\r\n\r\n\r\n//This contract is the specific DRCT base contract that holds the funds of the contract and redistributes them based upon the change in the underlying values\r\ncontract TokenToTokenSwap {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  /*Enums*/\r\n  //Describes various states of the Swap\r\n  enum SwapState {\r\n    created,\r\n    open,\r\n    started,\r\n    tokenized,\r\n    ready,\r\n    ended\r\n  }\r\n\r\n  /*Variables*/\r\n\r\n  //Address of the person who created this contract through the Factory\r\n  address creator;\r\n  //The Oracle address (check for list at www.github.com/DecentralizedDerivatives/Oracles)\r\n  address oracle_address;\r\n  Oracle_Interface oracle;\r\n\r\n  //Address of the Factory that created this contract\r\n  address public factory_address;\r\n  Factory_Interface factory;\r\n\r\n  //Addresses of parties going short and long the rate\r\n  address public long_party;\r\n  address public short_party;\r\n\r\n  //Enum state of the swap\r\n  SwapState public current_state;\r\n\r\n  //Start and end dates of the swaps - format is the same as block.timestamp\r\n  uint start_date;\r\n  uint end_date;\r\n\r\n  //This is the amount that the change will be calculated on.  10% change in rate on 100 Ether notional is a 10 Ether change\r\n  uint multiplier;\r\n\r\n  //This is the calculated share for the long and short side of the swap (200,000 is a fully capped move)\r\n  uint share_long;\r\n  uint share_short;\r\n\r\n  // pay_to_x refers to the amount of the base token (a or b) to pay to the long or short side based upon the share_long and share_short\r\n  uint pay_to_short_a;\r\n  uint pay_to_long_a;\r\n  uint pay_to_long_b;\r\n  uint pay_to_short_b;\r\n\r\n  //Address of created long and short DRCT tokens\r\n  address long_token_address;\r\n  address short_token_address;\r\n\r\n  //Number of DRCT Tokens distributed to both parties\r\n  uint num_DRCT_longtokens;\r\n  uint num_DRCT_shorttokens;\r\n\r\n  //Addresses of ERC20 tokens used to enter the swap\r\n  address token_a_address;\r\n  address token_b_address;\r\n\r\n  //Tokens A and B used for the notional\r\n  ERC20_Interface token_a;\r\n  ERC20_Interface token_b;\r\n\r\n  //The notional that the payment is calculated on from the change in the reference rate\r\n  uint public token_a_amount;\r\n  uint public token_b_amount;\r\n\r\n  uint public premium;\r\n\r\n  //Addresses of the two parties taking part in the swap\r\n  address token_a_party;\r\n  address token_b_party;\r\n\r\n  //Duration of the swap,pulled from the Factory contract\r\n  uint duration;\r\n  //Date by which the contract must be funded\r\n  uint enterDate;\r\n  DRCT_Token_Interface token;\r\n  address userContract;\r\n\r\n  /*Events*/\r\n\r\n  //Emitted when a Swap is created\r\n  event SwapCreation(address _token_a, address _token_b, uint _start_date, uint _end_date, address _creating_party);\r\n  //Emitted when the swap has been paid out\r\n  event PaidOut(address _long_token, address _short_token);\r\n\r\n  /*Modifiers*/\r\n\r\n  //Will proceed only if the contract is in the expected state\r\n  modifier onlyState(SwapState expected_state) {\r\n    require(expected_state == current_state);\r\n    _;\r\n  }\r\n\r\n  /*Functions*/\r\n\r\n  /*\r\n  * Constructor - Run by the factory at contract creation\r\n  *\r\n  * @param \"_factory_address\": Address of the factory that created this contract\r\n  * @param \"_creator\": Address of the person who created the contract\r\n  * @param \"_userContract\": Address of the _userContract that is authorized to interact with this contract\r\n  */\r\n  function TokenToTokenSwap (address _factory_address, address _creator, address _userContract, uint _start_date) public {\r\n    current_state = SwapState.created;\r\n    creator =_creator;\r\n    factory_address = _factory_address;\r\n    userContract = _userContract;\r\n    start_date = _start_date;\r\n  }\r\n\r\n\r\n  //A getter function for retriving standardized variables from the factory contract\r\n  function showPrivateVars() public view returns (address _userContract, uint num_DRCT_long, uint numb_DRCT_short, uint swap_share_long, uint swap_share_short, address long_token_addr, address short_token_addr, address oracle_addr, address token_a_addr, address token_b_addr, uint swap_multiplier, uint swap_duration, uint swap_start_date, uint swap_end_date){\r\n    return (userContract, num_DRCT_longtokens, num_DRCT_shorttokens,share_long,share_short,long_token_address,short_token_address, oracle_address, token_a_address, token_b_address, multiplier, duration, start_date, end_date);\r\n  }\r\n\r\n  /*\r\n  * Allows the sender to create the terms for the swap\r\n  * @param \"_amount_a\": Amount of Token A that should be deposited for the notional\r\n  * @param \"_amount_b\": Amount of Token B that should be deposited for the notional\r\n  * @param \"_sender_is_long\": Denotes whether the sender is set as the short or long party\r\n  * @param \"_senderAdd\": States the owner of this side of the contract (does not have to be msg.sender)\r\n  */\r\n  function CreateSwap(\r\n    uint _amount_a,\r\n    uint _amount_b,\r\n    bool _sender_is_long,\r\n    address _senderAdd\r\n    ) payable public onlyState(SwapState.created) {\r\n\r\n    require(\r\n      msg.sender == creator || (msg.sender == userContract && _senderAdd == creator)\r\n    );\r\n    factory = Factory_Interface(factory_address);\r\n    setVars();\r\n    end_date = start_date.add(duration.mul(86400));\r\n    token_a_amount = _amount_a;\r\n    token_b_amount = _amount_b;\r\n\r\n    premium = this.balance;\r\n    token_a = ERC20_Interface(token_a_address);\r\n    token_a_party = _senderAdd;\r\n    if (_sender_is_long)\r\n      long_party = _senderAdd;\r\n    else\r\n      short_party = _senderAdd;\r\n    current_state = SwapState.open;\r\n  }\r\n\r\n  function setVars() internal{\r\n      (oracle_address,duration,multiplier,token_a_address,token_b_address) = factory.getVariables();\r\n  }\r\n\r\n  /*\r\n  * This function is for those entering the swap. The details of the swap are re-entered and checked\r\n  * to ensure the entering party is entering the correct swap. Note that the tokens you are entering with\r\n  * do not need to be entered as a variable, but you should ensure that the contract is funded.\r\n  *\r\n  * @param: all parameters have the same functions as those in the CreateSwap function\r\n  */\r\n  function EnterSwap(\r\n    uint _amount_a,\r\n    uint _amount_b,\r\n    bool _sender_is_long,\r\n    address _senderAdd\r\n    ) public onlyState(SwapState.open) {\r\n\r\n    //Require that all of the information of the swap was entered correctly by the entering party.  Prevents partyA from exiting and changing details\r\n    require(\r\n      token_a_amount == _amount_a &&\r\n      token_b_amount == _amount_b &&\r\n      token_a_party != _senderAdd\r\n    );\r\n\r\n    token_b = ERC20_Interface(token_b_address);\r\n    token_b_party = _senderAdd;\r\n\r\n    //Set the entering party as the short or long party\r\n    if (_sender_is_long) {\r\n      require(long_party == 0);\r\n      long_party = _senderAdd;\r\n    } else {\r\n      require(short_party == 0);\r\n      short_party = _senderAdd;\r\n    }\r\n\r\n    SwapCreation(token_a_address, token_b_address, start_date, end_date, token_b_party);\r\n    enterDate = now;\r\n    current_state = SwapState.started;\r\n  }\r\n\r\n  /*\r\n  * This function creates the DRCT tokens for the short and long parties, and ensures the short and long parties\r\n  * have funded the contract with the correct amount of the ERC20 tokens A and B\r\n  *\r\n  */\r\n  function createTokens() public onlyState(SwapState.started){\r\n\r\n    //Ensure the contract has been funded by tokens a and b within 1 day\r\n    require(\r\n      now < (enterDate + 86400) &&\r\n      token_a.balanceOf(address(this)) >= token_a_amount &&\r\n      token_b.balanceOf(address(this)) >= token_b_amount\r\n    );\r\n\r\n    uint tokenratio = 1;\r\n    (long_token_address,tokenratio) = factory.createToken(token_a_amount, long_party,true,start_date);\r\n    num_DRCT_longtokens = token_a_amount.div(tokenratio);\r\n    (short_token_address,tokenratio) = factory.createToken(token_b_amount, short_party,false,start_date);\r\n    num_DRCT_shorttokens = token_b_amount.div(tokenratio);\r\n    current_state = SwapState.tokenized;\r\n    if (premium > 0){\r\n      if (creator == long_party){\r\n      short_party.transfer(premium);\r\n      }\r\n      else {\r\n        long_party.transfer(premium);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  * This function calculates the payout of the swap. It can be called after the Swap has been tokenized.\r\n  * The value of the underlying cannot reach zero, but rather can only get within 0.001 * the precision\r\n  * of the Oracle.\r\n  */\r\n  function Calculate() internal {\r\n    require(now >= end_date + 86400);\r\n    //Comment out above for testing purposes\r\n    oracle = Oracle_Interface(oracle_address);\r\n    uint start_value = oracle.RetrieveData(start_date);\r\n    uint end_value = oracle.RetrieveData(end_date);\r\n\r\n    uint ratio;\r\n    if (start_value > 0 && end_value > 0)\r\n      ratio = (end_value).mul(100000).div(start_value);\r\n    else if (end_value > 0)\r\n      ratio = 10e10;\r\n    else if (start_value > 0)\r\n      ratio = 0;\r\n    else\r\n      ratio = 100000;\r\n    if (ratio == 100000) {\r\n      share_long = share_short = ratio;\r\n    } else if (ratio > 100000) {\r\n      share_long = ((ratio).sub(100000)).mul(multiplier).add(100000);\r\n      if (share_long >= 200000)\r\n        share_short = 0;\r\n      else\r\n        share_short = 200000-share_long;\r\n    } else {\r\n      share_short = SafeMath.sub(100000,ratio).mul(multiplier).add(100000);\r\n       if (share_short >= 200000)\r\n        share_long = 0;\r\n      else\r\n        share_long = 200000- share_short;\r\n    }\r\n\r\n    //Calculate the payouts to long and short parties based on the short and long shares\r\n    calculatePayout();\r\n\r\n    current_state = SwapState.ready;\r\n  }\r\n\r\n  /*\r\n  * Calculates the amount paid to the short and long parties per token\r\n  */\r\n  function calculatePayout() internal {\r\n    uint ratio;\r\n    token_a_amount = token_a_amount.mul(995).div(1000);\r\n    token_b_amount = token_b_amount.mul(995).div(1000);\r\n    //If ratio is flat just swap tokens, otherwise pay the winner the entire other token and only pay the other side a portion of the opposite token\r\n    if (share_long == 100000) {\r\n      pay_to_short_a = (token_a_amount).div(num_DRCT_longtokens);\r\n      pay_to_long_b = (token_b_amount).div(num_DRCT_shorttokens);\r\n      pay_to_short_b = 0;\r\n      pay_to_long_a = 0;\r\n    } else if (share_long > 100000) {\r\n      ratio = SafeMath.min(100000, (share_long).sub(100000));\r\n      pay_to_long_b = (token_b_amount).div(num_DRCT_shorttokens);\r\n      pay_to_short_a = (SafeMath.sub(100000,ratio)).mul(token_a_amount).div(num_DRCT_longtokens).div(100000);\r\n      pay_to_long_a = ratio.mul(token_a_amount).div(num_DRCT_longtokens).div(100000);\r\n      pay_to_short_b = 0;\r\n    } else {\r\n      ratio = SafeMath.min(100000, (share_short).sub(100000));\r\n      pay_to_short_a = (token_a_amount).div(num_DRCT_longtokens);\r\n      pay_to_long_b = (SafeMath.sub(100000,ratio)).mul(token_b_amount).div(num_DRCT_shorttokens).div(100000);\r\n      pay_to_short_b = ratio.mul(token_b_amount).div(num_DRCT_shorttokens).div(100000);\r\n      pay_to_long_a = 0;\r\n    }\r\n  }\r\n\r\n  /*\r\n  * This function can be called after the swap is tokenized or after the Calculate function is called.\r\n  * If the Calculate function has not yet been called, this function will call it.\r\n  * The function then pays every token holder of both the long and short DRCT tokens\r\n  */\r\n  function forcePay(uint _begin, uint _end) public returns (bool) {\r\n    //Calls the Calculate function first to calculate short and long shares\r\n    if(current_state == SwapState.tokenized /*&& now > end_date + 86400*/){\r\n      Calculate();\r\n    }\r\n\r\n    //The state at this point should always be SwapState.ready\r\n    require(current_state == SwapState.ready);\r\n\r\n    //Loop through the owners of long and short DRCT tokens and pay them\r\n\r\n    token = DRCT_Token_Interface(long_token_address);\r\n    uint count = token.addressCount(address(this));\r\n    uint loop_count = count < _end ? count : _end;\r\n    //Indexing begins at 1 for DRCT_Token balances\r\n    for(uint i = loop_count-1; i >= _begin ; i--) {\r\n      address long_owner = token.getHolderByIndex(i, address(this));\r\n      uint to_pay_long = token.getBalanceByIndex(i, address(this));\r\n      paySwap(long_owner, to_pay_long, true);\r\n    }\r\n\r\n    token = DRCT_Token_Interface(short_token_address);\r\n    count = token.addressCount(address(this));\r\n    loop_count = count < _end ? count : _end;\r\n    for(uint j = loop_count-1; j >= _begin ; j--) {\r\n      address short_owner = token.getHolderByIndex(j, address(this));\r\n      uint to_pay_short = token.getBalanceByIndex(j, address(this));\r\n      paySwap(short_owner, to_pay_short, false);\r\n    }\r\n\r\n    if (loop_count == count){\r\n        token_a.transfer(factory_address, token_a.balanceOf(address(this)));\r\n        token_b.transfer(factory_address, token_b.balanceOf(address(this)));\r\n        PaidOut(long_token_address, short_token_address);\r\n        current_state = SwapState.ended;\r\n      }\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * This function pays the receiver an amount determined by the Calculate function\r\n  *\r\n  * @param \"_receiver\": The recipient of the payout\r\n  * @param \"_amount\": The amount of token the recipient holds\r\n  * @param \"_is_long\": Whether or not the reciever holds a long or short token\r\n  */\r\n  function paySwap(address _receiver, uint _amount, bool _is_long) internal {\r\n    if (_is_long) {\r\n      if (pay_to_long_a > 0)\r\n        token_a.transfer(_receiver, _amount.mul(pay_to_long_a));\r\n      if (pay_to_long_b > 0){\r\n        token_b.transfer(_receiver, _amount.mul(pay_to_long_b));\r\n      }\r\n        factory.payToken(_receiver,long_token_address);\r\n    } else {\r\n\r\n      if (pay_to_short_a > 0)\r\n        token_a.transfer(_receiver, _amount.mul(pay_to_short_a));\r\n      if (pay_to_short_b > 0){\r\n        token_b.transfer(_receiver, _amount.mul(pay_to_short_b));\r\n      }\r\n       factory.payToken(_receiver,short_token_address);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n  * This function allows both parties to exit. If only the creator has entered the swap, then the swap can be cancelled and the details modified\r\n  * Once two parties enter the swap, the contract is null after cancelled. Once tokenized however, the contract cannot be ended.\r\n  */\r\n  function Exit() public {\r\n   if (current_state == SwapState.open && msg.sender == token_a_party) {\r\n      token_a.transfer(token_a_party, token_a_amount);\r\n      if (premium>0){\r\n        msg.sender.transfer(premium);\r\n      }\r\n      delete token_a_amount;\r\n      delete token_b_amount;\r\n      delete premium;\r\n      current_state = SwapState.created;\r\n    } else if (current_state == SwapState.started && (msg.sender == token_a_party || msg.sender == token_b_party)) {\r\n      if (msg.sender == token_a_party || msg.sender == token_b_party) {\r\n        token_b.transfer(token_b_party, token_b.balanceOf(address(this)));\r\n        token_a.transfer(token_a_party, token_a.balanceOf(address(this)));\r\n        current_state = SwapState.ended;\r\n        if (premium > 0) { creator.transfer(premium);}\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n//Swap Deployer Contract-- purpose is to save gas for deployment of Factory contract\r\ncontract Deployer {\r\n  address owner;\r\n  address factory;\r\n\r\n  function Deployer(address _factory) public {\r\n    factory = _factory;\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function newContract(address _party, address user_contract, uint _start_date) public returns (address created) {\r\n    require(msg.sender == factory);\r\n    address new_contract = new TokenToTokenSwap(factory, _party, user_contract, _start_date);\r\n    return new_contract;\r\n  }\r\n\r\n   function setVars(address _factory, address _owner) public {\r\n    require (msg.sender == owner);\r\n    factory = _factory;\r\n    owner = _owner;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_party\",\"type\":\"address\"},{\"name\":\"user_contract\",\"type\":\"address\"},{\"name\":\"_start_date\",\"type\":\"uint256\"}],\"name\":\"newContract\",\"outputs\":[{\"name\":\"created\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setVars\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Deployer","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000003ebd304d88cccd39b1bac77b7fe760e21c2","Library":"","SwarmSource":"bzzr://aaecef3345113326e06115cee803e2c27477f38ee9b68ccf0d4eb47779826b3c"}]}