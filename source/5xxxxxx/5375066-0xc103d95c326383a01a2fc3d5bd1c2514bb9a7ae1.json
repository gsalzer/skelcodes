{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// Dev fee payout contract + dividend options \r\n// EtherGuy DApp fee will be stored here \r\n// Buying any token gives right to claim part of development dividends.\r\n// It is suggested you do withdraw once in a while. If someone still finds an attack after this fixed contrat \r\n// they are unable the steal any of your withdrawn eth. Withdrawing does not sell your tokens!\r\n// UI: etherguy.surge.sh/dividend.html\r\n// Made by EtherGuy, etherguy@mail.com \r\n// Version 2 of contract. Exploit(s) found by ccashwell in v1, thanks for reporting them!\r\n\r\n\r\n// IF THERE IS ANY BUG the data will be rerolled from here. See the discord https://discord.gg/R84hD6f if anything happens or mail me \r\n\r\n\r\ncontract Dividends{\r\n    // 10 million token supply \r\n    uint256 constant TokenSupply = 10000000;\r\n    \r\n    uint256 public TotalPaid = 0;\r\n    \r\n    uint16 public Tax = 1250; \r\n    \r\n    address dev;\r\n    \r\n    bool public StopSell=false; // in case aonther bug is found, stop selling so it is easier to give everyone their tokens back. \r\n    \r\n    mapping (address => uint256) public MyTokens;\r\n    mapping (address => uint256) public DividendCollectSince;\r\n    \r\n    // TKNS / PRICE \r\n    mapping(address => uint256[2]) public SellOrder;\r\n    \r\n    // web \r\n    // returns tokens + price (in wei)\r\n    function GetSellOrderDetails(address who) public view returns (uint256, uint256){\r\n        return (SellOrder[who][0], SellOrder[who][1]);\r\n    }\r\n    \r\n    function ViewMyTokens(address who) public view returns (uint256){\r\n        return MyTokens[who];\r\n    }\r\n\r\n    \r\n    function ViewMyDivs(address who) public view returns (uint256){\r\n        uint256 tkns = MyTokens[who];\r\n        if (tkns==0){\r\n            return 0;\r\n        }\r\n        return (GetDividends(who, tkns));\r\n    }\r\n    \r\n    function Bal() public view returns (uint256){\r\n        return (address(this).balance);\r\n    }\r\n    \r\n    // >MINT IT\r\n    function Dividends() public {\r\n        dev = msg.sender;\r\n        // EG\r\n        MyTokens[msg.sender] =  8000000;// was: TokenSupply - 400000;\r\n        // HE\r\n        MyTokens[address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285)] = 200000;\r\n        // PG\r\n        MyTokens[address(0x26581d1983ced8955C170eB4d3222DCd3845a092)] = 200000;\r\n        //MyTokens[address(0x0)] = 400000;\r\n        \r\n        // Since not a lot of addresses bought, we can instantly restore this \r\n        // If this happens in the future, we will need users to do a single transaction to retrieve their tokens from \r\n        // previous contract and withdraw all amount immediately \r\n        // Below tokens are paid for - 0.5 szabo per token (cheap right? blame the develo --- oh wait :D )\r\n        \r\n        MyTokens[address(0x3130259deEdb3052E24FAD9d5E1f490CB8CCcaa0)] = 100000;\r\n        MyTokens[address(0x4f0d861281161f39c62B790995fb1e7a0B81B07b)] = 200000;\r\n        MyTokens[address(0x36E058332aE39efaD2315776B9c844E30d07388B)] =  20000;\r\n        MyTokens[address(0x1f2672E17fD7Ec4b52B7F40D41eC5C477fe85c0c)] =  40000;\r\n        MyTokens[address(0xedDaD54E9e1F8dd01e815d84b255998a0a901BbF)] =  20000;\r\n        MyTokens[address(0x0a3239799518E7F7F339867A4739282014b97Dcf)] = 500000;\r\n        MyTokens[address(0x29A9c76aD091c015C12081A1B201c3ea56884579)] = 600000;\r\n        MyTokens[address(0x0668deA6B5ec94D7Ce3C43Fe477888eee2FC1b2C)] = 100000;\r\n        MyTokens[address(0x0982a0bf061f3cec2a004b4d2c802F479099C971)] =  20000;\r\n        //                                                              ------+\r\n        //                                                             1600000 = 1.6M which corresponds to the sell volume. Nice.     +400k + 8M = 10M, which corresponds to token supply                                                          \r\n        \r\n        //PlaceSellOrder(1600000, (0.5 szabo)); // 1 token per 0.5 szabo / 500 gwei or 1000 tokens per 0.5 finney / 0.0005 ether or 1M tokens per 0.5 ETH \r\n    }\r\n    \r\n    function GetDividends(address who, uint256 TokenAmount ) internal view  returns(uint256){\r\n        if (TokenAmount == 0){\r\n            return 0;\r\n        }\r\n        uint256 TotalContractIn = address(this).balance + TotalPaid;\r\n        // division rounds DOWN so we never pay too much\r\n        // no revert errors due to this. \r\n        \r\n        uint256 MyBalance = sub(TotalContractIn, DividendCollectSince[who]);\r\n        \r\n        return  ((MyBalance * TokenAmount) / (TokenSupply));\r\n    }\r\n    \r\n    // dev can stop selling \r\n    // this does NOT DISABLE withdrawing \r\n    function EmergencyStopSell(bool setting) public {\r\n        require(msg.sender==dev);\r\n        StopSell=setting;\r\n    }\r\n    \r\n\r\n    event Sold(address Buyer, address Seller, uint256 price, uint256 tokens);\r\n    // price_max anti-scam arg \r\n    function Buy(address who, uint256 price_max) public payable {\r\n       // require(msg.value >= (1 szabo)); // normal amounts pls \r\n        // lookup order by addr \r\n        require(!StopSell);\r\n        require(who!=msg.sender && who!=tx.origin);\r\n        uint256[2] storage order = SellOrder[who];\r\n        uint256 amt_available = order[0];\r\n        uint256 price = order[1];\r\n        \r\n        // only buy for certain price \r\n        require(price <= price_max);\r\n        \r\n        uint256 excess = 0;\r\n        \r\n        // nothing to sell \r\n        if (amt_available == 0){\r\n            revert();\r\n        }\r\n        \r\n        // high price overflow prevent (ccashwell)\r\n        uint256 max = mul(amt_available, price); \r\n        uint256 currval = msg.value;\r\n        // more than max buy value \r\n        if (currval > max){\r\n            excess = (currval-max);\r\n            currval = max;\r\n        }\r\n        \r\n\r\n\r\n\r\n        uint256 take = currval / price;\r\n        \r\n        if (take == 0){\r\n            revert(); // very high price apparently \r\n        }\r\n        excess = excess + sub(currval, mul(take, price)); \r\n        // do not take max value off .\r\n        currval = sub(currval,sub(currval, mul(take, price)));\r\n        \r\n        // pay fees \r\n\r\n        uint256 fee = (mul(Tax, currval))/10000;\r\n\r\n        \r\n        // the person with these tokens will also receive dividend over this buy order (this.balance)\r\n        // however the excess is removed, see the excess transfer above \r\n     //   if (msg.value > (excess+currval+fee)){\r\n      //      msg.sender.transfer(msg.value-excess-currval-fee);\r\n     //   }\r\n\r\n\r\n        MyTokens[who] = MyTokens[who] - take; \r\n        SellOrder[who][0] = SellOrder[who][0]-take; \r\n        MyTokens[msg.sender] = MyTokens[msg.sender] + take;\r\n    //    MyPayouts[msg.sender] = MyPayouts[msg.sender] + GetDividends(msg.sender, take);\r\n        //DividendCollectSince[msg.sender] = (address(this).balance) + TotalPaid;\r\n        \r\n        emit Sold(msg.sender, who, price, take);\r\n       // push((excess + currval)/(1 finney), (msg.value)/(1 finney));\r\n       \r\n       // all transfers at end \r\n       \r\n       \r\n        dev.transfer(fee);\r\n        who.transfer(currval-fee);\r\n        if ((excess) > 0){\r\n            msg.sender.transfer(excess);\r\n        }\r\n        // call withdraw with tokens before data change \r\n        _withdraw(who, MyTokens[who]+take);\r\n        //DividendCollectSince[msg.sender] = (address(this).balance) + TotalPaid;\r\n        if (sub(MyTokens[msg.sender],take) > 0){\r\n            _withdraw(msg.sender,MyTokens[msg.sender]-take);    \r\n        }\r\n        else{\r\n            // withdraw zero tokens to set DividendCollectSince to the right place. \r\n            // updates before this break the withdraw if user has any tokens .\r\n            _withdraw(msg.sender, 0);\r\n        }\r\n        \r\n        \r\n        \r\n    }\r\n    \r\n    function Withdraw() public {\r\n        _withdraw(msg.sender, MyTokens[msg.sender]);\r\n    }\r\n    \r\n    \r\n    event GiveETH(address who, uint256 yummy_eth);\r\n    function _withdraw(address who, uint256 amt) internal{\r\n        // withdraws from amt. \r\n        // (amt not used in current code, always same value)\r\n       // if (MyTokens[who] < amt){\r\n        //    revert(); // ??? security check \r\n       // }\r\n        \r\n        uint256 divs = GetDividends(who, amt);\r\n        TotalPaid = TotalPaid + divs;\r\n        DividendCollectSince[who] = sub(TotalPaid + address(this).balance, divs);\r\n        \r\n        // muh logs \r\n        emit GiveETH(who, divs);\r\n        \r\n        who.transfer(divs);\r\n\r\n    }\r\n    \r\n    event SellOrderPlaced(address who, uint256 amt, uint256 price);\r\n    function PlaceSellOrder(uint256 amt, uint256 price) public {\r\n        // replaces old order \r\n        if (amt > MyTokens[msg.sender]){\r\n            revert(); // ?? more sell than you got \r\n        }\r\n        SellOrder[msg.sender] = [amt,price];\r\n        emit SellOrderPlaced(msg.sender, amt, price);\r\n    }\r\n    \r\n    function ChangeTax(uint16 amt) public {\r\n        require (amt <= 2500);\r\n        require(msg.sender == dev);\r\n        Tax=amt;\r\n    }\r\n    \r\n\r\n    \r\n    // dump divs in contract \r\n    function() public payable {\r\n        \r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    } \r\n    \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ViewMyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PlaceSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"MyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"setting\",\"type\":\"bool\"}],\"name\":\"EmergencyStopSell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Tax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"GetSellOrderDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"DividendCollectSince\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint16\"}],\"name\":\"ChangeTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SellOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ViewMyDivs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"StopSell\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Bal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"price_max\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"yummy_eth\",\"type\":\"uint256\"}],\"name\":\"GiveETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"SellOrderPlaced\",\"type\":\"event\"}]","ContractName":"Dividends","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2be1ee878972386eeaa1c7897d6fdf44f9a585e613f09fd88ac62606be67918d"}]}