{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// File: contracts\\Convertible.sol\r\n\r\n/**\r\n * Exchange all my ParcelX token to mainchain GPX\r\n */\r\ncontract Convertible {\r\n\r\n    function convertMainchainGPX(string destinationAccount, string extra) external returns (bool);\r\n  \r\n    // ParcelX deamon program is monitoring this event. \r\n    // Once it triggered, ParcelX will transfer corresponding GPX to destination account\r\n    event Converted(address indexed who, string destinationAccount, uint256 amount, string extra);\r\n}\r\n\r\n// File: contracts\\ERC20.sol\r\n\r\n/**\r\n * Starndard ERC20 interface: https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n    /**\t\r\n    * @dev Fix for the ERC20 short address attack.\t\r\n    * Remove short address attack checks from tokens(https://github.com/OpenZeppelin/openzeppelin-solidity/issues/261)\r\n    */\t\r\n    modifier onlyPayloadSize(uint256 size) {\t\r\n        require(msg.data.length >= size + 4);\r\n        _;\t\r\n    }\r\n    \r\n}\r\n\r\n// File: contracts\\MultiOwnable.sol\r\n\r\n/**\r\n * FEATURE 2): MultiOwnable implementation\r\n * Transactions approved by _multiRequires of _multiOwners' addresses will be executed. \r\n\r\n * All functions needing unit-tests cannot be INTERNAL\r\n */\r\ncontract MultiOwnable {\r\n\r\n    address[8] m_owners;\r\n    uint m_numOwners;\r\n    uint m_multiRequires;\r\n\r\n    mapping (bytes32 => uint) internal m_pendings;\r\n\r\n    event AcceptConfirm(address indexed who, uint confirmTotal);\r\n    \r\n    // constructor is given number of sigs required to do protected \"multiOwner\" transactions\r\n    function MultiOwnable (address[] _multiOwners, uint _multiRequires) public {\r\n        require(0 < _multiRequires && _multiRequires <= _multiOwners.length);\r\n        m_numOwners = _multiOwners.length;\r\n        require(m_numOwners <= 8);   // Bigger then 8 co-owners, not support !\r\n        for (uint i = 0; i < _multiOwners.length; ++i) {\r\n            m_owners[i] = _multiOwners[i];\r\n            require(m_owners[i] != address(0));\r\n        }\r\n        m_multiRequires = _multiRequires;\r\n    }\r\n\r\n    // Any one of the owners, will approve the action\r\n    modifier anyOwner {\r\n        if (isOwner(msg.sender)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    // Requiring num > m_multiRequires owners, to approve the action\r\n    modifier mostOwner(bytes32 operation) {\r\n        if (checkAndConfirm(msg.sender, operation)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function isOwner(address currentUser) public view returns (bool) {\r\n        for (uint i = 0; i < m_numOwners; ++i) {\r\n            if (m_owners[i] == currentUser) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function checkAndConfirm(address currentUser, bytes32 operation) public returns (bool) {\r\n        uint ownerIndex = m_numOwners;\r\n        uint i;\r\n        for (i = 0; i < m_numOwners; ++i) {\r\n            if (m_owners[i] == currentUser) {\r\n                ownerIndex = i;\r\n            }\r\n        }\r\n        if (ownerIndex == m_numOwners) {\r\n            return false;  // Not Owner\r\n        }\r\n        \r\n        uint newBitFinger = (m_pendings[operation] | (2 ** ownerIndex));\r\n\r\n        uint confirmTotal = 0;\r\n        for (i = 0; i < m_numOwners; ++i) {\r\n            if ((newBitFinger & (2 ** i)) > 0) {\r\n                confirmTotal ++;\r\n            }\r\n        }\r\n        \r\n        AcceptConfirm(currentUser, confirmTotal);\r\n\r\n        if (confirmTotal >= m_multiRequires) {\r\n            delete m_pendings[operation];\r\n            return true;\r\n        }\r\n        else {\r\n            m_pendings[operation] = newBitFinger;\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\Pausable.sol\r\n\r\n/**\r\n * FEATURE 3): Pausable implementation\r\n */\r\ncontract Pausable is MultiOwnable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool paused = false;\r\n\r\n    // Modifier to make a function callable only when the contract is not paused.\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    // Modifier to make a function callable only when the contract is paused.\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    // called by the owner to pause, triggers stopped state\r\n    function pause() mostOwner(keccak256(msg.data)) whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    // called by the owner to unpause, returns to normal state\r\n    function unpause() mostOwner(keccak256(msg.data)) whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n\r\n    function isPause() view public returns(bool) {\r\n        return paused;\r\n    }\r\n}\r\n\r\n// File: contracts\\SafeMath.sol\r\n\r\n/**\r\n* Standard SafeMath Library: zeppelin-solidity/contracts/math/SafeMath.sol\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts\\ParcelXGPX.sol\r\n\r\n/**\r\n * The main body of final smart contract \r\n */\r\ncontract ParcelXGPX is ERC20, MultiOwnable, Pausable, Convertible {\r\n\r\n    using SafeMath for uint256;\r\n  \r\n    string public constant name = \"ParcelX Token\";\r\n    string public constant symbol = \"GPX\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant TOTAL_SUPPLY = uint256(1000000000) * (uint256(10) ** decimals);  // 10,0000,0000\r\n\r\n    address internal tokenPool;      // Use a token pool holding all GPX. Avoid using sender address.\r\n    mapping(address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    function ParcelXGPX(address[] _multiOwners, uint _multiRequires) \r\n        MultiOwnable(_multiOwners, _multiRequires) public {\r\n        tokenPool = this;\r\n        require(tokenPool != address(0));\r\n        balances[tokenPool] = TOTAL_SUPPLY;\r\n    }\r\n\r\n    /**\r\n     * FEATURE 1): ERC20 implementation\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return TOTAL_SUPPLY;       \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n  }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * FEATURE 4): Buyable implements\r\n     * 0.000268 eth per GPX, so the rate is 1.0 / 0.000268 = 3731.3432835820895\r\n     */\r\n    uint256 internal buyRate = uint256(3731); \r\n    \r\n    event Deposit(address indexed who, uint256 value);\r\n    event Withdraw(address indexed who, uint256 value, address indexed lastApprover, string extra);\r\n        \r\n\r\n    function getBuyRate() external view returns (uint256) {\r\n        return buyRate;\r\n    }\r\n\r\n    function setBuyRate(uint256 newBuyRate) mostOwner(keccak256(msg.data)) external {\r\n        buyRate = newBuyRate;\r\n    }\r\n\r\n    /**\r\n     * FEATURE 4): Buyable\r\n     * minimum of 0.001 ether for purchase in the public, pre-ico, and private sale\r\n     */\r\n    function buy() payable whenNotPaused public returns (uint256) {\r\n        Deposit(msg.sender, msg.value);\r\n        require(msg.value >= 0.001 ether);\r\n\r\n        // Token compute & transfer\r\n        uint256 tokens = msg.value.mul(buyRate);\r\n        require(balances[tokenPool] >= tokens);\r\n        balances[tokenPool] = balances[tokenPool].sub(tokens);\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        Transfer(tokenPool, msg.sender, tokens);\r\n        \r\n        return tokens;\r\n    }\r\n\r\n    // gets called when no other function matches\r\n    function () payable public {\r\n        if (msg.value > 0) {\r\n            buy();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * FEATURE 6): Budget control\r\n     * Malloc GPX for airdrops, marketing-events, etc \r\n     */\r\n    function mallocBudget(address _admin, uint256 _value) mostOwner(keccak256(msg.data)) external returns (bool) {\r\n        require(_admin != address(0));\r\n        require(_value <= balances[tokenPool]);\r\n\r\n        balances[tokenPool] = balances[tokenPool].sub(_value);\r\n        balances[_admin] = balances[_admin].add(_value);\r\n        Transfer(tokenPool, _admin, _value);\r\n        return true;\r\n    }\r\n    \r\n    function execute(address _to, uint256 _value, string _extra) mostOwner(keccak256(msg.data)) external returns (bool){\r\n        require(_to != address(0));\r\n        Withdraw(_to, _value, msg.sender, _extra);\r\n        _to.transfer(_value);   // Prevent using call() or send()\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * FEATURE 5): Convertible implements\r\n     */\r\n    function convertMainchainGPX(string destinationAccount, string extra) external returns (bool) {\r\n        require(bytes(destinationAccount).length > 10 && bytes(destinationAccount).length < 128);\r\n        require(balances[msg.sender] > 0);\r\n        uint256 amount = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        balances[tokenPool] = balances[tokenPool].add(amount);   // recycle ParcelX to tokenPool's init account\r\n        Converted(msg.sender, destinationAccount, amount, extra);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currentUser\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuyRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currentUser\",\"type\":\"address\"},{\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"checkAndConfirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extra\",\"type\":\"string\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destinationAccount\",\"type\":\"string\"},{\"name\":\"extra\",\"type\":\"string\"}],\"name\":\"convertMainchainGPX\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBuyRate\",\"type\":\"uint256\"}],\"name\":\"setBuyRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mallocBudget\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multiOwners\",\"type\":\"address[]\"},{\"name\":\"_multiRequires\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"lastApprover\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"extra\",\"type\":\"string\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destinationAccount\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"extra\",\"type\":\"string\"}],\"name\":\"Converted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"confirmTotal\",\"type\":\"uint256\"}],\"name\":\"AcceptConfirm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ParcelXGPX","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000530c5de3558ba36b383f73dff4ad8078f2584fe5000000000000000000000000e7b63545572ad7c8fa80fc35a4f97c4e54e72ff3000000000000000000000000141c9ff89e2193f620e5ee0fd950b464ad6872b2","Library":"","SwarmSource":"bzzr://e8290874e7552ec0186f8367e5a12c49e9e9b62956cab0df8a0be7a7e12e9e1b"}]}