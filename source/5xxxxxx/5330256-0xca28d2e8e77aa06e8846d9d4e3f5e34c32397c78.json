{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ContractReceiver {\r\n\r\n    struct TKN {\r\n        address sender;\r\n        uint value;\r\n        bytes data;\r\n        bytes4 sig;\r\n    }\r\n\r\n    function tokenFallback(address _from, uint _value, bytes _data) public pure {\r\n        TKN memory tkn;\r\n        tkn.sender = _from;\r\n        tkn.value = _value;\r\n        tkn.data = _data;\r\n        uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n        tkn.sig = bytes4(u);\r\n\r\n        /* tkn variable is analogue of msg variable of Ether transaction\r\n        *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\r\n        *  tkn.value the number of tokens that were sent   (analogue of msg.value)\r\n        *  tkn.data is data of token transaction   (analogue of msg.data)\r\n        *  tkn.sig is 4 bytes signature of function\r\n        *  if data of token transaction is a function execution\r\n        */\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract CrowdsaleFront is Ownable{\r\n    //Crowdsale public provider;\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) internal userAmounts;\r\n    mapping (address => uint256) internal rewardPayed;\r\n    BwinCommons internal commons;\r\n    function setCommons(address _addr) public onlyOwner {\r\n        commons = BwinCommons(_addr);\r\n    }\r\n    // fallback function can be used to buy tokens\r\n    function () public payable {\r\n        buyTokens(msg.sender, 0, 999);\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address beneficiary, address _parent, uint256 _top) public payable returns(bool){\r\n      bool ret;\r\n      uint256 tokens;\r\n      (ret, tokens) = Crowdsale(commons.get(\"Crowdsale\")).buyTokens.value(msg.value)(beneficiary, beneficiary, _parent, _top);\r\n      userAmounts[beneficiary] = userAmounts[beneficiary].add(tokens);\r\n      require(ret);\r\n    }\r\n\r\n    function getTokensFromBuy(address _addr) public view returns (uint256){\r\n      return userAmounts[_addr];\r\n    }\r\n    function rewardPayedOf(address _user) public view returns (uint256) {\r\n      return rewardPayed[_user];\r\n    }\r\n    function rewardPay(address _user, uint256 amount) public {\r\n      require(msg.sender == commons.get(\"Crowdsale\"));\r\n      rewardPayed[_user] = rewardPayed[_user].add(amount);\r\n    }\r\n\r\n    // @return true if crowdsale event has ended\r\n    function hasEnded() public view returns (bool){\r\n        return Crowdsale(commons.get(\"Crowdsale\")).hasEnded();\r\n    }\r\n\r\n}\r\n\r\ncontract InterestHolder is Ownable{\r\n  using SafeMath for uint256;\r\n  BwinCommons internal commons;\r\n  function setCommons(address _addr) public onlyOwner {\r\n      commons = BwinCommons(_addr);\r\n  }\r\n  bool public locked = true;\r\n  event ReceiveBalanceUpdate(address _addr,address _user);\r\n  event ReceiveBalanceUpdateUserType(address _addr,address _user,uint256 _type);\r\n  function receiveBalanceUpdate(address _user) external returns (bool) {\r\n    emit ReceiveBalanceUpdate(msg.sender, _user);\r\n    Token token = Token(commons.get(\"Token\"));\r\n    User user = User(commons.get(\"User\"));\r\n    if (msg.sender == address(token)){\r\n      uint256 _type;\r\n      (,,_type) = user.getUserInfo(_user);\r\n      emit ReceiveBalanceUpdateUserType(msg.sender, _user, _type);\r\n      if (_type == 0){\r\n          return true;\r\n      }\r\n      process(_user,_type);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  event ProcessLx(address _addr,address _user, uint256 _type,uint256 lastBalance, uint256 iAmount, uint256 lastTime);\r\n  function process(address _user, uint256 _type) internal{\r\n    Token token = Token(commons.get(\"Token\"));\r\n    User user = User(commons.get(\"User\"));\r\n    uint256 _value = compute(_user, _type);\r\n    uint256 balance = token.balanceOf(_user);\r\n    user.setInterestor(_user,balance.add(_value),now);\r\n    if(_value > 0){\r\n      token.mintForWorker(_user,_value);\r\n      emit ProcessLx(msg.sender, _user, _type, balance, _value, now);\r\n    }\r\n  }\r\n  event GetLx(address _addr,address _user,uint256 _type);\r\n\r\n  function compute(address _user, uint256 _type) internal view returns (uint256) {\r\n    User user = User(commons.get(\"User\"));\r\n    uint256 lastBalance = 0;\r\n    uint256 lastTime = 0;\r\n    bool exist;\r\n    (lastBalance,lastTime,exist) = user.getInterestor(_user);\r\n    uint256 _value = 0;\r\n    if (exist && lastTime > 0){\r\n        uint256 times = now.sub(lastTime);\r\n        if (_type == 1){\r\n            _value = lastBalance.div(10000).mul(5).div(86400).mul(times);\r\n        }else if(_type == 2){\r\n            _value = lastBalance.div(10000).mul(8).div(86400).mul(times);\r\n        }\r\n    }\r\n    return _value;\r\n  }\r\n  function getLx() external returns (uint256) {\r\n    User user = User(commons.get(\"User\"));\r\n    uint256 _type;\r\n    (,,_type) = user.getUserInfo(msg.sender);\r\n    emit GetLx(msg.sender, msg.sender, _type);\r\n    if (_type == 0){\r\n        return 0;\r\n    }\r\n    return compute(msg.sender, _type);\r\n  }\r\n}\r\n\r\ncontract TokenHolder is Ownable{\r\n  using SafeMath for uint256;\r\n\r\n  BwinCommons internal commons;\r\n  function setCommons(address _addr) public onlyOwner {\r\n      commons = BwinCommons(_addr);\r\n  }\r\n  bool locked = true;\r\n  mapping (address => uint256) lockedAmount;\r\n  event ReceiveLockedAmount(address _addr, address _user, uint256 _amount);\r\n  function receiveLockedAmount(address _user, uint256 _amount) external returns (bool) {\r\n    address cds = commons.get(\"Crowdsale\");\r\n    if (msg.sender == address(cds)){\r\n      lockedAmount[_user] = lockedAmount[_user].add(_amount);\r\n      emit ReceiveLockedAmount(msg.sender, _user, _amount);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function balanceOf(address _user) public view returns (uint256) {\r\n    return lockedAmount[_user];\r\n  }\r\n  function balance() public view returns (uint256) {\r\n    return lockedAmount[msg.sender];\r\n  }\r\n\r\n  function setLock(bool _locked) public onlyOwner{\r\n    locked = _locked;\r\n  }\r\n\r\n  function withDrawlocked() public view returns (bool) {\r\n      return locked;\r\n  }\r\n\r\n  function withDrawable() public view returns (bool) {\r\n    User user = User(commons.get(\"User\"));\r\n    uint256 _type;\r\n    (,,_type) = user.getUserInfo(msg.sender);\r\n    return !locked && (_type > 0) && lockedAmount[msg.sender] > 0;\r\n  }\r\n\r\n  function withDraw() external {\r\n    assert(!locked);//用户必须是种子钱包\r\n    BwinToken token = BwinToken(commons.get(\"BwinToken\"));\r\n    User user = User(commons.get(\"User\"));\r\n    uint256 _type;\r\n    (,,_type) = user.getUserInfo(msg.sender);\r\n    assert(_type > 0);\r\n    uint _value = lockedAmount[msg.sender];\r\n    lockedAmount[msg.sender] = 0;\r\n    token.transfer(msg.sender,_value);\r\n  }\r\n\r\n}\r\n\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n}\r\n\r\ncontract EtherHolder is Destructible{\r\n  using SafeMath for uint256;\r\n  bool locked = false;\r\n\r\n  BwinCommons internal commons;\r\n  function setCommons(address _addr) public onlyOwner {\r\n      commons = BwinCommons(_addr);\r\n  }\r\n  struct Account {\r\n    address wallet;\r\n    address parent;\r\n    uint256 radio;\r\n    bool exist;\r\n  }\r\n  mapping (address => uint256) private userAmounts;\r\n  uint256 internal _balance;\r\n  event ProcessFunds(address _topWallet, uint256 _value ,bool isContract);\r\n\r\n  event ReceiveFunds(address _addr, address _user, uint256 _value, uint256 _amount);\r\n  function receiveFunds(address _user, uint256 _amount) external payable returns (bool) {\r\n    emit ReceiveFunds(msg.sender, _user, msg.value, _amount);\r\n    Crowdsale cds = Crowdsale(commons.get(\"Crowdsale\"));\r\n    User user = User(commons.get(\"User\"));\r\n    assert(msg.value == _amount);\r\n    if (msg.sender == address(cds)){\r\n        address _topWallet;\r\n        uint _percent=0;\r\n        bool _contract;\r\n        uint256 _topValue = 0;\r\n        bool _topOk;\r\n        uint256 _totalShares = 0;\r\n        uint256 _totalSharePercent = 0;\r\n        bool _shareRet;\r\n        if(user.hasUser(_user)){\r\n          (_topWallet,_percent,_contract) = user.getTopInfoDetail(_user);\r\n          assert(_percent <= 1000);\r\n          (_topValue,_topOk) = processFunds(_topWallet,_amount,_percent,_contract);\r\n        }else{\r\n          _topOk = true;\r\n        }\r\n        (_totalShares,_totalSharePercent,_shareRet) = processShares(_amount.sub(_topValue));\r\n        assert(_topOk && _shareRet);\r\n        assert(_topValue.add(_totalShares) <= _amount);\r\n        assert(_totalSharePercent <= 1000);\r\n        _balance = _balance.add(_amount);\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n  event ProcessShares(uint256 _amount, uint i, uint256 _percent, bool _contract,address _wallet);\r\n  function processShares(uint256 _amount) internal returns(uint256,uint256,bool){\r\n      uint256 _sended = 0;\r\n      uint256 _sharePercent = 0;\r\n      User user = User(commons.get(\"User\"));\r\n      for(uint i=0;i<user.getShareHolderCount();i++){\r\n        address _wallet;\r\n        uint256 _percent;\r\n        bool _contract;\r\n        emit ProcessShares(_amount, i, _percent, _contract,_wallet);\r\n        assert(_percent <= 1000);\r\n        (_wallet,_percent,_contract) = user.getShareHolder(i);\r\n        uint256 _value;\r\n        bool _valueOk;\r\n        (_value,_valueOk) = processFunds(_wallet,_amount,_percent,_contract);\r\n        _sharePercent = _sharePercent.add(_percent);\r\n        _sended = _sended.add(_value);\r\n      }\r\n      return (_sended,_sharePercent,true);\r\n  }\r\n  function getAmount(uint256 _amount, uint256 _percent) internal pure returns(uint256){\r\n      uint256 _value = _amount.div(1000).mul(_percent);\r\n      return _value;\r\n  }\r\n  function processFunds(address _topWallet, uint256 _amount ,uint256 _percent, bool isContract) internal returns(uint,bool) {\r\n      uint256 _value = getAmount(_amount, _percent);\r\n      userAmounts[_topWallet] = userAmounts[_topWallet].add(_value);\r\n      emit ProcessFunds(_topWallet,_value,isContract);\r\n      return (_value,true);\r\n  }\r\n\r\n  function balanceOf(address _user) public view returns (uint256) {\r\n    return userAmounts[_user];\r\n  }\r\n\r\n  function balanceOfme() public view returns (uint256) {\r\n    return userAmounts[msg.sender];\r\n  }\r\n\r\n  function withDrawlocked() public view returns (bool) {\r\n      return locked;\r\n  }\r\n  function getBalance() public view returns (uint256, uint256) {\r\n    return (address(this).balance,_balance);\r\n  }\r\n  function lock(bool _locked) public onlyOwner{\r\n    locked = _locked;\r\n  }\r\n  event WithDraw(address caller, uint256 _amount);\r\n\r\n  function withDraw(uint256 _amount) external {\r\n    assert(!locked);\r\n    assert(userAmounts[msg.sender] >= _amount);\r\n    userAmounts[msg.sender] = userAmounts[msg.sender].sub(_amount);\r\n    _balance = _balance.sub(_amount);\r\n    msg.sender.transfer(_amount);\r\n    emit WithDraw(msg.sender, _amount);\r\n  }\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * A constant role name for indicating admins.\r\n   */\r\n  string public constant ROLE_ADMIN = \"admin\";\r\n\r\n  /**\r\n   * @dev constructor. Sets msg.sender as admin by default\r\n   */\r\n  function RBAC()\r\n    public\r\n  {\r\n    addRole(msg.sender, ROLE_ADMIN);\r\n  }\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminAddRole(address addr, string roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    addRole(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminRemoveRole(address addr, string roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    removeRole(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to admins\r\n   * // reverts\r\n   */\r\n  modifier onlyAdmin()\r\n  {\r\n    checkRole(msg.sender, ROLE_ADMIN);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\ncontract BwinCommons is RBAC, Destructible {\r\n    mapping (string => address) internal addresses;\r\n    mapping (address => string) internal names;\r\n\r\n    event UpdateRegistration(string key, address old, address n);\r\n\r\n    function register(string key, address ad) public onlyAdmin {\r\n        emit UpdateRegistration(key, addresses[key], ad);\r\n        addresses[key] = ad;\r\n        names[ad] = key;\r\n    }\r\n\r\n    function get(string key) public view returns(address) {\r\n        return addresses[key];\r\n    }\r\n\r\n    function remove() public {\r\n      string memory key = names[msg.sender];\r\n      delete addresses[key];\r\n      delete names[msg.sender];\r\n    }\r\n}\r\n\r\ncontract User is RBAC ,Destructible{\r\n    struct UserInfo {\r\n        //推荐人\r\n        address parent;\r\n        uint256 top;\r\n        bool exist;\r\n        uint256 userType;\r\n    }\r\n\r\n    struct Partner {\r\n      address addr;\r\n      uint256 percent;\r\n      bool exist;\r\n      bool iscontract;\r\n    }\r\n\r\n    struct UserBalance{\r\n        address user;\r\n        uint256 balance;\r\n        uint256 lastTime;\r\n        bool exist;\r\n    }\r\n    mapping (address => UserBalance) internal balanceForInterests;\r\n    uint256[] internal tops;\r\n    mapping (uint256 => Partner) internal topDefine;\r\n\r\n    uint256[] internal shareHolders;\r\n    mapping (uint256 => Partner) internal shareHolderInfos;\r\n    mapping (address => UserInfo) internal tree;\r\n    BwinCommons internal commons;\r\n    function setCommons(address _addr) public onlyAdmin {\r\n        commons = BwinCommons(_addr);\r\n    }\r\n\r\n\r\n    address[] internal users;\r\n    event SetInterestor(address caller, address _user, uint256 _balance, uint256 _lastTime);\r\n    event SetShareHolders(address caller, uint256 topId, address _topAddr, uint256 _percent, bool iscontract);\r\n    event SetTop(address caller, uint256 topId, address _topAddr, uint256 _percent, bool iscontract);\r\n    event AddUser(address caller, address _parent, uint256 _top);\r\n    event SetUser(address caller, address _user, address _parent, uint256 _top, uint256 _type);\r\n    event SetUserType(address caller, address _user, uint _type);\r\n    event RemoveUser(address caller, uint _index);\r\n\r\n    function setInterestor(address _user, uint256 _balance, uint256 _lastTime) public onlyRole(\"INTEREST_HOLDER\"){\r\n        balanceForInterests[_user] = UserBalance(_user,_balance,_lastTime,true);\r\n        emit SetInterestor(msg.sender,_user,_balance,_lastTime);\r\n    }\r\n\r\n    function getInterestor(address _user) public view returns(uint256,uint256,bool){\r\n        return (balanceForInterests[_user].balance,balanceForInterests[_user].lastTime,balanceForInterests[_user].exist);\r\n    }\r\n    function setShareHolders(uint256 topId, address _topAddr, uint256 _percent, bool iscontract) public onlyAdmin {\r\n        if (!shareHolderInfos[topId].exist){\r\n          shareHolders.push(topId);\r\n        }\r\n        shareHolderInfos[topId] = Partner(_topAddr, _percent, true, iscontract);\r\n        emit SetShareHolders(msg.sender,topId,_topAddr,_percent,iscontract);\r\n    }\r\n    function getShareHolder(uint256 _index) public view returns(address, uint256, bool){\r\n        uint256 shareHolderId = shareHolders[_index];\r\n        return getShareHoldersInfo(shareHolderId);\r\n    }\r\n    function getShareHolderCount() public view returns(uint256){\r\n        return shareHolders.length;\r\n    }\r\n    function getShareHoldersInfo(uint256 shareHolderId) public view returns(address, uint256, bool){\r\n      return (shareHolderInfos[shareHolderId].addr, shareHolderInfos[shareHolderId].percent, shareHolderInfos[shareHolderId].iscontract);\r\n    }\r\n\r\n    function setTop(uint256 topId, address _topAddr, uint256 _percent, bool iscontract) public onlyAdmin {\r\n        if (!topDefine[topId].exist){\r\n          tops.push(topId);\r\n        }\r\n        topDefine[topId] = Partner(_topAddr, _percent, true, iscontract);\r\n        emit SetTop(msg.sender, topId, _topAddr, _percent, iscontract);\r\n    }\r\n    function getTopInfoDetail(address _user) public view returns(address, uint256, bool){\r\n        uint256 _topId;\r\n        address _wallet;\r\n        uint256 _percent;\r\n        bool _contract;\r\n        (,_topId,) = getUserInfo(_user);\r\n        (_wallet,_percent,_contract) = getTopInfo(_topId);\r\n        return (_wallet,_percent,_contract);\r\n    }\r\n    function getTopInfo(uint256 topId) public view returns(address, uint256, bool){\r\n      return (topDefine[topId].addr, topDefine[topId].percent, topDefine[topId].iscontract);\r\n    }\r\n    function addUser(address _parent, uint256 _top) public {\r\n        require(msg.sender != _parent);\r\n        if (_parent != address(0)) {\r\n            require(tree[_parent].exist);\r\n        }\r\n        require(!hasUser(msg.sender));\r\n        tree[msg.sender] = UserInfo(_parent, _top, true, 0);\r\n        users.push(msg.sender);\r\n        emit AddUser(msg.sender, _parent, _top);\r\n    }\r\n\r\n    function getUsersCount() public view returns(uint) {\r\n        return users.length;\r\n    }\r\n\r\n    function getUserInfo(address _user) public view returns(address, uint256, uint256) {\r\n        return (tree[_user].parent, tree[_user].top, tree[_user].userType);\r\n    }\r\n\r\n    function hasUser(address _user) public view returns(bool) {\r\n        return tree[_user].exist;\r\n    }\r\n\r\n    function setUser(address _user, address _parent, uint256 _top, uint256 _type) public onlyAdmin {\r\n      if(!tree[_user].exist){\r\n        users.push(_user);\r\n      }\r\n      tree[_user] = UserInfo(_parent, _top, true, _type);\r\n      emit SetUser(msg.sender, _user, _parent, _top, _type);\r\n    }\r\n\r\n    function setUserType(address _user, uint _type) public onlyAdmin {\r\n        require(hasUser(_user));\r\n        tree[_user].userType = _type;\r\n        emit SetUserType(msg.sender, _user, _type);\r\n    }\r\n    function indexOfUserInfo(uint _index) public view returns (address) {\r\n        return users[_index];\r\n    }\r\n\r\n    function removeUser(uint _index) public onlyAdmin {\r\n        address _user = indexOfUserInfo(_index);\r\n        delete users[_index];\r\n        delete tree[_user];\r\n        emit RemoveUser(msg.sender, _index);\r\n    }\r\n}\r\n\r\ncontract Pausable is RBAC {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyAdmin whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyAdmin whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\ncontract BwinToken is ERC20, Pausable, Destructible{\r\n    //Token t;\r\n\r\n    BwinCommons internal commons;\r\n    function setCommons(address _addr) public onlyOwner {\r\n        commons = BwinCommons(_addr);\r\n    }\r\n    string public constant name = \"FFgame Coin\";\r\n    string public constant symbol = \"FFC\";\r\n    uint8 public constant decimals = 18;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    function BwinToken() public {\r\n      addRole(msg.sender, ROLE_ADMIN);\r\n    }\r\n    function totalSupply() public view returns (uint256){\r\n      Token t = Token(commons.get(\"Token\"));\r\n      return t.totalSupply();\r\n    }\r\n    function balanceOf(address who) public view returns (uint256){\r\n      Token t = Token(commons.get(\"Token\"));\r\n      return t.balanceOf(who);\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool){\r\n      bytes memory empty;\r\n      Token t = Token(commons.get(\"Token\"));\r\n      if(t.transfer(msg.sender, to, value,empty)){\r\n          emit Transfer(msg.sender, to, value);\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256){\r\n      Token t = Token(commons.get(\"Token\"));\r\n      return t.allowance(owner, spender);\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool){\r\n      Token t = Token(commons.get(\"Token\"));\r\n      if(t._transferFrom(msg.sender, from, to, value)){\r\n          emit Transfer(from, to, value);\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool){\r\n      Token t = Token(commons.get(\"Token\"));\r\n      if (t._approve(msg.sender, spender, value)){\r\n          emit Approval(msg.sender, spender, value);\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n      Token t = Token(commons.get(\"Token\"));\r\n      if(t._increaseApproval(msg.sender, _spender, _addedValue)){\r\n          emit Approval(msg.sender, _spender, _addedValue);\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n      Token t = Token(commons.get(\"Token\"));\r\n      if (t._decreaseApproval(msg.sender,_spender, _subtractedValue)){\r\n          emit Approval(msg.sender, _spender, _subtractedValue);\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\ncontract Token is RBAC, Pausable{\r\n    using SafeMath for uint256;\r\n\r\n    BwinCommons internal commons;\r\n    function setCommons(address _addr) public onlyAdmin {\r\n        commons = BwinCommons(_addr);\r\n    }\r\n    event TokenApproval(address indexed owner, address indexed spender, uint256 value);\r\n    event TokenTransfer(address indexed from, address indexed to, uint256 value);\r\n    event MintForSale(address indexed to, uint256 amount);\r\n    event MintForWorker(address indexed to, uint256 amount);\r\n    event MintForUnlock(address indexed to, uint256 amount);\r\n\r\n    function Token() public {\r\n        addRole(msg.sender, ROLE_ADMIN);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      return td.totalSupply();\r\n    }\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      return td.balanceOf(_owner);\r\n    }\r\n    function _transferFrom(address _sender, address _from, address _to, uint256 _value) external whenNotPaused onlyRole(\"FRONT_TOKEN_USER\") returns (bool) {\r\n      InterestHolder ih = InterestHolder(commons.get(\"InterestHolder\"));\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      uint256 _balanceFrom = balanceOf(_from);\r\n      uint256 _balanceTo = balanceOf(_to);\r\n      uint256 _allow = allowance(_from, _sender);\r\n      require(_from != address(0));\r\n      require(_sender != address(0));\r\n      require(_to != address(0));\r\n      require(_value <= _balanceFrom);\r\n      require(_value <= _allow);\r\n      td.setBalance(_from,_balanceFrom.sub(_value));\r\n      td.setBalance(_to,_balanceTo.add(_value));\r\n      td.setAllowance(_from, _sender, _allow.sub(_value));\r\n      if(ih != address(0)){\r\n        ih.receiveBalanceUpdate(_from);\r\n        ih.receiveBalanceUpdate(_to);\r\n      }\r\n      emit TokenTransfer(_from, _to, _value);\r\n      return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      return td.allowance(_owner,_spender);\r\n    }\r\n    function _approve(address _sender, address _spender, uint256 _value) public onlyRole(\"FRONT_TOKEN_USER\")  whenNotPaused returns (bool) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      return td.setAllowance(_sender, _spender, _value);\r\n    }\r\n    function _increaseApproval(address _sender, address _spender, uint _addedValue) public onlyRole(\"FRONT_TOKEN_USER\") whenNotPaused returns (bool) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      td.setAllowance(_sender, _spender, allowance(_sender, _spender).add(_addedValue));\r\n      emit TokenApproval(_sender, _spender, allowance(_sender, _spender));\r\n      return true;\r\n    }\r\n    function _decreaseApproval(address _sender, address _spender, uint _subtractedValue) public onlyRole(\"FRONT_TOKEN_USER\") whenNotPaused returns (bool) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      uint oldValue = allowance(_sender, _spender);\r\n      if (_subtractedValue > oldValue) {\r\n          td.setAllowance(_sender, _spender, 0);\r\n          //allowed[msg.sender][_spender] = 0;\r\n      } else {\r\n          td.setAllowance(_sender, _spender, oldValue.sub(_subtractedValue));\r\n          //allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n      }\r\n      emit TokenApproval(_sender, _spender, allowance(_sender, _spender));\r\n      return true;\r\n    }\r\n\r\n    function unlockAmount(address _to, uint256 _amount) external onlyAdmin returns (bool){\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\r\n      uint256 unlockedAmount = td.valueOf(\"unlockedAmount\");\r\n      if(_mint(_to, _amount)){\r\n          td.setValue(\"unlockedAmount\",unlockedAmount.add(_amount));\r\n          emit MintForUnlock(_to, _amount);\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    function _mint(address _to, uint256 _amount) internal returns (bool) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      InterestHolder ih = InterestHolder(commons.get(\"InterestHolder\"));\r\n      require(_to != address(0));\r\n      require(_amount > 0);\r\n      uint256 totalMinted = td.valueOf(\"totalMinted\");\r\n      td.setTotal(td.totalSupply().add(_amount));\r\n      td.setBalance(_to,balanceOf(_to).add(_amount));\r\n      td.setValue(\"totalMinted\",totalMinted.add(_amount));\r\n      if(address(ih) != address(0)){\r\n        ih.receiveBalanceUpdate(_to);\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function mintForSale(address _to, uint256 _amount) external onlyRole(\"TOKEN_SALE\") whenNotPaused returns (bool) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\r\n      uint256 saledAmount = td.valueOf(\"saledAmount\");\r\n      if(_mint(_to, _amount)){\r\n          td.setValue(\"saledAmount\",saledAmount.add(_amount));\r\n          emit MintForSale(_to, _amount);\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n    function mintForWorker(address _to, uint256 _amount) external onlyRole(\"TOKEN_WORKER\") whenNotPaused returns (bool) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      require(td.totalSupply().add(_amount) <= td.TotalCapacity());\r\n      uint256 minedAmount = td.valueOf(\"minedAmount\");\r\n      if(_mint(_to, _amount)){\r\n        td.setValue(\"minedAmount\",minedAmount.add(_amount));\r\n        emit MintForWorker(_to, _amount);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    function transfer(address _from, address _to, uint _value, bytes _data) external whenNotPaused onlyRole(\"FRONT_TOKEN_USER\")  returns (bool success) {\r\n\r\n        if (isContract(_to)) {\r\n            return transferToContract(_from, _to, _value, _data);\r\n        }else {\r\n            return transferToAddress(_from, _to, _value);\r\n        }\r\n    }\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\r\n      TokenData td = TokenData(commons.get(\"TokenData\"));\r\n      InterestHolder ih = InterestHolder(commons.get(\"InterestHolder\"));\r\n      require(_to != address(0));\r\n      require(_value <= balanceOf(_from));\r\n      td.setBalance(_from,balanceOf(_from).sub(_value));\r\n      td.setBalance(_to,balanceOf(_to).add(_value));\r\n      if(ih != address(0)){\r\n        ih.receiveBalanceUpdate(_from);\r\n        ih.receiveBalanceUpdate(_to);\r\n      }\r\n      emit TokenTransfer(_from, _to, _value);\r\n      return true;\r\n    }\r\n\r\n    //function that is called when transaction target is an address\r\n    function transferToAddress(address _from, address _to, uint _value) internal returns (bool success) {\r\n        require(balanceOf(_from) >= _value);\r\n        require(_transfer(_from, _to, _value));\r\n        emit TokenTransfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    //function that is called when transaction target is a contract\r\n    function transferToContract(address _from, address _to, uint _value, bytes _data) internal returns (bool success) {\r\n        require(balanceOf(_from) >= _value);\r\n        require(_transfer(_from, _to, _value));\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        emit TokenTransfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\ncontract TokenData is RBAC, Pausable{\r\n  //using SafeMath for uint256;\r\n  event TokenDataBalance(address sender, address indexed addr, uint256 value);\r\n  event TokenDataAllowance(address sender, address indexed from, address indexed to, uint256 value);\r\n  event SetTotalSupply(address _addr, uint256 _total);\r\n  mapping(address => uint256) internal balances;\r\n  mapping(string => uint256) internal values;\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  address[] internal users;\r\n\r\n  uint256 internal totalSupply_;\r\n  uint256 internal totalCapacity_;\r\n\r\n  string internal  name_;\r\n  string internal  symbol_;\r\n  uint8 internal  decimals_;\r\n  function TokenData(uint256 _totalSupply, uint256 _totalCapacity) public {\r\n    addRole(msg.sender, ROLE_ADMIN);\r\n    totalSupply_ = _totalSupply;\r\n    totalCapacity_ = _totalCapacity;\r\n  }\r\n\r\n  BwinCommons internal commons;\r\n  function setCommons(address _addr) public onlyAdmin {\r\n      commons = BwinCommons(_addr);\r\n  }\r\n  function setTotal(uint256 _total) public onlyRole(\"TOKEN_DATA_USER\") {\r\n      totalSupply_ = _total;\r\n      emit SetTotalSupply(msg.sender, _total);\r\n  }\r\n  event SetValue(address _addr, string name, uint256 _value);\r\n\r\n  function setValue(string name, uint256 _value) external onlyRole(\"TOKEN_DATA_USER\") {\r\n      values[name] = _value;\r\n      emit SetValue(msg.sender, name, _value);\r\n  }\r\n\r\n  event SetTotalCapacity(address _addr, uint256 _total);\r\n\r\n  function setTotalCapacity(uint256 _total) external onlyRole(\"TOKEN_DATA_USER\") {\r\n      totalCapacity_ = _total;\r\n      emit SetTotalCapacity(msg.sender, _total);\r\n  }\r\n\r\n  function valueOf(string _name) public view returns(uint256){\r\n      return values[_name];\r\n  }\r\n\r\n\r\n  function TotalCapacity() public view returns (uint256) {\r\n    return totalCapacity_;\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n\r\n\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n\r\n\r\n  function setBalance(address _addr, uint256 _value) external whenNotPaused onlyRole(\"TOKEN_DATA_USER\") returns (bool) {\r\n    return _setBalance(_addr, _value);\r\n  }\r\n  function setAllowance(address _from, address _to, uint256 _value) external whenNotPaused onlyRole(\"TOKEN_DATA_USER\") returns (bool) {\r\n    return _setAllowance(_from, _to, _value);\r\n  }\r\n\r\n  function setBalanceAdmin(address _addr, uint256 _value) external onlyAdmin returns (bool) {\r\n    return _setBalance(_addr, _value);\r\n  }\r\n  function setAllowanceAdmin(address _from, address _to, uint256 _value) external onlyAdmin returns (bool) {\r\n    return _setAllowance(_from, _to, _value);\r\n  }\r\n\r\n  function _setBalance(address _addr, uint256 _value) internal returns (bool) {\r\n    require(_addr != address(0));\r\n    require(_value >= 0);\r\n    balances[_addr] = _value;\r\n    emit TokenDataBalance(msg.sender, _addr, _value);\r\n    return true;\r\n  }\r\n  function _setAllowance(address _from, address _to, uint256 _value) internal returns (bool) {\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n    require(_value >= 0);\r\n    allowed[_from][_to] = _value;\r\n    emit TokenDataAllowance(msg.sender, _from, _to, _value);\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract Crowdsale is Ownable, Pausable{\r\n  using SafeMath for uint256;\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  uint256 public saleCapacity;\r\n  uint256 public saledAmount;\r\n  uint256 public rate;\r\n  uint256 public weiRaised;\r\n  event TokenPurchase(address payor, address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n  BwinCommons internal commons;\r\n  function setCommons(address _addr) public onlyOwner {\r\n      commons = BwinCommons(_addr);\r\n  }\r\n  function buyTokens(address payor, address beneficiary, address _parent, uint256 _top) public  payable returns(bool, uint256);\r\n  function hasEnded() public view returns (bool){\r\n      return (now > endTime || saledAmount >= saleCapacity);\r\n  }\r\n  modifier onlyFront() {\r\n      require(msg.sender == address(commons.get(\"CrowdsaleFront\")));\r\n      _;\r\n  }\r\n  function validPurchase() internal view returns (bool) {\r\n      bool withinPeriod = now >= startTime && now <= endTime;\r\n      bool withinCapacity = saledAmount <= saleCapacity;\r\n      return withinPeriod && withinCapacity;\r\n  }\r\n\r\n  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {\r\n      return weiAmount.mul(rate);\r\n  }\r\n}\r\n\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminRemoveRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminAddRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setCommons\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"}]","ContractName":"BwinToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://79aa5201125b5861ab37b34dc129345840c94ae224b98313416024ad2d5fa172"}]}