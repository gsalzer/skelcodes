{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/PausableToken.sol\r\n\r\n/**\r\n * @title Pausable token\r\n *\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}\r\n\r\n// File: contracts/CustomPOAToken.sol\r\n\r\ncontract CustomPOAToken is PausableToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n\r\n  uint8 public constant decimals = 18;\r\n\r\n  address public owner;\r\n  address public broker;\r\n  address public custodian;\r\n\r\n  uint256 public creationBlock;\r\n  uint256 public timeoutBlock;\r\n  // the total per token payout rate: accumulates as payouts are received\r\n  uint256 public totalPerTokenPayout;\r\n  uint256 public tokenSaleRate;\r\n  uint256 public fundedAmount;\r\n  uint256 public fundingGoal;\r\n  uint256 public initialSupply;\r\n  // ‰ permille NOT percent\r\n  uint256 public constant feeRate = 5;\r\n\r\n  // self contained whitelist on contract, must be whitelisted to buy\r\n  mapping (address => bool) public whitelisted;\r\n  // used to deduct already claimed payouts on a per token basis\r\n  mapping(address => uint256) public claimedPerTokenPayouts;\r\n  // fallback for when a transfer happens with payouts remaining\r\n  mapping(address => uint256) public unclaimedPayoutTotals;\r\n\r\n  enum Stages {\r\n    Funding,\r\n    Pending,\r\n    Failed,\r\n    Active,\r\n    Terminated\r\n  }\r\n\r\n  Stages public stage = Stages.Funding;\r\n\r\n  event StageEvent(Stages stage);\r\n  event BuyEvent(address indexed buyer, uint256 amount);\r\n  event PayoutEvent(uint256 amount);\r\n  event ClaimEvent(uint256 payout);\r\n  event TerminatedEvent();\r\n  event WhitelistedEvent(address indexed account, bool isWhitelisted);\r\n\r\n  modifier isWhitelisted() {\r\n    require(whitelisted[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCustodian() {\r\n    require(msg.sender == custodian);\r\n    _;\r\n  }\r\n\r\n  // start stage related modifiers\r\n  modifier atStage(Stages _stage) {\r\n    require(stage == _stage);\r\n    _;\r\n  }\r\n\r\n  modifier atEitherStage(Stages _stage, Stages _orStage) {\r\n    require(stage == _stage || stage == _orStage);\r\n    _;\r\n  }\r\n\r\n  modifier checkTimeout() {\r\n    if (stage == Stages.Funding && block.number >= creationBlock.add(timeoutBlock)) {\r\n      uint256 _unsoldBalance = balances[this];\r\n      balances[this] = 0;\r\n      totalSupply = totalSupply.sub(_unsoldBalance);\r\n      Transfer(this, address(0), balances[this]);\r\n      enterStage(Stages.Failed);\r\n    }\r\n    _;\r\n  }\r\n  // end stage related modifiers\r\n\r\n  // token totalSupply must be more than fundingGoal!\r\n  function CustomPOAToken\r\n  (\r\n    string _name,\r\n    string _symbol,\r\n    address _broker,\r\n    address _custodian,\r\n    uint256 _timeoutBlock,\r\n    uint256 _totalSupply,\r\n    uint256 _fundingGoal\r\n  )\r\n    public\r\n  {\r\n    require(_fundingGoal > 0);\r\n    require(_totalSupply > _fundingGoal);\r\n    owner = msg.sender;\r\n    name = _name;\r\n    symbol = _symbol;\r\n    broker = _broker;\r\n    custodian = _custodian;\r\n    timeoutBlock = _timeoutBlock;\r\n    creationBlock = block.number;\r\n    // essentially sqm unit of building...\r\n    totalSupply = _totalSupply;\r\n    initialSupply = _totalSupply;\r\n    fundingGoal = _fundingGoal;\r\n    balances[this] = _totalSupply;\r\n    paused = true;\r\n  }\r\n\r\n  // start token conversion functions\r\n\r\n  /*******************\r\n  * TKN      supply  *\r\n  * ---  =  -------  *\r\n  * ETH     funding  *\r\n  *******************/\r\n\r\n  // util function to convert wei to tokens. can be used publicly to see\r\n  // what the balance would be for a given Ξ amount.\r\n  // will drop miniscule amounts of wei due to integer division\r\n  function weiToTokens(uint256 _weiAmount)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _weiAmount\r\n      .mul(1e18)\r\n      .mul(initialSupply)\r\n      .div(fundingGoal)\r\n      .div(1e18);\r\n  }\r\n\r\n  // util function to convert tokens to wei. can be used publicly to see how\r\n  // much Ξ would be received for token reclaim amount\r\n  // will typically lose 1 wei unit of Ξ due to integer division\r\n  function tokensToWei(uint256 _tokenAmount)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _tokenAmount\r\n      .mul(1e18)\r\n      .mul(fundingGoal)\r\n      .div(initialSupply)\r\n      .div(1e18);\r\n  }\r\n\r\n  // end token conversion functions\r\n\r\n  // pause override\r\n  function unpause()\r\n    public\r\n    onlyOwner\r\n    whenPaused\r\n  {\r\n    // only allow unpausing when in Active stage\r\n    require(stage == Stages.Active);\r\n    return super.unpause();\r\n  }\r\n\r\n  // stage related functions\r\n  function enterStage(Stages _stage)\r\n    private\r\n  {\r\n    stage = _stage;\r\n    StageEvent(_stage);\r\n  }\r\n\r\n  // start whitelist related functions\r\n\r\n  // allow address to buy tokens\r\n  function whitelistAddress(address _address)\r\n    external\r\n    onlyOwner\r\n    atStage(Stages.Funding)\r\n  {\r\n    require(whitelisted[_address] != true);\r\n    whitelisted[_address] = true;\r\n    WhitelistedEvent(_address, true);\r\n  }\r\n\r\n  // disallow address to buy tokens.\r\n  function blacklistAddress(address _address)\r\n    external\r\n    onlyOwner\r\n    atStage(Stages.Funding)\r\n  {\r\n    require(whitelisted[_address] != false);\r\n    whitelisted[_address] = false;\r\n    WhitelistedEvent(_address, false);\r\n  }\r\n\r\n  // check to see if contract whitelist has approved address to buy\r\n  function whitelisted(address _address)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return whitelisted[_address];\r\n  }\r\n\r\n  // end whitelist related functions\r\n\r\n  // start fee handling functions\r\n\r\n  // public utility function to allow checking of required fee for a given amount\r\n  function calculateFee(uint256 _value)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return feeRate.mul(_value).div(1000);\r\n  }\r\n\r\n  // end fee handling functions\r\n\r\n  // start lifecycle functions\r\n\r\n  function buy()\r\n    public\r\n    payable\r\n    checkTimeout\r\n    atStage(Stages.Funding)\r\n    isWhitelisted\r\n    returns (bool)\r\n  {\r\n    uint256 _payAmount;\r\n    uint256 _buyAmount;\r\n    // check if balance has met funding goal to move on to Pending\r\n    if (fundedAmount.add(msg.value) < fundingGoal) {\r\n      // _payAmount is just value sent\r\n      _payAmount = msg.value;\r\n      // get token amount from wei... drops remainders (keeps wei dust in contract)\r\n      _buyAmount = weiToTokens(_payAmount);\r\n      // check that buyer will indeed receive something after integer division\r\n      // this check cannot be done in other case because it could prevent\r\n      // contract from moving to next stage\r\n      require(_buyAmount > 0);\r\n    } else {\r\n      // let the world know that the token is in Pending Stage\r\n      enterStage(Stages.Pending);\r\n      // set refund amount (overpaid amount)\r\n      uint256 _refundAmount = fundedAmount.add(msg.value).sub(fundingGoal);\r\n      // get actual Ξ amount to buy\r\n      _payAmount = msg.value.sub(_refundAmount);\r\n      // get token amount from wei... drops remainders (keeps wei dust in contract)\r\n      _buyAmount = weiToTokens(_payAmount);\r\n      // assign remaining dust\r\n      uint256 _dust = balances[this].sub(_buyAmount);\r\n      // sub dust from contract\r\n      balances[this] = balances[this].sub(_dust);\r\n      // give dust to owner\r\n      balances[owner] = balances[owner].add(_dust);\r\n      Transfer(this, owner, _dust);\r\n      // SHOULD be ok even with reentrancy because of enterStage(Stages.Pending)\r\n      msg.sender.transfer(_refundAmount);\r\n    }\r\n    // deduct token buy amount balance from contract balance\r\n    balances[this] = balances[this].sub(_buyAmount);\r\n    // add token buy amount to sender's balance\r\n    balances[msg.sender] = balances[msg.sender].add(_buyAmount);\r\n    // increment the funded amount\r\n    fundedAmount = fundedAmount.add(_payAmount);\r\n    // send out event giving info on amount bought as well as claimable dust\r\n    Transfer(this, msg.sender, _buyAmount);\r\n    BuyEvent(msg.sender, _buyAmount);\r\n    return true;\r\n  }\r\n\r\n  function activate()\r\n    external\r\n    checkTimeout\r\n    onlyCustodian\r\n    payable\r\n    atStage(Stages.Pending)\r\n    returns (bool)\r\n  {\r\n    // calculate company fee charged for activation\r\n    uint256 _fee = calculateFee(fundingGoal);\r\n    // value must exactly match fee\r\n    require(msg.value == _fee);\r\n    // if activated and fee paid: put in Active stage\r\n    enterStage(Stages.Active);\r\n    // owner (company) fee set in unclaimedPayoutTotals to be claimed by owner\r\n    unclaimedPayoutTotals[owner] = unclaimedPayoutTotals[owner].add(_fee);\r\n    // custodian value set to claimable. can now be claimed via claim function\r\n    // set all eth in contract other than fee as claimable.\r\n    // should only be buy()s. this ensures buy() dust is cleared\r\n    unclaimedPayoutTotals[custodian] = unclaimedPayoutTotals[custodian]\r\n      .add(this.balance.sub(_fee));\r\n    // allow trading of tokens\r\n    paused = false;\r\n    // let world know that this token can now be traded.\r\n    Unpause();\r\n    return true;\r\n  }\r\n\r\n  // used when property no longer exists etc. allows for winding down via payouts\r\n  // can no longer be traded after function is run\r\n  function terminate()\r\n    external\r\n    onlyCustodian\r\n    atStage(Stages.Active)\r\n    returns (bool)\r\n  {\r\n    // set Stage to terminated\r\n    enterStage(Stages.Terminated);\r\n    // pause. Cannot be unpaused now that in Stages.Terminated\r\n    paused = true;\r\n    // let the world know this token is in Terminated Stage\r\n    TerminatedEvent();\r\n  }\r\n\r\n  // emergency temporary function used only in case of emergency to return\r\n  // Ξ to contributors in case of catastrophic contract failure.\r\n  function kill()\r\n    external\r\n    onlyOwner\r\n  {\r\n    // stop trading\r\n    paused = true;\r\n    // enter stage which will no longer allow unpausing\r\n    enterStage(Stages.Terminated);\r\n    // transfer funds to company in order to redistribute manually\r\n    owner.transfer(this.balance);\r\n    // let the world know that this token is in Terminated Stage\r\n    TerminatedEvent();\r\n  }\r\n\r\n  // end lifecycle functions\r\n\r\n  // start payout related functions\r\n\r\n  // get current payout for perTokenPayout and unclaimed\r\n  function currentPayout(address _address, bool _includeUnclaimed)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    /*\r\n      need to check if there have been no payouts\r\n      safe math will throw otherwise due to dividing 0\r\n\r\n      The below variable represents the total payout from the per token rate pattern\r\n      it uses this funky naming pattern in order to differentiate from the unclaimedPayoutTotals\r\n      which means something very different.\r\n    */\r\n    uint256 _totalPerTokenUnclaimedConverted = totalPerTokenPayout == 0\r\n      ? 0\r\n      : balances[_address]\r\n      .mul(totalPerTokenPayout.sub(claimedPerTokenPayouts[_address]))\r\n      .div(1e18);\r\n\r\n    /*\r\n    balances may be bumped into unclaimedPayoutTotals in order to\r\n    maintain balance tracking accross token transfers\r\n\r\n    perToken payout rates are stored * 1e18 in order to be kept accurate\r\n    perToken payout is / 1e18 at time of usage for actual Ξ balances\r\n    unclaimedPayoutTotals are stored as actual Ξ value\r\n      no need for rate * balance\r\n    */\r\n    return _includeUnclaimed\r\n      ? _totalPerTokenUnclaimedConverted.add(unclaimedPayoutTotals[_address])\r\n      : _totalPerTokenUnclaimedConverted;\r\n\r\n  }\r\n\r\n  // settle up perToken balances and move into unclaimedPayoutTotals in order\r\n  // to ensure that token transfers will not result in inaccurate balances\r\n  function settleUnclaimedPerTokenPayouts(address _from, address _to)\r\n    private\r\n    returns (bool)\r\n  {\r\n    // add perToken balance to unclaimedPayoutTotals which will not be affected by transfers\r\n    unclaimedPayoutTotals[_from] = unclaimedPayoutTotals[_from].add(currentPayout(_from, false));\r\n    // max out claimedPerTokenPayouts in order to effectively make perToken balance 0\r\n    claimedPerTokenPayouts[_from] = totalPerTokenPayout;\r\n    // same as above for to\r\n    unclaimedPayoutTotals[_to] = unclaimedPayoutTotals[_to].add(currentPayout(_to, false));\r\n    // same as above for to\r\n    claimedPerTokenPayouts[_to] = totalPerTokenPayout;\r\n    return true;\r\n  }\r\n\r\n  // used to manually set Stage to Failed when no users have bought any tokens\r\n  // if no buy()s occurred before timeoutBlock token would be stuck in Funding\r\n  function setFailed()\r\n    external\r\n    atStage(Stages.Funding)\r\n    checkTimeout\r\n    returns (bool)\r\n  {\r\n    if (stage == Stages.Funding) {\r\n      revert();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // reclaim Ξ for sender if fundingGoal is not met within timeoutBlock\r\n  function reclaim()\r\n    external\r\n    checkTimeout\r\n    atStage(Stages.Failed)\r\n    returns (bool)\r\n  {\r\n    // get token balance of user\r\n    uint256 _tokenBalance = balances[msg.sender];\r\n    // ensure that token balance is over 0\r\n    require(_tokenBalance > 0);\r\n    // set token balance to 0 so re reclaims are not possible\r\n    balances[msg.sender] = 0;\r\n    // decrement totalSupply by token amount being reclaimed\r\n    totalSupply = totalSupply.sub(_tokenBalance);\r\n    Transfer(msg.sender, address(0), _tokenBalance);\r\n    // decrement fundedAmount by eth amount converted from token amount being reclaimed\r\n    fundedAmount = fundedAmount.sub(tokensToWei(_tokenBalance));\r\n    // set reclaim total as token value\r\n    uint256 _reclaimTotal = tokensToWei(_tokenBalance);\r\n    // send Ξ back to sender\r\n    msg.sender.transfer(_reclaimTotal);\r\n    return true;\r\n  }\r\n\r\n  // send Ξ to contract to be claimed by token holders\r\n  function payout()\r\n    external\r\n    payable\r\n    atEitherStage(Stages.Active, Stages.Terminated)\r\n    onlyCustodian\r\n    returns (bool)\r\n  {\r\n    // calculate fee based on feeRate\r\n    uint256 _fee = calculateFee(msg.value);\r\n    // ensure the value is high enough for a fee to be claimed\r\n    require(_fee > 0);\r\n    // deduct fee from payout\r\n    uint256 _payoutAmount = msg.value.sub(_fee);\r\n    /*\r\n    totalPerTokenPayout is a rate at which to payout based on token balance\r\n    it is stored as * 1e18 in order to keep accuracy\r\n    it is / 1e18 when used relating to actual Ξ values\r\n    */\r\n    totalPerTokenPayout = totalPerTokenPayout\r\n      .add(_payoutAmount\r\n        .mul(1e18)\r\n        .div(totalSupply)\r\n      );\r\n\r\n    // take remaining dust and send to owner rather than leave stuck in contract\r\n    // should not be more than a few wei\r\n    uint256 _delta = (_payoutAmount.mul(1e18) % totalSupply).div(1e18);\r\n    unclaimedPayoutTotals[owner] = unclaimedPayoutTotals[owner].add(_fee).add(_delta);\r\n    // let the world know that a payout has happened for this token\r\n    PayoutEvent(_payoutAmount);\r\n    return true;\r\n  }\r\n\r\n  // claim total Ξ claimable for sender based on token holdings at time of each payout\r\n  function claim()\r\n    external\r\n    atEitherStage(Stages.Active, Stages.Terminated)\r\n    returns (uint256)\r\n  {\r\n    /*\r\n    pass true to currentPayout in order to get both:\r\n      perToken payouts\r\n      unclaimedPayoutTotals\r\n    */\r\n    uint256 _payoutAmount = currentPayout(msg.sender, true);\r\n    // check that there indeed is a pending payout for sender\r\n    require(_payoutAmount > 0);\r\n    // max out per token payout for sender in order to make payouts effectively\r\n    // 0 for sender\r\n    claimedPerTokenPayouts[msg.sender] = totalPerTokenPayout;\r\n    // 0 out unclaimedPayoutTotals for user\r\n    unclaimedPayoutTotals[msg.sender] = 0;\r\n    // let the world know that a payout for sender has been claimed\r\n    ClaimEvent(_payoutAmount);\r\n    // transfer Ξ payable amount to sender\r\n    msg.sender.transfer(_payoutAmount);\r\n    return _payoutAmount;\r\n  }\r\n\r\n  // end payout related functions\r\n\r\n  // start ERC20 overrides\r\n\r\n  // same as ERC20 transfer other than settling unclaimed payouts\r\n  function transfer\r\n  (\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    // move perToken payout balance to unclaimedPayoutTotals\r\n    require(settleUnclaimedPerTokenPayouts(msg.sender, _to));\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  // same as ERC20 transfer other than settling unclaimed payouts\r\n  function transferFrom\r\n  (\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    // move perToken payout balance to unclaimedPayoutTotals\r\n    require(settleUnclaimedPerTokenPayouts(_from, _to));\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  // end ERC20 overrides\r\n\r\n  // check if there is a way to get around gas issue when no gas limit calculated...\r\n  // fallback function defaulting to buy\r\n  function()\r\n    public\r\n    payable\r\n  {\r\n    buy();\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_includeUnclaimed\",\"type\":\"bool\"}],\"name\":\"currentPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setFailed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"custodian\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"whitelistAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPerTokenPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"weiToTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeoutBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokensToWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"broker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedPerTokenPayouts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unclaimedPayoutTotals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_broker\",\"type\":\"address\"},{\"name\":\"_custodian\",\"type\":\"address\"},{\"name\":\"_timeoutBlock\",\"type\":\"uint256\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_fundingGoal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stage\",\"type\":\"uint8\"}],\"name\":\"StageEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"ClaimEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TerminatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"WhitelistedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CustomPOAToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000a8304a539dbe280c5d4230b492d1de32dd29c800000000000000000000000000ebd7e41d48a9d80e18188d4acc0dc77e28271800000000000000000000000000000000000000000000000000000000000119090000000000000000000000000000000000000000000000008ac7230489e8000000000000000000000000000000000000000000000000000000038d7ea4c6800000000000000000000000000000000000000000000000000000000000000000185465737420437573746f6d20506f4120436f6e747261637400000000000000000000000000000000000000000000000000000000000000000000000000000008504f412d54455354000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://202412154b1303d9352a26241e1d56d609b3b0d9ae2632d1a6a8f595e0bf174b"}]}