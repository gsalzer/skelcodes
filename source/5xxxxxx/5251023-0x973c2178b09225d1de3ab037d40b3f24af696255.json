{"status":"1","message":"OK","result":[{"SourceCode":"contract SHA3_512 {\r\n   function hash(uint64[8]) pure public returns(uint32[16]) {}\r\n}\r\n\r\ncontract TeikhosBounty {\r\n\r\n    address public bipedaljoe = 0x4c5D24A7Ca972aeA90Cc040DA6770A13Fc7D4d9A; // In case no one submits the correct solution, the bounty is sent to me\r\n\r\n    SHA3_512 public sha3_512 = SHA3_512(0xbD6361cC42fD113ED9A9fdbEDF7eea27b325a222); // Mainnet: 0xbD6361cC42fD113ED9A9fdbEDF7eea27b325a222, \r\n                                                                                     // Rinkeby: 0x2513CF99E051De22cEB6cf5f2EaF0dc4065c8F1f\r\n\r\n    struct Commit {\r\n        uint timestamp;\r\n        bytes signature;\r\n    }    \r\n\r\n    mapping(address => Commit) public commitment;\r\n\r\n    struct Solution {\r\n        uint timestamp;\r\n        bytes publicKey; // The key that solves the bounty, empty until the correct key has been submitted with authenticate()\r\n        bytes32 msgHash;\r\n    }    \r\n\r\n    Solution public isSolved;\r\n    \r\n    struct Winner {\r\n        uint timestamp;\r\n        address winner;\r\n    }\r\n\r\n    Winner public winner;\r\n\r\n    enum State { Commit, Reveal, Payout }\r\n    \r\n    modifier inState(State _state)\r\n    {\r\n        if(_state == State.Commit) { require(isSolved.timestamp == 0); }\r\n        if(_state == State.Reveal) { require(isSolved.timestamp != 0 && now < isSolved.timestamp + 7 days); }\r\n        if(_state == State.Payout) { require(isSolved.timestamp != 0 && now > isSolved.timestamp + 7 days); }\r\n        _;\r\n    }\r\n\r\n    // Proof-of-public-key in format 2xbytes32, to support xor operator and ecrecover r, s v format\r\n    bytes32 public proof_of_public_key1 = hex\"7b5f8ddd34df50d24e492bbee1a888122c1579e898eaeb6e0673156a1b97c24b\";\r\n    bytes32 public proof_of_public_key2 = hex\"26d64a34756bd684766dce3e6a8e8695a14a2b16d001559f4ae3a0849ac127fe\";\r\n\r\n    function commit(bytes _signature) public inState(State.Commit) {\r\n        require(commitment[msg.sender].timestamp == 0);\r\n        commitment[msg.sender].signature = _signature;\r\n        commitment[msg.sender].timestamp = now;\r\n    }\r\n\r\n    function reveal() public inState(State.Reveal) {\r\n        bytes memory signature = commitment[msg.sender].signature;\r\n        require(signature.length != 0);\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n        r := mload(add(signature,0x20))\r\n        s := mload(add(signature,0x40))\r\n        v := byte(0, mload(add(signature, 96)))\r\n        }\r\n\r\n        if (v < 27) v += 27;\r\n\r\n        if(ecrecover(isSolved.msgHash, v, r, s) == msg.sender) {\r\n            if(winner.timestamp == 0 || commitment[msg.sender].timestamp < winner.timestamp) {\r\n                winner.winner = msg.sender;\r\n                winner.timestamp = commitment[msg.sender].timestamp;\r\n            }\r\n        }\r\n        delete commitment[msg.sender];\r\n    }\r\n\r\n    function reward() public inState(State.Payout) {\r\n        if(winner.winner != 0) selfdestruct(winner.winner);\r\n        else selfdestruct(bipedaljoe);\r\n    }\r\n\r\n    function authenticate(bytes _publicKey) public inState(State.Commit) {\r\n        \r\n        // Remind people to commit before submitting the solution\r\n        require(commitment[msg.sender].timestamp != 0);\r\n        \r\n        bytes memory keyHash = getHash(_publicKey);\r\n         \r\n        // Split hash of public key in 2xbytes32, to support xor operator and ecrecover r, s v format\r\n\r\n        bytes32 hash1;\r\n        bytes32 hash2;\r\n\r\n        assembly {\r\n        hash1 := mload(add(keyHash,0x20))\r\n        hash2 := mload(add(keyHash,0x40))\r\n        }\r\n\r\n        // Use xor (reverse cipher) to get signature in r, s v format\r\n        bytes32 r = proof_of_public_key1 ^ hash1;\r\n        bytes32 s = proof_of_public_key2 ^ hash2;\r\n\r\n        // Get msgHash for use with ecrecover\r\n        bytes32 msgHash = keccak256(\"\\x19Ethereum Signed Message:\\n64\", _publicKey);\r\n\r\n        // Get address from public key\r\n        address signer = address(keccak256(_publicKey));\r\n\r\n        // The value v is not known, try both 27 and 28\r\n        if(ecrecover(msgHash, 27, r, s) == signer || ecrecover(msgHash, 28, r, s) == signer ) {\r\n            isSolved.timestamp = now;\r\n            isSolved.publicKey = _publicKey; \r\n            isSolved.msgHash = msgHash;\r\n        }\r\n    }\r\n\r\n   // A separate method getHash() for converting bytes to uint64[8], which is done since the EVM cannot pass bytes between contracts\r\n   // The SHA3_512 logic is in a separate contract to make it easier to read, that contract could be audited on its own, and so on\r\n\r\n   function getHash(bytes _message) view internal returns (bytes messageHash) {\r\n\r\n        // Use SHA3_512 library to get a sha3_512 hash of public key\r\n\r\n        uint64[8] memory input;\r\n\r\n        // The evm is big endian, have to reverse the bytes\r\n\r\n        bytes memory reversed = new bytes(64);\r\n\r\n        for(uint i = 0; i < 64; i++) {\r\n            reversed[i] = _message[63 - i];\r\n        }\r\n\r\n        for(i = 0; i < 8; i++) {\r\n            bytes8 oneEigth;\r\n            // Load 8 byte from reversed public key at position 32 + i * 8\r\n            assembly {\r\n                oneEigth := mload(add(reversed, add(32, mul(i, 8)))) \r\n            }\r\n            input[7 - i] = uint64(oneEigth);\r\n        }\r\n\r\n        uint32[16] memory output = sha3_512.hash(input);\r\n        \r\n        bytes memory toBytes = new bytes(64);\r\n        \r\n        for(i = 0; i < 16; i++) {\r\n            bytes4 oneSixteenth = bytes4(output[15 - i]);\r\n            // Store 4 byte in keyHash at position 32 + i * 4\r\n            assembly { mstore(add(toBytes, add(32, mul(i, 4))), oneSixteenth) }\r\n        }\r\n\r\n        messageHash = new bytes(64);\r\n\r\n        for(i = 0; i < 64; i++) {\r\n            messageHash[i] = toBytes[63 - i];\r\n        }   \r\n   }\r\n   \r\n   // Make it possible to send ETH to the contract with \"payable\" on the fallback function\r\n   \r\n    function() public payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"proof_of_public_key1\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSolved\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"publicKey\",\"type\":\"bytes\"},{\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"commit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sha3_512\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reveal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"commitment\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proof_of_public_key2\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bipedaljoe\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_publicKey\",\"type\":\"bytes\"}],\"name\":\"authenticate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"TeikhosBounty","CompilerVersion":"v0.4.22-nightly.2018.3.13+commit.f2614be9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3e047ae964f2fff749c6de10ddfb64c4e1db363056c7f6d364636602b9cf4e96"}]}