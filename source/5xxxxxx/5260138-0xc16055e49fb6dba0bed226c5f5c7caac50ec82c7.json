{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\ncontract CrypteloERC20{\r\n  mapping (address => uint256) public balanceOf;\r\n  function transfer(address to, uint amount);\r\n  function burn(uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract CrypteloPreSale{\r\n  function isWhiteList(address _addr) public returns (uint _group);\r\n}\r\n\r\ncontract TadamWhitelistPublicSale{\r\n    function isWhiteListed(address _addr) returns (uint _group);\r\n    mapping (address => uint) public PublicSaleWhiteListed;\r\n}\r\n\r\ncontract CrypteloPublicSale{\r\n    using SafeMath for uint256;\r\n    mapping (address => bool) private owner;\r\n\r\n    \r\n    uint public contributorCounter = 0;\r\n    mapping (uint => address) contributor;\r\n    mapping (address => uint) contributorAmount;\r\n    \r\n    /*\r\n        Public Sale Timings and bonuses\r\n    */\r\n    \r\n    \r\n    uint ICOstartTime = 0; \r\n    uint ICOendTime = now + 30 days;\r\n    \r\n    //first 7 days bonus 25%\r\n    uint firstDiscountStartTime = ICOstartTime;\r\n    uint firstDiscountEndTime = ICOstartTime + 7 days;\r\n    \r\n    //day 7 to day 14 bonus 20%\r\n    uint secDiscountStartTime = ICOstartTime + 7 days;\r\n    uint secDiscountEndTime = ICOstartTime + 14 days;\r\n    \r\n    //day 14 to day 21 bonus 15%\r\n    uint thirdDiscountStartTime = ICOstartTime + 14 days;\r\n    uint thirdDiscountEndTime = ICOstartTime + 21 days;\r\n    \r\n    //day 21 to day 28 bonus 10%\r\n    uint fourthDiscountStartTime = ICOstartTime + 21 days;\r\n    uint fourthDiscountEndTime = ICOstartTime + 28 days;\r\n\r\n    /*\r\n        External addresses\r\n    */\r\n    address public ERC20Address; \r\n    address public preSaleContract;\r\n    address private forwardFundsWallet;\r\n    address public whiteListAddress;\r\n    \r\n    event eSendTokens(address _addr, uint _amount);\r\n    event eStateChange(bool state);\r\n    event eLog(string str, uint no);\r\n    event eWhiteList(address adr, uint group);\r\n    \r\n    function calculateBonus(uint _whiteListLevel) returns (uint _totalBonus){\r\n        uint timeBonus = currentTimeBonus();\r\n        uint totalBonus = 0;\r\n        uint whiteListBonus = 0;\r\n        if (_whiteListLevel == 1){\r\n            whiteListBonus = whiteListBonus.add(5);\r\n        }\r\n        totalBonus = totalBonus.add(timeBonus).add(whiteListBonus);\r\n        return totalBonus;\r\n    }\r\n    function currentTimeBonus () public returns (uint _bonus){\r\n        uint bonus = 0;\r\n        //ICO is running\r\n        if (now >= firstDiscountStartTime && now <= firstDiscountEndTime){\r\n            bonus = 25;\r\n        }else if(now >= secDiscountStartTime && now <= secDiscountEndTime){\r\n            bonus = 20;\r\n        }else if(now >= thirdDiscountStartTime && now <= thirdDiscountEndTime){\r\n            bonus = 15;\r\n        }else if(now >= fourthDiscountStartTime && now <= fourthDiscountEndTime){\r\n            bonus = 10;\r\n        }else{\r\n            bonus = 5;\r\n        }\r\n        return bonus;\r\n    }\r\n    \r\n    function CrypteloPublicSale(address _ERC20Address, address _preSaleContract, address _forwardFundsWallet, address _whiteListAddress ){\r\n        owner[msg.sender] = true;\r\n        ERC20Address = _ERC20Address;\r\n        preSaleContract = _preSaleContract;\r\n        forwardFundsWallet = _forwardFundsWallet;\r\n        whiteListAddress = _whiteListAddress;    \r\n    }\r\n    /*\r\n        States are\r\n            false - Paused - it doesn't accept payments\r\n            true - Live - accepts payments and disburse tokens if conditions meet\r\n    */\r\n    bool public currentState = false;\r\n\r\n    \r\n    /*\r\n        Financial Ratios \r\n    */\r\n    uint hardCapTokens = addDecimals(8,187500000);\r\n    uint raisedWei = 0;\r\n    uint tokensLeft = hardCapTokens;\r\n    uint reservedTokens = 0;\r\n    uint minimumDonationWei = 100000000000000000;\r\n    uint public tokensPerEther = addDecimals(8, 12500); //1250000000000\r\n    uint public tokensPerMicroEther = tokensPerEther.div(1000000);\r\n    \r\n    function () payable {\r\n\r\n        uint tokensToSend = 0;\r\n        uint amountEthWei = msg.value;\r\n        address sender = msg.sender;\r\n        \r\n        //check if its live\r\n        \r\n        require(currentState);\r\n        eLog(\"state OK\", 0);\r\n        require(amountEthWei >= minimumDonationWei);\r\n        eLog(\"amount OK\", amountEthWei);\r\n        \r\n        uint whiteListedLevel = isWhiteListed(sender);\r\n        require( whiteListedLevel > 0);\r\n\r\n        tokensToSend = calculateTokensToSend(amountEthWei, whiteListedLevel);\r\n        \r\n        require(tokensLeft >= tokensToSend);\r\n        eLog(\"tokens left vs tokens to send ok\", tokensLeft);    \r\n        eLog(\"tokensToSend\", tokensToSend);\r\n        \r\n        //test for minus\r\n        if (tokensToSend <= tokensLeft){\r\n            tokensLeft = tokensLeft.sub(tokensToSend);    \r\n        }\r\n        \r\n        addContributor(sender, tokensToSend);\r\n        reservedTokens = reservedTokens.add(tokensToSend);\r\n        eLog(\"send tokens ok\", 0);\r\n        \r\n        forwardFunds(amountEthWei);\r\n        eLog(\"forward funds ok\", amountEthWei);\r\n    }\r\n    \r\n    function  calculateTokensToSend(uint _amount_wei, uint _whiteListLevel) public returns (uint _tokensToSend){\r\n        uint tokensToSend = 0;\r\n        uint amountMicroEther = _amount_wei.div(1000000000000);\r\n        uint tokens = amountMicroEther.mul(tokensPerMicroEther);\r\n        \r\n        eLog(\"tokens: \", tokens);\r\n        uint bonusPerc = calculateBonus(_whiteListLevel); \r\n        uint bonusTokens = 0;\r\n        if (bonusPerc > 0){\r\n            bonusTokens = tokens.div(100).mul(bonusPerc);    \r\n        }\r\n        eLog(\"bonusTokens\", bonusTokens); \r\n        \r\n        tokensToSend = tokens.add(bonusTokens);\r\n\r\n        eLog(\"tokensToSend\", tokensToSend);  \r\n        return tokensToSend;\r\n    }\r\n    \r\n    function payContributorByNumber(uint _n) onlyOwner{\r\n        require(now > ICOendTime);\r\n        \r\n        address adr = contributor[_n];\r\n        uint amount = contributorAmount[adr];\r\n        sendTokens(adr, amount);\r\n        contributorAmount[adr] = 0;\r\n    }\r\n    \r\n    function payContributorByAdress(address _adr) {\r\n        require(now > ICOendTime);\r\n        uint amount = contributorAmount[_adr];\r\n        sendTokens(_adr, amount);\r\n        contributorAmount[_adr] = 0;\r\n    }\r\n    \r\n    function addContributor(address _addr, uint _amount) private{\r\n        contributor[contributorCounter] = _addr;\r\n        if (contributorAmount[_addr] > 0){\r\n            contributorAmount[_addr] += _amount;\r\n        }else{\r\n            contributorAmount[_addr] = _amount;    \r\n        }\r\n        \r\n        contributorCounter++;\r\n    }\r\n    function getContributorByAddress(address _addr) constant returns (uint _amount){\r\n        return contributorAmount[_addr];\r\n    }\r\n    \r\n    function getContributorByNumber(uint _n) constant returns (address _adr, uint _amount){\r\n        address contribAdr = contributor[_n];\r\n        uint amount = contributorAmount[contribAdr];\r\n        return (contribAdr, amount);\r\n        \r\n    }\r\n    \r\n    function forwardFunds(uint _amountEthWei) private{\r\n        raisedWei += _amountEthWei;\r\n        forwardFundsWallet.transfer(_amountEthWei);  //find balance\r\n    }\r\n    \r\n    function sendTokens(address _to, uint _amountCRL) private{\r\n        //invoke call on token address\r\n       CrypteloERC20 _tadamerc20;\r\n        _tadamerc20 = CrypteloERC20(ERC20Address);\r\n        _tadamerc20.transfer(_to, _amountCRL);\r\n        eSendTokens(_to, _amountCRL);\r\n    }\r\n    \r\n    function setCurrentState(bool _state) public onlyOwner {\r\n        currentState = _state;\r\n        eStateChange(_state);\r\n    } \r\n    \r\n    function burnAllTokens() public onlyOwner{\r\n        CrypteloERC20 _tadamerc20;\r\n        _tadamerc20 = CrypteloERC20(ERC20Address);\r\n        uint tokensToBurn = _tadamerc20.balanceOf(this);\r\n        require (tokensToBurn > reservedTokens);\r\n        tokensToBurn -= reservedTokens;\r\n        eLog(\"tokens burned\", tokensToBurn);\r\n        _tadamerc20.burn(tokensToBurn);\r\n    }\r\n    \r\n    function isWhiteListed(address _address) returns (uint){\r\n        \r\n        /*\r\n            return values :\r\n            0 = not whitelisted at all,\r\n            1 = white listed early (pre sale or before 15th of March)\r\n            2 = white listed after 15th of March\r\n        */\r\n        uint256 whiteListedStatus = 0;\r\n        \r\n        TadamWhitelistPublicSale whitelistPublic;\r\n        whitelistPublic = TadamWhitelistPublicSale(whiteListAddress);\r\n        \r\n        uint256 PSaleGroup = whitelistPublic.PublicSaleWhiteListed(_address);\r\n        //if we have it in the PublicSale add it\r\n        if (PSaleGroup > 0){\r\n            whiteListedStatus = PSaleGroup;\r\n        }else{\r\n            CrypteloPreSale _testPreSale;\r\n            _testPreSale = CrypteloPreSale(preSaleContract);\r\n            if (_testPreSale.isWhiteList(_address) > 0){\r\n                //exists in the pre-sale white list threfore give em early 1\r\n                whiteListedStatus = 1;\r\n            }else{\r\n                //not found on either\r\n                whiteListedStatus = 0;\r\n            }\r\n        }\r\n        eWhiteList(_address, whiteListedStatus);\r\n        return whiteListedStatus;\r\n    }\r\n    \r\n    function addDecimals(uint _noDecimals, uint _toNumber) private returns (uint _finalNo) {\r\n        uint finalNo = _toNumber * (10 ** _noDecimals);\r\n        return finalNo;\r\n    }\r\n    \r\n    function withdrawAllTokens() public onlyOwner{\r\n        CrypteloERC20 _tadamerc20;\r\n        _tadamerc20 = CrypteloERC20(ERC20Address);\r\n        uint totalAmount = _tadamerc20.balanceOf(this);\r\n        require(totalAmount > reservedTokens);\r\n        uint toWithdraw = totalAmount.sub(reservedTokens);\r\n        sendTokens(msg.sender, toWithdraw);\r\n    }\r\n    \r\n    function withdrawAllEther() public onlyOwner{\r\n        msg.sender.send(this.balance);\r\n    }\r\n     \r\n    modifier onlyOwner(){\r\n        require(owner[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"getContributorByNumber\",\"outputs\":[{\"name\":\"_adr\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerMicroEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount_wei\",\"type\":\"uint256\"},{\"name\":\"_whiteListLevel\",\"type\":\"uint256\"}],\"name\":\"calculateTokensToSend\",\"outputs\":[{\"name\":\"_tokensToSend\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whiteListLevel\",\"type\":\"uint256\"}],\"name\":\"calculateBonus\",\"outputs\":[{\"name\":\"_totalBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setCurrentState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributorCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getContributorByAddress\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"payContributorByAdress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"payContributorByNumber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC20Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnAllTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"currentTimeBonus\",\"outputs\":[{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ERC20Address\",\"type\":\"address\"},{\"name\":\"_preSaleContract\",\"type\":\"address\"},{\"name\":\"_forwardFundsWallet\",\"type\":\"address\"},{\"name\":\"_whiteListAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"eSendTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"eStateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"str\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"no\",\"type\":\"uint256\"}],\"name\":\"eLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"group\",\"type\":\"uint256\"}],\"name\":\"eWhiteList\",\"type\":\"event\"}]","ContractName":"CrypteloPublicSale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007123027d76a5135e66b3a365efaba2b55de18a62000000000000000000000000efcc5dcaba4a93046b5f5c24c1281c685154214c00000000000000000000000036dbd52934569093e4f74be22b4c46ba615dad53000000000000000000000000ec80e62211ab9ba26e33d95033af8968cdef2464","Library":"","SwarmSource":"bzzr://cc37a2fc6964f0723ae4fcf7513ca1afbeaf5f60b10bf79d6008eb3235be0f3b"}]}