{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract Proxied is Ownable {\r\n    address public target;\r\n    mapping (address => bool) public initialized;\r\n\r\n    event EventUpgrade(address indexed newTarget, address indexed oldTarget, address indexed admin);\r\n    event EventInitialized(address indexed target);\r\n\r\n    function upgradeTo(address _target) public;\r\n}\r\n\r\ncontract Upgradeable is Proxied {\r\n    /*\r\n     * @notice Modifier to make body of function only execute if the contract has not already been initialized.\r\n     */\r\n    modifier initializeOnceOnly() {\r\n         if(!initialized[target]) {\r\n             initialized[target] = true;\r\n             emit EventInitialized(target);\r\n             _;\r\n         } else revert();\r\n     }\r\n\r\n    /**\r\n     * @notice Will always fail if called. This is used as a placeholder for the contract ABI.\r\n     * @dev This is code is never executed by the Proxy using delegate call\r\n     */\r\n    function upgradeTo(address) public {\r\n        assert(false);\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize any state variables that would normally be set in the contructor.\r\n     * @dev Initialization functionality MUST be implemented in inherited upgradeable contract if the child contract requires\r\n     * variable initialization on creation. This is because the contructor of the child contract will not execute\r\n     * and set any state when the Proxy contract targets it.\r\n     * This function MUST be called stright after the Upgradeable contract is set as the target of the Proxy. This method\r\n     * can be overwridden so that it may have arguments. Make sure that the initializeOnceOnly() modifier is used to protect\r\n     * from being initialized more than once.\r\n     * If a contract is upgraded twice, pay special attention that the state variables are not initialized again\r\n     */\r\n    function initialize() initializeOnceOnly public {\r\n        // initialize contract state variables here\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require (!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require (paused) ;\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\ninterface IClaims  {\r\n\r\n    event ClaimCreated(uint indexed claimId);\r\n\r\n    function createClaim(address[] _voters, uint _votingDeadline,\r\n    address _claimantAddress) external;\r\n\r\n    function castVote(uint _claimId, uint _pType, bytes32 _hash, string _url,\r\n    bytes32 _tokenHash) external;\r\n    \r\n    function register(uint _claimId, uint _pType, bytes32 _hash, string _url,\r\n    bytes32 _tokenHash) external;\r\n}\r\n\r\ncontract NaiveClaims is Upgradeable, Pausable, IClaims  {\r\n\r\n    struct Claim {\r\n        address[] voters;\r\n        mapping(address => Vote) votes;\r\n        address claimantAddress;\r\n        uint votingDeadline;\r\n    }\r\n\r\n    struct Vote {\r\n        uint pType;\r\n        bytes32 hash;\r\n        string url;\r\n        bool exists;\r\n        bytes32 tokenHash;\r\n    }\r\n\r\n    mapping (uint => Claim) public claims;\r\n    event ClaimCreated(uint indexed claimId);\r\n    uint256 public claimsCreated;\r\n\r\n    /**\r\n     * @param _voters - addresses eligible to vote\r\n     * @param _votingDeadline - after which votes cannot be submitted\r\n     * @param _claimantAddress  - claimants address\r\n     */\r\n    function createClaim(address[] _voters, uint _votingDeadline, address _claimantAddress) external whenNotPaused {\r\n\r\n        claims[claimsCreated].voters = _voters;\r\n        claims[claimsCreated].claimantAddress = _claimantAddress;\r\n        claims[claimsCreated].votingDeadline = _votingDeadline;\r\n\r\n        emit ClaimCreated(claimsCreated);\r\n        claimsCreated++;\r\n    }\r\n\r\n    /**\r\n     * @param _claimId - claim id for which user is casting the vote\r\n     * @param _pType - type of hashPointer (1 - PlainVote)\r\n     * @param _hash - of the vote - in this version plain YES or NO\r\n     * @param _url - to the location of the vote (mongo://{vote-doc-id})\r\n     * @param _tokenHash - received from indorse on centralized vote submission\r\n     */\r\n    function castVote(uint _claimId, uint _pType, bytes32 _hash, string _url,\r\n    bytes32 _tokenHash) external {\r\n        Claim storage claim = claims[_claimId];\r\n        Vote storage vote = claim.votes[msg.sender];\r\n\r\n        require(vote.exists != true, \"Voters can only vote once\");\r\n        require(now < claim.votingDeadline, \"Cannot vote after the dealine has passed\");\r\n\r\n        claims[_claimId].votes[msg.sender] = Vote(_pType, _hash, _url, true, _tokenHash);\r\n    }\r\n\r\n    function getVote(uint _claimId, address _voter)  constant external returns (uint ,bytes32,\r\n    string ,bool ,bytes32){\r\n        return (claims[_claimId].votes[_voter].pType,\r\n        claims[_claimId].votes[_voter].hash,\r\n        claims[_claimId].votes[_voter].url,\r\n        claims[_claimId].votes[_voter].exists,\r\n        claims[_claimId].votes[_voter].tokenHash);\r\n    }\r\n\r\n    function getVoter(uint _claimId, uint _index) external constant returns (address) {\r\n        return claims[_claimId].voters[_index];\r\n    }\r\n\r\n    function getVoterCount(uint _claimId) external constant returns (uint) {\r\n        return claims[_claimId].voters.length;\r\n    }\r\n\r\n    function initialize() initializeOnceOnly public {\r\n        claimsCreated = 0; // This is not strictly needed but is good practice to show initialization here\r\n    }\r\n\r\n    function register(uint _claimId, uint _pType, bytes32 _hash, string _url,\r\n    bytes32 _tokenHash) external {\r\n        revert(\"Unsupported operation\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_claimId\",\"type\":\"uint256\"},{\"name\":\"_pType\",\"type\":\"uint256\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_url\",\"type\":\"string\"},{\"name\":\"_tokenHash\",\"type\":\"bytes32\"}],\"name\":\"castVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voters\",\"type\":\"address[]\"},{\"name\":\"_votingDeadline\",\"type\":\"uint256\"},{\"name\":\"_claimantAddress\",\"type\":\"address\"}],\"name\":\"createClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimsCreated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_claimId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getVoter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_claimId\",\"type\":\"uint256\"},{\"name\":\"_pType\",\"type\":\"uint256\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_url\",\"type\":\"string\"},{\"name\":\"_tokenHash\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"name\":\"claimantAddress\",\"type\":\"address\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_claimId\",\"type\":\"uint256\"},{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"getVote\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_claimId\",\"type\":\"uint256\"}],\"name\":\"getVoterCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimId\",\"type\":\"uint256\"}],\"name\":\"ClaimCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newTarget\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oldTarget\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"EventUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"}],\"name\":\"EventInitialized\",\"type\":\"event\"}]","ContractName":"NaiveClaims","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c287abcb81a4876bc54fe819bf499a1d265fdec8149ed9914081e2e4614f0b4e"}]}