{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSExec {\r\n    function tryExec( address target, bytes calldata, uint value)\r\n             internal\r\n             returns (bool call_ret)\r\n    {\r\n        return target.call.value(value)(calldata);\r\n    }\r\n    function exec( address target, bytes calldata, uint value)\r\n             internal\r\n    {\r\n        if(!tryExec(target, calldata, value)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    // Convenience aliases\r\n    function exec( address t, bytes c )\r\n        internal\r\n    {\r\n        exec(t, c, 0);\r\n    }\r\n    function exec( address t, uint256 v )\r\n        internal\r\n    {\r\n        bytes memory c; exec(t, c, v);\r\n    }\r\n    function tryExec( address t, bytes c )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return tryExec(t, c, 0);\r\n    }\r\n    function tryExec( address t, uint256 v )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        bytes memory c; return tryExec(t, c, v);\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSGroup is DSExec, DSNote {\r\n    address[]  public  members;\r\n    uint       public  quorum;\r\n    uint       public  window;\r\n    uint       public  actionCount;\r\n\r\n    mapping (uint => Action)                     public  actions;\r\n    mapping (uint => mapping (address => bool))  public  confirmedBy;\r\n    mapping (address => bool)                    public  isMember;\r\n\r\n    // Legacy events\r\n    event Proposed   (uint id, bytes calldata);\r\n    event Confirmed  (uint id, address member);\r\n    event Triggered  (uint id);\r\n\r\n    struct Action {\r\n        address  target;\r\n        bytes    calldata;\r\n        uint     value;\r\n\r\n        uint     confirmations;\r\n        uint     deadline;\r\n        bool     triggered;\r\n    }\r\n\r\n    function DSGroup(\r\n        address[]  members_,\r\n        uint       quorum_,\r\n        uint       window_\r\n    ) {\r\n        members  = members_;\r\n        quorum   = quorum_;\r\n        window   = window_;\r\n\r\n        for (uint i = 0; i < members.length; i++) {\r\n            isMember[members[i]] = true;\r\n        }\r\n    }\r\n\r\n    function memberCount() constant returns (uint) {\r\n        return members.length;\r\n    }\r\n\r\n    function target(uint id) constant returns (address) {\r\n        return actions[id].target;\r\n    }\r\n    function calldata(uint id) constant returns (bytes) {\r\n        return actions[id].calldata;\r\n    }\r\n    function value(uint id) constant returns (uint) {\r\n        return actions[id].value;\r\n    }\r\n\r\n    function confirmations(uint id) constant returns (uint) {\r\n        return actions[id].confirmations;\r\n    }\r\n    function deadline(uint id) constant returns (uint) {\r\n        return actions[id].deadline;\r\n    }\r\n    function triggered(uint id) constant returns (bool) {\r\n        return actions[id].triggered;\r\n    }\r\n\r\n    function confirmed(uint id) constant returns (bool) {\r\n        return confirmations(id) >= quorum;\r\n    }\r\n    function expired(uint id) constant returns (bool) {\r\n        return now > deadline(id);\r\n    }\r\n\r\n    function deposit() note payable {\r\n    }\r\n\r\n    function propose(\r\n        address  target,\r\n        bytes    calldata,\r\n        uint     value\r\n    ) onlyMembers note returns (uint id) {\r\n        id = ++actionCount;\r\n\r\n        actions[id].target    = target;\r\n        actions[id].calldata  = calldata;\r\n        actions[id].value     = value;\r\n        actions[id].deadline  = now + window;\r\n\r\n        Proposed(id, calldata);\r\n    }\r\n\r\n    function confirm(uint id) onlyMembers onlyActive(id) note {\r\n        assert(!confirmedBy[id][msg.sender]);\r\n\r\n        confirmedBy[id][msg.sender] = true;\r\n        actions[id].confirmations++;\r\n\r\n        Confirmed(id, msg.sender);\r\n    }\r\n\r\n    function trigger(uint id) onlyMembers onlyActive(id) note {\r\n        assert(confirmed(id));\r\n\r\n        actions[id].triggered = true;\r\n        exec(actions[id].target, actions[id].calldata, actions[id].value);\r\n\r\n        Triggered(id);\r\n    }\r\n\r\n    modifier onlyMembers {\r\n        assert(isMember[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyActive(uint id) {\r\n        assert(!expired(id));\r\n        assert(!triggered(id));\r\n        _;\r\n    }\r\n\r\n    //------------------------------------------------------------------\r\n    // Legacy functions\r\n    //------------------------------------------------------------------\r\n\r\n    function getInfo() constant returns (\r\n        uint  quorum_,\r\n        uint  memberCount,\r\n        uint  window_,\r\n        uint  actionCount_\r\n    ) {\r\n        return (quorum, members.length, window, actionCount);\r\n    }\r\n\r\n    function getActionStatus(uint id) constant returns (\r\n        uint     confirmations,\r\n        uint     deadline,\r\n        bool     triggered,\r\n        address  target,\r\n        uint     value\r\n    ) {\r\n        return (\r\n            actions[id].confirmations,\r\n            actions[id].deadline,\r\n            actions[id].triggered,\r\n            actions[id].target,\r\n            actions[id].value\r\n        );\r\n    }\r\n}\r\n\r\ncontract DSGroupFactory is DSNote {\r\n    mapping (address => bool)  public  isGroup;\r\n\r\n    function newGroup(\r\n        address[]  members,\r\n        uint       quorum,\r\n        uint       window\r\n    ) note returns (DSGroup group) {\r\n        group = new DSGroup(members, quorum, window);\r\n        isGroup[group] = true;\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(s));\r\n    }\r\n\r\n}\r\n\r\ncontract WETH9_ {\r\n    string public name     = \"Wrapped Ether\";\r\n    string public symbol   = \"WETH\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function() public payable {\r\n        deposit();\r\n    }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface FundInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PortfolioContent(address[] assets, uint[] holdings, uint[] prices);\r\n    event RequestUpdated(uint id);\r\n    event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);\r\n    event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);\r\n    event ErrorMessage(string errorMessage);\r\n\r\n    // EXTERNAL METHODS\r\n    // Compliance by Investor\r\n    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external;\r\n    function executeRequest(uint requestId) external;\r\n    function cancelRequest(uint requestId) external;\r\n    function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);\r\n    // Administration by Manager\r\n    function enableInvestment(address[] ofAssets) external;\r\n    function disableInvestment(address[] ofAssets) external;\r\n    function shutDown() external;\r\n\r\n    // PUBLIC METHODS\r\n    function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);\r\n    function calcSharePriceAndAllocateFees() public returns (uint);\r\n\r\n\r\n    // PUBLIC VIEW METHODS\r\n    // Get general information\r\n    function getModules() view returns (address, address, address);\r\n    function getLastRequestId() view returns (uint);\r\n    function getManager() view returns (address);\r\n\r\n    // Get accounting information\r\n    function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);\r\n    function calcSharePrice() view returns (uint);\r\n}\r\n\r\ninterface AssetInterface {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    // Events\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n\r\n    //ERC 223\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\r\n\r\n    // ERC 20\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    // PUBLIC VIEW METHODS\r\n    function balanceOf(address _owner) view public returns (uint balance);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract Asset is DSMath, ERC20Interface {\r\n\r\n    // DATA STRUCTURES\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public _totalSupply;\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    /// @notice Restriction: An account can only use this function to send to itself\r\n    /// @dev Allows for an approved third party to transfer tokens from one\r\n    /// address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n        // require(_to == msg.sender); // can only use transferFrom to send to self\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(_spender != address(0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @dev Returns number of allowed tokens that a spender can transfer on\r\n    /// behalf of a token owner.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    /// @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by the given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns balance of owner.\r\n    function balanceOf(address _owner) constant public returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function totalSupply() view public returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ninterface SharesInterface {\r\n\r\n    event Created(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event Annihilated(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n\r\n    // VIEW METHODS\r\n\r\n    function getName() view returns (bytes32);\r\n    function getSymbol() view returns (bytes8);\r\n    function getDecimals() view returns (uint);\r\n    function getCreationTime() view returns (uint);\r\n    function toSmallestShareUnit(uint quantity) view returns (uint);\r\n    function toWholeShareUnit(uint quantity) view returns (uint);\r\n\r\n}\r\n\r\ncontract Shares is SharesInterface, Asset {\r\n\r\n    // FIELDS\r\n\r\n    // Constructor fields\r\n    bytes32 public name;\r\n    bytes8 public symbol;\r\n    uint public decimal;\r\n    uint public creationTime;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param _name Name these shares\r\n    /// @param _symbol Symbol of shares\r\n    /// @param _decimal Amount of decimals sharePrice is denominated in, defined to be equal as deciamls in REFERENCE_ASSET contract\r\n    /// @param _creationTime Timestamp of share creation\r\n    function Shares(bytes32 _name, bytes8 _symbol, uint _decimal, uint _creationTime) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimal = _decimal;\r\n        creationTime = _creationTime;\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getName() view returns (bytes32) { return name; }\r\n    function getSymbol() view returns (bytes8) { return symbol; }\r\n    function getDecimals() view returns (uint) { return decimal; }\r\n    function getCreationTime() view returns (uint) { return creationTime; }\r\n    function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }\r\n    function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @param recipient Address the new shares should be sent to\r\n    /// @param shareQuantity Number of shares to be created\r\n    function createShares(address recipient, uint shareQuantity) internal {\r\n        _totalSupply = add(_totalSupply, shareQuantity);\r\n        balances[recipient] = add(balances[recipient], shareQuantity);\r\n        emit Created(msg.sender, now, shareQuantity);\r\n        emit Transfer(address(0), recipient, shareQuantity);\r\n    }\r\n\r\n    /// @param recipient Address the new shares should be taken from when destroyed\r\n    /// @param shareQuantity Number of shares to be annihilated\r\n    function annihilateShares(address recipient, uint shareQuantity) internal {\r\n        _totalSupply = sub(_totalSupply, shareQuantity);\r\n        balances[recipient] = sub(balances[recipient], shareQuantity);\r\n        emit Annihilated(msg.sender, now, shareQuantity);\r\n        emit Transfer(recipient, address(0), shareQuantity);\r\n    }\r\n}\r\n\r\ninterface ComplianceInterface {\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks whether investment is permitted for a participant\r\n    /// @param ofParticipant Address requesting to invest in a Melon fund\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    /// @return Whether identity is eligible to invest in a Melon fund.\r\n    function isInvestmentPermitted(\r\n        address ofParticipant,\r\n        uint256 giveQuantity,\r\n        uint256 shareQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks whether redemption is permitted for a participant\r\n    /// @param ofParticipant Address requesting to redeem from a Melon fund\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\r\n    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\r\n    /// @return Whether identity is eligible to redeem from a Melon fund.\r\n    function isRedemptionPermitted(\r\n        address ofParticipant,\r\n        uint256 shareQuantity,\r\n        uint256 receiveQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ncontract DBC {\r\n\r\n    // MODIFIERS\r\n\r\n    modifier pre_cond(bool condition) {\r\n        require(condition);\r\n        _;\r\n    }\r\n\r\n    modifier post_cond(bool condition) {\r\n        _;\r\n        assert(condition);\r\n    }\r\n\r\n    modifier invariant(bool condition) {\r\n        require(condition);\r\n        _;\r\n        assert(condition);\r\n    }\r\n}\r\n\r\ncontract Owned is DBC {\r\n\r\n    // FIELDS\r\n\r\n    address public owner;\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    function isOwner() internal returns (bool) { return msg.sender == owner; }\r\n\r\n}\r\n\r\ncontract Fund is DSMath, DBC, Owned, Shares, FundInterface {\r\n\r\n    event OrderUpdated(address exchange, bytes32 orderId, UpdateType updateType);\r\n\r\n    // TYPES\r\n\r\n    struct Modules { // Describes all modular parts, standardised through an interface\r\n        CanonicalPriceFeed pricefeed; // Provides all external data\r\n        ComplianceInterface compliance; // Boolean functions regarding invest/redeem\r\n        RiskMgmtInterface riskmgmt; // Boolean functions regarding make/take orders\r\n    }\r\n\r\n    struct Calculations { // List of internal calculations\r\n        uint gav; // Gross asset value\r\n        uint managementFee; // Time based fee\r\n        uint performanceFee; // Performance based fee measured against QUOTE_ASSET\r\n        uint unclaimedFees; // Fees not yet allocated to the fund manager\r\n        uint nav; // Net asset value\r\n        uint highWaterMark; // A record of best all-time fund performance\r\n        uint totalSupply; // Total supply of shares\r\n        uint timestamp; // Time when calculations are performed in seconds\r\n    }\r\n\r\n    enum UpdateType { make, take, cancel }\r\n    enum RequestStatus { active, cancelled, executed }\r\n    struct Request { // Describes and logs whenever asset enter and leave fund due to Participants\r\n        address participant; // Participant in Melon fund requesting investment or redemption\r\n        RequestStatus status; // Enum: active, cancelled, executed; Status of request\r\n        address requestAsset; // Address of the asset being requested\r\n        uint shareQuantity; // Quantity of Melon fund shares\r\n        uint giveQuantity; // Quantity in Melon asset to give to Melon fund to receive shareQuantity\r\n        uint receiveQuantity; // Quantity in Melon asset to receive from Melon fund for given shareQuantity\r\n        uint timestamp;     // Time of request creation in seconds\r\n        uint atUpdateId;    // Pricefeed updateId when this request was created\r\n    }\r\n\r\n    struct Exchange {\r\n        address exchange;\r\n        address exchangeAdapter;\r\n        bool takesCustody;  // exchange takes custody before making order\r\n    }\r\n\r\n    struct OpenMakeOrder {\r\n        uint id; // Order Id from exchange\r\n        uint expiresAt; // Timestamp when the order expires\r\n    }\r\n\r\n    struct Order { // Describes an order event (make or take order)\r\n        address exchangeAddress; // address of the exchange this order is on\r\n        bytes32 orderId; // Id as returned from exchange\r\n        UpdateType updateType; // Enum: make, take (cancel should be ignored)\r\n        address makerAsset; // Order maker's asset\r\n        address takerAsset; // Order taker's asset\r\n        uint makerQuantity; // Quantity of makerAsset to be traded\r\n        uint takerQuantity; // Quantity of takerAsset to be traded\r\n        uint timestamp; // Time of order creation in seconds\r\n        uint fillTakerQuantity; // Quantity of takerAsset to be filled\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // Constant fields\r\n    uint public constant MAX_FUND_ASSETS = 20; // Max ownable assets by the fund supported by gas limits\r\n    uint public constant ORDER_EXPIRATION_TIME = 86400; // Make order expiration time (1 day)\r\n    // Constructor fields\r\n    uint public MANAGEMENT_FEE_RATE; // Fee rate in QUOTE_ASSET per managed seconds in WAD\r\n    uint public PERFORMANCE_FEE_RATE; // Fee rate in QUOTE_ASSET per delta improvement in WAD\r\n    address public VERSION; // Address of Version contract\r\n    Asset public QUOTE_ASSET; // QUOTE asset as ERC20 contract\r\n    // Methods fields\r\n    Modules public modules; // Struct which holds all the initialised module instances\r\n    Exchange[] public exchanges; // Array containing exchanges this fund supports\r\n    Calculations public atLastUnclaimedFeeAllocation; // Calculation results at last allocateUnclaimedFees() call\r\n    Order[] public orders;  // append-only list of makes/takes from this fund\r\n    mapping (address => mapping(address => OpenMakeOrder)) public exchangesToOpenMakeOrders; // exchangeIndex to: asset to open make orders\r\n    bool public isShutDown; // Security feature, if yes than investing, managing, allocateUnclaimedFees gets blocked\r\n    Request[] public requests; // All the requests this fund received from participants\r\n    mapping (address => bool) public isInvestAllowed; // If false, fund rejects investments from the key asset\r\n    address[] public ownedAssets; // List of all assets owned by the fund or for which the fund has open make orders\r\n    mapping (address => bool) public isInAssetList; // Mapping from asset to whether the asset exists in ownedAssets\r\n    mapping (address => bool) public isInOpenMakeOrder; // Mapping from asset to whether the asset is in a open make order as buy asset\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Should only be called via Version.setupFund(..)\r\n    /// @param withName human-readable descriptive name (not necessarily unique)\r\n    /// @param ofQuoteAsset Asset against which mgmt and performance fee is measured against and which can be used to invest using this single asset\r\n    /// @param ofManagementFee A time based fee expressed, given in a number which is divided by 1 WAD\r\n    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 1 WAD\r\n    /// @param ofCompliance Address of compliance module\r\n    /// @param ofRiskMgmt Address of risk management module\r\n    /// @param ofPriceFeed Address of price feed module\r\n    /// @param ofExchanges Addresses of exchange on which this fund can trade\r\n    /// @param ofDefaultAssets Addresses of assets to enable invest for (quote asset is already enabled)\r\n    /// @return Deployed Fund with manager set as ofManager\r\n    function Fund(\r\n        address ofManager,\r\n        bytes32 withName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address ofPriceFeed,\r\n        address[] ofExchanges,\r\n        address[] ofDefaultAssets\r\n    )\r\n        Shares(withName, \"MLNF\", 18, now)\r\n    {\r\n        require(ofManagementFee < 10 ** 18); // Require management fee to be less than 100 percent\r\n        require(ofPerformanceFee < 10 ** 18); // Require performance fee to be less than 100 percent\r\n        isInvestAllowed[ofQuoteAsset] = true;\r\n        owner = ofManager;\r\n        MANAGEMENT_FEE_RATE = ofManagementFee; // 1 percent is expressed as 0.01 * 10 ** 18\r\n        PERFORMANCE_FEE_RATE = ofPerformanceFee; // 1 percent is expressed as 0.01 * 10 ** 18\r\n        VERSION = msg.sender;\r\n        modules.compliance = ComplianceInterface(ofCompliance);\r\n        modules.riskmgmt = RiskMgmtInterface(ofRiskMgmt);\r\n        modules.pricefeed = CanonicalPriceFeed(ofPriceFeed);\r\n        // Bridged to Melon exchange interface by exchangeAdapter library\r\n        for (uint i = 0; i < ofExchanges.length; ++i) {\r\n            require(modules.pricefeed.exchangeIsRegistered(ofExchanges[i]));\r\n            var (ofExchangeAdapter, takesCustody, ) = modules.pricefeed.getExchangeInformation(ofExchanges[i]);\r\n            exchanges.push(Exchange({\r\n                exchange: ofExchanges[i],\r\n                exchangeAdapter: ofExchangeAdapter,\r\n                takesCustody: takesCustody\r\n            }));\r\n        }\r\n        QUOTE_ASSET = Asset(ofQuoteAsset);\r\n        // Quote Asset always in owned assets list\r\n        ownedAssets.push(ofQuoteAsset);\r\n        isInAssetList[ofQuoteAsset] = true;\r\n        require(address(QUOTE_ASSET) == modules.pricefeed.getQuoteAsset()); // Sanity check\r\n        for (uint j = 0; j < ofDefaultAssets.length; j++) {\r\n            require(modules.pricefeed.assetIsRegistered(ofDefaultAssets[j]));\r\n            isInvestAllowed[ofDefaultAssets[j]] = true;\r\n        }\r\n        atLastUnclaimedFeeAllocation = Calculations({\r\n            gav: 0,\r\n            managementFee: 0,\r\n            performanceFee: 0,\r\n            unclaimedFees: 0,\r\n            nav: 0,\r\n            highWaterMark: 10 ** getDecimals(),\r\n            totalSupply: _totalSupply,\r\n            timestamp: now\r\n        });\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    // EXTERNAL : ADMINISTRATION\r\n\r\n    /// @notice Enable investment in specified assets\r\n    /// @param ofAssets Array of assets to enable investment in\r\n    function enableInvestment(address[] ofAssets)\r\n        external\r\n        pre_cond(isOwner())\r\n    {\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            require(modules.pricefeed.assetIsRegistered(ofAssets[i]));\r\n            isInvestAllowed[ofAssets[i]] = true;\r\n        }\r\n    }\r\n\r\n    /// @notice Disable investment in specified assets\r\n    /// @param ofAssets Array of assets to disable investment in\r\n    function disableInvestment(address[] ofAssets)\r\n        external\r\n        pre_cond(isOwner())\r\n    {\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            isInvestAllowed[ofAssets[i]] = false;\r\n        }\r\n    }\r\n\r\n    function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }\r\n\r\n    // EXTERNAL : PARTICIPATION\r\n\r\n    /// @notice Give melon tokens to receive shares of this fund\r\n    /// @dev Recommended to give some leeway in prices to account for possibly slightly changing prices\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    /// @param investmentAsset Address of asset to invest in\r\n    function requestInvestment(\r\n        uint giveQuantity,\r\n        uint shareQuantity,\r\n        address investmentAsset\r\n    )\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(isInvestAllowed[investmentAsset]) // investment using investmentAsset has not been deactivated by the Manager\r\n        pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))    // Compliance Module: Investment permitted\r\n    {\r\n        requests.push(Request({\r\n            participant: msg.sender,\r\n            status: RequestStatus.active,\r\n            requestAsset: investmentAsset,\r\n            shareQuantity: shareQuantity,\r\n            giveQuantity: giveQuantity,\r\n            receiveQuantity: shareQuantity,\r\n            timestamp: now,\r\n            atUpdateId: modules.pricefeed.getLastUpdateId()\r\n        }));\r\n\r\n        emit RequestUpdated(getLastRequestId());\r\n    }\r\n\r\n    /// @notice Executes active investment and redemption requests, in a way that minimises information advantages of investor\r\n    /// @dev Distributes melon and shares according to the request\r\n    /// @param id Index of request to be executed\r\n    /// @dev Active investment or redemption request executed\r\n    function executeRequest(uint id)\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(requests[id].status == RequestStatus.active)\r\n        pre_cond(\r\n            _totalSupply == 0 ||\r\n            (\r\n                now >= add(requests[id].timestamp, modules.pricefeed.getInterval()) &&\r\n                modules.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)\r\n            )\r\n        )   // PriceFeed Module: Wait at least one interval time and two updates before continuing (unless it is the first investment)\r\n\r\n    {\r\n        Request request = requests[id];\r\n        var (isRecent, , ) =\r\n            modules.pricefeed.getPriceInfo(address(request.requestAsset));\r\n        require(isRecent);\r\n\r\n        // sharePrice quoted in QUOTE_ASSET and multiplied by 10 ** fundDecimals\r\n        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees())); // By definition quoteDecimals == fundDecimals\r\n        if (request.requestAsset != address(QUOTE_ASSET)) {\r\n            var (isPriceRecent, invertedRequestAssetPrice, requestAssetDecimal) = modules.pricefeed.getInvertedPriceInfo(request.requestAsset);\r\n            if (!isPriceRecent) {\r\n                revert();\r\n            }\r\n            costQuantity = mul(costQuantity, invertedRequestAssetPrice) / 10 ** requestAssetDecimal;\r\n        }\r\n\r\n        if (\r\n            isInvestAllowed[request.requestAsset] &&\r\n            costQuantity <= request.giveQuantity\r\n        ) {\r\n            request.status = RequestStatus.executed;\r\n            require(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity)); // Allocate Value\r\n            createShares(request.participant, request.shareQuantity); // Accounting\r\n            if (!isInAssetList[request.requestAsset]) {\r\n                ownedAssets.push(request.requestAsset);\r\n                isInAssetList[request.requestAsset] = true;\r\n            }\r\n        } else {\r\n            revert(); // Invalid Request or invalid giveQuantity / receiveQuantity\r\n        }\r\n    }\r\n\r\n    /// @notice Cancels active investment and redemption requests\r\n    /// @param id Index of request to be executed\r\n    function cancelRequest(uint id)\r\n        external\r\n        pre_cond(requests[id].status == RequestStatus.active) // Request is active\r\n        pre_cond(requests[id].participant == msg.sender || isShutDown) // Either request creator or fund is shut down\r\n    {\r\n        requests[id].status = RequestStatus.cancelled;\r\n    }\r\n\r\n    /// @notice Redeems by allocating an ownership percentage of each asset to the participant\r\n    /// @dev Independent of running price feed!\r\n    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for individual assets\r\n    /// @return Whether all assets sent to shareholder or not\r\n    function redeemAllOwnedAssets(uint shareQuantity)\r\n        external\r\n        returns (bool success)\r\n    {\r\n        return emergencyRedeem(shareQuantity, ownedAssets);\r\n    }\r\n\r\n    // EXTERNAL : MANAGING\r\n\r\n    /// @notice Universal method for calling exchange functions through adapters\r\n    /// @notice See adapter contracts for parameters needed for each exchange\r\n    /// @param exchangeIndex Index of the exchange in the \"exchanges\" array\r\n    /// @param method Signature of the adapter method to call (as per ABI spec)\r\n    /// @param orderAddresses [0] Order maker\r\n    /// @param orderAddresses [1] Order taker\r\n    /// @param orderAddresses [2] Order maker asset\r\n    /// @param orderAddresses [3] Order taker asset\r\n    /// @param orderAddresses [4] Fee recipient\r\n    /// @param orderValues [0] Maker token quantity\r\n    /// @param orderValues [1] Taker token quantity\r\n    /// @param orderValues [2] Maker fee\r\n    /// @param orderValues [3] Taker fee\r\n    /// @param orderValues [4] Timestamp (seconds)\r\n    /// @param orderValues [5] Salt/nonce\r\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\r\n    /// @param orderValues [7] Dexy signature mode\r\n    /// @param identifier Order identifier\r\n    /// @param v ECDSA recovery id\r\n    /// @param r ECDSA signature output r\r\n    /// @param s ECDSA signature output s\r\n    function callOnExchange(\r\n        uint exchangeIndex,\r\n        bytes4 method,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n    {\r\n        require(modules.pricefeed.exchangeMethodIsAllowed(\r\n            exchanges[exchangeIndex].exchange, method\r\n        ));\r\n        require((exchanges[exchangeIndex].exchangeAdapter).delegatecall(\r\n            method, exchanges[exchangeIndex].exchange,\r\n            orderAddresses, orderValues, identifier, v, r, s\r\n        ));\r\n    }\r\n\r\n    function addOpenMakeOrder(\r\n        address ofExchange,\r\n        address ofSellAsset,\r\n        uint orderId\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        isInOpenMakeOrder[ofSellAsset] = true;\r\n        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].id = orderId;\r\n        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].expiresAt = add(now, ORDER_EXPIRATION_TIME);\r\n    }\r\n\r\n    function removeOpenMakeOrder(\r\n        address ofExchange,\r\n        address ofSellAsset\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        delete exchangesToOpenMakeOrders[ofExchange][ofSellAsset];\r\n    }\r\n\r\n    function orderUpdateHook(\r\n        address ofExchange,\r\n        bytes32 orderId,\r\n        UpdateType updateType,\r\n        address[2] orderAddresses, // makerAsset, takerAsset\r\n        uint[3] orderValues        // makerQuantity, takerQuantity, fillTakerQuantity (take only)\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        // only save make/take\r\n        if (updateType == UpdateType.make || updateType == UpdateType.take) {\r\n            orders.push(Order({\r\n                exchangeAddress: ofExchange,\r\n                orderId: orderId,\r\n                updateType: updateType,\r\n                makerAsset: orderAddresses[0],\r\n                takerAsset: orderAddresses[1],\r\n                makerQuantity: orderValues[0],\r\n                takerQuantity: orderValues[1],\r\n                timestamp: block.timestamp,\r\n                fillTakerQuantity: orderValues[2]\r\n            }));\r\n        }\r\n        emit OrderUpdated(ofExchange, orderId, updateType);\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    // PUBLIC METHODS : ACCOUNTING\r\n\r\n    /// @notice Calculates gross asset value of the fund\r\n    /// @dev Decimals in assets must be equal to decimals in PriceFeed for all entries in AssetRegistrar\r\n    /// @dev Assumes that module.pricefeed.getPriceInfo(..) returns recent prices\r\n    /// @return gav Gross asset value quoted in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcGav() returns (uint gav) {\r\n        // prices quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        uint[] memory allAssetHoldings = new uint[](ownedAssets.length);\r\n        uint[] memory allAssetPrices = new uint[](ownedAssets.length);\r\n        address[] memory tempOwnedAssets;\r\n        tempOwnedAssets = ownedAssets;\r\n        delete ownedAssets;\r\n        for (uint i = 0; i < tempOwnedAssets.length; ++i) {\r\n            address ofAsset = tempOwnedAssets[i];\r\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\r\n            uint assetHoldings = add(\r\n                uint(AssetInterface(ofAsset).balanceOf(address(this))), // asset base units held by fund\r\n                quantityHeldInCustodyOfExchange(ofAsset)\r\n            );\r\n            // assetPrice formatting: mul(exchangePrice, 10 ** assetDecimal)\r\n            var (isRecent, assetPrice, assetDecimals) = modules.pricefeed.getPriceInfo(ofAsset);\r\n            if (!isRecent) {\r\n                revert();\r\n            }\r\n            allAssetHoldings[i] = assetHoldings;\r\n            allAssetPrices[i] = assetPrice;\r\n            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\r\n            gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));   // Sum up product of asset holdings of this vault and asset prices\r\n            if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || isInOpenMakeOrder[ofAsset]) { // Check if asset holdings is not zero or is address(QUOTE_ASSET) or in open make order\r\n                ownedAssets.push(ofAsset);\r\n            } else {\r\n                isInAssetList[ofAsset] = false; // Remove from ownedAssets if asset holdings are zero\r\n            }\r\n        }\r\n        emit PortfolioContent(tempOwnedAssets, allAssetHoldings, allAssetPrices);\r\n    }\r\n\r\n    /// @notice Add an asset to the list that this fund owns\r\n    function addAssetToOwnedAssets (address ofAsset)\r\n        public\r\n        pre_cond(isOwner() || msg.sender == address(this))\r\n    {\r\n        isInOpenMakeOrder[ofAsset] = true;\r\n        if (!isInAssetList[ofAsset]) {\r\n            ownedAssets.push(ofAsset);\r\n            isInAssetList[ofAsset] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Calculates unclaimed fees of the fund manager\r\n    @param gav Gross asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    @return {\r\n      \"managementFees\": \"A time (seconds) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\",\r\n      \"performanceFees\": \"A performance (rise of sharePrice measured in QUOTE_ASSET) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\",\r\n      \"unclaimedfees\": \"The sum of both managementfee and performancefee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\"\r\n    }\r\n    */\r\n    function calcUnclaimedFees(uint gav)\r\n        view\r\n        returns (\r\n            uint managementFee,\r\n            uint performanceFee,\r\n            uint unclaimedFees)\r\n    {\r\n        // Management fee calculation\r\n        uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);\r\n        uint gavPercentage = mul(timePassed, gav) / (1 years);\r\n        managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);\r\n\r\n        // Performance fee calculation\r\n        // Handle potential division through zero by defining a default value\r\n        uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), _totalSupply) : toSmallestShareUnit(1);\r\n        if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {\r\n            uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);\r\n            uint investmentProfits = wmul(gainInSharePrice, _totalSupply);\r\n            performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);\r\n        }\r\n\r\n        // Sum of all FEES\r\n        unclaimedFees = add(managementFee, performanceFee);\r\n    }\r\n\r\n    /// @notice Calculates the Net asset value of this fund\r\n    /// @param gav Gross asset value of this fund in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @param unclaimedFees The sum of both managementFee and performanceFee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @return nav Net asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcNav(uint gav, uint unclaimedFees)\r\n        view\r\n        returns (uint nav)\r\n    {\r\n        nav = sub(gav, unclaimedFees);\r\n    }\r\n\r\n    /// @notice Calculates the share price of the fund\r\n    /// @dev Convention for valuePerShare (== sharePrice) formatting: mul(totalValue / numShares, 10 ** decimal), to avoid floating numbers\r\n    /// @dev Non-zero share supply; value denominated in [base unit of melonAsset]\r\n    /// @param totalValue the total value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @param numShares the number of shares multiplied by 10 ** shareDecimals\r\n    /// @return valuePerShare Share price denominated in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcValuePerShare(uint totalValue, uint numShares)\r\n        view\r\n        pre_cond(numShares > 0)\r\n        returns (uint valuePerShare)\r\n    {\r\n        valuePerShare = toSmallestShareUnit(totalValue) / numShares;\r\n    }\r\n\r\n    /**\r\n    @notice Calculates essential fund metrics\r\n    @return {\r\n      \"gav\": \"Gross asset value of this fund denominated in [base unit of melonAsset]\",\r\n      \"managementFee\": \"A time (seconds) based fee\",\r\n      \"performanceFee\": \"A performance (rise of sharePrice measured in QUOTE_ASSET) based fee\",\r\n      \"unclaimedFees\": \"The sum of both managementFee and performanceFee denominated in [base unit of melonAsset]\",\r\n      \"feesShareQuantity\": \"The number of shares to be given as fees to the manager\",\r\n      \"nav\": \"Net asset value denominated in [base unit of melonAsset]\",\r\n      \"sharePrice\": \"Share price denominated in [base unit of melonAsset]\"\r\n    }\r\n    */\r\n    function performCalculations()\r\n        view\r\n        returns (\r\n            uint gav,\r\n            uint managementFee,\r\n            uint performanceFee,\r\n            uint unclaimedFees,\r\n            uint feesShareQuantity,\r\n            uint nav,\r\n            uint sharePrice\r\n        )\r\n    {\r\n        gav = calcGav(); // Reflects value independent of fees\r\n        (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);\r\n        nav = calcNav(gav, unclaimedFees);\r\n\r\n        // The value of unclaimedFees measured in shares of this fund at current value\r\n        feesShareQuantity = (gav == 0) ? 0 : mul(_totalSupply, unclaimedFees) / gav;\r\n        // The total share supply including the value of unclaimedFees, measured in shares of this fund\r\n        uint totalSupplyAccountingForFees = add(_totalSupply, feesShareQuantity);\r\n        sharePrice = _totalSupply > 0 ? calcValuePerShare(gav, totalSupplyAccountingForFees) : toSmallestShareUnit(1); // Handle potential division through zero by defining a default value\r\n    }\r\n\r\n    /// @notice Converts unclaimed fees of the manager into fund shares\r\n    /// @return sharePrice Share price denominated in [base unit of melonAsset]\r\n    function calcSharePriceAndAllocateFees() public returns (uint)\r\n    {\r\n        var (\r\n            gav,\r\n            managementFee,\r\n            performanceFee,\r\n            unclaimedFees,\r\n            feesShareQuantity,\r\n            nav,\r\n            sharePrice\r\n        ) = performCalculations();\r\n\r\n        createShares(owner, feesShareQuantity); // Updates _totalSupply by creating shares allocated to manager\r\n\r\n        // Update Calculations\r\n        uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;\r\n        atLastUnclaimedFeeAllocation = Calculations({\r\n            gav: gav,\r\n            managementFee: managementFee,\r\n            performanceFee: performanceFee,\r\n            unclaimedFees: unclaimedFees,\r\n            nav: nav,\r\n            highWaterMark: highWaterMark,\r\n            totalSupply: _totalSupply,\r\n            timestamp: now\r\n        });\r\n\r\n        emit FeesConverted(now, feesShareQuantity, unclaimedFees);\r\n        emit CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, _totalSupply);\r\n\r\n        return sharePrice;\r\n    }\r\n\r\n    // PUBLIC : REDEEMING\r\n\r\n    /// @notice Redeems by allocating an ownership percentage only of requestedAssets to the participant\r\n    /// @dev This works, but with loops, so only up to a certain number of assets (right now the max is 4)\r\n    /// @dev Independent of running price feed! Note: if requestedAssets != ownedAssets then participant misses out on some owned value\r\n    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for a slice of assets\r\n    /// @param requestedAssets List of addresses that consitute a subset of ownedAssets.\r\n    /// @return Whether all assets sent to shareholder or not\r\n    function emergencyRedeem(uint shareQuantity, address[] requestedAssets)\r\n        public\r\n        pre_cond(balances[msg.sender] >= shareQuantity)  // sender owns enough shares\r\n        returns (bool)\r\n    {\r\n        address ofAsset;\r\n        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\r\n        address[] memory redeemedAssets = new address[](requestedAssets.length);\r\n\r\n        // Check whether enough assets held by fund\r\n        for (uint i = 0; i < requestedAssets.length; ++i) {\r\n            ofAsset = requestedAssets[i];\r\n            require(isInAssetList[ofAsset]);\r\n            for (uint j = 0; j < redeemedAssets.length; j++) {\r\n                if (ofAsset == redeemedAssets[j]) {\r\n                    revert();\r\n                }\r\n            }\r\n            redeemedAssets[i] = ofAsset;\r\n            uint assetHoldings = add(\r\n                uint(AssetInterface(ofAsset).balanceOf(address(this))),\r\n                quantityHeldInCustodyOfExchange(ofAsset)\r\n            );\r\n\r\n            if (assetHoldings == 0) continue;\r\n\r\n            // participant's ownership percentage of asset holdings\r\n            ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / _totalSupply;\r\n\r\n            // CRITICAL ERR: Not enough fund asset balance for owed ownershipQuantitiy, eg in case of unreturned asset quantity at address(exchanges[i].exchange) address\r\n            if (uint(AssetInterface(ofAsset).balanceOf(address(this))) < ownershipQuantities[i]) {\r\n                isShutDown = true;\r\n                emit ErrorMessage(\"CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy\");\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Annihilate shares before external calls to prevent reentrancy\r\n        annihilateShares(msg.sender, shareQuantity);\r\n\r\n        // Transfer ownershipQuantity of Assets\r\n        for (uint k = 0; k < requestedAssets.length; ++k) {\r\n            // Failed to send owed ownershipQuantity from fund to participant\r\n            ofAsset = requestedAssets[k];\r\n            if (ownershipQuantities[k] == 0) {\r\n                continue;\r\n            } else if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[k])) {\r\n                revert();\r\n            }\r\n        }\r\n        emit Redeemed(msg.sender, now, shareQuantity);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC : FEES\r\n\r\n    /// @dev Quantity of asset held in exchange according to associated order id\r\n    /// @param ofAsset Address of asset\r\n    /// @return Quantity of input asset held in exchange\r\n    function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {\r\n        uint totalSellQuantity;     // quantity in custody across exchanges\r\n        uint totalSellQuantityInApprove; // quantity of asset in approve (allowance) but not custody of exchange\r\n        for (uint i; i < exchanges.length; i++) {\r\n            if (exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id == 0) {\r\n                continue;\r\n            }\r\n            var (sellAsset, , sellQuantity, ) = GenericExchangeInterface(exchanges[i].exchangeAdapter).getOrder(exchanges[i].exchange, exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id);\r\n            if (sellQuantity == 0) {    // remove id if remaining sell quantity zero (closed)\r\n                delete exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset];\r\n            }\r\n            totalSellQuantity = add(totalSellQuantity, sellQuantity);\r\n            if (!exchanges[i].takesCustody) {\r\n                totalSellQuantityInApprove += sellQuantity;\r\n            }\r\n        }\r\n        if (totalSellQuantity == 0) {\r\n            isInOpenMakeOrder[sellAsset] = false;\r\n        }\r\n        return sub(totalSellQuantity, totalSellQuantityInApprove); // Since quantity in approve is not actually in custody\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Calculates sharePrice denominated in [base unit of melonAsset]\r\n    /// @return sharePrice Share price denominated in [base unit of melonAsset]\r\n    function calcSharePrice() view returns (uint sharePrice) {\r\n        (, , , , , sharePrice) = performCalculations();\r\n        return sharePrice;\r\n    }\r\n\r\n    function getModules() view returns (address, address, address) {\r\n        return (\r\n            address(modules.pricefeed),\r\n            address(modules.compliance),\r\n            address(modules.riskmgmt)\r\n        );\r\n    }\r\n\r\n    function getLastRequestId() view returns (uint) { return requests.length - 1; }\r\n    function getLastOrderIndex() view returns (uint) { return orders.length - 1; }\r\n    function getManager() view returns (address) { return owner; }\r\n    function getOwnedAssetsLength() view returns (uint) { return ownedAssets.length; }\r\n    function getExchangeInfo() view returns (address[], address[], bool[]) {\r\n        address[] memory ofExchanges = new address[](exchanges.length);\r\n        address[] memory ofAdapters = new address[](exchanges.length);\r\n        bool[] memory takesCustody = new bool[](exchanges.length);\r\n        for (uint i = 0; i < exchanges.length; i++) {\r\n            ofExchanges[i] = exchanges[i].exchange;\r\n            ofAdapters[i] = exchanges[i].exchangeAdapter;\r\n            takesCustody[i] = exchanges[i].takesCustody;\r\n        }\r\n        return (ofExchanges, ofAdapters, takesCustody);\r\n    }\r\n    function orderExpired(address ofExchange, address ofAsset) view returns (bool) {\r\n        uint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;\r\n        require(expiryTime > 0);\r\n        return block.timestamp >= expiryTime;\r\n    }\r\n    function getOpenOrderInfo(address ofExchange, address ofAsset) view returns (uint, uint) {\r\n        OpenMakeOrder order = exchangesToOpenMakeOrders[ofExchange][ofAsset];\r\n        return (order.id, order.expiresAt);\r\n    }\r\n}\r\n\r\ninterface GenericExchangeInterface {\r\n\r\n    // EVENTS\r\n\r\n    event OrderUpdated(uint id);\r\n\r\n    // METHODS\r\n    // EXTERNAL METHODS\r\n\r\n    function makeOrder(\r\n        address onExchange,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) external returns (uint);\r\n    function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);\r\n    function cancelOrder(address onExchange, uint id) external returns (bool);\r\n\r\n\r\n    // PUBLIC METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function isApproveOnly() view returns (bool);\r\n    function getLastOrderId(address onExchange) view returns (uint);\r\n    function isActive(address onExchange, uint id) view returns (bool);\r\n    function getOwner(address onExchange, uint id) view returns (address);\r\n    function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);\r\n    function getTimestamp(address onExchange, uint id) view returns (uint);\r\n\r\n}\r\n\r\ninterface ExchangeAdapterInterface {\r\n    function makeOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n\r\n    function takeOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n\r\n    function cancelOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n}\r\n\r\ncontract MatchingMarketAdapter is ExchangeAdapterInterface, DSMath, DBC {\r\n\r\n    //  METHODS\r\n\r\n    //  PUBLIC METHODS\r\n\r\n    // Responsibilities of makeOrder are:\r\n    // - check sender\r\n    // - check fund not shut down\r\n    // - check price recent\r\n    // - check risk management passes\r\n    // - approve funds to be traded (if necessary)\r\n    // - make order on the exchange\r\n    // - check order was made (if possible)\r\n    // - place asset in ownedAssets if not already tracked\r\n    /// @notice Makes an order on the selected exchange\r\n    /// @dev These orders are not expected to settle immediately\r\n    /// @param targetExchange Address of the exchange\r\n    /// @param orderAddresses [2] Order maker asset\r\n    /// @param orderAddresses [3] Order taker asset\r\n    /// @param orderValues [0] Maker token quantity\r\n    /// @param orderValues [1] Taker token quantity\r\n    function makeOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) {\r\n        require(Fund(address(this)).owner() == msg.sender);\r\n        require(!Fund(address(this)).isShutDown());\r\n\r\n        ERC20 makerAsset = ERC20(orderAddresses[2]);\r\n        ERC20 takerAsset = ERC20(orderAddresses[3]);\r\n        uint makerQuantity = orderValues[0];\r\n        uint takerQuantity = orderValues[1];\r\n\r\n        require(makeOrderPermitted(makerQuantity, makerAsset, takerQuantity, takerAsset));\r\n        require(makerAsset.approve(targetExchange, makerQuantity));\r\n\r\n        uint orderId = MatchingMarket(targetExchange).offer(makerQuantity, makerAsset, takerQuantity, takerAsset);\r\n\r\n        require(orderId != 0);   // defines success in MatchingMarket\r\n        require(\r\n            Fund(address(this)).isInAssetList(takerAsset) ||\r\n            Fund(address(this)).getOwnedAssetsLength() < Fund(address(this)).MAX_FUND_ASSETS()\r\n        );\r\n\r\n        Fund(address(this)).addOpenMakeOrder(targetExchange, makerAsset, orderId);\r\n        Fund(address(this)).addAssetToOwnedAssets(takerAsset);\r\n        Fund(address(this)).orderUpdateHook(\r\n            targetExchange,\r\n            bytes32(orderId),\r\n            Fund.UpdateType.make,\r\n            [address(makerAsset), address(takerAsset)],\r\n            [makerQuantity, takerQuantity, uint(0)]\r\n        );\r\n    }\r\n\r\n    // Responsibilities of takeOrder are:\r\n    // - check sender\r\n    // - check fund not shut down\r\n    // - check not buying own fund tokens\r\n    // - check price exists for asset pair\r\n    // - check price is recent\r\n    // - check price passes risk management\r\n    // - approve funds to be traded (if necessary)\r\n    // - take order from the exchange\r\n    // - check order was taken (if possible)\r\n    // - place asset in ownedAssets if not already tracked\r\n    /// @notice Takes an active order on the selected exchange\r\n    /// @dev These orders are expected to settle immediately\r\n    /// @param targetExchange Address of the exchange\r\n    /// @param orderValues [6] Fill amount : amount of taker token to fill\r\n    /// @param identifier Active order id\r\n    function takeOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) {\r\n        require(Fund(address(this)).owner() == msg.sender);\r\n        require(!Fund(address(this)).isShutDown());\r\n        var (pricefeed,,) = Fund(address(this)).modules();\r\n        uint fillTakerQuantity = orderValues[6];\r\n        var (\r\n            maxMakerQuantity,\r\n            makerAsset,\r\n            maxTakerQuantity,\r\n            takerAsset\r\n        ) = MatchingMarket(targetExchange).getOffer(uint(identifier));\r\n        uint fillMakerQuantity = mul(fillTakerQuantity, maxMakerQuantity) / maxTakerQuantity;\r\n\r\n        require(takerAsset != address(this) && makerAsset != address(this));\r\n        require(address(makerAsset) != address(takerAsset));\r\n        require(pricefeed.existsPriceOnAssetPair(takerAsset, makerAsset));\r\n        require(fillMakerQuantity <= maxMakerQuantity);\r\n        require(fillTakerQuantity <= maxTakerQuantity);\r\n        require(takeOrderPermitted(fillTakerQuantity, takerAsset, fillMakerQuantity, makerAsset));\r\n        require(takerAsset.approve(targetExchange, fillTakerQuantity));\r\n        require(MatchingMarket(targetExchange).buy(uint(identifier), fillMakerQuantity));\r\n        require(\r\n            Fund(address(this)).isInAssetList(makerAsset) ||\r\n            Fund(address(this)).getOwnedAssetsLength() < Fund(address(this)).MAX_FUND_ASSETS()\r\n        );\r\n\r\n        Fund(address(this)).addAssetToOwnedAssets(makerAsset);\r\n        Fund(address(this)).orderUpdateHook(\r\n            targetExchange,\r\n            bytes32(identifier),\r\n            Fund.UpdateType.take,\r\n            [address(makerAsset), address(takerAsset)],\r\n            [maxMakerQuantity, maxTakerQuantity, fillTakerQuantity]\r\n        );\r\n    }\r\n\r\n    // responsibilities of cancelOrder are:\r\n    // - check sender is owner, or that order expired, or that fund shut down\r\n    // - remove order from tracking array\r\n    // - cancel order on exchange\r\n    /// @notice Cancels orders that were not expected to settle immediately\r\n    /// @param targetExchange Address of the exchange\r\n    /// @param orderAddresses [2] Order maker asset\r\n    /// @param identifier Order ID on the exchange\r\n    function cancelOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        pre_cond(Fund(address(this)).owner() == msg.sender ||\r\n                 Fund(address(this)).isShutDown()          ||\r\n                 Fund(address(this)).orderExpired(targetExchange, orderAddresses[2])\r\n        )\r\n    {\r\n        require(uint(identifier) != 0);\r\n\r\n        var (, makerAsset, ,) = MatchingMarket(targetExchange).getOffer(uint(identifier));\r\n\r\n        require(address(makerAsset) == orderAddresses[2]); // ensure we are checking correct asset\r\n\r\n        Fund(address(this)).removeOpenMakeOrder(targetExchange, orderAddresses[2]);\r\n        MatchingMarket(targetExchange).cancel(\r\n            uint(identifier)\r\n        );\r\n        Fund(address(this)).orderUpdateHook(\r\n            targetExchange,\r\n            bytes32(identifier),\r\n            Fund.UpdateType.cancel,\r\n            [address(0), address(0)],\r\n            [uint(0), uint(0), uint(0)]\r\n        );\r\n    }\r\n\r\n    // VIEW METHODS\r\n\r\n    // TODO: delete this function if possible\r\n    function getLastOrderId(address targetExchange)\r\n        view\r\n        returns (uint)\r\n    {\r\n        return MatchingMarket(targetExchange).last_offer_id();\r\n    }\r\n\r\n    // TODO: delete this function if possible\r\n    function getOrder(address targetExchange, uint id)\r\n        view\r\n        returns (address, address, uint, uint)\r\n    {\r\n        var (\r\n            sellQuantity,\r\n            sellAsset,\r\n            buyQuantity,\r\n            buyAsset\r\n        ) = MatchingMarket(targetExchange).getOffer(id);\r\n        return (\r\n            address(sellAsset),\r\n            address(buyAsset),\r\n            sellQuantity,\r\n            buyQuantity\r\n        );\r\n    }\r\n\r\n    //  INTERNAL METHODS\r\n\r\n    /// @dev needed to avoid stack too deep error\r\n    function makeOrderPermitted(\r\n        uint makerQuantity,\r\n        ERC20 makerAsset,\r\n        uint takerQuantity,\r\n        ERC20 takerAsset\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(takerAsset != address(this) && makerAsset != address(this));\r\n        var (pricefeed, , riskmgmt) = Fund(address(this)).modules();\r\n        require(pricefeed.existsPriceOnAssetPair(makerAsset, takerAsset));\r\n        var (isRecent, referencePrice, ) = pricefeed.getReferencePriceInfo(makerAsset, takerAsset);\r\n        require(isRecent);\r\n        uint orderPrice = pricefeed.getOrderPriceInfo(\r\n            makerAsset,\r\n            takerAsset,\r\n            makerQuantity,\r\n            takerQuantity\r\n        );\r\n        return(\r\n            riskmgmt.isMakePermitted(\r\n                orderPrice,\r\n                referencePrice,\r\n                makerAsset,\r\n                takerAsset,\r\n                makerQuantity,\r\n                takerQuantity\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev needed to avoid stack too deep error\r\n    function takeOrderPermitted(\r\n        uint takerQuantity,\r\n        ERC20 takerAsset,\r\n        uint makerQuantity,\r\n        ERC20 makerAsset\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        var (pricefeed, , riskmgmt) = Fund(address(this)).modules();\r\n        var (isRecent, referencePrice, ) = pricefeed.getReferencePriceInfo(takerAsset, makerAsset);\r\n        require(isRecent);\r\n        uint orderPrice = pricefeed.getOrderPriceInfo(\r\n            takerAsset,\r\n            makerAsset,\r\n            takerQuantity,\r\n            makerQuantity\r\n        );\r\n        return(\r\n            riskmgmt.isTakePermitted(\r\n                orderPrice,\r\n                referencePrice,\r\n                takerAsset,\r\n                makerAsset,\r\n                takerQuantity,\r\n                makerQuantity\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\ncontract ERC20Events {\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n}\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address guy) public view returns (uint);\r\n    function allowance(address src, address guy) public view returns (uint);\r\n\r\n    function approve(address guy, uint wad) public returns (bool);\r\n    function transfer(address dst, uint wad) public returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint wad\r\n    ) public returns (bool);\r\n}\r\n\r\ncontract EventfulMarket {\r\n    event LogItemUpdate(uint id);\r\n    event LogTrade(uint pay_amt, address indexed pay_gem,\r\n                   uint buy_amt, address indexed buy_gem);\r\n\r\n                   event LogMake(\r\n                       bytes32  indexed  id,\r\n                       bytes32  indexed  pair,\r\n                       address  indexed  maker,\r\n                       ERC20             pay_gem,\r\n                       ERC20             buy_gem,\r\n                       uint128           pay_amt,\r\n                       uint128           buy_amt,\r\n                       uint64            timestamp\r\n                   );\r\n\r\n                   event LogBump(\r\n                       bytes32  indexed  id,\r\n                       bytes32  indexed  pair,\r\n                       address  indexed  maker,\r\n                       ERC20             pay_gem,\r\n                       ERC20             buy_gem,\r\n                       uint128           pay_amt,\r\n                       uint128           buy_amt,\r\n                       uint64            timestamp\r\n                   );\r\n\r\n                   event LogTake(\r\n                       bytes32           id,\r\n                       bytes32  indexed  pair,\r\n                       address  indexed  maker,\r\n                       ERC20             pay_gem,\r\n                       ERC20             buy_gem,\r\n                       address  indexed  taker,\r\n                       uint128           take_amt,\r\n                       uint128           give_amt,\r\n                       uint64            timestamp\r\n                   );\r\n\r\n                   event LogKill(\r\n                       bytes32  indexed  id,\r\n                       bytes32  indexed  pair,\r\n                       address  indexed  maker,\r\n                       ERC20             pay_gem,\r\n                       ERC20             buy_gem,\r\n                       uint128           pay_amt,\r\n                       uint128           buy_amt,\r\n                       uint64            timestamp\r\n                   );\r\n}\r\n\r\ncontract SimpleMarket is EventfulMarket, DSMath {\r\n\r\n    uint public last_offer_id;\r\n\r\n    mapping (uint => OfferInfo) public offers;\r\n\r\n    bool locked;\r\n\r\n    struct OfferInfo {\r\n        uint     pay_amt;\r\n        ERC20    pay_gem;\r\n        uint     buy_amt;\r\n        ERC20    buy_gem;\r\n        address  owner;\r\n        uint64   timestamp;\r\n    }\r\n\r\n    modifier can_buy(uint id) {\r\n        require(isActive(id));\r\n        _;\r\n    }\r\n\r\n    modifier can_cancel(uint id) {\r\n        require(isActive(id));\r\n        require(getOwner(id) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _;\r\n    }\r\n\r\n    modifier synchronized {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function isActive(uint id) public constant returns (bool active) {\r\n        return offers[id].timestamp > 0;\r\n    }\r\n\r\n    function getOwner(uint id) public constant returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n\r\n    function getOffer(uint id) public constant returns (uint, ERC20, uint, ERC20) {\r\n        var offer = offers[id];\r\n        return (offer.pay_amt, offer.pay_gem,\r\n                offer.buy_amt, offer.buy_gem);\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    function bump(bytes32 id_)\r\n    public\r\n    can_buy(uint256(id_))\r\n    {\r\n        var id = uint256(id_);\r\n        LogBump(\r\n            id_,\r\n            keccak256(offers[id].pay_gem, offers[id].buy_gem),\r\n            offers[id].owner,\r\n            offers[id].pay_gem,\r\n            offers[id].buy_gem,\r\n            uint128(offers[id].pay_amt),\r\n            uint128(offers[id].buy_amt),\r\n            offers[id].timestamp\r\n        );\r\n    }\r\n\r\n    // Accept given `quantity` of an offer. Transfers funds from caller to\r\n    // offer maker, and from market to caller.\r\n    function buy(uint id, uint quantity)\r\n    public\r\n    can_buy(id)\r\n    synchronized\r\n    returns (bool)\r\n    {\r\n        OfferInfo memory offer = offers[id];\r\n        uint spend = mul(quantity, offer.buy_amt) / offer.pay_amt;\r\n\r\n        require(uint128(spend) == spend);\r\n        require(uint128(quantity) == quantity);\r\n\r\n        // For backwards semantic compatibility.\r\n        if (quantity == 0 || spend == 0 ||\r\n            quantity > offer.pay_amt || spend > offer.buy_amt)\r\n            {\r\n                return false;\r\n            }\r\n\r\n            offers[id].pay_amt = sub(offer.pay_amt, quantity);\r\n            offers[id].buy_amt = sub(offer.buy_amt, spend);\r\n            require( offer.buy_gem.transferFrom(msg.sender, offer.owner, spend) );\r\n            require( offer.pay_gem.transfer(msg.sender, quantity) );\r\n\r\n            LogItemUpdate(id);\r\n            LogTake(\r\n                bytes32(id),\r\n                keccak256(offer.pay_gem, offer.buy_gem),\r\n                offer.owner,\r\n                offer.pay_gem,\r\n                offer.buy_gem,\r\n                msg.sender,\r\n                uint128(quantity),\r\n                uint128(spend),\r\n                uint64(now)\r\n            );\r\n            LogTrade(quantity, offer.pay_gem, spend, offer.buy_gem);\r\n\r\n            if (offers[id].pay_amt == 0) {\r\n                delete offers[id];\r\n            }\r\n\r\n            return true;\r\n    }\r\n\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel(uint id)\r\n    public\r\n    can_cancel(id)\r\n    synchronized\r\n    returns (bool success)\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        require( offer.pay_gem.transfer(offer.owner, offer.pay_amt) );\r\n\r\n        LogItemUpdate(id);\r\n        LogKill(\r\n            bytes32(id),\r\n            keccak256(offer.pay_gem, offer.buy_gem),\r\n            offer.owner,\r\n            offer.pay_gem,\r\n            offer.buy_gem,\r\n            uint128(offer.pay_amt),\r\n            uint128(offer.buy_amt),\r\n            uint64(now)\r\n        );\r\n\r\n        success = true;\r\n    }\r\n\r\n    function kill(bytes32 id)\r\n    public\r\n    {\r\n        require(cancel(uint256(id)));\r\n    }\r\n\r\n    function make(\r\n        ERC20    pay_gem,\r\n        ERC20    buy_gem,\r\n        uint128  pay_amt,\r\n        uint128  buy_amt\r\n    )\r\n    public\r\n    returns (bytes32 id)\r\n    {\r\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer(uint pay_amt, ERC20 pay_gem, uint buy_amt, ERC20 buy_gem)\r\n    public\r\n    can_offer\r\n    synchronized\r\n    returns (uint id)\r\n    {\r\n        require(uint128(pay_amt) == pay_amt);\r\n        require(uint128(buy_amt) == buy_amt);\r\n        require(pay_amt > 0);\r\n        require(pay_gem != ERC20(0x0));\r\n        require(buy_amt > 0);\r\n        require(buy_gem != ERC20(0x0));\r\n        require(pay_gem != buy_gem);\r\n\r\n        OfferInfo memory info;\r\n        info.pay_amt = pay_amt;\r\n        info.pay_gem = pay_gem;\r\n        info.buy_amt = buy_amt;\r\n        info.buy_gem = buy_gem;\r\n        info.owner = msg.sender;\r\n        info.timestamp = uint64(now);\r\n        id = _next_id();\r\n        offers[id] = info;\r\n\r\n        require( pay_gem.transferFrom(msg.sender, this, pay_amt) );\r\n\r\n        LogItemUpdate(id);\r\n        LogMake(\r\n            bytes32(id),\r\n            keccak256(pay_gem, buy_gem),\r\n            msg.sender,\r\n            pay_gem,\r\n            buy_gem,\r\n            uint128(pay_amt),\r\n            uint128(buy_amt),\r\n            uint64(now)\r\n        );\r\n    }\r\n\r\n    function take(bytes32 id, uint128 maxTakeAmount)\r\n    public\r\n    {\r\n        require(buy(uint256(id), maxTakeAmount));\r\n    }\r\n\r\n    function _next_id()\r\n    internal\r\n    returns (uint)\r\n    {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n}\r\n\r\ncontract ExpiringMarket is DSAuth, SimpleMarket {\r\n    uint64 public close_time;\r\n    bool public stopped;\r\n\r\n    // after close_time has been reached, no new offers are allowed\r\n    modifier can_offer {\r\n        require(!isClosed());\r\n        _;\r\n    }\r\n\r\n    // after close, no new buys are allowed\r\n    modifier can_buy(uint id) {\r\n        require(isActive(id));\r\n        require(!isClosed());\r\n        _;\r\n    }\r\n\r\n    // after close, anyone can cancel an offer\r\n    modifier can_cancel(uint id) {\r\n        require(isActive(id));\r\n        require(isClosed() || (msg.sender == getOwner(id)));\r\n        _;\r\n    }\r\n\r\n    function ExpiringMarket(uint64 _close_time)\r\n    public\r\n    {\r\n        close_time = _close_time;\r\n    }\r\n\r\n    function isClosed() public constant returns (bool closed) {\r\n        return stopped || getTime() > close_time;\r\n    }\r\n\r\n    function getTime() public constant returns (uint64) {\r\n        return uint64(now);\r\n    }\r\n\r\n    function stop() public auth {\r\n        stopped = true;\r\n    }\r\n}\r\n\r\ncontract MatchingEvents {\r\n    event LogBuyEnabled(bool isEnabled);\r\n    event LogMinSell(address pay_gem, uint min_amount);\r\n    event LogMatchingEnabled(bool isEnabled);\r\n    event LogUnsortedOffer(uint id);\r\n    event LogSortedOffer(uint id);\r\n    event LogAddTokenPairWhitelist(ERC20 baseToken, ERC20 quoteToken);\r\n    event LogRemTokenPairWhitelist(ERC20 baseToken, ERC20 quoteToken);\r\n    event LogInsert(address keeper, uint id);\r\n    event LogDelete(address keeper, uint id);\r\n}\r\n\r\ncontract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote {\r\n    bool public buyEnabled = true;      //buy enabled\r\n    bool public matchingEnabled = true; //true: enable matching,\r\n    //false: revert to expiring market\r\n    struct sortInfo {\r\n        uint next;  //points to id of next higher offer\r\n        uint prev;  //points to id of previous lower offer\r\n        uint delb;  //the blocknumber where this entry was marked for delete\r\n    }\r\n    mapping(uint => sortInfo) public _rank;                     //doubly linked lists of sorted offer ids\r\n    mapping(address => mapping(address => uint)) public _best;  //id of the highest offer for a token pair\r\n    mapping(address => mapping(address => uint)) public _span;  //number of offers stored for token pair in sorted orderbook\r\n    mapping(address => uint) public _dust;                      //minimum sell amount for a token to avoid dust offers\r\n    mapping(uint => uint) public _near;         //next unsorted offer id\r\n    mapping(bytes32 => bool) public _menu;      //whitelist tracking which token pairs can be traded\r\n    uint _head;                                 //first unsorted offer id\r\n\r\n    //check if token pair is enabled\r\n    modifier isWhitelist(ERC20 buy_gem, ERC20 pay_gem) {\r\n        require(_menu[keccak256(buy_gem, pay_gem)] || _menu[keccak256(pay_gem, buy_gem)]);\r\n        _;\r\n    }\r\n\r\n    function MatchingMarket(uint64 close_time) ExpiringMarket(close_time) public {\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    function make(\r\n        ERC20    pay_gem,\r\n        ERC20    buy_gem,\r\n        uint128  pay_amt,\r\n        uint128  buy_amt\r\n    )\r\n    public\r\n    returns (bytes32)\r\n    {\r\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\r\n    }\r\n\r\n    function take(bytes32 id, uint128 maxTakeAmount) public {\r\n        require(buy(uint256(id), maxTakeAmount));\r\n    }\r\n\r\n    function kill(bytes32 id) public {\r\n        require(cancel(uint256(id)));\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    //\r\n    // If matching is enabled:\r\n    //     * creates new offer without putting it in\r\n    //       the sorted list.\r\n    //     * available to authorized contracts only!\r\n    //     * keepers should call insert(id,pos)\r\n    //       to put offer in the sorted list.\r\n    //\r\n    // If matching is disabled:\r\n    //     * calls expiring market's offer().\r\n    //     * available to everyone without authorization.\r\n    //     * no sorting is done.\r\n    //\r\n    function offer(\r\n        uint pay_amt,    //maker (ask) sell how much\r\n        ERC20 pay_gem,   //maker (ask) sell which token\r\n        uint buy_amt,    //taker (ask) buy how much\r\n        ERC20 buy_gem    //taker (ask) buy which token\r\n    )\r\n    public\r\n    isWhitelist(pay_gem, buy_gem)\r\n    /* NOT synchronized!!! */\r\n    returns (uint)\r\n    {\r\n        var fn = matchingEnabled ? _offeru : super.offer;\r\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer(\r\n        uint pay_amt,    //maker (ask) sell how much\r\n        ERC20 pay_gem,   //maker (ask) sell which token\r\n        uint buy_amt,    //maker (ask) buy how much\r\n        ERC20 buy_gem,   //maker (ask) buy which token\r\n        uint pos         //position to insert offer, 0 should be used if unknown\r\n    )\r\n    public\r\n    isWhitelist(pay_gem, buy_gem)\r\n    /*NOT synchronized!!! */\r\n    can_offer\r\n    returns (uint)\r\n    {\r\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, false);\r\n    }\r\n\r\n    function offer(\r\n        uint pay_amt,    //maker (ask) sell how much\r\n        ERC20 pay_gem,   //maker (ask) sell which token\r\n        uint buy_amt,    //maker (ask) buy how much\r\n        ERC20 buy_gem,   //maker (ask) buy which token\r\n        uint pos,        //position to insert offer, 0 should be used if unknown\r\n        bool rounding    //match \"close enough\" orders?\r\n    )\r\n    public\r\n    isWhitelist(pay_gem, buy_gem)\r\n    /*NOT synchronized!!! */\r\n    can_offer\r\n    returns (uint)\r\n    {\r\n        require(_dust[pay_gem] <= pay_amt);\r\n\r\n        if (matchingEnabled) {\r\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, rounding);\r\n        }\r\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\r\n    }\r\n\r\n    //Transfers funds from caller to offer maker, and from market to caller.\r\n    function buy(uint id, uint amount)\r\n    public\r\n    /*NOT synchronized!!! */\r\n    can_buy(id)\r\n    returns (bool)\r\n    {\r\n        var fn = matchingEnabled ? _buys : super.buy;\r\n        return fn(id, amount);\r\n    }\r\n\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel(uint id)\r\n    public\r\n    /*NOT synchronized!!! */\r\n    can_cancel(id)\r\n    returns (bool success)\r\n    {\r\n        if (matchingEnabled) {\r\n            if (isOfferSorted(id)) {\r\n                require(_unsort(id));\r\n            } else {\r\n                require(_hide(id));\r\n            }\r\n        }\r\n        return super.cancel(id);    //delete the offer.\r\n    }\r\n\r\n    //insert offer into the sorted list\r\n    //keepers need to use this function\r\n    function insert(\r\n        uint id,   //maker (ask) id\r\n        uint pos   //position to insert into\r\n    )\r\n    public\r\n    returns (bool)\r\n    {\r\n        require(!isOfferSorted(id));    //make sure offers[id] is not yet sorted\r\n        require(isActive(id));          //make sure offers[id] is active\r\n\r\n        _hide(id);                      //remove offer from unsorted offers list\r\n        _sort(id, pos);                 //put offer into the sorted offers list\r\n        LogInsert(msg.sender, id);\r\n        return true;\r\n    }\r\n\r\n    //deletes _rank [id]\r\n    //  Function should be called by keepers.\r\n    function del_rank(uint id)\r\n    public\r\n    returns (bool)\r\n    {\r\n        require(!isActive(id) && _rank[id].delb != 0 && _rank[id].delb < block.number - 10);\r\n        delete _rank[id];\r\n        LogDelete(msg.sender, id);\r\n        return true;\r\n    }\r\n\r\n    //returns true if token is succesfully added to whitelist\r\n    //  Function is used to add a token pair to the whitelist\r\n    //  All incoming offers are checked against the whitelist.\r\n    function addTokenPairWhitelist(\r\n        ERC20 baseToken,\r\n        ERC20 quoteToken\r\n    )\r\n    public\r\n    auth\r\n    note\r\n    returns (bool)\r\n    {\r\n        require(!isTokenPairWhitelisted(baseToken, quoteToken));\r\n        require(address(baseToken) != 0x0 && address(quoteToken) != 0x0);\r\n\r\n        _menu[keccak256(baseToken, quoteToken)] = true;\r\n        LogAddTokenPairWhitelist(baseToken, quoteToken);\r\n        return true;\r\n    }\r\n\r\n    //returns true if token is successfully removed from whitelist\r\n    //  Function is used to remove a token pair from the whitelist.\r\n    //  All incoming offers are checked against the whitelist.\r\n    function remTokenPairWhitelist(\r\n        ERC20 baseToken,\r\n        ERC20 quoteToken\r\n    )\r\n    public\r\n    auth\r\n    note\r\n    returns (bool)\r\n    {\r\n        require(isTokenPairWhitelisted(baseToken, quoteToken));\r\n\r\n        delete _menu[keccak256(baseToken, quoteToken)];\r\n        delete _menu[keccak256(quoteToken, baseToken)];\r\n        LogRemTokenPairWhitelist(baseToken, quoteToken);\r\n        return true;\r\n    }\r\n\r\n    function isTokenPairWhitelisted(\r\n        ERC20 baseToken,\r\n        ERC20 quoteToken\r\n    )\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        return (_menu[keccak256(baseToken, quoteToken)] || _menu[keccak256(quoteToken, baseToken)]);\r\n    }\r\n\r\n    //set the minimum sell amount for a token\r\n    //    Function is used to avoid \"dust offers\" that have\r\n    //    very small amount of tokens to sell, and it would\r\n    //    cost more gas to accept the offer, than the value\r\n    //    of tokens received.\r\n    function setMinSell(\r\n        ERC20 pay_gem,     //token to assign minimum sell amount to\r\n        uint dust          //maker (ask) minimum sell amount\r\n    )\r\n    public\r\n    auth\r\n    note\r\n    returns (bool)\r\n    {\r\n        _dust[pay_gem] = dust;\r\n        LogMinSell(pay_gem, dust);\r\n        return true;\r\n    }\r\n\r\n    //returns the minimum sell amount for an offer\r\n    function getMinSell(\r\n        ERC20 pay_gem      //token for which minimum sell amount is queried\r\n    )\r\n    public\r\n    constant\r\n    returns (uint)\r\n    {\r\n        return _dust[pay_gem];\r\n    }\r\n\r\n    //set buy functionality enabled/disabled\r\n    function setBuyEnabled(bool buyEnabled_) public auth returns (bool) {\r\n        buyEnabled = buyEnabled_;\r\n        LogBuyEnabled(buyEnabled);\r\n        return true;\r\n    }\r\n\r\n    //set matching enabled/disabled\r\n    //    If matchingEnabled true(default), then inserted offers are matched.\r\n    //    Except the ones inserted by contracts, because those end up\r\n    //    in the unsorted list of offers, that must be later sorted by\r\n    //    keepers using insert().\r\n    //    If matchingEnabled is false then MatchingMarket is reverted to ExpiringMarket,\r\n    //    and matching is not done, and sorted lists are disabled.\r\n    function setMatchingEnabled(bool matchingEnabled_) public auth returns (bool) {\r\n        matchingEnabled = matchingEnabled_;\r\n        LogMatchingEnabled(matchingEnabled);\r\n        return true;\r\n    }\r\n\r\n    //return the best offer for a token pair\r\n    //      the best offer is the lowest one if it's an ask,\r\n    //      and highest one if it's a bid offer\r\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem) public constant returns(uint) {\r\n        return _best[sell_gem][buy_gem];\r\n    }\r\n\r\n    //return the next worse offer in the sorted list\r\n    //      the worse offer is the higher one if its an ask,\r\n    //      a lower one if its a bid offer,\r\n    //      and in both cases the newer one if they're equal.\r\n    function getWorseOffer(uint id) public constant returns(uint) {\r\n        return _rank[id].prev;\r\n    }\r\n\r\n    //return the next better offer in the sorted list\r\n    //      the better offer is in the lower priced one if its an ask,\r\n    //      the next higher priced one if its a bid offer\r\n    //      and in both cases the older one if they're equal.\r\n    function getBetterOffer(uint id) public constant returns(uint) {\r\n\r\n        return _rank[id].next;\r\n    }\r\n\r\n    //return the amount of better offers for a token pair\r\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem) public constant returns(uint) {\r\n        return _span[sell_gem][buy_gem];\r\n    }\r\n\r\n    //get the first unsorted offer that was inserted by a contract\r\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\r\n    //      Their offers get put in the unsorted list of offers.\r\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\r\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\r\n    function getFirstUnsortedOffer() public constant returns(uint) {\r\n        return _head;\r\n    }\r\n\r\n    //get the next unsorted offer\r\n    //      Can be used to cycle through all the unsorted offers.\r\n    function getNextUnsortedOffer(uint id) public constant returns(uint) {\r\n        return _near[id];\r\n    }\r\n\r\n    function isOfferSorted(uint id) public constant returns(bool) {\r\n        return _rank[id].next != 0\r\n            || _rank[id].prev != 0\r\n                || _best[offers[id].pay_gem][offers[id].buy_gem] == id;\r\n    }\r\n\r\n    function sellAllAmount(ERC20 pay_gem, uint pay_amt, ERC20 buy_gem, uint min_fill_amount)\r\n    public\r\n    returns (uint fill_amt)\r\n    {\r\n        uint offerId;\r\n        while (pay_amt > 0) {                           //while there is amount to sell\r\n            offerId = getBestOffer(buy_gem, pay_gem);   //Get the best offer for the token pair\r\n            require(offerId != 0);                      //Fails if there are not more offers\r\n\r\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\r\n            if (pay_amt * 1 ether < wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) {\r\n                break;                                  //We consider that all amount is sold\r\n            }\r\n            if (pay_amt >= offers[offerId].buy_amt) {                       //If amount to sell is higher or equal than current offer amount to buy\r\n                fill_amt = add(fill_amt, offers[offerId].pay_amt);          //Add amount bought to acumulator\r\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt);            //Decrease amount to sell\r\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt));   //We take the whole offer\r\n            } else { // if lower\r\n                var baux = rmul(pay_amt * 10 ** 9, rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) / 10 ** 9;\r\n                fill_amt = add(fill_amt, baux);         //Add amount bought to acumulator\r\n                take(bytes32(offerId), uint128(baux));  //We take the portion of the offer that we need\r\n                pay_amt = 0;                            //All amount is sold\r\n            }\r\n        }\r\n        require(fill_amt >= min_fill_amount);\r\n    }\r\n\r\n    function buyAllAmount(ERC20 buy_gem, uint buy_amt, ERC20 pay_gem, uint max_fill_amount)\r\n    public\r\n    returns (uint fill_amt)\r\n    {\r\n        uint offerId;\r\n        while (buy_amt > 0) {                           //Meanwhile there is amount to buy\r\n            offerId = getBestOffer(buy_gem, pay_gem);   //Get the best offer for the token pair\r\n            require(offerId != 0);\r\n\r\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\r\n            if (buy_amt * 1 ether < wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) {\r\n                break;                                  //We consider that all amount is sold\r\n            }\r\n            if (buy_amt >= offers[offerId].pay_amt) {                       //If amount to buy is higher or equal than current offer amount to sell\r\n                fill_amt = add(fill_amt, offers[offerId].buy_amt);          //Add amount sold to acumulator\r\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt);            //Decrease amount to buy\r\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt));   //We take the whole offer\r\n            } else {                                                        //if lower\r\n                fill_amt = add(fill_amt, rmul(buy_amt * 10 ** 9, rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) / 10 ** 9); //Add amount sold to acumulator\r\n                take(bytes32(offerId), uint128(buy_amt));                   //We take the portion of the offer that we need\r\n                buy_amt = 0;                                                //All amount is bought\r\n            }\r\n        }\r\n        require(fill_amt <= max_fill_amount);\r\n    }\r\n\r\n    function getBuyAmount(ERC20 buy_gem, ERC20 pay_gem, uint pay_amt) public constant returns (uint fill_amt) {\r\n        var offerId = getBestOffer(buy_gem, pay_gem);           //Get best offer for the token pair\r\n        while (pay_amt > offers[offerId].buy_amt) {\r\n            fill_amt = add(fill_amt, offers[offerId].pay_amt);  //Add amount to buy accumulator\r\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt);    //Decrease amount to pay\r\n            if (pay_amt > 0) {                                  //If we still need more offers\r\n                offerId = getWorseOffer(offerId);               //We look for the next best offer\r\n                require(offerId != 0);                          //Fails if there are not enough offers to complete\r\n            }\r\n        }\r\n        fill_amt = add(fill_amt, rmul(pay_amt * 10 ** 9, rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) / 10 ** 9); //Add proportional amount of last offer to buy accumulator\r\n    }\r\n\r\n    function getPayAmount(ERC20 pay_gem, ERC20 buy_gem, uint buy_amt) public constant returns (uint fill_amt) {\r\n        var offerId = getBestOffer(buy_gem, pay_gem);           //Get best offer for the token pair\r\n        while (buy_amt > offers[offerId].pay_amt) {\r\n            fill_amt = add(fill_amt, offers[offerId].buy_amt);  //Add amount to pay accumulator\r\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt);    //Decrease amount to buy\r\n            if (buy_amt > 0) {                                  //If we still need more offers\r\n                offerId = getWorseOffer(offerId);               //We look for the next best offer\r\n                require(offerId != 0);                          //Fails if there are not enough offers to complete\r\n            }\r\n        }\r\n        fill_amt = add(fill_amt, rmul(buy_amt * 10 ** 9, rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) / 10 ** 9); //Add proportional amount of last offer to pay accumulator\r\n    }\r\n\r\n    // ---- Internal Functions ---- //\r\n\r\n    function _buys(uint id, uint amount)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        require(buyEnabled);\r\n\r\n        if (amount == offers[id].pay_amt && isOfferSorted(id)) {\r\n            //offers[id] must be removed from sorted list because all of it is bought\r\n            _unsort(id);\r\n        }\r\n        require(super.buy(id, amount));\r\n        return true;\r\n    }\r\n\r\n    //find the id of the next higher offer after offers[id]\r\n    function _find(uint id)\r\n    internal\r\n    view\r\n    returns (uint)\r\n    {\r\n        require( id > 0 );\r\n\r\n        address buy_gem = address(offers[id].buy_gem);\r\n        address pay_gem = address(offers[id].pay_gem);\r\n        uint top = _best[pay_gem][buy_gem];\r\n        uint old_top = 0;\r\n\r\n        // Find the larger-than-id order whose successor is less-than-id.\r\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\r\n            old_top = top;\r\n            top = _rank[top].prev;\r\n        }\r\n        return old_top;\r\n    }\r\n\r\n    //find the id of the next higher offer after offers[id]\r\n    function _findpos(uint id, uint pos)\r\n    internal\r\n    view\r\n    returns (uint)\r\n    {\r\n        require(id > 0);\r\n\r\n        // Look for an active order.\r\n        while (pos != 0 && !isActive(pos)) {\r\n            pos = _rank[pos].prev;\r\n        }\r\n\r\n        if (pos == 0) {\r\n            //if we got to the end of list without a single active offer\r\n            return _find(id);\r\n\r\n        } else {\r\n            // if we did find a nearby active offer\r\n            // Walk the order book down from there...\r\n            if(_isPricedLtOrEq(id, pos)) {\r\n                uint old_pos;\r\n\r\n                // Guaranteed to run at least once because of\r\n                // the prior if statements.\r\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\r\n                    old_pos = pos;\r\n                    pos = _rank[pos].prev;\r\n                }\r\n                return old_pos;\r\n\r\n                // ...or walk it up.\r\n            } else {\r\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\r\n                    pos = _rank[pos].next;\r\n                }\r\n                return pos;\r\n            }\r\n        }\r\n    }\r\n\r\n    //return true if offers[low] priced less than or equal to offers[high]\r\n    function _isPricedLtOrEq(\r\n        uint low,   //lower priced offer's id\r\n        uint high   //higher priced offer's id\r\n    )\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return mul(offers[low].buy_amt, offers[high].pay_amt)\r\n        >= mul(offers[high].buy_amt, offers[low].pay_amt);\r\n    }\r\n\r\n    //these variables are global only because of solidity local variable limit\r\n\r\n    //match offers with taker offer, and execute token transactions\r\n    function _matcho(\r\n        uint t_pay_amt,    //taker sell how much\r\n        ERC20 t_pay_gem,   //taker sell which token\r\n        uint t_buy_amt,    //taker buy how much\r\n        ERC20 t_buy_gem,   //taker buy which token\r\n        uint pos,          //position id\r\n        bool rounding      //match \"close enough\" orders?\r\n    )\r\n    internal\r\n    returns (uint id)\r\n    {\r\n        uint best_maker_id;    //highest maker id\r\n        uint t_buy_amt_old;    //taker buy how much saved\r\n        uint m_buy_amt;        //maker offer wants to buy this much token\r\n        uint m_pay_amt;        //maker offer wants to sell this much token\r\n\r\n        // there is at least one offer stored for token pair\r\n        while (_best[t_buy_gem][t_pay_gem] > 0) {\r\n            best_maker_id = _best[t_buy_gem][t_pay_gem];\r\n            m_buy_amt = offers[best_maker_id].buy_amt;\r\n            m_pay_amt = offers[best_maker_id].pay_amt;\r\n\r\n            // Ugly hack to work around rounding errors. Based on the idea that\r\n            // the furthest the amounts can stray from their \"true\" values is 1.\r\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\r\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\r\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\r\n            // c * d > a * b + a + b + c + d, we write...\r\n            if (mul(m_buy_amt, t_buy_amt) > mul(t_pay_amt, m_pay_amt) +\r\n                (rounding ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt : 0))\r\n                {\r\n                    break;\r\n                }\r\n                // ^ The `rounding` parameter is a compromise borne of a couple days\r\n                // of discussion.\r\n\r\n                buy(best_maker_id, min(m_pay_amt, t_buy_amt));\r\n                t_buy_amt_old = t_buy_amt;\r\n                t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\r\n                t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\r\n\r\n                if (t_pay_amt == 0 || t_buy_amt == 0) {\r\n                    break;\r\n                }\r\n        }\r\n\r\n        if (t_buy_amt > 0 && t_pay_amt > 0) {\r\n            //new offer should be created\r\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\r\n            //insert offer into the sorted list\r\n            _sort(id, pos);\r\n        }\r\n    }\r\n\r\n    // Make a new offer without putting it in the sorted list.\r\n    // Takes funds from the caller into market escrow.\r\n    // ****Available to authorized contracts only!**********\r\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\r\n    function _offeru(\r\n        uint pay_amt,      //maker (ask) sell how much\r\n        ERC20 pay_gem,     //maker (ask) sell which token\r\n        uint buy_amt,      //maker (ask) buy how much\r\n        ERC20 buy_gem      //maker (ask) buy which token\r\n    )\r\n    internal\r\n    /*NOT synchronized!!! */\r\n    returns (uint id)\r\n    {\r\n        require(_dust[pay_gem] <= pay_amt);\r\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\r\n        _near[id] = _head;\r\n        _head = id;\r\n        LogUnsortedOffer(id);\r\n    }\r\n\r\n    //put offer into the sorted list\r\n    function _sort(\r\n        uint id,    //maker (ask) id\r\n        uint pos    //position to insert into\r\n    )\r\n    internal\r\n    {\r\n        require(isActive(id));\r\n\r\n        address buy_gem = address(offers[id].buy_gem);\r\n        address pay_gem = address(offers[id].pay_gem);\r\n        uint prev_id;                                      //maker (ask) id\r\n\r\n        if (pos == 0 || !isOfferSorted(pos)) {\r\n            pos = _find(id);\r\n        } else {\r\n            pos = _findpos(id, pos);\r\n\r\n            //if user has entered a `pos` that belongs to another currency pair\r\n            //we start from scratch\r\n            if(pos != 0 && (offers[pos].pay_gem != offers[id].pay_gem\r\n                || offers[pos].buy_gem != offers[id].buy_gem))\r\n            {\r\n                pos = 0;\r\n                pos=_find(id);\r\n            }\r\n        }\r\n\r\n\r\n        //requirement below is satisfied by statements above\r\n        //require(pos == 0 || isOfferSorted(pos));\r\n\r\n\r\n        if (pos != 0) {                                    //offers[id] is not the highest offer\r\n            //requirement below is satisfied by statements above\r\n            //require(_isPricedLtOrEq(id, pos));\r\n            prev_id = _rank[pos].prev;\r\n            _rank[pos].prev = id;\r\n            _rank[id].next = pos;\r\n        } else {                                           //offers[id] is the highest offer\r\n            prev_id = _best[pay_gem][buy_gem];\r\n            _best[pay_gem][buy_gem] = id;\r\n        }\r\n\r\n        if (prev_id != 0) {                               //if lower offer does exist\r\n            //requirement below is satisfied by statements above\r\n            //require(!_isPricedLtOrEq(id, prev_id));\r\n            _rank[prev_id].next = id;\r\n            _rank[id].prev = prev_id;\r\n        }\r\n\r\n        _span[pay_gem][buy_gem]++;\r\n        LogSortedOffer(id);\r\n    }\r\n\r\n    // Remove offer from the sorted list (does not cancel offer)\r\n    function _unsort(\r\n        uint id    //id of maker (ask) offer to remove from sorted list\r\n    )\r\n    internal\r\n    returns (bool)\r\n    {\r\n        address buy_gem = address(offers[id].buy_gem);\r\n        address pay_gem = address(offers[id].pay_gem);\r\n        require(_span[pay_gem][buy_gem] > 0);\r\n\r\n        require(_rank[id].delb == 0 &&                    //assert id is in the sorted list\r\n                isOfferSorted(id));\r\n\r\n        if (id != _best[pay_gem][buy_gem]) {              // offers[id] is not the highest offer\r\n            require(_rank[_rank[id].next].prev == id);\r\n            _rank[_rank[id].next].prev = _rank[id].prev;\r\n        } else {                                          //offers[id] is the highest offer\r\n            _best[pay_gem][buy_gem] = _rank[id].prev;\r\n        }\r\n\r\n        if (_rank[id].prev != 0) {                        //offers[id] is not the lowest offer\r\n            require(_rank[_rank[id].prev].next == id);\r\n            _rank[_rank[id].prev].next = _rank[id].next;\r\n        }\r\n\r\n        _span[pay_gem][buy_gem]--;\r\n        _rank[id].delb = block.number;                    //mark _rank[id] for deletion\r\n        return true;\r\n    }\r\n\r\n    //Hide offer from the unsorted order book (does not cancel offer)\r\n    function _hide(\r\n        uint id     //id of maker offer to remove from unsorted list\r\n    )\r\n    internal\r\n    returns (bool)\r\n    {\r\n        uint uid = _head;               //id of an offer in unsorted offers list\r\n        uint pre = uid;                 //id of previous offer in unsorted offers list\r\n\r\n        require(!isOfferSorted(id));    //make sure offer id is not in sorted offers list\r\n\r\n        if (_head == id) {              //check if offer is first offer in unsorted offers list\r\n            _head = _near[id];          //set head to new first unsorted offer\r\n            _near[id] = 0;              //delete order from unsorted order list\r\n            return true;\r\n        }\r\n        while (uid > 0 && uid != id) {  //find offer in unsorted order list\r\n            pre = uid;\r\n            uid = _near[uid];\r\n        }\r\n        if (uid != id) {                //did not find offer id in unsorted offers list\r\n            return false;\r\n        }\r\n        _near[pre] = _near[id];         //set previous unsorted offer to point to offer after offer id\r\n        _near[id] = 0;                  //delete order from unsorted order list\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract CanonicalRegistrar is DSThing, DBC {\r\n\r\n    // TYPES\r\n\r\n    struct Asset {\r\n        bool exists; // True if asset is registered here\r\n        bytes32 name; // Human-readable name of the Asset as in ERC223 token standard\r\n        bytes8 symbol; // Human-readable symbol of the Asset as in ERC223 token standard\r\n        uint decimals; // Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\r\n        string url; // URL for additional information of Asset\r\n        string ipfsHash; // Same as url but for ipfs\r\n        address breakIn; // Break in contract on destination chain\r\n        address breakOut; // Break out contract on this chain; A way to leave\r\n        uint[] standards; // compliance with standards like ERC20, ERC223, ERC777, etc. (the uint is the standard number)\r\n        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->Asset` as much as possible. I.e. name same concepts with the same functionSignature.\r\n        uint price; // Price of asset quoted against `QUOTE_ASSET` * 10 ** decimals\r\n        uint timestamp; // Timestamp of last price update of this asset\r\n    }\r\n\r\n    struct Exchange {\r\n        bool exists;\r\n        address adapter; // adapter contract for this exchange\r\n        // One-time note: takesCustody is inverse case of isApproveOnly\r\n        bool takesCustody; // True in case of exchange implementation which requires  are approved when an order is made instead of transfer\r\n        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->ExchangeAdapter` as much as possible. I.e. name same concepts with the same functionSignature.\r\n    }\r\n    // TODO: populate each field here\r\n    // TODO: add whitelistFunction function\r\n\r\n    // FIELDS\r\n\r\n    // Methods fields\r\n    mapping (address => Asset) public assetInformation;\r\n    address[] public registeredAssets;\r\n\r\n    mapping (address => Exchange) public exchangeInformation;\r\n    address[] public registeredExchanges;\r\n\r\n    // METHODS\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @notice Registers an Asset information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofAsset is registered\r\n    /// @param ofAsset Address of asset to be registered\r\n    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputDecimals Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputUrl Url for extended information of the asset\r\n    /// @param inputIpfsHash Same as url but for ipfs\r\n    /// @param breakInBreakOut Address of break in and break out contracts on destination chain\r\n    /// @param inputStandards Integers of EIP standards this asset adheres to\r\n    /// @param inputFunctionSignatures Function signatures for whitelisted asset functions\r\n    function registerAsset(\r\n        address ofAsset,\r\n        bytes32 inputName,\r\n        bytes8 inputSymbol,\r\n        uint inputDecimals,\r\n        string inputUrl,\r\n        string inputIpfsHash,\r\n        address[2] breakInBreakOut,\r\n        uint[] inputStandards,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(!assetInformation[ofAsset].exists)\r\n    {\r\n        assetInformation[ofAsset].exists = true;\r\n        registeredAssets.push(ofAsset);\r\n        updateAsset(\r\n            ofAsset,\r\n            inputName,\r\n            inputSymbol,\r\n            inputDecimals,\r\n            inputUrl,\r\n            inputIpfsHash,\r\n            breakInBreakOut,\r\n            inputStandards,\r\n            inputFunctionSignatures\r\n        );\r\n        assert(assetInformation[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Register an exchange information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofExchange is registered\r\n    /// @param ofExchange Address of the exchange\r\n    /// @param ofExchangeAdapter Address of exchange adapter for this exchange\r\n    /// @param inputTakesCustody Whether this exchange takes custody of tokens before trading\r\n    /// @param inputFunctionSignatures Function signatures for whitelisted exchange functions\r\n    function registerExchange(\r\n        address ofExchange,\r\n        address ofExchangeAdapter,\r\n        bool inputTakesCustody,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(!exchangeInformation[ofExchange].exists)\r\n    {\r\n        exchangeInformation[ofExchange].exists = true;\r\n        registeredExchanges.push(ofExchange);\r\n        updateExchange(\r\n            ofExchange,\r\n            ofExchangeAdapter,\r\n            inputTakesCustody,\r\n            inputFunctionSignatures\r\n        );\r\n        assert(exchangeInformation[ofExchange].exists);\r\n    }\r\n\r\n    /// @notice Updates description information of a registered Asset\r\n    /// @dev Pre: Owner can change an existing entry\r\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\r\n    /// @param ofAsset Address of the asset to be updated\r\n    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputUrl Url for extended information of the asset\r\n    /// @param inputIpfsHash Same as url but for ipfs\r\n    function updateAsset(\r\n        address ofAsset,\r\n        bytes32 inputName,\r\n        bytes8 inputSymbol,\r\n        uint inputDecimals,\r\n        string inputUrl,\r\n        string inputIpfsHash,\r\n        address[2] ofBreakInBreakOut,\r\n        uint[] inputStandards,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(assetInformation[ofAsset].exists)\r\n    {\r\n        Asset asset = assetInformation[ofAsset];\r\n        asset.name = inputName;\r\n        asset.symbol = inputSymbol;\r\n        asset.decimals = inputDecimals;\r\n        asset.url = inputUrl;\r\n        asset.ipfsHash = inputIpfsHash;\r\n        asset.breakIn = ofBreakInBreakOut[0];\r\n        asset.breakOut = ofBreakInBreakOut[1];\r\n        asset.standards = inputStandards;\r\n        asset.functionSignatures = inputFunctionSignatures;\r\n    }\r\n\r\n    function updateExchange(\r\n        address ofExchange,\r\n        address ofExchangeAdapter,\r\n        bool inputTakesCustody,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(exchangeInformation[ofExchange].exists)\r\n    {\r\n        Exchange exchange = exchangeInformation[ofExchange];\r\n        exchange.adapter = ofExchangeAdapter;\r\n        exchange.takesCustody = inputTakesCustody;\r\n        exchange.functionSignatures = inputFunctionSignatures;\r\n    }\r\n\r\n    // TODO: check max size of array before remaking this becomes untenable\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofAsset address for which specific information is requested\r\n    function removeAsset(\r\n        address ofAsset,\r\n        uint assetIndex\r\n    )\r\n        auth\r\n        pre_cond(assetInformation[ofAsset].exists)\r\n    {\r\n        require(registeredAssets[assetIndex] == ofAsset);\r\n        delete assetInformation[ofAsset]; // Sets exists boolean to false\r\n        delete registeredAssets[assetIndex];\r\n        for (uint i = assetIndex; i < registeredAssets.length-1; i++) {\r\n            registeredAssets[i] = registeredAssets[i+1];\r\n        }\r\n        registeredAssets.length--;\r\n        assert(!assetInformation[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofExchange address for which specific information is requested\r\n    /// @param exchangeIndex index of the exchange in array\r\n    function removeExchange(\r\n        address ofExchange,\r\n        uint exchangeIndex\r\n    )\r\n        auth\r\n        pre_cond(exchangeInformation[ofExchange].exists)\r\n    {\r\n        require(registeredExchanges[exchangeIndex] == ofExchange);\r\n        delete exchangeInformation[ofExchange];\r\n        delete registeredExchanges[exchangeIndex];\r\n        for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {\r\n            registeredExchanges[i] = registeredExchanges[i+1];\r\n        }\r\n        registeredExchanges.length--;\r\n        assert(!exchangeInformation[ofExchange].exists);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // get asset specific information\r\n    function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }\r\n    function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }\r\n    function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }\r\n    function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }\r\n    function getRegisteredAssets() view returns (address[]) { return registeredAssets; }\r\n    function assetMethodIsAllowed(\r\n        address ofAsset, bytes4 querySignature\r\n    )\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == querySignature) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // get exchange-specific information\r\n    function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }\r\n    function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }\r\n    function getExchangeInformation(address ofExchange)\r\n        view\r\n        returns (address, bool)\r\n    {\r\n        Exchange exchange = exchangeInformation[ofExchange];\r\n        return (\r\n            exchange.adapter,\r\n            exchange.takesCustody\r\n        );\r\n    }\r\n    function getExchangeFunctionSignatures(address ofExchange)\r\n        view\r\n        returns (bytes4[])\r\n    {\r\n        return exchangeInformation[ofExchange].functionSignatures;\r\n    }\r\n    function exchangeMethodIsAllowed(\r\n        address ofExchange, bytes4 querySignature\r\n    )\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == querySignature) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\ninterface SimplePriceFeedInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PriceUpdated(bytes32 hash);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function update(address[] ofAssets, uint[] newPrices) external;\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get price feed operation specific information\r\n    function getQuoteAsset() view returns (address);\r\n    function getLastUpdateId() view returns (uint);\r\n    // Get asset specific information as updated in price feed\r\n    function getPrice(address ofAsset) view returns (uint price, uint timestamp);\r\n    function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);\r\n}\r\n\r\ncontract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {\r\n\r\n    // TYPES\r\n    struct Data {\r\n        uint price;\r\n        uint timestamp;\r\n    }\r\n\r\n    // FIELDS\r\n    mapping(address => Data) public assetsToPrices;\r\n\r\n    // Constructor fields\r\n    address public QUOTE_ASSET; // Asset of a portfolio against which all other assets are priced\r\n\r\n    // Contract-level variables\r\n    uint public updateId;        // Update counter for this pricefeed; used as a check during investment\r\n    CanonicalRegistrar public registrar;\r\n    CanonicalPriceFeed public superFeed;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param ofRegistrar Address of canonical registrar\r\n    /// @param ofSuperFeed Address of superfeed\r\n    function SimplePriceFeed(\r\n        address ofRegistrar,\r\n        address ofQuoteAsset,\r\n        address ofSuperFeed\r\n    ) {\r\n        registrar = CanonicalRegistrar(ofRegistrar);\r\n        QUOTE_ASSET = ofQuoteAsset;\r\n        superFeed = CanonicalPriceFeed(ofSuperFeed);\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    /// @param newPrices list of prices for each of the assets\r\n    function update(address[] ofAssets, uint[] newPrices)\r\n        external\r\n        auth\r\n    {\r\n        _updatePrices(ofAssets, newPrices);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get pricefeed specific information\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    /**\r\n    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\r\n    @dev Asset has been registered\r\n    @param ofAsset Asset for which price should be returned\r\n    @return {\r\n      \"price\": \"Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers\",\r\n      \"timestamp\": \"When the asset's price was updated\"\r\n    }\r\n    */\r\n    function getPrice(address ofAsset)\r\n        view\r\n        returns (uint price, uint timestamp)\r\n    {\r\n        Data data = assetsToPrices[ofAsset];\r\n        return (data.price, data.timestamp);\r\n    }\r\n\r\n    /**\r\n    @notice Price of a registered asset in format (bool areRecent, uint[] prices, uint[] decimals)\r\n    @dev Convention for price formatting: mul(price, 10 ** decimal), to avoid floating numbers\r\n    @param ofAssets Assets for which prices should be returned\r\n    @return {\r\n        \"prices\":       \"Array of prices\",\r\n        \"timestamps\":   \"Array of timestamps\",\r\n    }\r\n    */\r\n    function getPrices(address[] ofAssets)\r\n        view\r\n        returns (uint[], uint[])\r\n    {\r\n        uint[] memory prices = new uint[](ofAssets.length);\r\n        uint[] memory timestamps = new uint[](ofAssets.length);\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            var (price, timestamp) = getPrice(ofAssets[i]);\r\n            prices[i] = price;\r\n            timestamps[i] = timestamp;\r\n        }\r\n        return (prices, timestamps);\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @dev Internal so that feeds inheriting this one are not obligated to have an exposed update(...) method, but can still perform updates\r\n    function _updatePrices(address[] ofAssets, uint[] newPrices)\r\n        internal\r\n        pre_cond(ofAssets.length == newPrices.length)\r\n    {\r\n        updateId++;\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            require(registrar.assetIsRegistered(ofAssets[i]));\r\n            require(assetsToPrices[ofAssets[i]].timestamp != now); // prevent two updates in one block\r\n            assetsToPrices[ofAssets[i]].timestamp = now;\r\n            assetsToPrices[ofAssets[i]].price = newPrices[i];\r\n        }\r\n        emit PriceUpdated(keccak256(ofAssets, newPrices));\r\n    }\r\n}\r\n\r\ncontract StakingPriceFeed is SimplePriceFeed {\r\n\r\n    OperatorStaking public stakingContract;\r\n    AssetInterface public stakingToken;\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param ofRegistrar Address of canonical registrar\r\n    /// @param ofSuperFeed Address of superfeed\r\n    function StakingPriceFeed(\r\n        address ofRegistrar,\r\n        address ofQuoteAsset,\r\n        address ofSuperFeed\r\n    )\r\n        SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)\r\n    {\r\n        stakingContract = OperatorStaking(ofSuperFeed); // canonical feed *is* staking contract\r\n        stakingToken = AssetInterface(stakingContract.stakingToken());\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @param amount Number of tokens to stake for this feed\r\n    /// @param data Data may be needed for some future applications (can be empty for now)\r\n    function depositStake(uint amount, bytes data)\r\n        external\r\n        auth\r\n    {\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n        require(stakingToken.approve(stakingContract, amount));\r\n        stakingContract.stake(amount, data);\r\n    }\r\n\r\n    /// @param amount Number of tokens to unstake for this feed\r\n    /// @param data Data may be needed for some future applications (can be empty for now)\r\n    function unstake(uint amount, bytes data) {\r\n        stakingContract.unstake(amount, data);\r\n    }\r\n\r\n    function withdrawStake()\r\n        external\r\n        auth\r\n    {\r\n        uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));\r\n        stakingContract.withdrawStake();\r\n        require(stakingToken.transfer(msg.sender, amountToWithdraw));\r\n    }\r\n}\r\n\r\ninterface RiskMgmtInterface {\r\n\r\n    // METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks if the makeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If makeOrder is permitted\r\n    function isMakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks if the takeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If takeOrder is permitted\r\n    function isTakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ncontract OperatorStaking is DBC {\r\n\r\n    // EVENTS\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event StakeBurned(address indexed user, uint256 amount, bytes data);\r\n\r\n    // TYPES\r\n\r\n    struct StakeData {\r\n        uint amount;\r\n        address staker;\r\n    }\r\n\r\n    // Circular linked list\r\n    struct Node {\r\n        StakeData data;\r\n        uint prev;\r\n        uint next;\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // INTERNAL FIELDS\r\n    Node[] internal stakeNodes; // Sorted circular linked list nodes containing stake data (Built on top https://programtheblockchain.com/posts/2018/03/30/storage-patterns-doubly-linked-list/)\r\n\r\n    // PUBLIC FIELDS\r\n    uint public minimumStake;\r\n    uint public numOperators;\r\n    uint public withdrawalDelay;\r\n    mapping (address => bool) public isRanked;\r\n    mapping (address => uint) public latestUnstakeTime;\r\n    mapping (address => uint) public stakeToWithdraw;\r\n    mapping (address => uint) public stakedAmounts;\r\n    uint public numStakers; // Current number of stakers (Needed because of array holes)\r\n    AssetInterface public stakingToken;\r\n\r\n    // TODO: consider renaming \"operator\" depending on how this is implemented\r\n    //  (i.e. is pricefeed staking itself?)\r\n    function OperatorStaking(\r\n        AssetInterface _stakingToken,\r\n        uint _minimumStake,\r\n        uint _numOperators,\r\n        uint _withdrawalDelay\r\n    )\r\n        public\r\n    {\r\n        require(address(_stakingToken) != address(0));\r\n        stakingToken = _stakingToken;\r\n        minimumStake = _minimumStake;\r\n        numOperators = _numOperators;\r\n        withdrawalDelay = _withdrawalDelay;\r\n        StakeData memory temp = StakeData({ amount: 0, staker: address(0) });\r\n        stakeNodes.push(Node(temp, 0, 0));\r\n    }\r\n\r\n    // METHODS : STAKING\r\n\r\n    function stake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n        pre_cond(amount >= minimumStake)\r\n    {\r\n        uint tailNodeId = stakeNodes[0].prev;\r\n        stakedAmounts[msg.sender] += amount;\r\n        updateStakerRanking(msg.sender);\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n\r\n    function unstake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n    {\r\n        uint preStake = stakedAmounts[msg.sender];\r\n        uint postStake = preStake - amount;\r\n        require(postStake >= minimumStake || postStake == 0);\r\n        require(stakedAmounts[msg.sender] >= amount);\r\n        latestUnstakeTime[msg.sender] = block.timestamp;\r\n        stakedAmounts[msg.sender] -= amount;\r\n        stakeToWithdraw[msg.sender] += amount;\r\n        updateStakerRanking(msg.sender);\r\n        emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);\r\n    }\r\n\r\n    function withdrawStake()\r\n        public\r\n        pre_cond(stakeToWithdraw[msg.sender] > 0)\r\n        pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)\r\n    {\r\n        uint amount = stakeToWithdraw[msg.sender];\r\n        stakeToWithdraw[msg.sender] = 0;\r\n        require(stakingToken.transfer(msg.sender, amount));\r\n    }\r\n\r\n    // VIEW FUNCTIONS\r\n\r\n    function isValidNode(uint id) view returns (bool) {\r\n        // 0 is a sentinel and therefore invalid.\r\n        // A valid node is the head or has a previous node.\r\n        return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);\r\n    }\r\n\r\n    function searchNode(address staker) view returns (uint) {\r\n        uint current = stakeNodes[0].next;\r\n        while (isValidNode(current)) {\r\n            if (staker == stakeNodes[current].data.staker) {\r\n                return current;\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function isOperator(address user) view returns (bool) {\r\n        address[] memory operators = getOperators();\r\n        for (uint i; i < operators.length; i++) {\r\n            if (operators[i] == user) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getOperators()\r\n        view\r\n        returns (address[])\r\n    {\r\n        uint arrLength = (numOperators > numStakers) ?\r\n            numStakers :\r\n            numOperators;\r\n        address[] memory operators = new address[](arrLength);\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < arrLength; i++) {\r\n            operators[i] = stakeNodes[current].data.staker;\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return operators;\r\n    }\r\n\r\n    function getStakersAndAmounts()\r\n        view\r\n        returns (address[], uint[])\r\n    {\r\n        address[] memory stakers = new address[](numStakers);\r\n        uint[] memory amounts = new uint[](numStakers);\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < numStakers; i++) {\r\n            stakers[i] = stakeNodes[current].data.staker;\r\n            amounts[i] = stakeNodes[current].data.amount;\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return (stakers, amounts);\r\n    }\r\n\r\n    function totalStakedFor(address user)\r\n        view\r\n        returns (uint)\r\n    {\r\n        return stakedAmounts[user];\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    // DOUBLY-LINKED LIST\r\n\r\n    function insertNodeSorted(uint amount, address staker) internal returns (uint) {\r\n        uint current = stakeNodes[0].next;\r\n        if (current == 0) return insertNodeAfter(0, amount, staker);\r\n        while (isValidNode(current)) {\r\n            if (amount > stakeNodes[current].data.amount) {\r\n                break;\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return insertNodeBefore(current, amount, staker);\r\n    }\r\n\r\n    function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {\r\n\r\n        // 0 is allowed here to insert at the beginning.\r\n        require(id == 0 || isValidNode(id));\r\n\r\n        Node storage node = stakeNodes[id];\r\n\r\n        stakeNodes.push(Node({\r\n            data: StakeData(amount, staker),\r\n            prev: id,\r\n            next: node.next\r\n        }));\r\n\r\n        newID = stakeNodes.length - 1;\r\n\r\n        stakeNodes[node.next].prev = newID;\r\n        node.next = newID;\r\n        numStakers++;\r\n    }\r\n\r\n    function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {\r\n        return insertNodeAfter(stakeNodes[id].prev, amount, staker);\r\n    }\r\n\r\n    function removeNode(uint id) internal {\r\n        require(isValidNode(id));\r\n\r\n        Node storage node = stakeNodes[id];\r\n\r\n        stakeNodes[node.next].prev = node.prev;\r\n        stakeNodes[node.prev].next = node.next;\r\n\r\n        delete stakeNodes[id];\r\n        numStakers--;\r\n    }\r\n\r\n    // UPDATING OPERATORS\r\n\r\n    function updateStakerRanking(address _staker) internal {\r\n        uint newStakedAmount = stakedAmounts[_staker];\r\n        if (newStakedAmount == 0) {\r\n            isRanked[_staker] = false;\r\n            removeStakerFromArray(_staker);\r\n        } else if (isRanked[_staker]) {\r\n            removeStakerFromArray(_staker);\r\n            insertNodeSorted(newStakedAmount, _staker);\r\n        } else {\r\n            isRanked[_staker] = true;\r\n            insertNodeSorted(newStakedAmount, _staker);\r\n        }\r\n    }\r\n\r\n    function removeStakerFromArray(address _staker) internal {\r\n        uint id = searchNode(_staker);\r\n        require(id > 0);\r\n        removeNode(id);\r\n    }\r\n\r\n}\r\n\r\ncontract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {\r\n\r\n    // EVENTS\r\n    event SetupPriceFeed(address ofPriceFeed);\r\n\r\n    struct HistoricalPrices {\r\n        address[] assets;\r\n        uint[] prices;\r\n        uint timestamp;\r\n    }\r\n\r\n    // FIELDS\r\n    bool public updatesAreAllowed = true;\r\n    uint public minimumPriceCount = 1;\r\n    uint public VALIDITY;\r\n    uint public INTERVAL;\r\n    mapping (address => bool) public isStakingFeed; // If the Staking Feed has been created through this contract\r\n    HistoricalPrices[] public priceHistory;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Define and register a quote asset against which all prices are measured/based against\r\n    /// @param ofStakingAsset Address of staking asset (may or may not be quoteAsset)\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param quoteAssetName Name of quote asset\r\n    /// @param quoteAssetSymbol Symbol for quote asset\r\n    /// @param quoteAssetDecimals Decimal places for quote asset\r\n    /// @param quoteAssetUrl URL related to quote asset\r\n    /// @param quoteAssetIpfsHash IPFS hash associated with quote asset\r\n    /// @param quoteAssetBreakInBreakOut Break-in/break-out for quote asset on destination chain\r\n    /// @param quoteAssetStandards EIP standards quote asset adheres to\r\n    /// @param quoteAssetFunctionSignatures Whitelisted functions of quote asset contract\r\n    // /// @param interval Number of seconds between pricefeed updates (this interval is not enforced on-chain, but should be followed by the datafeed maintainer)\r\n    // /// @param validity Number of seconds that datafeed update information is valid for\r\n    /// @param ofGovernance Address of contract governing the Canonical PriceFeed\r\n    function CanonicalPriceFeed(\r\n        address ofStakingAsset,\r\n        address ofQuoteAsset, // Inital entry in asset registrar contract is Melon (QUOTE_ASSET)\r\n        bytes32 quoteAssetName,\r\n        bytes8 quoteAssetSymbol,\r\n        uint quoteAssetDecimals,\r\n        string quoteAssetUrl,\r\n        string quoteAssetIpfsHash,\r\n        address[2] quoteAssetBreakInBreakOut,\r\n        uint[] quoteAssetStandards,\r\n        bytes4[] quoteAssetFunctionSignatures,\r\n        uint[2] updateInfo, // interval, validity\r\n        uint[3] stakingInfo, // minStake, numOperators, unstakeDelay\r\n        address ofGovernance\r\n    )\r\n        OperatorStaking(\r\n            AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]\r\n        )\r\n        SimplePriceFeed(address(this), ofQuoteAsset, address(0))\r\n    {\r\n        registerAsset(\r\n            ofQuoteAsset,\r\n            quoteAssetName,\r\n            quoteAssetSymbol,\r\n            quoteAssetDecimals,\r\n            quoteAssetUrl,\r\n            quoteAssetIpfsHash,\r\n            quoteAssetBreakInBreakOut,\r\n            quoteAssetStandards,\r\n            quoteAssetFunctionSignatures\r\n        );\r\n        INTERVAL = updateInfo[0];\r\n        VALIDITY = updateInfo[1];\r\n        setOwner(ofGovernance);\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @notice Create a new StakingPriceFeed\r\n    function setupStakingPriceFeed() external {\r\n        address ofStakingPriceFeed = new StakingPriceFeed(\r\n            address(this),\r\n            stakingToken,\r\n            address(this)\r\n        );\r\n        isStakingFeed[ofStakingPriceFeed] = true;\r\n        StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);\r\n        emit SetupPriceFeed(ofStakingPriceFeed);\r\n    }\r\n\r\n    /// @dev override inherited update function to prevent manual update from authority\r\n    function update() external { revert(); }\r\n\r\n    /// @dev Burn state for a pricefeed operator\r\n    /// @param user Address of pricefeed operator to burn the stake from\r\n    function burnStake(address user)\r\n        external\r\n        auth\r\n    {\r\n        uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);\r\n        stakedAmounts[user] = 0;\r\n        stakeToWithdraw[user] = 0;\r\n        updateStakerRanking(user);\r\n        emit StakeBurned(user, totalToBurn, \"\");\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    // STAKING\r\n\r\n    function stake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n        pre_cond(isStakingFeed[msg.sender])\r\n    {\r\n        OperatorStaking.stake(amount, data);\r\n    }\r\n\r\n    // function stakeFor(\r\n    //     address user,\r\n    //     uint amount,\r\n    //     bytes data\r\n    // )\r\n    //     public\r\n    //     pre_cond(isStakingFeed[user])\r\n    // {\r\n\r\n    //     OperatorStaking.stakeFor(user, amount, data);\r\n    // }\r\n\r\n    // AGGREGATION\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    function collectAndUpdate(address[] ofAssets)\r\n        public\r\n        auth\r\n        pre_cond(updatesAreAllowed)\r\n    {\r\n        uint[] memory newPrices = pricesToCommit(ofAssets);\r\n        priceHistory.push(\r\n            HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})\r\n        );\r\n        _updatePrices(ofAssets, newPrices);\r\n    }\r\n\r\n    function pricesToCommit(address[] ofAssets)\r\n        view\r\n        returns (uint[])\r\n    {\r\n        address[] memory operators = getOperators();\r\n        uint[] memory newPrices = new uint[](ofAssets.length);\r\n        for (uint i = 0; i < ofAssets.length; i++) {\r\n            uint[] memory assetPrices = new uint[](operators.length);\r\n            for (uint j = 0; j < operators.length; j++) {\r\n                SimplePriceFeed feed = SimplePriceFeed(operators[j]);\r\n                var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);\r\n                if (now > add(timestamp, VALIDITY)) {\r\n                    continue; // leaves a zero in the array (dealt with later)\r\n                }\r\n                assetPrices[j] = price;\r\n            }\r\n            newPrices[i] = medianize(assetPrices);\r\n        }\r\n        return newPrices;\r\n    }\r\n\r\n    /// @dev from MakerDao medianizer contract\r\n    function medianize(uint[] unsorted)\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint numValidEntries;\r\n        for (uint i = 0; i < unsorted.length; i++) {\r\n            if (unsorted[i] != 0) {\r\n                numValidEntries++;\r\n            }\r\n        }\r\n        if (numValidEntries < minimumPriceCount) {\r\n            revert();\r\n        }\r\n        uint counter;\r\n        uint[] memory out = new uint[](numValidEntries);\r\n        for (uint j = 0; j < unsorted.length; j++) {\r\n            uint item = unsorted[j];\r\n            if (item != 0) {    // skip zero (invalid) entries\r\n                if (counter == 0 || item >= out[counter - 1]) {\r\n                    out[counter] = item;  // item is larger than last in array (we are home)\r\n                } else {\r\n                    uint k = 0;\r\n                    while (item >= out[k]) {\r\n                        k++;  // get to where element belongs (between smaller and larger items)\r\n                    }\r\n                    for (uint l = counter; l > k; l--) {\r\n                        out[l] = out[l - 1];    // bump larger elements rightward to leave slot\r\n                    }\r\n                    out[k] = item;\r\n                }\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        uint value;\r\n        if (counter % 2 == 0) {\r\n            uint value1 = uint(out[(counter / 2) - 1]);\r\n            uint value2 = uint(out[(counter / 2)]);\r\n            value = add(value1, value2) / 2;\r\n        } else {\r\n            value = out[(counter - 1) / 2];\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }\r\n    function enableUpdates() auth { updatesAreAllowed = true; }\r\n    function disableUpdates() auth { updatesAreAllowed = false; }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // FEED INFORMATION\r\n\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getInterval() view returns (uint) { return INTERVAL; }\r\n    function getValidity() view returns (uint) { return VALIDITY; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    // PRICES\r\n\r\n    /// @notice Whether price of asset has been updated less than VALIDITY seconds ago\r\n    /// @param ofAsset Asset in registrar\r\n    /// @return isRecent Price information ofAsset is recent\r\n    function hasRecentPrice(address ofAsset)\r\n        view\r\n        pre_cond(assetIsRegistered(ofAsset))\r\n        returns (bool isRecent)\r\n    {\r\n        var ( , timestamp) = getPrice(ofAsset);\r\n        return (sub(now, timestamp) <= VALIDITY);\r\n    }\r\n\r\n    /// @notice Whether prices of assets have been updated less than VALIDITY seconds ago\r\n    /// @param ofAssets All assets in registrar\r\n    /// @return isRecent Price information ofAssets array is recent\r\n    function hasRecentPrices(address[] ofAssets)\r\n        view\r\n        returns (bool areRecent)\r\n    {\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            if (!hasRecentPrice(ofAssets[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getPriceInfo(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint price, uint assetDecimals)\r\n    {\r\n        isRecent = hasRecentPrice(ofAsset);\r\n        (price, ) = getPrice(ofAsset);\r\n        assetDecimals = getDecimals(ofAsset);\r\n    }\r\n\r\n    /**\r\n    @notice Gets inverted price of an asset\r\n    @dev Asset has been initialised and its price is non-zero\r\n    @dev Existing price ofAssets quoted in QUOTE_ASSET (convention)\r\n    @param ofAsset Asset for which inverted price should be return\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"invertedPrice\": \"Price based (instead of quoted) against QUOTE_ASSET\",\r\n        \"assetDecimals\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getInvertedPriceInfo(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint invertedPrice, uint assetDecimals)\r\n    {\r\n        uint inputPrice;\r\n        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);\r\n\r\n        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\r\n        uint quoteDecimals = getDecimals(QUOTE_ASSET);\r\n\r\n        return (\r\n            isRecent,\r\n            mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,\r\n            quoteDecimals   // TODO: check on this; shouldn't it be assetDecimals?\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice Gets reference price of an asset pair\r\n    @dev One of the address is equal to quote asset\r\n    @dev either ofBase == QUOTE_ASSET or ofQuote == QUOTE_ASSET\r\n    @param ofBase Address of base asset\r\n    @param ofQuote Address of quote asset\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"referencePrice\": \"Reference price\",\r\n        \"decimal\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getReferencePriceInfo(address ofBase, address ofQuote)\r\n        view\r\n        returns (bool isRecent, uint referencePrice, uint decimal)\r\n    {\r\n        if (getQuoteAsset() == ofQuote) {\r\n            (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);\r\n        } else if (getQuoteAsset() == ofBase) {\r\n            (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);\r\n        } else {\r\n            revert(); // no suitable reference price available\r\n        }\r\n    }\r\n\r\n    /// @notice Gets price of Order\r\n    /// @param sellAsset Address of the asset to be sold\r\n    /// @param buyAsset Address of the asset to be bought\r\n    /// @param sellQuantity Quantity in base units being sold of sellAsset\r\n    /// @param buyQuantity Quantity in base units being bought of buyAsset\r\n    /// @return orderPrice Price as determined by an order\r\n    function getOrderPriceInfo(\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        view\r\n        returns (uint orderPrice)\r\n    {\r\n        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\r\n    }\r\n\r\n    /// @notice Checks whether data exists for a given asset pair\r\n    /// @dev Prices are only upated against QUOTE_ASSET\r\n    /// @param sellAsset Asset for which check to be done if data exists\r\n    /// @param buyAsset Asset for which check to be done if data exists\r\n    /// @return Whether assets exist for given asset pair\r\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\r\n        view\r\n        returns (bool isExistent)\r\n    {\r\n        return\r\n            hasRecentPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            hasRecentPrice(buyAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) && // One asset must be QUOTE_ASSET\r\n            (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET); // Pair must consists of diffrent assets\r\n    }\r\n\r\n    /// @return Sparse array of addresses of owned pricefeeds\r\n    function getPriceFeedsByOwner(address _owner)\r\n        view\r\n        returns(address[])\r\n    {\r\n        address[] memory ofPriceFeeds = new address[](numStakers);\r\n        if (numStakers == 0) return ofPriceFeeds;\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < numStakers; i++) {\r\n            StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);\r\n            if (stakingFeed.owner() == _owner) {\r\n                ofPriceFeeds[i] = address(stakingFeed);\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return ofPriceFeeds;\r\n    }\r\n\r\n    function getHistoryLength() returns (uint) { return priceHistory.length; }\r\n\r\n    function getHistoryAt(uint id) returns (address[], uint[], uint) {\r\n        address[] memory assets = priceHistory[id].assets;\r\n        uint[] memory prices = priceHistory[id].prices;\r\n        uint timestamp = priceHistory[id].timestamp;\r\n        return (assets, prices, timestamp);\r\n    }\r\n}\r\n\r\ninterface VersionInterface {\r\n\r\n    // EVENTS\r\n\r\n    event FundUpdated(uint id);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function shutDown() external;\r\n\r\n    function setupFund(\r\n        bytes32 ofFundName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address[] ofExchanges,\r\n        address[] ofDefaultAssets,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n    function shutDownFund(address ofFund);\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getNativeAsset() view returns (address);\r\n    function getFundById(uint withId) view returns (address);\r\n    function getLastFundId() view returns (uint);\r\n    function getFundByManager(address ofManager) view returns (address);\r\n    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"},{\"name\":\"orderAddresses\",\"type\":\"address[5]\"},{\"name\":\"orderValues\",\"type\":\"uint256[8]\"},{\"name\":\"identifier\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"},{\"name\":\"orderAddresses\",\"type\":\"address[5]\"},{\"name\":\"orderValues\",\"type\":\"uint256[8]\"},{\"name\":\"identifier\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"makeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"}],\"name\":\"getLastOrderId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"},{\"name\":\"orderAddresses\",\"type\":\"address[5]\"},{\"name\":\"orderValues\",\"type\":\"uint256[8]\"},{\"name\":\"identifier\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"takeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MatchingMarketAdapter","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://87405f387e33db6336178b4a04405ca0dfc59ffcb1accdbbc4196e0b20414a27"}]}