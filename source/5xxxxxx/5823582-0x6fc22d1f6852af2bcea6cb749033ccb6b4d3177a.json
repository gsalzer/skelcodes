{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract owned {\r\n    address public owner;\r\n}\r\n\r\ncontract TokenERC20 {\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n}\r\n\r\ncontract BitSTDShares is owned, TokenERC20 {\r\n\r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n\r\n    mapping (address => bool) public frozenAccount;\r\n}\r\n\r\ncontract BitSTDData {\r\n    // Used to control data migration\r\n    bool public data_migration_control = true;\r\n    address public owner;\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    // An array of all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n    // The allowed address zhi value wei value is true\r\n    mapping (address => bool) public owners;\r\n    // Freeze address\r\n    mapping (address => bool) public frozenAccount;\r\n    BitSTDShares private bit;\r\n\r\n    constructor(address contractAddress) public {\r\n        bit = BitSTDShares(contractAddress);\r\n        owner = msg.sender;\r\n        name = bit.name();\r\n        symbol = bit.symbol();\r\n        decimals = bit.decimals();\r\n        sellPrice = bit.sellPrice();\r\n        buyPrice = bit.buyPrice();\r\n        totalSupply = bit.totalSupply();\r\n        balanceOf[msg.sender] = totalSupply;\r\n    }\r\n\r\n    modifier qualification {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // Move the super administrator\r\n    function transferAuthority(address newOwner) public {\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setBalanceOfAddr(address addr, uint256 value) qualification public {\r\n        balanceOf[addr] = value;\r\n    }\r\n\r\n    function setAllowance(address authorizer, address sender, uint256 value) qualification public {\r\n        allowance[authorizer][sender] = value;\r\n    }\r\n\r\n\r\n    function setFrozenAccount(address addr, bool value) qualification public {\r\n        frozenAccount[addr] = value;\r\n    }\r\n\r\n    function addTotalSupply(uint256 value) qualification public {\r\n        totalSupply = value;\r\n    }\r\n\r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public {\r\n        require(msg.sender == owner);\r\n        sellPrice = newSellPrice;\r\n        buyPrice = newBuyPrice;\r\n    }\r\n\r\n    // Old contract data\r\n    function getOldBalanceOf(address addr) constant  public returns(uint256) {\r\n       return bit.balanceOf(addr);\r\n    }\r\n   \r\n    \r\n    function getOldAllowance(address authorizer, address sender) constant  public returns(uint256) {\r\n        return bit.allowance(authorizer, sender);\r\n    }\r\n\r\n    function getOldFrozenAccount(address addr) constant public returns(bool) {\r\n        return bit.frozenAccount(addr);\r\n    }\r\n   \r\n}\r\n\r\n\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\ncontract BitSTDLogic {\r\n    address public owner;\r\n    // data layer\r\n\tBitSTDData private data;\r\n\r\n    constructor(address dataAddress) {\r\n        data = BitSTDData(dataAddress);\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    // Transfer logical layer authority\r\n    function transferAuthority(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n\tmodifier onlyOwner(){\r\n\t\trequire(msg.sender == owner);\r\n        _;\r\n\t}\r\n\t\r\n\t// Transfer data layer authority\r\n    function transferDataAuthority(address newOwner) onlyOwner public {\r\n        data.transferAuthority(newOwner);\r\n    }\r\n    function setData(address dataAddress)onlyOwner public {\r\n        data = BitSTDData(dataAddress);\r\n    }\r\n\r\n    // Old contract data\r\n    function getOldBalanceOf(address addr) constant public returns (uint256) {\r\n        return data.getOldBalanceOf(addr);\r\n    }\r\n\r\n\t/**\r\n\t * Internal transfers can only be invoked through this contract\r\n\t*/\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        uint256 f_value = balanceOf(_from);\r\n        uint256 t_value = balanceOf(_to);\r\n        // Prevents transmission to 0x0 address.Call to Burn ()\r\n        require(_to != 0x0);\r\n        // Check that the sender is adequate\r\n        require(f_value >= _value);\r\n        // Check the overflow\r\n        require(t_value + _value > t_value);\r\n        // Save it as a future assertion\r\n        uint previousBalances = f_value + t_value;\r\n        // Minus from the sender\r\n        setBalanceOf(_from, f_value - _value);\r\n        // Add to receiver\r\n        setBalanceOf(_to, t_value + _value);\r\n\r\n        // Assertions are used to use static analysis to detect errors in code.They should not fail\r\n        assert(balanceOf(_from) + balanceOf(_to) == previousBalances);\r\n\r\n    }\r\n    // data migration\r\n    function migration(address sender, address receiver) onlyOwner public returns (bool) {\r\n        require(sender != receiver);\r\n        bool result= false;\r\n        // Start data migration\r\n        // uint256 t_value = balanceOf(receiver);\r\n        uint256 _value = data.getOldBalanceOf(receiver);\r\n        //Transfer balance\r\n        if (data.balanceOf(receiver) == 0) {\r\n            if (_value > 0) {\r\n                _transfer(sender, receiver, _value);\r\n                result = true;\r\n            }\r\n        }\r\n        //Frozen account migration\r\n        if (data.getOldFrozenAccount(receiver)== true) {\r\n            if (data.frozenAccount(receiver)!= true) {\r\n                data.setFrozenAccount(receiver, true);\r\n            }\r\n        }\r\n        //End data migration\r\n        return result;\r\n    }\r\n\r\n    // Check the contract token\r\n    function balanceOf(address addr) constant public returns (uint256) {\r\n        return data.balanceOf(addr);\r\n    }\r\n\r\n    function name() constant public returns (string) {\r\n  \t   return data.name();\r\n  \t}\r\n\r\n  \tfunction symbol() constant public returns(string) {\r\n  \t   return data.symbol();\r\n  \t}\r\n\r\n  \tfunction decimals() constant public returns(uint8) {\r\n  \t   return data.decimals();\r\n  \t}\r\n\r\n  \tfunction totalSupply() constant public returns(uint256) {\r\n  \t   return data.totalSupply();\r\n  \t}\r\n\r\n  \tfunction allowance(address authorizer, address sender) constant public returns(uint256) {\r\n  \t   return data.allowance(authorizer, sender);\r\n  \t}\r\n\r\n  \tfunction sellPrice() constant public returns (uint256) {\r\n  \t   return data.sellPrice();\r\n  \t}\r\n\r\n  \tfunction buyPrice() constant public returns (uint256) {\r\n  \t   return data.buyPrice();\r\n  \t}\r\n\r\n  \tfunction frozenAccount(address addr) constant public returns(bool) {\r\n  \t   return data.frozenAccount(addr);\r\n  \t}\r\n\r\n    //Modify the contract\r\n    function setBalanceOf(address addr, uint256 value) onlyOwner public {\r\n        data.setBalanceOfAddr(addr, value);\r\n    }\r\n\r\n    /**\r\n     * Pass the token\r\n     * send a value token to your account\r\n    */\r\n    function transfer(address sender, address _to, uint256 _value) onlyOwner public returns (bool) {\r\n        _transfer(sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *Passing tokens from other addresses\r\n      *\r\n      * sends the value token to \"to\", representing \"from\"\r\n      *\r\n      * @param _from sender's address\r\n      * @param _to recipient's address\r\n      * @param _value number sent\r\n     */\r\n    function transferFrom(address _from, address sender, address _to, uint256 _value) onlyOwner public returns (bool success) {\r\n        uint256 a_value = data.allowance(_from, sender);\r\n        require(_value <=_value ); // Check allowance\r\n        data.setAllowance(_from, sender, a_value - _value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n     /**\r\n* set allowances for other addresses\r\n*\r\n* allow the \"spender\" to spend only the \"value\" card in your name\r\n*\r\n* @param _spender authorized address\r\n* @param _value they can spend the most money\r\n     */\r\n    function approve(address _spender, address sender, uint256 _value) onlyOwner public returns (bool success) {\r\n        data.setAllowance(sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Grant and notify other addresses\r\n       *\r\n       * allow \"spender\" to only mark \"value\" in your name and then write the contract on it.\r\n       *\r\n       * @param _spender authorized address\r\n       * @param _value they can spend the most money\r\n       * @param _extraData sends some additional information to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, address sender, address _contract, uint256 _value, bytes _extraData) onlyOwner public returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, sender, _value)) {\r\n            spender.receiveApproval(sender, _value, _contract, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n     /**\r\n     * Destroy the tokens,\r\n       *\r\n       * delete \"value\" tokens from the system\r\n       *\r\n       * param _value the amount of money to burn\r\n     */\r\n    function burn(address sender, uint256 _value) onlyOwner public returns (bool success) {\r\n        uint256 f_value = balanceOf(sender);\r\n        require(f_value >= _value);                 // Check that the sender is adequate\r\n        setBalanceOf(sender, f_value - _value);    // Minus from the sender\r\n        data.addTotalSupply(totalSupply() - _value);                      // Renewal aggregate supply\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other accounts\r\n       *\r\n       * delete \"value\" tokens from \"from\" in the system.\r\n       *\r\n       * @param _from the address of the sender\r\n       * param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, address sender, uint256 _value) onlyOwner public returns (bool success) {\r\n        uint256 f_value = balanceOf(sender);\r\n        uint256 a_value = data.allowance(_from, sender);\r\n        require(f_value >= _value);                             // Check that the target balance is adequate\r\n        require(_value <= a_value);                             // Check the allowance\r\n        setBalanceOf(_from, f_value - _value);                // Subtract from the goal balance\r\n        data.setAllowance(_from, sender, f_value - _value);  // Minus the sender's allowance\r\n        data.addTotalSupply(totalSupply() - _value);         // update totalSupply\r\n\r\n        return true;\r\n    }\r\n\r\n    //@ notifies you to create the mintedAmount token and send it to the target\r\n      // @param target address receiving token\r\n      // @param mintedAmount will receive the number of tokens\r\n    function mintToken(address target, address _contract, uint256 mintedAmount) onlyOwner public {\r\n        uint256 f_value = balanceOf(target);\r\n        setBalanceOf(target, f_value + mintedAmount);\r\n        data.addTotalSupply(totalSupply() + mintedAmount);\r\n\r\n    }\r\n\r\n    //Notice freezes the account to prevent \"target\" from sending and receiving tokens\r\n      // @param target address is frozen\r\n      // @param freezes or does not freeze\r\n    function freezeAccount(address target, bool freeze) onlyOwner public returns (bool) {\r\n        data.setFrozenAccount(target, freeze);\r\n        return true;\r\n\r\n    }\r\n\r\n    // Notice of purchase of tokens by sending ether\r\n    function buy(address _contract, address sender, uint256 value) payable public {\r\n        require(false);\r\n        uint amount = value / data.buyPrice();        // Calculate the purchase amount\r\n        _transfer(_contract, sender, amount);              // makes the transfers\r\n    }\r\n    // @notice to sell the amount token\r\n    // @param amount\r\n    function sell(address _contract, address sender, uint256 amount) public {\r\n        require(false);\r\n        require(address(_contract).balance >= amount * data.sellPrice());      // Check if there is enough ether in the contract\r\n        _transfer(sender, _contract, amount);              // makes the transfers\r\n        sender.transfer(amount * data.sellPrice());          // Shipping ether to the seller.This is important to avoid recursive attacks\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract BitSTDView {\r\n\r\n\tBitSTDLogic private logic;\r\n\taddress public owner;\r\n\r\n    // This creates a public event on the blockchain that notifies the customer\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    // This tells the customer how much money is being burned\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n\t//start Query data interface\r\n    function balanceOf(address add)constant  public returns (uint256) {\r\n\t    return logic.balanceOf(add);\r\n\t}\r\n\r\n\tfunction name() constant  public returns (string) {\r\n\t    return logic.name();\r\n\t}\r\n\r\n\tfunction symbol() constant  public returns (string) {\r\n\t    return logic.symbol();\r\n\t}\r\n\r\n\tfunction decimals() constant  public returns (uint8) {\r\n\t    return logic.decimals();\r\n\t}\r\n\r\n\tfunction totalSupply() constant  public returns (uint256) {\r\n\t    return logic.totalSupply();\r\n\t}\r\n\r\n\tfunction allowance(address authorizer, address sender) constant  public returns (uint256) {\r\n\t    return logic.allowance(authorizer, sender);\r\n\t}\r\n\r\n\tfunction sellPrice() constant  public returns (uint256) {\r\n\t    return logic.sellPrice();\r\n\t}\r\n\r\n\tfunction buyPrice() constant  public returns (uint256) {\r\n\t    return logic.buyPrice();\r\n\t}\r\n\r\n\tfunction frozenAccount(address addr) constant  public returns (bool) {\r\n\t    return logic.frozenAccount(addr);\r\n\t}\r\n\r\n\t//End Query data interface\r\n\r\n\t//initialize\r\n    constructor(address logicAddressr) public {\r\n        logic=BitSTDLogic(logicAddressr);\r\n        owner=msg.sender;\r\n    }\r\n\r\n    //start Authority and control\r\n    modifier onlyOwner(){\r\n\t\trequire(msg.sender == owner);\r\n        _;\r\n\t}\r\n\r\n\t//Update the address of the data and logic layer\r\n    function setBitSTD(address dataAddress,address logicAddressr) onlyOwner public{\r\n        logic=BitSTDLogic(logicAddressr);\r\n        logic.setData(dataAddress);\r\n    }\r\n\r\n    //Hand over the logical layer authority\r\n    function transferLogicAuthority(address newOwner) onlyOwner public{\r\n        logic.transferAuthority(newOwner);\r\n    }\r\n\r\n    //Hand over the data layer authority\r\n    function transferDataAuthority(address newOwner) onlyOwner public{\r\n        logic.transferDataAuthority(newOwner);\r\n    }\r\n\r\n    //Hand over the view layer authority\r\n    function transferAuthority(address newOwner) onlyOwner public{\r\n        owner=newOwner;\r\n    }\r\n    //End Authority and control\r\n\r\n    //data migration\r\n    function migration(address addr) public {\r\n        if (logic.migration(msg.sender, addr) == true) {\r\n            emit Transfer(msg.sender, addr,logic.getOldBalanceOf(addr));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n\tfunction transfer(address _to, uint256 _value) public {\r\n\t    if (logic.transfer(msg.sender, _to, _value) == true) {\r\n\t        emit Transfer(msg.sender, _to, _value);\r\n\t    }\r\n\t}\r\n\r\n\t/**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t    if (logic.transferFrom(_from, msg.sender, _to, _value) == true) {\r\n\t        emit Transfer(_from, _to, _value);\r\n\t        return true;\r\n\t    }\r\n\t}\r\n\r\n\t/**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t    return logic.approve( _spender, msg.sender,  _value);\r\n\t}\r\n\r\n\t/**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n\t    return logic.approveAndCall(_spender, msg.sender, this, _value, _extraData);\r\n\t}\r\n\r\n\t/**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t    if (logic.burn(msg.sender, _value) == true) {\r\n\t        emit Burn(msg.sender, _value);\r\n\t        return true;\r\n\t    }\r\n\t}\r\n\r\n\t/**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n\t    if (logic.burnFrom( _from, msg.sender, _value) == true) {\r\n\t        emit Burn(_from, _value);\r\n\t        return true;\r\n\t    }\r\n\t}\r\n\r\n\t/// @notice Create `mintedAmount` tokens and send it to `target`\r\n    /// @param target Address to receive the tokens\r\n    /// @param mintedAmount the amount of tokens it will receive\r\n\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n\t    logic.mintToken(target, this,  mintedAmount);\r\n\t    emit Transfer(0, this, mintedAmount);\r\n        emit Transfer(this, target, mintedAmount);\r\n\t}\r\n\r\n\t/// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n    /// @param target Address to be frozen\r\n    /// @param freeze either to freeze it or not\r\n\tfunction freezeAccount(address target, bool freeze) onlyOwner public {\r\n\t    if (logic.freezeAccount(target,  freeze) == true) {\r\n\t        emit FrozenFunds(target, freeze);\r\n\t    }\r\n\t}\r\n\r\n\t//The next two are buying and selling tokens\r\n\tfunction buy() payable public {\r\n\t    logic.buy(this, msg.sender, msg.value);\r\n\t}\r\n\r\n\tfunction sell(uint256 amount) public {\r\n\t    logic.sell(this,msg.sender, amount);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferDataAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataAddress\",\"type\":\"address\"},{\"name\":\"logicAddressr\",\"type\":\"address\"}],\"name\":\"setBitSTD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"migration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"add\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferLogicAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authorizer\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"logicAddressr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"BitSTDView","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002ff5695d66bf0ce704014c3f6bc37aa69635fea7","Library":"","SwarmSource":"bzzr://17455e7f08344d158e6f8a6f8331e5d6e2e483ecdf75da42a8a79eb36e8db951"}]}