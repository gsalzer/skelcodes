{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 interface\r\n * @dev see https://github.com/ethereum/eips/issues/721\r\n */\r\ncontract ERC721 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function transfer(address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function takeOwnership(uint256 _tokenId) public;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721Token\r\n * Generic implementation for the required functionality of the ERC721 standard\r\n */\r\ncontract ERC721Token is ERC721 {\r\n  using SafeMath for uint256;\r\n\r\n  // Total amount of tokens\r\n  uint256 private totalTokens;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) private tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) private tokenApprovals;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping (address => uint256[]) private ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) private ownedTokensIndex;\r\n\r\n  /**\r\n  * @dev Guarantees msg.sender is owner of the given token\r\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n  */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the total amount of tokens stored by the contract\r\n  * @return uint256 representing the total amount of tokens\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalTokens;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address\r\n  * @param _owner address to query the balance of\r\n  * @return uint256 representing the amount owned by the passed address\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return ownedTokens[_owner].length;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the list of tokens owned by a given address\r\n  * @param _owner address to query the tokens of\r\n  * @return uint256[] representing the list of tokens owned by the passed address\r\n  */\r\n  function tokensOf(address _owner) public view returns (uint256[]) {\r\n    return ownedTokens[_owner];\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the owner of the specified token ID\r\n  * @param _tokenId uint256 ID of the token to query the owner of\r\n  * @return owner address currently marked as the owner of the given token ID\r\n  */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address to take ownership of a given token ID\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved to take ownership of the given token ID\r\n   */\r\n  function approvedFor(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfers the ownership of a given token ID to another address\r\n  * @param _to address to receive the ownership of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\r\n    clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Approves another address to claim for the ownership of the given token ID\r\n  * @param _to address to be approved for the given token ID\r\n  * @param _tokenId uint256 ID of the token to be approved\r\n  */\r\n  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    if (approvedFor(_tokenId) != 0 || _to != 0) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      Approval(owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Claims the ownership of a given token ID\r\n  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\r\n  */\r\n  function takeOwnership(uint256 _tokenId) public {\r\n    require(isApprovedFor(msg.sender, _tokenId));\r\n    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Mint token function\r\n  * @param _to The address that will own the minted token\r\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n  */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addToken(_to, _tokenId);\r\n    Transfer(0x0, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Burns a specific token\r\n  * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n  */\r\n  function _burn(uint256 _tokenId) onlyOwnerOf(_tokenId) internal {\r\n    if (approvedFor(_tokenId) != 0) {\r\n      clearApproval(msg.sender, _tokenId);\r\n    }\r\n    removeToken(msg.sender, _tokenId);\r\n    Transfer(msg.sender, 0x0, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether the msg.sender is approved for the given token ID or not\r\n   * This function is not private so it can be extended in further implementations like the operatable ERC721\r\n   * @param _owner address of the owner to query the approval of\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether the msg.sender is approved for the given token ID or not\r\n   */\r\n  function isApprovedFor(address _owner, uint256 _tokenId) internal view returns (bool) {\r\n    return approvedFor(_tokenId) == _owner;\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function to clear current approval and transfer the ownership of a given token ID\r\n  * @param _from address which you want to send tokens from\r\n  * @param _to address which you want to transfer the token to\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    require(_to != ownerOf(_tokenId));\r\n    require(ownerOf(_tokenId) == _from);\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeToken(_from, _tokenId);\r\n    addToken(_to, _tokenId);\r\n    Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function to clear current approval of a given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function clearApproval(address _owner, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    tokenApprovals[_tokenId] = 0;\r\n    Approval(_owner, 0, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function to add a token ID to the list of a given address\r\n  * @param _to address representing the new owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n  */\r\n  function addToken(address _to, uint256 _tokenId) private {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    uint256 length = balanceOf(_to);\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n    totalTokens = totalTokens.add(1);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function to remove a token ID from the list of a given address\r\n  * @param _from address representing the previous owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n  */\r\n  function removeToken(address _from, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _from);\r\n\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = balanceOf(_from).sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    tokenOwner[_tokenId] = 0;\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n    totalTokens = totalTokens.sub(1);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external pure returns (string _name);\r\n\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() external pure returns (string _symbol);\r\n\r\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n  ///  Metadata JSON Schema\".\r\n  function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n\r\ncontract SupeRare is ERC721Token, Ownable, ERC721Metadata {\r\n    using SafeMath for uint256;\r\n    \r\n    // Percentage to owner of SupeRare. (* 10) to allow for < 1% \r\n    uint256 public maintainerPercentage = 30; \r\n    \r\n    // Percentage to creator of artwork. (* 10) to allow for tens decimal. \r\n    uint256 public creatorPercentage = 100; \r\n    \r\n    // Mapping from token ID to the address bidding\r\n    mapping(uint256 => address) private tokenBidder;\r\n\r\n    // Mapping from token ID to the current bid amount\r\n    mapping(uint256 => uint256) private tokenCurrentBid;\r\n    \r\n    // Mapping from token ID to the owner sale price\r\n    mapping(uint256 => uint256) private tokenSalePrice;\r\n\r\n    // Mapping from token ID to the creator's address\r\n    mapping(uint256 => address) private tokenCreator;\r\n  \r\n    // Mapping from token ID to the metadata uri\r\n    mapping(uint256 => string) private tokenToURI;\r\n    \r\n    // Mapping from metadata uri to the token ID\r\n    mapping(string => uint256) private uriOriginalToken;\r\n    \r\n    // Mapping from token ID to whether the token has been sold before.\r\n    mapping(uint256 => bool) private tokenSold;\r\n\r\n    // Mapping of address to boolean indicating whether the add\r\n    mapping(address => bool) private creatorWhitelist;\r\n\r\n\r\n    event WhitelistCreator(address indexed _creator);\r\n    event Bid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId);\r\n    event AcceptBid(address indexed _bidder, address indexed _seller, uint256 _amount, uint256 indexed _tokenId);\r\n    event CancelBid(address indexed _bidder, uint256 indexed _amount, uint256 indexed _tokenId);\r\n    event Sold(address indexed _buyer, address indexed _seller, uint256 _amount, uint256 indexed _tokenId);\r\n    event SalePriceSet(uint256 indexed _tokenId, uint256 indexed _price);\r\n\r\n    /**\r\n     * @dev Guarantees _uri has not been used with a token already\r\n     * @param _uri string of the metadata uri associated with the token\r\n     */\r\n    modifier uniqueURI(string _uri) {\r\n        require(uriOriginalToken[_uri] == 0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees msg.sender is not the owner of the given token\r\n     * @param _tokenId uint256 ID of the token to validate its ownership does not belongs to msg.sender\r\n     */\r\n    modifier notOwnerOf(uint256 _tokenId) {\r\n        require(ownerOf(_tokenId) != msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees msg.sender is a whitelisted creator of SupeRare\r\n     */\r\n    modifier onlyCreator() {\r\n        require(creatorWhitelist[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address.\r\n     * Sets the token to be on its second sale.\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\r\n        tokenSold[_tokenId] = true;\r\n        tokenSalePrice[_tokenId] = 0;\r\n        clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a new unique token to the supply\r\n     * @param _uri string metadata uri associated with the token\r\n     */\r\n    function addNewToken(string _uri) public uniqueURI(_uri) onlyCreator {\r\n        uint256 newId = createToken(_uri, msg.sender);\r\n        uriOriginalToken[_uri] = newId;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a new unique token to the supply with N editions. The sale price is set for all editions\r\n     * @param _uri string metadata uri associated with the token.\r\n     * @param _editions uint256 number of editions to create.\r\n     * @param _salePrice uint256 wei price of editions.\r\n     */\r\n    function addNewTokenWithEditions(string _uri, uint256 _editions, uint256 _salePrice) public uniqueURI(_uri) onlyCreator {\r\n      uint256 originalId = createToken(_uri, msg.sender);\r\n      uriOriginalToken[_uri] = originalId;\r\n\r\n      for (uint256 i=0; i<_editions; i++){\r\n        uint256 newId = createToken(_uri, msg.sender);\r\n        tokenSalePrice[newId] = _salePrice;\r\n        SalePriceSet(newId, _salePrice);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Bids on the token, replacing the bid if the bid is higher than the current bid. You cannot bid on a token you already own.\r\n    * @param _tokenId uint256 ID of the token to bid on\r\n    */\r\n    function bid(uint256 _tokenId) public payable notOwnerOf(_tokenId) {\r\n        require(isGreaterBid(_tokenId));\r\n        returnCurrentBid(_tokenId);\r\n        tokenBidder[_tokenId] = msg.sender;\r\n        tokenCurrentBid[_tokenId] = msg.value;\r\n        Bid(msg.sender, msg.value, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Accept the bid on the token, transferring ownership to the current bidder and paying out the owner.\r\n     * @param _tokenId uint256 ID of the token with the standing bid\r\n     */\r\n    function acceptBid(uint256 _tokenId) public onlyOwnerOf(_tokenId) {\r\n        uint256 currentBid = tokenCurrentBid[_tokenId];\r\n        address currentBidder = tokenBidder[_tokenId];\r\n        address tokenOwner = ownerOf(_tokenId);\r\n        address creator = tokenCreator[_tokenId];\r\n        clearApprovalAndTransfer(msg.sender, currentBidder, _tokenId);\r\n        payout(currentBid, owner, creator, tokenOwner, _tokenId);\r\n        clearBid(_tokenId);\r\n        AcceptBid(currentBidder, tokenOwner, currentBid, _tokenId);\r\n        tokenSalePrice[_tokenId] = 0;\r\n    }\r\n    \r\n    /**\r\n     * @dev Cancels the bid on the token, returning the bid amount to the bidder.\r\n     * @param _tokenId uint256 ID of the token with a bid\r\n     */\r\n    function cancelBid(uint256 _tokenId) public {\r\n        address bidder = tokenBidder[_tokenId];\r\n        require(msg.sender == bidder);\r\n        uint256 bidAmount = tokenCurrentBid[_tokenId];\r\n        msg.sender.transfer(bidAmount);\r\n        clearBid(_tokenId);\r\n        CancelBid(bidder, bidAmount, _tokenId);\r\n    }\r\n    \r\n    /**\r\n     * @dev Purchase the token if there is a sale price; transfers ownership to buyer and pays out owner.\r\n     * @param _tokenId uint256 ID of the token to be purchased\r\n     */\r\n    function buy(uint256 _tokenId) public payable notOwnerOf(_tokenId) {\r\n        uint256 salePrice = tokenSalePrice[_tokenId];\r\n        uint256 sentPrice = msg.value;\r\n        address buyer = msg.sender;\r\n        address tokenOwner = ownerOf(_tokenId);\r\n        address creator = tokenCreator[_tokenId];\r\n        require(salePrice > 0);\r\n        require(sentPrice >= salePrice);\r\n        returnCurrentBid(_tokenId);\r\n        clearBid(_tokenId);\r\n        clearApprovalAndTransfer(tokenOwner, buyer, _tokenId);\r\n        payout(sentPrice, owner, creator, tokenOwner, _tokenId);\r\n        tokenSalePrice[_tokenId] = 0;\r\n        Sold(buyer, tokenOwner, sentPrice, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the sale price of the token\r\n     * @param _tokenId uint256 ID of the token with the standing bid\r\n     */\r\n    function setSalePrice(uint256 _tokenId, uint256 _salePrice) public onlyOwnerOf(_tokenId) {\r\n        uint256 currentBid = tokenCurrentBid[_tokenId];\r\n        require(_salePrice > currentBid);\r\n        tokenSalePrice[_tokenId] = _salePrice;\r\n        SalePriceSet(_tokenId, _salePrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds the provided address to the whitelist of creators\r\n     * @param _creator address to be added to the whitelist\r\n     */\r\n    function whitelistCreator(address _creator) public onlyOwner {\r\n      creatorWhitelist[_creator] = true;\r\n      WhitelistCreator(_creator);\r\n    }\r\n    \r\n    /**\r\n     * @dev Set the maintainer Percentage. Needs to be 10 * target percentage\r\n     * @param _percentage uint256 percentage * 10.\r\n     */\r\n    function setMaintainerPercentage(uint256 _percentage) public onlyOwner() {\r\n       maintainerPercentage = _percentage;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set the creator Percentage. Needs to be 10 * target percentage\r\n     * @param _percentage uint256 percentage * 10.\r\n     */\r\n    function setCreatorPercentage(uint256 _percentage) public onlyOwner() {\r\n       creatorPercentage = _percentage;\r\n    }\r\n    \r\n    /**\r\n     * @notice A descriptive name for a collection of NFTs in this contract\r\n     */\r\n    function name() external pure returns (string _name) {\r\n        return 'SupeRare';\r\n    }\r\n\r\n    /**\r\n     * @notice An abbreviated name for NFTs in this contract\r\n     */\r\n    function symbol() external pure returns (string _symbol) {\r\n        return 'SUPR';\r\n    }\r\n\r\n    /**\r\n     * @notice approve is not a supported function for this contract\r\n     */\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        revert();\r\n    }\r\n\r\n    /** \r\n     * @dev Returns whether the creator is whitelisted\r\n     * @param _creator address to check\r\n     * @return bool \r\n     */\r\n    function isWhitelisted(address _creator) external view returns (bool) {\r\n      return creatorWhitelist[_creator];\r\n    }\r\n\r\n    /** \r\n     * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n     * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n     * 3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n     * Metadata JSON Schema\".\r\n     */\r\n    function tokenURI(uint256 _tokenId) external view returns (string) {\r\n        ownerOf(_tokenId);\r\n        return tokenToURI[_tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the specified token ID of the uri. It only\r\n    * returns ids of originals.\r\n    * Throw if not connected to a token ID.\r\n    * @param _uri string uri of metadata\r\n    * @return uint256 token ID\r\n    */\r\n    function originalTokenOfUri(string _uri) public view returns (uint256) {\r\n        uint256 tokenId = uriOriginalToken[_uri];\r\n        ownerOf(tokenId);\r\n        return tokenId;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the current bid and bidder of the token\r\n    * @param _tokenId uint256 ID of the token to get bid details\r\n    * @return bid amount and bidder address of token\r\n    */\r\n    function currentBidDetailsOfToken(uint256 _tokenId) public view returns (uint256, address) {\r\n        return (tokenCurrentBid[_tokenId], tokenBidder[_tokenId]);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the creator of the token\r\n    * @param _tokenId uint256 ID of the token\r\n    * @return address of the creator\r\n    */\r\n    function creatorOfToken(uint256 _tokenId) public view returns (address) {\r\n        return tokenCreator[_tokenId];\r\n    }\r\n    \r\n    /**\r\n    * @dev Gets the sale price of the token\r\n    * @param _tokenId uint256 ID of the token\r\n    * @return sale price of the token\r\n    */\r\n    function salePriceOfToken(uint256 _tokenId) public view returns (uint256) {\r\n        return tokenSalePrice[_tokenId];\r\n    }\r\n    \r\n    /**\r\n    * @dev Internal function to return funds to current bidder.\r\n    * @param _tokenId uint256 ID of the token with the standing bid\r\n    */\r\n    function returnCurrentBid(uint256 _tokenId) private {\r\n        uint256 currentBid = tokenCurrentBid[_tokenId];\r\n        address currentBidder = tokenBidder[_tokenId];\r\n        if(currentBidder != address(0)) {\r\n            currentBidder.transfer(currentBid);\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Internal function to check that the bid is larger than current bid\r\n    * @param _tokenId uint256 ID of the token with the standing bid\r\n    */\r\n    function isGreaterBid(uint256 _tokenId) private view returns (bool) {\r\n        return msg.value > tokenCurrentBid[_tokenId];\r\n    }\r\n    \r\n    /**\r\n    * @dev Internal function to clear bid\r\n    * @param _tokenId uint256 ID of the token with the standing bid\r\n    */\r\n    function clearBid(uint256 _tokenId) private {\r\n        tokenBidder[_tokenId] = address(0);\r\n        tokenCurrentBid[_tokenId] = 0;\r\n    }\r\n    \r\n    /**\r\n    * @dev Internal function to pay the bidder, creator, and maintainer\r\n    * @param _val uint256 value to be split\r\n    * @param _maintainer address of account maintaining SupeRare\r\n    * @param _creator address of the creator of token\r\n    * @param _maintainer address of the owner of token\r\n    */\r\n    function payout(uint256 _val, address _maintainer, address _creator, address _tokenOwner, uint256 _tokenId) private {\r\n        uint256 maintainerPayment;\r\n        uint256 creatorPayment;\r\n        uint256 ownerPayment;\r\n        if (tokenSold[_tokenId]) {\r\n            maintainerPayment = _val.mul(maintainerPercentage).div(1000);\r\n            creatorPayment = _val.mul(creatorPercentage).div(1000);\r\n            ownerPayment = _val.sub(creatorPayment).sub(maintainerPayment); \r\n        } else {\r\n            maintainerPayment = 0;\r\n            creatorPayment = _val;\r\n            ownerPayment = 0;\r\n            tokenSold[_tokenId] = true;\r\n        }\r\n        _maintainer.transfer(maintainerPayment);\r\n        _creator.transfer(creatorPayment);\r\n        _tokenOwner.transfer(ownerPayment);\r\n      \r\n    }\r\n\r\n    /**\r\n     * @dev Internal function creating a new token.\r\n     * @param _uri string metadata uri associated with the token\r\n     */\r\n    function createToken(string _uri, address _creator) private  returns (uint256){\r\n      uint256 newId = totalSupply() + 1;\r\n      _mint(_creator, newId);\r\n      tokenCreator[newId] = _creator;\r\n      tokenToURI[newId] = _uri;\r\n      return newId;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_uri\",\"type\":\"string\"},{\"name\":\"_editions\",\"type\":\"uint256\"},{\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"addNewTokenWithEditions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"setSalePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"currentBidDetailsOfToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approvedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"acceptBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setMaintainerPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"whitelistCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"originalTokenOfUri\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"salePriceOfToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setCreatorPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"creatorOfToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"addNewToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creatorPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maintainerPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"WhitelistCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"AcceptBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"CancelBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"SalePriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SupeRare","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a5a90035ddc72fcfd3293a41dad9a688e046d74d8130c2dda9fc71bd5ebf6545"}]}