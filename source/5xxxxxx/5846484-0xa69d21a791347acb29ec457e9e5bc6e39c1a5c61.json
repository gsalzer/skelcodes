{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// </ORACLIZE_API>\r\n// Minimal required STAKE token interface\r\ncontract StakeToken\r\n{\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n}\r\n\r\ncontract StakeDiceGame\r\n{\r\n    // Prevent people from losing Ether by accidentally sending it to this contract.\r\n    function () payable external\r\n    {\r\n        revert();\r\n    }\r\n    \r\n    ///////////////////////////////\r\n    /////// GAME PARAMETERS\r\n    \r\n    StakeDice public stakeDice;\r\n    \r\n    // Number between 0 and 10 000. Examples:\r\n    // 700 indicates 7% chance.\r\n    // 5000 indicates 50% chance.\r\n    // 8000 indicates 80% chance.\r\n    uint256 public winningChance;\r\n    \r\n    // Examples of multiplierOnWin() return values:\r\n    // 10 000 indicates 1x returned.\r\n    // 13 000 indicated 1.3x returned\r\n    // 200 000 indicates 20x returned\r\n    function multiplierOnWin() public view returns (uint256)\r\n    {\r\n        uint256 beforeHouseEdge = 10000;\r\n        uint256 afterHouseEdge = beforeHouseEdge - stakeDice.houseEdge();\r\n        return afterHouseEdge * 10000 / winningChance;\r\n    }\r\n    \r\n    function maximumBet() public view returns (uint256)\r\n    {\r\n        uint256 availableTokens = stakeDice.stakeTokenContract().balanceOf(address(stakeDice));\r\n        return availableTokens * 10000 / multiplierOnWin() / 5;\r\n    }\r\n    \r\n    ///////////////////////////////\r\n    /////// GAME FUNCTIONALITY\r\n    \r\n    // If we receive approval to transfer a gambler's tokens\r\n    /*function receiveApproval(address _gambler, uint256 _amount, address _tokenContract, bytes) external returns (bool)\r\n    {\r\n        // Make sure that we are receiving STAKE tokens, and not some other token\r\n        require(_tokenContract == address(stakeDice.stakeTokenContract()));\r\n        require(msg.sender == _tokenContract);\r\n        \r\n        // Make sure the bet is within the current limits\r\n        require(_amount >= stakeDice.minimumBet());\r\n        require(_amount <= maximumBet());\r\n        \r\n        // Tranfer the STAKE tokens from the user's account to the StakeDice contract\r\n        stakeDice.stakeTokenContract().transferFrom(_gambler, stakeDice, _amount);\r\n        \r\n        // Notify the StakeDice contract that a bet has been placed\r\n        stakeDice.betPlaced(_gambler, _amount, winningChance);\r\n    }*/\r\n    \r\n    ///////////////////////////////\r\n    /////// OWNER FUNCTIONS\r\n    \r\n    // Constructor function\r\n    // Provide a number between 0 and 10 000 to indicate the winning chance and house edge.\r\n    constructor(StakeDice _stakeDice, uint256 _winningChance) public\r\n    {\r\n        // Ensure the parameters are sane\r\n        require(_winningChance > 0);\r\n        require(_winningChance < 10000);\r\n        require(_stakeDice != address(0x0));\r\n        require(msg.sender == address(_stakeDice));\r\n        \r\n        stakeDice = _stakeDice;\r\n        winningChance = _winningChance;\r\n    }\r\n    \r\n    // Allow the owner to change the winning chance\r\n    function setWinningChance(uint256 _newWinningChance) external\r\n    {\r\n        require(msg.sender == stakeDice.owner());\r\n        require(_newWinningChance > 0);\r\n        require(_newWinningChance < 10000);\r\n        winningChance = _newWinningChance;\r\n    }\r\n    \r\n    // Allow the owner to withdraw STAKE tokens that\r\n    // may have been accidentally sent here.\r\n    function withdrawStakeTokens(uint256 _amount, address _to) external\r\n    {\r\n        require(msg.sender == stakeDice.owner());\r\n        require(_to != address(0x0));\r\n        stakeDice.stakeTokenContract().transfer(_to, _amount);\r\n    }\r\n}\r\n\r\n\r\ncontract StakeDice\r\n{\r\n    ///////////////////////////////\r\n    /////// GAME PARAMETERS\r\n    \r\n    StakeToken public stakeTokenContract;\r\n    mapping(address => bool) public addressIsStakeDiceGameContract;\r\n    StakeDiceGame[] public allGames;\r\n    uint256 public houseEdge;\r\n    uint256 public minimumBet;\r\n    \r\n    //////////////////////////////\r\n    /////// PLAYER STATISTICS\r\n    \r\n    address[] public allPlayers;\r\n    mapping(address => uint256) public playersToTotalBets;\r\n    mapping(address => uint256[]) public playersToBetIndices;\r\n    function playerAmountOfBets(address _player) external view returns (uint256)\r\n    {\r\n        return playersToBetIndices[_player].length;\r\n    }\r\n    \r\n    function totalUniquePlayers() external view returns (uint256)\r\n    {\r\n        return allPlayers.length;\r\n    }\r\n    \r\n    //////////////////////////////\r\n    /////// GAME FUNCTIONALITY\r\n    \r\n    // Events\r\n    event BetPlaced(address indexed gambler, uint256 betIndex);\r\n    event BetWon(address indexed gambler, uint256 betIndex);\r\n    event BetLost(address indexed gambler, uint256 betIndex);\r\n    event BetCanceled(address indexed gambler, uint256 betIndex);\r\n    \r\n    enum BetStatus\r\n    {\r\n        NON_EXISTANT,\r\n        IN_PROGRESS,\r\n        WON,\r\n        LOST,\r\n        CANCELED\r\n    }\r\n    \r\n    struct Bet\r\n    {\r\n        address gambler;\r\n        uint256 winningChance;\r\n        uint256 betAmount;\r\n        uint256 potentialRevenue;\r\n        uint256 roll;\r\n        BetStatus status;\r\n    }\r\n    \r\n    Bet[] public bets;\r\n    uint public betsLength = 0;\r\n    mapping(bytes32 => uint256) public oraclizeQueryIdsToBetIndices;\r\n    \r\n    function betPlaced(address gameContract, uint256 _amount) external\r\n    {\r\n        // Only StakeDiceGame contracts are allowed to call this function\r\n        require(addressIsStakeDiceGameContract[gameContract] == true);\r\n        \r\n         // Make sure the bet is within the current limits\r\n        require(_amount >= minimumBet);\r\n        require(_amount <= StakeDiceGame(gameContract).maximumBet());\r\n        \r\n        // Tranfer the STAKE tokens from the user's account to the StakeDice contract\r\n        stakeTokenContract.transferFrom(msg.sender, this, _amount);\r\n        \r\n        \r\n        // Calculate how much the gambler might win\r\n        uint256 potentialRevenue = StakeDiceGame(gameContract).multiplierOnWin() * _amount / 10000;\r\n        \r\n        // Store the bet\r\n        emit BetPlaced(msg.sender, bets.length);\r\n        playersToBetIndices[msg.sender].push(bets.length);\r\n        bets.push(Bet({gambler: msg.sender, winningChance: StakeDiceGame(gameContract).winningChance(), betAmount: _amount, potentialRevenue: potentialRevenue, roll: 0, status: BetStatus.IN_PROGRESS}));\r\n        betsLength +=1;\r\n        // Update statistics\r\n        if (playersToTotalBets[msg.sender] == 0)\r\n        {\r\n            allPlayers.push(msg.sender);\r\n        }\r\n        playersToTotalBets[msg.sender] += _amount;\r\n        //uint _result = 1; //the random number\r\n        uint256 betIndex = betsLength;\r\n        Bet storage bet = bets[betIndex];\r\n        require(bet.status == BetStatus.IN_PROGRESS);\r\n        // Now that we have generated a random number, let's use it..\r\n        uint randomNumber = uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%100);\r\n       \r\n        // Store the roll in the blockchain permanently\r\n        bet.roll = randomNumber;\r\n        \r\n        // If the random number is smaller than the winningChance, the gambler won!\r\n        if (randomNumber < bet.winningChance/100)\r\n        {\r\n            // If we somehow don't have enough tokens to payout their winnings,\r\n            // cancel the bet and refund the gambler automatically\r\n            if (stakeTokenContract.balanceOf(this) < bet.potentialRevenue)\r\n            {\r\n                _cancelBet(betIndex);\r\n            }\r\n            \r\n            // Otherwise, (if we do have enough tokens)\r\n            else\r\n            {\r\n                // The gambler won!\r\n                bet.status = BetStatus.WON;\r\n            \r\n                // Send them their winnings\r\n                stakeTokenContract.transfer(bet.gambler, bet.potentialRevenue);\r\n                \r\n                // Trigger BetWon event\r\n                emit BetWon(bet.gambler, betIndex);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // The gambler lost!\r\n            bet.status = BetStatus.LOST;\r\n            \r\n            // Send them the smallest possible token unit as consolation prize\r\n            // and as notification that their bet has lost.\r\n            stakeTokenContract.transfer(bet.gambler, 1); // Send 0.00000001 STAKE\r\n            \r\n            // Trigger BetLost event\r\n            emit BetLost(bet.gambler, betIndex);\r\n        }\r\n    }\r\n    \r\n    function _cancelBet(uint256 _betIndex) private\r\n    {\r\n        // Only bets that are in progress can be canceled\r\n        require(bets[_betIndex].status == BetStatus.IN_PROGRESS);\r\n        \r\n        // Store the fact that the bet has been canceled\r\n        bets[_betIndex].status = BetStatus.CANCELED;\r\n        \r\n        // Refund the bet amount to the gambler\r\n        stakeTokenContract.transfer(bets[_betIndex].gambler, bets[_betIndex].betAmount);\r\n        \r\n        // Trigger BetCanceled event\r\n        emit BetCanceled(bets[_betIndex].gambler, _betIndex);\r\n        \r\n        // Subtract the bet from their total\r\n        playersToTotalBets[bets[_betIndex].gambler] -= bets[_betIndex].betAmount;\r\n    }\r\n    \r\n    function amountOfGames() external view returns (uint256)\r\n    {\r\n        return allGames.length;\r\n    }\r\n    \r\n    function amountOfBets() external view returns (uint256)\r\n    {\r\n        return bets.length-1;\r\n    }\r\n    \r\n    ///////////////////////////////\r\n    /////// OWNER FUNCTIONS\r\n    \r\n    address public owner;\r\n    \r\n    // Constructor function\r\n    constructor(StakeToken _stakeTokenContract, uint256 _houseEdge, uint256 _minimumBet) public\r\n    {\r\n        // Bet indices start at 1 because the values of the\r\n        // oraclizeQueryIdsToBetIndices mapping are by default 0.\r\n        bets.length = 1;\r\n        \r\n        // Whoever deployed the contract is made owner\r\n        owner = msg.sender;\r\n        \r\n        // Ensure that the arguments are sane\r\n        require(_houseEdge < 10000);\r\n        require(_stakeTokenContract != address(0x0));\r\n        \r\n        // Store the initializing arguments\r\n        stakeTokenContract = _stakeTokenContract;\r\n        houseEdge = _houseEdge;\r\n        minimumBet = _minimumBet;\r\n    }\r\n    \r\n    // Allow the owner to easily create the default dice games\r\n    function createDefaultGames() public\r\n    {\r\n        require(allGames.length == 0);\r\n        \r\n        addNewStakeDiceGame(500); // 5% chance\r\n        addNewStakeDiceGame(1000); // 10% chance\r\n        addNewStakeDiceGame(1500); // 15% chance\r\n        addNewStakeDiceGame(2000); // 20% chance\r\n        addNewStakeDiceGame(2500); // 25% chance\r\n        addNewStakeDiceGame(3000); // 30% chance\r\n        addNewStakeDiceGame(3500); // 35% chance\r\n        addNewStakeDiceGame(4000); // 40% chance\r\n        addNewStakeDiceGame(4500); // 45% chance\r\n        addNewStakeDiceGame(5000); // 50% chance\r\n        addNewStakeDiceGame(5500); // 55% chance\r\n        addNewStakeDiceGame(6000); // 60% chance\r\n        addNewStakeDiceGame(6500); // 65% chance\r\n        addNewStakeDiceGame(7000); // 70% chance\r\n        addNewStakeDiceGame(7500); // 75% chance\r\n        addNewStakeDiceGame(8000); // 80% chance\r\n        addNewStakeDiceGame(8500); // 85% chance\r\n        addNewStakeDiceGame(9000); // 90% chance\r\n        addNewStakeDiceGame(9500); // 95% chance\r\n    }\r\n    \r\n    // Allow the owner to cancel a bet when it's in progress.\r\n    // This will probably never be needed, but it might some day be needed\r\n    // to refund people if oraclize is not responding.\r\n    function cancelBet(uint256 _betIndex) public\r\n    {\r\n        require(msg.sender == owner);\r\n        \r\n        _cancelBet(_betIndex);\r\n    }\r\n    \r\n    // Allow the owner to add new games with different winning chances\r\n    function addNewStakeDiceGame(uint256 _winningChance) public\r\n    {\r\n        require(msg.sender == owner);\r\n        \r\n        // Deploy a new StakeDiceGame contract\r\n        StakeDiceGame newGame = new StakeDiceGame(this, _winningChance);\r\n        \r\n        // Store the fact that this new address is a StakeDiceGame contract\r\n        addressIsStakeDiceGameContract[newGame] = true;\r\n        allGames.push(newGame);\r\n    }\r\n    \r\n    // Allow the owner to change the house edge\r\n    function setHouseEdge(uint256 _newHouseEdge) external\r\n    {\r\n        require(msg.sender == owner);\r\n        require(_newHouseEdge < 10000);\r\n        houseEdge = _newHouseEdge;\r\n    }\r\n    \r\n    // Allow the owner to change the minimum bet\r\n    // This also allows the owner to temporarily disable the game by setting the\r\n    // minimum bet to an impossibly high number.\r\n    function setMinimumBet(uint256 _newMinimumBet) external\r\n    {\r\n        require(msg.sender == owner);\r\n        minimumBet = _newMinimumBet;\r\n    }\r\n    \r\n    // Allow the owner to deposit and withdraw ether\r\n    // (this contract needs to pay oraclize fees)\r\n    function depositEther() payable external\r\n    {\r\n        require(msg.sender == owner);\r\n    }\r\n    function withdrawEther(uint256 _amount) payable external\r\n    {\r\n        require(msg.sender == owner);\r\n        owner.transfer(_amount);\r\n    }\r\n    \r\n    // Allow the owner to make another address the owner\r\n    function transferOwnership(address _newOwner) external \r\n    {\r\n        require(msg.sender == owner);\r\n        require(_newOwner != 0x0);\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    // Allow the owner to withdraw STAKE tokens\r\n    function withdrawStakeTokens(uint256 _amount) external\r\n    {\r\n        require(msg.sender == owner);\r\n        stakeTokenContract.transfer(owner, _amount);\r\n    }\r\n    \r\n    // Prevent people from losing Ether by accidentally sending it to this contract.\r\n    function () payable external\r\n    {\r\n        revert();\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"gambler\",\"type\":\"address\"},{\"name\":\"winningChance\",\"type\":\"uint256\"},{\"name\":\"betAmount\",\"type\":\"uint256\"},{\"name\":\"potentialRevenue\",\"type\":\"uint256\"},{\"name\":\"roll\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playersToBetIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_betIndex\",\"type\":\"uint256\"}],\"name\":\"cancelBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"oraclizeQueryIdsToBetIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createDefaultGames\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"playerAmountOfBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newHouseEdge\",\"type\":\"uint256\"}],\"name\":\"setHouseEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStakeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_winningChance\",\"type\":\"uint256\"}],\"name\":\"addNewStakeDiceGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinimumBet\",\"type\":\"uint256\"}],\"name\":\"setMinimumBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUniquePlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allGames\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playersToTotalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameContract\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"betPlaced\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressIsStakeDiceGameContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_stakeTokenContract\",\"type\":\"address\"},{\"name\":\"_houseEdge\",\"type\":\"uint256\"},{\"name\":\"_minimumBet\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"BetWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"BetLost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gambler\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betIndex\",\"type\":\"uint256\"}],\"name\":\"BetCanceled\",\"type\":\"event\"}]","ContractName":"StakeDice","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000026fccc1f97dec0fe1e6845e3deafb98d5242b0e0000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000f4240","Library":"","SwarmSource":"bzzr://d03af343f1d93f65e1a57bc28a42df01fdc9778b209b3971eb919f0fc30f8578"}]}