{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/Auction.sol\r\n\r\ncontract Auction {\r\n  \r\n  string public description;\r\n  string public instructions; // will be used for delivery address or email\r\n  uint public price;\r\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\r\n  uint public timestampEnd;\r\n  address public beneficiary;\r\n  bool public finalized = false;\r\n\r\n  address public owner;\r\n  address public winner;\r\n  mapping(address => uint) public bids;\r\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\r\n  function getAccountListLenght() public constant returns(uint) { return accountsList.length; } // lenght is not accessible from DApp, exposing convenience method: https://stackoverflow.com/questions/43016011/getting-the-length-of-public-array-variable-getter\r\n\r\n  // THINK: should be (an optional) constructor parameter?\r\n  // For now if you want to change - simply modify the code\r\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\r\n  uint public increaseTimeBy = 24 * 60 * 60;\r\n  \r\n\r\n  event BidEvent(address indexed bidder, uint value, uint timestamp); // cannot have event and struct with the same name\r\n  event Refund(address indexed bidder, uint value, uint timestamp);\r\n\r\n  \r\n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\r\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\r\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\r\n\r\n\r\n  function setDescription(string _description) public onlyOwner() {\r\n    description = _description;\r\n  }\r\n\r\n  // TODO: Override this method in the derived functions, think about on-chain / off-chain communication mechanism\r\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\r\n    instructions = _instructions;\r\n  }\r\n\r\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\r\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\r\n    owner = msg.sender;\r\n    price = _price;\r\n    description = _description;\r\n    timestampEnd = _timestampEnd;\r\n    beneficiary = _beneficiary;\r\n  }\r\n\r\n  // Same for all the derived contract, it's the implementation of refund() and bid() that differs\r\n  function() public payable {\r\n    if (msg.value == 0) {\r\n      refund();\r\n    } else {\r\n      bid();\r\n    }  \r\n  }\r\n\r\n  function bid() public payable {\r\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\r\n\r\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\r\n      bids[msg.sender] += msg.value;\r\n    } else {\r\n      bids[msg.sender] = msg.value;\r\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \r\n    }\r\n\r\n    if (initialPrice) {\r\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\r\n    } else {\r\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\r\n    }\r\n    \r\n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\r\n      timestampEnd = now + increaseTimeBy;\r\n    }\r\n\r\n    initialPrice = false;\r\n    price = bids[msg.sender];\r\n    winner = msg.sender;\r\n    emit BidEvent(winner, msg.value, now); // THINK: I prefer sharing the value of the current transaction, the total value can be retrieved from the array\r\n  }\r\n\r\n  function finalize() public ended() onlyOwner() {\r\n    require(finalized == false, \"can withdraw only once\");\r\n    require(initialPrice == false, \"can withdraw only if there were bids\");\r\n\r\n    finalized = true;\r\n    beneficiary.transfer(price);\r\n  }\r\n\r\n  function refund(address addr) private {\r\n    require(addr != winner, \"winner cannot refund\");\r\n    require(bids[addr] > 0, \"refunds only allowed if you sent something\");\r\n\r\n    uint refundValue = bids[addr];\r\n    bids[addr] = 0; // reentrancy fix, setting to zero first\r\n    addr.transfer(refundValue);\r\n    \r\n    emit Refund(addr, refundValue, now);\r\n  }\r\n\r\n  function refund() public {\r\n    refund(msg.sender);\r\n  }\r\n\r\n  function refundOnBehalf(address addr) public onlyOwner() {\r\n    refund(addr);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/AuctionMultiple.sol\r\n\r\n// 1, \"something\", 1539659548, \"0xca35b7d915458ef540ade6068dfe2f44e8fa733c\", 3\r\n// 1, \"something\", 1539659548, \"0x315f80C7cAaCBE7Fb1c14E65A634db89A33A9637\", 3\r\n\r\ncontract AuctionMultiple is Auction {\r\n\r\n  uint public constant LIMIT = 2000; // due to gas restrictions we limit the number of participants in the auction (no Burning Man tickets yet)\r\n  uint public constant HEAD = 120000000 * 1e18; // uint(-1); // really big number\r\n  uint public constant TAIL = 0;\r\n  uint public lastBidID = 0;  \r\n  uint public howMany; // number of items to sell, for isntance 40k tickets to a concert\r\n\r\n  struct Bid {\r\n    uint prev;            // bidID of the previous element.\r\n    uint next;            // bidID of the next element.\r\n    uint value;\r\n    address contributor;  // The contributor who placed the bid.\r\n  }    \r\n\r\n  mapping (uint => Bid) public bids; // map bidID to actual Bid structure\r\n  mapping (address => uint) public contributors; // map address to bidID\r\n  \r\n  event LogNumber(uint number);\r\n  event LogText(string text);\r\n  event LogAddress(address addr);\r\n  \r\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary, uint _howMany) Auction(_price, _description, _timestampEnd, _beneficiary) public {\r\n    require(_howMany > 1, \"This auction is suited to multiple items. With 1 item only - use different code. Or remove this 'require' - you've been warned\");\r\n    howMany = _howMany;\r\n\r\n    bids[HEAD] = Bid({\r\n        prev: TAIL,\r\n        next: TAIL,\r\n        value: HEAD,\r\n        contributor: address(0)\r\n    });\r\n    bids[TAIL] = Bid({\r\n        prev: HEAD,\r\n        next: HEAD,\r\n        value: TAIL,\r\n        contributor: address(0)\r\n    });    \r\n  }\r\n\r\n  function bid() public payable {\r\n    require(now < timestampEnd, \"cannot bid after the auction ends\");\r\n\r\n    uint myBidId = contributors[msg.sender];\r\n    uint insertionBidId;\r\n    \r\n    if (myBidId > 0) { // sender has already placed bid, we increase the existing one\r\n        \r\n      Bid storage existingBid = bids[myBidId];\r\n      existingBid.value = existingBid.value + msg.value;\r\n      if (existingBid.value > bids[existingBid.next].value) { // else do nothing (we are lower than the next one)\r\n        insertionBidId = searchInsertionPoint(existingBid.value, existingBid.next);\r\n\r\n        bids[existingBid.prev].next = existingBid.next;\r\n        bids[existingBid.next].prev = existingBid.prev;\r\n\r\n        existingBid.prev = insertionBidId;\r\n        existingBid.next = bids[insertionBidId].next;\r\n\r\n        bids[ bids[insertionBidId].next ].prev = myBidId;\r\n        bids[insertionBidId].next = myBidId;\r\n      } \r\n\r\n    } else { // bid from this guy does not exist, create a new one\r\n      require(msg.value >= price, \"Not much sense sending less than the price, likely an error\"); // but it is OK to bid below the cut off bid, some guys may withdraw\r\n      require(lastBidID < LIMIT, \"Due to blockGas limit we limit number of people in the auction to 4000 - round arbitrary number - check test gasLimit folder for more info\");\r\n\r\n      lastBidID++;\r\n\r\n      insertionBidId = searchInsertionPoint(msg.value, TAIL);\r\n\r\n      contributors[msg.sender] = lastBidID;\r\n      accountsList.push(msg.sender);\r\n\r\n      bids[lastBidID] = Bid({\r\n        prev: insertionBidId,\r\n        next: bids[insertionBidId].next,\r\n        value: msg.value,\r\n        contributor: msg.sender\r\n      });\r\n\r\n      bids[ bids[insertionBidId].next ].prev = lastBidID;\r\n      bids[insertionBidId].next = lastBidID;\r\n    }\r\n\r\n    emit BidEvent(msg.sender, msg.value, now);\r\n  }\r\n\r\n  function refund(address addr) private {\r\n    uint bidId = contributors[addr];\r\n    require(bidId > 0, \"the guy with this address does not exist, makes no sense to witdraw\");\r\n    uint position = getPosition(addr);\r\n    require(position > howMany, \"only the non-winning bids can be withdrawn\");\r\n\r\n    uint refundValue = bids[ bidId ].value;\r\n    _removeBid(bidId);\r\n\r\n    addr.transfer(refundValue);\r\n    emit Refund(addr, refundValue, now);\r\n  }\r\n\r\n  // Separate function as it is used by derived contracts too\r\n  function _removeBid(uint bidId) internal {\r\n    Bid memory thisBid = bids[ bidId ];\r\n    bids[ thisBid.prev ].next = thisBid.next;\r\n    bids[ thisBid.next ].prev = thisBid.prev;\r\n\r\n    delete bids[ bidId ]; // clearning storage\r\n    delete contributors[ msg.sender ]; // clearning storage\r\n    // cannot delete from accountsList - cannot shrink an array in place without spending shitloads of gas\r\n  }\r\n\r\n  function finalize() public ended() onlyOwner() {\r\n    require(finalized == false, \"auction already finalized, can withdraw only once\");\r\n    finalized = true;\r\n\r\n    uint sumContributions = 0;\r\n    uint counter = 0;\r\n    Bid memory currentBid = bids[HEAD];\r\n    while(counter++ < howMany && currentBid.prev != TAIL) {\r\n      currentBid = bids[ currentBid.prev ];\r\n      sumContributions += currentBid.value;\r\n    }\r\n\r\n    beneficiary.transfer(sumContributions);\r\n  }\r\n\r\n  // We are  starting from TAIL and going upwards\r\n  // This is to simplify the case of increasing bids (can go upwards, cannot go lower)\r\n  // NOTE: blockSize gas limit in case of so many bids (wishful thinking)\r\n  function searchInsertionPoint(uint _contribution, uint _startSearch) view public returns (uint) {\r\n    require(_contribution > bids[_startSearch].value, \"your contribution and _startSearch does not make sense, it will search in a wrong direction\");\r\n\r\n    Bid memory lowerBid = bids[_startSearch];\r\n    Bid memory higherBid;\r\n\r\n    while(true) { // it is guaranteed to stop as we set the HEAD bid with very high maximum valuation\r\n      higherBid = bids[lowerBid.next];\r\n\r\n      if (_contribution < higherBid.value) {\r\n        return higherBid.prev;\r\n      } else {\r\n        lowerBid = higherBid;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getPosition(address addr) view public returns(uint) {\r\n    uint bidId = contributors[addr];\r\n    require(bidId != 0, \"cannot ask for a position of a guy who is not on the list\");\r\n    uint position = 1;\r\n\r\n    Bid memory currentBid = bids[HEAD];\r\n\r\n    while (currentBid.prev != bidId) { // BIG LOOP WARNING, that why we have LIMIT\r\n      currentBid = bids[currentBid.prev];\r\n      position++;\r\n    }\r\n    return position;\r\n  }\r\n\r\n  function getPosition() view public returns(uint) { // shorthand for calling without parameters\r\n    return getPosition(msg.sender);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/AuctionMultipleGuaranteed.sol\r\n\r\n// 100000000000000000, \"membership in Casa Crypto\", 1546300799, \"0x8855Ef4b740Fc23D822dC8e1cb44782e52c07e87\", 20, 5, 5000000000000000000\r\n\r\n// 100000000000000000, \"Ethereum coding workshop 24th August 2018\", 1538351999, \"0x09b25F7627A8d509E5FaC01cB7692fdBc26A2663\", 12, 3, 5000000000000000000\r\n\r\n// For instance: effering limited \"Early Bird\" tickets that are guaranteed\r\ncontract AuctionMultipleGuaranteed is AuctionMultiple {\r\n\r\n  uint public howManyGuaranteed; // after guaranteed slots are used, we decrease the number of slots available (in the parent contract)\r\n  uint public priceGuaranteed;\r\n  address[] public guaranteedContributors; // cannot iterate mapping, keeping addresses in an array\r\n  mapping (address => uint) public guaranteedContributions;\r\n  function getGuaranteedContributorsLenght() public constant returns(uint) { return guaranteedContributors.length; } // lenght is not accessible from DApp, exposing convenience method: https://stackoverflow.com/questions/43016011/getting-the-length-of-public-array-variable-getter\r\n\r\n  event GuaranteedBid(address indexed bidder, uint value, uint timestamp);\r\n  \r\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary, uint _howMany, uint _howManyGuaranteed, uint _priceGuaranteed) AuctionMultiple(_price, _description, _timestampEnd, _beneficiary, _howMany) public {\r\n    require(_howMany >= _howManyGuaranteed, \"The number of guaranteed items should be less or equal than total items. If equal = fixed price sell, kind of OK with me\");\r\n    require(_priceGuaranteed > 0, \"Guranteed price must be greated than zero\");\r\n\r\n    howManyGuaranteed = _howManyGuaranteed;\r\n    priceGuaranteed = _priceGuaranteed;\r\n  }\r\n\r\n  function bid() public payable {\r\n    require(now < timestampEnd, \"cannot bid after the auction ends\");\r\n    require(guaranteedContributions[msg.sender] == 0, \"already a guranteed contributor, cannot more than once\");\r\n\r\n    uint myBidId = contributors[msg.sender];\r\n    if (myBidId > 0) {\r\n      uint newTotalValue = bids[myBidId].value + msg.value;\r\n      if (newTotalValue >= priceGuaranteed && howManyGuaranteed > 0) {\r\n        _removeBid(myBidId);\r\n        _guarantedBid(newTotalValue);\r\n      } else {\r\n        super.bid(); // regular bid (sum is smaller than guranteed or guranteed already used)\r\n      }\r\n    } else if (msg.value >= priceGuaranteed && howManyGuaranteed > 0) {\r\n      _guarantedBid(msg.value);\r\n    } else {\r\n       super.bid(); // regular bid (completely new one)\r\n    }\r\n  }\r\n\r\n  function _guarantedBid(uint value) private {\r\n    guaranteedContributors.push(msg.sender);\r\n    guaranteedContributions[msg.sender] = value;\r\n    howManyGuaranteed--;\r\n    howMany--;\r\n    emit GuaranteedBid(msg.sender, value, now);\r\n  }\r\n\r\n  function finalize() public ended() onlyOwner() {\r\n    require(finalized == false, \"auction already finalized, can withdraw only once\");\r\n    finalized = true;\r\n\r\n    uint sumContributions = 0;\r\n    uint counter = 0;\r\n    Bid memory currentBid = bids[HEAD];\r\n    while(counter++ < howMany && currentBid.prev != TAIL) {\r\n      currentBid = bids[ currentBid.prev ];\r\n      sumContributions += currentBid.value;\r\n    }\r\n\r\n    // At all times we are aware of gas limits - that's why we limit auction to 2000 participants, see also `test-gasLimit` folder\r\n    for (uint i=0; i<guaranteedContributors.length; i++) {\r\n      sumContributions += guaranteedContributions[ guaranteedContributors[i] ];\r\n    }\r\n\r\n    beneficiary.transfer(sumContributions);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"timestampEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howManyGuaranteed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HEAD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"instructions\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"prev\",\"type\":\"uint256\"},{\"name\":\"next\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"contributor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGuaranteedContributorsLenght\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"refundOnBehalf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBidID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howMany\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"guaranteedContributors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"increaseTimeIfBidBeforeEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"setDescription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contribution\",\"type\":\"uint256\"},{\"name\":\"_startSearch\",\"type\":\"uint256\"}],\"name\":\"searchInsertionPoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceGuaranteed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountListLenght\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TAIL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"increaseTimeBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"guaranteedContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_instructions\",\"type\":\"string\"}],\"name\":\"setInstructions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_timestampEnd\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_howMany\",\"type\":\"uint256\"},{\"name\":\"_howManyGuaranteed\",\"type\":\"uint256\"},{\"name\":\"_priceGuaranteed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"GuaranteedBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"LogNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"LogText\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BidEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"AuctionMultipleGuaranteed","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000005b7ff34000000000000000000000000085a363699c6864248a6ffca66e4a1a5ccf9f5567000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000004563918244f400000000000000000000000000000000000000000000000000000000000000000018457468657265756d20636f64696e6720776f726b73686f700000000000000000","Library":"","SwarmSource":"bzzr://370f90f5d60b674c4e647bb079cd7ff02e744982672d318ba14385a9f03e7abc"}]}