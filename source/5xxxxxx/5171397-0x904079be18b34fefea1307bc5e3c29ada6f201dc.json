{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations that are safe for uint256 against overflow and negative values\r\n * @dev https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n */\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Moderated\r\n * @dev restricts execution of 'onlyModerator' modified functions to the contract moderator\r\n * @dev restricts execution of 'ifUnrestricted' modified functions to when unrestricted \r\n *      boolean state is true\r\n * @dev allows for the extraction of ether or other ERC20 tokens mistakenly sent to this address\r\n */\r\ncontract Moderated {\r\n    \r\n    address public moderator;\r\n    \r\n    bool public unrestricted;\r\n    \r\n    modifier onlyModerator {\r\n        require(msg.sender == moderator);\r\n        _;\r\n    }\r\n    \r\n    modifier ifUnrestricted {\r\n        require(unrestricted);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPayloadSize(uint256 numWords) {\r\n        assert(msg.data.length >= numWords * 32 + 4);\r\n        _;\r\n    }    \r\n    \r\n    function Moderated() public {\r\n        moderator = msg.sender;\r\n        unrestricted = true;\r\n    }\r\n    \r\n    function reassignModerator(address newModerator) public onlyModerator {\r\n        moderator = newModerator;\r\n    }\r\n    \r\n    function restrict() public onlyModerator {\r\n        unrestricted = false;\r\n    }\r\n    \r\n    function unrestrict() public onlyModerator {\r\n        unrestricted = true;\r\n    }  \r\n    \r\n    /// This method can be used to extract tokens mistakenly sent to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    function extract(address _token) public returns (bool) {\r\n        require(_token != address(0x0));\r\n        Token token = Token(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        return token.transfer(moderator, balance);\r\n    }\r\n    \r\n    function isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(_addr) }\r\n        return (size > 0);\r\n    }    \r\n} \r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract Token { \r\n\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);    \r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);    \r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Controlled\r\n * @dev Restricts execution of modified functions to the contract controller alone\r\n */\r\ncontract Controlled {\r\n    address public controller;\r\n\r\n    function Controlled() public {\r\n        controller = msg.sender;\r\n    }\r\n\r\n    modifier onlyController {\r\n        require(msg.sender == controller);\r\n        _;\r\n    }\r\n\r\n    function transferControl(address newController) public onlyController{\r\n        controller = newController;\r\n    }\r\n}\r\n\r\n/**\r\n * @title RefundVault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\n * and forwarding it if crowdsale is successful.\r\n */\r\ncontract RefundVault is Controlled {\r\n    using SafeMath for uint256;\r\n    \r\n    enum State { Active, Refunding, Closed }\r\n    \r\n    mapping (address => uint256) public deposited;\r\n    address public wallet;\r\n    State public state;\r\n    \r\n    event Closed();\r\n    event RefundsEnabled();\r\n    event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n    \r\n    function RefundVault(address _wallet) public {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;        \r\n        state = State.Active;\r\n    }\r\n\r\n\tfunction () external payable {\r\n\t    revert();\r\n\t}\r\n    \r\n    function deposit(address investor) onlyController public payable {\r\n        require(state == State.Active);\r\n        deposited[investor] = deposited[investor].add(msg.value);\r\n    }\r\n    \r\n    function close() onlyController public {\r\n        require(state == State.Active);\r\n        state = State.Closed;\r\n        Closed();\r\n        wallet.transfer(this.balance);\r\n    }\r\n    \r\n    function enableRefunds() onlyController public {\r\n        require(state == State.Active);\r\n        state = State.Refunding;\r\n        RefundsEnabled();\r\n    }\r\n    \r\n    function refund(address investor) public {\r\n        require(state == State.Refunding);\r\n        uint256 depositedValue = deposited[investor];\r\n        deposited[investor] = 0;\r\n        investor.transfer(depositedValue);\r\n        Refunded(investor, depositedValue);\r\n    }\r\n}\r\n\r\ncontract CrowdSale is Moderated {\r\n\tusing SafeMath for uint256;\r\n\t\r\n\t// LEON ERC20 smart contract\r\n\tToken public tokenContract;\r\n\t\r\n    // crowdsale starts 1 March 2018, 00h00 PDT\r\n    uint256 public constant startDate = 1519891200;\r\n    // crowdsale ends 31 December 2018, 23h59 PDT\r\n    uint256 public constant endDate = 1546243140;\r\n    \r\n    // crowdsale aims to sell at least 100 000 LEONS\r\n    uint256 public constant crowdsaleTarget = 100000 * 10**18;\r\n    uint256 public constant margin = 1000 * 10**18;\r\n    // running total of tokens sold\r\n    uint256 public tokensSold;\r\n    \r\n    // ethereum to US Dollar exchange rate\r\n    uint256 public etherToUSDRate;\r\n    \r\n    // address to receive accumulated ether given a successful crowdsale\r\n\taddress public constant etherVault = 0xD8d97E3B5dB13891e082F00ED3fe9A0BC6B7eA01;    \r\n\t// vault contract escrows ether and facilitates refunds given unsuccesful crowdsale\r\n\tRefundVault public refundVault;\r\n    \r\n    // minimum of 0.005 ether to participate in crowdsale\r\n\tuint256 constant purchaseThreshold = 5 finney;\r\n\r\n    // boolean to indicate crowdsale finalized state\t\r\n\tbool public isFinalized = false;\r\n\t\r\n\tbool public active = false;\r\n\t\r\n\t// finalization event\r\n\tevent Finalized();\r\n\t\r\n\t// purchase event\r\n\tevent Purchased(address indexed purchaser, uint256 indexed tokens);\r\n    \r\n    // checks that crowd sale is live\t\r\n    modifier onlyWhileActive {\r\n        require(now >= startDate && now <= endDate && active);\r\n        _;\r\n    }\t\r\n\t\r\n    function CrowdSale(address _tokenAddr, uint256 price) public {\r\n        // the LEON token contract\r\n        tokenContract = Token(_tokenAddr);\r\n        // initiate new refund vault to escrow ether from purchasers\r\n        refundVault = new RefundVault(etherVault);\r\n        \r\n        etherToUSDRate = price;\r\n    }\t\r\n\tfunction setRate(uint256 _rate) public onlyModerator returns (bool) {\r\n\t    etherToUSDRate = _rate;\r\n\t}\r\n\t// fallback function invokes buyTokens method\r\n\tfunction() external payable {\r\n\t    buyTokens(msg.sender);\r\n\t}\r\n\t\r\n\t// forwards ether received to refund vault and generates tokens for purchaser\r\n\tfunction buyTokens(address _purchaser) public payable ifUnrestricted onlyWhileActive returns (bool) {\r\n\t    require(!targetReached());\r\n\t    require(msg.value > purchaseThreshold);\r\n\t    refundVault.deposit.value(msg.value)(_purchaser);\r\n\t    // 1 LEON is priced at 1 USD\r\n\t    // etherToUSDRate is stored in cents, /100 to get USD quantity\r\n\t    // crowdsale offers 100% bonus, purchaser receives (tokens before bonus) * 2\r\n\t    // tokens = (ether * etherToUSDRate in cents) * 2 / 100\r\n\t\tuint256 _tokens = (msg.value).mul(etherToUSDRate).div(50);\t\t\r\n\t\trequire(tokenContract.transferFrom(moderator,_purchaser, _tokens));\r\n        tokensSold = tokensSold.add(_tokens);\r\n        Purchased(_purchaser, _tokens);\r\n        return true;\r\n\t}\t\r\n\t\r\n\tfunction initialize() public onlyModerator returns (bool) {\r\n\t    require(!active && !isFinalized);\r\n\t    require(tokenContract.allowance(moderator,address(this)) == crowdsaleTarget + margin);\r\n\t    active = true;\r\n\t}\r\n\t\r\n\t// activates end of crowdsale state\r\n    function finalize() public onlyModerator {\r\n        // cannot have been invoked before\r\n        require(!isFinalized);\r\n        // can only be invoked after end date or if target has been reached\r\n        require(hasEnded() || targetReached());\r\n        \r\n        // if crowdsale has been successful\r\n        if(targetReached()) {\r\n            // close refund vault and forward ether to etherVault\r\n            refundVault.close();\r\n\r\n        // if the sale was unsuccessful    \r\n        } else {\r\n            // activate refund vault\r\n            refundVault.enableRefunds();\r\n        }\r\n        // emit Finalized event\r\n        Finalized();\r\n        // set isFinalized boolean to true\r\n        isFinalized = true;\r\n        \r\n        active = false;\r\n\r\n    }\r\n    \r\n\t// checks if end date of crowdsale is passed    \r\n    function hasEnded() internal view returns (bool) {\r\n        return (now > endDate);\r\n    }\r\n    \r\n    // checks if crowdsale target is reached\r\n    function targetReached() internal view returns (bool) {\r\n        return (tokensSold >= crowdsaleTarget);\r\n    }\r\n    \r\n    // refunds ether to investors if crowdsale is unsuccessful \r\n    function claimRefund() public {\r\n        // can only be invoked after sale is finalized\r\n        require(isFinalized);\r\n        // can only be invoked if sale target was not reached\r\n        require(!targetReached());\r\n        // if msg.sender invested ether during crowdsale - refund them of their contribution\r\n        refundVault.refund(msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unrestricted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moderator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newModerator\",\"type\":\"address\"}],\"name\":\"reassignModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherToUSDRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"margin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restrict\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unrestrict\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"extract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_purchaser\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"}]","ContractName":"CrowdSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000022d00ff8d5ba5246f048b96b6e101b4dac483d7500000000000000000000000000000000000000000000000000000000000186a0","Library":"","SwarmSource":"bzzr://e7d46b47e0cfcc2e1727600bd72c794ad63f380908c0917e894519d430fea4ac"}]}