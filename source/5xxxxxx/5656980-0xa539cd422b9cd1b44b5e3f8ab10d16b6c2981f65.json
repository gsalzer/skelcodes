{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/**\r\n *\r\n *\r\n *\r\n * ATTENTION!\r\n *\r\n *  HALO3D token machine!\r\n */\r\n\r\ncontract ERC20Interface {\r\n    function transfer(address to, uint256 tokens) public returns (bool success);\r\n}\r\n\r\ncontract Halo3D {\r\n\r\n    function buy(address) public payable returns(uint256);\r\n    function transfer(address, uint256) public returns(bool);\r\n    function withdraw() public;\r\n    function myTokens() public view returns(uint256);\r\n    function myDividends(bool) public view returns(uint256);\r\n    function reinvest() public;\r\n}\r\n\r\n/**\r\n * Definition of contract accepting Halo3D tokens\r\n * Games, casinos, anything can reuse this contract to support Halo3D tokens\r\n */\r\ncontract AcceptsHalo3D {\r\n    Halo3D public tokenContract;\r\n\r\n    function AcceptsHalo3D(address _tokenContract) public {\r\n        tokenContract = Halo3D(_tokenContract);\r\n    }\r\n\r\n    modifier onlyTokenContract {\r\n        require(msg.sender == address(tokenContract));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Standard ERC677 function that will handle incoming token transfers.\r\n    *\r\n    * @param _from  Token sender address.\r\n    * @param _value Amount of tokens.\r\n    * @param _data  Transaction metadata.\r\n    */\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public ownerCandidate;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        ownerCandidate = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == ownerCandidate);\r\n        owner = ownerCandidate;\r\n    }\r\n\r\n}\r\n\r\ncontract Halo3DDoublr is Owned, AcceptsHalo3D {\r\n\r\n    /**\r\n     * Events\r\n     */\r\n    event Deposit(uint256 amount, address depositer);\r\n    event Payout(uint256 amount, address creditor);\r\n\r\n    /**\r\n     * Structs\r\n     */\r\n    struct Participant {\r\n        address etherAddress;\r\n        uint256 payout;\r\n    }\r\n\r\n    //Total ETH managed over the lifetime of the contract\r\n    uint256 throughput;\r\n    //Total ETH received from dividends\r\n    uint256 dividends;\r\n    //The percent to return to depositers. 100 for 00%, 200 to double, etc.\r\n    uint256 public multiplier;\r\n    //Where in the line we are with creditors\r\n    uint256 public payoutOrder = 0;\r\n    //How much is owed to people\r\n    uint256 public backlog = 0;\r\n    //The creditor line\r\n    Participant[] public participants;\r\n    //How much each person is owed\r\n    mapping(address => uint256) public creditRemaining;\r\n\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Halo3DDoublr(uint multiplierPercent, address _baseContract)\r\n      AcceptsHalo3D(_baseContract)\r\n      public {\r\n        multiplier = multiplierPercent;\r\n    }\r\n\r\n\r\n    /**\r\n     * Fallback function for the contract, protect investors\r\n     */\r\n    function() payable public {\r\n      // Not accepting Ether directly\r\n    }\r\n\r\n    /**\r\n    * Deposit Halo3D tokens to get in line to be credited back the multiplier as percent.\r\n    * This function can be called only via Halo3D contract using function\r\n    * Halo3D.transferAndCall(address, uint256, bytes)\r\n    *\r\n    * @dev Standard ERC677 function that will handle incoming token transfers.\r\n    * @param _from  Token sender address.\r\n    * @param _value Amount of tokens.\r\n    * @param _data  Transaction metadata.\r\n    */\r\n    function tokenFallback(address _from, uint256 _value, bytes _data)\r\n      external\r\n      onlyTokenContract\r\n      returns (bool) {\r\n        require(!_isContract(_from));\r\n        require(_value <= 100 ether); // 100 H3D tokens\r\n        require(_value >= 1 ether); // 1 H3D token\r\n        //Compute how much to pay them\r\n        uint256 amountCredited = (_value * multiplier) / 100;\r\n        //Get in line to be paid back.\r\n        participants.push(Participant(_from, amountCredited));\r\n        //Increase the backlog by the amount owed\r\n        backlog += amountCredited;\r\n        //Increase the amount owed to this address\r\n        creditRemaining[_from] += amountCredited;\r\n        //Emit a deposit event.\r\n        emit Deposit(_value, _from);\r\n\r\n        //Increase our total throughput\r\n        throughput += _value;\r\n\r\n        uint balance = _value;\r\n\r\n        //While we still have money to send\r\n        reinvest(); // protect from people sending tokens to contract\r\n        while (balance > 0) {\r\n            //Either pay them what they are owed or however much we have, whichever is lower.\r\n            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\r\n            //if we have something to pay them\r\n            if(payoutToSend > 0){\r\n                //subtract how much we've spent\r\n                balance -= payoutToSend;\r\n                //subtract the amount paid from the amount owed\r\n                backlog -= payoutToSend;\r\n                //subtract the amount remaining they are owed\r\n                creditRemaining[participants[payoutOrder].etherAddress] -= payoutToSend;\r\n                //credit their account the amount they are being paid\r\n                participants[payoutOrder].payout -= payoutToSend;\r\n\r\n                //Try and pay them, making best effort. But if we fail? Run out of gas? That's not our problem any more\r\n                if(tokenContract.transfer(participants[payoutOrder].etherAddress, payoutToSend)) {\r\n                  //Record that they were paid\r\n                  emit Payout(payoutToSend, participants[payoutOrder].etherAddress);\r\n                }else{\r\n                    //undo the accounting, they are being skipped because they are not payable.\r\n                    balance += payoutToSend;\r\n                    backlog += payoutToSend;\r\n                    creditRemaining[participants[payoutOrder].etherAddress] += payoutToSend;\r\n                    participants[payoutOrder].payout += payoutToSend;\r\n                }\r\n\r\n            }\r\n            //If we still have balance left over\r\n            if(balance > 0){\r\n                // go to the next person in line\r\n                payoutOrder += 1;\r\n            }\r\n            //If we've run out of people to pay, stop\r\n            if(payoutOrder >= participants.length){\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _isContract(address _user) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(_user) }\r\n        return size > 0;\r\n    }\r\n\r\n    // Reinvest Halo3D Doublr dividends\r\n    // All the dividends this contract makes will be used to grow token fund for players\r\n    function reinvest() public {\r\n       if(tokenContract.myDividends(true) > 1) {\r\n         tokenContract.reinvest();\r\n       }\r\n    }\r\n\r\n    /**\r\n     * Number of participants who are still owed.\r\n     */\r\n    function backlogLength() public view returns (uint256){\r\n        return participants.length - payoutOrder;\r\n    }\r\n\r\n    /**\r\n     * Total amount still owed in credit to depositors.\r\n     */\r\n    function backlogAmount() public view returns (uint256){\r\n        return backlog;\r\n    }\r\n\r\n    /**\r\n     * Total number of deposits in the lifetime of the contract.\r\n     */\r\n    function totalParticipants() public view returns (uint256){\r\n        return participants.length;\r\n    }\r\n\r\n    /**\r\n     * Total amount of Halo3D that the contract has delt with so far.\r\n     */\r\n    function totalSpent() public view returns (uint256){\r\n        return throughput;\r\n    }\r\n\r\n    /**\r\n     * Amount still owed to an individual address\r\n     */\r\n    function amountOwed(address anAddress) public view returns (uint256) {\r\n        return creditRemaining[anAddress];\r\n    }\r\n\r\n     /**\r\n      * Amount owed to this person.\r\n      */\r\n    function amountIAmOwed() public view returns (uint256){\r\n        return amountOwed(msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"amountIAmOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"etherAddress\",\"type\":\"address\"},{\"name\":\"payout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"backlog\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"backlogAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"backlogLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"anAddress\",\"type\":\"address\"}],\"name\":\"amountOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"creditRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"multiplierPercent\",\"type\":\"uint256\"},{\"name\":\"_baseContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositer\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creditor\",\"type\":\"address\"}],\"name\":\"Payout\",\"type\":\"event\"}]","ContractName":"Halo3DDoublr","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000960000000000000000000000000b3e515cb8b318120c5a126679eb945f2bb2ddea","Library":"","SwarmSource":"bzzr://b5256bb976ab581028850e2c9838a976a51535730133327a2219d4e424c128ac"}]}