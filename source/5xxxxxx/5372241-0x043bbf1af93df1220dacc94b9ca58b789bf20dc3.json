{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/// @title ERC-165 Standard Interface Detection\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\ncontract ERC721 is ERC165 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\ninterface ERC721TokenReceiver {\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    function name() external pure returns (string _name);\r\n    function symbol() external pure returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title A reusable contract to comply with ERC-165\r\n/// @author William Entriken (https://phor.net)\r\ncontract PublishInterfaces is ERC165 {\r\n    /// @dev Every interface that we support\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    function PublishInterfaces() internal {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n    }\r\n\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[interfaceID] && (interfaceID != 0xffffffff);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title The external contract that is responsible for generating metadata for GanTokens,\r\n///  it has one function that will return the data as bytes.\r\ncontract Metadata {\r\n\r\n    /// @dev Given a token Id, returns a string with metadata\r\n    function getMetadata(uint256 _tokenId, string) public pure returns (bytes32[4] buffer, uint256 count) {\r\n        if (_tokenId == 1) {\r\n            buffer[0] = \"Hello World! :D\";\r\n            count = 15;\r\n        } else if (_tokenId == 2) {\r\n            buffer[0] = \"I would definitely choose a medi\";\r\n            buffer[1] = \"um length string.\";\r\n            count = 49;\r\n        } else if (_tokenId == 3) {\r\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\r\n            buffer[2] = \" tristique vestibulum id, libero\";\r\n            buffer[3] = \" suscipit varius sapien aliquam.\";\r\n            count = 128;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract GanNFT is ERC165, ERC721, ERC721Enumerable, PublishInterfaces, Ownable {\r\n\r\n  function GanNFT() internal {\r\n      supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n      supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n      supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n      supportedInterfaces[0x8153916a] = true; // ERC721 + 165 (not needed)\r\n  }\r\n\r\n  bytes4 private constant ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"));\r\n\r\n  // @dev claim price taken for each new GanToken\r\n  // generating a new token will be free in the beinging and later changed\r\n  uint256 public claimPrice = 0;\r\n\r\n  // @dev max supply for token\r\n  uint256 public maxSupply = 300;\r\n\r\n  // The contract that will return tokens metadata\r\n  Metadata public erc721Metadata;\r\n\r\n  /// @dev list of all owned token ids\r\n  uint256[] public tokenIds;\r\n\r\n  /// @dev a mpping for all tokens\r\n  mapping(uint256 => address) public tokenIdToOwner;\r\n\r\n  /// @dev mapping to keep owner balances\r\n  mapping(address => uint256) public ownershipCounts;\r\n\r\n  /// @dev mapping to owners to an array of tokens that they own\r\n  mapping(address => uint256[]) public ownerBank;\r\n\r\n  /// @dev mapping to approved ids\r\n  mapping(uint256 => address) public tokenApprovals;\r\n\r\n  /// @dev The authorized operators for each address\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external pure returns (string) {\r\n      return \"GanToken\";\r\n  }\r\n\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() external pure returns (string) {\r\n      return \"GT\";\r\n  }\r\n\r\n  /// @dev Set the address of the sibling contract that tracks metadata.\r\n  /// Only the contract creater can call this.\r\n  /// @param _contractAddress The location of the contract with meta data\r\n  function setMetadataAddress(address _contractAddress) public onlyOwner {\r\n      erc721Metadata = Metadata(_contractAddress);\r\n  }\r\n\r\n  modifier canTransfer(uint256 _tokenId, address _from, address _to) {\r\n    address owner = tokenIdToOwner[_tokenId];\r\n    require(tokenApprovals[_tokenId] == _to || owner == _from || operatorApprovals[_to][_to]);\r\n    _;\r\n  }\r\n  /// @notice checks to see if a sender owns a _tokenId\r\n  /// @param _tokenId The identifier for an NFT\r\n  modifier owns(uint256 _tokenId) {\r\n    require(tokenIdToOwner[_tokenId] == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /// @dev This emits any time the ownership of a GanToken changes.\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /// @dev This emits when the approved addresses for a GanToken is changed or reaffirmed.\r\n  /// The zero address indicates there is no owner and it get reset on a transfer\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n  /// @dev This emits when an operator is enabled or disabled for an owner.\r\n  ///  The operator can manage all NFTs of the owner.\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  /// @notice allow the owner to set the supply max\r\n  function setMaxSupply(uint max) external payable onlyOwner {\r\n    require(max > tokenIds.length);\r\n\r\n    maxSupply = max;\r\n  }\r\n\r\n  /// @notice allow the owner to set a new fee for creating a GanToken\r\n  function setClaimPrice(uint256 price) external payable onlyOwner {\r\n    claimPrice = price;\r\n  }\r\n\r\n  /// @dev Required for ERC-721 compliance.\r\n  function balanceOf(address _owner) external view returns (uint256 balance) {\r\n    balance = ownershipCounts[_owner];\r\n  }\r\n\r\n  /// @notice Gets the onwner of a an NFT\r\n  /// @param _tokenId The identifier for an NFT\r\n  /// @dev Required for ERC-721 compliance.\r\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\r\n    owner = tokenIdToOwner[_tokenId];\r\n  }\r\n\r\n  /// @notice returns all owners' tokens will return an empty array\r\n  /// if the address has no tokens\r\n  /// @param _owner The address of the owner in question\r\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\r\n    uint256 tokenCount = ownershipCounts[_owner];\r\n\r\n    if (tokenCount == 0) {\r\n      return new uint256[](0);\r\n    }\r\n\r\n    uint256[] memory result = new uint256[](tokenCount);\r\n\r\n    for (uint256 i = 0; i < tokenCount; i++) {\r\n      result[i] = ownerBank[_owner][i];\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /// @dev creates a list of all the tokenIds\r\n  function getAllTokenIds() external view returns (uint256[]) {\r\n    uint256[] memory result = new uint256[](tokenIds.length);\r\n    for (uint i = 0; i < result.length; i++) {\r\n      result[i] = tokenIds[i];\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /// @notice Create a new GanToken with a id and attaches an owner\r\n  /// @param _noise The id of the token that's being created\r\n  function newGanToken(uint256 _noise) external payable {\r\n    require(msg.sender != address(0));\r\n    require(tokenIdToOwner[_noise] == 0x0);\r\n    require(tokenIds.length < maxSupply);\r\n    require(msg.value >= claimPrice);\r\n\r\n    tokenIds.push(_noise);\r\n    ownerBank[msg.sender].push(_noise);\r\n    tokenIdToOwner[_noise] = msg.sender;\r\n    ownershipCounts[msg.sender]++;\r\n\r\n    emit Transfer(address(0), msg.sender, 0);\r\n  }\r\n\r\n  /// @notice Transfers the ownership of an NFT from one address to another address\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  ///  `onERC721Received` on `_to` and throws if the return value is not\r\n  ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  /// @param data Additional data with no specified format, sent in call to `_to`\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public payable\r\n  {\r\n      _safeTransferFrom(_from, _to, _tokenId, data);\r\n  }\r\n\r\n  /// @notice Transfers the ownership of an NFT from one address to another address\r\n  /// @dev This works identically to the other function with an extra data parameter,\r\n  ///  except this function just sets data to \"\"\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable\r\n  {\r\n      _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n  ///  THEY MAY BE PERMANENTLY LOST\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  `_tokenId` is not a valid NFT.\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n    require(_to != 0x0);\r\n    require(_to != address(this));\r\n    require(tokenApprovals[_tokenId] == msg.sender);\r\n    require(tokenIdToOwner[_tokenId] == _from);\r\n\r\n    _transfer(_tokenId, _to);\r\n  }\r\n\r\n  /// @notice Grant another address the right to transfer a specific token via\r\n  ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\r\n  /// @dev The zero address indicates there is no approved address.\r\n  /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n  ///  operator of the current owner.\r\n  /// @dev Required for ERC-721 compliance.\r\n  /// @param _to The address to be granted transfer approval. Pass address(0) to\r\n  ///  clear all approvals.\r\n  /// @param _tokenId The ID of the Kitty that can be transferred if this call succeeds.\r\n  function approve(address _to, uint256 _tokenId) external owns(_tokenId) payable {\r\n      // Register the approval (replacing any previous approval).\r\n      tokenApprovals[_tokenId] = _to;\r\n\r\n      emit Approval(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n  ///  all your asset.\r\n  /// @dev Emits the ApprovalForAll event\r\n  /// @param _operator Address to add to the set of authorized operators.\r\n  /// @param _approved True if the operators is approved, false to revoke approval\r\n  function setApprovalForAll(address _operator, bool _approved) external {\r\n      operatorApprovals[msg.sender][_operator] = _approved;\r\n      emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /// @notice Get the approved address for a single NFT\r\n  /// @param _tokenId The NFT to find the approved address for\r\n  /// @return The approved address for this NFT, or the zero address if there is none\r\n  function getApproved(uint256 _tokenId) external view returns (address) {\r\n      return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /// @notice Query if an address is an authorized operator for another address\r\n  /// @param _owner The address that owns the NFTs\r\n  /// @param _operator The address that acts on behalf of the owner\r\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n      return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /// @notice Count NFTs tracked by this contract\r\n  /// @return A count of valid NFTs tracked by this contract, where each one of\r\n  ///  them has an assigned and queryable owner not equal to the zero address\r\n  /// @dev Required for ERC-721 compliance.\r\n  function totalSupply() external view returns (uint256) {\r\n    return tokenIds.length;\r\n  }\r\n\r\n  /// @notice Enumerate valid NFTs\r\n  /// @param _index A counter less than `totalSupply()`\r\n  /// @return The token identifier for index the `_index`th NFT 0 if it doesn't exist,\r\n  function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n      return tokenIds[_index];\r\n  }\r\n\r\n  /// @notice Enumerate NFTs assigned to an owner\r\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  ///  `_owner` is the zero address, representing invalid NFTs.\r\n  /// @param _owner An address where we are interested in NFTs owned by them\r\n  /// @param _index A counter less than `balanceOf(_owner)`\r\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  ///   (sort order not specified)\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {\r\n      require(_owner != address(0));\r\n      require(_index < ownerBank[_owner].length);\r\n      _tokenId = ownerBank[_owner][_index];\r\n  }\r\n\r\n  function _transfer(uint256 _tokenId, address _to) internal {\r\n    require(_to != address(0));\r\n\r\n    address from = tokenIdToOwner[_tokenId];\r\n    uint256 tokenCount = ownershipCounts[from];\r\n    // remove from ownerBank and replace the deleted token id\r\n    for (uint256 i = 0; i < tokenCount; i++) {\r\n      uint256 ownedId = ownerBank[from][i];\r\n      if (_tokenId == ownedId) {\r\n        delete ownerBank[from][i];\r\n        if (i != tokenCount) {\r\n          ownerBank[from][i] = ownerBank[from][tokenCount - 1];\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    ownershipCounts[from]--;\r\n    ownershipCounts[_to]++;\r\n    ownerBank[_to].push(_tokenId);\r\n\r\n    tokenIdToOwner[_tokenId] = _to;\r\n    tokenApprovals[_tokenId] = address(0);\r\n    emit Transfer(from, _to, 1);\r\n  }\r\n\r\n  /// @dev Actually perform the safeTransferFrom\r\n  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)\r\n      private\r\n      canTransfer(_tokenId, _from, _to)\r\n  {\r\n      address owner = tokenIdToOwner[_tokenId];\r\n\r\n      require(owner == _from);\r\n      require(_to != address(0));\r\n      require(_to != address(this));\r\n      _transfer(_tokenId, _to);\r\n\r\n\r\n      // Do the callback after everything is done to avoid reentrancy attack\r\n      uint256 codeSize;\r\n      assembly { codeSize := extcodesize(_to) }\r\n      if (codeSize == 0) {\r\n          return;\r\n      }\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\r\n      require(retval == ERC721_RECEIVED);\r\n  }\r\n\r\n  /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n  ///  This method is licenced under the Apache License.\r\n  ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n  function _memcpy(uint _dest, uint _src, uint _len) private pure {\r\n      // Copy word-length chunks while possible\r\n      for(; _len >= 32; _len -= 32) {\r\n          assembly {\r\n              mstore(_dest, mload(_src))\r\n          }\r\n          _dest += 32;\r\n          _src += 32;\r\n      }\r\n\r\n      // Copy remaining bytes\r\n      uint256 mask = 256 ** (32 - _len) - 1;\r\n      assembly {\r\n          let srcpart := and(mload(_src), not(mask))\r\n          let destpart := and(mload(_dest), mask)\r\n          mstore(_dest, or(destpart, srcpart))\r\n      }\r\n  }\r\n\r\n  /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n  ///  This method is licenced under the Apache License.\r\n  ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n  function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private pure returns (string) {\r\n      string memory outputString = new string(_stringLength);\r\n      uint256 outputPtr;\r\n      uint256 bytesPtr;\r\n\r\n      assembly {\r\n          outputPtr := add(outputString, 32)\r\n          bytesPtr := _rawBytes\r\n      }\r\n\r\n      _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n      return outputString;\r\n  }\r\n\r\n\r\n  /// @notice Returns a URI pointing to a metadata package for this token conforming to\r\n  ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\r\n  /// @param _tokenId The ID number of the GanToken whose metadata should be returned.\r\n  function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\r\n      require(erc721Metadata != address(0));\r\n      uint256 count;\r\n      bytes32[4] memory buffer;\r\n\r\n      (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\r\n\r\n      return _toString(buffer, count);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract GanTokenMain is GanNFT {\r\n\r\n  struct Offer {\r\n    bool isForSale;\r\n    uint256 tokenId;\r\n    address seller;\r\n    uint value;          // in ether\r\n    address onlySellTo;     // specify to sell only to a specific person\r\n  }\r\n\r\n  struct Bid {\r\n    bool hasBid;\r\n    uint256 tokenId;\r\n    address bidder;\r\n    uint value;\r\n  }\r\n\r\n  /// @dev mapping of balances for address\r\n  mapping(address => uint256) public pendingWithdrawals;\r\n\r\n  /// @dev mapping of tokenId to to an offer\r\n  mapping(uint256 => Offer) public ganTokenOfferedForSale;\r\n\r\n  /// @dev mapping bids to tokenIds\r\n  mapping(uint256 => Bid) public tokenBids;\r\n\r\n  event BidForGanTokenOffered(uint256 tokenId, uint256 value, address sender);\r\n  event BidWithdrawn(uint256 tokenId, uint256 value, address bidder);\r\n  event GanTokenOfferedForSale(uint256 tokenId, uint256 minSalePriceInWei, address onlySellTo);\r\n  event GanTokenNoLongerForSale(uint256 tokenId);\r\n\r\n\r\n  /// @notice Allow a token owner to pull sale\r\n  /// @param tokenId The id of the token that's created\r\n  function ganTokenNoLongerForSale(uint256 tokenId) public payable owns(tokenId) {\r\n    ganTokenOfferedForSale[tokenId] = Offer(false, tokenId, msg.sender, 0, 0x0);\r\n\r\n    emit GanTokenNoLongerForSale(tokenId);\r\n  }\r\n\r\n  /// @notice Put a token up for sale\r\n  /// @param tokenId The id of the token that's created\r\n  /// @param minSalePriceInWei desired price of token\r\n  function offerGanTokenForSale(uint tokenId, uint256 minSalePriceInWei) external payable owns(tokenId) {\r\n    ganTokenOfferedForSale[tokenId] = Offer(true, tokenId, msg.sender, minSalePriceInWei, 0x0);\r\n\r\n    emit GanTokenOfferedForSale(tokenId, minSalePriceInWei, 0x0);\r\n  }\r\n\r\n  /// @notice Create a new GanToken with a id and attaches an owner\r\n  /// @param tokenId The id of the token that's being created\r\n  function offerGanTokenForSaleToAddress(uint tokenId, address sendTo, uint256 minSalePriceInWei) external payable {\r\n    require(tokenIdToOwner[tokenId] == msg.sender);\r\n    ganTokenOfferedForSale[tokenId] = Offer(true, tokenId, msg.sender, minSalePriceInWei, sendTo);\r\n\r\n    emit GanTokenOfferedForSale(tokenId, minSalePriceInWei, sendTo);\r\n  }\r\n\r\n  /// @notice Allows an account to buy a NFT gan token that is up for offer\r\n  /// the token owner must set onlySellTo to the sender\r\n  /// @param id the id of the token\r\n  function buyGanToken(uint256 id) public payable {\r\n    Offer memory offer = ganTokenOfferedForSale[id];\r\n    require(offer.isForSale);\r\n    require(offer.onlySellTo == msg.sender && offer.onlySellTo != 0x0);\r\n    require(msg.value == offer.value);\r\n    require(tokenIdToOwner[id] == offer.seller);\r\n\r\n    safeTransferFrom(offer.seller, offer.onlySellTo, id);\r\n\r\n    ganTokenOfferedForSale[id] = Offer(false, id, offer.seller, 0, 0x0);\r\n\r\n    pendingWithdrawals[offer.seller] += msg.value;\r\n  }\r\n\r\n  /// @notice Allows an account to enter a higher bid on a toekn\r\n  /// @param tokenId the id of the token\r\n  function enterBidForGanToken(uint256 tokenId) external payable {\r\n    Bid memory existing = tokenBids[tokenId];\r\n    require(tokenIdToOwner[tokenId] != msg.sender);\r\n    require(tokenIdToOwner[tokenId] != 0x0);\r\n    require(msg.value > existing.value);\r\n    if (existing.value > 0) {\r\n      // Refund the failing bid\r\n      pendingWithdrawals[existing.bidder] += existing.value;\r\n    }\r\n\r\n    tokenBids[tokenId] = Bid(true, tokenId, msg.sender, msg.value);\r\n    emit BidForGanTokenOffered(tokenId, msg.value, msg.sender);\r\n  }\r\n\r\n  /// @notice Allows the owner of a token to accept an outstanding bid for that token\r\n  /// @param tokenId The id of the token that's being created\r\n  /// @param price The desired price of token in wei\r\n  function acceptBid(uint256 tokenId, uint256 price) external payable {\r\n    require(tokenIdToOwner[tokenId] == msg.sender);\r\n    Bid memory bid = tokenBids[tokenId];\r\n    require(bid.value != 0);\r\n    require(bid.value == price);\r\n\r\n    safeTransferFrom(msg.sender, bid.bidder, tokenId);\r\n\r\n    tokenBids[tokenId] = Bid(false, tokenId, address(0), 0);\r\n    pendingWithdrawals[msg.sender] += bid.value;\r\n  }\r\n\r\n  /// @notice Check is a given id is on sale\r\n  /// @param tokenId The id of the token in question\r\n  /// @return a bool whether of not the token is on sale\r\n  function isOnSale(uint256 tokenId) external view returns (bool) {\r\n    return ganTokenOfferedForSale[tokenId].isForSale;\r\n  }\r\n\r\n  /// @notice Gets all the sale data related to a token\r\n  /// @param tokenId The id of the token\r\n  /// @return sale information\r\n  function getSaleData(uint256 tokenId) public view returns (bool isForSale, address seller, uint value, address onlySellTo) {\r\n    Offer memory offer = ganTokenOfferedForSale[tokenId];\r\n    isForSale = offer.isForSale;\r\n    seller = offer.seller;\r\n    value = offer.value;\r\n    onlySellTo = offer.onlySellTo;\r\n  }\r\n\r\n  /// @notice Gets all the bid data related to a token\r\n  /// @param tokenId The id of the token\r\n  /// @return bid information\r\n  function getBidData(uint256 tokenId) view public returns (bool hasBid, address bidder, uint value) {\r\n    Bid memory bid = tokenBids[tokenId];\r\n    hasBid = bid.hasBid;\r\n    bidder = bid.bidder;\r\n    value = bid.value;\r\n  }\r\n\r\n  /// @notice Allows a bidder to withdraw their bid\r\n  /// @param tokenId The id of the token\r\n  function withdrawBid(uint256 tokenId) external payable {\r\n      Bid memory bid = tokenBids[tokenId];\r\n      require(tokenIdToOwner[tokenId] != msg.sender);\r\n      require(tokenIdToOwner[tokenId] != 0x0);\r\n      require(bid.bidder == msg.sender);\r\n\r\n      emit BidWithdrawn(tokenId, bid.value, msg.sender);\r\n      uint amount = bid.value;\r\n      tokenBids[tokenId] = Bid(false, tokenId, 0x0, 0);\r\n      // Refund the bid money\r\n      msg.sender.transfer(amount);\r\n  }\r\n\r\n  /// @notice Allows a sender to withdraw any amount in the contrat\r\n  function withdraw() external {\r\n    uint256 amount = pendingWithdrawals[msg.sender];\r\n    // Remember to zero the pending refund before\r\n    // sending to prevent re-entrancy attacks\r\n    pendingWithdrawals[msg.sender] = 0;\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"acceptBid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawBid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenBids\",\"outputs\":[{\"name\":\"hasBid\",\"type\":\"bool\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ganTokenOfferedForSale\",\"outputs\":[{\"name\":\"isForSale\",\"type\":\"bool\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"onlySellTo\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setClaimPrice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"}],\"name\":\"offerGanTokenForSale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerBank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"enterBidForGanToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getSaleData\",\"outputs\":[{\"name\":\"isForSale\",\"type\":\"bool\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"onlySellTo\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getBidData\",\"outputs\":[{\"name\":\"hasBid\",\"type\":\"bool\"},{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_noise\",\"type\":\"uint256\"}],\"name\":\"newGanToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenApprovals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"},{\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"}],\"name\":\"offerGanTokenForSaleToAddress\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ganTokenNoLongerForSale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"buyGanToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownershipCounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTokenIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isOnSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"BidForGanTokenOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"BidWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minSalePriceInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"onlySellTo\",\"type\":\"address\"}],\"name\":\"GanTokenOfferedForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"GanTokenNoLongerForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"GanTokenMain","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7d601ad39c5cfe01a015dd4e417bfcf45705dcb9c931df9153eaee5dea60acd7"}]}