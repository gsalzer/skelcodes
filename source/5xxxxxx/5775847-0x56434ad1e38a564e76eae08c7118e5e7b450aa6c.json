{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/*\r\n* The Blockchain Football network presents....\r\n* https://fantasyfootballfund.co/\r\n* https://discord.gg/qPjA6Tx\r\n*\r\n* Build your fantasy player portfolio. Earn crypto daily based on player performance.\r\n*\r\n* 4 Ways to earn\r\n* [1] Price Fluctuations - buy and sell at the right moments\r\n* [2] Match day Divs - allocated to shareholders of top performing players every day\r\n* [3] Fame Divs - allocated to shareholders of infamous players on non-match days\r\n* [4] Original Owner - allocated to owners of original player cards on blockchainfootball.co (2% per share sold)\r\n*/\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract PlayerToken is ERC20 {\r\n\r\n    // Ownable\r\n    address public owner;\r\n    bool public paused = false;\r\n\r\n    // Events\r\n    event PlayerTokenBuy(address indexed buyer, address indexed referrer, uint tokens, uint cost, string symbol);\r\n    event PlayerTokenSell(address indexed seller, uint tokens, uint value, string symbol);\r\n\r\n    // Libs\r\n    using SafeMath for uint256;\r\n\r\n    // Core token attributes\r\n    uint256 public initialTokenPrice_;  // Typically = 1 Finney (0.001 Ether)\r\n    uint256 public incrementalTokenPrice_; // Typically = 0.01 Finney (0.00001 Ether)\r\n\r\n    // Token Properties - set via the constructor for each player\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 0;\r\n\r\n    // Exchange Contract - used to hold the dividend pool across all ERC20 player contracts\r\n    // when shares are brought or sold the dividend fee gets transfered here\r\n    address public exchangeContract_;\r\n    \r\n    // Blockchainfootball.co attributes - if this is set the owner receieves a fee for owning the original card\r\n    BCFMain bcfContract_ = BCFMain(0x6abF810730a342ADD1374e11F3e97500EE774D1F);\r\n    uint256 public playerId_;\r\n    address public originalOwner_;\r\n\r\n    // Fees - denoted in %\r\n    uint8 constant internal processingFee_ = 5; // inc. fees to cover DAILY gas usage to assign divs to token holders\r\n    uint8 constant internal originalOwnerFee_ = 2; // of all token buys per original player owned + set on blockchainfootball.co\r\n    uint8 internal dividendBuyPoolFee_ = 15; // buys AND sells go into the div pool to promote gameplay - can be updated\r\n    uint8 internal dividendSellPoolFee_ = 20;\r\n    uint8 constant internal referrerFee_ = 1; // for all token buys (but not sells)\r\n\r\n    // ERC20 data structures\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping (address => uint256)) internal allowed;\r\n\r\n    // Player Exchange Data Structures\r\n    address[] public tokenHolders;\r\n    mapping(address => uint256) public addressToTokenHolderIndex; // Helps to gas-efficiently remove shareholders, by swapping last index\r\n    mapping(address => int256) public totalCost; // To hold the total expenditure of each address, profit tracking\r\n\r\n    // ERC20 Properties\r\n    uint256 totalSupply_;\r\n\r\n    // Additional accessors\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrExchange() {\r\n        require(msg.sender == owner || msg.sender == exchangeContract_);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    // Constructor\r\n    constructor(\r\n        string _name, \r\n        string _symbol, \r\n        uint _startPrice, \r\n        uint _incrementalPrice, \r\n        address _owner, \r\n        address _exchangeContract, \r\n        uint256 _playerId,\r\n        uint8 _promoSharesQuantity\r\n    ) \r\n        public\r\n        payable\r\n    {\r\n        require(_exchangeContract != address(0));\r\n        require(_owner != address(0));\r\n\r\n        exchangeContract_ = _exchangeContract;\r\n        playerId_ = _playerId;\r\n\r\n        // Set initial starting exchange values\r\n        initialTokenPrice_ = _startPrice;\r\n        incrementalTokenPrice_ = _incrementalPrice; // In most cases this will be 1 finney, 0.001 ETH\r\n\r\n        // Initial token properties\r\n        paused = true;\r\n        owner = _owner;\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        // Purchase promotional player shares - we purchase initial shares (the same way users do) as prizes for promos/competitions/giveaways\r\n        if (_promoSharesQuantity > 0) {\r\n            _buyTokens(msg.value, _promoSharesQuantity, _owner, address(0));\r\n        }\r\n    }\r\n\r\n    // **External Exchange**\r\n    function buyTokens(uint8 _amount, address _referredBy) payable external whenNotPaused {\r\n        require(_amount > 0 && _amount <= 100, \"Valid token amount required between 1 and 100\");\r\n        require(msg.value > 0, \"Provide a valid fee\"); \r\n        // solium-disable-next-line security/no-tx-origin\r\n        require(msg.sender == tx.origin, \"Only valid users are allowed to buy tokens\"); \r\n        _buyTokens(msg.value, _amount, msg.sender, _referredBy);\r\n    }\r\n\r\n    function sellTokens(uint8 _amount) external {\r\n        require(_amount > 0, \"Valid sell amount required\");\r\n        require(_amount <= balances[msg.sender]);\r\n        _sellTokens(_amount, msg.sender);\r\n    }\r\n\r\n    // **Internal Exchange**\r\n    function _buyTokens(uint _ethSent, uint8 _amount, address _buyer, address _referredBy) internal {\r\n        \r\n        uint _totalCost;\r\n        uint _processingFee;\r\n        uint _originalOwnerFee;\r\n        uint _dividendPoolFee;\r\n        uint _referrerFee;\r\n\r\n        (_totalCost, _processingFee, _originalOwnerFee, _dividendPoolFee, _referrerFee) = calculateTokenBuyPrice(_amount);\r\n\r\n        require(_ethSent >= _totalCost, \"Invalid fee to buy tokens\");\r\n\r\n        // Send to original card owner if available\r\n        // If we don't have an original owner we move this fee into the dividend pool\r\n        if (originalOwner_ != address(0)) {\r\n            originalOwner_.transfer(_originalOwnerFee);\r\n        } else {\r\n            _dividendPoolFee = _dividendPoolFee.add(_originalOwnerFee);\r\n        }\r\n\r\n        // Send to the referrer - if we don't have a referrer we move this fee into the dividend pool\r\n        if (_referredBy != address(0)) {\r\n            _referredBy.transfer(_referrerFee);\r\n        } else {\r\n            _dividendPoolFee = _dividendPoolFee.add(_referrerFee);\r\n        }\r\n\r\n        // These will always be available\r\n        owner.transfer(_processingFee);\r\n        exchangeContract_.transfer(_dividendPoolFee);\r\n\r\n        // Refund excess\r\n        uint excess = _ethSent.sub(_totalCost);\r\n        _buyer.transfer(excess);\r\n\r\n        // Track ownership of token holders - only if this is the first time the user is buying these player shares\r\n        if (balanceOf(_buyer) == 0) {\r\n            tokenHolders.push(_buyer);\r\n            addressToTokenHolderIndex[_buyer] = tokenHolders.length - 1;\r\n        }\r\n        \r\n        // Provide users with the shares\r\n        _allocatePlayerTokensTo(_buyer, _amount);\r\n\r\n        // Track costs\r\n        totalCost[_buyer] = totalCost[_buyer] + int256(_totalCost); // No need for safe maths here, just holds profit tracking\r\n\r\n        // Event tracking\r\n        emit PlayerTokenBuy(_buyer, _referredBy, _amount, _totalCost, symbol);\r\n    }\r\n\r\n    function _sellTokens(uint8 _amount, address _seller) internal {\r\n        \r\n        uint _totalSellerProceeds;\r\n        uint _processingFee;\r\n        uint _dividendPoolFee;\r\n\r\n        (_totalSellerProceeds, _processingFee, _dividendPoolFee) = calculateTokenSellPrice(_amount);\r\n\r\n        // Burn the sellers shares\r\n        _burnPlayerTokensFrom(_seller, _amount);\r\n\r\n        // Track ownership of token holders if the user no longer has tokens let's remove them\r\n        // we do this semi-efficently by swapping the last index\r\n        if (balanceOf(_seller) == 0) {\r\n            removeFromTokenHolders(_seller);\r\n        }\r\n\r\n        // Transfer to processor, seller and dividend pool\r\n        owner.transfer(_processingFee);\r\n        _seller.transfer(_totalSellerProceeds);\r\n        exchangeContract_.transfer(_dividendPoolFee);\r\n\r\n        // Track costs\r\n        totalCost[_seller] = totalCost[_seller] - int256(_totalSellerProceeds); // No need for safe maths here, just holds profit tracking\r\n\r\n        // Event tracking\r\n        emit PlayerTokenSell(_seller, _amount, _totalSellerProceeds, symbol);\r\n    }\r\n\r\n    // **Calculations - these factor in all fees**\r\n    function calculateTokenBuyPrice(uint _amount) \r\n        public \r\n        view \r\n        returns (\r\n        uint _totalCost, \r\n        uint _processingFee, \r\n        uint _originalOwnerFee, \r\n        uint _dividendPoolFee, \r\n        uint _referrerFee\r\n    ) {    \r\n        uint tokenCost = calculateTokenOnlyBuyPrice(_amount);\r\n\r\n        // We now need to apply fees on top of this\r\n        // In all cases we apply fees - but if there's no original owner or referrer\r\n        // these go into the dividend pool\r\n        _processingFee = SafeMath.div(SafeMath.mul(tokenCost, processingFee_), 100);\r\n        _originalOwnerFee = SafeMath.div(SafeMath.mul(tokenCost, originalOwnerFee_), 100);\r\n        _dividendPoolFee = SafeMath.div(SafeMath.mul(tokenCost, dividendBuyPoolFee_), 100);\r\n        _referrerFee = SafeMath.div(SafeMath.mul(tokenCost, referrerFee_), 100);\r\n\r\n        _totalCost = tokenCost.add(_processingFee).add(_originalOwnerFee).add(_dividendPoolFee).add(_referrerFee);\r\n    }\r\n\r\n    function calculateTokenSellPrice(uint _amount) \r\n        public \r\n        view \r\n        returns (\r\n        uint _totalSellerProceeds,\r\n        uint _processingFee,\r\n        uint _dividendPoolFee\r\n    ) {\r\n        uint tokenSellCost = calculateTokenOnlySellPrice(_amount);\r\n\r\n        // We remove the processing and dividend fees on the final sell price\r\n        // this represents the difference between the buy and sell price on the UI\r\n        _processingFee = SafeMath.div(SafeMath.mul(tokenSellCost, processingFee_), 100);\r\n        _dividendPoolFee = SafeMath.div(SafeMath.mul(tokenSellCost, dividendSellPoolFee_), 100);\r\n\r\n        _totalSellerProceeds = tokenSellCost.sub(_processingFee).sub(_dividendPoolFee);\r\n    }\r\n\r\n    // **Calculate total cost of tokens without fees**\r\n    function calculateTokenOnlyBuyPrice(uint _amount) public view returns(uint) {\r\n        \r\n        // We use a simple arithmetic progression series, summing the incremental prices\r\n\t    // ((n / 2) * (2 * a + (n - 1) * d))\r\n\t    // a = starting value (1st term), d = price increment (diff.), n = amount of shares (no. of terms)\r\n\r\n        // NOTE: we use a mutiplier to avoid issues with an odd number of shares, dividing and limited fixed point support in Solidity\r\n        uint8 multiplier = 10;\r\n        uint amountMultiplied = _amount * multiplier; \r\n        uint startingPrice = initialTokenPrice_ + (totalSupply_ * incrementalTokenPrice_);\r\n        uint totalBuyPrice = (amountMultiplied / 2) * (2 * startingPrice + (_amount - 1) * incrementalTokenPrice_) / multiplier;\r\n\r\n        // Should never *concievably* occur, but more effecient than Safemaths on the entire formula\r\n        assert(totalBuyPrice >= startingPrice); \r\n        return totalBuyPrice;\r\n    }\r\n\r\n    function calculateTokenOnlySellPrice(uint _amount) public view returns(uint) {\r\n        // Similar to calculateTokenBuyPrice, but we abs() the incrementalTokenPrice so we get a reverse arithmetic series\r\n        uint8 multiplier = 10;\r\n        uint amountMultiplied = _amount * multiplier; \r\n        uint startingPrice = initialTokenPrice_ + ((totalSupply_-1) * incrementalTokenPrice_);\r\n        int absIncrementalTokenPrice = int(incrementalTokenPrice_) * -1;\r\n        uint totalSellPrice = uint((int(amountMultiplied) / 2) * (2 * int(startingPrice) + (int(_amount) - 1) * absIncrementalTokenPrice) / multiplier);\r\n        return totalSellPrice;\r\n    }\r\n\r\n    // **UI Helpers**\r\n    function buySellPrices() public view returns(uint _buyPrice, uint _sellPrice) {\r\n        (_buyPrice,,,,) = calculateTokenBuyPrice(1);\r\n        (_sellPrice,,) = calculateTokenSellPrice(1);\r\n    }\r\n\r\n    function portfolioSummary(address _address) public view returns(uint _tokenBalance, int _cost, uint _value) {\r\n        _tokenBalance = balanceOf(_address);\r\n        _cost = totalCost[_address];\r\n        (_value,,) = calculateTokenSellPrice(_tokenBalance);       \r\n    }\r\n\r\n    function totalTokenHolders() public view returns(uint) {\r\n        return tokenHolders.length;\r\n    }\r\n\r\n    function tokenHoldersByIndex() public view returns(address[] _addresses, uint[] _shares) {\r\n        \r\n        // This will only be called offchain to take snapshots of share count at cut off points for divs\r\n        uint tokenHolderCount = tokenHolders.length;\r\n        address[] memory addresses = new address[](tokenHolderCount);\r\n        uint[] memory shares = new uint[](tokenHolderCount);\r\n\r\n        for (uint i = 0; i < tokenHolderCount; i++) {\r\n            addresses[i] = tokenHolders[i];\r\n            shares[i] = balanceOf(tokenHolders[i]);\r\n        }\r\n\r\n        return (addresses, shares);\r\n    }\r\n\r\n    // In cases where there's bugs in the exchange contract we need a way to re-point\r\n    function setExchangeContractAddress(address _exchangeContract) external onlyOwner {\r\n        exchangeContract_ = _exchangeContract;\r\n    }\r\n\r\n    // **Blockchainfootball.co Support**\r\n    function setBCFContractAddress(address _address) external onlyOwner {\r\n        BCFMain candidateContract = BCFMain(_address);\r\n        require(candidateContract.implementsERC721());\r\n        bcfContract_ = candidateContract;\r\n    }\r\n\r\n    function setPlayerId(uint256 _playerId) external onlyOwner {\r\n        playerId_ = _playerId;\r\n    }\r\n\r\n    function setSellDividendPercentageFee(uint8 _dividendPoolFee) external onlyOwnerOrExchange {\r\n        // We'll need some flexibility to alter this as the right dividend structure helps promote gameplay\r\n        // This pushes users to buy players who are performing well to grab divs rather than just getting in early to new players being released\r\n        require(_dividendPoolFee <= 50, \"Max of 50% is assignable to the pool\");\r\n        dividendSellPoolFee_ = _dividendPoolFee;\r\n    }\r\n\r\n    function setBuyDividendPercentageFee(uint8 _dividendPoolFee) external onlyOwnerOrExchange {\r\n        require(_dividendPoolFee <= 50, \"Max of 50% is assignable to the pool\");\r\n        dividendBuyPoolFee_ = _dividendPoolFee;\r\n    }\r\n\r\n    // Can be called by anyone, in which case we could use a another contract to set the original owner whenever it changes on blockchainfootball.co\r\n    function setOriginalOwner(uint256 _playerCardId, address _address) external {\r\n        require(playerId_ > 0, \"Player ID must be set on the contract\");\r\n        \r\n        // As we call .transfer() on buys to send original owners divs we need to make sure this can't be DOS'd through setting the\r\n        // original owner as a smart contract and then reverting any transfer() calls\r\n        // while it would be silly to reject divs it is a valid DOS scenario\r\n        // solium-disable-next-line security/no-tx-origin\r\n        require(msg.sender == tx.origin, \"Only valid users are able to set original ownership\"); \r\n       \r\n        address _cardOwner;\r\n        uint256 _playerId;\r\n        bool _isFirstGeneration;\r\n\r\n        (_playerId,_cardOwner,,_isFirstGeneration) = bcfContract_.playerCards(_playerCardId);\r\n\r\n        require(_isFirstGeneration, \"Card must be an original\");\r\n        require(_playerId == playerId_, \"Card must tbe the same player this contract relates to\");\r\n        require(_cardOwner == _address, \"Card must be owned by the address provided\");\r\n        \r\n        // All good, set the address as the original owner, happy div day \\o/\r\n        originalOwner_ = _address;\r\n    }\r\n\r\n    // ** Internal Token Handling - validation completed by callers **\r\n    function _allocatePlayerTokensTo(address _to, uint256 _amount) internal {\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    function _burnPlayerTokensFrom(address _from, uint256 _amount) internal {\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        totalSupply_ = totalSupply_.sub(_amount);\r\n        emit Transfer(_from, address(0), _amount);\r\n    }\r\n\r\n    function removeFromTokenHolders(address _seller) internal {\r\n        \r\n        uint256 tokenIndex = addressToTokenHolderIndex[_seller];\r\n        uint256 lastAddressIndex = tokenHolders.length.sub(1);\r\n        address lastAddress = tokenHolders[lastAddressIndex];\r\n        \r\n        tokenHolders[tokenIndex] = lastAddress;\r\n        tokenHolders[lastAddressIndex] = address(0);\r\n        tokenHolders.length--;\r\n\r\n        addressToTokenHolderIndex[lastAddress] = tokenIndex;\r\n    }\r\n\r\n    // ** ERC20 Support **\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // Track ownership of token holders - only if this is the first time the user is buying these player shares\r\n        if (balanceOf(_to) == 0) {\r\n            tokenHolders.push(_to);\r\n            addressToTokenHolderIndex[_to] = tokenHolders.length - 1;\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        // Track ownership of token holders if the user no longer has tokens let's remove them\r\n        // we do this semi-efficently by swapping the last index\r\n        if (balanceOf(msg.sender) == 0) {\r\n            removeFromTokenHolders(msg.sender);\r\n        }\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        // Track ownership of token holders - only if this is the first time the user is buying these player shares\r\n        if (balanceOf(_to) == 0) {\r\n            tokenHolders.push(_to);\r\n            addressToTokenHolderIndex[_to] = tokenHolders.length - 1;\r\n        }\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        // Track ownership of token holders if the user no longer has tokens let's remove them\r\n        // we do this semi-efficently by swapping the last index\r\n        if (balanceOf(_from) == 0) {\r\n            removeFromTokenHolders(_from);\r\n        }\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256){\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Utilities\r\n    function setOwner(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n    function pause() onlyOwnerOrExchange whenNotPaused public {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() onlyOwnerOrExchange whenPaused public {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract BCFMain {\r\n    function playerCards(uint256 playerCardId) public view returns (uint256 playerId, address owner, address approvedForTransfer, bool isFirstGeneration);\r\n    function implementsERC721() public pure returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract PlayerExchangeCore {\r\n\r\n    // Events\r\n    event InitialPlayerOffering(address indexed contractAddress, string name, string symbol);\r\n    event DividendWithdrawal(address indexed user, uint amount);\r\n\r\n    // Libs\r\n    using SafeMath for uint256;\r\n\r\n    // Ownership\r\n    address public owner;\r\n    address public referee; // Used to pay out divs and initiate an IPO\r\n\r\n    // Structs\r\n    struct DividendWinner {\r\n        uint playerTokenContractId;\r\n        uint perTokenEthValue;\r\n        uint totalTokens;\r\n        uint tokensProcessed; // So we can determine when all tokens have been allocated divs + settled\r\n    }\r\n\r\n    // State management\r\n    uint internal balancePendingWithdrawal_; // this.balance - balancePendingWithdrawal_ = div prize pool\r\n\r\n    // Data Store\r\n    PlayerToken[] public playerTokenContracts_; // Holds a list of all player token contracts\r\n    DividendWinner[] public dividendWinners_; // Holds a list of dividend winners (player contract id's, not users)\r\n    mapping(address => uint256) public addressToDividendBalance;\r\n\r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyReferee() {\r\n        require(msg.sender == referee);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrReferee() {\r\n        require(msg.sender == owner || msg.sender == referee);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setReferee(address newReferee) public onlyOwner {\r\n        require(newReferee != address(0));\r\n        referee = newReferee;\r\n    }\r\n\r\n    constructor(address _owner, address _referee) public {\r\n        owner = _owner;\r\n        referee = _referee;\r\n    }\r\n\r\n    // Create new instances of a PlayerToken contract and pass along msg.value (so the referee pays and not the contract)\r\n    function newInitialPlayerOffering(\r\n        string _name, \r\n        string _symbol, \r\n        uint _startPrice, \r\n        uint _incrementalPrice, \r\n        address _owner,\r\n        uint256 _playerId,\r\n        uint8 _promoSharesQuantity\r\n    ) \r\n        external \r\n        onlyOwnerOrReferee\r\n        payable\r\n    {\r\n        PlayerToken playerTokenContract = (new PlayerToken).value(msg.value)(\r\n            _name, \r\n            _symbol, \r\n            _startPrice, \r\n            _incrementalPrice, \r\n            _owner, \r\n            address(this), \r\n            _playerId, \r\n            _promoSharesQuantity\r\n        );\r\n\r\n        // Add it to a local storage so we can iterate over it to pull portfolio stats\r\n        playerTokenContracts_.push(playerTokenContract);\r\n\r\n        // Event handling\r\n        emit InitialPlayerOffering(address(playerTokenContract), _name, _symbol);\r\n    }\r\n\r\n    // Empty fallback - any Ether here just goes straight into the Dividend pool\r\n    // this is useful as it provides a mechanism for the other blockchain football games\r\n    // to top the fund up for special events / promotions\r\n    function() payable public { }\r\n\r\n    function getTotalDividendPool() public view returns (uint) {\r\n        return address(this).balance.sub(balancePendingWithdrawal_);\r\n    }\r\n\r\n    function totalPlayerTokenContracts() public view returns (uint) {\r\n        return playerTokenContracts_.length;\r\n    }\r\n\r\n    function totalDividendWinners() public view returns (uint) {\r\n        return dividendWinners_.length;\r\n    }\r\n\r\n    // Called off-chain to manage UI state so no gas concerns - also never likely to be more than 50-200ish player contracts\r\n    function allPlayerTokenContracts() external view returns (address[]) {\r\n        uint playerContractCount = totalPlayerTokenContracts();\r\n        address[] memory addresses = new address[](playerContractCount);\r\n\r\n        for (uint i = 0; i < playerContractCount; i++) {\r\n            addresses[i] = address(playerTokenContracts_[i]);\r\n        }\r\n\r\n        return addresses;\r\n    }\r\n\r\n    /* Safeguard function to quickly pause a stack of contracts */\r\n    function pausePlayerContracts(uint startIndex, uint endIndex) onlyOwnerOrReferee external {\r\n        for (uint i = startIndex; i < endIndex; i++) {\r\n            PlayerToken playerTokenContract = playerTokenContracts_[i];\r\n            if (!playerTokenContract.paused()) {\r\n                playerTokenContract.pause();\r\n            }\r\n        }\r\n    }\r\n\r\n    function unpausePlayerContracts(uint startIndex, uint endIndex) onlyOwnerOrReferee external {\r\n        for (uint i = startIndex; i < endIndex; i++) {\r\n            PlayerToken playerTokenContract = playerTokenContracts_[i];\r\n            if (playerTokenContract.paused()) {\r\n                playerTokenContract.unpause();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setSellDividendPercentageFee(uint8 _fee, uint startIndex, uint endIndex) onlyOwner external {\r\n        for (uint i = startIndex; i < endIndex; i++) {\r\n            PlayerToken playerTokenContract = playerTokenContracts_[i];\r\n            playerTokenContract.setSellDividendPercentageFee(_fee);\r\n        }\r\n    }\r\n\r\n    function setBuyDividendPercentageFee(uint8 _fee, uint startIndex, uint endIndex) onlyOwner external {\r\n        for (uint i = startIndex; i < endIndex; i++) {\r\n            PlayerToken playerTokenContract = playerTokenContracts_[i];\r\n            playerTokenContract.setBuyDividendPercentageFee(_fee);\r\n        }\r\n    }\r\n\r\n    /* Portfolio Support */\r\n    // Only called offchain - so we can omit additional pagination/optimizations here\r\n    function portfolioSummary(address _address) \r\n        external \r\n        view \r\n    returns (\r\n        uint[] _playerTokenContractId, \r\n        uint[] _totalTokens, \r\n        int[] _totalCost, \r\n        uint[] _totalValue) \r\n    {\r\n        uint playerContractCount = totalPlayerTokenContracts();\r\n\r\n        uint[] memory playerTokenContractIds = new uint[](playerContractCount);\r\n        uint[] memory totalTokens = new uint[](playerContractCount);\r\n        int[] memory totalCost = new int[](playerContractCount);\r\n        uint[] memory totalValue = new uint[](playerContractCount);\r\n\r\n        PlayerToken playerTokenContract;\r\n\r\n        for (uint i = 0; i < playerContractCount; i++) {\r\n            playerTokenContract = playerTokenContracts_[i];\r\n            playerTokenContractIds[i] = i;\r\n            (totalTokens[i], totalCost[i], totalValue[i]) = playerTokenContract.portfolioSummary(_address);\r\n        }\r\n\r\n        return (playerTokenContractIds, totalTokens, totalCost, totalValue);\r\n    }\r\n\r\n    /* Dividend Handling */\r\n    // These are all handled based on their corresponding index\r\n    // Takes a snapshot of the current dividend pool balance and allocates a per share div award\r\n    function setDividendWinners(\r\n        uint[] _playerContractIds, \r\n        uint[] _totalPlayerTokens, \r\n        uint8[] _individualPlayerAllocationPcs, \r\n        uint _totalPrizePoolAllocationPc\r\n    ) \r\n        external \r\n        onlyOwnerOrReferee \r\n    {\r\n        require(_playerContractIds.length > 0, \"Must have valid player contracts to award divs to\");\r\n        require(_playerContractIds.length == _totalPlayerTokens.length);\r\n        require(_totalPlayerTokens.length == _individualPlayerAllocationPcs.length);\r\n        require(_totalPrizePoolAllocationPc > 0);\r\n        require(_totalPrizePoolAllocationPc <= 100);\r\n        \r\n        // Calculate how much dividends we have allocated\r\n        uint dailyDivPrizePool = SafeMath.div(SafeMath.mul(getTotalDividendPool(), _totalPrizePoolAllocationPc), 100);\r\n\r\n        // Iteration here should be fine as there should concievably only ever be 3 or 4 winning players each day\r\n        uint8 totalPlayerAllocationPc = 0;\r\n        for (uint8 i = 0; i < _playerContractIds.length; i++) {\r\n            totalPlayerAllocationPc += _individualPlayerAllocationPcs[i];\r\n\r\n            // Calculate from the total daily pool how much is assigned to owners of this player\r\n            // e.g. a typical day might = Total Dividend pool: 100 ETH, _totalPrizePoolAllocationPc: 20 (%)\r\n            // therefore the total dailyDivPrizePool = 20 ETH\r\n            // Which could be allocated as follows\r\n            // 1. 50% MVP Player - (Attacker) (10 ETH total)\r\n            // 2. 25% Player - (Midfielder) (5 ETH total)\r\n            // 3. 25% Player - (Defender) (5 ETH total)\r\n            uint playerPrizePool = SafeMath.div(SafeMath.mul(dailyDivPrizePool, _individualPlayerAllocationPcs[i]), 100);\r\n\r\n            // Calculate total div-per-share\r\n            uint totalPlayerTokens = _totalPlayerTokens[i];\r\n            uint perTokenEthValue = playerPrizePool.div(totalPlayerTokens);\r\n\r\n            // Add to the winners array so it can then be picked up by the div payment processor\r\n            DividendWinner memory divWinner = DividendWinner({\r\n                playerTokenContractId: _playerContractIds[i],\r\n                perTokenEthValue: perTokenEthValue,\r\n                totalTokens: totalPlayerTokens,\r\n                tokensProcessed: 0\r\n            });\r\n\r\n            dividendWinners_.push(divWinner);\r\n        }\r\n\r\n        // We need to make sure we are allocating a valid set of dividend totals (i.e. not more than 100%)\r\n        // this is just to cover us for basic errors, this should never occur\r\n        require(totalPlayerAllocationPc == 100);\r\n    }\r\n\r\n    function allocateDividendsToWinners(uint _dividendWinnerId, address[] _winners, uint[] _tokenAllocation) external onlyOwnerOrReferee {\r\n        DividendWinner storage divWinner = dividendWinners_[_dividendWinnerId];\r\n        require(divWinner.totalTokens > 0); // Basic check to make sure we don't access a 0'd struct\r\n        require(divWinner.tokensProcessed < divWinner.totalTokens);\r\n        require(_winners.length == _tokenAllocation.length);\r\n\r\n        uint totalEthAssigned;\r\n        uint totalTokensAllocatedEth;\r\n        uint ethAllocation;\r\n        address winner;\r\n\r\n        for (uint i = 0; i < _winners.length; i++) {\r\n            winner = _winners[i];\r\n            ethAllocation = _tokenAllocation[i].mul(divWinner.perTokenEthValue);\r\n            addressToDividendBalance[winner] = addressToDividendBalance[winner].add(ethAllocation);\r\n            totalTokensAllocatedEth = totalTokensAllocatedEth.add(_tokenAllocation[i]);\r\n            totalEthAssigned = totalEthAssigned.add(ethAllocation);\r\n        }\r\n\r\n        // Update balancePendingWithdrawal_ - this allows us to get an accurate reflection of the div pool\r\n        balancePendingWithdrawal_ = balancePendingWithdrawal_.add(totalEthAssigned);\r\n\r\n        // As we will likely cause this function in batches this allows us to make sure we don't oversettle (failsafe)\r\n        divWinner.tokensProcessed = divWinner.tokensProcessed.add(totalTokensAllocatedEth);\r\n\r\n        // This should never occur, but a failsafe for when automated div payments are rolled out\r\n        require(divWinner.tokensProcessed <= divWinner.totalTokens);\r\n    }\r\n\r\n    function withdrawDividends() external {\r\n        require(addressToDividendBalance[msg.sender] > 0, \"Must have a valid dividend balance\");\r\n        uint senderBalance = addressToDividendBalance[msg.sender];\r\n        addressToDividendBalance[msg.sender] = 0;\r\n        balancePendingWithdrawal_ = balancePendingWithdrawal_.sub(senderBalance);\r\n        msg.sender.transfer(senderBalance);\r\n        emit DividendWithdrawal(msg.sender, senderBalance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToDividendBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dividendWinnerId\",\"type\":\"uint256\"},{\"name\":\"_winners\",\"type\":\"address[]\"},{\"name\":\"_tokenAllocation\",\"type\":\"uint256[]\"}],\"name\":\"allocateDividendsToWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint8\"},{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"setBuyDividendPercentageFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"portfolioSummary\",\"outputs\":[{\"name\":\"_playerTokenContractId\",\"type\":\"uint256[]\"},{\"name\":\"_totalTokens\",\"type\":\"uint256[]\"},{\"name\":\"_totalCost\",\"type\":\"int256[]\"},{\"name\":\"_totalValue\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referee\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPlayerTokenContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalDividendPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerTokenContracts_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"unpausePlayerContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newReferee\",\"type\":\"address\"}],\"name\":\"setReferee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_playerContractIds\",\"type\":\"uint256[]\"},{\"name\":\"_totalPlayerTokens\",\"type\":\"uint256[]\"},{\"name\":\"_individualPlayerAllocationPcs\",\"type\":\"uint8[]\"},{\"name\":\"_totalPrizePoolAllocationPc\",\"type\":\"uint256\"}],\"name\":\"setDividendWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"pausePlayerContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint8\"},{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"setSellDividendPercentageFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividendWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividendWinners_\",\"outputs\":[{\"name\":\"playerTokenContractId\",\"type\":\"uint256\"},{\"name\":\"perTokenEthValue\",\"type\":\"uint256\"},{\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"name\":\"tokensProcessed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allPlayerTokenContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_incrementalPrice\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_playerId\",\"type\":\"uint256\"},{\"name\":\"_promoSharesQuantity\",\"type\":\"uint8\"}],\"name\":\"newInitialPlayerOffering\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_referee\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"InitialPlayerOffering\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendWithdrawal\",\"type\":\"event\"}]","ContractName":"PlayerExchangeCore","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001b161b2f5c50a43c2395ef469546527a6b4d09e400000000000000000000000088d68e99bd7e803a0465235ef24189865f0130fd","Library":"","SwarmSource":"bzzr://385bed36813c46b3abeca865cce4aca5b4000b6aa88aef5aa39c2ea6214796b3"}]}