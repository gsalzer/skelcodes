{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic authorization control functions,\r\n/// this simplifies the implementation of \"user permissions\".\r\n/// @dev Based on OpenZeppelin's Ownable.\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed _by, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    /// @dev Constructor sets the original `owner` of the contract to the sender account.\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerCandidate() {\r\n        require(msg.sender == newOwnerCandidate);\r\n        _;\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        require(_newOwnerCandidate != address(0));\r\n\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accept ownership transfer. This method needs to be called by the perviously proposed owner.\r\n    function acceptOwnership() external onlyOwnerCandidate {\r\n        address previousOwner = owner;\r\n\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = address(0);\r\n\r\n        OwnershipTransferred(previousOwner, owner);\r\n    }\r\n}\r\n\r\n/// @title Math operations with safety checks\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // require(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function toPower2(uint256 a) internal pure returns (uint256) {\r\n        return mul(a, a);\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        uint256 c = (a + 1) / 2;\r\n        uint256 b = a;\r\n        while (c < b) {\r\n            b = c;\r\n            c = (a / c + c) / 2;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n\r\n/// @title ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/issues/20)\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n    function balanceOf(address _owner) constant public returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n/// @title ERC Token Standard #677 Interface (https://github.com/ethereum/EIPs/issues/677)\r\ncontract ERC677 is ERC20 {\r\n    function transferAndCall(address to, uint value, bytes data) public returns (bool ok);\r\n\r\n    event TransferAndCall(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\n/// @title ERC223Receiver Interface\r\n/// @dev Based on the specs form: https://github.com/ethereum/EIPs/issues/223\r\ncontract ERC223Receiver {\r\n    function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\r\n}\r\n\r\n\r\n\r\n\r\n/// @title Basic ERC20 token contract implementation.\r\n/// @dev Based on OpenZeppelin's StandardToken.\r\ncontract BasicToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public totalSupply;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => uint256) balances;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve (see NOTE)\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\r\n            revert();\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    /// @param _owner address The address which owns the funds.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @return uint256 specifying the amount of tokens still available for the spender.\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner address The address to query the the balance of.\r\n    /// @return uint256 representing the amount owned by the passed address.\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @dev Transfer token to a specified address.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another.\r\n    /// @param _from address The address which you want to send tokens from.\r\n    /// @param _to address The address which you want to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Standard677Token implentation, base on https://github.com/ethereum/EIPs/issues/677\r\n\r\ncontract Standard677Token is ERC677, BasicToken {\r\n\r\n  /// @dev ERC223 safe token transfer from one address to another\r\n  /// @param _to address the address which you want to transfer to.\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function transferAndCall(address _to, uint _value, bytes _data) public returns (bool) {\r\n    require(super.transfer(_to, _value)); // do a normal token transfer\r\n    TransferAndCall(msg.sender, _to, _value, _data);\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (isContract(_to)) return contractFallback(_to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  /// @dev called when transaction target is a contract\r\n  /// @param _to address the address which you want to transfer to.\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function contractFallback(address _to, uint _value, bytes _data) private returns (bool) {\r\n    ERC223Receiver receiver = ERC223Receiver(_to);\r\n    require(receiver.tokenFallback(msg.sender, _value, _data));\r\n    return true;\r\n  }\r\n\r\n  /// @dev check if the address is contract\r\n  /// assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  /// @param _addr address the address to check\r\n  function isContract(address _addr) private constant returns (bool is_contract) {\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Token holder contract.\r\ncontract TokenHolder is Ownable {\r\n    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n    /// @param _tokenAddress address The address of the ERC20 contract.\r\n    /// @param _amount uint256 The amount of tokens to be transferred.\r\n    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\r\n        return ERC20(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Colu Local Network contract.\r\n/// @author Tal Beja.\r\ncontract ColuLocalNetwork is Ownable, Standard677Token, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Colu Local Network\";\r\n    string public constant symbol = \"CLN\";\r\n\r\n    // Using same decimals value as ETH (makes ETH-CLN conversion much easier).\r\n    uint8 public constant decimals = 18;\r\n\r\n    // States whether token transfers is allowed or not.\r\n    // Used during token sale.\r\n    bool public isTransferable = false;\r\n\r\n    event TokensTransferable();\r\n\r\n    modifier transferable() {\r\n        require(msg.sender == owner || isTransferable);\r\n        _;\r\n    }\r\n\r\n    /// @dev Creates all tokens and gives them to the owner.\r\n    function ColuLocalNetwork(uint256 _totalSupply) public {\r\n        totalSupply = _totalSupply;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n\r\n    /// @dev start transferable mode.\r\n    function makeTokensTransferable() external onlyOwner {\r\n        if (isTransferable) {\r\n            return;\r\n        }\r\n\r\n        isTransferable = true;\r\n\r\n        TokensTransferable();\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if not transferable.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public transferable returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if not transferable.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public transferable returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if not transferable.\r\n    /// @param _from address The address to send tokens from.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public transferable returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /// @dev Same ERC677 behavior, but reverts if not transferable.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    /// @param _data bytes data to send to receiver if it is a contract.\r\n    function transferAndCall(address _to, uint _value, bytes _data) public transferable returns (bool success) {\r\n      return super.transferAndCall(_to, _value, _data);\r\n    }\r\n}\r\n\r\n\r\n\r\n /// @title Standard ERC223 Token Receiver implementing tokenFallback function and tokenPayable modifier\r\n\r\ncontract Standard223Receiver is ERC223Receiver {\r\n  Tkn tkn;\r\n\r\n  struct Tkn {\r\n    address addr;\r\n    address sender; // the transaction caller\r\n    uint256 value;\r\n  }\r\n\r\n  bool __isTokenFallback;\r\n\r\n  modifier tokenPayable {\r\n    require(__isTokenFallback);\r\n    _;\r\n  }\r\n\r\n  /// @dev Called when the receiver of transfer is contract\r\n  /// @param _sender address the address of tokens sender\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\r\n    if (!supportsToken(msg.sender)) {\r\n      return false;\r\n    }\r\n\r\n    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\r\n    // Solution: Remove the the data\r\n    tkn = Tkn(msg.sender, _sender, _value);\r\n    __isTokenFallback = true;\r\n    if (!address(this).delegatecall(_data)) {\r\n      __isTokenFallback = false;\r\n      return false;\r\n    }\r\n    // avoid doing an overwrite to .token, which would be more expensive\r\n    // makes accessing .tkn values outside tokenPayable functions unsafe\r\n    __isTokenFallback = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function supportsToken(address token) public constant returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title TokenOwnable\r\n/// @dev The TokenOwnable contract adds a onlyTokenOwner modifier as a tokenReceiver with ownable addaptation\r\n\r\ncontract TokenOwnable is Standard223Receiver, Ownable {\r\n    /// @dev Reverts if called by any account other than the owner for token sending.\r\n    modifier onlyTokenOwner() {\r\n        require(tkn.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Vesting trustee contract for Colu Local Network.\r\n/// @dev This Contract can't be TokenHolder, since it will allow its owner to drain its vested tokens.\r\n/// @dev This means that any token sent to it different than ColuLocalNetwork is basicly stucked here forever.\r\n/// @dev ColuLocalNetwork that sent here (by mistake) can withdrawn using the grant method.\r\ncontract VestingTrustee is TokenOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    // Colu Local Network contract.\r\n    ColuLocalNetwork public cln;\r\n\r\n    // Vesting grant for a speicifc holder.\r\n    struct Grant {\r\n        uint256 value;\r\n        uint256 start;\r\n        uint256 cliff;\r\n        uint256 end;\r\n        uint256 installmentLength; // In seconds.\r\n        uint256 transferred;\r\n        bool revokable;\r\n    }\r\n\r\n    // Holder to grant information mapping.\r\n    mapping (address => Grant) public grants;\r\n\r\n    // Total tokens vested.\r\n    uint256 public totalVesting;\r\n\r\n    event NewGrant(address indexed _from, address indexed _to, uint256 _value);\r\n    event TokensUnlocked(address indexed _to, uint256 _value);\r\n    event GrantRevoked(address indexed _holder, uint256 _refund);\r\n\r\n    uint constant OK = 1;\r\n    uint constant ERR_INVALID_VALUE = 10001;\r\n    uint constant ERR_INVALID_VESTED = 10002;\r\n    uint constant ERR_INVALID_TRANSFERABLE = 10003;\r\n\r\n    event Error(address indexed sender, uint error);\r\n\r\n    /// @dev Constructor that initializes the address of the Colu Local Network contract.\r\n    /// @param _cln ColuLocalNetwork The address of the previously deployed Colu Local Network contract.\r\n    function VestingTrustee(ColuLocalNetwork _cln) public {\r\n        require(_cln != address(0));\r\n\r\n        cln = _cln;\r\n    }\r\n\r\n    /// @dev Allow only cln token to be tokenPayable\r\n    /// @param token the token to check\r\n    function supportsToken(address token) public constant returns (bool) {\r\n        return (cln == token);\r\n    }\r\n\r\n    /// @dev Grant tokens to a specified address.\r\n    /// @param _to address The holder address.\r\n    /// @param _start uint256 The beginning of the vesting period (timestamp).\r\n    /// @param _cliff uint256 When the first installment is made (timestamp).\r\n    /// @param _end uint256 The end of the vesting period (timestamp).\r\n    /// @param _installmentLength uint256 The length of each vesting installment (in seconds).\r\n    /// @param _revokable bool Whether the grant is revokable or not.\r\n    function grant(address _to, uint256 _start, uint256 _cliff, uint256 _end,\r\n        uint256 _installmentLength, bool _revokable)\r\n        external onlyTokenOwner tokenPayable {\r\n\r\n        require(_to != address(0));\r\n        require(_to != address(this)); // Protect this contract from receiving a grant.\r\n\r\n        uint256 value = tkn.value;\r\n\r\n        require(value > 0);\r\n\r\n        // Require that every holder can be granted tokens only once.\r\n        require(grants[_to].value == 0);\r\n\r\n        // Require for time ranges to be consistent and valid.\r\n        require(_start <= _cliff && _cliff <= _end);\r\n\r\n        // Require installment length to be valid and no longer than (end - start).\r\n        require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\r\n\r\n        // Grant must not exceed the total amount of tokens currently available for vesting.\r\n        require(totalVesting.add(value) <= cln.balanceOf(address(this)));\r\n\r\n        // Assign a new grant.\r\n        grants[_to] = Grant({\r\n            value: value,\r\n            start: _start,\r\n            cliff: _cliff,\r\n            end: _end,\r\n            installmentLength: _installmentLength,\r\n            transferred: 0,\r\n            revokable: _revokable\r\n        });\r\n\r\n        // Since tokens have been granted, increase the total amount vested.\r\n        totalVesting = totalVesting.add(value);\r\n\r\n        NewGrant(msg.sender, _to, value);\r\n    }\r\n\r\n    /// @dev Grant tokens to a specified address.\r\n    /// @param _to address The holder address.\r\n    /// @param _value uint256 The amount of tokens to be granted.\r\n    /// @param _start uint256 The beginning of the vesting period (timestamp).\r\n    /// @param _cliff uint256 When the first installment is made (timestamp).\r\n    /// @param _end uint256 The end of the vesting period (timestamp).\r\n    /// @param _installmentLength uint256 The length of each vesting installment (in seconds).\r\n    /// @param _revokable bool Whether the grant is revokable or not.\r\n    function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\r\n        uint256 _installmentLength, bool _revokable)\r\n        external onlyOwner {\r\n\r\n        require(_to != address(0));\r\n        require(_to != address(this)); // Protect this contract from receiving a grant.\r\n        require(_value > 0);\r\n\r\n        // Require that every holder can be granted tokens only once.\r\n        require(grants[_to].value == 0);\r\n\r\n        // Require for time ranges to be consistent and valid.\r\n        require(_start <= _cliff && _cliff <= _end);\r\n\r\n        // Require installment length to be valid and no longer than (end - start).\r\n        require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\r\n\r\n        // Grant must not exceed the total amount of tokens currently available for vesting.\r\n        require(totalVesting.add(_value) <= cln.balanceOf(address(this)));\r\n\r\n        // Assign a new grant.\r\n        grants[_to] = Grant({\r\n            value: _value,\r\n            start: _start,\r\n            cliff: _cliff,\r\n            end: _end,\r\n            installmentLength: _installmentLength,\r\n            transferred: 0,\r\n            revokable: _revokable\r\n        });\r\n\r\n        // Since tokens have been granted, increase the total amount vested.\r\n        totalVesting = totalVesting.add(_value);\r\n\r\n        NewGrant(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @dev Revoke the grant of tokens of a specifed address.\r\n    /// @dev Unlocked tokens will be sent to the grantee, the rest is transferred to the trustee's owner.\r\n    /// @param _holder The address which will have its tokens revoked.\r\n    function revoke(address _holder) public onlyOwner {\r\n        Grant memory grant = grants[_holder];\r\n\r\n        // Grant must be revokable.\r\n        require(grant.revokable);\r\n\r\n        // Get the total amount of vested tokens, acccording to grant.\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n\r\n        // Calculate the untransferred vested tokens.\r\n        uint256 transferable = vested.sub(grant.transferred);\r\n\r\n        if (transferable > 0) {\r\n            // Update transferred and total vesting amount, then transfer remaining vested funds to holder.\r\n            grant.transferred = grant.transferred.add(transferable);\r\n            totalVesting = totalVesting.sub(transferable);\r\n            require(cln.transfer(_holder, transferable));\r\n\r\n            TokensUnlocked(_holder, transferable);\r\n        }\r\n\r\n        // Calculate amount of remaining tokens that can still be returned.\r\n        uint256 refund = grant.value.sub(grant.transferred);\r\n\r\n        // Remove the grant.\r\n        delete grants[_holder];\r\n\r\n        // Update total vesting amount and transfer previously calculated tokens to owner.\r\n        totalVesting = totalVesting.sub(refund);\r\n        require(cln.transfer(msg.sender, refund));\r\n\r\n        GrantRevoked(_holder, refund);\r\n    }\r\n\r\n    /// @dev Calculate the amount of ready tokens of a holder.\r\n    /// @param _holder address The address of the holder.\r\n    /// @return a uint256 Representing a holder's total amount of vested tokens.\r\n    function readyTokens(address _holder) public constant returns (uint256) {\r\n        Grant memory grant = grants[_holder];\r\n\r\n        if (grant.value == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n\r\n        if (vested == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return vested.sub(grant.transferred);\r\n    }\r\n\r\n    /// @dev Calculate the total amount of vested tokens of a holder at a given time.\r\n    /// @param _holder address The address of the holder.\r\n    /// @param _time uint256 The specific time to calculate against.\r\n    /// @return a uint256 Representing a holder's total amount of vested tokens.\r\n    function vestedTokens(address _holder, uint256 _time) public constant returns (uint256) {\r\n        Grant memory grant = grants[_holder];\r\n        if (grant.value == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return calculateVestedTokens(grant, _time);\r\n    }\r\n\r\n    /// @dev Calculate amount of vested tokens at a specifc time.\r\n    /// @param _grant Grant The vesting grant.\r\n    /// @param _time uint256 The time to be checked\r\n    /// @return An uint256 Representing the amount of vested tokens of a specific grant.\r\n    function calculateVestedTokens(Grant _grant, uint256 _time) private pure returns (uint256) {\r\n        // If we're before the cliff, then nothing is vested.\r\n        if (_time < _grant.cliff) {\r\n            return 0;\r\n        }\r\n\r\n        // If we're after the end of the vesting period - everything is vested.\r\n        if (_time >= _grant.end) {\r\n            return _grant.value;\r\n        }\r\n\r\n        // Calculate amount of installments past until now.\r\n        //\r\n        // NOTE: result gets floored because of integer division.\r\n        uint256 installmentsPast = _time.sub(_grant.start).div(_grant.installmentLength);\r\n\r\n        // Calculate amount of days in entire vesting period.\r\n        uint256 vestingDays = _grant.end.sub(_grant.start);\r\n\r\n        // Calculate and return the number of tokens according to vesting days that have passed.\r\n        return _grant.value.mul(installmentsPast.mul(_grant.installmentLength)).div(vestingDays);\r\n    }\r\n\r\n    /// @dev Unlock vested tokens and transfer them to the grantee.\r\n    /// @return a uint The success or error code.\r\n    function unlockVestedTokens() external returns (uint) {\r\n        return unlockVestedTokens(msg.sender);\r\n    }\r\n\r\n    /// @dev Unlock vested tokens and transfer them to the grantee (helper function).\r\n    /// @param _grantee address The address of the grantee.\r\n    /// @return a uint The success or error code.\r\n    function unlockVestedTokens(address _grantee) private returns (uint) {\r\n        Grant storage grant = grants[_grantee];\r\n\r\n        // Make sure the grant has tokens available.\r\n        if (grant.value == 0) {\r\n            Error(_grantee, ERR_INVALID_VALUE);\r\n            return ERR_INVALID_VALUE;\r\n        }\r\n\r\n        // Get the total amount of vested tokens, acccording to grant.\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n        if (vested == 0) {\r\n            Error(_grantee, ERR_INVALID_VESTED);\r\n            return ERR_INVALID_VESTED;\r\n        }\r\n\r\n        // Make sure the holder doesn't transfer more than what he already has.\r\n        uint256 transferable = vested.sub(grant.transferred);\r\n        if (transferable == 0) {\r\n            Error(_grantee, ERR_INVALID_TRANSFERABLE);\r\n            return ERR_INVALID_TRANSFERABLE;\r\n        }\r\n\r\n        // Update transferred and total vesting amount, then transfer remaining vested funds to holder.\r\n        grant.transferred = grant.transferred.add(transferable);\r\n        totalVesting = totalVesting.sub(transferable);\r\n        require(cln.transfer(_grantee, transferable));\r\n\r\n        TokensUnlocked(_grantee, transferable);\r\n        return OK;\r\n    }\r\n\r\n    /// @dev batchUnlockVestedTokens vested tokens and transfer them to the grantees.\r\n    /// @param _grantees address[] The addresses of the grantees.\r\n    /// @return a boo if success.\r\n    function batchUnlockVestedTokens(address[] _grantees) external onlyOwner returns (bool success) {\r\n        for (uint i = 0; i<_grantees.length; i++) {\r\n            unlockVestedTokens(_grantees[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n    /// @param _tokenAddress address The address of the ERC20 contract.\r\n    /// @param _amount uint256 The amount of tokens to be transferred.\r\n    function withdrawERC20(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\r\n        if (_tokenAddress == address(cln)) {\r\n            // If the token is cln, allow to withdraw only non vested tokens.\r\n            uint256 availableCLN = cln.balanceOf(this).sub(totalVesting);\r\n            require(_amount <= availableCLN);\r\n        }\r\n        return ERC20(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"supportsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"vestedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_grantees\",\"type\":\"address[]\"}],\"name\":\"batchUnlockVestedTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_installmentLength\",\"type\":\"uint256\"},{\"name\":\"_revokable\",\"type\":\"bool\"}],\"name\":\"grant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"readyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockVestedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cln\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_installmentLength\",\"type\":\"uint256\"},{\"name\":\"_revokable\",\"type\":\"bool\"}],\"name\":\"grant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"grants\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"cliff\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"installmentLength\",\"type\":\"uint256\"},{\"name\":\"transferred\",\"type\":\"uint256\"},{\"name\":\"revokable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_cln\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"NewGrant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokensUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_refund\",\"type\":\"uint256\"}],\"name\":\"GrantRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"VestingTrustee","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004162178B78D6985480A308B2190EE5517460406D","Library":"","SwarmSource":"bzzr://23e279ba6dd17c7f0a8770f361cf7543be16a96d1d1db31ee899c3caf7ddfa8d"}]}