{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\n/**\r\n *@title abstract TokenContract\r\n *@dev  token contract to call multisig functions\r\n*/\r\ncontract TokenContract{\r\n  function mint(address _to, uint256 _amount) public;\r\n  function finishMinting () public;\r\n  function setupMultisig (address _address) public;\r\n}\r\n\r\n/**\r\n *@title contract GangMultisig\r\n *@dev using multisig access to call another contract functions\r\n*/\r\ncontract GangMultisig {\r\n  \r\n  /**\r\n   *@dev token contract variable, contains token address\r\n   *can use abstract contract functions\r\n  */\r\n  TokenContract public token;\r\n\r\n  //@dev Variable to check multisig functions life time.\r\n  //change it before deploy in main network\r\n  uint public lifeTime = 86400; // seconds;\r\n  \r\n  //@dev constructor\r\n  constructor (address _token, uint _needApprovesToConfirm, address[] _owners) public{\r\n    require (_needApprovesToConfirm > 1 && _needApprovesToConfirm <= _owners.length);\r\n    \r\n    //@dev setup GangTokenContract by contract address\r\n    token = TokenContract(_token);\r\n\r\n    addInitialOwners(_owners);\r\n\r\n    needApprovesToConfirm = _needApprovesToConfirm;\r\n\r\n    /**\r\n     *@dev Call function setupMultisig in token contract\r\n     *This function can be call once.\r\n    */\r\n    token.setupMultisig(address(this));\r\n    \r\n    ownersCount = _owners.length;\r\n  }\r\n\r\n  /**\r\n   *@dev internal function, called in constructor\r\n   *Add initial owners in mapping 'owners'\r\n  */\r\n  function addInitialOwners (address[] _owners) internal {\r\n    for (uint i = 0; i < _owners.length; i++){\r\n      //@dev check for duplicate owner addresses\r\n      require(!owners[_owners[i]]);\r\n      owners[_owners[i]] = true;\r\n    }\r\n  }\r\n\r\n  //@dev variable to check is minting finished;\r\n  bool public mintingFinished = false;\r\n\r\n  //@dev Mapping which contains all active owners.\r\n  mapping (address => bool) public owners;\r\n\r\n  //@dev Owner can add new proposal 1 time at each lifeTime cycle\r\n  mapping (address => uint32) public lastOwnersAction;\r\n  \r\n  modifier canCreate() { \r\n    require (lastOwnersAction[msg.sender] + lifeTime < now);\r\n    lastOwnersAction[msg.sender] = uint32(now);\r\n    _; \r\n  }\r\n  \r\n\r\n  //@dev Modifier to check is message sender contains in mapping 'owners'.\r\n  modifier onlyOwners() { \r\n    require (owners[msg.sender]); \r\n    _; \r\n  }\r\n\r\n  //@dev current owners count\r\n  uint public ownersCount;\r\n\r\n  //@dev current approves need to confirm for any function. Can't be less than 2. \r\n  uint public needApprovesToConfirm;\r\n\r\n  //Start Minting Tokens\r\n  struct SetNewMint {\r\n    address spender;\r\n    uint value;\r\n    uint8 confirms;\r\n    bool isExecute;\r\n    address initiator;\r\n    bool isCanceled;\r\n    uint32 creationTimestamp;\r\n    address[] confirmators;\r\n  }\r\n\r\n  //@dev Variable which contains all information about current SetNewMint request\r\n  SetNewMint public setNewMint;\r\n\r\n  event NewMintRequestSetup(address indexed initiator, address indexed spender, uint value);\r\n  event NewMintRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\r\n  event NewMintRequestCanceled();  \r\n\r\n  /**\r\n   * @dev Set new mint request, can be call only by owner\r\n   * @param _spender address The address which you want to mint to\r\n   * @param _value uint256 the amount of tokens to be minted\r\n   */\r\n  function setNewMintRequest (address _spender, uint _value) public onlyOwners canCreate {\r\n    require (setNewMint.creationTimestamp + lifeTime < uint32(now) || setNewMint.isExecute || setNewMint.isCanceled);\r\n\r\n    require (!mintingFinished);\r\n\r\n    address[] memory addr;\r\n\r\n    setNewMint = SetNewMint(_spender, _value, 1, false, msg.sender, false, uint32(now), addr);\r\n    setNewMint.confirmators.push(msg.sender);\r\n\r\n    emit NewMintRequestSetup(msg.sender, _spender, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve mint request, can be call only by owner\r\n   * which don't call this mint request before.\r\n   */\r\n  function approveNewMintRequest () public onlyOwners {\r\n    require (!setNewMint.isExecute && !setNewMint.isCanceled);\r\n    require (setNewMint.creationTimestamp + lifeTime >= uint32(now));\r\n\r\n    require (!mintingFinished);\r\n\r\n    for (uint i = 0; i < setNewMint.confirmators.length; i++){\r\n      require(setNewMint.confirmators[i] != msg.sender);\r\n    }\r\n      \r\n    setNewMint.confirms++;\r\n    setNewMint.confirmators.push(msg.sender);\r\n\r\n    if(setNewMint.confirms >= needApprovesToConfirm){\r\n      setNewMint.isExecute = true;\r\n\r\n      token.mint(setNewMint.spender, setNewMint.value); \r\n    }\r\n    emit NewMintRequestUpdate(msg.sender, setNewMint.confirms, setNewMint.isExecute);\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel mint request, can be call only by owner\r\n   * which created this mint request.\r\n   */\r\n  function cancelMintRequest () public {\r\n    require (msg.sender == setNewMint.initiator);    \r\n    require (!setNewMint.isCanceled && !setNewMint.isExecute);\r\n\r\n    setNewMint.isCanceled = true;\r\n    emit NewMintRequestCanceled();\r\n  }\r\n  //Finish Minting Tokens\r\n\r\n  //Start finishMinting functions\r\n  struct FinishMintingStruct {\r\n    uint8 confirms;\r\n    bool isExecute;\r\n    address initiator;\r\n    bool isCanceled;\r\n    uint32 creationTimestamp;\r\n    address[] confirmators;\r\n  }\r\n\r\n  //@dev Variable which contains all information about current finishMintingStruct request\r\n  FinishMintingStruct public finishMintingStruct;\r\n\r\n  event FinishMintingRequestSetup(address indexed initiator);\r\n  event FinishMintingRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\r\n  event FinishMintingRequestCanceled();\r\n  event FinishMintingApproveCanceled(address owner);\r\n\r\n  /**\r\n   * @dev New finish minting request, can be call only by owner\r\n   */\r\n  function finishMintingRequestSetup () public onlyOwners canCreate{\r\n    require ((finishMintingStruct.creationTimestamp + lifeTime < uint32(now) || finishMintingStruct.isCanceled) && !finishMintingStruct.isExecute);\r\n    \r\n    require (!mintingFinished);\r\n\r\n    address[] memory addr;\r\n\r\n    finishMintingStruct = FinishMintingStruct(1, false, msg.sender, false, uint32(now), addr);\r\n    finishMintingStruct.confirmators.push(msg.sender);\r\n\r\n    emit FinishMintingRequestSetup(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve finish minting request, can be call only by owner\r\n   * which don't call this finish minting request before.\r\n   */\r\n  function ApproveFinishMintingRequest () public onlyOwners {\r\n    require (!finishMintingStruct.isCanceled && !finishMintingStruct.isExecute);\r\n    require (finishMintingStruct.creationTimestamp + lifeTime >= uint32(now));\r\n\r\n    require (!mintingFinished);\r\n\r\n    for (uint i = 0; i < finishMintingStruct.confirmators.length; i++){\r\n      require(finishMintingStruct.confirmators[i] != msg.sender);\r\n    }\r\n\r\n    finishMintingStruct.confirmators.push(msg.sender);\r\n\r\n    finishMintingStruct.confirms++;\r\n\r\n    if(finishMintingStruct.confirms >= needApprovesToConfirm){\r\n      token.finishMinting();\r\n      finishMintingStruct.isExecute = true;\r\n      mintingFinished = true;\r\n    }\r\n    \r\n    emit FinishMintingRequestUpdate(msg.sender, finishMintingStruct.confirms, finishMintingStruct.isExecute);\r\n  }\r\n  \r\n  /**\r\n   * @dev Cancel finish minting request, can be call only by owner\r\n   * which created this finish minting request.\r\n   */\r\n  function cancelFinishMintingRequest () public {\r\n    require (msg.sender == finishMintingStruct.initiator);\r\n    require (!finishMintingStruct.isCanceled);\r\n\r\n    finishMintingStruct.isCanceled = true;\r\n    emit FinishMintingRequestCanceled();\r\n  }\r\n  //Finish finishMinting functions\r\n\r\n  //Start change approves count\r\n  struct SetNewApproves {\r\n    uint count;\r\n    uint8 confirms;\r\n    bool isExecute;\r\n    address initiator;\r\n    bool isCanceled;\r\n    uint32 creationTimestamp;\r\n    address[] confirmators;\r\n  }\r\n\r\n  //@dev Variable which contains all information about current setNewApproves request\r\n  SetNewApproves public setNewApproves;\r\n\r\n  event NewNeedApprovesToConfirmRequestSetup(address indexed initiator, uint count);\r\n  event NewNeedApprovesToConfirmRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\r\n  event NewNeedApprovesToConfirmRequestCanceled();\r\n\r\n  /**\r\n   * @dev Function to change 'needApprovesToConfirm' variable, can be call only by owner\r\n   * @param _count uint256 New need approves to confirm will needed\r\n   */\r\n  function setNewOwnersCountToApprove (uint _count) public onlyOwners canCreate {\r\n    require (setNewApproves.creationTimestamp + lifeTime < uint32(now) || setNewApproves.isExecute || setNewApproves.isCanceled);\r\n\r\n    require (_count > 1);\r\n\r\n    address[] memory addr;\r\n\r\n    setNewApproves = SetNewApproves(_count, 1, false, msg.sender,false, uint32(now), addr);\r\n    setNewApproves.confirmators.push(msg.sender);\r\n\r\n    emit NewNeedApprovesToConfirmRequestSetup(msg.sender, _count);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve new owners count request, can be call only by owner\r\n   * which don't call this new owners count request before.\r\n   */\r\n  function approveNewOwnersCount () public onlyOwners {\r\n    require (setNewApproves.count <= ownersCount);\r\n    require (setNewApproves.creationTimestamp + lifeTime >= uint32(now));\r\n    \r\n    for (uint i = 0; i < setNewApproves.confirmators.length; i++){\r\n      require(setNewApproves.confirmators[i] != msg.sender);\r\n    }\r\n    \r\n    require (!setNewApproves.isExecute && !setNewApproves.isCanceled);\r\n    \r\n    setNewApproves.confirms++;\r\n    setNewApproves.confirmators.push(msg.sender);\r\n\r\n    if(setNewApproves.confirms >= needApprovesToConfirm){\r\n      setNewApproves.isExecute = true;\r\n\r\n      needApprovesToConfirm = setNewApproves.count;   \r\n    }\r\n    emit NewNeedApprovesToConfirmRequestUpdate(msg.sender, setNewApproves.confirms, setNewApproves.isExecute);\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel new owners count request, can be call only by owner\r\n   * which created this owners count request.\r\n   */\r\n  function cancelNewOwnersCountRequest () public {\r\n    require (msg.sender == setNewApproves.initiator);    \r\n    require (!setNewApproves.isCanceled && !setNewApproves.isExecute);\r\n\r\n    setNewApproves.isCanceled = true;\r\n    emit NewNeedApprovesToConfirmRequestCanceled();\r\n  }\r\n  \r\n  //Finish change approves count\r\n\r\n  //Start add new owner\r\n  struct NewOwner {\r\n    address newOwner;\r\n    uint8 confirms;\r\n    bool isExecute;\r\n    address initiator;\r\n    bool isCanceled;\r\n    uint32 creationTimestamp;\r\n    address[] confirmators;\r\n  }\r\n\r\n  NewOwner public addOwner;\r\n  //@dev Variable which contains all information about current addOwner request\r\n\r\n  event AddOwnerRequestSetup(address indexed initiator, address newOwner);\r\n  event AddOwnerRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\r\n  event AddOwnerRequestCanceled();\r\n\r\n  /**\r\n   * @dev Function to add new owner in mapping 'owners', can be call only by owner\r\n   * @param _newOwner address new potentially owner\r\n   */\r\n  function setAddOwnerRequest (address _newOwner) public onlyOwners canCreate {\r\n    require (addOwner.creationTimestamp + lifeTime < uint32(now) || addOwner.isExecute || addOwner.isCanceled);\r\n    \r\n    address[] memory addr;\r\n\r\n    addOwner = NewOwner(_newOwner, 1, false, msg.sender, false, uint32(now), addr);\r\n    addOwner.confirmators.push(msg.sender);\r\n\r\n    emit AddOwnerRequestSetup(msg.sender, _newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve new owner request, can be call only by owner\r\n   * which don't call this new owner request before.\r\n   */\r\n  function approveAddOwnerRequest () public onlyOwners {\r\n    require (!addOwner.isExecute && !addOwner.isCanceled);\r\n    require (addOwner.creationTimestamp + lifeTime >= uint32(now));\r\n\r\n    /**\r\n     *@dev new owner shoudn't be in owners mapping\r\n     */\r\n    require (!owners[addOwner.newOwner]);\r\n\r\n    for (uint i = 0; i < addOwner.confirmators.length; i++){\r\n      require(addOwner.confirmators[i] != msg.sender);\r\n    }\r\n    \r\n    addOwner.confirms++;\r\n    addOwner.confirmators.push(msg.sender);\r\n\r\n    if(addOwner.confirms >= needApprovesToConfirm){\r\n      addOwner.isExecute = true;\r\n\r\n      owners[addOwner.newOwner] = true;\r\n      ownersCount++;\r\n    }\r\n\r\n    emit AddOwnerRequestUpdate(msg.sender, addOwner.confirms, addOwner.isExecute);\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel new owner request, can be call only by owner\r\n   * which created this add owner request.\r\n   */\r\n  function cancelAddOwnerRequest() public {\r\n    require (msg.sender == addOwner.initiator);\r\n    require (!addOwner.isCanceled && !addOwner.isExecute);\r\n\r\n    addOwner.isCanceled = true;\r\n    emit AddOwnerRequestCanceled();\r\n  }\r\n  //Finish add new owner\r\n\r\n  //Start remove owner\r\n  NewOwner public removeOwners;\r\n  //@dev Variable which contains all information about current removeOwners request\r\n\r\n  event RemoveOwnerRequestSetup(address indexed initiator, address newOwner);\r\n  event RemoveOwnerRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\r\n  event RemoveOwnerRequestCanceled();\r\n\r\n  /**\r\n   * @dev Function to remove owner from mapping 'owners', can be call only by owner\r\n   * @param _removeOwner address potentially owner to remove\r\n   */\r\n  function removeOwnerRequest (address _removeOwner) public onlyOwners canCreate {\r\n    require (removeOwners.creationTimestamp + lifeTime < uint32(now) || removeOwners.isExecute || removeOwners.isCanceled);\r\n\r\n    address[] memory addr;\r\n    \r\n    removeOwners = NewOwner(_removeOwner, 1, false, msg.sender, false, uint32(now), addr);\r\n    removeOwners.confirmators.push(msg.sender);\r\n\r\n    emit RemoveOwnerRequestSetup(msg.sender, _removeOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve remove owner request, can be call only by owner\r\n   * which don't call this remove owner request before.\r\n   */\r\n  function approveRemoveOwnerRequest () public onlyOwners {\r\n    require (ownersCount - 1 >= needApprovesToConfirm && ownersCount > 2);\r\n\r\n    require (owners[removeOwners.newOwner]);\r\n    \r\n    require (!removeOwners.isExecute && !removeOwners.isCanceled);\r\n    require (removeOwners.creationTimestamp + lifeTime >= uint32(now));\r\n\r\n    for (uint i = 0; i < removeOwners.confirmators.length; i++){\r\n      require(removeOwners.confirmators[i] != msg.sender);\r\n    }\r\n    \r\n    removeOwners.confirms++;\r\n    removeOwners.confirmators.push(msg.sender);\r\n\r\n    if(removeOwners.confirms >= needApprovesToConfirm){\r\n      removeOwners.isExecute = true;\r\n\r\n      owners[removeOwners.newOwner] = false;\r\n      ownersCount--;\r\n\r\n      _removeOwnersAproves(removeOwners.newOwner);\r\n    }\r\n\r\n    emit RemoveOwnerRequestUpdate(msg.sender, removeOwners.confirms, removeOwners.isExecute);\r\n  }\r\n\r\n  \r\n  /**\r\n   * @dev Cancel remove owner request, can be call only by owner\r\n   * which created this remove owner request.\r\n   */\r\n  function cancelRemoveOwnerRequest () public {\r\n    require (msg.sender == removeOwners.initiator);    \r\n    require (!removeOwners.isCanceled && !removeOwners.isExecute);\r\n\r\n    removeOwners.isCanceled = true;\r\n    emit RemoveOwnerRequestCanceled();\r\n  }\r\n  //Finish remove owner\r\n\r\n  //Start remove 2nd owner\r\n  NewOwner public removeOwners2;\r\n  //@dev Variable which contains all information about current removeOwners request\r\n\r\n  event RemoveOwnerRequestSetup2(address indexed initiator, address newOwner);\r\n  event RemoveOwnerRequestUpdate2(address indexed owner, uint8 indexed confirms, bool isExecute);\r\n  event RemoveOwnerRequestCanceled2();\r\n\r\n  /**\r\n   * @dev Function to remove owner from mapping 'owners', can be call only by owner\r\n   * @param _removeOwner address potentially owner to remove\r\n   */\r\n  function removeOwnerRequest2 (address _removeOwner) public onlyOwners canCreate {\r\n    require (removeOwners2.creationTimestamp + lifeTime < uint32(now) || removeOwners2.isExecute || removeOwners2.isCanceled);\r\n\r\n    address[] memory addr;\r\n    \r\n    removeOwners2 = NewOwner(_removeOwner, 1, false, msg.sender, false, uint32(now), addr);\r\n    removeOwners2.confirmators.push(msg.sender);\r\n\r\n    emit RemoveOwnerRequestSetup2(msg.sender, _removeOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Approve remove owner request, can be call only by owner\r\n   * which don't call this remove owner request before.\r\n   */\r\n  function approveRemoveOwnerRequest2 () public onlyOwners {\r\n    require (ownersCount - 1 >= needApprovesToConfirm && ownersCount > 2);\r\n\r\n    require (owners[removeOwners2.newOwner]);\r\n    \r\n    require (!removeOwners2.isExecute && !removeOwners2.isCanceled);\r\n    require (removeOwners2.creationTimestamp + lifeTime >= uint32(now));\r\n\r\n    for (uint i = 0; i < removeOwners2.confirmators.length; i++){\r\n      require(removeOwners2.confirmators[i] != msg.sender);\r\n    }\r\n    \r\n    removeOwners2.confirms++;\r\n    removeOwners2.confirmators.push(msg.sender);\r\n\r\n    if(removeOwners2.confirms >= needApprovesToConfirm){\r\n      removeOwners2.isExecute = true;\r\n\r\n      owners[removeOwners2.newOwner] = false;\r\n      ownersCount--;\r\n\r\n      _removeOwnersAproves(removeOwners2.newOwner);\r\n    }\r\n\r\n    emit RemoveOwnerRequestUpdate2(msg.sender, removeOwners2.confirms, removeOwners2.isExecute);\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel remove owner request, can be call only by owner\r\n   * which created this remove owner request.\r\n   */\r\n  function cancelRemoveOwnerRequest2 () public {\r\n    require (msg.sender == removeOwners2.initiator);    \r\n    require (!removeOwners2.isCanceled && !removeOwners2.isExecute);\r\n\r\n    removeOwners2.isCanceled = true;\r\n    emit RemoveOwnerRequestCanceled2();\r\n  }\r\n  //Finish remove 2nd owner\r\n\r\n  /**\r\n   * @dev internal function to check and revert all actions\r\n   * by removed owner in this contract.\r\n   * If _oldOwner created request then it will be canceled.\r\n   * If _oldOwner approved request then his approve will canceled.\r\n   */\r\n  function _removeOwnersAproves(address _oldOwner) internal{\r\n    //@dev check actions in setNewMint requests\r\n    //@dev check for empty struct\r\n    if (setNewMint.initiator != address(0)){\r\n      //@dev check, can this request be approved by someone, if no then no sense to change something\r\n      if (setNewMint.creationTimestamp + lifeTime >= uint32(now) && !setNewMint.isExecute && !setNewMint.isCanceled){\r\n        if(setNewMint.initiator == _oldOwner){\r\n          setNewMint.isCanceled = true;\r\n          emit NewMintRequestCanceled();\r\n        }else{\r\n          //@dev Trying to find _oldOwner in struct confirmators\r\n          for (uint i = 0; i < setNewMint.confirmators.length; i++){\r\n            if (setNewMint.confirmators[i] == _oldOwner){\r\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\r\n              setNewMint.confirmators[i] = address(0);\r\n              setNewMint.confirms--;\r\n\r\n              /**\r\n               *@dev Struct can be confirmed each owner just once\r\n               *so no sence to continue loop\r\n               */\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**@dev check actions in finishMintingStruct requests\r\n     * check for empty struct\r\n     */\r\n    if (finishMintingStruct.initiator != address(0)){\r\n      //@dev check, can this request be approved by someone, if no then no sense to change something\r\n      if (finishMintingStruct.creationTimestamp + lifeTime >= uint32(now) && !finishMintingStruct.isExecute && !finishMintingStruct.isCanceled){\r\n        if(finishMintingStruct.initiator == _oldOwner){\r\n          finishMintingStruct.isCanceled = true;\r\n          emit NewMintRequestCanceled();\r\n        }else{\r\n          //@dev Trying to find _oldOwner in struct confirmators\r\n          for (i = 0; i < finishMintingStruct.confirmators.length; i++){\r\n            if (finishMintingStruct.confirmators[i] == _oldOwner){\r\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\r\n              finishMintingStruct.confirmators[i] = address(0);\r\n              finishMintingStruct.confirms--;\r\n\r\n              /**\r\n               *@dev Struct can be confirmed each owner just once\r\n               *so no sence to continue loop\r\n               */\r\n              break;\r\n            }\r\n          }\r\n        }     \r\n      }\r\n    }\r\n\r\n    /**@dev check actions in setNewApproves requests\r\n     * check for empty struct\r\n     */\r\n    if (setNewApproves.initiator != address(0)){\r\n      //@dev check, can this request be approved by someone, if no then no sense to change something\r\n      if (setNewApproves.creationTimestamp + lifeTime >= uint32(now) && !setNewApproves.isExecute && !setNewApproves.isCanceled){\r\n        if(setNewApproves.initiator == _oldOwner){\r\n          setNewApproves.isCanceled = true;\r\n\r\n          emit NewNeedApprovesToConfirmRequestCanceled();\r\n        }else{\r\n          //@dev Trying to find _oldOwner in struct confirmators\r\n          for (i = 0; i < setNewApproves.confirmators.length; i++){\r\n            if (setNewApproves.confirmators[i] == _oldOwner){\r\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\r\n              setNewApproves.confirmators[i] = address(0);\r\n              setNewApproves.confirms--;\r\n\r\n              /**\r\n               *@dev Struct can be confirmed each owner just once\r\n               *so no sence to continue loop\r\n               */\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     *@dev check actions in addOwner requests\r\n     *check for empty struct\r\n     */\r\n    if (addOwner.initiator != address(0)){\r\n      //@dev check, can this request be approved by someone, if no then no sense to change something\r\n      if (addOwner.creationTimestamp + lifeTime >= uint32(now) && !addOwner.isExecute && !addOwner.isCanceled){\r\n        if(addOwner.initiator == _oldOwner){\r\n          addOwner.isCanceled = true;\r\n          emit AddOwnerRequestCanceled();\r\n        }else{\r\n          //@dev Trying to find _oldOwner in struct confirmators\r\n          for (i = 0; i < addOwner.confirmators.length; i++){\r\n            if (addOwner.confirmators[i] == _oldOwner){\r\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\r\n              addOwner.confirmators[i] = address(0);\r\n              addOwner.confirms--;\r\n\r\n              /**\r\n               *@dev Struct can be confirmed each owner just once\r\n               *so no sence to continue loop\r\n               */\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**@dev check actions in removeOwners requests\r\n     *@dev check for empty struct\r\n    */\r\n    if (removeOwners.initiator != address(0)){\r\n      //@dev check, can this request be approved by someone, if no then no sense to change something\r\n      if (removeOwners.creationTimestamp + lifeTime >= uint32(now) && !removeOwners.isExecute && !removeOwners.isCanceled){\r\n        if(removeOwners.initiator == _oldOwner){\r\n          removeOwners.isCanceled = true;\r\n          emit RemoveOwnerRequestCanceled();\r\n        }else{\r\n          //@dev Trying to find _oldOwner in struct confirmators\r\n          for (i = 0; i < removeOwners.confirmators.length; i++){\r\n            if (removeOwners.confirmators[i] == _oldOwner){\r\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\r\n              removeOwners.confirmators[i] = address(0);\r\n              removeOwners.confirms--;\r\n\r\n              /**\r\n               *@dev Struct can be confirmed each owner just once\r\n               *so no sence to continue loop\r\n               */\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveNewOwnersCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelAddOwnerRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addOwner\",\"outputs\":[{\"name\":\"newOwner\",\"type\":\"address\"},{\"name\":\"confirms\",\"type\":\"uint8\"},{\"name\":\"isExecute\",\"type\":\"bool\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"isCanceled\",\"type\":\"bool\"},{\"name\":\"creationTimestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelNewOwnersCountRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelRemoveOwnerRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_removeOwner\",\"type\":\"address\"}],\"name\":\"removeOwnerRequest2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ApproveFinishMintingRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_removeOwner\",\"type\":\"address\"}],\"name\":\"removeOwnerRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveAddOwnerRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"removeOwners\",\"outputs\":[{\"name\":\"newOwner\",\"type\":\"address\"},{\"name\":\"confirms\",\"type\":\"uint8\"},{\"name\":\"isExecute\",\"type\":\"bool\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"isCanceled\",\"type\":\"bool\"},{\"name\":\"creationTimestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setNewOwnersCountToApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOwnersAction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelFinishMintingRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelRemoveOwnerRequest2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needApprovesToConfirm\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveRemoveOwnerRequest2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setNewMintRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelMintRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setNewApproves\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"confirms\",\"type\":\"uint8\"},{\"name\":\"isExecute\",\"type\":\"bool\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"isCanceled\",\"type\":\"bool\"},{\"name\":\"creationTimestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finishMintingStruct\",\"outputs\":[{\"name\":\"confirms\",\"type\":\"uint8\"},{\"name\":\"isExecute\",\"type\":\"bool\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"isCanceled\",\"type\":\"bool\"},{\"name\":\"creationTimestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"removeOwners2\",\"outputs\":[{\"name\":\"newOwner\",\"type\":\"address\"},{\"name\":\"confirms\",\"type\":\"uint8\"},{\"name\":\"isExecute\",\"type\":\"bool\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"isCanceled\",\"type\":\"bool\"},{\"name\":\"creationTimestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMintingRequestSetup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setNewMint\",\"outputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"confirms\",\"type\":\"uint8\"},{\"name\":\"isExecute\",\"type\":\"bool\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"isCanceled\",\"type\":\"bool\"},{\"name\":\"creationTimestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveRemoveOwnerRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lifeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setAddOwnerRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveNewMintRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_needApprovesToConfirm\",\"type\":\"uint256\"},{\"name\":\"_owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewMintRequestSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"confirms\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"isExecute\",\"type\":\"bool\"}],\"name\":\"NewMintRequestUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewMintRequestCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"FinishMintingRequestSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"confirms\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"isExecute\",\"type\":\"bool\"}],\"name\":\"FinishMintingRequestUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FinishMintingRequestCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"FinishMintingApproveCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"NewNeedApprovesToConfirmRequestSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"confirms\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"isExecute\",\"type\":\"bool\"}],\"name\":\"NewNeedApprovesToConfirmRequestUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewNeedApprovesToConfirmRequestCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AddOwnerRequestSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"confirms\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"isExecute\",\"type\":\"bool\"}],\"name\":\"AddOwnerRequestUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AddOwnerRequestCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"RemoveOwnerRequestSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"confirms\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"isExecute\",\"type\":\"bool\"}],\"name\":\"RemoveOwnerRequestUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RemoveOwnerRequestCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"RemoveOwnerRequestSetup2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"confirms\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"isExecute\",\"type\":\"bool\"}],\"name\":\"RemoveOwnerRequestUpdate2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RemoveOwnerRequestCanceled2\",\"type\":\"event\"}]","ContractName":"GangMultisig","CompilerVersion":"v0.4.22+commit.4cb486ee","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000037ff5a78a8197db306dc7766c39ab80c54efde77000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000007000000000000000000000000bbc8fb66289b057ee2d094d93f2ea465bf1e7f730000000000000000000000009bed3adc0fed8481e79cc634f7d6b1d9e73d647c0000000000000000000000005a09fdac5e20b31e8e9fb649371f095b39bc469e000000000000000000000000c147b34b1bde1c8f6f4d5f975444b2a81916d38b000000000000000000000000df617686079881d23c0d29ef42377cd1443a25e70000000000000000000000007eb985d63bc60ba5f5f516281657592b868881b400000000000000000000000020f92210fc63182956b35992192ae3af54d7f12f","Library":"","SwarmSource":"bzzr://6aee62237ad33a0f3eb4eb98755f37cedffacf1b626149c4bbcfbabc39b69c4c"}]}