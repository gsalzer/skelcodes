{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\tif (a == 0) {\r\n  \treturn 0;\r\n\t}\r\n\tuint256 c = a * b;\r\n\tassert(c / a == b);\r\n\treturn c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\tuint256 c = a / b;\r\n\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\treturn c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\tassert(b <= a);\r\n\treturn a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\tuint256 c = a + b;\r\n\tassert(c >= a);\r\n\treturn c;\r\n  }\r\n}\r\ncontract owned {\r\n\taddress public owner;\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n\tfunction owned() public {\r\n    \towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n    \trequire(msg.sender == owner);\r\n    \t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) onlyOwner public {\r\n    \trequire(newOwner != address(0));\r\n    \tOwnershipTransferred(owner, newOwner);\r\n    \towner = newOwner;\r\n\t}\r\n}\r\n\r\ncontract Pausable is owned {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n\trequire(!paused);\r\n\t_;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n\trequire(paused);\r\n\t_;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n\tpaused = true;\r\n\tPause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n\tpaused = false;\r\n\tUnpause();\r\n  }\r\n}\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\ninterface ERC20Token {\r\n\r\n \r\n\r\n\t/// @param _owner The address from which the balance will be retrieved\r\n\t/// @return The balance\r\n\tfunction balanceOf(address _owner) constant external returns (uint256 balance);\r\n\r\n\t/// @notice send `_value` token to `_to` from `msg.sender`\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return Whether the transfer was successful or not\r\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n\t/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n\t/// @param _from The address of the sender\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return Whether the transfer was successful or not\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    \r\n\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is ERC20Token, Pausable {\r\n using SafeMath for uint;\r\n  modifier onlyPayloadSize(uint size) {\r\n \tassert(msg.data.length == size.add(4));\r\n \t_;\r\n   }\r\n\r\n\tfunction transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) whenNotPaused external returns (bool success) {\r\n    \t//Default assumes totalSupply can't be over max (2^256 - 1).\r\n    \t//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    \t//Replace the if with this one instead.\r\n    \t//if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    \tif (balances[msg.sender] >= _value && _value > 0) {\r\n        \tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n        \tbalances[_to] = balances[_to].add(_value);\r\n        \tTransfer(msg.sender, _to, _value);\r\n        \treturn true;\r\n    \t} else { return false; }\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(2 * 32) whenNotPaused external returns (bool success) {\r\n    \t//same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    \t//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    \tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        \tbalances[_to] = balances[_to].add(_value);\r\n        \tbalances[_from] = balances[_from].sub(_value);\r\n        \tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        \tTransfer(_from, _to, _value);\r\n        \treturn true;\r\n    \t} else { return false; }\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) constant external returns (uint256 balance) {\r\n    \treturn balances[_owner];\r\n\t}\r\n    \r\n\t/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @param _value The amount of wei to be approved for transfer\r\n\t/// @return Whether the approval was successful or not\r\n\tfunction approve(address _spender, uint256 _value) whenNotPaused public returns (bool success) {\r\n    \trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n    \tallowed[msg.sender][_spender] = _value;\r\n    \tApproval(msg.sender, _spender, _value);\r\n    \treturn true;\r\n\t}\r\n\r\n\r\n   \r\n\t/// @param _owner The address of the account owning tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @return Amount of remaining tokens allowed to spent\r\n\tfunction allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n  \treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\tmapping (address => uint256) balances;\r\n\tmapping (address => mapping (address => uint256)) allowed;\r\n\tuint256 public _totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract Cryptoya is StandardToken{\r\n using SafeMath for uint;\r\n\r\n\r\n\t/* Public variables of the token */\r\n\r\n\t/*\r\n\tNOTE:\r\n\tThe following variables are OPTIONAL vanities. One does not have to include them.\r\n\tThey allow one to customise the token contract & in no way influences the core functionality.\r\n\tSome wallets/interfaces might not even bother to look at this information.\r\n\t*/\r\n\tstring public name;               \t//fancy name: eg Simon Bucks\r\n\tuint8 public decimals;            \t//How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n\tstring public symbol;             \t//An identifier: eg SBX\r\n\tstring public version = 'V1.0';   \t//Version 0.1 standard. Just an arbitrary versioning scheme.\r\n\tuint256 private fulltoken;\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n    \r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. ERC20Token\r\n\r\n\tfunction Cryptoya(\r\n    \t) public{\r\n    \tfulltoken = 500000000;  \t \r\n    \tdecimals = 18;                        \t// Amount of decimals for display purposes\r\n    \t_totalSupply = fulltoken.mul(10 ** uint256(decimals)); // Update total supply (100000 for example)\r\n    \tbalances[msg.sender] = _totalSupply;           \t// Give the creator all initial tokens (100000 for example)\r\n    \tname = \"Cryptoya\";                               \t// Set the name for display purposes\r\n    \tsymbol = \"CRA\";                           \t// Set the symbol for display purposes\r\n\t}\r\n \tfunction() public {\r\n     \t//not payable fallback function\r\n      \trevert();\r\n\t}\r\n    \t/**\r\n \t* Set allowance for other address and notify\r\n \t*\r\n \t* Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n \t*\r\n \t* @param _spender The address authorized to spend\r\n \t* @param _value the max amount they can spend\r\n \t* @param _extraData some extra information to send to the approved contract\r\n \t*/\r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n    \ttokenRecipient spender = tokenRecipient(_spender);\r\n    \tif (approve(_spender, _value)) {\r\n        \tspender.receiveApproval(msg.sender, _value, this, _extraData);\r\n        \treturn true;\r\n       \t}\r\n\t}\r\n    \r\n  \t/// @return total amount of tokens\r\n\tfunction totalSupply() constant public returns (uint256 supply){\r\n   \t \r\n    \treturn _totalSupply;\r\n\t}\r\n\r\n\t/**\r\n \t* Destroy tokens\r\n \t*\r\n \t* Remove `_value` tokens from the system irreversibly\r\n \t*\r\n \t* @param _value the amount of money to burn\r\n \t*/\r\n\tfunction burn(uint256 _value) onlyOwner public returns (bool success) {\r\n    \trequire(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n    \tbalances[msg.sender] = balances[msg.sender].sub(_value);        \t// Subtract from the sender\r\n    \t_totalSupply = _totalSupply.sub(_value);                  \t// Updates totalSupply\r\n    \tBurn(msg.sender, _value);\r\n    \tTransfer(msg.sender, address(0), _value);\r\n    \treturn true;\r\n\t}\r\n\r\n\t/**\r\n \t* Destroy tokens from other account\r\n \t*\r\n \t* Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n \t*\r\n \t* @param _from the address of the sender\r\n \t* @param _value the amount of money to burn\r\n \t*/\r\n\tfunction burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {\r\n    \trequire(balances[_from] >= _value);            \t// Check if the targeted balance is enough\r\n    \trequire(_value <= allowed[_from][msg.sender]);\t// Check allowance\r\n    \tbalances[_from] = balances[_from].sub(_value);                     \t// Subtract from the targeted balance\r\n    \tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);         \t// Subtract from the sender's allowance\r\n    \t_totalSupply = _totalSupply.sub(_value);                          \t// Update totalSupply\r\n    \tBurn(_from, _value);\r\n    \tTransfer(_from, address(0), _value);\r\n    \treturn true;\r\n\t}\r\n \tfunction onlyPayForFuel() public payable onlyOwner{\r\n    \t// Owner will pay in contract to bear the gas price if transactions made from contract\r\n   \t \r\n\t}\r\n\tfunction withdrawEtherFromcontract(uint _amountineth) public onlyOwner{\r\n    \tuint _amountInwei = _amountineth.mul(10 ** 18);\r\n    \trequire(this.balance > _amountInwei);\r\n  \trequire(msg.sender == owner);\r\n  \towner.transfer(_amountInwei);\r\n\t \r\n\t}\r\n     function withdrawTokensFromContract(uint _amountOfTokens) public onlyOwner{\r\n    \trequire(balances[this] > _amountOfTokens);\r\n    \trequire(msg.sender == owner);\r\n    \tbalances[msg.sender] = balances[msg.sender].add(_amountOfTokens);                    \t// adds the amount to owner's balance\r\n    \tbalances[this] = balances[this].sub(_amountOfTokens);              \t// subtracts the amount from contract balance\r\n   \t Transfer(this, msg.sender, _amountOfTokens);           \t// execute an event reflecting the change\r\n\t \r\n\t}\r\n \t \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"onlyPayForFuel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountineth\",\"type\":\"uint256\"}],\"name\":\"withdrawEtherFromcontract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Cryptoya","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9b3bfdc45041dc81ee43834d6030619c09c06e334e25e22b372ba4bdbf7f12c7"}]}