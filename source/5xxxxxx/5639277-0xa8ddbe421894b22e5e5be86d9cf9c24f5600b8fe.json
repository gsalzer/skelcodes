{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n //We have to specify what version of the compiler this code will use\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract QIUToken is StandardToken,Ownable {\r\n    string public name = 'QIUToken';\r\n    string public symbol = 'QIU';\r\n    uint8 public decimals = 0;\r\n    uint public INITIAL_SUPPLY = 5000000000;\r\n    uint public eth2qiuRate = 10000;\r\n\r\n    function() public payable { } // make this contract to receive ethers\r\n\r\n    function QIUToken() public {\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        balances[owner] = INITIAL_SUPPLY / 10;\r\n        balances[this] = INITIAL_SUPPLY - balances[owner];\r\n    }\r\n\r\n    function getOwner() public view returns (address) {\r\n        return owner;\r\n    }  \r\n    \r\n    /**\r\n    * @dev Transfer tokens from one address to another, only owner can do this super-user operate\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function ownerTransferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(tx.origin == owner); // only the owner can call the method.\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n      /**\r\n    * @dev transfer token for a specified address,but different from transfer is replace msg.sender with tx.origin\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function originTransfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[tx.origin]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[tx.origin] = balances[tx.origin].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(tx.origin, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    event ExchangeForETH(address fromAddr,address to,uint qiuAmount,uint ethAmount);\r\n    function exchangeForETH(uint qiuAmount) public returns (bool){\r\n        uint ethAmount = qiuAmount * 1000000000000000000 / eth2qiuRate; // only accept multiple of 100\r\n        require(this.balance >= ethAmount);\r\n        balances[this] = balances[this].add(qiuAmount);\r\n        balances[msg.sender] = balances[msg.sender].sub(qiuAmount);\r\n        msg.sender.transfer(ethAmount);\r\n        ExchangeForETH(this,msg.sender,qiuAmount,ethAmount);\r\n        return true;\r\n    }\r\n\r\n    event ExchangeForQIU(address fromAddr,address to,uint qiuAmount,uint ethAmount);\r\n    function exchangeForQIU() payable public returns (bool){\r\n        uint qiuAmount = msg.value * eth2qiuRate / 1000000000000000000;\r\n        require(qiuAmount <= balances[this]);\r\n        balances[this] = balances[this].sub(qiuAmount);\r\n        balances[msg.sender] = balances[msg.sender].add(qiuAmount);\r\n        ExchangeForQIU(this,msg.sender,qiuAmount,msg.value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    // transfer out method\r\n    function ownerETHCashout(address account) public onlyOwner {\r\n        account.transfer(this.balance);\r\n    }*/\r\n    function getETHBalance() public view returns (uint) {\r\n        return this.balance; // balance is \"inherited\" from the address type\r\n    }\r\n}\r\n\r\ncontract SoccerGamblingV_QIU is Ownable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct BettingInfo {\r\n        uint id;\r\n        address bettingOwner;\r\n        bool buyHome;\r\n        bool buyAway;\r\n        bool buyDraw;\r\n        uint bettingAmount;\r\n    }\r\n    \r\n    struct GamblingPartyInfo {\r\n        uint id;\r\n        address dealerAddress; // The address of the inital founder\r\n        uint homePayRate;\r\n        uint awayPayRate;\r\n        uint drawPayRate;\r\n        uint payRateScale;\r\n        uint bonusPool; // count by wei\r\n        uint baseBonusPool;\r\n        int finalScoreHome;\r\n        int finalScoreAway;\r\n        bool isEnded;\r\n        bool isLockedForBet;\r\n        BettingInfo[] bettingsInfo;\r\n    }\r\n\r\n    mapping (uint => GamblingPartyInfo) public gamblingPartiesInfo;\r\n    mapping (uint => uint[]) public matchId2PartyId;\r\n    uint private _nextGamblingPartyId;\r\n    uint private _nextBettingInfoId;\r\n    QIUToken public _internalToken;\r\n\r\n    uint private _commissionNumber;\r\n    uint private _commissionScale;\r\n    \r\n\r\n    function SoccerGamblingV_QIU(QIUToken _tokenAddress) public {\r\n        _nextGamblingPartyId = 0;\r\n        _nextBettingInfoId = 0;\r\n        _internalToken = _tokenAddress;\r\n        _commissionNumber = 2;\r\n        _commissionScale = 100;\r\n    }\r\n\r\n    function modifyCommission(uint number,uint scale) public onlyOwner returns(bool){\r\n        _commissionNumber = number;\r\n        _commissionScale = scale;\r\n        return true;\r\n    }\r\n\r\n    function _availableBetting(uint gamblingPartyId,uint8 buySide,uint bettingAmount) private view returns(bool) {\r\n        GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n        uint losePay = 0;\r\n        if (buySide==0)\r\n            losePay = losePay.add((gpInfo.homePayRate.mul(bettingAmount)).div(gpInfo.payRateScale));\r\n        else if (buySide==1)\r\n            losePay = losePay.add((gpInfo.awayPayRate.mul(bettingAmount)).div(gpInfo.payRateScale));\r\n        else if (buySide==2)\r\n            losePay = losePay.add((gpInfo.drawPayRate.mul(bettingAmount)).div(gpInfo.payRateScale));\r\n        uint mostPay = 0;\r\n        for (uint idx = 0; idx<gpInfo.bettingsInfo.length; idx++) {\r\n            BettingInfo storage bInfo = gpInfo.bettingsInfo[idx];\r\n            if (bInfo.buyHome && (buySide==0))\r\n                mostPay = mostPay.add((gpInfo.homePayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale));\r\n            else if (bInfo.buyAway && (buySide==1))\r\n                mostPay = mostPay.add((gpInfo.awayPayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale));\r\n            else if (bInfo.buyDraw && (buySide==2))\r\n                mostPay = mostPay.add((gpInfo.drawPayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale));\r\n        }\r\n        if (mostPay + losePay > gpInfo.bonusPool)\r\n            return false;\r\n        else \r\n            return true;\r\n    }\r\n\r\n    event NewBettingSucceed(address fromAddr,uint newBettingInfoId);\r\n    function betting(uint gamblingPartyId,uint8 buySide,uint bettingAmount) public {\r\n        require(bettingAmount > 0);\r\n        require(_internalToken.balanceOf(msg.sender) >= bettingAmount);\r\n        GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n        require(gpInfo.isEnded == false);\r\n        require(gpInfo.isLockedForBet == false);\r\n        require(_availableBetting(gamblingPartyId, buySide, bettingAmount));\r\n        BettingInfo memory bInfo;\r\n        bInfo.id = _nextBettingInfoId;\r\n        bInfo.bettingOwner = msg.sender;\r\n        bInfo.buyHome = false;\r\n        bInfo.buyAway = false;\r\n        bInfo.buyDraw = false;\r\n        bInfo.bettingAmount = bettingAmount;\r\n        if (buySide == 0)\r\n            bInfo.buyHome = true;\r\n        if (buySide == 1)\r\n            bInfo.buyAway = true;\r\n        if (buySide == 2)\r\n            bInfo.buyDraw = true;\r\n        _internalToken.originTransfer(this,bettingAmount);\r\n        gpInfo.bettingsInfo.push(bInfo);\r\n        _nextBettingInfoId++;\r\n        gpInfo.bonusPool = gpInfo.bonusPool.add(bettingAmount);\r\n        NewBettingSucceed(msg.sender,bInfo.id);\r\n    }\r\n\r\n    function remainingBettingFor(uint gamblingPartyId) public view returns\r\n        (uint remainingAmountHome,\r\n         uint remainingAmountAway,\r\n         uint remainingAmountDraw\r\n        ) {\r\n        for (uint8 buySide = 0;buySide<3;buySide++){\r\n            GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n            uint bonusPool = gpInfo.bonusPool;\r\n            for (uint idx = 0; idx<gpInfo.bettingsInfo.length; idx++) {\r\n                BettingInfo storage bInfo = gpInfo.bettingsInfo[idx];\r\n                if (bInfo.buyHome && (buySide==0))\r\n                    bonusPool = bonusPool.sub((gpInfo.homePayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale));\r\n                else if (bInfo.buyAway && (buySide==1))\r\n                    bonusPool = bonusPool.sub((gpInfo.awayPayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale));\r\n                else if (bInfo.buyDraw && (buySide==2))\r\n                    bonusPool = bonusPool.sub((gpInfo.drawPayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale));\r\n            }\r\n            if (buySide == 0)\r\n                remainingAmountHome = (bonusPool.mul(gpInfo.payRateScale)).div(gpInfo.homePayRate);\r\n            else if (buySide == 1)\r\n                remainingAmountAway = (bonusPool.mul(gpInfo.payRateScale)).div(gpInfo.awayPayRate);\r\n            else if (buySide == 2)\r\n                remainingAmountDraw = (bonusPool.mul(gpInfo.payRateScale)).div(gpInfo.drawPayRate);\r\n        }\r\n    }\r\n\r\n    event MatchAllGPsLock(address fromAddr,uint matchId,bool isLocked);\r\n    function lockUnlockMatchGPForBetting(uint matchId,bool lock) public {\r\n        uint[] storage gamblingPartyIds = matchId2PartyId[matchId];\r\n        for (uint idx = 0;idx < gamblingPartyIds.length;idx++) {\r\n            lockUnlockGamblingPartyForBetting(gamblingPartyIds[idx],lock);\r\n        }\r\n        MatchAllGPsLock(msg.sender,matchId,lock);        \r\n    }\r\n\r\n    function lockUnlockGamblingPartyForBetting(uint gamblingPartyId,bool lock) public onlyOwner {\r\n        GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n        gpInfo.isLockedForBet = lock;\r\n    }\r\n\r\n    function getGamblingPartyInfo(uint gamblingPartyId) public view returns (uint gpId,\r\n                                                                            address dealerAddress,\r\n                                                                            uint homePayRate,\r\n                                                                            uint awayPayRate,\r\n                                                                            uint drawPayRate,\r\n                                                                            uint payRateScale,\r\n                                                                            uint bonusPool,\r\n                                                                            int finalScoreHome,\r\n                                                                            int finalScoreAway,\r\n                                                                            bool isEnded) \r\n    {\r\n\r\n        GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n        gpId = gpInfo.id;\r\n        dealerAddress = gpInfo.dealerAddress; // The address of the inital founder\r\n        homePayRate = gpInfo.homePayRate;\r\n        awayPayRate = gpInfo.awayPayRate;\r\n        drawPayRate = gpInfo.drawPayRate;\r\n        payRateScale = gpInfo.payRateScale;\r\n        bonusPool = gpInfo.bonusPool; // count by wei\r\n        finalScoreHome = gpInfo.finalScoreHome;\r\n        finalScoreAway = gpInfo.finalScoreAway;\r\n        isEnded = gpInfo.isEnded;\r\n    }\r\n\r\n    //in this function, I removed the extra return value to fix the compiler exception caused by solidity limitation \r\n    //exception is: CompilerError: Stack too deep, try removing local variables.\r\n    //to get the extra value for the gambingParty , need to invoke the method getGamblingPartyInfo\r\n    function getGamblingPartySummarizeInfo(uint gamblingPartyId) public view returns(\r\n        uint gpId,\r\n        //uint salesAmount,\r\n        uint homeSalesAmount,\r\n        int  homeSalesEarnings,\r\n        uint awaySalesAmount,\r\n        int  awaySalesEarnings,\r\n        uint drawSalesAmount,\r\n        int  drawSalesEarnings,\r\n        int  dealerEarnings,\r\n        uint baseBonusPool\r\n    ){\r\n        GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n        gpId = gpInfo.id;\r\n        baseBonusPool = gpInfo.baseBonusPool;\r\n        for (uint idx = 0; idx < gpInfo.bettingsInfo.length; idx++) {\r\n            BettingInfo storage bInfo = gpInfo.bettingsInfo[idx];\r\n            if (bInfo.buyHome){\r\n                homeSalesAmount += bInfo.bettingAmount;\r\n                if (gpInfo.isEnded && (gpInfo.finalScoreHome > gpInfo.finalScoreAway)){\r\n                    homeSalesEarnings = homeSalesEarnings - int(bInfo.bettingAmount*gpInfo.homePayRate/gpInfo.payRateScale);\r\n                }else\r\n                    homeSalesEarnings += int(bInfo.bettingAmount);\r\n            } else if (bInfo.buyAway){\r\n                awaySalesAmount += bInfo.bettingAmount;\r\n                if (gpInfo.isEnded && (gpInfo.finalScoreHome < gpInfo.finalScoreAway)){\r\n                    awaySalesEarnings = awaySalesEarnings - int(bInfo.bettingAmount*gpInfo.awayPayRate/gpInfo.payRateScale);\r\n                }else\r\n                    awaySalesEarnings += int(bInfo.bettingAmount);\r\n            } else if (bInfo.buyDraw){\r\n                drawSalesAmount += bInfo.bettingAmount;\r\n                if (gpInfo.isEnded && (gpInfo.finalScoreHome == gpInfo.finalScoreAway)){\r\n                    drawSalesEarnings = drawSalesEarnings - int(bInfo.bettingAmount*gpInfo.drawPayRate/gpInfo.payRateScale);\r\n                }else\r\n                    drawSalesEarnings += int(bInfo.bettingAmount);\r\n            }\r\n        }\r\n        int commission;    \r\n        if(gpInfo.isEnded){\r\n            dealerEarnings = int(gpInfo.bonusPool);\r\n        }else{\r\n            dealerEarnings = int(gpInfo.bonusPool);\r\n            return;\r\n        }\r\n        if (homeSalesEarnings > 0){\r\n            commission = homeSalesEarnings * int(_commissionNumber) / int(_commissionScale);\r\n            homeSalesEarnings -= commission;\r\n        }\r\n        if (awaySalesEarnings > 0){\r\n            commission = awaySalesEarnings * int(_commissionNumber) / int(_commissionScale);\r\n            awaySalesEarnings -= commission;\r\n        }\r\n        if (drawSalesEarnings > 0){\r\n            commission = drawSalesEarnings * int(_commissionNumber) / int(_commissionScale);\r\n            drawSalesEarnings -= commission;\r\n        }\r\n        if (homeSalesEarnings < 0)\r\n            dealerEarnings = int(gpInfo.bonusPool) + homeSalesEarnings;\r\n        if (awaySalesEarnings < 0)\r\n            dealerEarnings = int(gpInfo.bonusPool) + awaySalesEarnings;\r\n        if (drawSalesEarnings < 0)\r\n            dealerEarnings = int(gpInfo.bonusPool) + drawSalesEarnings;\r\n        commission = dealerEarnings * int(_commissionNumber) / int(_commissionScale);\r\n        dealerEarnings -= commission;\r\n    }\r\n\r\n    function getMatchSummarizeInfo(uint matchId) public view returns (\r\n                                                            uint mSalesAmount,\r\n                                                            uint mHomeSalesAmount,\r\n                                                            uint mAwaySalesAmount,\r\n                                                            uint mDrawSalesAmount,\r\n                                                            int mDealerEarnings,\r\n                                                            uint mBaseBonusPool\r\n                                                        )\r\n    {\r\n        for (uint idx = 0; idx<matchId2PartyId[matchId].length; idx++) {\r\n            uint gamblingPartyId = matchId2PartyId[matchId][idx];\r\n            var (,homeSalesAmount,,awaySalesAmount,,drawSalesAmount,,dealerEarnings,baseBonusPool) = getGamblingPartySummarizeInfo(gamblingPartyId);\r\n            mHomeSalesAmount += homeSalesAmount;\r\n            mAwaySalesAmount += awaySalesAmount;\r\n            mDrawSalesAmount += drawSalesAmount;\r\n            mSalesAmount += homeSalesAmount + awaySalesAmount + drawSalesAmount;\r\n            mDealerEarnings += dealerEarnings;\r\n            mBaseBonusPool = baseBonusPool;\r\n        }\r\n    }\r\n\r\n    function getSumOfGamblingPartiesBonusPool(uint matchId) public view returns (uint) {\r\n        uint sum = 0;\r\n        for (uint idx = 0; idx<matchId2PartyId[matchId].length; idx++) {\r\n            uint gamblingPartyId = matchId2PartyId[matchId][idx];\r\n            GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n            sum += gpInfo.bonusPool;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function getWinLoseAmountByBettingOwnerInGamblingParty(uint gamblingPartyId,address bettingOwner) public view returns (int) {\r\n        int winLose = 0;\r\n        GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n        require(gpInfo.isEnded);\r\n        for (uint idx = 0; idx < gpInfo.bettingsInfo.length; idx++) {\r\n            BettingInfo storage bInfo = gpInfo.bettingsInfo[idx];\r\n            if (bInfo.bettingOwner == bettingOwner) {\r\n                if ((gpInfo.finalScoreHome > gpInfo.finalScoreAway) && (bInfo.buyHome)) {\r\n                    winLose += int(gpInfo.homePayRate * bInfo.bettingAmount / gpInfo.payRateScale);\r\n                } else if ((gpInfo.finalScoreHome < gpInfo.finalScoreAway) && (bInfo.buyAway)) {\r\n                    winLose += int(gpInfo.awayPayRate * bInfo.bettingAmount / gpInfo.payRateScale);\r\n                } else if ((gpInfo.finalScoreHome == gpInfo.finalScoreAway) && (bInfo.buyDraw)) {\r\n                    winLose += int(gpInfo.drawPayRate * bInfo.bettingAmount / gpInfo.payRateScale);\r\n                } else {\r\n                    winLose -= int(bInfo.bettingAmount);\r\n                }\r\n            }\r\n        }   \r\n        if (winLose > 0){\r\n            int commission = winLose * int(_commissionNumber) / int(_commissionScale);\r\n            winLose -= commission;\r\n        }\r\n        return winLose;\r\n    }\r\n\r\n    function getWinLoseAmountByBettingIdInGamblingParty(uint gamblingPartyId,uint bettingId) public view returns (int) {\r\n        int winLose = 0;\r\n        GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n        require(gpInfo.isEnded);\r\n        for (uint idx = 0; idx < gpInfo.bettingsInfo.length; idx++) {\r\n            BettingInfo storage bInfo = gpInfo.bettingsInfo[idx];\r\n            if (bInfo.id == bettingId) {\r\n                if ((gpInfo.finalScoreHome > gpInfo.finalScoreAway) && (bInfo.buyHome)) {\r\n                    winLose += int(gpInfo.homePayRate * bInfo.bettingAmount / gpInfo.payRateScale);\r\n                } else if ((gpInfo.finalScoreHome < gpInfo.finalScoreAway) && (bInfo.buyAway)) {\r\n                    winLose += int(gpInfo.awayPayRate * bInfo.bettingAmount / gpInfo.payRateScale);\r\n                } else if ((gpInfo.finalScoreHome == gpInfo.finalScoreAway) && (bInfo.buyDraw)) {\r\n                    winLose += int(gpInfo.drawPayRate * bInfo.bettingAmount / gpInfo.payRateScale);\r\n                } else {\r\n                    winLose -= int(bInfo.bettingAmount);\r\n                }\r\n                break;\r\n            }\r\n        }   \r\n        if (winLose > 0){\r\n            int commission = winLose * int(_commissionNumber) / int(_commissionScale);\r\n            winLose -= commission;\r\n        }\r\n        return winLose;\r\n    }\r\n\r\n    event NewGamblingPartyFounded(address fromAddr,uint newGPId);\r\n    function foundNewGamblingParty(\r\n        uint matchId,\r\n        uint homePayRate,\r\n        uint awayPayRate,\r\n        uint drawPayRate,\r\n        uint payRateScale,\r\n        uint basePool\r\n        ) public\r\n        {\r\n        address sender = msg.sender;\r\n        require(basePool > 0);\r\n        require(_internalToken.balanceOf(sender) >= basePool);\r\n        uint newId = _nextGamblingPartyId;\r\n        gamblingPartiesInfo[newId].id = newId;\r\n        gamblingPartiesInfo[newId].dealerAddress = sender;\r\n        gamblingPartiesInfo[newId].homePayRate = homePayRate;\r\n        gamblingPartiesInfo[newId].awayPayRate = awayPayRate;\r\n        gamblingPartiesInfo[newId].drawPayRate = drawPayRate;\r\n        gamblingPartiesInfo[newId].payRateScale = payRateScale;\r\n        gamblingPartiesInfo[newId].bonusPool = basePool;\r\n        gamblingPartiesInfo[newId].baseBonusPool = basePool;\r\n        gamblingPartiesInfo[newId].finalScoreHome = -1;\r\n        gamblingPartiesInfo[newId].finalScoreAway = -1;\r\n        gamblingPartiesInfo[newId].isEnded = false;\r\n        gamblingPartiesInfo[newId].isLockedForBet = false;\r\n        _internalToken.originTransfer(this,basePool);\r\n        matchId2PartyId[matchId].push(gamblingPartiesInfo[newId].id);\r\n        _nextGamblingPartyId++;\r\n        NewGamblingPartyFounded(sender,newId);//fire event\r\n    }\r\n\r\n    event MatchAllGPsEnded(address fromAddr,uint matchId);\r\n    function endMatch(uint matchId,int homeScore,int awayScore) public {\r\n        uint[] storage gamblingPartyIds = matchId2PartyId[matchId];\r\n        for (uint idx = 0;idx < gamblingPartyIds.length;idx++) {\r\n            endGamblingParty(gamblingPartyIds[idx],homeScore,awayScore);\r\n        }\r\n        MatchAllGPsEnded(msg.sender,matchId);        \r\n    }\r\n\r\n    event GamblingPartyEnded(address fromAddr,uint gamblingPartyId);\r\n    function endGamblingParty(uint gamblingPartyId,int homeScore,int awayScore) public onlyOwner {\r\n        GamblingPartyInfo storage gpInfo = gamblingPartiesInfo[gamblingPartyId];\r\n        require(!gpInfo.isEnded);\r\n        gpInfo.finalScoreHome = homeScore;\r\n        gpInfo.finalScoreAway = awayScore;\r\n        gpInfo.isEnded = true;\r\n        int flag = -1;\r\n        if (homeScore > awayScore)\r\n            flag = 0;\r\n        else if (homeScore < awayScore)\r\n            flag = 1;\r\n        else\r\n            flag = 2;\r\n        uint commission; // variable for commission caculation.\r\n        uint bonusPool = gpInfo.bonusPool;\r\n        for (uint idx = 0; idx < gpInfo.bettingsInfo.length; idx++) {\r\n            BettingInfo storage bInfo = gpInfo.bettingsInfo[idx];\r\n            uint transferAmount = 0;\r\n            if (flag == 0 && bInfo.buyHome)\r\n                transferAmount = (gpInfo.homePayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale);\r\n            if (flag == 1 && bInfo.buyAway)\r\n                transferAmount = (gpInfo.awayPayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale);\r\n            if (flag == 2 && bInfo.buyDraw)\r\n                transferAmount = (gpInfo.drawPayRate.mul(bInfo.bettingAmount)).div(gpInfo.payRateScale);\r\n            if (transferAmount != 0) {\r\n                bonusPool = bonusPool.sub(transferAmount);\r\n                commission = (transferAmount.mul(_commissionNumber)).div(_commissionScale);\r\n                transferAmount = transferAmount.sub(commission);\r\n                _internalToken.ownerTransferFrom(this,bInfo.bettingOwner,transferAmount);\r\n                _internalToken.ownerTransferFrom(this,owner,commission);\r\n            }\r\n        }    \r\n        if (bonusPool > 0) {\r\n            uint amount = bonusPool;\r\n            // subs the commission\r\n            commission = (amount.mul(_commissionNumber)).div(_commissionScale);\r\n            amount = amount.sub(commission);\r\n            _internalToken.ownerTransferFrom(this,gpInfo.dealerAddress,amount);\r\n            _internalToken.ownerTransferFrom(this,owner,commission);\r\n        }\r\n        GamblingPartyEnded(msg.sender,gpInfo.id);\r\n    }\r\n\r\n    function getETHBalance() public view returns (uint) {\r\n        return this.balance; // balance is \"inherited\" from the address type\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"getSumOfGamblingPartiesBonusPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gamblingPartiesInfo\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"dealerAddress\",\"type\":\"address\"},{\"name\":\"homePayRate\",\"type\":\"uint256\"},{\"name\":\"awayPayRate\",\"type\":\"uint256\"},{\"name\":\"drawPayRate\",\"type\":\"uint256\"},{\"name\":\"payRateScale\",\"type\":\"uint256\"},{\"name\":\"bonusPool\",\"type\":\"uint256\"},{\"name\":\"baseBonusPool\",\"type\":\"uint256\"},{\"name\":\"finalScoreHome\",\"type\":\"int256\"},{\"name\":\"finalScoreAway\",\"type\":\"int256\"},{\"name\":\"isEnded\",\"type\":\"bool\"},{\"name\":\"isLockedForBet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamblingPartyId\",\"type\":\"uint256\"}],\"name\":\"remainingBettingFor\",\"outputs\":[{\"name\":\"remainingAmountHome\",\"type\":\"uint256\"},{\"name\":\"remainingAmountAway\",\"type\":\"uint256\"},{\"name\":\"remainingAmountDraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gamblingPartyId\",\"type\":\"uint256\"},{\"name\":\"homeScore\",\"type\":\"int256\"},{\"name\":\"awayScore\",\"type\":\"int256\"}],\"name\":\"endGamblingParty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matchId2PartyId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"homeScore\",\"type\":\"int256\"},{\"name\":\"awayScore\",\"type\":\"int256\"}],\"name\":\"endMatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"getMatchSummarizeInfo\",\"outputs\":[{\"name\":\"mSalesAmount\",\"type\":\"uint256\"},{\"name\":\"mHomeSalesAmount\",\"type\":\"uint256\"},{\"name\":\"mAwaySalesAmount\",\"type\":\"uint256\"},{\"name\":\"mDrawSalesAmount\",\"type\":\"uint256\"},{\"name\":\"mDealerEarnings\",\"type\":\"int256\"},{\"name\":\"mBaseBonusPool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gamblingPartyId\",\"type\":\"uint256\"},{\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"lockUnlockGamblingPartyForBetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"number\",\"type\":\"uint256\"},{\"name\":\"scale\",\"type\":\"uint256\"}],\"name\":\"modifyCommission\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getETHBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamblingPartyId\",\"type\":\"uint256\"},{\"name\":\"bettingId\",\"type\":\"uint256\"}],\"name\":\"getWinLoseAmountByBettingIdInGamblingParty\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"homePayRate\",\"type\":\"uint256\"},{\"name\":\"awayPayRate\",\"type\":\"uint256\"},{\"name\":\"drawPayRate\",\"type\":\"uint256\"},{\"name\":\"payRateScale\",\"type\":\"uint256\"},{\"name\":\"basePool\",\"type\":\"uint256\"}],\"name\":\"foundNewGamblingParty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gamblingPartyId\",\"type\":\"uint256\"},{\"name\":\"buySide\",\"type\":\"uint8\"},{\"name\":\"bettingAmount\",\"type\":\"uint256\"}],\"name\":\"betting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamblingPartyId\",\"type\":\"uint256\"},{\"name\":\"bettingOwner\",\"type\":\"address\"}],\"name\":\"getWinLoseAmountByBettingOwnerInGamblingParty\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamblingPartyId\",\"type\":\"uint256\"}],\"name\":\"getGamblingPartyInfo\",\"outputs\":[{\"name\":\"gpId\",\"type\":\"uint256\"},{\"name\":\"dealerAddress\",\"type\":\"address\"},{\"name\":\"homePayRate\",\"type\":\"uint256\"},{\"name\":\"awayPayRate\",\"type\":\"uint256\"},{\"name\":\"drawPayRate\",\"type\":\"uint256\"},{\"name\":\"payRateScale\",\"type\":\"uint256\"},{\"name\":\"bonusPool\",\"type\":\"uint256\"},{\"name\":\"finalScoreHome\",\"type\":\"int256\"},{\"name\":\"finalScoreAway\",\"type\":\"int256\"},{\"name\":\"isEnded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gamblingPartyId\",\"type\":\"uint256\"}],\"name\":\"getGamblingPartySummarizeInfo\",\"outputs\":[{\"name\":\"gpId\",\"type\":\"uint256\"},{\"name\":\"homeSalesAmount\",\"type\":\"uint256\"},{\"name\":\"homeSalesEarnings\",\"type\":\"int256\"},{\"name\":\"awaySalesAmount\",\"type\":\"uint256\"},{\"name\":\"awaySalesEarnings\",\"type\":\"int256\"},{\"name\":\"drawSalesAmount\",\"type\":\"uint256\"},{\"name\":\"drawSalesEarnings\",\"type\":\"int256\"},{\"name\":\"dealerEarnings\",\"type\":\"int256\"},{\"name\":\"baseBonusPool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"lockUnlockMatchGPForBetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_internalToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newBettingInfoId\",\"type\":\"uint256\"}],\"name\":\"NewBettingSucceed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"MatchAllGPsLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newGPId\",\"type\":\"uint256\"}],\"name\":\"NewGamblingPartyFounded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"MatchAllGPsEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gamblingPartyId\",\"type\":\"uint256\"}],\"name\":\"GamblingPartyEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SoccerGamblingV_QIU","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000037f387fe48c9569500b514a1c7e1f6b04be8d421","Library":"","SwarmSource":"bzzr://00563c9dc68b92e70abbb2f130fe2673c1b6bda87dfc0212fbdd5c3fe24c8bfe"}]}