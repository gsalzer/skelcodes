{"status":"1","message":"OK","result":[{"SourceCode":"// BitFrank.com : The unstoppable on-chain exchange of ERC20 tokens\r\n// Copyright (c) 2018. All rights reserved.\r\n\r\npragma solidity ^0.4.20;\r\n\r\ncontract SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function transfer(address dst, uint wad) public returns (bool);\r\n    function transferFrom(address src, address dst, uint wad) public returns (bool);\r\n}\r\n\r\ncontract BitFrank is SafeMath {\r\n    \r\n    address public admin;\r\n    \r\n    string public constant name = \"BitFrank v1\";\r\n    bool public suspendDeposit = false; // if we are upgrading to a new contract, deposit will be suspended, but you can still withdraw / trade\r\n \r\n    // market details for each TOKEN\r\n    struct TOKEN_DETAIL {\r\n        uint8 level; // 1 = listed, 2 = registered, 3 = verified (by admin), MAX = 9\r\n        uint fee; // fee for taker. 100 = 0.01%, 1000 = 0.1%, 10000 = 1%, 1000000 = 100%\r\n    }\r\n    uint public marketRegisterCost = 99 * (10 ** 16); // 0.99 ETH\r\n    uint public marketDefaultFeeLow = 2000; // 0.2%\r\n    uint public marketDefaultFeeHigh = 8000; // 0.8%\r\n    \r\n    mapping (address => TOKEN_DETAIL) public tokenMarket; // registered token details\r\n    address[] public tokenList; // list of registered tokens\r\n    \r\n    mapping (address => mapping (address => uint)) public balance; // balance[tokenAddr][userAddr]\r\n    mapping (address => mapping (address => uint)) public balanceLocked; // token locked in orders\r\n    \r\n    uint public globalOrderSerial = 100000; // always increasing\r\n    uint public PRICE_FACTOR = 10 ** 18; // all prices are multiplied by PRICE_FACTOR\r\n    \r\n    struct ORDER {\r\n        address token;\r\n        bool isBuy; // buy or sell\r\n        address user; // userMaker\r\n        uint wad;\r\n        uint wadFilled;\r\n        uint price; // all prices are multiplied by PRICE_FACTOR\r\n        uint listPosition; // position in orderList, useful when updating orderList\r\n    }\r\n    \r\n    mapping (uint => ORDER) public order; // [orderID] => ORDER\r\n    uint[] public orderList; // list of orderIDs\r\n\r\n    //============== EVENTS ==============\r\n    \r\n    event MARKET_CHANGE(address indexed token);\r\n    event DEPOSIT(address indexed user, address indexed token, uint wad, uint result);\r\n    event WITHDRAW(address indexed user, address indexed token, uint wad, uint result);\r\n    event ORDER_PLACE(address indexed user, address indexed token, bool isBuy, uint wad, uint price, uint indexed id);\r\n    event ORDER_CANCEL(address indexed user, address indexed token, uint indexed id);\r\n    event ORDER_MODIFY(address indexed user, address indexed token, uint indexed id, uint new_wad, uint new_price);\r\n    event ORDER_FILL(address indexed userTaker, address userMaker, address indexed token, bool isOriginalOrderBuy, uint fillAmt, uint price, uint indexed id);\r\n    event ORDER_DONE(address indexed userTaker, address userMaker, address indexed token, bool isOriginalOrderBuy, uint fillAmt, uint price, uint indexed id);\r\n    \r\n    //============== ORDER PLACEMENT & TRADE ==============\r\n    \r\n    // get order list count\r\n    \r\n    function getOrderCount() public constant returns (uint) {\r\n        return orderList.length;\r\n    }\r\n    \r\n    // limit order @ price (all prices are multiplied by PRICE_FACTOR)\r\n    \r\n    function orderPlace(address token, bool isBuy, uint wad, uint price) public {\r\n        \r\n        uint newLocked;\r\n        if (isBuy) { // buy token, lock ETH\r\n            newLocked = add(balanceLocked[0][msg.sender], mul(wad, price) / PRICE_FACTOR);\r\n            require(balance[0][msg.sender] >= newLocked);\r\n            balanceLocked[0][msg.sender] = newLocked;\r\n        } else { // sell token, lock token\r\n            newLocked = add(balanceLocked[token][msg.sender], wad);\r\n            require(balance[token][msg.sender] >= newLocked);\r\n            balanceLocked[token][msg.sender] = newLocked;\r\n        }\r\n        \r\n        // place order\r\n        ORDER memory o;\r\n        o.token = token;\r\n        o.isBuy = isBuy;\r\n        o.wad = wad;\r\n        o.price = price;\r\n        o.user = msg.sender;\r\n        o.listPosition = orderList.length; // position in orderList\r\n        order[globalOrderSerial] = o;\r\n        \r\n        // update order list with orderID = globalOrderSerial\r\n        orderList.push(globalOrderSerial);\r\n        \r\n        // event\r\n        ORDER_PLACE(msg.sender, token, isBuy, wad, price, globalOrderSerial);\r\n\r\n        globalOrderSerial++; // can never overflow\r\n    }\r\n    \r\n    // market order to take order @ price (all prices are multiplied by PRICE_FACTOR)\r\n    \r\n    function orderTrade(uint orderID, uint wad, uint price) public {\r\n        \r\n        ORDER storage o = order[orderID];\r\n        require(price == o.price); // price must match, because maker can modify price\r\n        \r\n        // fill amt\r\n        uint fillAmt = sub(o.wad, o.wadFilled);\r\n        if (fillAmt > wad) fillAmt = wad;\r\n        \r\n        // fill ETH and fee\r\n        uint fillETH = mul(fillAmt, price) / PRICE_FACTOR;\r\n        uint fee = mul(fillETH, tokenMarket[o.token].fee) / 1000000;\r\n    \r\n        uint newTakerBalance;\r\n        \r\n        if (o.isBuy) { // taker is selling token to maker\r\n            \r\n            // remove token from taker (check balance first)\r\n            newTakerBalance = sub(balance[o.token][msg.sender], fillAmt);\r\n            require(newTakerBalance >= balanceLocked[o.token][msg.sender]);\r\n            balance[o.token][msg.sender] = newTakerBalance;\r\n            \r\n            // remove ETH from maker\r\n            balance[0][o.user] = sub(balance[0][o.user], fillETH);\r\n            balanceLocked[0][o.user] = sub(balanceLocked[0][o.user], fillETH);\r\n            \r\n            // give token to maker\r\n            balance[o.token][o.user] = add(balance[o.token][o.user], fillAmt);\r\n            \r\n            // give ETH (after fee) to taker \r\n            balance[0][msg.sender] = add(balance[0][msg.sender], sub(fillETH, fee));\r\n            \r\n        } else { // taker is buying token from maker\r\n        \r\n            // remove ETH (with fee) from taker (check balance first)\r\n            newTakerBalance = sub(balance[0][msg.sender], add(fillETH, fee));\r\n            require(newTakerBalance >= balanceLocked[0][msg.sender]);\r\n            balance[0][msg.sender] = newTakerBalance;\r\n\r\n            // remove token from maker\r\n            balance[o.token][o.user] = sub(balance[o.token][o.user], fillAmt);\r\n            balanceLocked[o.token][o.user] = sub(balanceLocked[o.token][o.user], fillAmt);\r\n            \r\n            // give ETH to maker\r\n            balance[0][o.user] = add(balance[0][o.user], fillETH);\r\n\r\n            // give token to taker\r\n            balance[o.token][msg.sender] = add(balance[o.token][msg.sender], fillAmt);\r\n        }\r\n        \r\n        balance[0][admin] = add(balance[0][admin], fee);\r\n\r\n        // fill order\r\n        o.wadFilled = add(o.wadFilled, fillAmt);\r\n        \r\n        // remove filled order\r\n        if (o.wadFilled >= o.wad) {\r\n\r\n            // update order list\r\n            orderList[o.listPosition] = orderList[orderList.length - 1];\r\n            order[orderList[o.listPosition]].listPosition = o.listPosition; // update position in orderList\r\n            orderList.length--;\r\n            \r\n            // delete order\r\n            ORDER_DONE(msg.sender, o.user, o.token, o.isBuy, fillAmt, price, orderID);\r\n\r\n            delete order[orderID];\r\n            \r\n        } else {\r\n            ORDER_FILL(msg.sender, o.user, o.token, o.isBuy, fillAmt, price, orderID);\r\n        }\r\n    }\r\n    \r\n    function orderCancel(uint orderID) public {\r\n        // make sure the order is correct\r\n        ORDER memory o = order[orderID]; // o is not modified\r\n        require(o.user == msg.sender);\r\n\r\n        uint wadLeft = sub(o.wad, o.wadFilled);\r\n\r\n        // release remained amt\r\n        if (o.isBuy) { // release ETH\r\n            balanceLocked[0][msg.sender] = sub(balanceLocked[0][msg.sender], mul(o.price, wadLeft) / PRICE_FACTOR);\r\n        } else { // release token\r\n            balanceLocked[o.token][msg.sender] = sub(balanceLocked[o.token][msg.sender], wadLeft);\r\n        }\r\n\r\n        ORDER_CANCEL(msg.sender, o.token, orderID);\r\n        \r\n        // update order list\r\n        orderList[o.listPosition] = orderList[orderList.length - 1];\r\n        order[orderList[o.listPosition]].listPosition = o.listPosition; // update position in orderList\r\n        orderList.length--;\r\n        \r\n        // delete order\r\n        delete order[orderID];\r\n    }\r\n    \r\n    function orderModify(uint orderID, uint new_wad, uint new_price) public {\r\n        // make sure the order is correct\r\n        ORDER storage o = order[orderID]; // o is modified\r\n        require(o.user == msg.sender);\r\n        require(o.wadFilled == 0); // for simplicity, you can't change filled orders\r\n        \r\n        // change amount of locked assets\r\n        \r\n        uint newLocked;\r\n        if (o.isBuy) { // lock ETH\r\n            newLocked = sub(add(balanceLocked[0][msg.sender], mul(new_wad, new_price) / PRICE_FACTOR), mul(o.wad, o.price) / PRICE_FACTOR);\r\n            require(balance[0][msg.sender] >= newLocked);\r\n            balanceLocked[0][msg.sender] = newLocked;\r\n        } else { // lock token\r\n            newLocked = sub(add(balanceLocked[o.token][msg.sender], new_wad), o.wad);\r\n            require(balance[o.token][msg.sender] >= newLocked);\r\n            balanceLocked[o.token][msg.sender] = newLocked;\r\n        }\r\n    \r\n        // modify order\r\n        o.wad = new_wad;\r\n        o.price = new_price;\r\n        \r\n        ORDER_MODIFY(msg.sender, o.token, orderID, new_wad, new_price);\r\n    }\r\n  \r\n    //============== ADMINISTRATION ==============\r\n  \r\n    function BitFrank() public {\r\n        admin = msg.sender;\r\n        \r\n        adminSetMarket(0, 9, 0); // ETH, level 9, fee = 0\r\n    }\r\n    \r\n    // set admin\r\n    function adminSetAdmin(address newAdmin) public {\r\n        require(msg.sender == admin);\r\n        require(balance[0][newAdmin] > 0); // newAdmin must have deposits\r\n        admin = newAdmin;\r\n    }\r\n    \r\n    // suspend deposit (prepare for upgrading to a new contract)\r\n    function adminSuspendDeposit(bool status) public {\r\n        require(msg.sender == admin);\r\n        suspendDeposit = status;\r\n    }\r\n    \r\n    // set market details\r\n    function adminSetMarket(address token, uint8 level_, uint fee_) public {\r\n        require(msg.sender == admin);\r\n        require(level_ != 0);\r\n        require(level_ <= 9);\r\n        if (tokenMarket[token].level == 0) {\r\n            tokenList.push(token);\r\n        }\r\n        tokenMarket[token].level = level_;\r\n        tokenMarket[token].fee = fee_;\r\n        MARKET_CHANGE(token);\r\n    }\r\n    \r\n    // set register cost\r\n    function adminSetRegisterCost(uint cost_) public {\r\n        require(msg.sender == admin);\r\n        marketRegisterCost = cost_;\r\n    }\r\n    \r\n    // set default fee\r\n    function adminSetDefaultFee(uint marketDefaultFeeLow_, uint marketDefaultFeeHigh_) public {\r\n        require(msg.sender == admin);\r\n        marketDefaultFeeLow = marketDefaultFeeLow_;\r\n        marketDefaultFeeHigh = marketDefaultFeeHigh_;\r\n    }\r\n    \r\n    //============== MARKET REGISTRATION & HELPER ==============\r\n\r\n    // register token\r\n    function marketRegisterToken(address token) public payable {\r\n        require(tokenMarket[token].level == 1);\r\n        require(msg.value >= marketRegisterCost); // register cost\r\n        balance[0][admin] = add(balance[0][admin], msg.value);\r\n        \r\n        tokenMarket[token].level = 2;\r\n        tokenMarket[token].fee = marketDefaultFeeLow;\r\n        MARKET_CHANGE(token);\r\n    }\r\n    \r\n    // get token list count\r\n    function getTokenCount() public constant returns (uint) {\r\n        return tokenList.length;\r\n    }\r\n  \r\n    //============== DEPOSIT & WITHDRAW ==============\r\n  \r\n    function depositETH() public payable {\r\n        require(!suspendDeposit);\r\n        balance[0][msg.sender] = add(balance[0][msg.sender], msg.value);\r\n        DEPOSIT(msg.sender, 0, msg.value, balance[0][msg.sender]);\r\n    }\r\n\r\n    function depositToken(address token, uint wad) public {\r\n        require(!suspendDeposit);\r\n        // remember to call TOKEN(address).approve(this, wad) first\r\n        require(ERC20(token).transferFrom(msg.sender, this, wad)); // transfer token\r\n        \r\n        // add new token to list\r\n        if (tokenMarket[token].level == 0) {\r\n            tokenList.push(token);\r\n            tokenMarket[token].level = 1;\r\n            tokenMarket[token].fee = marketDefaultFeeHigh;\r\n            MARKET_CHANGE(token);\r\n        }\r\n        \r\n        balance[token][msg.sender] = add(balance[token][msg.sender], wad); // set balance\r\n        DEPOSIT(msg.sender, token, wad, balance[token][msg.sender]);\r\n    }\r\n\r\n    function withdrawETH(uint wad) public {\r\n        balance[0][msg.sender] = sub(balance[0][msg.sender], wad); // set amt first\r\n        require(balance[0][msg.sender] >= balanceLocked[0][msg.sender]); // can't withdraw locked ETH\r\n        msg.sender.transfer(wad); // send ETH\r\n        WITHDRAW(msg.sender, 0, wad, balance[0][msg.sender]);\r\n    }\r\n    \r\n    function withdrawToken(address token, uint wad) public {\r\n        require(token != 0); // not for withdrawing ETH\r\n        balance[token][msg.sender] = sub(balance[token][msg.sender], wad);\r\n        require(balance[token][msg.sender] >= balanceLocked[token][msg.sender]); // can't withdraw locked token\r\n        require(ERC20(token).transfer(msg.sender, wad)); // send token\r\n        WITHDRAW(msg.sender, token, wad, balance[token][msg.sender]);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenMarket\",\"outputs\":[{\"name\":\"level\",\"type\":\"uint8\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalOrderSerial\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"adminSetAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"order\",\"outputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"isBuy\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"},{\"name\":\"wadFilled\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"listPosition\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"adminSuspendDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"level_\",\"type\":\"uint8\"},{\"name\":\"fee_\",\"type\":\"uint256\"}],\"name\":\"adminSetMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"isBuy\",\"type\":\"bool\"},{\"name\":\"wad\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"orderPlace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderID\",\"type\":\"uint256\"},{\"name\":\"new_wad\",\"type\":\"uint256\"},{\"name\":\"new_price\",\"type\":\"uint256\"}],\"name\":\"orderModify\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketRegisterCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cost_\",\"type\":\"uint256\"}],\"name\":\"adminSetRegisterCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"suspendDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderID\",\"type\":\"uint256\"}],\"name\":\"orderCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"marketRegisterToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderID\",\"type\":\"uint256\"},{\"name\":\"wad\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"orderTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"marketDefaultFeeLow_\",\"type\":\"uint256\"},{\"name\":\"marketDefaultFeeHigh_\",\"type\":\"uint256\"}],\"name\":\"adminSetDefaultFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketDefaultFeeHigh\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketDefaultFeeLow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MARKET_CHANGE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"DEPOSIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"WITHDRAW\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ORDER_PLACE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ORDER_CANCEL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"new_wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"new_price\",\"type\":\"uint256\"}],\"name\":\"ORDER_MODIFY\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"userTaker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"userMaker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isOriginalOrderBuy\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"fillAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ORDER_FILL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"userTaker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"userMaker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isOriginalOrderBuy\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"fillAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ORDER_DONE\",\"type\":\"event\"}]","ContractName":"BitFrank","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://facd0c872b15cbb48c09d0871784fe313f877fedc4d29350ba775c5e1289f925"}]}