{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract AtomicSwap {\r\n  struct Swap {\r\n    uint expiration;\r\n    address initiator;\r\n    address participant;\r\n    uint256 value;\r\n    bool isToken;\r\n    address token;\r\n    bool exists;\r\n  }\r\n\r\n  // maps the redeemer and bytes20 hash to a swap    \r\n  mapping(address => mapping(bytes20 => Swap)) public swaps;\r\n\r\n  function initiate(uint _expiration, bytes20 _hash, address _participant, address _token, bool _isToken, uint256 _value) payable public {\r\n    Swap storage s = swaps[_participant][_hash];\r\n    // make sure you aren't overwriting a pre-existing swap\r\n    // (so the original initiator can't rewrite the terms)\r\n    require (s.exists == false);\r\n    // don't allow the creation of already expired swaps\r\n    require (now < _expiration);\r\n\r\n    if (_isToken) {\r\n      // require that the sender has allowed the tokens to be withdrawn from their account\r\n      ERC20 token = ERC20(_token);\r\n      require(token.allowance(msg.sender, this) == _value);\r\n      token.transferFrom(msg.sender, this, _value);\r\n    }\r\n    // create the new swap\r\n    swaps[_participant][_hash] = Swap(_expiration, msg.sender, _participant, _isToken ? _value : msg.value, _isToken, _token, true);\r\n  }\r\n\r\n  function redeem(bytes32 _secret) public {\r\n    // get a swap from the mapping. we can do it directly because there is no way to \r\n    // fake the secret.\r\n    bytes20 hash = ripemd160(_secret);\r\n    Swap storage s = swaps[msg.sender][hash];\r\n    \r\n    // make sure the swap was not redeemed or refunded\r\n    require(s.exists);\r\n    // make sure the swap did not expire already\r\n    require(now < s.expiration);\r\n    \r\n    // clean up and send\r\n    s.exists = false;\r\n    if (s.isToken) {\r\n      ERC20 token = ERC20(s.token);\r\n      token.transfer(msg.sender, s.value);\r\n    } else {\r\n      msg.sender.transfer(s.value);\r\n    }\r\n  }\r\n\r\n  function refund(bytes20 _hash, address _participant) public {\r\n    Swap storage s = swaps[_participant][_hash];\r\n    // don't allow refund if swap did not expire\r\n    require(now > s.expiration);\r\n    // don't allow refunds if the caller is not the initator\r\n    require(msg.sender == s.initiator);\r\n    // make sure the swap was not redeemed or refunded\r\n    require(s.exists);\r\n\r\n    s.exists = false;\r\n    if (s.isToken) {\r\n      ERC20 token = ERC20(s.token);\r\n      token.transfer(msg.sender, s.value);\r\n    } else {\r\n      msg.sender.transfer(s.value);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_expiration\",\"type\":\"uint256\"},{\"name\":\"_hash\",\"type\":\"bytes20\"},{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_isToken\",\"type\":\"bool\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"initiate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes20\"}],\"name\":\"swaps\",\"outputs\":[{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isToken\",\"type\":\"bool\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes20\"},{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AtomicSwap","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://80c28590daee4218773406d0edfd8b337dede21fdd2c4ccf23ee33cd44409369"}]}