{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/AccountLevels.sol\r\n\r\ncontract AccountLevels {\r\n  //given a user, returns an account level\r\n  //0 = regular user (pays take fee and make fee)\r\n  //1 = market maker silver (pays take fee, no make fee, gets rebate)\r\n  //2 = market maker gold (pays take fee, no make fee, gets entire counterparty's take fee as rebate)\r\n  function accountLevel(address user) public constant returns(uint);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/SwissCryptoExchange.sol\r\n\r\n/**\r\n * @title SwissCryptoExchange\r\n */\r\ncontract SwissCryptoExchange {\r\n  using SafeMath for uint256;\r\n\r\n  // Storage definition.\r\n  address public admin; //the admin address\r\n  address public feeAccount; //the account that will receive fees\r\n  address public accountLevelsAddr; //the address of the AccountLevels contract\r\n  uint256 public feeMake; //percentage times (1 ether)\r\n  uint256 public feeTake; //percentage times (1 ether)\r\n  uint256 public feeRebate; //percentage times (1 ether)\r\n  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => bool) public whitelistedTokens; //mapping of whitelisted token addresses (token=0 means Ether)\r\n  mapping (address => bool) public whitelistedUsers; // mapping of whitelisted users that can perform trading\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint256)) public orderFills; //mapping of user accounts to mapping of order hashes to uint256s (amount of order that has been filled)\r\n\r\n  // Events definition.\r\n  event Order(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address user);\r\n  event Cancel(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n  event Withdraw(address token, address user, uint256 amount, uint256 balance);\r\n\r\n  /**\r\n   * @dev Create a new instance of the SwissCryptoExchange contract.\r\n   * @param _admin             address Admin address\r\n   * @param _feeAccount        address Fee Account address\r\n   * @param _accountLevelsAddr address AccountLevels contract address\r\n   * @param _feeMake           uint256 FeeMake amount\r\n   * @param _feeTake           uint256 FeeTake amount\r\n   * @param _feeRebate         uint256 FeeRebate amount\r\n   */\r\n  function SwissCryptoExchange(\r\n    address _admin,\r\n    address _feeAccount,\r\n    address _accountLevelsAddr,\r\n    uint256 _feeMake,\r\n    uint256 _feeTake,\r\n    uint256 _feeRebate\r\n  )\r\n    public\r\n  {\r\n    // Ensure the admin address is valid.\r\n    require(_admin != 0x0);\r\n\r\n    // Store the values.\r\n    admin = _admin;\r\n    feeAccount = _feeAccount;\r\n    accountLevelsAddr = _accountLevelsAddr;\r\n    feeMake = _feeMake;\r\n    feeTake = _feeTake;\r\n    feeRebate = _feeRebate;\r\n\r\n    // Validate \"ethereum address\".\r\n    whitelistedTokens[0x0] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Ensure the function caller is the contract admin.\r\n   */\r\n  modifier onlyAdmin() { \r\n    require(msg.sender == admin);\r\n    _; \r\n  }\r\n\r\n  /**\r\n   * @dev The fallback function is not used for receiving money. If someone sends\r\n   *      wei directly to the contract address the transaction will fail.\r\n   */\r\n  function () public payable {\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * @dev Change the admin address.\r\n   * @param _admin address The new admin address\r\n   */\r\n  function changeAdmin(address _admin) public onlyAdmin {\r\n    // The provided address should be valid and different from the current one.\r\n    require(_admin != 0x0 && admin != _admin);\r\n\r\n    // Store the new value.\r\n    admin = _admin;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the AccountLevels contract address. This address could be set to 0x0\r\n   *      if the functionality is not needed.\r\n   * @param _accountLevelsAddr address The new AccountLevels contract address\r\n   */\r\n  function changeAccountLevelsAddr(address _accountLevelsAddr) public onlyAdmin {\r\n    // Store the new value.\r\n    accountLevelsAddr = _accountLevelsAddr;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the feeAccount address.\r\n   * @param _feeAccount address\r\n   */\r\n  function changeFeeAccount(address _feeAccount) public onlyAdmin {\r\n    // The provided address should be valid.\r\n    require(_feeAccount != 0x0);\r\n\r\n    // Store the new value.\r\n    feeAccount = _feeAccount;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the feeMake amount.\r\n   * @param _feeMake uint256 New fee make.\r\n   */\r\n  function changeFeeMake(uint256 _feeMake) public onlyAdmin {\r\n    // Store the new value.\r\n    feeMake = _feeMake;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the feeTake amount.\r\n   * @param _feeTake uint256 New fee take.\r\n   */\r\n  function changeFeeTake(uint256 _feeTake) public onlyAdmin {\r\n    // The new feeTake should be greater than or equal to the feeRebate.\r\n    require(_feeTake >= feeRebate);\r\n\r\n    // Store the new value.\r\n    feeTake = _feeTake;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the feeRebate amount.\r\n   * @param _feeRebate uint256 New fee rebate.\r\n   */\r\n  function changeFeeRebate(uint256 _feeRebate) public onlyAdmin {\r\n    // The new feeRebate should be less than or equal to the feeTake.\r\n    require(_feeRebate <= feeTake);\r\n\r\n    // Store the new value.\r\n    feeRebate = _feeRebate;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a ERC20 token contract address to the whitelisted ones.\r\n   * @param token address Address of the contract to be added to the whitelist.\r\n   */\r\n  function addWhitelistedTokenAddr(address token) public onlyAdmin {\r\n    // Token address should not be 0x0 (ether) and it should not be already whitelisted.\r\n    require(token != 0x0 && !whitelistedTokens[token]);\r\n\r\n    // Change the flag for this contract address to true.\r\n    whitelistedTokens[token] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Remove a ERC20 token contract address from the whitelisted ones.\r\n   * @param token address Address of the contract to be removed from the whitelist.\r\n   */\r\n  function removeWhitelistedTokenAddr(address token) public onlyAdmin {\r\n    // Token address should not be 0x0 (ether) and it should be whitelisted.\r\n    require(token != 0x0 && whitelistedTokens[token]);\r\n\r\n    // Change the flag for this contract address to false.\r\n    whitelistedTokens[token] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Add an user address to the whitelisted ones.\r\n   * @param user address Address to be added to the whitelist.\r\n   */\r\n  function addWhitelistedUserAddr(address user) public onlyAdmin {\r\n    // Address provided should be valid and not already whitelisted.\r\n    require(user != 0x0 && !whitelistedUsers[user]);\r\n\r\n    // Change the flag for this address to false.\r\n    whitelistedUsers[user] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Remove an user address from the whitelisted ones.\r\n   * @param user address Address to be removed from the whitelist.\r\n   */\r\n  function removeWhitelistedUserAddr(address user) public onlyAdmin {\r\n    // Address provided should be valid and whitelisted.\r\n    require(user != 0x0 && whitelistedUsers[user]);\r\n\r\n    // Change the flag for this address to false.\r\n    whitelistedUsers[user] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Deposit wei into the exchange contract.\r\n   */\r\n  function deposit() public payable {\r\n    // Only whitelisted users can make deposits.\r\n    require(whitelistedUsers[msg.sender]);\r\n\r\n    // Add the deposited wei amount to the user balance.\r\n    tokens[0x0][msg.sender] = tokens[0x0][msg.sender].add(msg.value);\r\n\r\n    // Trigger the event.\r\n    Deposit(0x0, msg.sender, msg.value, tokens[0x0][msg.sender]);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw wei from the exchange contract back to the user. \r\n   * @param amount uint256 Wei amount to be withdrawn.\r\n   */\r\n  function withdraw(uint256 amount) public {\r\n    // Requester should have enough balance.\r\n    require(tokens[0x0][msg.sender] >= amount);\r\n  \r\n    // Substract the withdrawn wei amount from the user balance.\r\n    tokens[0x0][msg.sender] = tokens[0x0][msg.sender].sub(amount);\r\n\r\n    // Transfer the wei to the requester.\r\n    msg.sender.transfer(amount);\r\n\r\n    // Trigger the event.\r\n    Withdraw(0x0, msg.sender, amount, tokens[0x0][msg.sender]);\r\n  }\r\n\r\n  /**\r\n   * @dev Perform a new token deposit to the exchange contract.\r\n   * @dev Remember to call ERC20(address).approve(this, amount) or this contract will not\r\n   *      be able to do the transfer on your behalf.\r\n   * @param token  address Address of the deposited token contract\r\n   * @param amount uint256 Amount to be deposited\r\n   */\r\n  function depositToken(address token, uint256 amount)\r\n    public\r\n  {\r\n    // Should not deposit wei using this function and\r\n    // token contract address should be whitelisted.\r\n    require(token != 0x0 && whitelistedTokens[token]);\r\n      \r\n    // Only whitelisted users can make deposits.\r\n    require(whitelistedUsers[msg.sender]);\r\n\r\n    // Add the deposited token amount to the user balance.\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\r\n    \r\n    // Transfer tokens from caller to this contract account.\r\n    require(ERC20(token).transferFrom(msg.sender, address(this), amount));\r\n  \r\n    // Trigger the event.    \r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw the given token amount from the requester balance.\r\n   * @param token  address Address of the withdrawn token contract\r\n   * @param amount uint256 Amount of tokens to be withdrawn\r\n   */\r\n  function withdrawToken(address token, uint256 amount) public {\r\n    // Should not withdraw wei using this function.\r\n    require(token != 0x0);\r\n\r\n    // Requester should have enough balance.\r\n    require(tokens[token][msg.sender] >= amount);\r\n\r\n    // Substract the withdrawn token amount from the user balance.\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n    \r\n    // Transfer the tokens to the investor.\r\n    require(ERC20(token).transfer(msg.sender, amount));\r\n\r\n    // Trigger the event.\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  /**\r\n   * @dev Check the balance of the given user in the given token.\r\n   * @param token address Address of the token contract\r\n   * @param user  address Address of the user whom balance will be queried\r\n   */\r\n  function balanceOf(address token, address user)\r\n    public\r\n    constant\r\n    returns (uint256)\r\n  {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  /**\r\n   * @dev Place a new order to the this contract. \r\n   * @param tokenGet   address\r\n   * @param amountGet  uint256\r\n   * @param tokenGive  address\r\n   * @param amountGive uint256\r\n   * @param expires    uint256\r\n   * @param nonce      uint256\r\n   */\r\n  function order(\r\n    address tokenGet,\r\n    uint256 amountGet,\r\n    address tokenGive,\r\n    uint256 amountGive,\r\n    uint256 expires,\r\n    uint256 nonce\r\n  )\r\n    public\r\n  {\r\n    // Order placer address should be whitelisted.\r\n    require(whitelistedUsers[msg.sender]);\r\n\r\n    // Order tokens addresses should be whitelisted. \r\n    require(whitelistedTokens[tokenGet] && whitelistedTokens[tokenGive]);\r\n\r\n    // Calculate the order hash.\r\n    bytes32 hash = keccak256(address(this), tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    \r\n    // Store the order.\r\n    orders[msg.sender][hash] = true;\r\n\r\n    // Trigger the event.\r\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel an existing order.\r\n   * @param tokenGet   address\r\n   * @param amountGet  uint256\r\n   * @param tokenGive  address\r\n   * @param amountGive uint256\r\n   * @param expires    uint256\r\n   * @param nonce      uint256\r\n   * @param v          uint8\r\n   * @param r          bytes32\r\n   * @param s          bytes32\r\n   */\r\n  function cancelOrder(\r\n    address tokenGet,\r\n    uint256 amountGet,\r\n    address tokenGive,\r\n    uint256 amountGive,\r\n    uint256 expires,\r\n    uint256 nonce,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  )\r\n    public\r\n  {\r\n    // Calculate the order hash.\r\n    bytes32 hash = keccak256(address(this), tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    \r\n    // Ensure the message validity.\r\n    require(validateOrderHash(hash, msg.sender, v, r, s));\r\n    \r\n    // Fill the order to the requested amount.\r\n    orderFills[msg.sender][hash] = amountGet;\r\n\r\n    // Trigger the event.\r\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * @dev Perform a trade.\r\n   * @param tokenGet   address\r\n   * @param amountGet  uint256\r\n   * @param tokenGive  address\r\n   * @param amountGive uint256\r\n   * @param expires    uint256\r\n   * @param nonce      uint256\r\n   * @param user       address\r\n   * @param v          uint8\r\n   * @param r          bytes32\r\n   * @param s          bytes32\r\n   * @param amount     uint256 Traded amount - in amountGet terms\r\n   */\r\n  function trade(\r\n    address tokenGet,\r\n    uint256 amountGet,\r\n    address tokenGive,\r\n    uint256 amountGive,\r\n    uint256 expires,\r\n    uint256 nonce,\r\n    address user,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    uint256 amount \r\n  )\r\n    public\r\n  {\r\n    // Only whitelisted users can perform trades.\r\n    require(whitelistedUsers[msg.sender]);\r\n\r\n    // Only whitelisted tokens can be traded.\r\n    require(whitelistedTokens[tokenGet] && whitelistedTokens[tokenGive]);\r\n\r\n    // Expire block number should be greater than current block.\r\n    require(block.number <= expires);\r\n\r\n    // Calculate the trade hash.\r\n    bytes32 hash = keccak256(address(this), tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    \r\n    // Validate the hash.\r\n    require(validateOrderHash(hash, user, v, r, s));\r\n\r\n    // Ensure that after the trade the ordered amount will not be excedeed.\r\n    require(SafeMath.add(orderFills[user][hash], amount) <= amountGet); \r\n    \r\n    // Add the traded amount to the order fill.\r\n    orderFills[user][hash] = orderFills[user][hash].add(amount);\r\n\r\n    // Trade balances.\r\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n    \r\n    // Trigger the event.\r\n    Trade(tokenGet, amount, tokenGive, SafeMath.mul(amountGive, amount).div(amountGet), user, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Check if the trade with provided parameters will pass or not.\r\n   * @param tokenGet   address\r\n   * @param amountGet  uint256\r\n   * @param tokenGive  address\r\n   * @param amountGive uint256\r\n   * @param expires    uint256\r\n   * @param nonce      uint256\r\n   * @param user       address\r\n   * @param v          uint8\r\n   * @param r          bytes32\r\n   * @param s          bytes32\r\n   * @param amount     uint256\r\n   * @param sender     address\r\n   * @return bool\r\n   */\r\n  function testTrade(\r\n    address tokenGet,\r\n    uint256 amountGet,\r\n    address tokenGive,\r\n    uint256 amountGive,\r\n    uint256 expires,\r\n    uint256 nonce,\r\n    address user,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    uint256 amount,\r\n    address sender\r\n  )\r\n    public\r\n    constant\r\n    returns(bool)\r\n  {\r\n    // Traders should be whitelisted.\r\n    require(whitelistedUsers[user] && whitelistedUsers[sender]);\r\n\r\n    // Tokens should be whitelisted.\r\n    require(whitelistedTokens[tokenGet] && whitelistedTokens[tokenGive]);\r\n\r\n    // Sender should have at least the amount he wants to trade and \r\n    require(tokens[tokenGet][sender] >= amount);\r\n\r\n    // order should have available volume to fill.\r\n    return availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate the available volume for a given trade.\r\n   * @param tokenGet   address\r\n   * @param amountGet  uint256\r\n   * @param tokenGive  address\r\n   * @param amountGive uint256\r\n   * @param expires    uint256\r\n   * @param nonce      uint256\r\n   * @param user       address\r\n   * @param v          uint8\r\n   * @param r          bytes32\r\n   * @param s          bytes32\r\n   * @return uint256\r\n   */\r\n  function availableVolume(\r\n    address tokenGet,\r\n    uint256 amountGet,\r\n    address tokenGive,\r\n    uint256 amountGive,\r\n    uint256 expires,\r\n    uint256 nonce,\r\n    address user,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  )\r\n    public\r\n    constant\r\n    returns (uint256)\r\n  {\r\n    // User should be whitelisted.\r\n    require(whitelistedUsers[user]);\r\n\r\n    // Tokens should be whitelisted.\r\n    require(whitelistedTokens[tokenGet] && whitelistedTokens[tokenGive]);\r\n\r\n    // Calculate the hash.\r\n    bytes32 hash = keccak256(address(this), tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n\r\n    // If the order is not valid or the trade is expired early exit with 0.\r\n    if (!(validateOrderHash(hash, user, v, r, s) && block.number <= expires)) {\r\n      return 0;\r\n    }\r\n\r\n    // Condition is used for ensuring the the value returned is\r\n    //   - the maximum available balance of the user in tokenGet terms if the user can't fullfil all the order\r\n    //     - SafeMath.sub(amountGet, orderFills[user][hash])\r\n    //     - amountGet - amountAvailableForFill\r\n    //   - the available balance of the the user in tokenGet terms if the user has enough to fullfil all the order \r\n    //     - SafeMath.mul(tokens[tokenGive][user], amountGet).div(amountGive) \r\n    //     - balanceGiveAvailable * amountGet / amountGive\r\n    //     - amountGet / amountGive represents the exchange rate \r\n    if (SafeMath.sub(amountGet, orderFills[user][hash]) < SafeMath.mul(tokens[tokenGive][user], amountGet).div(amountGive)) {\r\n      return SafeMath.sub(amountGet, orderFills[user][hash]);\r\n    }\r\n\r\n    return SafeMath.mul(tokens[tokenGive][user], amountGet).div(amountGive);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the amount filled for the given order.\r\n   * @param tokenGet   address\r\n   * @param amountGet  uint256\r\n   * @param tokenGive  address\r\n   * @param amountGive uint256\r\n   * @param expires    uint256\r\n   * @param nonce      uint256\r\n   * @param user       address\r\n   * @return uint256\r\n   */\r\n  function amountFilled(\r\n    address tokenGet,\r\n    uint256 amountGet,\r\n    address tokenGive,\r\n    uint256 amountGive,\r\n    uint256 expires,\r\n    uint256 nonce,\r\n    address user\r\n  )\r\n    public\r\n    constant\r\n    returns (uint256)\r\n  {\r\n    // User should be whitelisted.\r\n    require(whitelistedUsers[user]);\r\n\r\n    // Tokens should be whitelisted.\r\n    require(whitelistedTokens[tokenGet] && whitelistedTokens[tokenGive]);\r\n\r\n    // Return the amount filled for the given order.\r\n    return orderFills[user][keccak256(address(this), tokenGet, amountGet, tokenGive, amountGive, expires, nonce)];\r\n  }\r\n\r\n    /**\r\n   * @dev Trade balances of given tokens amounts between two users.\r\n   * @param tokenGet   address\r\n   * @param amountGet  uint256\r\n   * @param tokenGive  address\r\n   * @param amountGive uint256\r\n   * @param user       address\r\n   * @param amount     uint256\r\n   */\r\n  function tradeBalances(\r\n    address tokenGet,\r\n    uint256 amountGet,\r\n    address tokenGive,\r\n    uint256 amountGive,\r\n    address user,\r\n    uint256 amount\r\n  )\r\n    private\r\n  {\r\n    // Calculate the constant taxes.\r\n    uint256 feeMakeXfer = amount.mul(feeMake).div(1 ether);\r\n    uint256 feeTakeXfer = amount.mul(feeTake).div(1 ether);\r\n    uint256 feeRebateXfer = 0;\r\n    \r\n    // Calculate the tax according to account level.\r\n    if (accountLevelsAddr != 0x0) {\r\n      uint256 accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\r\n      if (accountLevel == 1) {\r\n        feeRebateXfer = amount.mul(feeRebate).div(1 ether);\r\n      } else if (accountLevel == 2) {\r\n        feeRebateXfer = feeTakeXfer;\r\n      }\r\n    }\r\n\r\n    // Update the balances for both maker and taker and add the fee to the feeAccount.\r\n    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount.add(feeTakeXfer));\r\n    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount.add(feeRebateXfer).sub(feeMakeXfer));\r\n    tokens[tokenGet][feeAccount] = tokens[tokenGet][feeAccount].add(feeMakeXfer.add(feeTakeXfer).sub(feeRebateXfer));\r\n    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\r\n    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\r\n  }\r\n\r\n  /**\r\n   * @dev Validate an order hash.\r\n   * @param hash bytes32\r\n   * @param user address\r\n   * @param v    uint8\r\n   * @param r    bytes32\r\n   * @param s    bytes32\r\n   * @return bool\r\n   */\r\n  function validateOrderHash(\r\n    bytes32 hash,\r\n    address user,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  )\r\n    private\r\n    constant\r\n    returns (bool)\r\n  {\r\n    return (\r\n      orders[user][hash] ||\r\n      ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"order\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addWhitelistedUserAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"amountFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeMake\",\"type\":\"uint256\"}],\"name\":\"changeFeeMake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeMake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeRebate\",\"type\":\"uint256\"}],\"name\":\"changeFeeRebate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeWhitelistedTokenAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"testTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRebate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeTake\",\"type\":\"uint256\"}],\"name\":\"changeFeeTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addWhitelistedTokenAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeWhitelistedUserAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accountLevelsAddr\",\"type\":\"address\"}],\"name\":\"changeAccountLevelsAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accountLevelsAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"availableVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_feeAccount\",\"type\":\"address\"},{\"name\":\"_accountLevelsAddr\",\"type\":\"address\"},{\"name\":\"_feeMake\",\"type\":\"uint256\"},{\"name\":\"_feeTake\",\"type\":\"uint256\"},{\"name\":\"_feeRebate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"get\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"give\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"SwissCryptoExchange","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f909d2168d2623967e0e870c89576b0948dd32af00000000000000000000000061e6ecbcda879e42a9e98b7498bac5aa76b25d2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa87bee5380000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://234477659725ad38f361ac5a6b8b278da3ce8868b9cc541fd8eecc28ffe46b74"}]}