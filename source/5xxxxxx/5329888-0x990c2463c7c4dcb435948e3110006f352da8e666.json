{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n    // Required methods\r\n    function implementsERC721() public pure returns (bool);\r\n    // ERC20 compatible methods\r\n    function name() public pure returns (string);\r\n    function symbol() public pure returns (string);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function totalSupply() public view returns (uint256 total);\r\n    // Methods defining ownership\r\n    function ownerOf(uint256 _tokenId) public view returns (address addr);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function takeOwnership(uint256 _tokenId) public;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function transfer(address _to, uint256 _tokenId) public;\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint256 tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 tokenId);\r\n}\r\n\r\ncontract YTIcons is ERC721 {\r\n\r\n    /* CONSTANTS */\r\n\r\n    /// Name and symbol of the non-fungible token (ERC721)\r\n    string public constant NAME = \"YTIcons\";\r\n    string public constant SYMBOL = \"YTIcon\";\r\n\r\n    /// The corporation address that will be used for its development (giveaway, game events...)\r\n    address private _utilityFund = 0x6B06a2a15dCf3AE45b9F133Be6FD0Be5a9FAedC2;\r\n\r\n    /// When a card isn't verified, the normal share given to the beneficiary linked\r\n    /// to the card is given to the charity fund's address instead.\r\n    address private _charityFund = 0xF9864660c4aa89E241d7D44903D3c8A207644332;\r\n\r\n    uint16 public _generation = 0;\r\n    uint256 private _defaultPrice = 0.001 ether;\r\n    uint256 private firstLimit =  0.05 ether;\r\n    uint256 private secondLimit = 0.5 ether;\r\n    uint256 private thirdLimit = 1 ether;\r\n\r\n\r\n    /* STORAGE */\r\n\r\n    /// An array containing all of the owners addresses :\r\n    /// those addresses are the only ones that can execute actions requiring an admin.\r\n    address private _owner0x = 0x8E787E0c0B05BE25Ec993C5e109881166b675b31;\r\n    address private _ownerA =  0x97fEA5464539bfE3810b8185E9Fa9D2D6d68a52c;\r\n    address private _ownerB =  0x0678Ecc4Db075F89B966DE7Ea945C4A866966b0e;\r\n    address private _ownerC =  0xC39574B02b76a43B03747641612c3d332Dec679B;\r\n    address private _ownerD =  0x1282006521647ca094503219A61995C8142a9824;\r\n\r\n    Card[] private _cards;\r\n\r\n    /// A mapping from cards' IDs to their prices [0], the last investment* [1] and their highest price [2].\r\n    /// *If someone buys an icon for 0.001 ETH, then the last investment of the card will be 0.001 ETH. If someone else buys it back at 0.002 ETH,\r\n    /// then the last investment will be 0.002 ETH.\r\n    mapping (uint256 => uint256[3]) private _cardsPrices;\r\n\r\n    /// A mapping from cards' names to the beneficiary addresses\r\n    mapping (uint256 => address) private _beneficiaryAddresses;\r\n\r\n    /// A mapping from cards' IDs to their owners\r\n    mapping (uint256 => address) private _cardsOwners;\r\n\r\n    /// A mapping from owner address to count of tokens that address owns.\r\n    /// Used for ERC721's method 'balanceOf()' to resolve ownership count.\r\n    mapping (address => uint256) private _tokenPerOwners;\r\n\r\n    /// A mapping from cards' ids to an address that has been approved to call\r\n    /// transferFrom(). Each Card can only have one approved address for transfer\r\n    /// at any time. A zero value means no approval is outstanding.\r\n    mapping (uint256 => address) public _allowedAddresses;\r\n\r\n\r\n    /* STRUCTURES */\r\n\r\n    struct Card {\r\n        uint16  generation;\r\n        string  name;\r\n        bool    isLocked;\r\n    }\r\n\r\n    /* EVENTS */\r\n    event YTIconSold(uint256 tokenId, uint256 newPrice, address newOwner);\r\n    event PriceModified(uint256 tokenId, uint256 newPrice);\r\n\r\n\r\n\r\n    /* ACCESS MODIFIERS */\r\n\r\n    /// Access modifier for owner's functionalities and actions only\r\n    modifier ownerOnly() {\r\n        require(msg.sender == _owner0x || msg.sender == _ownerA || msg.sender == _ownerB || msg.sender == _ownerC || msg.sender == _ownerD);\r\n        _;\r\n    }\r\n\r\n\r\n    /* PROTOCOL METHODS (ERC721) */\r\n\r\n    function implementsERC721() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n        /**************/\r\n        /* ERC20 compatible methods */\r\n        /**************/\r\n\r\n    /// This function is used to tell outside contracts and applications the name of this token.\r\n    function name() public pure returns (string) {\r\n        return NAME;\r\n    }\r\n\r\n    /// It provides outside programs with the token’s shorthand name, or symbol.\r\n    function symbol() public pure returns (string) {\r\n        return SYMBOL;\r\n    }\r\n\r\n    /// This function returns the total number of coins available on the blockchain.\r\n    /// The supply does not have to be constant.\r\n    function totalSupply() public view returns (uint256 supply) {\r\n        return _cards.length;\r\n    }\r\n\r\n    /// This function is used to find the number of tokens that a given address owns.\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return _tokenPerOwners[_owner];\r\n    }\r\n\r\n        /**************/\r\n        /* Ownership methods */\r\n        /**************/\r\n\r\n    /// This function returns the address of the owner of a token. Because each ERC721 token is non-fungible and,\r\n    /// therefore, unique, it’s referenced on the blockchain via a unique ID.\r\n    /// We can determine the owner of a token using its ID.\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner) {\r\n        require(_addressNotNull(_cardsOwners[_tokenId]));\r\n        return _cardsOwners[_tokenId];\r\n    }\r\n\r\n    /// This function approves, or grants, another entity permission to transfer a token on the owner’s behalf.\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        require(bytes(_cards[_tokenId].name).length != 0);\r\n        require(!_cards[_tokenId].isLocked);\r\n        require(_owns(msg.sender, _tokenId));\r\n        require(msg.sender != _to);\r\n        _allowedAddresses[_tokenId] = _to;\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /// This function acts like a withdraw function, since an outside party can call it in order\r\n    /// to take tokens out of another user’s account.\r\n    /// Therefore, takeOwnership can be used to when a user has been approved to own a certain amount of\r\n    /// tokens and wishes to withdraw said tokens from another user’s balance.\r\n    function takeOwnership(uint256 _tokenId) public {\r\n        require(bytes(_cards[_tokenId].name).length != 0);\r\n        require(!_cards[_tokenId].isLocked);\r\n        address newOwner = msg.sender;\r\n        address oldOwner = _cardsOwners[_tokenId];\r\n        require(_addressNotNull(newOwner));\r\n        require(newOwner != oldOwner);\r\n        require(_isAllowed(newOwner, _tokenId));\r\n\r\n        _transfer(oldOwner, newOwner, _tokenId);\r\n    }\r\n\r\n    /// \"transfer\" lets the owner of a token send it to another user, similar to a standalone cryptocurrency.\r\n    function transfer(address _to, uint256 _tokenId) public {\r\n        require(bytes(_cards[_tokenId].name).length != 0);\r\n        require(!_cards[_tokenId].isLocked);\r\n        require(_owns(msg.sender, _tokenId));\r\n        require(msg.sender != _to);\r\n        require(_addressNotNull(_to));\r\n\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 tokenId) private {\r\n        // Transfer ownership to the new owner\r\n        _cardsOwners[tokenId] = to;\r\n        // Increase the number of tokens own by the new owner\r\n        _tokenPerOwners[to] += 1;\r\n\r\n        // When creating new cards, from is address(0)\r\n        if (from != address(0)) {\r\n            _tokenPerOwners[from] -= 1;\r\n            // clear any previously approved ownership exchange\r\n            delete _allowedAddresses[tokenId];\r\n        }\r\n\r\n        // Emit the transfer event.\r\n        Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /// Third-party initiates transfer of token from address from to address to\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(!_cards[tokenId].isLocked);\r\n        require(_owns(from, tokenId));\r\n        require(_isAllowed(to, tokenId));\r\n        require(_addressNotNull(to));\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n\r\n    /* MANAGEMENT FUNCTIONS -- ONLY USABLE BY ADMINS */\r\n\r\n    function createCard(string cardName, uint price, address cardOwner, address beneficiary, bool isLocked) public ownerOnly {\r\n        require(bytes(cardName).length != 0);\r\n        price = price == 0 ? _defaultPrice : price;\r\n        _createCard(cardName, price, cardOwner, beneficiary, isLocked);\r\n    }\r\n\r\n    function createCardFromName(string cardName) public ownerOnly {\r\n        require(bytes(cardName).length != 0);\r\n        _createCard(cardName, _defaultPrice, address(0), address(0), false);\r\n    }\r\n\r\n    /// Create card\r\n    function _createCard(string cardName, uint price, address cardOwner, address beneficiary, bool isLocked) private {\r\n        require(_cards.length < 2^256 - 1);\r\n        Card memory card = Card({\r\n                                    generation: _generation,\r\n                                    name: cardName,\r\n                                    isLocked: isLocked\r\n                                });\r\n        _cardsPrices[_cards.length][0] = price; // Current price\r\n        _cardsPrices[_cards.length][1] = price; // Last bought price\r\n        _cardsPrices[_cards.length][2] = price; // Highest\r\n        _cardsOwners[_cards.length] = cardOwner;\r\n        _beneficiaryAddresses[_cards.length] = beneficiary;\r\n        _tokenPerOwners[cardOwner] += 1;\r\n        _cards.push(card);\r\n    }\r\n\r\n\r\n    /// Change the current generation\r\n    function evolveGeneration(uint16 newGeneration) public ownerOnly {\r\n        _generation = newGeneration;\r\n    }\r\n\r\n    /// Change the address of one owner.\r\n    function setOwner(address currentAddress, address newAddress) public ownerOnly {\r\n        require(_addressNotNull(newAddress));\r\n\r\n        if (currentAddress == _ownerA) {\r\n            _ownerA = newAddress;\r\n        } else if (currentAddress == _ownerB) {\r\n            _ownerB = newAddress;\r\n        } else if (currentAddress == _ownerC) {\r\n            _ownerC = newAddress;\r\n        } else if (currentAddress == _ownerD) {\r\n            _ownerD = newAddress;\r\n        }\r\n    }\r\n\r\n    /// Set the charity fund.\r\n    function setCharityFund(address newCharityFund) public ownerOnly {\r\n        _charityFund = newCharityFund;\r\n    }\r\n\r\n    /// Set the beneficiary ETH address.\r\n    function setBeneficiaryAddress(uint256 tokenId, address beneficiaryAddress) public ownerOnly {\r\n        require(bytes(_cards[tokenId].name).length != 0);\r\n        _beneficiaryAddresses[tokenId] = beneficiaryAddress;\r\n    }\r\n\r\n    /// Lock a card and make it unusable\r\n    function lock(uint256 tokenId) public ownerOnly {\r\n        require(!_cards[tokenId].isLocked);\r\n        _cards[tokenId].isLocked = true;\r\n    }\r\n\r\n    /// Unlock a YTIcon and make it usable\r\n    function unlock(uint256 tokenId) public ownerOnly {\r\n        require(_cards[tokenId].isLocked);\r\n        _cards[tokenId].isLocked = false;\r\n    }\r\n\r\n    /// Get the smart contract's balance out of the contract and transfers it to every related account.\r\n    function payout() public ownerOnly {\r\n        _payout();\r\n    }\r\n\r\n    function _payout() private {\r\n        uint256 balance = this.balance;\r\n        _ownerA.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));\r\n        _ownerB.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));\r\n        _ownerC.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));\r\n        _ownerD.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));\r\n        _utilityFund.transfer(SafeMath.div(SafeMath.mul(balance, 20), 100));\r\n    }\r\n\r\n\r\n    /* UTILS */\r\n\r\n    /// Check if the address is valid by checking if it is not equal to 0x0.\r\n    function _addressNotNull(address target) private pure returns (bool) {\r\n        return target != address(0);\r\n    }\r\n\r\n    /// Check for token ownership\r\n    function _owns(address pretender, uint256 tokenId) private view returns (bool) {\r\n        return pretender == _cardsOwners[tokenId];\r\n    }\r\n\r\n    function _isAllowed(address claimant, uint256 tokenId) private view returns (bool) {\r\n        return _allowedAddresses[tokenId] == claimant;\r\n    }\r\n\r\n    /* PUBLIC FUNCTIONS */\r\n\r\n    /// Get all of the useful card's informations.\r\n    function getCard(uint256 tokenId) public view returns (string cardName, uint16 generation, bool isLocked, uint256 price, address owner, address beneficiary, bool isVerified) {\r\n        Card storage card = _cards[tokenId];\r\n        cardName = card.name;\r\n        require(bytes(cardName).length != 0);\r\n        generation = card.generation;\r\n        isLocked = card.isLocked;\r\n        price = _cardsPrices[tokenId][0];\r\n        owner = _cardsOwners[tokenId];\r\n        beneficiary = _beneficiaryAddresses[tokenId];\r\n        isVerified = _addressNotNull(_beneficiaryAddresses[tokenId]) ? true : false;\r\n    }\r\n\r\n    /// Set a lower price if the sender is the card's owner.\r\n    function setPrice(uint256 tokenId, uint256 newPrice) public {\r\n        require(!_cards[tokenId].isLocked);\r\n        // If new price > 0\r\n        // If the new price is higher or equal to the basic investment of the owner (e.g. if someone buys a card 0.001 ETH, then the default investment will be 0.001)\r\n        // If the new price is lower or equal than the highest price set by the algorithm.\r\n        require(newPrice > 0 && newPrice >= _cardsPrices[tokenId][1] && newPrice <= _cardsPrices[tokenId][2]);\r\n        require(msg.sender == _cardsOwners[tokenId]);\r\n\r\n        _cardsPrices[tokenId][0] = newPrice;\r\n        PriceModified(tokenId, newPrice);\r\n    }\r\n\r\n    function purchase(uint256 tokenId) public payable {\r\n        require(!_cards[tokenId].isLocked);\r\n        require(_cardsPrices[tokenId][0] > 0);\r\n\r\n        address oldOwner = _cardsOwners[tokenId];\r\n        address newOwner = msg.sender;\r\n\r\n        uint256 sellingPrice = _cardsPrices[tokenId][0];\r\n\r\n        // Making sure the token owner isn't trying to purchase his/her own token.\r\n        require(oldOwner != newOwner);\r\n\r\n        require(_addressNotNull(newOwner));\r\n\r\n        // Making sure the amount sent is greater than or equal to the sellingPrice.\r\n        require(msg.value >= sellingPrice);\r\n\r\n        uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 92), 100));\r\n        uint256 beneficiaryPayment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 3), 100));\r\n        uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\r\n        uint256 newPrice = 0;\r\n\r\n        // Update prices\r\n        if (sellingPrice < firstLimit) {\r\n            newPrice = SafeMath.div(SafeMath.mul(sellingPrice, 200), 92);\r\n        } else if (sellingPrice < secondLimit) {\r\n            newPrice = SafeMath.div(SafeMath.mul(sellingPrice, 150), 92);\r\n        } else if (sellingPrice < thirdLimit) {\r\n            newPrice = SafeMath.div(SafeMath.mul(sellingPrice, 125), 92);\r\n        } else {\r\n            newPrice = SafeMath.div(SafeMath.mul(sellingPrice, 115), 92);\r\n        }\r\n\r\n        _cardsPrices[tokenId][0] = newPrice; // New price\r\n        _cardsPrices[tokenId][1] = sellingPrice; // Last bought price\r\n        _cardsPrices[tokenId][2] = newPrice; // New highest price\r\n\r\n        _transfer(oldOwner, newOwner, tokenId);\r\n\r\n        // Pay previous owner\r\n        if (oldOwner != address(this) && oldOwner != address(0)) {\r\n            oldOwner.transfer(payment);\r\n        }\r\n\r\n        if (_beneficiaryAddresses[tokenId] != address(0)) {\r\n            _beneficiaryAddresses[tokenId].transfer(beneficiaryPayment);\r\n        } else {\r\n            _charityFund.transfer(beneficiaryPayment);\r\n        }\r\n\r\n        YTIconSold(tokenId, newPrice, newOwner);\r\n\r\n        msg.sender.transfer(purchaseExcess);\r\n    }\r\n\r\n    function getOwnerCards(address owner) public view returns(uint256[] ownerTokens) {\r\n        uint256 balance = balanceOf(owner);\r\n        if (balance == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](balance);\r\n            uint256 total = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            uint256 cardId;\r\n            for (cardId = 0; cardId <= total; cardId++) {\r\n                if (_cardsOwners[cardId] == owner) {\r\n                    result[resultIndex] = cardId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function getHighestPrice(uint256 tokenId) public view returns(uint256 highestPrice) {\r\n        highestPrice = _cardsPrices[tokenId][1];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"beneficiaryAddress\",\"type\":\"address\"}],\"name\":\"setBeneficiaryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCharityFund\",\"type\":\"address\"}],\"name\":\"setCharityFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currentAddress\",\"type\":\"address\"},{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_allowedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardName\",\"type\":\"string\"}],\"name\":\"createCardFromName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getHighestPrice\",\"outputs\":[{\"name\":\"highestPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCard\",\"outputs\":[{\"name\":\"cardName\",\"type\":\"string\"},{\"name\":\"generation\",\"type\":\"uint16\"},{\"name\":\"isLocked\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"isVerified\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOwnerCards\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_generation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newGeneration\",\"type\":\"uint16\"}],\"name\":\"evolveGeneration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardName\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"cardOwner\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"createCard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"YTIconSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"PriceModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"YTIcons","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a1a1d476d88a7fccbb4d02160dc3f16b56c23e11efba6c3db9a28cde09ee1bf5"}]}