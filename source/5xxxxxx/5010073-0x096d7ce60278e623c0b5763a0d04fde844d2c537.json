{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\n \r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\n \r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n   \r\n  function transferOwnership(address newOwner) onlyOwner public{\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Interface for required functionality in the ERC721 standard\r\n * for non-fungible tokens.\r\n * Borrowed from Token Standard discussion board\r\n *\r\n * \r\n */\r\n \r\ncontract ERC721 {\r\n    // Function\r\n    function totalSupply() public view returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint _tokenId) public view returns (address _owner);\r\n    function transfer(address _to, uint _tokenId) internal;\r\n    function implementsERC721() public view returns (bool _implementsERC721);\r\n\r\n  \r\n    function approve(address _to, uint _tokenId) internal;\r\n    function transferFrom(address _from, address _to, uint _tokenId) internal;\r\n\r\n   \r\n    // Events\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n}\r\n\r\n/**\r\n * Interface for optional functionality in the ERC721 standard\r\n * for non-fungible tokens.\r\n *\r\n *  \r\n * Borrowed in part from Token Standard discussion board\r\n */\r\n \r\ncontract DetailedERC721 is ERC721 {\r\n    function name() public view returns (string _name);\r\n    function symbol() public view returns (string _symbol);\r\n   // function tokenMetadata(uint _tokenId) public view returns (string _infoUrl);\r\n    function tokenOfOwnerByIndex(address _owner, uint _index) public view returns (uint _tokenId);\r\n}\r\n\r\n/**\r\n * @title NonFungibleToken\r\n *\r\n * Generic implementation for both required and optional functionality in\r\n * the ERC721 standard for non-fungible tokens.\r\n *\r\n * Borrowed in part from Token Standard discussion board\r\n */\r\n \r\ncontract NonFungibleToken is DetailedERC721 {\r\n    string public name;\r\n    string public symbol;\r\n\r\n    uint public numTokensTotal;\r\n    uint public currentTokenIdNumber;\r\n\r\n    mapping(uint => address) internal tokenIdToOwner;\r\n    mapping(uint => address) internal tokenIdNumber;\r\n    mapping(uint => address) internal tokenIdToApprovedAddress;\r\n   // mapping(uint => string) internal tokenIdToMetadata;\r\n    mapping(address => uint[]) internal ownerToTokensOwned;\r\n    mapping(uint => uint) internal tokenIdToOwnerArrayIndex;\r\n\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    modifier onlyExtantToken(uint _tokenId) {\r\n        require(ownerOf(_tokenId) != address(0));\r\n        _;\r\n    }\r\n\r\n    function name()\r\n        public\r\n        view\r\n        returns (string _name)\r\n    {\r\n        return name;\r\n    }\r\n\r\n    function symbol()\r\n        public\r\n        view\r\n        returns (string _symbol)\r\n    {\r\n        return symbol;\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256 _totalSupply)\r\n    {\r\n        return numTokensTotal;\r\n    }\r\n    \r\n    function currentIDnumber()\r\n        public\r\n        view\r\n        returns (uint256 _tokenId)\r\n    {\r\n        return currentTokenIdNumber;\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n        public\r\n        view\r\n        returns (uint _balance)\r\n    {\r\n        return ownerToTokensOwned[_owner].length;\r\n    }\r\n\r\n    function ownerOf(uint _tokenId)\r\n        public\r\n        view\r\n        returns (address _owner)\r\n    {\r\n        return _ownerOf(_tokenId);\r\n    }\r\n    \r\n   /*  NOT USED\r\n    function tokenMetadata(uint _tokenId)\r\n        public\r\n        view\r\n        returns (string _infoUrl)\r\n    {\r\n        return tokenIdToMetadata[_tokenId];\r\n    }\r\n */\r\n    function approve(address _to, uint _tokenId)\r\n        internal\r\n        onlyExtantToken(_tokenId)\r\n    {\r\n        require(msg.sender == ownerOf(_tokenId));\r\n        require(msg.sender != _to);\r\n\r\n        if (_getApproved(_tokenId) != address(0) ||\r\n                _to != address(0)) {\r\n            _approve(_to, _tokenId);\r\n            Approval(msg.sender, _to, _tokenId);\r\n        }\r\n    }\r\n\r\n  \r\n    function transferFrom(address _from, address _to, uint _tokenId)\r\n        internal\r\n        onlyExtantToken(_tokenId)\r\n    {\r\n        require(getApproved(_tokenId) == msg.sender);\r\n        require(ownerOf(_tokenId) == _from);\r\n        require(_to != address(0));\r\n\r\n        _clearApprovalAndTransfer(_from, _to, _tokenId);\r\n\r\n        Approval(_from, 0, _tokenId);\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function auctiontransfer(address _currentowner, address _to, uint _tokenId)\r\n        internal\r\n        onlyExtantToken(_tokenId)\r\n    {\r\n        require(ownerOf(_tokenId) == _currentowner);\r\n        require(_to != address(0));\r\n\r\n        _clearApprovalAndTransfer(_currentowner, _to, _tokenId);\r\n\r\n        Approval(_currentowner, 0, _tokenId);\r\n        Transfer(_currentowner, _to, _tokenId);\r\n    }\r\n   \r\n\r\n    function transfer(address _to, uint _tokenId)\r\n        internal \r\n        onlyExtantToken(_tokenId)\r\n    {\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n        require(_to != address(0));\r\n\r\n        _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n\r\n        Approval(msg.sender, 0, _tokenId);\r\n        Transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint _index)\r\n        public\r\n        view\r\n        returns (uint _tokenId)\r\n    {\r\n        return _getOwnerTokenByIndex(_owner, _index);\r\n    }\r\n\r\n    function getOwnerTokens(address _owner)\r\n        public\r\n        view\r\n        returns (uint[] _tokenIds)\r\n    {\r\n        return _getOwnerTokens(_owner);\r\n    }\r\n\r\n    function implementsERC721()\r\n        public\r\n        view\r\n        returns (bool _implementsERC721)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function getApproved(uint _tokenId)\r\n        public\r\n        view\r\n        returns (address _approved)\r\n    {\r\n        return _getApproved(_tokenId);\r\n    }\r\n\r\n    function _clearApprovalAndTransfer(address _from, address _to, uint _tokenId)\r\n        internal\r\n    {\r\n        _clearTokenApproval(_tokenId);\r\n        _removeTokenFromOwnersList(_from, _tokenId);\r\n        _setTokenOwner(_tokenId, _to);\r\n        _addTokenToOwnersList(_to, _tokenId);\r\n    }\r\n\r\n    function _ownerOf(uint _tokenId)\r\n        internal\r\n        view\r\n        returns (address _owner)\r\n    {\r\n        return tokenIdToOwner[_tokenId];\r\n    }\r\n\r\n   \r\n    function _approve(address _to, uint _tokenId)\r\n        internal\r\n    {\r\n        tokenIdToApprovedAddress[_tokenId] = _to;\r\n    }\r\n\r\n    function _getApproved(uint _tokenId)\r\n        internal\r\n        view\r\n        returns (address _approved)\r\n    {\r\n        return tokenIdToApprovedAddress[_tokenId];\r\n    }\r\n\r\n    function _getOwnerTokens(address _owner)\r\n        internal\r\n        view\r\n        returns (uint[] _tokens)\r\n    {\r\n        return ownerToTokensOwned[_owner];\r\n    }\r\n\r\n    function _getOwnerTokenByIndex(address _owner, uint _index)\r\n        internal\r\n        view\r\n        returns (uint _tokens)\r\n    {\r\n        return ownerToTokensOwned[_owner][_index];\r\n    }\r\n\r\n\r\n    function _clearTokenApproval(uint _tokenId)\r\n        internal\r\n    {\r\n        tokenIdToApprovedAddress[_tokenId] = address(0);\r\n    }\r\n\r\n\r\n    function _setTokenOwner(uint _tokenId, address _owner)\r\n        internal\r\n    {\r\n        tokenIdToOwner[_tokenId] = _owner;\r\n    }\r\n\r\n    function _addTokenToOwnersList(address _owner, uint _tokenId)\r\n        internal\r\n    {\r\n        ownerToTokensOwned[_owner].push(_tokenId);\r\n        tokenIdToOwnerArrayIndex[_tokenId] =\r\n            ownerToTokensOwned[_owner].length - 1;\r\n    }\r\n\r\n    function _removeTokenFromOwnersList(address _owner, uint _tokenId)\r\n        internal\r\n    {\r\n        uint length = ownerToTokensOwned[_owner].length;\r\n        uint index = tokenIdToOwnerArrayIndex[_tokenId];\r\n        uint swapToken = ownerToTokensOwned[_owner][length - 1];\r\n\r\n        ownerToTokensOwned[_owner][index] = swapToken;\r\n        tokenIdToOwnerArrayIndex[swapToken] = index;\r\n\r\n        delete ownerToTokensOwned[_owner][length - 1];\r\n        ownerToTokensOwned[_owner].length--;\r\n    }\r\n\r\n/* Not Used\r\n    function _insertTokenMetadata(uint _tokenId, string _metadata)\r\n        internal\r\n    {\r\n        tokenIdToMetadata[_tokenId] = _metadata;\r\n    }\r\n   \r\n */  \r\n}\r\n\r\n/**\r\n * @title MintableNonFungibleToken\r\n *\r\n * Superset of the ERC721 standard that allows for the minting\r\n * of non-fungible tokens.\r\n * Borrowed from Token Standard discussion board\r\n */\r\n \r\ncontract MintableNonFungibleToken is NonFungibleToken {\r\n    using SafeMath for uint;\r\n\r\n    event Mint(address indexed _to, uint256 indexed _tokenId);\r\n\r\n    modifier onlyNonexistentToken(uint _tokenId) {\r\n        require(tokenIdToOwner[_tokenId] == address(0));\r\n        _;\r\n    }\r\n\r\n    function mint(address _owner, uint256 _tokenId)\r\n        internal\r\n        onlyNonexistentToken(_tokenId)\r\n    {\r\n        _setTokenOwner(_tokenId, _owner);\r\n        _addTokenToOwnersList(_owner, _tokenId);\r\n        //_insertTokenMetadata(_tokenId, _metadata);\r\n\r\n        numTokensTotal = numTokensTotal.add(1);\r\n\r\n        Mint(_owner, _tokenId);\r\n    }\r\n   \r\n    \r\n}\r\n\r\n/**\r\n * @title Auction\r\n *\r\n * BillionTix proprietary Auction \r\n * of BillionTix\r\n * Developed Exclusively for and by BillionTix Jan 31 2018\r\n */\r\n \r\ncontract Auction is NonFungibleToken, Ownable {\r\n            using SafeMath for uint256;\r\n\r\n    \r\n    struct ActiveAuctionsStruct {\r\n    address auctionOwner;\r\n    uint isBeingAuctioned; \r\n    //1=Being Auctioned 0=Not Being Auctioned\r\n    uint startingPrice;\r\n    uint buynowPrice;\r\n    uint highestBid;\r\n    uint numberofBids;\r\n    uint auctionEnd;\r\n    uint lastSellingPrice;\r\n    address winningBidder;\r\n    \r\n  }\r\n  \r\n  struct ActiveAuctionsByAddressStruct {\r\n      \r\n      uint tixNumberforSale;\r\n      \r\n  }\r\n  \r\n \r\n    mapping(uint => ActiveAuctionsStruct) private activeAuctionsStructs;\r\n    mapping(address => uint[]) private activeAuctionsByAddressStructs;\r\n\r\n    event LiveAuctionEvent (address auctionowner, uint indexed tixNumberforSale, uint indexed startingPrice, uint indexed buynowPrice, uint auctionLength);\r\n    event RunningAuctionsEvent (address auctionowner, uint indexed tixNumberforSale, uint indexed isBeingAuctioned, uint auctionLength);\r\n    event SuccessAuctionEvent (address auctionowner, address auctionwinner, uint indexed tixNumberforSale, uint indexed winningPrice);\r\n    event CanceledAuctionEvent (address auctionowner, address highestbidder, uint indexed tixNumberforSale, uint indexed highestbid);\r\n    event BuyNowEvent (address auctionowner, address ticketbuyer, uint indexed tixNumberforSale, uint indexed purchaseprice);\r\n    event LogBid (address auctionowner, address highestbidder, uint indexed tixNumberforSale, uint indexed highestbid, uint indexed bidnumber);\r\n    event LogRefund (address losingbidder, uint indexed tixNumberforSale, uint indexed refundedamount);\r\n    event CreationFailedEvent (address auctionrequestedby, uint indexed tixNumberforSale, string approvalstatus);\r\n    event BidFailedEvent (address bidder, uint tixNumberforSale, string bidfailure);\r\n\r\n    \r\n    address ticketownwer;\r\n    address public auctionleader;\r\n\r\n    string public approval = \"Auction Approved\";\r\n    string public notapproved = \"You Do Not Own This Ticket or Ticket is Already For Sale\";\r\n    string public bidfailure =\"Bid Failure\";\r\n   \r\n    uint public tixNumberforSale;\r\n    uint public leadingBid;\r\n    uint public startingPrice;\r\n    uint public winningPrice;\r\n    uint public buynowPrice;\r\n    uint public auctionLength;\r\n    uint256 public ownerCut;\r\n    uint256 public cancelCost;\r\n    \r\n    uint[] public runningauctions;\r\n \r\n    function Auction() public {\r\n        //Only called once when contract created.  Put initialization constructs here if needed\r\n    }\r\n    \r\n\r\n    function createAuction (uint _startprice, uint _buynowprice, uint _tixforsale, uint _auctiontime) public  {\r\n        \r\n        require (_startprice >= 0);\r\n        require (_buynowprice >= 0);\r\n        require (_tixforsale > 0);\r\n        require (_auctiontime > 0);\r\n        \r\n        address auctionowner = msg.sender;\r\n        tixNumberforSale = _tixforsale;\r\n        ticketownwer = ownerOf(tixNumberforSale);\r\n        auctionLength = _auctiontime;\r\n         \r\n        var auctionDetails = activeAuctionsStructs[tixNumberforSale];\r\n\r\n        uint auctionstatus = auctionDetails.isBeingAuctioned;\r\n\r\n\r\n        if (auctionowner == ticketownwer && auctionstatus != 1) {\r\n         \r\n         startingPrice = _startprice;\r\n         buynowPrice = _buynowprice;\r\n         auctionDetails.auctionOwner = auctionowner;\r\n         auctionDetails.startingPrice = startingPrice;\r\n         auctionDetails.buynowPrice = buynowPrice;\r\n         auctionDetails.highestBid = startingPrice;\r\n         auctionDetails.isBeingAuctioned = 1;\r\n         auctionDetails.numberofBids = 0;\r\n         auctionDetails.auctionEnd = now + auctionLength;\r\n         runningauctions.push(tixNumberforSale);\r\n\r\n     \r\n         activeAuctionsByAddressStructs[auctionowner].push(tixNumberforSale);\r\n         LiveAuctionEvent(auctionowner, tixNumberforSale, startingPrice, buynowPrice, auctionDetails.auctionEnd);\r\n\r\n       \r\n        } else {\r\n            \r\n        CreationFailedEvent(msg.sender, tixNumberforSale, notapproved);\r\n        revert();\r\n\r\n        }\r\n    \r\n    }\r\n   \r\n    function placeBid(uint _tixforsale) payable public{\r\n       \r\n\r\n      var auctionDetails = activeAuctionsStructs[_tixforsale];\r\n      uint auctionavailable = auctionDetails.isBeingAuctioned;\r\n      uint leadbid = auctionDetails.highestBid;\r\n      uint bidtotal = auctionDetails.numberofBids;\r\n      address auctionowner = auctionDetails.auctionOwner;\r\n      address leadingbidder = auctionDetails.winningBidder;\r\n      uint endofauction = auctionDetails.auctionEnd;\r\n      \r\n      require (now <= endofauction);\r\n      require (auctionavailable == 1);\r\n      require (msg.value > leadbid);\r\n      \r\n        if (msg.value > leadbid) {\r\n           \r\n            auctionDetails.winningBidder = msg.sender;\r\n            auctionDetails.highestBid = msg.value;\r\n            auctionDetails.numberofBids++;\r\n            uint bidnumber = auctionDetails.numberofBids;\r\n            \r\n             if (bidtotal > 0) {\r\n            returnPrevBid(leadingbidder, leadbid, _tixforsale);\r\n           }\r\n            LogBid(auctionowner, auctionDetails.winningBidder, _tixforsale, auctionDetails.highestBid, bidnumber);\r\n        }\r\n        else {\r\n            \r\n            BidFailedEvent(msg.sender, _tixforsale, bidfailure);\r\n            revert();\r\n            \r\n        }\r\n    \r\n    \r\n        \r\n    }\r\n   \r\n    function returnPrevBid(address _highestbidder, uint _leadbid, uint _tixnumberforsale) internal {\r\n      \r\n        if (_highestbidder != 0 && _leadbid > 0) {\r\n           \r\n            _highestbidder.transfer(_leadbid);\r\n            \r\n            LogRefund(_highestbidder, _tixnumberforsale, _leadbid);\r\n        \r\n        }\r\n    }\r\n    \r\n    function setOwnerCut(uint256 _ownercut) onlyOwner public {\r\n       \r\n       ownerCut = _ownercut;\r\n       \r\n       \r\n   }\r\n   \r\n   function setCostToCancel(uint256 _cancelcost) onlyOwner public {\r\n       \r\n       cancelCost = _cancelcost;\r\n       \r\n       \r\n   }\r\n   \r\n    function getCostToCancel() view public returns (uint256) {\r\n       \r\n       return cancelCost;\r\n       \r\n       \r\n   }\r\n    \r\n\r\n    //END AUCTION FUNCTION CAN BE CALLED AFTER AUCTION TIME IS UP BY EITHER SELLER OR WINNING PARTY\r\n    \r\n    function endAuction(uint _tixnumberforsale) public {\r\n        \r\n\r\n      var auctionDetails = activeAuctionsStructs[_tixnumberforsale];\r\n      uint auctionEnd = auctionDetails.auctionEnd;\r\n      address auctionowner = auctionDetails.auctionOwner;\r\n      address auctionwinner = auctionDetails.winningBidder;\r\n      uint256 winningBid = auctionDetails.highestBid;\r\n      uint numberofBids = auctionDetails.numberofBids;\r\n\r\n        require (now > auctionEnd);\r\n\r\n       if ((msg.sender == auctionowner || msg.sender == auctionwinner) && numberofBids > 0 && winningBid > 0) {\r\n          \r\n\r\n           uint256 ownersCut = winningBid * ownerCut / 10000;\r\n        \r\n           owner.transfer(ownersCut);\r\n           auctionowner.transfer(auctionDetails.highestBid - ownersCut);\r\n           auctiontransfer(auctionowner, auctionwinner, _tixnumberforsale);\r\n           auctionDetails.isBeingAuctioned = 0;\r\n           auctionDetails.auctionEnd = 0;\r\n           auctionDetails.numberofBids = 0;\r\n           auctionDetails.highestBid = 0;\r\n           auctionDetails.buynowPrice = 0;\r\n           auctionDetails.startingPrice = 0;\r\n           removeByValue(_tixnumberforsale);\r\n           SuccessAuctionEvent(auctionowner, auctionwinner, _tixnumberforsale, winningBid);\r\n           \r\n       }\r\n       \r\n       if (msg.sender == auctionowner && numberofBids == 0) {\r\n          \r\n\r\n           auctionDetails.isBeingAuctioned = 0;\r\n           auctionDetails.auctionEnd = 0;\r\n           auctionDetails.numberofBids = 0;\r\n           auctionDetails.highestBid = 0;\r\n           auctionDetails.buynowPrice = 0;\r\n           auctionDetails.startingPrice = 0;\r\n\r\n           removeByValue(_tixnumberforsale);\r\n\r\n           SuccessAuctionEvent(auctionowner, auctionwinner, _tixnumberforsale, winningBid);\r\n           \r\n       }\r\n       \r\n       \r\n       \r\n       \r\n   }\r\n   \r\n   \r\n  \r\n\r\n   //CANCEL AUCTION CAN ONLY BE CALLED BY AUCTION OWNER - ALL MONEY RETURNED TO HIGHEST BIDDER. COSTS ETHER\r\n   \r\n   function cancelAuction(uint _tixnumberforsale) payable public {\r\n       \r\n            \r\n        var auctionDetails = activeAuctionsStructs[_tixnumberforsale];\r\n        uint auctionEnd = auctionDetails.auctionEnd;\r\n        uint numberofBids = auctionDetails.numberofBids;\r\n\r\n        require (now < auctionEnd);\r\n        \r\n        \r\n        \r\n         uint256 highestBid = auctionDetails.highestBid;\r\n         address auctionwinner = auctionDetails.winningBidder;\r\n         address auctionowner = auctionDetails.auctionOwner;\r\n         \r\n                if (msg.sender == auctionowner && msg.value >= cancelCost && numberofBids > 0) {\r\n\r\n        \r\n                        auctionwinner.transfer(highestBid);\r\n                        LogRefund(auctionwinner, _tixnumberforsale, highestBid);\r\n\r\n                        owner.transfer(cancelCost);\r\n                        \r\n                        auctionDetails.isBeingAuctioned = 0;\r\n                        auctionDetails.auctionEnd = 0;\r\n                        auctionDetails.numberofBids = 0;\r\n                        auctionDetails.highestBid = 0;\r\n                        auctionDetails.buynowPrice = 0;\r\n                        auctionDetails.startingPrice = 0;\r\n\r\n                        removeByValue(_tixnumberforsale);\r\n\r\n\r\n              CanceledAuctionEvent(auctionowner, auctionwinner, _tixnumberforsale, highestBid);\r\n\r\n                } \r\n                \r\n                if (msg.sender == auctionowner && msg.value >= cancelCost && numberofBids == 0) {\r\n\r\n                        owner.transfer(cancelCost);\r\n                        \r\n                        auctionDetails.isBeingAuctioned = 0;\r\n                        auctionDetails.auctionEnd = 0;\r\n                        auctionDetails.numberofBids = 0;\r\n                        auctionDetails.highestBid = 0;\r\n                        auctionDetails.buynowPrice = 0;\r\n                        auctionDetails.startingPrice = 0;\r\n\r\n                        removeByValue(_tixnumberforsale);\r\n\r\n\r\n              CanceledAuctionEvent(auctionowner, auctionwinner, _tixnumberforsale, highestBid);\r\n\r\n                }\r\n\r\n       \r\n   }\r\n   \r\n\r\n   //Buy Now Cancels Auction with no Penalty and returns all placed bids.  Contract takes cut of buy now price\r\n\r\n   function buyNow(uint _tixnumberforsale) payable public {\r\n       \r\n\r\n     var auctionDetails = activeAuctionsStructs[_tixnumberforsale];\r\n      uint auctionEnd = auctionDetails.auctionEnd;\r\n      address auctionowner = auctionDetails.auctionOwner;\r\n      address auctionlead = auctionDetails.winningBidder;\r\n      uint256 highestBid = auctionDetails.highestBid;\r\n      uint256 buynowprice = auctionDetails.buynowPrice;\r\n      \r\n      uint256 buynowcut = ownerCut;\r\n    \r\n      uint256 buynowownersCut = buynowPrice * buynowcut / 10000;\r\n\r\n\r\n      require(buynowprice > 0);\r\n      require(now < auctionEnd);\r\n        \r\n      if (msg.value == buynowPrice) {\r\n          \r\n\r\n          auctionowner.transfer(buynowPrice - buynowownersCut);\r\n          owner.transfer(buynowownersCut);\r\n         \r\n         \r\n          auctiontransfer(auctionowner, msg.sender, _tixnumberforsale);\r\n          auctionDetails.isBeingAuctioned = 0;\r\n          auctionDetails.auctionEnd = 0;\r\n          auctionDetails.numberofBids = 0;\r\n          auctionDetails.highestBid = 0;\r\n          auctionDetails.buynowPrice = 0;\r\n          auctionDetails.startingPrice = 0;\r\n\r\n          removeByValue(_tixnumberforsale);\r\n\r\n\r\n          BuyNowEvent(auctionowner, msg.sender, _tixnumberforsale, msg.value);\r\n          \r\n           if (auctionDetails.numberofBids > 0) {\r\n         \r\n          returnPrevBid(auctionlead, highestBid, _tixnumberforsale);\r\n\r\n         }\r\n          \r\n          \r\n      } else {\r\n          \r\n          revert();\r\n      }\r\n       \r\n   }\r\n   \r\n    function withdraw(address forwardAddress, uint amount) public onlyOwner {\r\n\r\n        forwardAddress.transfer(amount);\r\n\r\n}\r\n   \r\n \r\n    function getAuctionDetails(uint tixnumberforsale)\r\n        public\r\n        view\r\n        returns (uint _startingprice, uint _buynowprice, uint _numberofBids, uint _highestBid, uint _auctionEnd, address winningBidder, address _auctionOwner)\r\n    {\r\n        return (\r\n         activeAuctionsStructs[tixnumberforsale].startingPrice,\r\n         activeAuctionsStructs[tixnumberforsale].buynowPrice,\r\n         activeAuctionsStructs[tixnumberforsale].numberofBids,\r\n         activeAuctionsStructs[tixnumberforsale].highestBid,\r\n         activeAuctionsStructs[tixnumberforsale].auctionEnd,\r\n         activeAuctionsStructs[tixnumberforsale].winningBidder,\r\n         activeAuctionsStructs[tixnumberforsale].auctionOwner);\r\n         \r\n\r\n    }\r\n    \r\n    //Had to split due to stack limitations of Solidity - Pull back together in UI\r\n    \r\n    function getMoreAuctionDetails(uint tixnumberforsale) public view returns (uint _auctionstatus, uint _auctionEnd, address _auctionOwner) {\r\n        \r\n     return (\r\n                    \r\n                    activeAuctionsStructs[tixnumberforsale].isBeingAuctioned,\r\n                    activeAuctionsStructs[tixnumberforsale].auctionEnd,\r\n                    activeAuctionsStructs[tixnumberforsale].auctionOwner);\r\n        \r\n    }\r\n   \r\n    \r\n     function getOwnerAuctions(address _auctionowner)\r\n        public\r\n        view\r\n        returns (uint[] _auctions)\r\n    {\r\n       \r\n        return activeAuctionsByAddressStructs[_auctionowner];\r\n    }\r\n  \r\n    \r\n  //FUNCTIONS USED TO KEEP ACCURATE ARRAY OF LIVE AUCTIONS\r\n  \r\n  function find(uint value) view public returns(uint) {\r\n        uint i = 0;\r\n        while (runningauctions[i] != value) {\r\n            i++;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    function removeByValue(uint value) internal {\r\n        uint i = find(value);\r\n        removeByIndex(i);\r\n    }\r\n\r\n    function removeByIndex(uint i) internal {\r\n        while (i<runningauctions.length-1) {\r\n            runningauctions[i] = runningauctions[i+1];\r\n            i++;\r\n        }\r\n        runningauctions.length--;\r\n    }\r\n\r\n    function getRunningAuctions() constant public returns(uint[]) {\r\n        return runningauctions;\r\n    }\r\n\r\n\r\n     function() payable public {}\r\n\r\n   \r\n}\r\n\r\n\r\n/**\r\n * @title BillionTix\r\n *\r\n * Main BillionTix Contract. Controls creation of BillionTix and  \r\n * selecting and Paying Giveaway Winners\r\n * Developed Exclusively for and by BillionTix Jan 31 2018\r\n */\r\n \r\ncontract Billiontix is MintableNonFungibleToken, Auction {\r\n   address owner;\r\n\r\n    string public name = 'BillionTix';\r\n    string public symbol = 'BTIX';\r\n   \r\n    string internal TenTimesEther = \"0.005 Ether\";\r\n    string internal OneHundredTimesEther = \"0.05 Ether\";\r\n    string internal OneThousandTimesEther = \"0.5 Ether\";\r\n    string internal TenThousandTimesEther = \"5 Ether\";\r\n    string internal OneHundredThousandTimesEther = \"50 Ether\";\r\n    string internal OneMillionTimesEther = \"500 Ether\";\r\n    string internal TenMillionTimesEther = \"5,000 Ether\";\r\n    string internal OneHundredMillionTimesEther = \"50,000 Ether\";\r\n    string internal OneBillionTimesEther = \"500,000 Ether\";\r\n   \r\n   \r\n    //SET THESE PRICES IN WEI\r\n    \r\n    uint256 public buyPrice =      500000000000000;\r\n    uint256 public buy5Price =    2500000000000000;\r\n    uint256 public buy10Price =   5000000000000000;\r\n    uint256 public buy20Price =  10000000000000000;\r\n    uint256 public buy50Price =  25000000000000000;\r\n    uint256 public buy100Price = 50000000000000000;\r\n\r\n    address public winner;\r\n  \r\n   //These are the supertix numbers. They will NOT CHANGE\r\n   \r\n    uint[] supertixarray = [10000,100000,500000,1000000,5000000,10000000,50000000,100000000,500000000,750000000];\r\n\r\n \r\n    mapping(address => uint256) public balanceOf; \r\n    \r\n    event PayoutEvent (uint indexed WinningNumber, address indexed _to, uint indexed value);\r\n    event WinningNumbersEvent (uint256 indexed WinningNumber, string AmountWon); \r\n    event WinnerPaidEvent (address indexed Winner, string AmountWon);\r\n    \r\n\r\n\r\n  function buy () payable public \r\n   onlyNonexistentToken(_tokenId)\r\n    {\r\n       \r\n       if ((msg.value) == buyPrice) {\r\n           \r\n           \r\n        uint256 _tokenId = numTokensTotal +1;\r\n        _setTokenOwner(_tokenId, msg.sender);\r\n        _addTokenToOwnersList(msg.sender, _tokenId);\r\n       // _insertTokenMetadata(_tokenId, _metadata);\r\n\r\n       numTokensTotal = numTokensTotal.add(1);\r\n\r\n        Mint(msg.sender, _tokenId);          \r\n\r\n       if (numTokensTotal > 1 && numTokensTotal < 10000000002) {\r\n       playDraw();\r\n       playDraw2();\r\n       supertixdraw();\r\n       } else { }\r\n\r\n\r\n       }\r\n       else {\r\n          \r\n       }\r\n       \r\n   }\r\n   \r\n   \r\n     function buy5 () payable public \r\n   onlyNonexistentToken(_tokenId)\r\n    {\r\n       for (uint i = 0; i < 5; i++) {\r\n       if ((msg.value) == buy5Price) {\r\n           \r\n        uint256 _tokenId = numTokensTotal +1;\r\n        _setTokenOwner(_tokenId, msg.sender);\r\n        _addTokenToOwnersList(msg.sender, _tokenId);\r\n       // _insertTokenMetadata(_tokenId, _metadata);\r\n\r\n       numTokensTotal = numTokensTotal.add(1);\r\n\r\n        Mint(msg.sender, _tokenId);          \r\n\r\n       if (numTokensTotal > 1 && numTokensTotal < 10000000002) {\r\n       playDraw();\r\n       playDraw2();\r\n       supertixdraw();\r\n\r\n       } else { \r\n       }\r\n       \r\n       }\r\n       else {\r\n       }\r\n       }\r\n   }\r\n\r\n\r\n  function buy10 () payable public \r\n   onlyNonexistentToken(_tokenId)\r\n    {\r\n       for (uint i = 0; i < 10; i++) {\r\n       if ((msg.value) == buy10Price) {\r\n           \r\n        uint256 _tokenId = numTokensTotal +1;\r\n        _setTokenOwner(_tokenId, msg.sender);\r\n        _addTokenToOwnersList(msg.sender, _tokenId);\r\n       // _insertTokenMetadata(_tokenId, _metadata);\r\n\r\n       numTokensTotal = numTokensTotal.add(1);\r\n\r\n        Mint(msg.sender, _tokenId);          \r\n\r\n       if (numTokensTotal > 1 && numTokensTotal < 10000000002) {\r\n       playDraw();\r\n       playDraw2();\r\n       supertixdraw();\r\n\r\n       } else { }\r\n       }\r\n       else {\r\n          \r\n       }\r\n       }\r\n   }\r\n      \r\n    function buy20 () payable public \r\n   onlyNonexistentToken(_tokenId)\r\n    {\r\n       for (uint i = 0; i < 20; i++) {\r\n       if ((msg.value) == buy20Price) {\r\n           \r\n        uint256 _tokenId = numTokensTotal +1;\r\n        _setTokenOwner(_tokenId, msg.sender);\r\n        _addTokenToOwnersList(msg.sender, _tokenId);\r\n       // _insertTokenMetadata(_tokenId, _metadata);\r\n\r\n       numTokensTotal = numTokensTotal.add(1);\r\n\r\n        Mint(msg.sender, _tokenId);          \r\n\r\n       if (numTokensTotal > 1 && numTokensTotal < 10000000002) {\r\n       playDraw();\r\n       playDraw2();\r\n        supertixdraw();\r\n        \r\n      } else { }\r\n       }\r\n       else {\r\n          \r\n       }\r\n       }\r\n   }\r\n   \r\n    function buy50 () payable public \r\n   onlyNonexistentToken(_tokenId)\r\n    {\r\n       for (uint i = 0; i < 50; i++) {\r\n       if ((msg.value) == buy50Price) {\r\n           \r\n         uint256 _tokenId = numTokensTotal +1;\r\n        _setTokenOwner(_tokenId, msg.sender);\r\n        _addTokenToOwnersList(msg.sender, _tokenId);\r\n       // _insertTokenMetadata(_tokenId, _metadata);\r\n\r\n       numTokensTotal = numTokensTotal.add(1);\r\n\r\n        Mint(msg.sender, _tokenId);          \r\n\r\n       if (numTokensTotal > 1 && numTokensTotal < 10000000002) {\r\n       playDraw();\r\n       playDraw2();\r\n        supertixdraw();\r\n   \r\n       } else { }\r\n       }\r\n       else {\r\n          \r\n       }\r\n       }\r\n   }\r\n   \r\n    function buy100 () payable public \r\n   onlyNonexistentToken(_tokenId)\r\n    {\r\n       for (uint i = 0; i < 100; i++) {\r\n       if ((msg.value) == buy100Price) {\r\n           \r\n        uint256 _tokenId = numTokensTotal +1;\r\n        _setTokenOwner(_tokenId, msg.sender);\r\n        _addTokenToOwnersList(msg.sender, _tokenId);\r\n       // _insertTokenMetadata(_tokenId, _metadata);\r\n\r\n       numTokensTotal = numTokensTotal.add(1);\r\n\r\n        Mint(msg.sender, _tokenId);          \r\n\r\n       if (numTokensTotal > 1 && numTokensTotal < 10000000002) {\r\n       playDraw();\r\n       playDraw2();\r\n       supertixdraw();\r\n\r\n       } else { }\r\n       }\r\n       else {\r\n          \r\n       }\r\n       }\r\n   }\r\n\r\n   \r\n function playDraw() internal returns (uint winningrandomNumber1, \r\n uint winningrandomNumber2, \r\n uint winningrandomNumber3, \r\n uint winningrandomNumber4, \r\n uint winningrandomNumber5)  {\r\n     \r\n\r\n     uint A = ((numTokensTotal / 1) % 10);\r\n     uint B = ((numTokensTotal / 10) % 10);\r\n     uint C = ((numTokensTotal / 100) % 10);\r\n     uint D = ((numTokensTotal / 1000) % 10);\r\n     uint E = ((numTokensTotal / 10000) % 10);\r\n     uint F = ((numTokensTotal / 100000) % 10);\r\n     uint G = ((numTokensTotal / 1000000) % 10);\r\n     uint H = ((numTokensTotal / 10000000) % 10);\r\n     uint I = ((numTokensTotal / 100000000) % 10);\r\n     uint J = ((numTokensTotal / 1000000000) % 10);\r\n\r\n  \r\n     \r\n       if (A == 1 && B == 0) {\r\n         \r\n         winningrandomNumber1 = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 1))%100 + (1000000000 * J) + (100000000 * I) + (10000000 * H) + (1000000 * G) + (100000 * F) + (10000 * E) + (1000 * D) + (100 * (C - 1)));\r\n        \r\n         WinningNumbersEvent(winningrandomNumber1, TenTimesEther);\r\n         \r\n\r\n        // PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN EVENT Pays 10x Ether - 0.005\r\n\r\n         winner = ownerOf(winningrandomNumber1);\r\n         payWinner(winner, 5000000000000000); \r\n         \r\n         WinnerPaidEvent(winner, TenTimesEther);\r\n\r\n        \r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n\r\n if (A == 1 && B == 0 && C == 0) {\r\n         \r\n         winningrandomNumber2 = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 2))%1000 + (1000000000 * J) + (100000000 * I) + (10000000 * H) + (1000000 * G) + (100000 * F) + (10000 * E) + (1000 * (D - 1)));\r\n             \r\n         WinningNumbersEvent(winningrandomNumber2, OneHundredTimesEther);\r\n\r\n\r\n        // PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN EVENT\r\n        // PAYS 100x Ether\r\n\r\n         winner = ownerOf(winningrandomNumber2);\r\n         payWinner(winner, 50000000000000000); \r\n         payBilliontixOwner();\r\n\r\n         WinnerPaidEvent(winner, OneHundredTimesEther);\r\n  \r\n     \r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n \r\n if (A == 1 && B == 0 && C == 0 && D == 0) {\r\n         \r\n          winningrandomNumber3 = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 3))%10000 + (1000000000 * J) + (100000000 * I) + (10000000 * H) + (1000000 * G) + (100000 * F) + (10000 * (E - 1)));\r\n          WinningNumbersEvent(winningrandomNumber3, OneThousandTimesEther);\r\n\r\n\r\n      // PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN EVENT\r\n      // PAYS 1,000x Ether   \r\n      \r\n        winner = ownerOf(winningrandomNumber3);\r\n        payWinner(winner, 500000000000000000); \r\n        WinnerPaidEvent(winner, OneThousandTimesEther);\r\n\r\n\r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n\r\n     if (A == 1 && B == 0 && C == 0 && D == 0 && E == 0) {\r\n         \r\n          winningrandomNumber4 = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 4))%100000 + (1000000000 * J) + (100000000 * I) + (10000000 * H) + (1000000 * G) + (100000 * (F - 1)));\r\n          WinningNumbersEvent(winningrandomNumber4, TenThousandTimesEther);\r\n\r\n\r\n      // PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN EVENT\r\n      // PAYS 10,000x Ether\r\n         \r\n         winner = ownerOf(winningrandomNumber4);\r\n         payWinner(winner, 5000000000000000000); \r\n         \r\n         WinnerPaidEvent(winner, TenThousandTimesEther);\r\n\r\n         \r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n     \r\n  if (A == 1 && B == 0 && C == 0 && D == 0 && E == 0 && F == 0) {\r\n         \r\n          winningrandomNumber5 = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 5))%1000000 + (1000000000 * J) + (100000000 * I) + (10000000 * H) + (1000000 * (G - 1)));\r\n          WinningNumbersEvent(winningrandomNumber5, OneHundredThousandTimesEther);\r\n\r\n        // PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN EVENT\r\n        // PAYS 100,000x Ether\r\n\r\n         winner = ownerOf(winningrandomNumber5);\r\n         payWinner(winner, 50000000000000000000); \r\n         \r\n        WinnerPaidEvent(winner, OneHundredThousandTimesEther);\r\n\r\n         \r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n  \r\n     \r\n }\r\n \r\n function playDraw2() internal returns (\r\n uint winningrandomNumber6,\r\n uint winningrandomNumber7,\r\n uint winningrandomNumber8,\r\n uint billiondollarwinningNumber) {\r\n     \r\n\r\n     uint A = ((numTokensTotal / 1) % 10);\r\n     uint B = ((numTokensTotal / 10) % 10);\r\n     uint C = ((numTokensTotal / 100) % 10);\r\n     uint D = ((numTokensTotal / 1000) % 10);\r\n     uint E = ((numTokensTotal / 10000) % 10);\r\n     uint F = ((numTokensTotal / 100000) % 10);\r\n     uint G = ((numTokensTotal / 1000000) % 10);\r\n     uint H = ((numTokensTotal / 10000000) % 10);\r\n     uint I = ((numTokensTotal / 100000000) % 10);\r\n     uint J = ((numTokensTotal / 1000000000) % 10);\r\n     uint K = ((numTokensTotal / 10000000000) % 10);\r\n\r\n   \r\n  \r\n  if (A == 1 && B == 0 && C == 0 && D == 0 && E == 0 && F == 0 && G == 0) {\r\n         \r\n          winningrandomNumber6 = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 6))%10000000 + (1000000000 * J) + (100000000 * I) + (10000000 * (H - 1)));\r\n          WinningNumbersEvent(winningrandomNumber6, OneMillionTimesEther);\r\n\r\n\r\n        // PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN EVENT\r\n        // PAYS 1,000,000x Ether\r\n\r\n         winner = ownerOf(winningrandomNumber6);\r\n         payWinner(winner, 500000000000000000000); \r\n         \r\n         WinnerPaidEvent(winner, OneMillionTimesEther);\r\n\r\n\r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n     \r\n      if (A == 1 && B == 0 && C == 0 && D == 0 && E == 0 && F == 0 && G == 0 && H == 0) {\r\n         \r\n         winningrandomNumber7 = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 7))%100000000 + (1000000000 * J) + (100000000 * (I - 1)));\r\n         WinningNumbersEvent(winningrandomNumber7, TenMillionTimesEther);\r\n\r\n\r\n       // PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN EVENT\r\n       // PAYS 10,000,000x Ether\r\n        \r\n         winner = ownerOf(winningrandomNumber7);\r\n         payWinner(winner, 5000000000000000000000);\r\n         \r\n         WinnerPaidEvent(winner, TenMillionTimesEther);\r\n\r\n\r\n     \r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n \r\n     if (A == 1 && B == 0 && C == 0 && D == 0 && E == 0 && F == 0 && G == 0 && H == 0 && I == 0) {\r\n         \r\n          winningrandomNumber8 = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 8))%1000000000 + (1000000000 * (J - 1)));\r\n          WinningNumbersEvent(winningrandomNumber8, OneHundredMillionTimesEther);\r\n\r\n        // PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN ARRAY\r\n        // PAYS 100,000,000x Ether\r\n        \r\n         winner = ownerOf(winningrandomNumber8);\r\n         payWinner(winner, 50000000000000000000000);\r\n         \r\n         WinnerPaidEvent(winner, OneHundredMillionTimesEther);\r\n\r\n        \r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n     \r\n     if (A == 1 && B == 0 && C == 0 && D == 0 && E == 0 && F == 0 && G == 0 && H == 0 && I == 0 && J == 0 && K == 1) {\r\n         \r\n         billiondollarwinningNumber = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 9))%10000000000);\r\n         WinningNumbersEvent(billiondollarwinningNumber, OneBillionTimesEther);\r\n\r\n\r\n        //PAY OUT THE WINNER HERE AFTER LOGGING WINNING NUMBER IN EVENT\r\n        // PAYS 1,000,000,000x Ether\r\n    \r\n         winner = ownerOf(billiondollarwinningNumber);\r\n         payWinner(winner, 500000000000000000000000);\r\n         \r\n         WinnerPaidEvent(winner, OneBillionTimesEther);\r\n\r\n\r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n\r\n   \r\n     \r\n }\r\n \r\n function supertixdraw()  internal returns (uint winningsupertixnumber) {\r\n\r\n     uint A = ((numTokensTotal / 1) % 10);\r\n     uint B = ((numTokensTotal / 10) % 10);\r\n     uint C = ((numTokensTotal / 100) % 10);\r\n     uint D = ((numTokensTotal / 1000) % 10);\r\n     uint E = ((numTokensTotal / 10000) % 10);\r\n     uint F = ((numTokensTotal / 100000) % 10);\r\n     uint G = ((numTokensTotal / 1000000) % 10);\r\n     uint H = ((numTokensTotal / 10000000) % 10);\r\n     uint I = ((numTokensTotal / 100000000) % 10);\r\n     uint J = ((numTokensTotal / 1000000000) % 10);\r\n     \r\n   \r\n     \r\n      if (A == 1 && B == 0 && C == 0 && D == 0 && E == 0 && F == 0 && G == 0 && H == 0 && I == 0 && J==1) {\r\n          \r\n          //AT TICKET 1Billion and 1 Sold - Give Away 10Million times Ether to SuperTix holder\r\n          \r\n           uint randomsupertixnumber = (uint(keccak256(block.blockhash(block.number-1), numTokensTotal + 2))%10);\r\n\r\n           winningsupertixnumber = supertixarray[randomsupertixnumber];\r\n       \r\n           WinningNumbersEvent(winningsupertixnumber, TenMillionTimesEther);\r\n\r\n         winner = ownerOf(winningsupertixnumber);\r\n         payWinner(winner, 5000000000000000000000);\r\n         \r\n         WinnerPaidEvent(winner, TenMillionTimesEther);\r\n\r\n        \r\n     } else {\r\n         //Do stuff here with non winning ticket if needed\r\n     }\r\n     \r\n     \r\n }\r\n\r\n function Billiontix() public {\r\n      owner = msg.sender;\r\n   }\r\n  \r\n function transferEther(address forwardAddress, uint amount) public onlyOwner {\r\n\r\n        forwardAddress.transfer(amount);\r\n\r\n}\r\n \r\n\r\n  function payWinner(address winnerAddress, uint amount) internal {\r\n      \r\n        winnerAddress.transfer(amount);\r\n\r\n}\r\n \r\n function payBilliontixOwner () internal {\r\n     \r\n     //This is Called at Every 1000 Level Giveaway to Give BillionTix Their Cut in Wei\r\n     \r\n      owner.transfer(50000000000000000);\r\n     \r\n }\r\n \r\n\r\n   function kill() public onlyOwner {\r\n      if(msg.sender == owner)\r\n         selfdestruct(owner);\r\n   }\r\n   \r\n      function() payable public {}\r\n      \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"buy20\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"forwardAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leadingBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"_approved\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tixnumberforsale\",\"type\":\"uint256\"}],\"name\":\"buyNow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy10\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"_implementsERC721\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRunningAuctions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approval\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"find\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startprice\",\"type\":\"uint256\"},{\"name\":\"_buynowprice\",\"type\":\"uint256\"},{\"name\":\"_tixforsale\",\"type\":\"uint256\"},{\"name\":\"_auctiontime\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buy50Price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buy5Price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tixnumberforsale\",\"type\":\"uint256\"}],\"name\":\"getMoreAuctionDetails\",\"outputs\":[{\"name\":\"_auctionstatus\",\"type\":\"uint256\"},{\"name\":\"_auctionEnd\",\"type\":\"uint256\"},{\"name\":\"_auctionOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownercut\",\"type\":\"uint256\"}],\"name\":\"setOwnerCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buy100Price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCostToCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tixNumberforSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cancelCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tixnumberforsale\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tixforsale\",\"type\":\"uint256\"}],\"name\":\"placeBid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"notapproved\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cancelcost\",\"type\":\"uint256\"}],\"name\":\"setCostToCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buynowPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTokensTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tixnumberforsale\",\"type\":\"uint256\"}],\"name\":\"endAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buy20Price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentIDnumber\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTokenIdNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy100\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwnerTokens\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy5\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy50\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buy10Price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_auctionowner\",\"type\":\"address\"}],\"name\":\"getOwnerAuctions\",\"outputs\":[{\"name\":\"_auctions\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionleader\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidfailure\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"runningauctions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tixnumberforsale\",\"type\":\"uint256\"}],\"name\":\"getAuctionDetails\",\"outputs\":[{\"name\":\"_startingprice\",\"type\":\"uint256\"},{\"name\":\"_buynowprice\",\"type\":\"uint256\"},{\"name\":\"_numberofBids\",\"type\":\"uint256\"},{\"name\":\"_highestBid\",\"type\":\"uint256\"},{\"name\":\"_auctionEnd\",\"type\":\"uint256\"},{\"name\":\"winningBidder\",\"type\":\"address\"},{\"name\":\"_auctionOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"forwardAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"WinningNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PayoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"WinningNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"AmountWon\",\"type\":\"string\"}],\"name\":\"WinningNumbersEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"Winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"AmountWon\",\"type\":\"string\"}],\"name\":\"WinnerPaidEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionowner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buynowPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionLength\",\"type\":\"uint256\"}],\"name\":\"LiveAuctionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionowner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"isBeingAuctioned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionLength\",\"type\":\"uint256\"}],\"name\":\"RunningAuctionsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionowner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"auctionwinner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winningPrice\",\"type\":\"uint256\"}],\"name\":\"SuccessAuctionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionowner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"highestbidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"highestbid\",\"type\":\"uint256\"}],\"name\":\"CanceledAuctionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionowner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketbuyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"purchaseprice\",\"type\":\"uint256\"}],\"name\":\"BuyNowEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionowner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"highestbidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"highestbid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bidnumber\",\"type\":\"uint256\"}],\"name\":\"LogBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"losingbidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"refundedamount\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"auctionrequestedby\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"approvalstatus\",\"type\":\"string\"}],\"name\":\"CreationFailedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tixNumberforSale\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bidfailure\",\"type\":\"string\"}],\"name\":\"BidFailedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Billiontix","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c2502202b39d8845335841990faa680e1fe8066de95b4d3dd707ea4556edbfcc"}]}