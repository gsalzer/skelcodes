{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  } \r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract LoveToken {\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function freeze(address target) public returns (bool);\r\n  function release(address target) public returns (bool);\r\n}\r\n\r\ncontract LoveContribution is Ownable {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  //The token being given\r\n  LoveToken  token;\r\n  \r\n  // contribution in wei\r\n  mapping(address => uint256) public contributionOf;\r\n  \r\n  // array of contributors\r\n  address[] contributors;\r\n  \r\n  // array of top contributed winners\r\n   address[] topWinners=[address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0),address(0)];\r\n  \r\n  // array of random winners\r\n  address[] randomWinners;\r\n  \r\n  // won amount in wei\r\n  mapping(address => uint256) public amountWon;\r\n  \r\n  // ckeck whether the winner withdrawn the won amount\r\n  mapping(address => bool) public claimed;\r\n  \r\n  // ckeck whether the contributor completed KYC\r\n  mapping(address => bool) public KYCDone;\r\n\r\n  // start and end timestamps\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n\r\n  // price of token in wei\r\n  uint256 public rate = 10e14;\r\n\r\n  // amount of wei raised\r\n  uint256 public weiRaised;\r\n  \r\n  // amount of wei withdrawn by owner\r\n  uint256 public ownerWithdrawn;\r\n  \r\n  event contributionSuccessful(address indexed contributedBy, uint256 contribution, uint256 tokenReceived);\r\n  event FundTransfer(address indexed beneficiary, uint256 amount);\r\n  event FundTransferFailed();\r\n  event KYCApproved(address indexed contributor);\r\n\r\n  function LoveContribution(uint256 _startTime, uint256 _endTime, LoveToken  _token) public {\r\n    require(_startTime >= now);\r\n    require(_endTime >= _startTime);\r\n    require(_token != address(0));\r\n\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n    token = _token;\r\n  }\r\n\r\n  // fallback function can be used to buy tokens\r\n  function () external payable {\r\n    contribute();\r\n  }\r\n    \r\n   \r\n  /**\r\n   * @dev low level token purchase function\r\n   */\r\n  function contribute() internal {\r\n    uint256 weiAmount = msg.value;\r\n    require(msg.sender != address(0) && weiAmount >= 5e15);\r\n    require(now >= startTime && now <= endTime);\r\n    \r\n    // calculate the number of tokens to be send. multipling with (10 ** 8) since the token used has 8 decimals\r\n    uint256 numToken = getTokenAmount(weiAmount).mul(10 ** 8);\r\n    \r\n    // check whether the contract have enough token balance \r\n    require(token.balanceOf(this).sub(numToken) > 0 );\r\n    \r\n    // check whether the sender is contributing for the first time\r\n    if(contributionOf[msg.sender] <= 0){\r\n        contributors.push(msg.sender);\r\n        token.freeze(msg.sender);\r\n    }\r\n    \r\n    contributionOf[msg.sender] = contributionOf[msg.sender].add(weiAmount);\r\n    \r\n    token.transfer(msg.sender, numToken);\r\n    \r\n    weiRaised = weiRaised.add(weiAmount);\r\n    \r\n    updateWinnersList();\r\n    \r\n    contributionSuccessful(msg.sender,weiAmount,numToken);\r\n  }\r\n\r\n  // @return Number of tokens\r\n  function getTokenAmount(uint256 weiAmount) internal returns(uint256) {\r\n       uint256 tokenAmount;\r\n       \r\n        if(weiRaised <= 100 ether){\r\n            rate = 10e14;\r\n            tokenAmount = weiAmount.div(rate);\r\n            return tokenAmount;\r\n        }\r\n        else if(weiRaised > 100 ether && weiRaised <= 150 ether){\r\n            rate = 15e14;\r\n            tokenAmount = weiAmount.div(rate);\r\n            return tokenAmount;\r\n        }\r\n        else if(weiRaised > 150 ether && weiRaised <= 200 ether){\r\n            rate = 20e14;\r\n            tokenAmount = weiAmount.div(rate);\r\n            return tokenAmount;\r\n        }\r\n        else if(weiRaised > 200 ether && weiRaised <= 250 ether){\r\n            rate = 25e14;\r\n            tokenAmount = weiAmount.div(rate);\r\n            return tokenAmount;\r\n        }\r\n        else if(weiRaised > 250){\r\n            rate = 30e14;\r\n            tokenAmount = weiAmount.div(rate);\r\n            return tokenAmount;\r\n        }\r\n        \r\n  }\r\n  \r\n  // update winners list\r\n  function updateWinnersList() internal returns(bool) {\r\n      if(topWinners[0] != msg.sender){\r\n       bool flag=false;\r\n       for(uint256 i = 0; i < 10; i++){\r\n           if(topWinners[i] == msg.sender){\r\n               break;\r\n           }\r\n           if(contributionOf[msg.sender] > contributionOf[topWinners[i]]){\r\n               flag=true;\r\n               break;\r\n           }\r\n       }\r\n       if(flag == true){\r\n           for(uint256 j = 10; j > i; j--){\r\n               if(topWinners[j-1] != msg.sender){\r\n                   topWinners[j]=topWinners[j-1];\r\n               }\r\n               else{\r\n                   for(uint256 k = j; k < 10; k++){\r\n                       topWinners[k]=topWinners[k+1];\r\n                   }\r\n               }\r\n            }\r\n            topWinners[i]=msg.sender;\r\n       }\r\n       return true;\r\n     }\r\n  }\r\n\r\n  // @return true if contract is expired\r\n  function hasEnded() public view returns (bool) {\r\n    return (now > endTime) ;\r\n  }\r\n  \r\n  /**\r\n   * @dev Function to find the winners\r\n   */\r\n  function findWinners() public onlyOwner {\r\n    require(now >= endTime);\r\n    \r\n    // number of contributors\r\n    uint256 len=contributors.length;\r\n    \r\n    // factor multiplied to get the deserved percentage of weiRaised for a winner\r\n    uint256 mulFactor=50;\r\n    \r\n    // setting top ten winners with won amount \r\n    for(uint256 num = 0; num < 10 && num < len; num++){\r\n      amountWon[topWinners[num]]=(weiRaised.div(1000)).mul(mulFactor);\r\n      mulFactor=mulFactor.sub(5);\r\n     }\r\n     topWinners.length--;\r\n       \r\n    // setting next 10 random winners \r\n    if(len > 10 && len <= 20 ){\r\n        for(num = 0 ; num < 20 && num < len; num++){\r\n            if(amountWon[contributors[num]] <= 0){\r\n            randomWinners.push(contributors[num]);\r\n            amountWon[contributors[num]]=(weiRaised.div(1000)).mul(3);\r\n            }\r\n        }\r\n    }\r\n    else if(len > 20){\r\n        for(uint256 i = 0 ; i < 10; i++){\r\n            // finding a random number(winner) excluding the top 10 winners\r\n            uint256 randomNo=random(i+1) % len;\r\n            // To avoid multiple wining by same address\r\n            if(amountWon[contributors[randomNo]] <= 0){\r\n                randomWinners.push(contributors[randomNo]);\r\n                amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3);\r\n            }\r\n            else{\r\n                \r\n                for(uint256 j = 0; j < len; j++){\r\n                    randomNo=(randomNo.add(1)) % len;\r\n                    if(amountWon[contributors[randomNo]] <= 0){\r\n                        randomWinners.push(contributors[randomNo]);\r\n                        amountWon[contributors[randomNo]]=(weiRaised.div(1000)).mul(3);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }    \r\n    }\r\n  }\r\n  \r\n    \r\n  /**\r\n   * @dev Generate a random using the block number and loop count as the seed of randomness.\r\n   */\r\n   function random(uint256 count) internal constant returns (uint256) {\r\n    uint256 rand = block.number.mul(count);\r\n    return rand;\r\n  }\r\n  \r\n  /**\r\n   * @dev Function to stop the contribution\r\n   */\r\n  function stop() public onlyOwner  {\r\n    endTime = now ;\r\n  }\r\n  \r\n  /**\r\n   * @dev Function for withdrawing eth by the owner\r\n   */\r\n  function ownerWithdrawal(uint256 amt) public onlyOwner  {\r\n    // Limit owner from withdrawing not more than 70% \r\n    require((amt.add(ownerWithdrawn)) <= (weiRaised.div(100)).mul(70));\r\n    if (owner.send(amt)) {\r\n        ownerWithdrawn=ownerWithdrawn.add(amt);\r\n        FundTransfer(owner, amt);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * @dev Function for approving contributors after KYC\r\n   */\r\n  function KYCApprove(address[] contributorsList) public onlyOwner  {\r\n    for (uint256 i = 0; i < contributorsList.length; i++) {\r\n        address addr=contributorsList[i];\r\n        //set KYC Status\r\n        KYCDone[addr]=true;\r\n        KYCApproved(addr);\r\n        token.release(addr);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * @dev Function for withdrawing won amount by the winners\r\n   */\r\n  function winnerWithdrawal() public {\r\n    require(now >= endTime);\r\n    //check whether winner\r\n    require(amountWon[msg.sender] > 0);\r\n    //check whether winner done KYC\r\n    require(KYCDone[msg.sender]);\r\n    //check whether winner already withdrawn the won amount \r\n    require(!claimed[msg.sender]);\r\n\r\n    if (msg.sender.send(amountWon[msg.sender])) {\r\n        claimed[msg.sender]=true;\r\n        FundTransfer(msg.sender,amountWon[msg.sender] );\r\n    }\r\n  }\r\n  \r\n  // @return Current token balance of this contract\r\n  function tokensAvailable()public view returns (uint256) {\r\n    return token.balanceOf(this);\r\n  }\r\n  \r\n  // @return List of top winners\r\n  function showTopWinners() public view returns (address[]) {\r\n    require(now >= endTime);\r\n        return (topWinners);\r\n  }\r\n  \r\n  // @return List of random winners\r\n  function showRandomWinners() public view returns (address[]) {\r\n    require(now >= endTime);\r\n        return (randomWinners);\r\n  }\r\n  \r\n  /**\r\n   * @dev Function to destroy contract\r\n   */\r\n  function destroy() public onlyOwner {\r\n    require(now >= endTime);\r\n    uint256 balance= this.balance;\r\n    owner.transfer(balance);\r\n    FundTransfer(owner, balance);\r\n    uint256 balanceToken = tokensAvailable();\r\n    token.transfer(owner, balanceToken);\r\n    selfdestruct(owner);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showTopWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"KYCDone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"winnerWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"findWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributorsList\",\"type\":\"address[]\"}],\"name\":\"KYCApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showRandomWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributionOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"ownerWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributedBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenReceived\",\"type\":\"uint256\"}],\"name\":\"contributionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FundTransferFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"KYCApproved\",\"type\":\"event\"}]","ContractName":"LoveContribution","CompilerVersion":"v0.4.20-nightly.2018.1.6+commit.2548228b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a991d80000000000000000000000000000000000000000000000000000000005abf7840000000000000000000000000b510788cbb9aea54221d3dc8cce2dff629a1dbf7","Library":"","SwarmSource":"bzzr://39fbbf55326bd4bfbea6cac2fc2eb58c57981f0ef5396152e17c586edf09d0ae"}]}