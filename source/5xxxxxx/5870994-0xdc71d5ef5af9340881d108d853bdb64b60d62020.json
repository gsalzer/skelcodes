{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n// END OF library SafeMath\r\n\r\ncontract Roles {\r\n    // Master Key access, always ONE and ONE ONLY \r\n    address public superAdmin ;\r\n\r\n    address public canary ; \r\n\r\n\r\n    // initiators and validators can be many\r\n    mapping (address => bool) public initiators ; \r\n    mapping (address => bool) public validators ;  \r\n    address[] validatorsAcct ; \r\n\r\n    // keep track of the current qty. of initiators around \r\n    uint public qtyInitiators ; \r\n\r\n    // hard-code the max amount of validators/voters in the system \r\n    // this is required to initialize the storage for each new proposal \r\n    uint constant public maxValidators = 20 ; \r\n\r\n    // keep track of the current qty. of active validators around \r\n    uint public qtyValidators ; \r\n\r\n    event superAdminOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event initiatorAdded(address indexed newInitiator);\r\n    event validatorAdded(address indexed newValidator);\r\n    event initiatorRemoved(address indexed removedInitiator);\r\n    event validatorRemoved(address indexed addedValidator);\r\n    event canaryOwnershipTransferred(address indexed previousOwner, address indexed newOwner) ; \r\n\r\n\r\n    \r\n    constructor() public \r\n    { \r\n      superAdmin = msg.sender ;\r\n      \r\n    }\r\n\r\n    modifier onlySuperAdmin {\r\n        require( msg.sender == superAdmin );\r\n        _;\r\n    }\r\n\r\n    modifier onlyCanary {\r\n        require( msg.sender == canary );\r\n        _;\r\n    }\r\n\r\n    modifier onlyInitiators {\r\n        require( initiators[msg.sender] );\r\n        _;\r\n    }\r\n    \r\n    modifier onlyValidators {\r\n        require( validators[msg.sender] );\r\n        _;\r\n    }\r\n    \r\n\r\nfunction transferSuperAdminOwnership(address newOwner) public onlySuperAdmin \r\n{\r\n  require(newOwner != address(0)) ;\r\n  superAdmin = newOwner ;\r\n  emit superAdminOwnershipTransferred(superAdmin, newOwner) ;  \r\n}\r\n\r\nfunction transferCanaryOwnership(address newOwner) public onlySuperAdmin \r\n{\r\n  require(newOwner != address(0)) ;\r\n  canary = newOwner ;\r\n  emit canaryOwnershipTransferred(canary, newOwner) ;  \r\n}\r\n\r\n\r\nfunction addValidator(address _validatorAddr) public onlySuperAdmin \r\n{\r\n  require(_validatorAddr != address(0));\r\n  require(!validators[_validatorAddr]) ; \r\n  validators[_validatorAddr] = true ; \r\n  validatorsAcct.push(_validatorAddr) ; \r\n  qtyValidators++ ; \r\n  emit validatorAdded(_validatorAddr) ;  \r\n}\r\n\r\nfunction revokeValidator(address _validatorAddr) public onlySuperAdmin\r\n{\r\n  require(_validatorAddr != address(0));\r\n  require(validators[_validatorAddr]) ; \r\n  validators[_validatorAddr] = false ; \r\n  \r\n  for(uint i = 0 ; i < qtyValidators ; i++ ) \r\n    {\r\n      if (validatorsAcct[i] == _validatorAddr)\r\n         validatorsAcct[i] = address(0) ; \r\n    }\r\n  qtyValidators-- ; \r\n  emit validatorRemoved(_validatorAddr) ;  \r\n}\r\n\r\nfunction addInitiator(address _initiatorAddr) public onlySuperAdmin\r\n{\r\n  require(_initiatorAddr != address(0));\r\n  require(!initiators[_initiatorAddr]) ;\r\n  initiators[_initiatorAddr] = true ; \r\n  qtyInitiators++ ; \r\n  emit initiatorAdded(_initiatorAddr) ; \r\n}\r\n\r\nfunction revokeInitiator(address _initiatorAddr) public onlySuperAdmin\r\n{\r\n  require(_initiatorAddr != address(0));\r\n  require(initiators[_initiatorAddr]) ; \r\n  initiators[_initiatorAddr] = false ;\r\n  qtyInitiators-- ; \r\n  emit initiatorRemoved(_initiatorAddr) ; \r\n}\r\n  \r\n\r\n} // END OF Roles contract \r\n\r\n\r\ncontract Storage {\r\n\r\n  // We store here the whole storage implementation, decoupling the logic \r\n  // which will be defined in FKXIdentitiesV1, FKXIdentitiesV2..., FKXIdentitiesV1n\r\n\r\nuint scoringThreshold ; \r\n\r\nstruct Proposal \r\n  {\r\n    string ipfsAddress ; \r\n    uint timestamp ; \r\n    uint totalAffirmativeVotes ; \r\n    uint totalNegativeVotes ; \r\n    uint totalVoters ; \r\n    address[] votersAcct ; \r\n    mapping (address => uint) votes ; \r\n  }\r\n\r\n// storage to keep track of all the proposals \r\nmapping (bytes32 => Proposal) public proposals ; \r\nuint256 totalProposals ; \r\n\r\n// helper array to keep track of all rootHashes proposals\r\nbytes32[] rootHashesProposals ; \r\n\r\n\r\n// storage records the final && immutable ipfsAddresses validated by majority consensus of validators\r\nmapping (bytes32 => string) public ipfsAddresses ; \r\n\r\n// Helper vector to track all keys (rootHasshes) added to ipfsAddresses\r\nbytes32[] ipfsAddressesAcct ;\r\n\r\n}\r\n\r\n\r\ncontract Registry is Storage, Roles {\r\n\r\n    address public logic_contract;\r\n\r\n    function setLogicContract(address _c) public onlySuperAdmin returns (bool success){\r\n        logic_contract = _c;\r\n        return true;\r\n    }\r\n\r\n    function () payable public {\r\n        address target = logic_contract;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, target, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            case 1 { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract FKXIdentitiesV1 is Storage, Roles {\r\n\r\nusing SafeMath for uint256;\r\n\r\nevent newProposalLogged(address indexed initiator, bytes32 rootHash, string ipfsAddress ) ; \r\nevent newVoteLogged(address indexed voter, bool vote) ;\r\nevent newIpfsAddressAdded(bytes32 rootHash, string ipfsAddress ) ; \r\n\r\n\r\nconstructor() public \r\n{\r\n  qtyInitiators = 0 ; \r\n  qtyValidators = 0 ; \r\n  scoringThreshold = 10 ;\r\n}\r\n\r\n// Set the score parameter that once reached would eliminate/revoke\r\n// validators with scores greater than _scoreMax from the list of authorized validators\r\nfunction setScoringThreshold(uint _scoreMax) public onlySuperAdmin\r\n{\r\n  scoringThreshold = _scoreMax ; \r\n}\r\n\r\n\r\n// An initiator writes a new proposal in the proposal storage area \r\n\r\nfunction propose(bytes32 _rootHash, string _ipfsAddress) public onlyInitiators\r\n{\r\n  // proposal should not be present already, i.e timestamp has to be in an uninitialized state, i.e. zero \r\n  require(proposals[_rootHash].timestamp == 0 ) ;\r\n\r\n  // writes the proposal for the _ipfsAddress, timestamp it 'now' and set the qty to zero (i.e. no votes yet)\r\n  address[] memory newVoterAcct = new address[](maxValidators) ; \r\n  Proposal memory newProposal = Proposal( _ipfsAddress , now, 0, 0, 0, newVoterAcct ) ; \r\n  proposals[_rootHash] = newProposal ; \r\n  emit newProposalLogged(msg.sender, _rootHash, _ipfsAddress ) ; \r\n  rootHashesProposals.push(_rootHash) ; \r\n  totalProposals++ ; \r\n}\r\n\r\n\r\n// obtain, for a given rootHash, the definitive immutable stored _ipfsAddress \r\nfunction getIpfsAddress(bytes32 _rootHash) constant public returns (string _ipfsAddress)\r\n{\r\n  return ipfsAddresses[_rootHash] ; \r\n}\r\n\r\n// obtain, for a given rootHash, the proposed (not definitively voted yet) _ipfsAddress\r\nfunction getProposedIpfs(bytes32 _rootHash) constant public returns (string _ipfsAddress)\r\n{\r\n  return proposals[_rootHash].ipfsAddress ; \r\n}\r\n\r\n// how many voters have voted for a given proposal? \r\nfunction howManyVoters(bytes32 _rootHash) constant public returns (uint)\r\n{\r\n  return proposals[_rootHash].totalVoters ; \r\n}\r\n\r\n// Validator casts one vote to the proposed ipfsAddress stored in the _rootHash key in the proposals storage area \r\n// if _vote == true means voting affirmatively, else if _vote == false, means voting negatively\r\nfunction vote(bytes32 _rootHash, bool _vote) public onlyValidators\r\n{\r\n  // if timestamp == 0 it means such proposal does not exist, i.e. was never timestamped hence \r\n  //  contains the 'zero' uninitialized value\r\n  require(proposals[_rootHash].timestamp > 0) ;\r\n\r\n  // checks this validator have not already voted for this proposal\r\n  // 0 no voted yet\r\n  // 1 voted affirmatively\r\n  // 2 voted negatively \r\n\r\n  require(proposals[_rootHash].votes[msg.sender]==0) ; \r\n\r\n  // add this validator address to the array of voters. \r\n  proposals[_rootHash].votersAcct.push(msg.sender) ; \r\n\r\n  if (_vote ) \r\n    { \r\n      proposals[_rootHash].votes[msg.sender] = 1 ; // 1 means votes affirmatively\r\n      proposals[_rootHash].totalAffirmativeVotes++ ; \r\n    } \r\n       else \r\n        { proposals[_rootHash].votes[msg.sender] = 2 ; // 2 means votes negatively\r\n          proposals[_rootHash].totalNegativeVotes++ ; \r\n        } \r\n\r\n  emit newVoteLogged(msg.sender, _vote) ;\r\n  proposals[_rootHash].totalVoters++ ; \r\n\r\n  // check if a majority consensus was obtained and if so, it records the final result in the definitive \r\n  // immutable storage area: ipfsAddresses \r\n  if ( isConsensusObtained(proposals[_rootHash].totalAffirmativeVotes) )\r\n  {\r\n  // need to make sure the consensuated vote had not already been written to the storage area ipfsAddresses\r\n  // so we don't write duplicate info again, just to save some gas :) and also b/c it's the right thing to do \r\n  // to minimize entropy in the universe... hence, we need to check for an empty string\r\n    bytes memory tempEmptyString = bytes(ipfsAddresses[_rootHash]) ; \r\n    if ( tempEmptyString.length == 0 ) \r\n      { \r\n        ipfsAddresses[_rootHash] = proposals[_rootHash].ipfsAddress ;  \r\n        emit newIpfsAddressAdded(_rootHash, ipfsAddresses[_rootHash] ) ;\r\n        ipfsAddressesAcct.push(_rootHash) ; \r\n\r\n      } \r\n\r\n  }\r\n\r\n} \r\n\r\n\r\n// returns the total number of ipfsAddresses ever stored in the definitive immutable storage 'ipfsAddresses'\r\nfunction getTotalQtyIpfsAddresses() constant public returns (uint)\r\n{ \r\n  return ipfsAddressesAcct.length ; \r\n}\r\n\r\n// returns one rootHash which is stored at a specific _index position\r\nfunction getOneByOneRootHash(uint _index) constant public returns (bytes32 _rootHash )\r\n{\r\n  require( _index <= (getTotalQtyIpfsAddresses()-1) ) ; \r\n  return ipfsAddressesAcct[_index] ; \r\n}\r\n\r\n// consensus obtained it is true if and only if n+1 validators voted affirmatively for a proposal \r\n// where n == the total qty. of validators (qtyValidators)\r\nfunction isConsensusObtained(uint _totalAffirmativeVotes) constant public returns (bool)\r\n{\r\n // multiplying by 10000 (10 thousand) for decimal precision management\r\n // note: This scales up to 9999 validators only\r\n\r\n require (qtyValidators > 0) ; // prevents division by zero \r\n uint dTotalVotes = _totalAffirmativeVotes * 10000 ; \r\n return (dTotalVotes / qtyValidators > 5000 ) ;\r\n\r\n}\r\n\r\n\r\n// Validators:\r\n// returns one proposal (the first one) greater than, STRICTLY GREATER THAN the given _timestampFrom \r\n// timestamp > _timestampFrom \r\nfunction getProposals(uint _timestampFrom) constant public returns (bytes32 _rootHash)\r\n{\r\n   // returns the first rootHash corresponding to a timestamp greater than the parameter \r\n   uint max = rootHashesProposals.length ; \r\n\r\n   for(uint i = 0 ; i < max ; i++ ) \r\n    {\r\n      if (proposals[rootHashesProposals[i]].timestamp > _timestampFrom)\r\n         return rootHashesProposals[i] ; \r\n    }\r\n\r\n}\r\n\r\n// returns, for one proposal \r\n// identified by a rootHash, the timestamp UNIX epoch time associated with it\r\n\r\nfunction getTimestampProposal(bytes32 _rootHash) constant public returns (uint _timeStamp) \r\n{\r\n  return proposals[_rootHash].timestamp ; \r\n}\r\n\r\n\r\n\r\n// returns the total quantity of active validators\r\n// only 'active' ones quantity  \r\nfunction getQtyValidators() constant public returns (uint)\r\n{\r\n  return qtyValidators ; \r\n}\r\n\r\n// It returns the address of an active validator in the specific '_t' vector position of active validators \r\n// vector positions start at zero and ends at 'getQtyValidators - 1' so in order to get all vaidators \r\n// you have to iterate one by one from 0 to ' getQtyValidators -1 '\r\nfunction getValidatorAddress(int _t) constant public returns (address _validatorAddr)\r\n{\r\n   int x = -1 ; \r\n   uint size = validatorsAcct.length ; \r\n\r\n   for ( uint i = 0 ; i < size ; i++ )\r\n   {\r\n\r\n      if ( validators[validatorsAcct[i]] ) x++ ; \r\n      if ( x == _t ) return (validatorsAcct[i]) ;  \r\n   }\r\n}\r\n \r\n// returns true if the rootHash was impacted, i.e. it's available and exists in the ipfsAddresses array\r\n// and false if otherwise\r\n\r\nfunction getStatusForRootHash(bytes32 _rootHash) constant public returns (bool)\r\n{\r\n bytes memory tempEmptyStringTest = bytes(ipfsAddresses[_rootHash]); // Uses memory\r\n if (tempEmptyStringTest.length == 0) {\r\n    // emptyStringTest is an empty string, hence the _rootHash was not impacted there so does not exist\r\n    return false ; \r\n} else {\r\n    // emptyStringTest is not an empty string\r\n    return true ; \r\n}\r\n\r\n} \r\n\r\n} // END OF FKXIdentities contract \r\n\r\n\r\n// DEBUG info below IGNORE \r\n// rootHash examples below, always 32 bytes in the format:\r\n// 0x12207D5A99F603F231D53A4F39D1521F98D2E8BB279CF29BEBFD0687DC98458E\r\n// 0x12207D5A99F603F231D53A4F39D1521F98D2E8BB279CF29BEBFD0687DC98458F\r\n// ipfs address, string: \"whatever here\",\r\n\r\n// JUN-5 v1 contract deployed at https://rinkeby.etherscan.io/address/0xbe2ee825339c25749fb8ff8f6621d304fb2e2be5\r\n// JUN-5 v1 contract deployed at https://ropsten.etherscan.io/address/0xbe2ee825339c25749fb8ff8f6621d304fb2e2be5\r\n\r\n// SuperOwner account is: 0xFA8f851b63E3742Eb5909C0735017C75b999B043 (macbook chrome)\r\n\r\n\r\n// returns the vote status for a given proposal for a specific validator Address \r\n// 0 no voted yet / blank vote \r\n// 1 voted affirmatively\r\n// 2 voted negatively \r\n// function getVoterStatus(bytes32 _rootHash, address _validatorAddr) constant public returns (uint _voteStatus)\r\n// {\r\n\r\n // proposals[_rootHash].votes[_validatorAddr] ; \r\n\r\n// }","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"name\":\"_ipfsAddress\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_validatorAddr\",\"type\":\"address\"}],\"name\":\"revokeValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initiatorAddr\",\"type\":\"address\"}],\"name\":\"revokeInitiator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQtyValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"}],\"name\":\"getIpfsAddress\",\"outputs\":[{\"name\":\"_ipfsAddress\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ipfsAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"}],\"name\":\"getTimestampProposal\",\"outputs\":[{\"name\":\"_timeStamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"qtyInitiators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestampFrom\",\"type\":\"uint256\"}],\"name\":\"getProposals\",\"outputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"ipfsAddress\",\"type\":\"string\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"totalAffirmativeVotes\",\"type\":\"uint256\"},{\"name\":\"totalNegativeVotes\",\"type\":\"uint256\"},{\"name\":\"totalVoters\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalAffirmativeVotes\",\"type\":\"uint256\"}],\"name\":\"isConsensusObtained\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_validatorAddr\",\"type\":\"address\"}],\"name\":\"addValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"}],\"name\":\"getProposedIpfs\",\"outputs\":[{\"name\":\"_ipfsAddress\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getOneByOneRootHash\",\"outputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferSuperAdminOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_t\",\"type\":\"int256\"}],\"name\":\"getValidatorAddress\",\"outputs\":[{\"name\":\"_validatorAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"qtyValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"}],\"name\":\"howManyVoters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferCanaryOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initiatorAddr\",\"type\":\"address\"}],\"name\":\"addInitiator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalQtyIpfsAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"initiators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_scoreMax\",\"type\":\"uint256\"}],\"name\":\"setScoringThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"validators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rootHash\",\"type\":\"bytes32\"}],\"name\":\"getStatusForRootHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ipfsAddress\",\"type\":\"string\"}],\"name\":\"newProposalLogged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vote\",\"type\":\"bool\"}],\"name\":\"newVoteLogged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rootHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ipfsAddress\",\"type\":\"string\"}],\"name\":\"newIpfsAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"superAdminOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newInitiator\",\"type\":\"address\"}],\"name\":\"initiatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"validatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"removedInitiator\",\"type\":\"address\"}],\"name\":\"initiatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addedValidator\",\"type\":\"address\"}],\"name\":\"validatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"canaryOwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FKXIdentitiesV1","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://478e074202676fc264ed60dfd2d398321d2c7d715681f2c35865a4c3a8eca196"}]}