{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Sets contract owner to address of constructor caller\r\n    */\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  Change Owner\r\n    *\r\n    *  Changes ownership of this contract. Only owner can call this method.\r\n    *\r\n    * @param newOwner - new owner's address\r\n    */\r\n    function changeOwner(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        require(newOwner != owner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract FHFTokenInterface {\r\n    /* Public parameters of the token */\r\n    string public standard = 'Token 0.1';\r\n    string public name = 'Forever Has Fallen';\r\n    string public symbol = 'FC';\r\n    uint8 public decimals = 18;\r\n\r\n    function approveCrowdsale(address _crowdsaleAddress) external;\r\n    function balanceOf(address _address) public constant returns (uint256 balance);\r\n    function vestedBalanceOf(address _address) public constant returns (uint256 balance);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _currentValue, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract CrowdsaleParameters {\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Configuration Independent Parameters\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    struct AddressTokenAllocation {\r\n        address addr;\r\n        uint256 amount;\r\n    }\r\n\r\n    uint256 public maximumICOCap = 350e6;\r\n\r\n    // ICO period timestamps:\r\n    // 1525777200 = May 8, 2018. 11am GMT\r\n    // 1529406000 = June 19, 2018. 11am GMT\r\n    uint256 public generalSaleStartDate = 1525777200;\r\n    uint256 public generalSaleEndDate = 1529406000;\r\n\r\n    // Vesting\r\n    // 1592564400 = June 19, 2020. 11am GMT\r\n    uint32 internal vestingTeam = 1592564400;\r\n    // 1529406000 = Bounty to ico end date - June 19, 2018. 11am GMT\r\n    uint32 internal vestingBounty = 1529406000;\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Production Config\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // QA Config\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    AddressTokenAllocation internal generalSaleWallet = AddressTokenAllocation(0x265Fb686cdd2f9a853c519592078cC4d1718C15a, 350e6);\r\n    AddressTokenAllocation internal communityReserve =  AddressTokenAllocation(0x76d472C73681E3DF8a7fB3ca79E5f8915f9C5bA5, 450e6);\r\n    AddressTokenAllocation internal team =              AddressTokenAllocation(0x05d46150ceDF59ED60a86d5623baf522E0EB46a2, 170e6);\r\n    AddressTokenAllocation internal advisors =          AddressTokenAllocation(0x3d5fa25a3C0EB68690075eD810A10170e441413e, 48e5);\r\n    AddressTokenAllocation internal bounty =            AddressTokenAllocation(0xAc2099D2705434f75adA370420A8Dd397Bf7CCA1, 176e5);\r\n    AddressTokenAllocation internal administrative =    AddressTokenAllocation(0x438aB07D5EC30Dd9B0F370e0FE0455F93C95002e, 76e5);\r\n\r\n    address internal playersReserve = 0x8A40B0Cf87DaF12C689ADB5C74a1B2f23B3a33e1;\r\n}\r\n\r\ncontract FHFToken is Owned, CrowdsaleParameters, FHFTokenInterface {\r\n    /* Arrays of all balances, vesting, approvals, and approval uses */\r\n    mapping (address => uint256) private balances;              // Total token balances\r\n    mapping (address => uint256) private balancesEndIcoFreeze;  // Balances frozen for ICO end by address\r\n    mapping (address => uint256) private balances2yearFreeze;  // Balances frozen for 2 years after ICO end by address\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    mapping (address => mapping (address => bool)) private allowanceUsed;\r\n\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event VestingTransfer(address indexed from, address indexed to, uint256 value, uint256 vestingTime);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n    event Issuance(uint256 _amount); // triggered when the total supply is increased\r\n    event Destruction(uint256 _amount); // triggered when the total supply is decreased\r\n    event NewFHFToken(address _token);\r\n\r\n    /* Miscellaneous */\r\n    uint256 public totalSupply = 0; // 1 000 000 000 when minted\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Initializes contract with initial supply tokens to the creator of the contract\r\n    */\r\n    function FHFToken() public {\r\n        owner = msg.sender;\r\n\r\n        mintToken(generalSaleWallet);\r\n        mintToken(communityReserve);\r\n        mintToken(team);\r\n        mintToken(advisors);\r\n        mintToken(bounty);\r\n        mintToken(administrative);\r\n\r\n        NewFHFToken(address(this));\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  1. Associate crowdsale contract address with this Token\r\n    *  2. Allocate general sale amount\r\n    *\r\n    * @param _crowdsaleAddress - crowdsale contract address\r\n    */\r\n    function approveCrowdsale(address _crowdsaleAddress) external onlyOwner {\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint amount = generalSaleWallet.amount * exponent;\r\n\r\n        allowed[generalSaleWallet.addr][_crowdsaleAddress] = amount;\r\n        Approval(generalSaleWallet.addr, _crowdsaleAddress, amount);\r\n    }\r\n\r\n    /**\r\n    *  Get token balance of an address\r\n    *\r\n    * @param _address - address to query\r\n    * @return Token balance of _address\r\n    */\r\n    function balanceOf(address _address) public constant returns (uint256 balance) {\r\n        return balances[_address];\r\n    }\r\n\r\n    /**\r\n    *  Get vested token balance of an address\r\n    *\r\n    * @param _address - address to query\r\n    * @return balance that has vested\r\n    */\r\n    function vestedBalanceOf(address _address) public constant returns (uint256 balance) {\r\n        if (now < vestingBounty) {\r\n            return balances[_address] - balances2yearFreeze[_address] - balancesEndIcoFreeze[_address];\r\n        }\r\n        if (now < vestingTeam) {\r\n            return balances[_address] - balances2yearFreeze[_address];\r\n        } else {\r\n            return balances[_address];\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  Get token amount allocated for a transaction from _owner to _spender addresses\r\n    *\r\n    * @param _owner - owner address, i.e. address to transfer from\r\n    * @param _spender - spender address, i.e. address to transfer to\r\n    * @return Remaining amount allowed to be transferred\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    *  Create token and credit it to target address\r\n    *  Created tokens need to vest\r\n    *\r\n    */\r\n    function mintToken(AddressTokenAllocation tokenAllocation) internal {\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint mintedAmount = tokenAllocation.amount * exponent;\r\n\r\n        // Mint happens right here: Balance becomes non-zero from zero\r\n        balances[tokenAllocation.addr] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n\r\n        // Emit Issue and Transfer events\r\n        Issuance(mintedAmount);\r\n        Transfer(address(this), tokenAllocation.addr, mintedAmount);\r\n    }\r\n\r\n    /**\r\n    *  Allow another contract to spend some tokens on your behalf\r\n    *\r\n    * @param _spender - address to allocate tokens for\r\n    * @param _value - number of tokens to allocate\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\r\n        require(_value == 0 || allowanceUsed[msg.sender][_spender] == false);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        allowanceUsed[msg.sender][_spender] = false;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Allow another contract to spend some tokens on your behalf\r\n    *\r\n    * @param _spender - address to allocate tokens for\r\n    * @param _currentValue - current number of tokens approved for allocation\r\n    * @param _value - number of tokens to allocate\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function approve(address _spender, uint256 _currentValue, uint256 _value) public onlyPayloadSize(3*32) returns (bool success) {\r\n        require(allowed[msg.sender][_spender] == _currentValue);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Send coins from sender's address to address specified in parameters\r\n    *\r\n    * @param _to - address to send to\r\n    * @param _value - amount to send in Wei\r\n    */\r\n    function transfer(address _to, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\r\n        // Check if the sender has enough\r\n        require(vestedBalanceOf(msg.sender) >= _value);\r\n\r\n        // Subtract from the sender\r\n        // _value is never greater than balance of input validation above\r\n        balances[msg.sender] -= _value;\r\n\r\n        // Overflow is never possible due to input validation above\r\n        balances[_to] += _value;\r\n\r\n        // If tokens issued from this address need to vest (i.e. this address is a team pool), freeze them here\r\n        if ((msg.sender == bounty.addr) && (now < vestingBounty)) {\r\n            balancesEndIcoFreeze[_to] += _value;\r\n        }\r\n        if ((msg.sender == team.addr) && (now < vestingTeam)) {\r\n            balances2yearFreeze[_to] += _value;\r\n        }\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  A contract attempts to get the coins. Tokens should be previously allocated\r\n    *\r\n    * @param _to - address to transfer tokens to\r\n    * @param _from - address to transfer tokens from\r\n    * @param _value - number of tokens to transfer\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3*32) returns (bool success) {\r\n        // Check if the sender has enough\r\n        require(vestedBalanceOf(_from) >= _value);\r\n\r\n        // Check allowed\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        // Subtract from the sender\r\n        // _value is never greater than balance because of input validation above\r\n        balances[_from] -= _value;\r\n        // Add the same to the recipient\r\n        // Overflow is not possible because of input validation above\r\n        balances[_to] += _value;\r\n\r\n        // Deduct allocation\r\n        // _value is never greater than allowed amount because of input validation above\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        // If tokens issued from this address need to vest (i.e. this address is a team pool), freeze them here\r\n        if ((_from == bounty.addr) && (now < vestingBounty)) {\r\n            balancesEndIcoFreeze[_to] += _value;\r\n        }\r\n        if ((_from == team.addr) && (now < vestingTeam)) {\r\n            balances2yearFreeze[_to] += _value;\r\n        }\r\n\r\n        Transfer(_from, _to, _value);\r\n        allowanceUsed[_from][msg.sender] = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Default method\r\n    *\r\n    *  This unnamed function is called whenever someone tries to send ether to\r\n    *  it. Just revert transaction because there is nothing that Token can do\r\n    *  with incoming ether.\r\n    *\r\n    *  Missing payable modifier prevents accidental sending of ether\r\n    */\r\n    function() public {\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"vestedBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalSaleEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_currentValue\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"name\":\"approveCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumICOCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalSaleStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"vestingTime\",\"type\":\"uint256\"}],\"name\":\"VestingTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"NewFHFToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FHFToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1238cbb7ef31d128fad4a9034f76da27d13cd5eec21974f09ba24e935f077bab"}]}