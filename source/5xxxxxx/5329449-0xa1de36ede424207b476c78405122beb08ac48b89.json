{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n// Fucking kek that you read the source code \r\n// Warning this contract has an exit scam.\r\n\r\ncontract GameState{\r\n    // Vote timer / Buy in round / Lowest gas round / Close time.\r\n    uint256[3] RoundTimes = [(5 minutes), (20 minutes), (10 minutes)]; // 5 20 10\r\n    uint256[3] NextRound = [1,2,0]; // Round flow order. \r\n    \r\n\r\n    // Block external calls altering the game mode. \r\n//    modifier BlockExtern(){\r\n //       require(msg.sender==caller);\r\n  //      _;\r\n  //  }\r\n    \r\n    \r\n    uint256 public CurrentGame = 0;\r\n  ///  bool StartedGame = false;\r\n    \r\n    uint256 public Timestamp = 0;\r\n    \r\n    function Timer() internal view returns (bool){\r\n        if (block.timestamp < Timestamp){\r\n       //     StartedGame = false;\r\n            return (true);\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    // FixTimer is only for immediate start rounds \r\n    // takes last timer and adds stuff to that \r\n    function Start() internal {\r\n    \r\n        Timestamp = block.timestamp + RoundTimes[CurrentGame];\r\n\r\n       // StartedGame=true;\r\n    }\r\n    \r\n    function Next(bool StartNow) internal {\r\n        uint256 NextRoundBuffer = NextRound[CurrentGame];\r\n        if (StartNow){\r\n            //Start();\r\n           // StartedGame = true; \r\n            Timestamp = Timestamp + RoundTimes[NextRoundBuffer];\r\n        }\r\n        else{\r\n           // StartedGame = false;\r\n        }\r\n        CurrentGame = NextRoundBuffer;\r\n    }\r\n    \r\n //   function GameState() public {\r\n  //      caller = msg.sender;\r\n  //  }\r\n    \r\n    \r\n    \r\n    // returns bit number n from uint. \r\n    //function GetByte(uint256 bt, uint256 n) public returns (uint256){\r\n    //    return ((bt >> n) & (1));\r\n   // }\r\n    \r\n\r\n\r\n}\r\n\r\ncontract ServiceStation is GameState{\r\n  \r\n    uint256 public Votes = 0;\r\n    uint256 public constant VotesNecessary = 6; // THIS CANNOT BE 1 \r\n    uint256 public constant devFee = 500; // 5%\r\n    \r\n    address owner;\r\n    // Fee address is a contract and is supposed to be used for future projects. \r\n    // You can buy a dividend card here, which gives you 10% of the development fee. \r\n    // If someone else buys it, the contract enforces you do make profit by transferring\r\n    // (part of) the cost of the card to you. \r\n    // It will also pay out all dividends if someone buys the card\r\n    // A withdraw function is also available to withdraw the dividends up to that point. \r\n    // The way to lose money with this card is if not enough dev fee enters the contract AND no one buys the card. \r\n    // You can buy it on https://etherguy.surge.sh (if this site is offline, contact me). (Or check contract address and run it in remix to manually buy.)\r\n    address constant fee_address = 0x3323075B8D3c471631A004CcC5DAD0EEAbc5B4D1; \r\n    \r\n    \r\n    event NewVote(uint256 AllVotes);\r\n    event VoteStarted();\r\n    event ItemBought(uint256 ItemID, address OldOwner, address NewOwner, uint256 NewPrice, uint256 FlipAmount);\r\n    event JackpotChange(uint256 HighJP, uint256 LowJP);\r\n    event OutGassed(bool HighGame, uint256 NewGas, address WhoGassed, address NewGasser);\r\n    event Paid(address Paid, uint256 Amount);\r\n    \r\n    \r\n    modifier OnlyDev(){\r\n        require(msg.sender==owner);\r\n        _;\r\n    }\r\n    \r\n    modifier OnlyState(uint256 id){\r\n        require (CurrentGame == id);\r\n        _;\r\n    }\r\n    \r\n    // OR relation \r\n    modifier OnlyStateOR(uint256 id, uint256 id2){\r\n        require (CurrentGame == id || CurrentGame == id2);\r\n        _;\r\n    }\r\n    \r\n    // Thanks to TechnicalRise\r\n    // Ban contracts\r\n    modifier NoContract(){\r\n        uint size;\r\n        address addr = msg.sender;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size == 0);\r\n        _;\r\n    }\r\n    \r\n    function ServiceStation() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    // State 0 rules \r\n    // Simply vote. \r\n    \r\n    function Vote() public NoContract OnlyStateOR(0,2) {\r\n        bool StillOpen;\r\n        if (CurrentGame == 2){\r\n            StillOpen = Timer();\r\n            if (StillOpen){\r\n                revert(); // cannot vote yet. \r\n            }\r\n            else{\r\n                Next(false); // start in next lines.\r\n            }\r\n        }\r\n        StillOpen = Timer();\r\n        if (!StillOpen){\r\n            emit VoteStarted();\r\n            Start();\r\n            Votes=0;\r\n        }\r\n        if ((Votes+1)>= VotesNecessary){\r\n            GameStart();\r\n        }\r\n        else{\r\n            Votes++;\r\n        }\r\n        emit NewVote(Votes);\r\n    }\r\n    \r\n    function DevForceOpen() public NoContract OnlyState(0) OnlyDev {\r\n        emit NewVote(VotesNecessary);\r\n        Timestamp = now; // prevent that round immediately ends if votes were long ago. \r\n        GameStart();\r\n    }\r\n    \r\n    // State 1 rules \r\n    // Pyramid scheme, buy in for 10% jackpot.\r\n    \r\n    function GameStart() internal OnlyState(0){\r\n        RoundNumber++;\r\n        Votes = 0;\r\n        // pay latest persons if not yet paid. \r\n        Withdraw();\r\n        Next(true);\r\n        TotalPot = address(this).balance;\r\n    }\r\n\r\n    \r\n    uint256 RoundNumber = 0;\r\n    uint256 constant MaxItems = 11; // max id, so max items - 1 please here.\r\n    uint256 constant StartPrice = (0.005 ether);\r\n    uint256 constant PriceIncrease = 9750;\r\n    uint256 constant PotPaidTotal = 8000;\r\n    uint256 constant PotPaidHigh = 9000;\r\n    uint256 constant PreviousPaid = 6500;\r\n    uint256 public TotalPot;\r\n    \r\n    // This stores if you are in low jackpot, high jackpot\r\n    // It uses numbers to keep track how much items you have. \r\n    mapping(address => bool) LowJackpot;\r\n    mapping(address => uint256) HighJackpot;\r\n    mapping(address => uint256) CurrentRound;\r\n    \r\n    address public LowJackpotHolder;\r\n    address public HighJackpotHolder;\r\n    \r\n    uint256 CurrTimeHigh; \r\n    uint256 CurrTimeLow;\r\n    \r\n    uint256 public LowGasAmount;\r\n    uint256 public HighGasAmount;\r\n    \r\n    \r\n    struct Item{\r\n        address holder;\r\n        uint256 price;\r\n    }\r\n    \r\n    mapping(uint256 => Item) Market;\r\n    \r\n\r\n    // read jackpots \r\n    function GetJackpots() public view returns (uint256, uint256){\r\n        uint256 PotPaidRound = (TotalPot * PotPaidTotal)/10000;\r\n        uint256 HighJP = (PotPaidRound * PotPaidHigh)/10000;\r\n        uint256 LowJP = (PotPaidRound * (10000 - PotPaidHigh))/10000;\r\n        return (HighJP, LowJP);\r\n    }\r\n    \r\n    function GetItemInfo(uint256 ID) public view returns (uint256, address){\r\n        Item memory targetItem = Market[ID];\r\n        return (targetItem.price, targetItem.holder);\r\n    }\r\n    \r\n\r\n    function BuyItem(uint256 ID) public payable NoContract OnlyState(1){\r\n        require(ID <= MaxItems);\r\n        bool StillOpen = Timer();\r\n        if (!StillOpen){\r\n            revert();\r\n            //Next(); // move on to next at new timer; \r\n            //msg.sender.transfer(msg.value); // return amount. \r\n            //return; // cannot buy\r\n        }\r\n        uint256 price = Market[ID].price;\r\n        if (price == 0){\r\n            price = StartPrice;\r\n        }\r\n        require(msg.value >= price);\r\n        // excess big goodbye back to owner.\r\n        if (msg.value > price){\r\n            msg.sender.transfer(msg.value-price);\r\n        }\r\n       \r\n        \r\n        // fee -> out \r\n        \r\n        uint256 Fee = (price * (devFee))/10000;\r\n        uint256 Left = price - Fee;\r\n        \r\n        // send fee to fee address which is a contract. you can buy a dividend card to claim 10% of these funds, see above at \"address fee_address\"\r\n        fee_address.transfer(Fee);\r\n        \r\n        if (price != StartPrice){\r\n            // pay previous. \r\n            address target = Market[ID].holder;\r\n            uint256 payment = (price * PreviousPaid)/10000;\r\n            target.transfer (payment);\r\n            \r\n            if (target != msg.sender){\r\n                if (HighJackpot[target] >= 1){\r\n                    // Keep track of how many high jackpot items we own. \r\n                    // Why? Because if someone else buys your thing you might have another card \r\n                    // Which still gives you right to do high jackpot. \r\n                    HighJackpot[target] = HighJackpot[target] - 1;\r\n                }\r\n            }\r\n\r\n            //LowJackpotHolder = Market[ID].holder;\r\n            TotalPot = TotalPot + Left - payment;\r\n            \r\n            emit ItemBought(ID, target, msg.sender, (price * (PriceIncrease + 10000))/10000, payment);\r\n        }\r\n        else{\r\n            // Keep track of total pot because we gotta pay people from this later \r\n            // since people are paid immediately we cannot read this.balance because this decreases\r\n            TotalPot = TotalPot + Left;\r\n            emit ItemBought(ID, address(0x0), msg.sender, (price * (PriceIncrease + 10000))/10000, 0);\r\n        }\r\n        \r\n        uint256 PotPaidRound = (TotalPot * PotPaidTotal)/10000;\r\n        emit JackpotChange((PotPaidRound * PotPaidHigh)/10000, (PotPaidRound * (10000 - PotPaidHigh))/10000);\r\n        \r\n        \r\n        \r\n        // activate low pot. you can claim low pot if you are not in the high jackpot .\r\n        LowJackpot[msg.sender] = true;\r\n        \r\n        // Update price \r\n        \r\n        price = (price * (PriceIncrease + 10000))/10000;\r\n        \r\n        // \r\n        if (CurrentRound[msg.sender] != RoundNumber){\r\n            // New round reset count \r\n            if (HighJackpot[msg.sender] != 1){\r\n                HighJackpot[msg.sender] = 1;\r\n            }\r\n            CurrentRound[msg.sender] = RoundNumber;\r\n            \r\n        }\r\n        else{\r\n            HighJackpot[msg.sender] = HighJackpot[msg.sender] + 1;\r\n        }\r\n\r\n        Market[ID].holder = msg.sender;\r\n        Market[ID].price = price;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    // Round 2 least gas war \r\n    \r\n    // returns: can play (bool), high jackpot (bool)\r\n    function GetGameType(address targ) public view returns (bool, bool){\r\n        if (CurrentRound[targ] != RoundNumber){\r\n            // no buy in, reject playing jackpot game \r\n            return (false,false);\r\n        }\r\n        else{\r\n            \r\n            if (HighJackpot[targ] > 0){\r\n                // play high jackpot \r\n                return (true, true);\r\n            }\r\n            else{\r\n                if (LowJackpot[targ]){\r\n                    // play low jackpot \r\n                    return (true, false);\r\n                }\r\n            }\r\n            \r\n            \r\n        }\r\n        // functions should not go here. \r\n        return (false, false);\r\n    }\r\n    \r\n    \r\n    \r\n    // \r\n    function BurnGas() public NoContract OnlyStateOR(2,1) {\r\n        bool StillOpen;\r\n       if (CurrentGame == 1){\r\n           StillOpen = Timer();\r\n           if (!StillOpen){\r\n               Next(true); // move to round 2. immediate start \r\n           }\r\n           else{\r\n               revert(); // gas burn closed. \r\n           }\r\n       } \r\n       StillOpen = Timer();\r\n       if (!StillOpen){\r\n           Next(true);\r\n           Withdraw();\r\n           return;\r\n       }\r\n       bool CanPlay;\r\n       bool IsPremium;\r\n       (CanPlay, IsPremium) = GetGameType(msg.sender);\r\n       require(CanPlay); \r\n       \r\n       uint256 AllPot = (TotalPot * PotPaidTotal)/10000;\r\n       uint256 PotTarget;\r\n       \r\n\r\n       \r\n       uint256 timespent;\r\n       uint256 payment;\r\n       \r\n       if (IsPremium){\r\n           PotTarget = (AllPot * PotPaidHigh)/10000;\r\n           if (HighGasAmount == 0 || tx.gasprice < HighGasAmount){\r\n               if (HighGasAmount == 0){\r\n                   emit OutGassed(true, tx.gasprice, address(0x0), msg.sender);\r\n               }\r\n               else{\r\n                   timespent = now - CurrTimeHigh;\r\n                   payment = (PotTarget * timespent) / RoundTimes[2]; // calculate payment and send \r\n                   HighJackpotHolder.transfer(payment);\r\n                   emit OutGassed(true, tx.gasprice, HighJackpotHolder, msg.sender);\r\n                   emit Paid(HighJackpotHolder, payment);\r\n               }\r\n               HighGasAmount = tx.gasprice;\r\n               CurrTimeHigh = now;\r\n               HighJackpotHolder = msg.sender;\r\n           }\r\n       }\r\n       else{\r\n           PotTarget = (AllPot * (10000 - PotPaidHigh)) / 10000;\r\n           \r\n            if (LowGasAmount == 0 || tx.gasprice < LowGasAmount){\r\n               if (LowGasAmount == 0){\r\n                    emit OutGassed(false, tx.gasprice, address(0x0), msg.sender);\r\n               }\r\n               else{\r\n                   timespent = now - CurrTimeLow;\r\n                   payment = (PotTarget * timespent) / RoundTimes[2]; // calculate payment and send \r\n                   LowJackpotHolder.transfer(payment);\r\n                   emit OutGassed(false, tx.gasprice, LowJackpotHolder, msg.sender);\r\n                   emit Paid(LowJackpotHolder, payment);\r\n               }\r\n               LowGasAmount = tx.gasprice;\r\n               CurrTimeLow = now;\r\n               LowJackpotHolder = msg.sender;\r\n            }\r\n       }\r\n       \r\n      \r\n       \r\n  \r\n    }\r\n    \r\n    function Withdraw() public NoContract OnlyStateOR(0,2){\r\n        bool gonext = false;\r\n        if (CurrentGame == 2){\r\n            bool StillOpen;\r\n            StillOpen = Timer();\r\n            if (!StillOpen){\r\n                gonext = true;\r\n            }\r\n            else{\r\n                revert(); // no cheats\r\n            }\r\n        }\r\n        uint256 timespent;\r\n        uint256 payment;\r\n        uint256 AllPot = (TotalPot * PotPaidTotal)/10000;\r\n        uint256 PotTarget;\r\n        if (LowGasAmount != 0){\r\n            PotTarget = (AllPot * (10000 - PotPaidHigh))/10000;\r\n            timespent = Timestamp - CurrTimeLow;\r\n            payment = (PotTarget * timespent) / RoundTimes[2]; // calculate payment and send \r\n            LowJackpotHolder.transfer(payment);     \r\n            emit Paid(LowJackpotHolder, payment);\r\n        }\r\n        if (HighGasAmount != 0){\r\n            PotTarget = (AllPot * PotPaidHigh)/10000;\r\n            timespent = Timestamp - CurrTimeHigh;\r\n            payment = (PotTarget * timespent) / RoundTimes[2]; // calculate payment and send \r\n            HighJackpotHolder.transfer(payment);\r\n            emit Paid(HighJackpotHolder, payment);\r\n        }\r\n        // reset low gas high gas for next round \r\n        LowGasAmount = 0;\r\n        HighGasAmount = 0;\r\n        \r\n        // reset market prices. \r\n        uint8 id; \r\n        for (id=0; id<MaxItems; id++){\r\n            Market[id].price=0;\r\n        }\r\n        \r\n        if (gonext){\r\n            Next(true);\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    // this is added in case something goes wrong \r\n    // the contract can be funded if any bugs happen when \r\n    // trying to transfer eth.\r\n    function() payable{\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"DevForceOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LowGasAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HighJackpotHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"BurnGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HighGasAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetJackpots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"}],\"name\":\"BuyItem\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"}],\"name\":\"GetItemInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Votes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CurrentGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LowJackpotHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"targ\",\"type\":\"address\"}],\"name\":\"GetGameType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VotesNecessary\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Timestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"AllVotes\",\"type\":\"uint256\"}],\"name\":\"NewVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"VoteStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ItemID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"OldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"FlipAmount\",\"type\":\"uint256\"}],\"name\":\"ItemBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"HighJP\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"LowJP\",\"type\":\"uint256\"}],\"name\":\"JackpotChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"HighGame\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"NewGas\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"WhoGassed\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewGasser\",\"type\":\"address\"}],\"name\":\"OutGassed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Paid\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"Paid\",\"type\":\"event\"}]","ContractName":"ServiceStation","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a2277a29e5c340619d3634b5902aba78ef7ef241fe48d6d66f2b07671f782fb9"}]}