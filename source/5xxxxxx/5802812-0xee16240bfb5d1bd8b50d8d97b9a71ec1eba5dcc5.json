{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address _who) public constant returns (uint);\r\n  function allowance(address _owner, address _spender) public constant returns (uint);\r\n\r\n  function transfer(address _to, uint _value) public returns (bool ok);\r\n  function transferFrom(address _from, address _to, uint _value) public returns (bool ok);\r\n  function approve(address _spender, uint _value) public returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract VLToken is ERC20, Ownable, SafeMath {\r\n\r\n    // Token related informations\r\n    string public constant name = \"Villiam Blockchain Token\";\r\n    string public constant symbol = \"VLT\";\r\n    uint256 public constant decimals = 18; // decimal places\r\n\r\n    // Start withdraw of tokens\r\n    uint256 public startWithdraw;\r\n\r\n    // Address of wallet from which tokens assigned\r\n    address public ethExchangeWallet;\r\n\r\n    // MultiSig Wallet Address\r\n    address public VLTMultisig;\r\n\r\n    uint256 public tokensPerEther = 1500;\r\n\r\n    bool public startStop = false;\r\n\r\n    mapping (address => uint256) public walletAngelSales;\r\n    mapping (address => uint256) public walletPESales;\r\n\r\n    mapping (address => uint256) public releasedAngelSales;\r\n    mapping (address => uint256) public releasedPESales;\r\n\r\n    mapping (uint => address) public walletAddresses;\r\n\r\n    // Mapping of token balance and allowed address for each address with transfer limit\r\n    mapping (address => uint256) balances;\r\n    //mapping of allowed address for each address with tranfer limit\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function VLToken() public {\r\n        totalSupply = 500000000 ether;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n\r\n    // Only to be called by Owner of this contract\r\n    // @param _id Id of lock wallet address\r\n    // @param _walletAddress Address of lock wallet\r\n    function addWalletAddresses(uint _id, address _walletAddress) onlyOwner external{\r\n        require(_walletAddress != address(0));\r\n        walletAddresses[_id] = _walletAddress;\r\n    }\r\n\r\n    // Owner can Set Multisig wallet\r\n    // @param _vltMultisig address of Multisig wallet.\r\n    function setVLTMultiSig(address _vltMultisig) onlyOwner external{\r\n        require(_vltMultisig != address(0));\r\n        VLTMultisig = _vltMultisig;\r\n    }\r\n\r\n    // Only to be called by Owner of this contract\r\n    // @param _ethExchangeWallet Ether Address of exchange wallet\r\n    function setEthExchangeWallet(address _ethExchangeWallet) onlyOwner external {\r\n        require(_ethExchangeWallet != address(0));\r\n        ethExchangeWallet = _ethExchangeWallet;\r\n    }\r\n\r\n    // Only to be called by Owner of this contract\r\n    // @param _tokensPerEther Tokens per ether during ICO stages\r\n    function setTokensPerEther(uint256 _tokensPerEther) onlyOwner external {\r\n        require(_tokensPerEther > 0);\r\n        tokensPerEther = _tokensPerEther;\r\n    }\r\n\r\n    function startStopICO(bool status) onlyOwner external {\r\n        startStop = status;\r\n    }\r\n\r\n    function startLockingPeriod() onlyOwner external {\r\n        startWithdraw = now;\r\n    }\r\n\r\n    // Assign tokens to investor with locking period\r\n    function assignToken(address _investor,uint256 _tokens) external {\r\n        // Tokens assigned by only Angel Sales And PE Sales wallets\r\n        require(msg.sender == walletAddresses[0] || msg.sender == walletAddresses[1]);\r\n\r\n        // Check investor address and tokens.Not allow 0 value\r\n        require(_investor != address(0) && _tokens > 0);\r\n        // Check wallet have enough token balance to assign\r\n        require(_tokens <= balances[msg.sender]);\r\n        \r\n        // Debit the tokens from the wallet\r\n        balances[msg.sender] = safeSub(balances[msg.sender],_tokens);\r\n\r\n        uint256 calCurrentTokens = getPercentageAmount(_tokens, 20);\r\n        uint256 allocateTokens = safeSub(_tokens, calCurrentTokens);\r\n\r\n        // Initially assign 20% tokens to the investor\r\n        balances[_investor] = safeAdd(balances[_investor], calCurrentTokens);\r\n\r\n        // Assign tokens to the investor\r\n        if(msg.sender == walletAddresses[0]){\r\n            walletAngelSales[_investor] = safeAdd(walletAngelSales[_investor],allocateTokens);\r\n            releasedAngelSales[_investor] = safeAdd(releasedAngelSales[_investor], calCurrentTokens);\r\n        }\r\n        else if(msg.sender == walletAddresses[1]){\r\n            walletPESales[_investor] = safeAdd(walletPESales[_investor],allocateTokens);\r\n            releasedPESales[_investor] = safeAdd(releasedPESales[_investor], calCurrentTokens);\r\n        }\r\n        else{\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function withdrawTokens() public {\r\n        require(walletAngelSales[msg.sender] > 0 || walletPESales[msg.sender] > 0);\r\n        uint256 withdrawableAmount = 0;\r\n\r\n        if (walletAngelSales[msg.sender] > 0) {\r\n            uint256 withdrawableAmountAS = getWithdrawableAmountAS(msg.sender);\r\n            walletAngelSales[msg.sender] = safeSub(walletAngelSales[msg.sender], withdrawableAmountAS);\r\n            releasedAngelSales[msg.sender] = safeAdd(releasedAngelSales[msg.sender],withdrawableAmountAS);\r\n            withdrawableAmount = safeAdd(withdrawableAmount, withdrawableAmountAS);\r\n        }\r\n        if (walletPESales[msg.sender] > 0) {\r\n            uint256 withdrawableAmountPS = getWithdrawableAmountPES(msg.sender);\r\n            walletPESales[msg.sender] = safeSub(walletPESales[msg.sender], withdrawableAmountPS);\r\n            releasedPESales[msg.sender] = safeAdd(releasedPESales[msg.sender], withdrawableAmountPS);\r\n            withdrawableAmount = safeAdd(withdrawableAmount, withdrawableAmountPS);\r\n        }\r\n        require(withdrawableAmount > 0);\r\n        // Assign tokens to the sender\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], withdrawableAmount);\r\n    }\r\n\r\n    // For wallet Angel Sales\r\n    function getWithdrawableAmountAS(address _investor) public view returns(uint256) {\r\n        require(startWithdraw != 0);\r\n        // interval in months\r\n        uint interval = safeDiv(safeSub(now,startWithdraw),30 days);\r\n        // total allocatedTokens\r\n        uint _allocatedTokens = safeAdd(walletAngelSales[_investor],releasedAngelSales[_investor]);\r\n        // Atleast 6 months\r\n        if (interval < 6) { \r\n            return (0); \r\n        } else if (interval >= 6 && interval < 9) {\r\n            return safeSub(getPercentageAmount(40,_allocatedTokens), releasedAngelSales[_investor]);\r\n        } else if (interval >= 9 && interval < 12) {\r\n            return safeSub(getPercentageAmount(60,_allocatedTokens), releasedAngelSales[_investor]);\r\n        } else if (interval >= 12 && interval < 15) {\r\n            return safeSub(getPercentageAmount(80,_allocatedTokens), releasedAngelSales[_investor]);\r\n        } else if (interval >= 15) {\r\n            return safeSub(_allocatedTokens, releasedAngelSales[_investor]);\r\n        }\r\n    }\r\n\r\n    // For wallet PE Sales\r\n    function getWithdrawableAmountPES(address _investor) public view returns(uint256) {\r\n        require(startWithdraw != 0);\r\n        // interval in months\r\n        uint interval = safeDiv(safeSub(now,startWithdraw),30 days);\r\n        // total allocatedTokens\r\n        uint _allocatedTokens = safeAdd(walletPESales[_investor],releasedPESales[_investor]);\r\n        // Atleast 12 months\r\n        if (interval < 12) { \r\n            return (0); \r\n        } else if (interval >= 12 && interval < 18) {\r\n            return safeSub(getPercentageAmount(40,_allocatedTokens), releasedPESales[_investor]);\r\n        } else if (interval >= 18 && interval < 24) {\r\n            return safeSub(getPercentageAmount(60,_allocatedTokens), releasedPESales[_investor]);\r\n        } else if (interval >= 24 && interval < 30) {\r\n            return safeSub(getPercentageAmount(80,_allocatedTokens), releasedPESales[_investor]);\r\n        } else if (interval >= 30) {\r\n            return safeSub(_allocatedTokens, releasedPESales[_investor]);\r\n        }\r\n    }\r\n\r\n    function getPercentageAmount(uint256 percent,uint256 _tokens) internal pure returns (uint256) {\r\n        return safeDiv(safeMul(_tokens,percent),100);\r\n    }\r\n\r\n    // Sale of the tokens. Investors can call this method to invest into VLT Tokens\r\n    function() payable external {\r\n        // Allow only to invest in ICO stage\r\n        require(startStop);\r\n\r\n        //Sorry !! We only allow to invest with minimum 0.5 Ether as value\r\n        require(msg.value >= (0.5 ether));\r\n\r\n        // multiply by exchange rate to get token amount\r\n        uint256 calculatedTokens = safeMul(msg.value, tokensPerEther);\r\n\r\n        // Wait we check tokens available for assign\r\n        require(balances[ethExchangeWallet] >= calculatedTokens);\r\n\r\n        // Call to Internal function to assign tokens\r\n        assignTokens(msg.sender, calculatedTokens);\r\n    }\r\n\r\n    // Function will transfer the tokens to investor's address\r\n    // Common function code for assigning tokens\r\n    function assignTokens(address investor, uint256 tokens) internal {\r\n        // Debit tokens from ether exchange wallet\r\n        balances[ethExchangeWallet] = safeSub(balances[ethExchangeWallet], tokens);\r\n\r\n        // Assign tokens to the sender\r\n        balances[investor] = safeAdd(balances[investor], tokens);\r\n\r\n        // Finally token assigned to sender, log the creation event\r\n        Transfer(ethExchangeWallet, investor, tokens);\r\n    }\r\n\r\n    function finalizeCrowdSale() external{\r\n        // Check VLT Multisig wallet set or not\r\n        require(VLTMultisig != address(0));\r\n        // Send fund to multisig wallet\r\n        require(VLTMultisig.send(address(this).balance));\r\n    }\r\n\r\n    // @param _who The address of the investor to check balance\r\n    // @return balance tokens of investor address\r\n    function balanceOf(address _who) public constant returns (uint) {\r\n        return balances[_who];\r\n    }\r\n\r\n    // @param _owner The address of the account owning tokens\r\n    // @param _spender The address of the account able to transfer the tokens\r\n    // @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    //  Transfer `value` VLT tokens from sender's account\r\n    // `msg.sender` to provided account address `to`.\r\n    // @param _to The address of the recipient\r\n    // @param _value The number of VLT tokens to transfer\r\n    // @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) public returns (bool ok) {\r\n        //validate receiver address and value.Not allow 0 value\r\n        require(_to != 0 && _value > 0);\r\n        uint256 senderBalance = balances[msg.sender];\r\n        //Check sender have enough balance\r\n        require(senderBalance >= _value);\r\n        senderBalance = safeSub(senderBalance, _value);\r\n        balances[msg.sender] = senderBalance;\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    //  Transfer `value` VLT tokens from sender 'from'\r\n    // to provided account address `to`.\r\n    // @param from The address of the sender\r\n    // @param to The address of the recipient\r\n    // @param value The number of VLT to transfer\r\n    // @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool ok) {\r\n        //validate _from,_to address and _value(Now allow with 0)\r\n        require(_from != 0 && _to != 0 && _value > 0);\r\n        //Check amount is approved by the owner for spender to spent and owner have enough balances\r\n        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value);\r\n        balances[_from] = safeSub(balances[_from],_value);\r\n        balances[_to] = safeAdd(balances[_to],_value);\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    //  `msg.sender` approves `spender` to spend `value` tokens\r\n    // @param spender The address of the account able to transfer the tokens\r\n    // @param value The amount of wei to be approved for transfer\r\n    // @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) public returns (bool ok) {\r\n        //validate _spender address\r\n        require(_spender != 0);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"releasedPESales\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getWithdrawableAmountPES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"addWalletAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VLTMultisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletAngelSales\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"startStopICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethExchangeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startStop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vltMultisig\",\"type\":\"address\"}],\"name\":\"setVLTMultiSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getWithdrawableAmountAS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startLockingPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensPerEther\",\"type\":\"uint256\"}],\"name\":\"setTokensPerEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletPESales\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethExchangeWallet\",\"type\":\"address\"}],\"name\":\"setEthExchangeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"assignToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"releasedAngelSales\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"VLToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b48f11e238589fcd2787c4855fdd2c2c847f1624874fa7452fe9ec03eaff2d62"}]}