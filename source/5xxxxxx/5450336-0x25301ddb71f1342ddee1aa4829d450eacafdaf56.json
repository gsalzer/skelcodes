{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev The constructor sets the original owner of the contract to the sender account.\r\n   */\r\n  function Ownable() public {\r\n    setOwner(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets a new owner address\r\n   */\r\n  function setOwner(address newOwner) internal {\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    setOwner(newOwner);\r\n  }\r\n}\r\n\r\ncontract ERC820Registry {\r\n    function getManager(address addr) public view returns(address);\r\n    function setManager(address addr, address newManager) public;\r\n    function getInterfaceImplementer(address addr, bytes32 iHash) public constant returns (address);\r\n    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\r\n}\r\n\r\ncontract ERC820Implementer {\r\n    ERC820Registry erc820Registry = ERC820Registry(0x991a1bcb077599290d7305493c9A630c20f8b798);\r\n\r\n    function setInterfaceImplementation(string ifaceLabel, address impl) internal {\r\n        bytes32 ifaceHash = keccak256(ifaceLabel);\r\n        erc820Registry.setInterfaceImplementer(this, ifaceHash, impl);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string ifaceLabel) internal constant returns(address) {\r\n        bytes32 ifaceHash = keccak256(ifaceLabel);\r\n        return erc820Registry.getInterfaceImplementer(addr, ifaceHash);\r\n    }\r\n\r\n    function delegateManagement(address newManager) internal {\r\n        erc820Registry.setManager(this, newManager);\r\n    }\r\n}\r\n\r\ninterface ERC777TokensSender {\r\n    function tokensToSend(address operator, address from, address to, uint amount, bytes userData,bytes operatorData) external;\r\n}\r\n\r\n\r\ninterface ERC777TokensRecipient {\r\n    function tokensReceived(address operator, address from, address to, uint amount, bytes userData, bytes operatorData) external;\r\n}\r\n\r\ncontract JaroCoinToken is Ownable, ERC820Implementer {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"JaroCoin\";\r\n    string public constant symbol = \"JARO\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant granularity = 1e10;   // Token has 8 digits after comma\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => bool)) public isOperatorFor;\r\n    mapping (address => mapping (uint256 => bool)) private usedNonces;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes userData, bytes operatorData);\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes userData, bytes operatorData);\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    uint256 public totalSupply = 0;\r\n    uint256 public constant maxSupply = 21000000e18;\r\n\r\n\r\n    // ------- ERC777/ERC965 Implementation ----------\r\n\r\n    /**\r\n    * @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\r\n    * @param _to The address of the recipient\r\n    * @param _amount The number of tokens to be sent\r\n    * @param _userData Data generated by the user to be sent to the recipient\r\n    */\r\n    function send(address _to, uint256 _amount, bytes _userData) public {\r\n        doSend(msg.sender, _to, _amount, _userData, msg.sender, \"\", true);\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address via cheque\r\n    * @param _to The address to transfer to\r\n    * @param _amount The amount to be transferred\r\n    * @param _userData The data to be executed\r\n    * @param _nonce Unique nonce to avoid double spendings\r\n    */\r\n    function sendByCheque(address _to, uint256 _amount, bytes _userData, uint256 _nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n        require(_to != address(this));\r\n\r\n        // Check if signature is valid, get signer's address and mark this cheque as used.\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 hash = keccak256(prefix, keccak256(_to, _amount, _userData, _nonce));\r\n        // bytes32 hash = keccak256(_to, _amount, _userData, _nonce);\r\n\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require (signer != 0);\r\n        require (!usedNonces[signer][_nonce]);\r\n        usedNonces[signer][_nonce] = true;\r\n\r\n        // Transfer tokens\r\n        doSend(signer, _to, _amount, _userData, signer, \"\", true);\r\n    }\r\n\r\n    /**\r\n    * @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\r\n    * @param _operator The operator that wants to be Authorized\r\n    */\r\n    function authorizeOperator(address _operator) public {\r\n        require(_operator != msg.sender);\r\n        isOperatorFor[_operator][msg.sender] = true;\r\n        emit AuthorizedOperator(_operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\r\n    * @param _operator The operator that wants to be Revoked\r\n    */\r\n    function revokeOperator(address _operator) public {\r\n        require(_operator != msg.sender);\r\n        isOperatorFor[_operator][msg.sender] = false;\r\n        emit RevokedOperator(_operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\r\n    * @param _from The address holding the tokens being sent\r\n    * @param _to The address of the recipient\r\n    * @param _amount The number of tokens to be sent\r\n    * @param _userData Data generated by the user to be sent to the recipient\r\n    * @param _operatorData Data generated by the operator to be sent to the recipient\r\n    */\r\n    function operatorSend(address _from, address _to, uint256 _amount, bytes _userData, bytes _operatorData) public {\r\n        require(isOperatorFor[msg.sender][_from]);\r\n        doSend(_from, _to, _amount, _userData, msg.sender, _operatorData, true);\r\n    }\r\n\r\n    /* -- Helper Functions -- */\r\n    /**\r\n    * @notice Internal function that ensures `_amount` is multiple of the granularity\r\n    * @param _amount The quantity that want's to be checked\r\n    */\r\n    function requireMultiple(uint256 _amount) internal pure {\r\n        require(_amount.div(granularity).mul(granularity) == _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Check whether an address is a regular address or not.\r\n    * @param _addr Address of the contract that has to be checked\r\n    * @return `true` if `_addr` is a regular address (not a contract)\r\n    */\r\n    function isRegularAddress(address _addr) internal constant returns(bool) {\r\n        if (_addr == 0) { return false; }\r\n        uint size;\r\n        assembly { size := extcodesize(_addr) } // solhint-disable-line no-inline-assembly\r\n        return size == 0;\r\n    }\r\n\r\n    /**\r\n    * @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\r\n    *  May throw according to `_preventLocking`\r\n    * @param _from The address holding the tokens being sent\r\n    * @param _to The address of the recipient\r\n    * @param _amount The amount of tokens to be sent\r\n    * @param _userData Data generated by the user to be passed to the recipient\r\n    * @param _operatorData Data generated by the operator to be passed to the recipient\r\n    *  implementing `ERC777TokensSender`.\r\n    *  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    *  functions SHOULD set this parameter to `false`.\r\n    */\r\n    function callSender(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _userData,\r\n        bytes _operatorData\r\n    ) private {\r\n        address senderImplementation = interfaceAddr(_from, \"ERC777TokensSender\");\r\n        if (senderImplementation != 0) {\r\n            ERC777TokensSender(senderImplementation).tokensToSend(\r\n                _operator, _from, _to, _amount, _userData, _operatorData);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\r\n    *  May throw according to `_preventLocking`\r\n    * @param _from The address holding the tokens being sent\r\n    * @param _to The address of the recipient\r\n    * @param _amount The number of tokens to be sent\r\n    * @param _userData Data generated by the user to be passed to the recipient\r\n    * @param _operatorData Data generated by the operator to be passed to the recipient\r\n    * @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n    *  implementing `ERC777TokensRecipient`.\r\n    *  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    *  functions SHOULD set this parameter to `false`.\r\n    */\r\n    function callRecipient(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _userData,\r\n        bytes _operatorData,\r\n        bool _preventLocking\r\n    ) private {\r\n        address recipientImplementation = interfaceAddr(_to, \"ERC777TokensRecipient\");\r\n        if (recipientImplementation != 0) {\r\n            ERC777TokensRecipient(recipientImplementation).tokensReceived(\r\n                _operator, _from, _to, _amount, _userData, _operatorData);\r\n        } else if (_preventLocking) {\r\n            require(isRegularAddress(_to));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Helper function actually performing the sending of tokens.\r\n    * @param _from The address holding the tokens being sent\r\n    * @param _to The address of the recipient\r\n    * @param _amount The number of tokens to be sent\r\n    * @param _userData Data generated by the user to be passed to the recipient\r\n    * @param _operatorData Data generated by the operator to be passed to the recipient\r\n    * @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n    *  implementing `erc777_tokenHolder`.\r\n    *  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    *  functions SHOULD set this parameter to `false`.\r\n    */\r\n    function doSend(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _userData,\r\n        address _operator,\r\n        bytes _operatorData,\r\n        bool _preventLocking\r\n    )\r\n        private\r\n    {\r\n        requireMultiple(_amount);\r\n\r\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\r\n\r\n        require(_to != 0x0);                  // forbid sending to 0x0 (=burning)\r\n        require(balanceOf[_from] >= _amount); // ensure enough funds\r\n\r\n        balanceOf[_from] = balanceOf[_from].sub(_amount);\r\n        balanceOf[_to] = balanceOf[_to].add(_amount);\r\n\r\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\r\n\r\n        emit Sent(_operator, _from, _to, _amount, _userData, _operatorData);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    // ------- ERC20 Implementation ----------\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        doSend(msg.sender, _to, _value, \"\", msg.sender, \"\", false);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another. Technically this is not ERC20 transferFrom but more ERC777 operatorSend.\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(isOperatorFor[msg.sender][_from]);\r\n        doSend(_from, _to, _value, \"\", msg.sender, \"\", true);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n\r\n     * @dev Originally in ERC20 this function to check the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * Function was added purly for backward compatibility with ERC20. Use operator logic from ERC777 instead.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A returning uint256 balanceOf _spender if it's active operator and 0 if not.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        if (isOperatorFor[_spender][_owner]) {\r\n            return balanceOf[_owner];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend tokens on behalf of msg.sender.\r\n     *\r\n     * This function is more authorizeOperator and revokeOperator from ERC777 that Approve from ERC20.\r\n     * Approve concept has several issues (e.g. https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729),\r\n     * so I prefer to use operator concept. If you want to revoke approval, just put 0 into _value.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value Fake value to be compatible with ERC20 requirements.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_spender != msg.sender);\r\n\r\n        if (_value > 0) {\r\n            // Authorizing operator\r\n            isOperatorFor[_spender][msg.sender] = true;\r\n            emit AuthorizedOperator(_spender, msg.sender);\r\n        } else {\r\n            // Revoking operator\r\n            isOperatorFor[_spender][msg.sender] = false;\r\n            emit RevokedOperator(_spender, msg.sender);\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // ------- Minting and burning ----------\r\n\r\n    /**\r\n    * @dev Function to mint tokens\r\n    * @param _to The address that will receive the minted tokens.\r\n    * @param _amount The amount of tokens to mint.\r\n    * @param _operatorData Data that will be passed to the recipient as a first transfer.\r\n    */\r\n    function mint(address _to, uint256 _amount, bytes _operatorData) public onlyOwner {\r\n        require (totalSupply.add(_amount) <= maxSupply);\r\n        requireMultiple(_amount);\r\n\r\n        totalSupply = totalSupply.add(_amount);\r\n        balanceOf[_to] = balanceOf[_to].add(_amount);\r\n\r\n        callRecipient(msg.sender, 0x0, _to, _amount, \"\", _operatorData, true);\r\n\r\n        emit Minted(msg.sender, _to, _amount, _operatorData);\r\n        emit Transfer(0x0, _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to burn sender's tokens\r\n    * @param _amount The amount of tokens to burn.\r\n    * @return A boolean that indicates if the operation was successful.\r\n    */\r\n    function burn(uint256 _amount, bytes _userData) public {\r\n        require (_amount > 0);\r\n        require (balanceOf[msg.sender] >= _amount);\r\n        requireMultiple(_amount);\r\n\r\n        callSender(msg.sender, msg.sender, 0x0, _amount, _userData, \"\");\r\n\r\n        totalSupply = totalSupply.sub(_amount);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_amount);\r\n\r\n        emit Burned(msg.sender, msg.sender, _amount, _userData, \"\");\r\n        emit Transfer(msg.sender, 0x0, _amount);\r\n    }\r\n}\r\n\r\ncontract JaroSleep is ERC820Implementer, ERC777TokensRecipient {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public lastBurn;                         // Time of last sleep token burn\r\n    uint256 public dailyTime;                        // Tokens to burn per day\r\n    JaroCoinToken public token;\r\n\r\n    event ReceivedTokens(address operator, address from, address to, uint amount, bytes userData, bytes operatorData);\r\n\r\n    function JaroSleep(address _token, uint256 _dailyTime) public {\r\n        setInterfaceImplementation(\"ERC777TokensRecipient\", this);\r\n        token = JaroCoinToken(_token);\r\n        lastBurn = getNow();\r\n        dailyTime = _dailyTime;\r\n    }\r\n\r\n    // Reject any ethers send to this address\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    function burnTokens() public returns (uint256) {\r\n        uint256 sec = getNow().sub(lastBurn);\r\n        uint256 tokensToBurn = 0;\r\n\r\n        // // TODO convert into uint64 for saving gas purposes\r\n        if (sec >= 1 days) {\r\n            uint256 d =  sec.div(86400);\r\n            tokensToBurn = d.mul(dailyTime);\r\n            token.burn(tokensToBurn, \"\");\r\n            lastBurn = lastBurn.add(d.mul(86400));\r\n        }\r\n\r\n        return tokensToBurn;\r\n    }\r\n\r\n    // Function needed for automated testing purposes\r\n    function getNow() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    // ERC777 tokens receiver callback\r\n    function tokensReceived(address operator, address from, address to, uint amount, bytes userData, bytes operatorData) external {\r\n        emit ReceivedTokens(operator, from, to, amount, userData, operatorData);\r\n    }\r\n}\r\n\r\ncontract PersonalTime is Ownable, ERC820Implementer, ERC777TokensRecipient {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public lastBurn;                         // Time of last sleep token burn\r\n    uint256 public dailyTime;                        // Tokens to burn per day\r\n    uint256 public debt = 0;                         // Debt which will be not minted during next sale period\r\n    uint256 public protect = 0;                      // Tokens which were transfered in favor of future days\r\n    JaroCoinToken public token;\r\n\r\n    event ReceivedTokens(address operator, address from, address to, uint amount, bytes userData, bytes operatorData);\r\n\r\n    function PersonalTime(address _token, uint256 _dailyTime) public {\r\n        setInterfaceImplementation(\"ERC777TokensRecipient\", this);\r\n        token = JaroCoinToken(_token);\r\n        lastBurn = getNow();\r\n        dailyTime = _dailyTime;\r\n    }\r\n\r\n    // Reject any ethers send to this address\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    function burnTokens() public returns (uint256) {\r\n        uint256 sec = getNow().sub(lastBurn);\r\n        uint256 tokensToBurn = 0;\r\n\r\n        // // TODO convert into uint64 for saving gas purposes\r\n        if (sec >= 1 days) {\r\n            uint256 d =  sec.div(86400);\r\n            tokensToBurn = d.mul(dailyTime);\r\n\r\n            if (protect >= tokensToBurn) {\r\n                protect = protect.sub(tokensToBurn);\r\n            } else {\r\n                token.burn(tokensToBurn.sub(protect), \"\");\r\n                protect = 0;\r\n            }\r\n\r\n            lastBurn = lastBurn.add(d.mul(86400));\r\n        }\r\n\r\n        return tokensToBurn;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) public onlyOwner {\r\n        protect = protect.add(_amount);\r\n        debt = debt.add(_amount);\r\n        token.transfer(_to, _amount);\r\n    }\r\n\r\n    // Function needed for automated testing purposes\r\n    function getNow() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    // ERC777 tokens receiver callback\r\n    function tokensReceived(address operator, address from, address to, uint amount, bytes userData, bytes operatorData) external {\r\n        require(msg.sender == address(token));\r\n        debt = (debt >= amount ? debt.sub(amount) : 0);\r\n        emit ReceivedTokens(operator, from, to, amount, userData, operatorData);\r\n    }\r\n}\r\n\r\n\r\ncontract JaroCoinCrowdsale is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public constant WALLET = 0xefF42c79c0aBea9958432DC82FebC4d65f3d24A3;\r\n\r\n    // Max tokens which can be in circulation\r\n    uint256 public constant MAX_AMOUNT = 21000000e18; // 21 000 000\r\n\r\n    // Amount of raised funds in satoshi\r\n    uint256 public satoshiRaised;\r\n\r\n    uint256 public rate;                              // number of tokens buyer gets per satoshi\r\n    uint256 public conversionRate;                    // wei per satoshi - per ETH => 0.056 ETH/BTC ? wei per satoshi?\r\n\r\n    JaroCoinToken public token;\r\n    JaroSleep public sleepContract;\r\n    PersonalTime public familyContract;\r\n    PersonalTime public personalContract;\r\n\r\n    uint256 public tokensToMint;                      // Amount of tokens left to mint in this sale\r\n    uint256 public saleStartTime;                     // Start time of recent token sale\r\n\r\n    // Indicator of token sale activity.\r\n    bool public isActive = false;\r\n    bool internal initialized = false;\r\n\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n    event SaleActivated(uint256 startTime, uint256 amount);\r\n    event SaleClosed();\r\n\r\n    modifier canMint() {\r\n        require (isActive);\r\n        require (getNow() > saleStartTime);\r\n        _;\r\n    }\r\n\r\n    function initialize(address _owner, address _token, address _familyOwner, address _personalOwner) public {\r\n        require (!initialized);\r\n\r\n        token = JaroCoinToken(_token);\r\n\r\n        sleepContract = createJaroSleep(_token, 34560e18);       // 9.6 hours per day\r\n        familyContract = createPersonalTime(_token, 21600e18);   // 6 hours per day\r\n        personalContract = createPersonalTime(_token, 12960e18); // 3.6 hours per day\r\n\r\n        familyContract.transferOwnership(_familyOwner);\r\n        personalContract.transferOwnership(_personalOwner);\r\n\r\n        rate = 100000e10;\r\n        conversionRate = 17e10;\r\n        satoshiRaised = 0;\r\n\r\n        setOwner(_owner);\r\n        initialized = true;\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function () external canMint payable {\r\n        _buyTokens(msg.sender, msg.value, 0);\r\n    }\r\n\r\n    function coupon(uint256 _timeStamp, uint8 _bonus, uint8 v, bytes32 r, bytes32 s) external canMint payable {\r\n        require(_timeStamp >= getNow());\r\n\r\n        // Check if signature is valid, get signer's address and mark this cheque as used.\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 hash = keccak256(prefix, keccak256(_timeStamp, _bonus));\r\n\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer == owner);\r\n\r\n        _buyTokens(msg.sender, msg.value, _bonus);\r\n    }\r\n\r\n    function buyTokens(address _beneficiary) public canMint payable {\r\n        _buyTokens(_beneficiary, msg.value, 0);\r\n    }\r\n\r\n    function _buyTokens(address _beneficiary, uint256 _value, uint8 _bonus) internal {\r\n        require (_beneficiary != address(0));\r\n        require (_value > 0);\r\n\r\n        uint256 weiAmount = _value;\r\n        uint256 satoshiAmount = weiAmount.div(conversionRate);\r\n        uint256 tokens = satoshiAmount.mul(rate).mul(100+_bonus).div(100);\r\n\r\n        // Mint tokens and refund not used ethers in case when max amount reached during this minting\r\n        uint256 excess = appendContribution(_beneficiary, tokens);\r\n        uint256 refund = (excess > 0 ? excess.mul(100).div(100+_bonus).mul(conversionRate).div(rate) : 0);\r\n        weiAmount = weiAmount.sub(refund);\r\n        satoshiRaised = satoshiRaised.add(satoshiAmount);\r\n\r\n        // if hard cap reached, no more tokens to mint, refund sender not used ethers\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n\r\n        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens.sub(excess));\r\n\r\n        // Send ethers into WALLET\r\n        WALLET.transfer(weiAmount);\r\n    }\r\n\r\n    function appendContribution(address _beneficiary, uint256 _tokens) internal returns (uint256) {\r\n        if (_tokens >= tokensToMint) {\r\n            mint(_beneficiary, tokensToMint);\r\n            uint256 excededTokens = _tokens.sub(tokensToMint);\r\n            _closeSale(); // Last tokens minted, lets close token sale\r\n            return excededTokens;\r\n        }\r\n\r\n        tokensToMint = tokensToMint.sub(_tokens);\r\n        mint(_beneficiary, _tokens);\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Owner can start new token sale, to mint missing tokens by using this function,\r\n     * but not more often than once per month.\r\n     * @param _startTime start time for new token sale.\r\n    */\r\n    function startSale(uint256 _startTime) public onlyOwner {\r\n        require (!isActive);\r\n        require (_startTime > getNow());\r\n        require (saleStartTime == 0 || _startTime.sub(saleStartTime) > 30 days);   // Minimum one month between token sales\r\n\r\n        // Burn unburned sleep, family and personal time.\r\n        sleepContract.burnTokens();\r\n        uint256 sleepTokens = token.balanceOf(address(sleepContract));\r\n\r\n        familyContract.burnTokens();\r\n        uint256 familyTokens = token.balanceOf(familyContract).add(familyContract.debt());\r\n\r\n        personalContract.burnTokens();\r\n        uint256 personalTokens = token.balanceOf(personalContract).add(personalContract.debt());\r\n\r\n        uint256 missingSleep = MAX_AMOUNT.div(100).mul(40).sub(sleepTokens);       // sleep and stuff takes 40% of Jaro time\r\n        uint256 missingFamily = MAX_AMOUNT.div(100).mul(25).sub(familyTokens);     // 25% for family\r\n        uint256 missingPersonal = MAX_AMOUNT.div(100).mul(15).sub(personalTokens); // 15% is Jaro personal time\r\n\r\n        mint(address(sleepContract), missingSleep);\r\n        mint(address(familyContract), missingFamily);\r\n        mint(address(personalContract), missingPersonal);\r\n\r\n        tokensToMint = MAX_AMOUNT.sub(token.totalSupply());\r\n        saleStartTime = _startTime;\r\n        isActive = true;\r\n        emit SaleActivated(_startTime, tokensToMint);\r\n    }\r\n\r\n    function _closeSale() internal {\r\n        tokensToMint = 0;\r\n        isActive = false;\r\n        emit SaleClosed();\r\n    }\r\n\r\n    function closeSale() public onlyOwner {\r\n        _closeSale();\r\n    }\r\n\r\n    function updateConvertionRate(uint256 _rate) public onlyOwner {\r\n        require (_rate > 0);\r\n        uint256 one = 1e18;\r\n        conversionRate = one.div(_rate);\r\n    }\r\n\r\n    function mint(address _beneficiary, uint256 _amount) internal {\r\n        if (_amount > 0) {\r\n            token.mint(_beneficiary, _amount, \"\");\r\n        }\r\n    }\r\n\r\n    // This function created for easier testing purposes\r\n    function createJaroSleep(address _token, uint256 _dailyTime) internal returns (JaroSleep) {\r\n        return new JaroSleep(_token, _dailyTime);\r\n    }\r\n\r\n    function createPersonalTime(address _token, uint256 _dailyTime) internal returns (PersonalTime) {\r\n        return new PersonalTime(_token, _dailyTime);\r\n    }\r\n\r\n    // This function created for easier testing purposes\r\n    function getNow() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"startSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"satoshiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateConvertionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timeStamp\",\"type\":\"uint256\"},{\"name\":\"_bonus\",\"type\":\"uint8\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"coupon\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sleepContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"personalContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensToMint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"familyContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_familyOwner\",\"type\":\"address\"},{\"name\":\"_personalOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SaleActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"JaroCoinCrowdsale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://543045a4f3bcc6ecff5eacb4f9d727a941eddc673244dc62ac560812b08442f1"}]}