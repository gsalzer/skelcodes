{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract VanityLib {\r\n    uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\r\n\r\n    function lengthOfCommonPrefix(bytes a, bytes b) public pure returns(uint) {\r\n        uint len = (a.length <= b.length) ? a.length : b.length;\r\n        for (uint i = 0; i < len; i++) {\r\n            if (a[i] != b[i]) {\r\n                return i;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    \r\n    function lengthOfCommonPrefix32(bytes32 a, bytes b) public pure returns(uint) {\r\n        for (uint i = 0; i < b.length; i++) {\r\n            if (a[i] != b[i]) {\r\n                return i;\r\n            }\r\n        }\r\n        return b.length;\r\n    }\r\n\r\n    function lengthOfCommonPrefix3232(bytes32 a, bytes32 b) public pure returns(uint) {\r\n        for (uint i = 0; i < 32; i++) {\r\n            if (a[i] != b[i] || a[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    function equalBytesToBytes(bytes a, bytes b) public pure returns (bool) {\r\n        if (a.length != b.length) {\r\n            return false;\r\n        }\r\n        for (uint i = 0; i < a.length; i++) {\r\n            if (a[i] != b[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function equalBytes32ToBytes(bytes32 a, bytes b) public pure returns (bool) {\r\n        for (uint i = 0; i < b.length; i++) {\r\n            if (a[i] != b[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function bytesToBytes32(bytes source) public pure returns(bytes32 result) {\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    /* Converts given number to base58, limited by 32 symbols */\r\n    function toBase58Checked(uint256 _value, byte appCode) public pure returns(bytes32) {\r\n        string memory letters = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\r\n        bytes memory alphabet = bytes(letters);\r\n        uint8 base = 58;\r\n        uint8 len = 0;\r\n        uint256 remainder = 0;\r\n        bool needBreak = false;\r\n        bytes memory bytesReversed = bytes(new string(32));\r\n        \r\n        for (uint8 i = 0; true; i++) {\r\n            if (_value < base) {\r\n                needBreak = true;\r\n            }\r\n            remainder = _value % base;\r\n            _value = uint256(_value / base);\r\n            if (len == 32) {\r\n                for (uint j = 0; j < len - 1; j++) {\r\n                    bytesReversed[j] = bytesReversed[j + 1];\r\n                }\r\n                len--;\r\n            }\r\n            bytesReversed[len] = alphabet[remainder];\r\n            len++;\r\n            if (needBreak) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Reverse\r\n        bytes memory result = bytes(new string(32));\r\n        result[0] = appCode;\r\n        for (i = 0; i < 31; i++) {\r\n            result[i + 1] = bytesReversed[len - 1 - i];\r\n        }\r\n        \r\n        return bytesToBytes32(result);\r\n    }\r\n\r\n    // Create BTC Address: https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address\r\n    function createBtcAddressHex(uint256 publicXPoint, uint256 publicYPoint) public pure returns(uint256) {\r\n        bytes20 publicKeyPart = ripemd160(sha256(byte(0x04), publicXPoint, publicYPoint));\r\n        bytes32 publicKeyCheckCode = sha256(sha256(byte(0x00), publicKeyPart));\r\n        \r\n        bytes memory publicKey = new bytes(32);\r\n        for (uint i = 0; i < 7; i++) {\r\n            publicKey[i] = 0x00;\r\n        }\r\n        publicKey[7] = 0x00; // Main Network\r\n        for (uint j = 0; j < 20; j++) {\r\n            publicKey[j + 8] = publicKeyPart[j];\r\n        }\r\n        publicKey[28] = publicKeyCheckCode[0];\r\n        publicKey[29] = publicKeyCheckCode[1];\r\n        publicKey[30] = publicKeyCheckCode[2];\r\n        publicKey[31] = publicKeyCheckCode[3];\r\n        \r\n        return uint256(bytesToBytes32(publicKey));\r\n    }\r\n    \r\n    function createBtcAddress(uint256 publicXPoint, uint256 publicYPoint) public pure returns(bytes32) {\r\n        return toBase58Checked(createBtcAddressHex(publicXPoint, publicYPoint), \"1\");\r\n    }\r\n\r\n    // https://github.com/stonecoldpat/anonymousvoting/blob/master/LocalCrypto.sol\r\n    function invmod(uint256 a, uint256 p) public pure returns (uint256) {\r\n        int t1 = 0;\r\n        int t2 = 1;\r\n        uint r1 = p;\r\n        uint r2 = a;\r\n        uint q;\r\n        while (r2 != 0) {\r\n            q = r1 / r2;\r\n            (t1, t2, r1, r2) = (t2, t1 - int(q) * t2, r2, r1 - q * r2);\r\n        }\r\n\r\n        return t1 < 0 ? p - uint(-t1) : uint(t1);\r\n    }\r\n    \r\n    // https://github.com/stonecoldpat/anonymousvoting/blob/master/LocalCrypto.sol\r\n    function submod(uint a, uint b, uint p) public pure returns (uint) {\r\n        return addmod(a, p - b, p);\r\n    }\r\n\r\n    // https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_addition\r\n    // https://github.com/bellaj/Blockchain/blob/6bffb47afae6a2a70903a26d215484cf8ff03859/ecdsa_bitcoin.pdf\r\n    // https://math.stackexchange.com/questions/2198139/elliptic-curve-formulas-for-point-addition\r\n    function addXY(uint x1, uint y1, uint x2, uint y2) public pure returns(uint x3, uint y3) {\r\n        uint anti = invmod(submod(x1, x2, m), m);\r\n        uint alpha = mulmod(submod(y1, y2, m), anti, m);\r\n        x3 = submod(submod(mulmod(alpha, alpha, m), x1, m), x2, m);\r\n        y3 = submod(mulmod(alpha, submod(x2, x3, m), m), y2, m);\r\n        \r\n        // x3 = bytes32(mul_mod(uint(x3), uint(y3), m)); == 1!!!!\r\n        \r\n        // https://github.com/jbaylina/ecsol/blob/master/ec.sol\r\n        // x3 = addmod(mulmod(y2, x1, m), mulmod(x2, y1, m), m);\r\n        // y3 = mulmod(y1, y2, m);\r\n    }\r\n\r\n    function doubleXY(uint x1, uint y1) public pure returns(uint x2, uint y2) {\r\n        uint anti = invmod(addmod(y1, y1, m), m);\r\n        uint alpha = mulmod(addmod(addmod(mulmod(x1, x1, m), mulmod(x1, x1, m), m), mulmod(x1, x1, m), m), anti, m);\r\n        x2 = submod(mulmod(alpha, alpha, m), addmod(x1, x1, m), m);\r\n        y2 = submod(mulmod(alpha, submod(x1, x2, m), m), y1, m);\r\n    }\r\n\r\n    function mulXY(uint x1, uint y1, uint privateKey) public pure returns(uint x2, uint y2) {\r\n        bool addition = false;\r\n        for (uint i = 0; i < 256; i++) {\r\n            if (((privateKey >> i) & 1) == 1) {\r\n                if (addition) {\r\n                    (x2, y2) = addXY(x1, y1, x2, y2);\r\n                } else {\r\n                    (x2, y2) = (x1, y1);\r\n                    addition = true;\r\n                }\r\n            }\r\n            (x1,y1) = doubleXY(x1, y1);\r\n        }\r\n    }\r\n\r\n    function bitcoinPublicKey(uint256 privateKey) public pure returns(uint, uint) {\r\n        uint256 gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798;\r\n        uint256 gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8;\r\n        return mulXY(gx, gy, privateKey);\r\n    }\r\n\r\n    function complexityForBtcAddressPrefix(bytes prefix) public pure returns(uint) {\r\n        return complexityForBtcAddressPrefixWithLength(prefix, prefix.length);\r\n    }\r\n\r\n    // https://bitcoin.stackexchange.com/questions/48586\r\n    function complexityForBtcAddressPrefixWithLength(bytes prefix, uint length) public pure returns(uint) {\r\n        require(prefix.length >= length);\r\n        \r\n        uint8[128] memory unbase58 = [\r\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \r\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \r\n            255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 255, 255, 255, 255, 255, 255, \r\n            255, 9, 10, 11, 12, 13, 14, 15, 16, 255, 17, 18, 19, 20, 21, 255, \r\n            22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 255, 255, 255, 255, 255,\r\n            255, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 255, 44, 45, 46,\r\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 255, 255, 255, 255, 255\r\n        ];\r\n\r\n        uint leadingOnes = countBtcAddressLeadingOnes(prefix, length);\r\n\r\n        uint256 prefixValue = 0;\r\n        uint256 prefix1 = 1;\r\n        for (uint i = 0; i < length; i++) {\r\n            uint index = uint(prefix[i]);\r\n            require(index != 255);\r\n            prefixValue = prefixValue * 58 + unbase58[index];\r\n            prefix1 *= 58;\r\n        }\r\n\r\n        uint256 top = (uint256(1) << (200 - 8*leadingOnes));\r\n        uint256 total = 0;\r\n        uint256 prefixMin = prefixValue;\r\n        uint256 diff = 0;\r\n        for (uint digits = 1; prefix1/58 < (1 << 192); digits++) {\r\n            prefix1 *= 58;\r\n            prefixMin *= 58;\r\n            prefixValue = prefixValue * 58 + 57;\r\n\r\n            diff = 0;\r\n            if (prefixValue >= top) {\r\n                diff += prefixValue - top;\r\n            }\r\n            if (prefixMin < (top >> 8)) {\r\n                diff += (top >> 8) - prefixMin;\r\n            }\r\n            \r\n            if ((58 ** digits) >= diff) {\r\n                total += (58 ** digits) - diff;\r\n            }\r\n        }\r\n\r\n        if (prefixMin == 0) { // if prefix is contains only ones: 111111\r\n            total = (58 ** (digits - 1)) - diff;\r\n        }\r\n\r\n        return (1 << 192) / total;\r\n    }\r\n\r\n    function countBtcAddressLeadingOnes(bytes prefix, uint length) public pure returns(uint) {\r\n        uint leadingOnes = 1;\r\n        for (uint j = 0; j < length && prefix[j] == 49; j++) {\r\n            leadingOnes = j + 1;\r\n        }\r\n        return leadingOnes;\r\n    }\r\n\r\n    function isValidBicoinAddressPrefix(bytes prefixArg) public pure returns(bool) {\r\n        if (prefixArg.length < 5) {\r\n            return false;\r\n        }\r\n        if (prefixArg[0] != \"1\" && prefixArg[0] != \"3\") {\r\n            return false;\r\n        }\r\n        \r\n        for (uint i = 0; i < prefixArg.length; i++) {\r\n            byte ch = prefixArg[i];\r\n            if (ch == \"0\" || ch == \"O\" || ch == \"I\" || ch == \"l\") {\r\n                return false;\r\n            }\r\n            if (!((ch >= \"1\" && ch <= \"9\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\"))) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isValidPublicKey(uint256 x, uint256 y) public pure returns(bool) {\r\n        return (mulmod(y, y, m) == addmod(mulmod(x, mulmod(x, x, m), m), 7, m));\r\n    }\r\n\r\n}\r\n\r\ncontract IUpgradable {\r\n\r\n    function startUpgrade() public;\r\n    function endUpgrade() public;\r\n\r\n}\r\n\r\ncontract Upgradable is Ownable {\r\n\r\n    struct UpgradableState {\r\n        bool isUpgrading;\r\n        address prevVersion;\r\n        address nextVersion;\r\n    }\r\n\r\n    UpgradableState public upgradableState;\r\n\r\n    event Initialized(address indexed prevVersion);\r\n    event Upgrading(address indexed nextVersion);\r\n    event Upgraded(address indexed nextVersion);\r\n\r\n    modifier isLastestVersion {\r\n        require(!upgradableState.isUpgrading);\r\n        require(upgradableState.nextVersion == address(0));\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrigin {\r\n        require(tx.origin == owner);\r\n        _;\r\n    }\r\n\r\n    function Upgradable(address _prevVersion) public {\r\n        if (_prevVersion != address(0)) {\r\n            require(msg.sender == Ownable(_prevVersion).owner());\r\n            upgradableState.isUpgrading = true;\r\n            upgradableState.prevVersion = _prevVersion;\r\n            IUpgradable(_prevVersion).startUpgrade();\r\n        } else {\r\n            Initialized(_prevVersion);\r\n        }\r\n    }\r\n\r\n    function startUpgrade() public onlyOwnerOrigin {\r\n        require(msg.sender != owner);\r\n        require(!upgradableState.isUpgrading);\r\n        require(upgradableState.nextVersion == 0);\r\n        upgradableState.isUpgrading = true;\r\n        upgradableState.nextVersion = msg.sender;\r\n        Upgrading(msg.sender);\r\n    }\r\n\r\n    //function upgrade(uint index, uint size) public onlyOwner {}\r\n\r\n    function endUpgrade() public onlyOwnerOrigin {\r\n        require(upgradableState.isUpgrading);\r\n        upgradableState.isUpgrading = false;\r\n        if (msg.sender != owner) {\r\n            require(upgradableState.nextVersion == msg.sender);\r\n            Upgraded(upgradableState.nextVersion);\r\n        } \r\n        else  {\r\n            if (upgradableState.prevVersion != address(0)) {\r\n                Upgradable(upgradableState.prevVersion).endUpgrade();\r\n            }\r\n            Initialized(upgradableState.prevVersion);\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract IEC {\r\n\r\n    function _inverse(uint256 a) public constant \r\n        returns(uint256 invA);\r\n\r\n    function _ecAdd(uint256 x1,uint256 y1,uint256 z1,\r\n                    uint256 x2,uint256 y2,uint256 z2) public constant\r\n        returns(uint256 x3,uint256 y3,uint256 z3);\r\n\r\n    function _ecDouble(uint256 x1,uint256 y1,uint256 z1) public constant\r\n        returns(uint256 x3,uint256 y3,uint256 z3);\r\n\r\n    function _ecMul(uint256 d, uint256 x1,uint256 y1,uint256 z1) public constant\r\n        returns(uint256 x3,uint256 y3,uint256 z3);\r\n\r\n    function publicKey(uint256 privKey) public constant\r\n        returns(uint256 qx, uint256 qy);\r\n\r\n    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public constant\r\n        returns(uint256 qx, uint256 qy);\r\n\r\n}\r\n\r\ncontract TaskRegister is Upgradable, VanityLib {\r\n\r\n    enum TaskType {\r\n        BITCOIN_ADDRESS_PREFIX\r\n    }\r\n\r\n    struct Task {\r\n        TaskType taskType;\r\n        uint256 taskId;\r\n        address creator;\r\n        uint256 reward;\r\n        bytes32 data;\r\n        uint256 dataLength;\r\n        uint256 requestPublicXPoint;\r\n        uint256 requestPublicYPoint;\r\n        uint256 answerPrivateKey;\r\n    }\r\n\r\n    IEC public ec;\r\n    ERC20 public token;\r\n    uint256 public nextTaskId = 1;\r\n    uint256 public totalReward;\r\n    \r\n    Task[] public tasks;\r\n    Task[] public completedTasks;\r\n    mapping(uint256 => uint) public indexOfTaskId; // Starting from 1\r\n    event TaskCreated(uint256 indexed taskId);\r\n    event TaskSolved(uint256 indexed taskId);\r\n    event TaskPayed(uint256 indexed taskId);\r\n\r\n    function TaskRegister(address _ec, address _token, address _prevVersion) public Upgradable(_prevVersion) {\r\n        ec = IEC(_ec);\r\n        token = ERC20(_token);\r\n    }\r\n\r\n    function upgrade(uint size) public onlyOwner {\r\n        require(upgradableState.isUpgrading);\r\n        require(upgradableState.prevVersion != 0);\r\n\r\n        // Migrate some vars\r\n        nextTaskId = TaskRegister(upgradableState.prevVersion).nextTaskId();\r\n        totalReward = TaskRegister(upgradableState.prevVersion).totalReward();\r\n\r\n        uint index = tasks.length;\r\n        uint tasksCount = TaskRegister(upgradableState.prevVersion).tasksCount();\r\n\r\n        // Migrate tasks\r\n\r\n        for (uint i = index; i < index + size && i < tasksCount; i++) {\r\n            tasks.push(Task(TaskType.BITCOIN_ADDRESS_PREFIX,0,0,0,bytes32(0),0,0,0,0));\r\n        }\r\n\r\n        for (uint j = index; j < index + size && j < tasksCount; j++) {\r\n            (\r\n                tasks[j].taskType,\r\n                tasks[j].taskId,\r\n                tasks[j].creator,\r\n                tasks[j].reward,\r\n                tasks[j].data,\r\n                ,//tasks[j].dataLength, \r\n                ,//tasks[j].requestPublicXPoint, \r\n                ,//tasks[j].requestPublicYPoint,\r\n                 //tasks[j].answerPrivateKey\r\n            ) = TaskRegister(upgradableState.prevVersion).tasks(j);\r\n            indexOfTaskId[tasks[j].taskId] = j + 1;\r\n        }\r\n\r\n        for (uint k = index; k < index + size && k < tasksCount; k++) {\r\n            (\r\n                ,//tasks[k].taskType,\r\n                ,//tasks[k].taskId,\r\n                ,//tasks[k].creator,\r\n                ,//tasks[k].reward,\r\n                ,//tasks[k].data,\r\n                tasks[k].dataLength, \r\n                tasks[k].requestPublicXPoint, \r\n                tasks[k].requestPublicYPoint,\r\n                tasks[k].answerPrivateKey\r\n            ) = TaskRegister(upgradableState.prevVersion).tasks(k);\r\n        }\r\n    }\r\n    \r\n    function endUpgrade() public {\r\n        super.endUpgrade();\r\n        \r\n        if (upgradableState.nextVersion != 0) {\r\n            token.transfer(upgradableState.nextVersion, token.balanceOf(this));\r\n        }\r\n    }\r\n\r\n    function tasksCount() public constant returns(uint) {\r\n        return tasks.length;\r\n    }\r\n\r\n    function completedTasksCount() public constant returns(uint) {\r\n        return completedTasks.length;\r\n    }\r\n\r\n    function payForTask(uint256 taskId, uint256 reward) public isLastestVersion {\r\n        require(reward > 0);\r\n        uint index = safeIndexOfTaskId(taskId);\r\n        token.transferFrom(tx.origin, this, reward);\r\n        tasks[index].reward += reward;\r\n        totalReward += reward;\r\n        TaskPayed(taskId);\r\n    }\r\n\r\n    function safeIndexOfTaskId(uint taskId) public constant returns(uint) {\r\n        uint index = indexOfTaskId[taskId];\r\n        require(index > 0);\r\n        return index - 1;\r\n    }\r\n    \r\n    function createBitcoinAddressPrefixTask(bytes prefix, uint256 reward, uint256 requestPublicXPoint, uint256 requestPublicYPoint) public isLastestVersion {\r\n        require(prefix.length > 5);\r\n        require(prefix[0] == \"1\");\r\n        require(prefix[1] != \"1\"); // Do not support multiple 1s yet\r\n        require(isValidBicoinAddressPrefix(prefix));\r\n        require(isValidPublicKey(requestPublicXPoint, requestPublicYPoint));\r\n        if (reward > 0) {\r\n            token.transferFrom(tx.origin, this, reward);\r\n        }\r\n\r\n        bytes32 data;\r\n        assembly {\r\n            data := mload(add(prefix, 32))\r\n        }\r\n        \r\n        Task memory task = Task({\r\n            taskType: TaskType.BITCOIN_ADDRESS_PREFIX,\r\n            taskId: nextTaskId,\r\n            creator: tx.origin,\r\n            reward: reward,\r\n            data: data,\r\n            dataLength: prefix.length,\r\n            requestPublicXPoint: requestPublicXPoint,\r\n            requestPublicYPoint: requestPublicYPoint,\r\n            answerPrivateKey: 0\r\n        });\r\n        tasks.push(task);\r\n        indexOfTaskId[nextTaskId] = tasks.length; // incremented to avoid 0 index\r\n        TaskCreated(nextTaskId);\r\n        nextTaskId++;\r\n    }\r\n    \r\n    function solveTask(uint taskId, uint256 answerPrivateKey) public isLastestVersion {\r\n        uint taskIndex = safeIndexOfTaskId(taskId);\r\n        Task storage task = tasks[taskIndex];\r\n\r\n        // Require private key to be part of address to prevent front-running attack\r\n        bytes32 answerPrivateKeyBytes = bytes32(answerPrivateKey);\r\n        bytes32 senderAddressBytes = bytes32(uint256(msg.sender) << 96);\r\n        for (uint i = 0; i < 16; i++) {\r\n            require(answerPrivateKeyBytes[i] == senderAddressBytes[i]);\r\n        }\r\n\r\n        if (task.taskType == TaskType.BITCOIN_ADDRESS_PREFIX) {\r\n            uint256 answerPublicXPoint;\r\n            uint256 answerPublicYPoint;\r\n            uint256 publicXPoint;\r\n            uint256 publicYPoint;\r\n            uint256 z;\r\n            (answerPublicXPoint, answerPublicYPoint) = ec.publicKey(answerPrivateKey);\r\n            (publicXPoint, publicYPoint, z) = ec._ecAdd(\r\n                task.requestPublicXPoint,\r\n                task.requestPublicYPoint,\r\n                1,\r\n                answerPublicXPoint,\r\n                answerPublicYPoint,\r\n                1\r\n            );\r\n\r\n            uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\r\n            z = ec._inverse(z);\r\n            publicXPoint = mulmod(publicXPoint, z, m);\r\n            publicYPoint = mulmod(publicYPoint, z, m);\r\n            require(isValidPublicKey(publicXPoint, publicYPoint));\r\n            \r\n            bytes32 btcAddress = createBtcAddress(publicXPoint, publicYPoint);\r\n            uint prefixLength = lengthOfCommonPrefix3232(btcAddress, task.data);\r\n            require(prefixLength == task.dataLength);\r\n            \r\n            task.answerPrivateKey = answerPrivateKey;\r\n        }\r\n\r\n        token.transfer(msg.sender, task.reward);\r\n        totalReward -= task.reward;\r\n\r\n        completeTask(taskId, taskIndex);\r\n        TaskSolved(taskId);\r\n    }\r\n\r\n    function completeTask(uint taskId, uint index) internal {\r\n        completedTasks.push(tasks[index]);\r\n        if (index < tasks.length - 1) { // if not latest\r\n            tasks[index] = tasks[tasks.length - 1];\r\n            indexOfTaskId[tasks[index].taskId] = index + 1;\r\n        }\r\n        tasks.length -= 1;\r\n        delete indexOfTaskId[taskId];\r\n    }\r\n\r\n    function recoverLost(ERC20Basic _token, address loser) public onlyOwner {\r\n        uint256 amount = _token.balanceOf(this);\r\n        if (_token == token) {\r\n            amount -= totalReward;\r\n        }\r\n        _token.transfer(loser, _token.balanceOf(this));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"privateKey\",\"type\":\"uint256\"}],\"name\":\"bitcoinPublicKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"invmod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prefixArg\",\"type\":\"bytes\"}],\"name\":\"isValidBicoinAddressPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"bytes\"},{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"equalBytesToBytes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"publicXPoint\",\"type\":\"uint256\"},{\"name\":\"publicYPoint\",\"type\":\"uint256\"}],\"name\":\"createBtcAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"appCode\",\"type\":\"bytes1\"}],\"name\":\"toBase58Checked\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"complexityForBtcAddressPrefixWithLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"isValidPublicKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"},{\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"submod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"completedTasks\",\"outputs\":[{\"name\":\"taskType\",\"type\":\"uint8\"},{\"name\":\"taskId\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"dataLength\",\"type\":\"uint256\"},{\"name\":\"requestPublicXPoint\",\"type\":\"uint256\"},{\"name\":\"requestPublicYPoint\",\"type\":\"uint256\"},{\"name\":\"answerPrivateKey\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskId\",\"type\":\"uint256\"},{\"name\":\"answerPrivateKey\",\"type\":\"uint256\"}],\"name\":\"solveTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"}],\"name\":\"complexityForBtcAddressPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"taskId\",\"type\":\"uint256\"}],\"name\":\"safeIndexOfTaskId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"bytes\"},{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"lengthOfCommonPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"completedTasksCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskId\",\"type\":\"uint256\"},{\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"payForTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"countBtcAddressLeadingOnes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tasks\",\"outputs\":[{\"name\":\"taskType\",\"type\":\"uint8\"},{\"name\":\"taskId\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"dataLength\",\"type\":\"uint256\"},{\"name\":\"requestPublicXPoint\",\"type\":\"uint256\"},{\"name\":\"requestPublicYPoint\",\"type\":\"uint256\"},{\"name\":\"answerPrivateKey\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradableState\",\"outputs\":[{\"name\":\"isUpgrading\",\"type\":\"bool\"},{\"name\":\"prevVersion\",\"type\":\"address\"},{\"name\":\"nextVersion\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"recoverLost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tasksCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"bytes\"}],\"name\":\"bytesToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"publicXPoint\",\"type\":\"uint256\"},{\"name\":\"publicYPoint\",\"type\":\"uint256\"}],\"name\":\"createBtcAddressHex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"}],\"name\":\"addXY\",\"outputs\":[{\"name\":\"x3\",\"type\":\"uint256\"},{\"name\":\"y3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"privateKey\",\"type\":\"uint256\"}],\"name\":\"mulXY\",\"outputs\":[{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"bytes32\"},{\"name\":\"b\",\"type\":\"bytes32\"}],\"name\":\"lengthOfCommonPrefix3232\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexOfTaskId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"requestPublicXPoint\",\"type\":\"uint256\"},{\"name\":\"requestPublicYPoint\",\"type\":\"uint256\"}],\"name\":\"createBitcoinAddressPrefixTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"}],\"name\":\"doubleXY\",\"outputs\":[{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"bytes32\"},{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"lengthOfCommonPrefix32\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"bytes32\"},{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"equalBytes32ToBytes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ec\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextTaskId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ec\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_prevVersion\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskId\",\"type\":\"uint256\"}],\"name\":\"TaskCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskId\",\"type\":\"uint256\"}],\"name\":\"TaskSolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskId\",\"type\":\"uint256\"}],\"name\":\"TaskPayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prevVersion\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nextVersion\",\"type\":\"address\"}],\"name\":\"Upgrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nextVersion\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TaskRegister","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000005aae78c0de67642c728504dc9d264ecb9bb3120000000000000000000000007777777c85eb309d937bddc80d74eeae7205503a0000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://02659557fdc9a27cd17895c447bf1de8cee8b6aa0bef1f0427a804d375c13b58"}]}