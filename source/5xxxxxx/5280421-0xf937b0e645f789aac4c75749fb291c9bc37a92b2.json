{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// BlackBox2.0 - Secure Ether & Token Storage\r\n// Rinkeby test contract: 0x21ED89693fF7e91c757DbDD9Aa30448415aa8156\r\n\r\n// token interface\r\ncontract Token {\r\n    function balanceOf(address _owner) constant public returns (uint balance);\r\n    function allowance(address _user, address _spender) constant public returns (uint amount);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n}\r\n\r\n// owned by contract creator\r\ncontract Owned {\r\n    address public owner = msg.sender;\r\n    bool public restricted = true;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    // restrict external contract calls\r\n    modifier onlyCompliant {\r\n        if (restricted) require(tx.origin == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function changeRestrictions() public onlyOwner {\r\n        restricted = !restricted;\r\n    }\r\n    \r\n    function kill() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\n// helper functions for hashing\r\ncontract Encoder {\r\n    enum Algorithm { sha, keccak }\r\n\r\n    /// @dev generateProofSet - function for off-chain proof derivation\r\n    /// @param seed Secret used to secure the proof-set\r\n    /// @param caller Address of the caller, or account that verifies the proof-set\r\n    /// @param receiver Address of the encoded recepient\r\n    /// @param tokenAddress Address of the token to transfer from the caller\r\n    /// @param algorithm Hash algorithm to use for generating proof-set\r\n    function generateProofSet(\r\n        string seed,\r\n        address caller,\r\n        address receiver,\r\n        address tokenAddress,\r\n        Algorithm algorithm\r\n    ) pure public returns(bytes32 hash, bytes32 operator, bytes32 check, address check_receiver, address check_token) {\r\n        (hash, operator, check) = _escrow(seed, caller, receiver, tokenAddress, algorithm);\r\n        bytes32 key = hash_seed(seed, algorithm);\r\n        check_receiver = address(hash_data(key, algorithm)^operator);\r\n        if (check_receiver == 0) check_receiver = caller;\r\n        if (tokenAddress != 0) check_token = address(check^key^blind(receiver, algorithm));\r\n    }\r\n\r\n    // internal function for generating the proof-set\r\n    function _escrow(\r\n        string seed, \r\n        address caller,\r\n        address receiver,\r\n        address tokenAddress,\r\n        Algorithm algorithm\r\n    ) pure internal returns(bytes32 index, bytes32 operator, bytes32 check) {\r\n        require(caller != receiver && caller != 0);\r\n        bytes32 x = hash_seed(seed, algorithm);\r\n        if (algorithm == Algorithm.sha) {\r\n            index = sha256(x, caller);\r\n            operator = sha256(x)^bytes32(receiver);\r\n            check = x^sha256(receiver);\r\n        } else {\r\n            index = keccak256(x, caller);\r\n            operator = keccak256(x)^bytes32(receiver);\r\n            check = x^keccak256(receiver);\r\n        }\r\n        if (tokenAddress != 0) {\r\n            check ^= bytes32(tokenAddress);\r\n        }\r\n    }\r\n    \r\n    // internal function for hashing the seed\r\n    function hash_seed(\r\n        string seed, \r\n        Algorithm algorithm\r\n    ) pure internal returns(bytes32) {\r\n        if (algorithm == Algorithm.sha) return sha256(seed);\r\n        else return keccak256(seed);\r\n    }\r\n    \r\n   // internal function for hashing bytes\r\n    function hash_data(\r\n        bytes32 key, \r\n        Algorithm algorithm\r\n    ) pure internal returns(bytes32) {\r\n        if (algorithm == Algorithm.sha) return sha256(key);\r\n        else return keccak256(key);\r\n    }\r\n    \r\n    // internal function for hashing an address\r\n    function blind(\r\n        address addr,\r\n        Algorithm algorithm\r\n    ) pure internal returns(bytes32) {\r\n        if (algorithm == Algorithm.sha) return sha256(addr);\r\n        else return keccak256(addr);\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract BlackBox is Owned, Encoder {\r\n\r\n    // struct of proof set\r\n    struct Proof {\r\n        uint256 balance;\r\n        bytes32 operator;\r\n        bytes32 check;\r\n    }\r\n    \r\n    // mappings\r\n    mapping(bytes32 => Proof) public proofs;\r\n    mapping(bytes32 => bool) public used;\r\n    mapping(address => uint) private deposits;\r\n\r\n    // events\r\n    event ProofVerified(string _key, address _prover, uint _value);\r\n    event Locked(bytes32 _hash, bytes32 _operator, bytes32 _check);\r\n    event WithdrawTokens(address _token, address _to, uint _value);\r\n    event ClearedDeposit(address _to, uint value);\r\n    event TokenTransfer(address _token, address _from, address _to, uint _value);\r\n\r\n    /// @dev lock - store a proof-set\r\n    /// @param _hash Hash Key used to index the proof\r\n    /// @param _operator A derived operator to encode the intended recipient\r\n    /// @param _check A derived operator to check recipient, or a decode the token address\r\n    function lock(\r\n        bytes32 _hash,\r\n        bytes32 _operator,\r\n        bytes32 _check\r\n    ) public payable {\r\n        // protect invalid entries on value transfer\r\n        if (msg.value > 0) {\r\n            require(_hash != 0 && _operator != 0 && _check != 0);\r\n        }\r\n        // check existence\r\n        require(!used[_hash]);\r\n        // lock the ether\r\n        proofs[_hash].balance = msg.value;\r\n        proofs[_hash].operator = _operator;\r\n        proofs[_hash].check = _check;\r\n        // track unique keys\r\n        used[_hash] = true;\r\n        Locked(_hash, _operator, _check);\r\n    }\r\n\r\n    /// @dev unlock - verify a proof to transfer the locked funds\r\n    /// @param _seed Secret used to derive the proof set\r\n    /// @param _value Optional token value to transfer if the proof-set maps to a token transfer\r\n    /// @param _algo Hash algorithm type\r\n    function unlock(\r\n        string _seed,\r\n        uint _value,\r\n        Algorithm _algo\r\n    ) public onlyCompliant {\r\n        bytes32 hash = 0;\r\n        bytes32 operator = 0;\r\n        bytes32 check = 0;\r\n        // calculate the proof\r\n        (hash, operator, check) = _escrow(_seed, msg.sender, 0, 0, _algo);\r\n        require(used[hash]);\r\n        // get balance to send to decoded receiver\r\n        uint balance = proofs[hash].balance;\r\n        address receiver = address(proofs[hash].operator^operator);\r\n        address _token = address(proofs[hash].check^hash_seed(_seed, _algo)^blind(receiver, _algo));\r\n        delete proofs[hash];\r\n        if (receiver == 0) receiver = msg.sender;\r\n        // send balance and deposits\r\n        clearDeposits(receiver, balance);\r\n        ProofVerified(_seed, msg.sender, balance);\r\n\r\n        // check for token transfer\r\n        if (_token != 0) {\r\n            Token token = Token(_token);\r\n            uint tokenBalance = token.balanceOf(msg.sender);\r\n            uint allowance = token.allowance(msg.sender, this);\r\n            // check the balance to send to the receiver\r\n            if (_value == 0 || _value > tokenBalance) _value = tokenBalance;\r\n            if (allowance > 0 && _value > 0) {\r\n                if (_value > allowance) _value = allowance;\r\n                TokenTransfer(_token, msg.sender, receiver, _value);\r\n                require(token.transferFrom(msg.sender, receiver, _value));\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// @dev withdrawTokens - withdraw tokens from contract\r\n    /// @param _token Address of token that this contract holds\r\n    function withdrawTokens(address _token) public onlyOwner {\r\n        Token token = Token(_token);\r\n        uint256 value = token.balanceOf(this);\r\n        require(token.transfer(msg.sender, value));\r\n        WithdrawTokens(_token, msg.sender, value);\r\n    }\r\n    \r\n    /// @dev clearDeposits - internal function to send ether\r\n    /// @param _for Address of recipient\r\n    /// @param _value Value of proof balance\r\n    function clearDeposits(address _for, uint _value) internal {\r\n        uint deposit = deposits[msg.sender];\r\n        if (deposit > 0) delete deposits[msg.sender];\r\n        if (deposit + _value > 0) {\r\n            if (!_for.send(deposit+_value)) {\r\n                require(msg.sender.send(deposit+_value));\r\n            }\r\n            ClearedDeposit(_for, deposit+_value);\r\n        }\r\n    }\r\n    \r\n    function allowance(address _token, address _from) public view returns(uint _allowance) {\r\n        Token token = Token(_token);\r\n        _allowance = token.allowance(_from, this);\r\n    }\r\n    \r\n    // store deposits for msg.sender\r\n    function() public payable {\r\n        require(msg.value > 0);\r\n        deposits[msg.sender] += msg.value;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_seed\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_algo\",\"type\":\"uint8\"}],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"proofs\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"operator\",\"type\":\"bytes32\"},{\"name\":\"check\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeRestrictions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restricted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_operator\",\"type\":\"bytes32\"},{\"name\":\"_check\",\"type\":\"bytes32\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"used\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seed\",\"type\":\"string\"},{\"name\":\"caller\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"algorithm\",\"type\":\"uint8\"}],\"name\":\"generateProofSet\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"bytes32\"},{\"name\":\"check\",\"type\":\"bytes32\"},{\"name\":\"check_receiver\",\"type\":\"address\"},{\"name\":\"check_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_allowance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_prover\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ProofVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_operator\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_check\",\"type\":\"bytes32\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ClearedDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokenTransfer\",\"type\":\"event\"}]","ContractName":"BlackBox","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f5dbd2289fd06263e1122a4281d3be47cc074003e04d4bae4037ff206ac8ba9a"}]}