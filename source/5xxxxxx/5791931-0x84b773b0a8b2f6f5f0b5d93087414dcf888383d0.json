{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Owned contract with safe ownership pass.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public contractOwner;\r\n\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public pendingContractOwner;\r\n\r\n    function Owned() {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner check modifier\r\n    */\r\n    modifier onlyContractOwner() {\r\n        if (contractOwner == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can call it\r\n     */\r\n    function destroy() onlyContractOwner {\r\n        suicide(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Prepares ownership pass.\r\n     *\r\n     * Can only be called by current owner.\r\n     *\r\n     * @param _to address of the next owner. 0x0 is not allowed.\r\n     *\r\n     * @return success.\r\n     */\r\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\r\n        if (_to  == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Finalize ownership pass.\r\n     *\r\n     * Can only be called by pending owner.\r\n     *\r\n     * @return success.\r\n     */\r\n    function claimContractOwnership() returns(bool) {\r\n        if (pendingContractOwner != msg.sender) {\r\n            return false;\r\n        }\r\n\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\r\n\r\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\r\n        for(uint i=0;i<tokens.length;i++) {\r\n            address token = tokens[i];\r\n            uint balance = ERC20Interface(token).balanceOf(this);\r\n            if(balance != 0)\r\n                ERC20Interface(token).transfer(_to,balance);\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function checkOnlyContractOwner() internal constant returns(uint) {\r\n        if (contractOwner == msg.sender) {\r\n            return OK;\r\n        }\r\n\r\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract GroupsAccessManagerEmitter {\r\n\r\n    event UserCreated(address user);\r\n    event UserDeleted(address user);\r\n    event GroupCreated(bytes32 groupName);\r\n    event GroupActivated(bytes32 groupName);\r\n    event GroupDeactivated(bytes32 groupName);\r\n    event UserToGroupAdded(address user, bytes32 groupName);\r\n    event UserFromGroupRemoved(address user, bytes32 groupName);\r\n}\r\n\r\n\r\n/// @title Group Access Manager\r\n///\r\n/// Base implementation\r\n/// This contract serves as group manager\r\ncontract GroupsAccessManager is Object, GroupsAccessManagerEmitter {\r\n\r\n    uint constant USER_MANAGER_SCOPE = 111000;\r\n    uint constant USER_MANAGER_MEMBER_ALREADY_EXIST = USER_MANAGER_SCOPE + 1;\r\n    uint constant USER_MANAGER_GROUP_ALREADY_EXIST = USER_MANAGER_SCOPE + 2;\r\n    uint constant USER_MANAGER_OBJECT_ALREADY_SECURED = USER_MANAGER_SCOPE + 3;\r\n    uint constant USER_MANAGER_CONFIRMATION_HAS_COMPLETED = USER_MANAGER_SCOPE + 4;\r\n    uint constant USER_MANAGER_USER_HAS_CONFIRMED = USER_MANAGER_SCOPE + 5;\r\n    uint constant USER_MANAGER_NOT_ENOUGH_GAS = USER_MANAGER_SCOPE + 6;\r\n    uint constant USER_MANAGER_INVALID_INVOCATION = USER_MANAGER_SCOPE + 7;\r\n    uint constant USER_MANAGER_DONE = USER_MANAGER_SCOPE + 11;\r\n    uint constant USER_MANAGER_CANCELLED = USER_MANAGER_SCOPE + 12;\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Member {\r\n        address addr;\r\n        uint groupsCount;\r\n        mapping(bytes32 => uint) groupName2index;\r\n        mapping(uint => uint) index2globalIndex;\r\n    }\r\n\r\n    struct Group {\r\n        bytes32 name;\r\n        uint priority;\r\n        uint membersCount;\r\n        mapping(address => uint) memberAddress2index;\r\n        mapping(uint => uint) index2globalIndex;\r\n    }\r\n\r\n    uint public membersCount;\r\n    mapping(uint => address) index2memberAddress;\r\n    mapping(address => uint) memberAddress2index;\r\n    mapping(address => Member) address2member;\r\n\r\n    uint public groupsCount;\r\n    mapping(uint => bytes32) index2groupName;\r\n    mapping(bytes32 => uint) groupName2index;\r\n    mapping(bytes32 => Group) groupName2group;\r\n    mapping(bytes32 => bool) public groupsBlocked; // if groupName => true, then couldn't be used for confirmation\r\n\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    /// @notice Register user\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _user user address\r\n    ///\r\n    /// @return code\r\n    function registerUser(address _user) external onlyContractOwner returns (uint) {\r\n        require(_user != 0x0);\r\n\r\n        if (isRegisteredUser(_user)) {\r\n            return USER_MANAGER_MEMBER_ALREADY_EXIST;\r\n        }\r\n\r\n        uint _membersCount = membersCount.add(1);\r\n        membersCount = _membersCount;\r\n        memberAddress2index[_user] = _membersCount;\r\n        index2memberAddress[_membersCount] = _user;\r\n        address2member[_user] = Member(_user, 0);\r\n\r\n        UserCreated(_user);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Discard user registration\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _user user address\r\n    ///\r\n    /// @return code\r\n    function unregisterUser(address _user) external onlyContractOwner returns (uint) {\r\n        require(_user != 0x0);\r\n\r\n        uint _memberIndex = memberAddress2index[_user];\r\n        if (_memberIndex == 0 || address2member[_user].groupsCount != 0) {\r\n            return USER_MANAGER_INVALID_INVOCATION;\r\n        }\r\n\r\n        uint _membersCount = membersCount;\r\n        delete memberAddress2index[_user];\r\n        if (_memberIndex != _membersCount) {\r\n            address _lastUser = index2memberAddress[_membersCount];\r\n            index2memberAddress[_memberIndex] = _lastUser;\r\n            memberAddress2index[_lastUser] = _memberIndex;\r\n        }\r\n        delete address2member[_user];\r\n        delete index2memberAddress[_membersCount];\r\n        delete memberAddress2index[_user];\r\n        membersCount = _membersCount.sub(1);\r\n\r\n        UserDeleted(_user);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Create group\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group name\r\n    /// @param _priority group priority\r\n    ///\r\n    /// @return code\r\n    function createGroup(bytes32 _groupName, uint _priority) external onlyContractOwner returns (uint) {\r\n        require(_groupName != bytes32(0));\r\n\r\n        if (isGroupExists(_groupName)) {\r\n            return USER_MANAGER_GROUP_ALREADY_EXIST;\r\n        }\r\n\r\n        uint _groupsCount = groupsCount.add(1);\r\n        groupName2index[_groupName] = _groupsCount;\r\n        index2groupName[_groupsCount] = _groupName;\r\n        groupName2group[_groupName] = Group(_groupName, _priority, 0);\r\n        groupsCount = _groupsCount;\r\n\r\n        GroupCreated(_groupName);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Change group status\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group name\r\n    /// @param _blocked block status\r\n    ///\r\n    /// @return code\r\n    function changeGroupActiveStatus(bytes32 _groupName, bool _blocked) external onlyContractOwner returns (uint) {\r\n        require(isGroupExists(_groupName));\r\n        groupsBlocked[_groupName] = _blocked;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Add users in group\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group name\r\n    /// @param _users user array\r\n    ///\r\n    /// @return code\r\n    function addUsersToGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\r\n        require(isGroupExists(_groupName));\r\n\r\n        Group storage _group = groupName2group[_groupName];\r\n        uint _groupMembersCount = _group.membersCount;\r\n\r\n        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\r\n            address _user = _users[_userIdx];\r\n            uint _memberIndex = memberAddress2index[_user];\r\n            require(_memberIndex != 0);\r\n\r\n            if (_group.memberAddress2index[_user] != 0) {\r\n                continue;\r\n            }\r\n\r\n            _groupMembersCount = _groupMembersCount.add(1);\r\n            _group.memberAddress2index[_user] = _groupMembersCount;\r\n            _group.index2globalIndex[_groupMembersCount] = _memberIndex;\r\n\r\n            _addGroupToMember(_user, _groupName);\r\n\r\n            UserToGroupAdded(_user, _groupName);\r\n        }\r\n        _group.membersCount = _groupMembersCount;\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Remove users in group\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group name\r\n    /// @param _users user array\r\n    ///\r\n    /// @return code\r\n    function removeUsersFromGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\r\n        require(isGroupExists(_groupName));\r\n\r\n        Group storage _group = groupName2group[_groupName];\r\n        uint _groupMembersCount = _group.membersCount;\r\n\r\n        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\r\n            address _user = _users[_userIdx];\r\n            uint _memberIndex = memberAddress2index[_user];\r\n            uint _groupMemberIndex = _group.memberAddress2index[_user];\r\n\r\n            if (_memberIndex == 0 || _groupMemberIndex == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (_groupMemberIndex != _groupMembersCount) {\r\n                uint _lastUserGlobalIndex = _group.index2globalIndex[_groupMembersCount];\r\n                address _lastUser = index2memberAddress[_lastUserGlobalIndex];\r\n                _group.index2globalIndex[_groupMemberIndex] = _lastUserGlobalIndex;\r\n                _group.memberAddress2index[_lastUser] = _groupMemberIndex;\r\n            }\r\n            delete _group.memberAddress2index[_user];\r\n            delete _group.index2globalIndex[_groupMembersCount];\r\n            _groupMembersCount = _groupMembersCount.sub(1);\r\n\r\n            _removeGroupFromMember(_user, _groupName);\r\n\r\n            UserFromGroupRemoved(_user, _groupName);\r\n        }\r\n        _group.membersCount = _groupMembersCount;\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Check is user registered\r\n    ///\r\n    /// @param _user user address\r\n    ///\r\n    /// @return status\r\n    function isRegisteredUser(address _user) public view returns (bool) {\r\n        return memberAddress2index[_user] != 0;\r\n    }\r\n\r\n    /// @notice Check is user in group\r\n    ///\r\n    /// @param _groupName user array\r\n    /// @param _user user array\r\n    ///\r\n    /// @return status\r\n    function isUserInGroup(bytes32 _groupName, address _user) public view returns (bool) {\r\n        return isRegisteredUser(_user) && address2member[_user].groupName2index[_groupName] != 0;\r\n    }\r\n\r\n    /// @notice Check is group exist\r\n    ///\r\n    /// @param _groupName group name\r\n    ///\r\n    /// @return status\r\n    function isGroupExists(bytes32 _groupName) public view returns (bool) {\r\n        return groupName2index[_groupName] != 0;\r\n    }\r\n\r\n    /// @notice Get current group names\r\n    ///\r\n    /// @return group names\r\n    function getGroups() public view returns (bytes32[] _groups) {\r\n        uint _groupsCount = groupsCount;\r\n        _groups = new bytes32[](_groupsCount);\r\n        for (uint _groupIdx = 0; _groupIdx < _groupsCount; ++_groupIdx) {\r\n            _groups[_groupIdx] = index2groupName[_groupIdx + 1];\r\n        }\r\n    }\r\n\r\n    // PRIVATE\r\n\r\n    function _removeGroupFromMember(address _user, bytes32 _groupName) private {\r\n        Member storage _member = address2member[_user];\r\n        uint _memberGroupsCount = _member.groupsCount;\r\n        uint _memberGroupIndex = _member.groupName2index[_groupName];\r\n        if (_memberGroupIndex != _memberGroupsCount) {\r\n            uint _lastGroupGlobalIndex = _member.index2globalIndex[_memberGroupsCount];\r\n            bytes32 _lastGroupName = index2groupName[_lastGroupGlobalIndex];\r\n            _member.index2globalIndex[_memberGroupIndex] = _lastGroupGlobalIndex;\r\n            _member.groupName2index[_lastGroupName] = _memberGroupIndex;\r\n        }\r\n        delete _member.groupName2index[_groupName];\r\n        delete _member.index2globalIndex[_memberGroupsCount];\r\n        _member.groupsCount = _memberGroupsCount.sub(1);\r\n    }\r\n\r\n    function _addGroupToMember(address _user, bytes32 _groupName) private {\r\n        Member storage _member = address2member[_user];\r\n        uint _memberGroupsCount = _member.groupsCount.add(1);\r\n        _member.groupName2index[_groupName] = _memberGroupsCount;\r\n        _member.index2globalIndex[_memberGroupsCount] = groupName2index[_groupName];\r\n        _member.groupsCount = _memberGroupsCount;\r\n    }\r\n}\r\n\r\ncontract PendingManagerEmitter {\r\n\r\n    event PolicyRuleAdded(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName, uint acceptLimit, uint declinesLimit);\r\n    event PolicyRuleRemoved(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName);\r\n\r\n    event ProtectionTxAdded(bytes32 key, bytes32 sig, uint blockNumber);\r\n    event ProtectionTxAccepted(bytes32 key, address indexed sender, bytes32 groupNameVoted);\r\n    event ProtectionTxDone(bytes32 key);\r\n    event ProtectionTxDeclined(bytes32 key, address indexed sender, bytes32 groupNameVoted);\r\n    event ProtectionTxCancelled(bytes32 key);\r\n    event ProtectionTxVoteRevoked(bytes32 key, address indexed sender, bytes32 groupNameVoted);\r\n    event TxDeleted(bytes32 key);\r\n\r\n    event Error(uint errorCode);\r\n\r\n    function _emitError(uint _errorCode) internal returns (uint) {\r\n        Error(_errorCode);\r\n        return _errorCode;\r\n    }\r\n}\r\n\r\ncontract PendingManagerInterface {\r\n\r\n    function signIn(address _contract) external returns (uint);\r\n    function signOut(address _contract) external returns (uint);\r\n\r\n    function addPolicyRule(\r\n        bytes4 _sig, \r\n        address _contract, \r\n        bytes32 _groupName, \r\n        uint _acceptLimit, \r\n        uint _declineLimit \r\n        ) \r\n        external returns (uint);\r\n        \r\n    function removePolicyRule(\r\n        bytes4 _sig, \r\n        address _contract, \r\n        bytes32 _groupName\r\n        ) \r\n        external returns (uint);\r\n\r\n    function addTx(bytes32 _key, bytes4 _sig, address _contract) external returns (uint);\r\n    function deleteTx(bytes32 _key) external returns (uint);\r\n\r\n    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\r\n    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\r\n    function revoke(bytes32 _key) external returns (uint);\r\n\r\n    function hasConfirmedRecord(bytes32 _key) public view returns (uint);\r\n    function getPolicyDetails(bytes4 _sig, address _contract) public view returns (\r\n        bytes32[] _groupNames,\r\n        uint[] _acceptLimits,\r\n        uint[] _declineLimits,\r\n        uint _totalAcceptedLimit,\r\n        uint _totalDeclinedLimit\r\n        );\r\n}\r\n\r\n/// @title PendingManager\r\n///\r\n/// Base implementation\r\n/// This contract serves as pending manager for transaction status\r\ncontract PendingManager is Object, PendingManagerEmitter, PendingManagerInterface {\r\n\r\n    uint constant NO_RECORDS_WERE_FOUND = 4;\r\n    uint constant PENDING_MANAGER_SCOPE = 4000;\r\n    uint constant PENDING_MANAGER_INVALID_INVOCATION = PENDING_MANAGER_SCOPE + 1;\r\n    uint constant PENDING_MANAGER_HASNT_VOTED = PENDING_MANAGER_SCOPE + 2;\r\n    uint constant PENDING_DUPLICATE_TX = PENDING_MANAGER_SCOPE + 3;\r\n    uint constant PENDING_MANAGER_CONFIRMED = PENDING_MANAGER_SCOPE + 4;\r\n    uint constant PENDING_MANAGER_REJECTED = PENDING_MANAGER_SCOPE + 5;\r\n    uint constant PENDING_MANAGER_IN_PROCESS = PENDING_MANAGER_SCOPE + 6;\r\n    uint constant PENDING_MANAGER_TX_DOESNT_EXIST = PENDING_MANAGER_SCOPE + 7;\r\n    uint constant PENDING_MANAGER_TX_WAS_DECLINED = PENDING_MANAGER_SCOPE + 8;\r\n    uint constant PENDING_MANAGER_TX_WAS_NOT_CONFIRMED = PENDING_MANAGER_SCOPE + 9;\r\n    uint constant PENDING_MANAGER_INSUFFICIENT_GAS = PENDING_MANAGER_SCOPE + 10;\r\n    uint constant PENDING_MANAGER_POLICY_NOT_FOUND = PENDING_MANAGER_SCOPE + 11;\r\n\r\n    using SafeMath for uint;\r\n\r\n    enum GuardState {\r\n        Decline, Confirmed, InProcess\r\n    }\r\n\r\n    struct Requirements {\r\n        bytes32 groupName;\r\n        uint acceptLimit;\r\n        uint declineLimit;\r\n    }\r\n\r\n    struct Policy {\r\n        uint groupsCount;\r\n        mapping(uint => Requirements) participatedGroups; // index => globalGroupIndex\r\n        mapping(bytes32 => uint) groupName2index; // groupName => localIndex\r\n        \r\n        uint totalAcceptedLimit;\r\n        uint totalDeclinedLimit;\r\n\r\n        uint securesCount;\r\n        mapping(uint => uint) index2txIndex;\r\n        mapping(uint => uint) txIndex2index;\r\n    }\r\n\r\n    struct Vote {\r\n        bytes32 groupName;\r\n        bool accepted;\r\n    }\r\n\r\n    struct Guard {\r\n        GuardState state;\r\n        uint basePolicyIndex;\r\n\r\n        uint alreadyAccepted;\r\n        uint alreadyDeclined;\r\n        \r\n        mapping(address => Vote) votes; // member address => vote\r\n        mapping(bytes32 => uint) acceptedCount; // groupName => how many from group has already accepted\r\n        mapping(bytes32 => uint) declinedCount; // groupName => how many from group has already declined\r\n    }\r\n\r\n    address public accessManager;\r\n\r\n    mapping(address => bool) public authorized;\r\n\r\n    uint public policiesCount;\r\n    mapping(uint => bytes32) index2PolicyId; // index => policy hash\r\n    mapping(bytes32 => uint) policyId2Index; // policy hash => index\r\n    mapping(bytes32 => Policy) policyId2policy; // policy hash => policy struct\r\n\r\n    uint public txCount;\r\n    mapping(uint => bytes32) index2txKey;\r\n    mapping(bytes32 => uint) txKey2index; // tx key => index\r\n    mapping(bytes32 => Guard) txKey2guard;\r\n\r\n    /// @dev Execution is allowed only by authorized contract\r\n    modifier onlyAuthorized {\r\n        if (authorized[msg.sender] || address(this) == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /// @dev Pending Manager's constructor\r\n    ///\r\n    /// @param _accessManager access manager's address\r\n    function PendingManager(address _accessManager) public {\r\n        require(_accessManager != 0x0);\r\n        accessManager = _accessManager;\r\n    }\r\n\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    /// @notice Update access manager address\r\n    ///\r\n    /// @param _accessManager access manager's address\r\n    function setAccessManager(address _accessManager) external onlyContractOwner returns (uint) {\r\n        require(_accessManager != 0x0);\r\n        accessManager = _accessManager;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Sign in contract\r\n    ///\r\n    /// @param _contract contract's address\r\n    function signIn(address _contract) external onlyContractOwner returns (uint) {\r\n        require(_contract != 0x0);\r\n        authorized[_contract] = true;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Sign out contract\r\n    ///\r\n    /// @param _contract contract's address\r\n    function signOut(address _contract) external onlyContractOwner returns (uint) {\r\n        require(_contract != 0x0);\r\n        delete authorized[_contract];\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Register new policy rule\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _sig target method signature\r\n    /// @param _contract target contract address\r\n    /// @param _groupName group's name\r\n    /// @param _acceptLimit accepted vote limit\r\n    /// @param _declineLimit decline vote limit\r\n    ///\r\n    /// @return code\r\n    function addPolicyRule(\r\n        bytes4 _sig,\r\n        address _contract,\r\n        bytes32 _groupName,\r\n        uint _acceptLimit,\r\n        uint _declineLimit\r\n    )\r\n    onlyContractOwner\r\n    external\r\n    returns (uint)\r\n    {\r\n        require(_sig != 0x0);\r\n        require(_contract != 0x0);\r\n        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\r\n        require(_acceptLimit != 0);\r\n        require(_declineLimit != 0);\r\n\r\n        bytes32 _policyHash = keccak256(_sig, _contract);\r\n        \r\n        if (policyId2Index[_policyHash] == 0) {\r\n            uint _policiesCount = policiesCount.add(1);\r\n            index2PolicyId[_policiesCount] = _policyHash;\r\n            policyId2Index[_policyHash] = _policiesCount;\r\n            policiesCount = _policiesCount;\r\n        }\r\n\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        uint _policyGroupsCount = _policy.groupsCount;\r\n\r\n        if (_policy.groupName2index[_groupName] == 0) {\r\n            _policyGroupsCount += 1;\r\n            _policy.groupName2index[_groupName] = _policyGroupsCount;\r\n            _policy.participatedGroups[_policyGroupsCount].groupName = _groupName;\r\n            _policy.groupsCount = _policyGroupsCount;\r\n        }\r\n\r\n        uint _previousAcceptLimit = _policy.participatedGroups[_policyGroupsCount].acceptLimit;\r\n        uint _previousDeclineLimit = _policy.participatedGroups[_policyGroupsCount].declineLimit;\r\n        _policy.participatedGroups[_policyGroupsCount].acceptLimit = _acceptLimit;\r\n        _policy.participatedGroups[_policyGroupsCount].declineLimit = _declineLimit;\r\n        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_previousAcceptLimit).add(_acceptLimit);\r\n        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_previousDeclineLimit).add(_declineLimit);\r\n\r\n        PolicyRuleAdded(_sig, _contract, _policyHash, _groupName, _acceptLimit, _declineLimit);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Remove policy rule\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group's name\r\n    ///\r\n    /// @return code\r\n    function removePolicyRule(\r\n        bytes4 _sig,\r\n        address _contract,\r\n        bytes32 _groupName\r\n    ) \r\n    onlyContractOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        require(_sig != bytes4(0));\r\n        require(_contract != 0x0);\r\n        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\r\n\r\n        bytes32 _policyHash = keccak256(_sig, _contract);\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        uint _policyGroupNameIndex = _policy.groupName2index[_groupName];\r\n\r\n        if (_policyGroupNameIndex == 0) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        uint _policyGroupsCount = _policy.groupsCount;\r\n        if (_policyGroupNameIndex != _policyGroupsCount) {\r\n            Requirements storage _requirements = _policy.participatedGroups[_policyGroupsCount];\r\n            _policy.participatedGroups[_policyGroupNameIndex] = _requirements;\r\n            _policy.groupName2index[_requirements.groupName] = _policyGroupNameIndex;\r\n        }\r\n\r\n        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit);\r\n        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit);\r\n\r\n        delete _policy.groupName2index[_groupName];\r\n        delete _policy.participatedGroups[_policyGroupsCount];\r\n        _policy.groupsCount = _policyGroupsCount.sub(1);\r\n\r\n        PolicyRuleRemoved(_sig, _contract, _policyHash, _groupName);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Add transaction\r\n    ///\r\n    /// @param _key transaction id\r\n    ///\r\n    /// @return code\r\n    function addTx(bytes32 _key, bytes4 _sig, address _contract) external onlyAuthorized returns (uint) {\r\n        require(_key != bytes32(0));\r\n        require(_sig != bytes4(0));\r\n        require(_contract != 0x0);\r\n\r\n        bytes32 _policyHash = keccak256(_sig, _contract);\r\n        require(isPolicyExist(_policyHash));\r\n\r\n        if (isTxExist(_key)) {\r\n            return _emitError(PENDING_DUPLICATE_TX);\r\n        }\r\n\r\n        if (_policyHash == bytes32(0)) {\r\n            return _emitError(PENDING_MANAGER_POLICY_NOT_FOUND);\r\n        }\r\n\r\n        uint _index = txCount.add(1);\r\n        txCount = _index;\r\n        index2txKey[_index] = _key;\r\n        txKey2index[_key] = _index;\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        _guard.basePolicyIndex = policyId2Index[_policyHash];\r\n        _guard.state = GuardState.InProcess;\r\n\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        uint _counter = _policy.securesCount.add(1);\r\n        _policy.securesCount = _counter;\r\n        _policy.index2txIndex[_counter] = _index;\r\n        _policy.txIndex2index[_index] = _counter;\r\n\r\n        ProtectionTxAdded(_key, _policyHash, block.number);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Delete transaction\r\n    /// @param _key transaction id\r\n    /// @return code\r\n    function deleteTx(bytes32 _key) external onlyContractOwner returns (uint) {\r\n        require(_key != bytes32(0));\r\n\r\n        if (!isTxExist(_key)) {\r\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\r\n        }\r\n\r\n        uint _txsCount = txCount;\r\n        uint _txIndex = txKey2index[_key];\r\n        if (_txIndex != _txsCount) {\r\n            bytes32 _last = index2txKey[txCount];\r\n            index2txKey[_txIndex] = _last;\r\n            txKey2index[_last] = _txIndex;\r\n        }\r\n\r\n        delete txKey2index[_key];\r\n        delete index2txKey[_txsCount];\r\n        txCount = _txsCount.sub(1);\r\n\r\n        uint _basePolicyIndex = txKey2guard[_key].basePolicyIndex;\r\n        Policy storage _policy = policyId2policy[index2PolicyId[_basePolicyIndex]];\r\n        uint _counter = _policy.securesCount;\r\n        uint _policyTxIndex = _policy.txIndex2index[_txIndex];\r\n        if (_policyTxIndex != _counter) {\r\n            uint _movedTxIndex = _policy.index2txIndex[_counter];\r\n            _policy.index2txIndex[_policyTxIndex] = _movedTxIndex;\r\n            _policy.txIndex2index[_movedTxIndex] = _policyTxIndex;\r\n        }\r\n\r\n        delete _policy.index2txIndex[_counter];\r\n        delete _policy.txIndex2index[_txIndex];\r\n        _policy.securesCount = _counter.sub(1);\r\n\r\n        TxDeleted(_key);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Accept transaction\r\n    /// Can be called only by registered user in GroupsAccessManager\r\n    ///\r\n    /// @param _key transaction id\r\n    ///\r\n    /// @return code\r\n    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\r\n        if (!isTxExist(_key)) {\r\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\r\n        }\r\n\r\n        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        if (_guard.state != GuardState.InProcess) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        if (_guard.votes[msg.sender].groupName != bytes32(0) && _guard.votes[msg.sender].accepted) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\r\n        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\r\n        uint _groupAcceptedVotesCount = _guard.acceptedCount[_votingGroupName];\r\n        if (_groupAcceptedVotesCount == _policy.participatedGroups[_policyGroupIndex].acceptLimit) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        _guard.votes[msg.sender] = Vote(_votingGroupName, true);\r\n        _guard.acceptedCount[_votingGroupName] = _groupAcceptedVotesCount + 1;\r\n        uint _alreadyAcceptedCount = _guard.alreadyAccepted + 1;\r\n        _guard.alreadyAccepted = _alreadyAcceptedCount;\r\n\r\n        ProtectionTxAccepted(_key, msg.sender, _votingGroupName);\r\n\r\n        if (_alreadyAcceptedCount == _policy.totalAcceptedLimit) {\r\n            _guard.state = GuardState.Confirmed;\r\n            ProtectionTxDone(_key);\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Decline transaction\r\n    /// Can be called only by registered user in GroupsAccessManager\r\n    ///\r\n    /// @param _key transaction id\r\n    ///\r\n    /// @return code\r\n    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\r\n        if (!isTxExist(_key)) {\r\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\r\n        }\r\n\r\n        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        if (_guard.state != GuardState.InProcess) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        if (_guard.votes[msg.sender].groupName != bytes32(0) && !_guard.votes[msg.sender].accepted) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\r\n        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\r\n        uint _groupDeclinedVotesCount = _guard.declinedCount[_votingGroupName];\r\n        if (_groupDeclinedVotesCount == _policy.participatedGroups[_policyGroupIndex].declineLimit) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        _guard.votes[msg.sender] = Vote(_votingGroupName, false);\r\n        _guard.declinedCount[_votingGroupName] = _groupDeclinedVotesCount + 1;\r\n        uint _alreadyDeclinedCount = _guard.alreadyDeclined + 1;\r\n        _guard.alreadyDeclined = _alreadyDeclinedCount;\r\n\r\n\r\n        ProtectionTxDeclined(_key, msg.sender, _votingGroupName);\r\n\r\n        if (_alreadyDeclinedCount == _policy.totalDeclinedLimit) {\r\n            _guard.state = GuardState.Decline;\r\n            ProtectionTxCancelled(_key);\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Revoke user votes for transaction\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _key transaction id\r\n    /// @param _user target user address\r\n    ///\r\n    /// @return code\r\n    function forceRejectVotes(bytes32 _key, address _user) external onlyContractOwner returns (uint) {\r\n        return _revoke(_key, _user);\r\n    }\r\n\r\n    /// @notice Revoke vote for transaction\r\n    /// Can be called only by authorized user\r\n    /// @param _key transaction id\r\n    /// @return code\r\n    function revoke(bytes32 _key) external returns (uint) {\r\n        return _revoke(_key, msg.sender);\r\n    }\r\n\r\n    /// @notice Check transaction status\r\n    /// @param _key transaction id\r\n    /// @return code\r\n    function hasConfirmedRecord(bytes32 _key) public view returns (uint) {\r\n        require(_key != bytes32(0));\r\n\r\n        if (!isTxExist(_key)) {\r\n            return NO_RECORDS_WERE_FOUND;\r\n        }\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        return _guard.state == GuardState.InProcess\r\n        ? PENDING_MANAGER_IN_PROCESS\r\n        : _guard.state == GuardState.Confirmed\r\n        ? OK\r\n        : PENDING_MANAGER_REJECTED;\r\n    }\r\n\r\n\r\n    /// @notice Check policy details\r\n    ///\r\n    /// @return _groupNames group names included in policies\r\n    /// @return _acceptLimits accept limit for group\r\n    /// @return _declineLimits decline limit for group\r\n    function getPolicyDetails(bytes4 _sig, address _contract)\r\n    public\r\n    view\r\n    returns (\r\n        bytes32[] _groupNames,\r\n        uint[] _acceptLimits,\r\n        uint[] _declineLimits,\r\n        uint _totalAcceptedLimit,\r\n        uint _totalDeclinedLimit\r\n    ) {\r\n        require(_sig != bytes4(0));\r\n        require(_contract != 0x0);\r\n        \r\n        bytes32 _policyHash = keccak256(_sig, _contract);\r\n        uint _policyIdx = policyId2Index[_policyHash];\r\n        if (_policyIdx == 0) {\r\n            return;\r\n        }\r\n\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        uint _policyGroupsCount = _policy.groupsCount;\r\n        _groupNames = new bytes32[](_policyGroupsCount);\r\n        _acceptLimits = new uint[](_policyGroupsCount);\r\n        _declineLimits = new uint[](_policyGroupsCount);\r\n\r\n        for (uint _idx = 0; _idx < _policyGroupsCount; ++_idx) {\r\n            Requirements storage _requirements = _policy.participatedGroups[_idx + 1];\r\n            _groupNames[_idx] = _requirements.groupName;\r\n            _acceptLimits[_idx] = _requirements.acceptLimit;\r\n            _declineLimits[_idx] = _requirements.declineLimit;\r\n        }\r\n\r\n        (_totalAcceptedLimit, _totalDeclinedLimit) = (_policy.totalAcceptedLimit, _policy.totalDeclinedLimit);\r\n    }\r\n\r\n    /// @notice Check policy include target group\r\n    /// @param _policyHash policy hash (sig, contract address)\r\n    /// @param _groupName group id\r\n    /// @return bool\r\n    function isGroupInPolicy(bytes32 _policyHash, bytes32 _groupName) public view returns (bool) {\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        return _policy.groupName2index[_groupName] != 0;\r\n    }\r\n\r\n    /// @notice Check is policy exist\r\n    /// @param _policyHash policy hash (sig, contract address)\r\n    /// @return bool\r\n    function isPolicyExist(bytes32 _policyHash) public view returns (bool) {\r\n        return policyId2Index[_policyHash] != 0;\r\n    }\r\n\r\n    /// @notice Check is transaction exist\r\n    /// @param _key transaction id\r\n    /// @return bool\r\n    function isTxExist(bytes32 _key) public view returns (bool){\r\n        return txKey2index[_key] != 0;\r\n    }\r\n\r\n    function _updateTxState(Policy storage _policy, Guard storage _guard, uint confirmedAmount, uint declineAmount) private {\r\n        if (declineAmount != 0 && _guard.state != GuardState.Decline) {\r\n            _guard.state = GuardState.Decline;\r\n        } else if (confirmedAmount >= _policy.groupsCount && _guard.state != GuardState.Confirmed) {\r\n            _guard.state = GuardState.Confirmed;\r\n        } else if (_guard.state != GuardState.InProcess) {\r\n            _guard.state = GuardState.InProcess;\r\n        }\r\n    }\r\n\r\n    function _revoke(bytes32 _key, address _user) private returns (uint) {\r\n        require(_key != bytes32(0));\r\n        require(_user != 0x0);\r\n\r\n        if (!isTxExist(_key)) {\r\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\r\n        }\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        if (_guard.state != GuardState.InProcess) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        bytes32 _votedGroupName = _guard.votes[_user].groupName;\r\n        if (_votedGroupName == bytes32(0)) {\r\n            return _emitError(PENDING_MANAGER_HASNT_VOTED);\r\n        }\r\n\r\n        bool isAcceptedVote = _guard.votes[_user].accepted;\r\n        if (isAcceptedVote) {\r\n            _guard.acceptedCount[_votedGroupName] = _guard.acceptedCount[_votedGroupName].sub(1);\r\n            _guard.alreadyAccepted = _guard.alreadyAccepted.sub(1);\r\n        } else {\r\n            _guard.declinedCount[_votedGroupName] = _guard.declinedCount[_votedGroupName].sub(1);\r\n            _guard.alreadyDeclined = _guard.alreadyDeclined.sub(1);\r\n\r\n        }\r\n\r\n        delete _guard.votes[_user];\r\n\r\n        ProtectionTxVoteRevoked(_key, _user, _votedGroupName);\r\n        return OK;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"policiesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sig\",\"type\":\"bytes4\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_groupName\",\"type\":\"bytes32\"}],\"name\":\"removePolicyRule\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sig\",\"type\":\"bytes4\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"getPolicyDetails\",\"outputs\":[{\"name\":\"_groupNames\",\"type\":\"bytes32[]\"},{\"name\":\"_acceptLimits\",\"type\":\"uint256[]\"},{\"name\":\"_declineLimits\",\"type\":\"uint256[]\"},{\"name\":\"_totalAcceptedLimit\",\"type\":\"uint256\"},{\"name\":\"_totalDeclinedLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"signOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_sig\",\"type\":\"bytes4\"},{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"addTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sig\",\"type\":\"bytes4\"},{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_groupName\",\"type\":\"bytes32\"},{\"name\":\"_acceptLimit\",\"type\":\"uint256\"},{\"name\":\"_declineLimit\",\"type\":\"uint256\"}],\"name\":\"addPolicyRule\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"forceRejectVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_votingGroupName\",\"type\":\"bytes32\"}],\"name\":\"accept\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_policyHash\",\"type\":\"bytes32\"},{\"name\":\"_groupName\",\"type\":\"bytes32\"}],\"name\":\"isGroupInPolicy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"signIn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"hasConfirmedRecord\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_policyHash\",\"type\":\"bytes32\"}],\"name\":\"isPolicyExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"isTxExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accessManager\",\"type\":\"address\"}],\"name\":\"setAccessManager\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_votingGroupName\",\"type\":\"bytes32\"}],\"name\":\"decline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accessManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_accessManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"groupName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"acceptLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"declinesLimit\",\"type\":\"uint256\"}],\"name\":\"PolicyRuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"groupName\",\"type\":\"bytes32\"}],\"name\":\"PolicyRuleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"ProtectionTxAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"groupNameVoted\",\"type\":\"bytes32\"}],\"name\":\"ProtectionTxAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"ProtectionTxDone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"groupNameVoted\",\"type\":\"bytes32\"}],\"name\":\"ProtectionTxDeclined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"ProtectionTxCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"groupNameVoted\",\"type\":\"bytes32\"}],\"name\":\"ProtectionTxVoteRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"TxDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"Error\",\"type\":\"event\"}]","ContractName":"PendingManager","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dbf2da30cdb8b03d46752d320ed1415a56b83abb","Library":"","SwarmSource":"bzzr://be6254c8e7a42ab10e4de32c928e9867ad3eee12e415f41cf7d7341547da7028"}]}