{"status":"1","message":"OK","result":[{"SourceCode":"/* \r\n   A vault so that anyone can try out the Teikhos authentication method \r\n\r\n   proof-of-public-key = f(nextPublicKey) xor sha512(nextPublicKey)\r\n   \r\n   note, very high gas cost since it uses an on-state sha3_512 library\r\n*/\r\n\r\n\r\n\r\ncontract SHA3_512 {\r\n   function hash(uint64[8]) pure public returns(uint32[16]) {}\r\n}\r\n\r\ncontract Teikhos {\r\n\r\n    SHA3_512 public sha3_512 = SHA3_512(0x367b9E7d0364CF8aa8fEc906DDa56Faf41292dB7);\r\n\r\n    // Use a string as the account identifier, so people can use any name they want\r\n\r\n    mapping(string => bytes) proof_of_public_key;\r\n    \r\n    mapping(string => uint) balanceOf;\r\n\r\n\r\n    function checkAccount(string _name) view public returns (uint balance, bytes proof) {\r\n         return (balanceOf[_name], proof_of_public_key[_name]);\r\n    }\r\n\r\n    function newAccount(string _name, bytes _proof_of_public_key) public {\r\n        require(proof_of_public_key[_name].length == 0);\r\n        require(_proof_of_public_key.length == 64); \r\n        require(bytes(_name).length != 0);\r\n    \r\n        proof_of_public_key[_name] = _proof_of_public_key;\r\n    }\r\n\r\n    function deposit(string _name) public payable {\r\n        require(proof_of_public_key[_name].length == 64);\r\n        balanceOf[_name] += msg.value;\r\n    }\r\n    \r\n\r\n    function authenticate(string _name, bytes _publicKey) public {\r\n\r\n        require(proof_of_public_key[_name].length == 64);\r\n\r\n        // Get address from public key\r\n        address signer = address(keccak256(_publicKey));\r\n\r\n        require(signer == msg.sender);\r\n\r\n        bytes memory keyHash = getHash(_publicKey);\r\n         \r\n        // Split hash of public key in 2xbytes32, to support xor operator and ecrecover r, s v format\r\n\r\n        bytes32 hash1;\r\n        bytes32 hash2;\r\n\r\n        assembly {\r\n        hash1 := mload(add(keyHash,0x20))\r\n        hash2 := mload(add(keyHash,0x40))\r\n        }\r\n\r\n        // Split proof_of_public_key in 2xbytes32, to support xor operator and ecrecover r, s v format\r\n\r\n        bytes memory PoPk = proof_of_public_key[_name];\r\n\r\n        bytes32 proof_of_public_key1;\r\n        bytes32 proof_of_public_key2;\r\n\r\n        assembly {\r\n        proof_of_public_key1 := mload(add(PoPk,0x20))\r\n        proof_of_public_key2 := mload(add(PoPk,0x40))\r\n        }\r\n\r\n        // Use xor (reverse cipher) to get signature in r, s v format\r\n        bytes32 r = proof_of_public_key1 ^ hash1;\r\n        bytes32 s = proof_of_public_key2 ^ hash2;\r\n\r\n        // Get msgHash for use with ecrecover\r\n        bytes32 msgHash = keccak256(\"\\x19Ethereum Signed Message:\\n64\", _publicKey);\r\n\r\n        // The value v is not known, try both 27 and 28\r\n        if(ecrecover(msgHash, 27, r, s) == signer || ecrecover(msgHash, 28, r, s) == signer ) {\r\n           uint amount = balanceOf[_name];\r\n           // delete the account to prevent recursive call attacks\r\n           delete balanceOf[_name];\r\n           delete proof_of_public_key[_name];\r\n           // then withdraw all ether held in the vault\r\n           require(msg.sender.send(amount));\r\n        }\r\n    }\r\n\r\n   // A separate method getHash() for converting bytes to uint64[8], which is done since the EVM cannot pass bytes between contracts\r\n   // The SHA3_512 logic is in a separate contract to make it easier to read, that contract could be audited on its own, and so on\r\n\r\n   function getHash(bytes _message) view internal returns (bytes messageHash) {\r\n\r\n        // Use SHA3_512 library to get a sha3_512 hash of public key\r\n\r\n        uint64[8] memory input;\r\n\r\n        // The evm is big endian, have to reverse the bytes\r\n\r\n        bytes memory reversed = new bytes(64);\r\n\r\n        for(uint i = 0; i < 64; i++) {\r\n            reversed[i] = _message[63 - i];\r\n        }\r\n\r\n        for(i = 0; i < 8; i++) {\r\n            bytes8 oneEigth;\r\n            // Load 8 byte from reversed public key at position 32 + i * 8\r\n            assembly {\r\n                oneEigth := mload(add(reversed, add(32, mul(i, 8)))) \r\n            }\r\n            input[7 - i] = uint64(oneEigth);\r\n        }\r\n\r\n        uint32[16] memory output = sha3_512.hash(input);\r\n        \r\n        bytes memory toBytes = new bytes(64);\r\n        \r\n        for(i = 0; i < 16; i++) {\r\n            bytes4 oneSixteenth = bytes4(output[15 - i]);\r\n            // Store 4 byte in keyHash at position 32 + i * 4\r\n            assembly { mstore(add(toBytes, add(32, mul(i, 4))), oneSixteenth) }\r\n        }\r\n\r\n        messageHash = new bytes(64);\r\n\r\n        for(i = 0; i < 64; i++) {\r\n            messageHash[i] = toBytes[63 - i];\r\n        }   \r\n   }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_proof_of_public_key\",\"type\":\"bytes\"}],\"name\":\"newAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"checkAccount\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sha3_512\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_publicKey\",\"type\":\"bytes\"}],\"name\":\"authenticate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Teikhos","CompilerVersion":"v0.4.22-nightly.2018.3.13+commit.f2614be9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f75a2356cce4d6078d813de4c511d77967e0614cd745c05c546abb76be7d7193"}]}