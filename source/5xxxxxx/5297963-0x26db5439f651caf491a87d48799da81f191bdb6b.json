{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\npragma solidity ^0.4.18;\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * CashBetCoin ERC20 token\r\n * Based on the OpenZeppelin Standard Token\r\n * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol\r\n */\r\n\r\ncontract MigrationSource {\r\n  function vacate(address _addr) public returns (uint256 o_balance,\r\n                                                 uint256 o_lock_value,\r\n                                                 uint256 o_lock_endTime,\r\n                                                 bytes32 o_operatorId,\r\n                                                 bytes32 o_playerId);\r\n}\r\n\r\ncontract CashBetCoin is MigrationSource, ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  string public constant name = \"CashBetCoin\";\r\n  string public constant symbol = \"CBC\";\r\n  uint8 public constant decimals = 8;\r\n  uint internal totalSupply_;\r\n\r\n  address public owner;\r\n\r\n  mapping(bytes32 => bool) public operators;\r\n  mapping(address => User) public users;\r\n  mapping(address => mapping(bytes32 => bool)) public employees;\r\n  \r\n  MigrationSource public migrateFrom;\r\n  address public migrateTo;\r\n\r\n  struct User {\r\n    uint256 balance;\r\n    uint256 lock_value;\r\n    uint256 lock_endTime;\r\n    bytes32 operatorId;\r\n    bytes32 playerId;\r\n      \r\n    mapping(address => uint256) authorized;\r\n  }\r\n\r\n  modifier only_owner(){\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier only_employees(address _user){\r\n    require(employees[msg.sender][users[_user].operatorId]);\r\n    _;\r\n  }\r\n\r\n  // PlayerId may only be set if operatorId is set too.\r\n  modifier playerid_iff_operatorid(bytes32 _opId, bytes32 _playerId){\r\n    require(_opId != bytes32(0) || _playerId == bytes32(0));\r\n    _;\r\n  }\r\n\r\n  // Value argument must be less than unlocked balance.\r\n  modifier value_less_than_unlocked_balance(address _user, uint256 _value){\r\n    User storage user = users[_user];\r\n    require(user.lock_endTime < block.timestamp ||\r\n            _value <= user.balance - user.lock_value);\r\n    require(_value <= user.balance);\r\n    _;\r\n  }\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event LockIncrease(address indexed user, uint256 amount, uint256 time);\r\n  event LockDecrease(address indexed user, address employee,  uint256 amount, uint256 time);\r\n\r\n  event Associate(address indexed user, address agent, bytes32 indexed operatorId, bytes32 playerId);\r\n  \r\n  event Burn(address indexed owner, uint256 value);\r\n\r\n  event OptIn(address indexed owner, uint256 value);\r\n  event Vacate(address indexed owner, uint256 value);\r\n\r\n  event Employee(address indexed empl, bytes32 indexed operatorId, bool allowed);\r\n  event Operator(bytes32 indexed operatorId, bool allowed);\r\n\r\n  function CashBetCoin(uint _totalSupply) public {\r\n    totalSupply_ = _totalSupply;\r\n    owner = msg.sender;\r\n    User storage user = users[owner];\r\n    user.balance = totalSupply_;\r\n    user.lock_value = 0;\r\n    user.lock_endTime = 0;\r\n    user.operatorId = bytes32(0);\r\n    user.playerId = bytes32(0);\r\n    Transfer(0, owner, _totalSupply);\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256){\r\n    return totalSupply_;\r\n  }\r\n\r\n  function balanceOf(address _addr) public view returns (uint256 balance) {\r\n    return users[_addr].balance;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) public value_less_than_unlocked_balance(msg.sender, _value) returns (bool success) {\r\n    User storage user = users[msg.sender];\r\n    user.balance = user.balance.sub(_value);\r\n    users[_to].balance = users[_to].balance.add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public value_less_than_unlocked_balance(_from, _value) returns (bool success) {\r\n    User storage user = users[_from];\r\n    user.balance = user.balance.sub(_value);\r\n    users[_to].balance = users[_to].balance.add(_value);\r\n    user.authorized[msg.sender] = user.authorized[msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool success){\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (users[msg.sender].authorized[_spender] == 0));\r\n    users[msg.sender].authorized[_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _user, address _spender) public view returns (uint256){\r\n    return users[_user].authorized[_spender];\r\n  }\r\n\r\n  // Returns the number of locked tokens at the specified address.\r\n  //\r\n  function lockedValueOf(address _addr) public view returns (uint256 value) {\r\n    User storage user = users[_addr];\r\n    // Is the lock expired?\r\n    if (user.lock_endTime < block.timestamp) {\r\n      // Lock is expired, no locked value.\r\n      return 0;\r\n    } else {\r\n      return user.lock_value;\r\n    }\r\n  }\r\n\r\n  // Returns the unix time that the current token lock will expire.\r\n  //\r\n  function lockedEndTimeOf(address _addr) public view returns (uint256 time) {\r\n    return users[_addr].lock_endTime;\r\n  }\r\n\r\n  // Lock the specified number of tokens until the specified unix\r\n  // time.  The locked value and expiration time are both absolute (if\r\n  // the account already had some locked tokens the count will be\r\n  // increased to this value.)  If the user already has locked tokens\r\n  // the locked token count and expiration time may not be smaller\r\n  // than the previous values.\r\n  //\r\n  function increaseLock(uint256 _value, uint256 _time) public returns (bool success) {\r\n    User storage user = users[msg.sender];\r\n\r\n    // Is there a lock in effect?\r\n    if (block.timestamp < user.lock_endTime) {\r\n      // Lock in effect, ensure nothing gets smaller.\r\n      require(_value >= user.lock_value);\r\n      require(_time >= user.lock_endTime);\r\n      // Ensure something has increased.\r\n      require(_value > user.lock_value || _time > user.lock_endTime);\r\n    }\r\n\r\n    // Things we always require.\r\n    require(_value <= user.balance);\r\n    require(_time > block.timestamp);\r\n\r\n    user.lock_value = _value;\r\n    user.lock_endTime = _time;\r\n    LockIncrease(msg.sender, _value, _time);\r\n    return true;\r\n  }\r\n\r\n  // Employees of CashBet may decrease the locked token value and/or\r\n  // decrease the locked token expiration date.  These values may not\r\n  // ever be increased by an employee.\r\n  //\r\n  function decreaseLock(uint256 _value, uint256 _time, address _user) public only_employees(_user) returns (bool success) {\r\n    User storage user = users[_user];\r\n\r\n    // We don't modify expired locks (they are already 0)\r\n    require(user.lock_endTime > block.timestamp);\r\n    // Ensure nothing gets bigger.\r\n    require(_value <= user.lock_value);\r\n    require(_time <= user.lock_endTime);\r\n    // Ensure something has decreased.\r\n    require(_value < user.lock_value || _time < user.lock_endTime);\r\n\r\n    user.lock_value = _value;\r\n    user.lock_endTime = _time;\r\n    LockDecrease(_user, msg.sender, _value, _time);\r\n    return true;\r\n  }\r\n\r\n  function associate(bytes32 _opId, bytes32 _playerId) public playerid_iff_operatorid(_opId, _playerId) returns (bool success) {\r\n    User storage user = users[msg.sender];\r\n\r\n    // Players can associate their playerId once while the token is\r\n    // locked.  They can't change this association until the lock\r\n    // expires ...\r\n    require(user.lock_value == 0 ||\r\n            user.lock_endTime < block.timestamp ||\r\n            user.playerId == 0);\r\n\r\n    // OperatorId argument must be empty or in the approved operators set.\r\n    require(_opId == bytes32(0) || operators[_opId]);\r\n\r\n    user.operatorId = _opId;\r\n    user.playerId = _playerId;\r\n    Associate(msg.sender, msg.sender, _opId, _playerId);\r\n    return true;\r\n  }\r\n\r\n  function associationOf(address _addr) public view returns (bytes32 opId, bytes32 playerId) {\r\n    return (users[_addr].operatorId, users[_addr].playerId);\r\n  }\r\n\r\n  function setAssociation(address _user, bytes32 _opId, bytes32 _playerId) public only_employees(_user) playerid_iff_operatorid(_opId, _playerId) returns (bool success) {\r\n    User storage user = users[_user];\r\n\r\n    // Employees may only set opId to empty or something they are an\r\n    // employee of.\r\n    require(_opId == bytes32(0) || employees[msg.sender][_opId]);\r\n    \r\n    user.operatorId = _opId;\r\n    user.playerId = _playerId;\r\n    Associate(_user, msg.sender, _opId, _playerId);\r\n    return true;\r\n  }\r\n  \r\n  function setEmployee(address _addr, bytes32 _opId, bool _allowed) public only_owner {\r\n    employees[_addr][_opId] = _allowed;\r\n    Employee(_addr, _opId, _allowed);\r\n  }\r\n\r\n  function setOperator(bytes32 _opId, bool _allowed) public only_owner {\r\n    operators[_opId] = _allowed;\r\n    Operator(_opId, _allowed);\r\n  }\r\n\r\n  function setOwner(address _addr) public only_owner {\r\n    owner = _addr;\r\n  }\r\n\r\n  function burnTokens(uint256 _value) public value_less_than_unlocked_balance(msg.sender, _value) returns (bool success) {\r\n    User storage user = users[msg.sender];\r\n    user.balance = user.balance.sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    Burn(msg.sender, _value);\r\n    return true;\r\n  }\r\n\r\n  // Sets the contract address that this contract will migrate\r\n  // from when the optIn() interface is used.\r\n  //\r\n  function setMigrateFrom(address _addr) public only_owner {\r\n    require(migrateFrom == MigrationSource(0));\r\n    migrateFrom = MigrationSource(_addr);\r\n  }\r\n\r\n  // Sets the contract address that is allowed to call vacate on this\r\n  // contract.\r\n  //\r\n  function setMigrateTo(address _addr) public only_owner {\r\n    migrateTo = _addr;\r\n  }\r\n\r\n  // Called by a token holding address, this method migrates the\r\n  // tokens from an older version of the contract to this version.\r\n  // The migrated tokens are merged with any existing tokens in this\r\n  // version of the contract, resulting in the locked token count\r\n  // being set to the sum of locked tokens in the old and new\r\n  // contracts and the lock expiration being set the longest lock\r\n  // duration for this address in either contract.  The playerId is\r\n  // transferred unless it was already set in the new contract.\r\n  //\r\n  // NOTE - allowances (approve) are *not* transferred.  If you gave\r\n  // another address an allowance in the old contract you need to\r\n  // re-approve it in the new contract.\r\n  //\r\n  function optIn() public returns (bool success) {\r\n    require(migrateFrom != MigrationSource(0));\r\n    User storage user = users[msg.sender];\r\n    uint256 balance;\r\n    uint256 lock_value;\r\n    uint256 lock_endTime;\r\n    bytes32 opId;\r\n    bytes32 playerId;\r\n    (balance, lock_value, lock_endTime, opId, playerId) =\r\n        migrateFrom.vacate(msg.sender);\r\n\r\n    OptIn(msg.sender, balance);\r\n    \r\n    user.balance = user.balance.add(balance);\r\n\r\n    bool lockTimeIncreased = false;\r\n    user.lock_value = user.lock_value.add(lock_value);\r\n    if (user.lock_endTime < lock_endTime) {\r\n      user.lock_endTime = lock_endTime;\r\n      lockTimeIncreased = true;\r\n    }\r\n    if (lock_value > 0 || lockTimeIncreased) {\r\n      LockIncrease(msg.sender, user.lock_value, user.lock_endTime);\r\n    }\r\n\r\n    if (user.operatorId == bytes32(0) && opId != bytes32(0)) {\r\n      user.operatorId = opId;\r\n      user.playerId = playerId;\r\n      Associate(msg.sender, msg.sender, opId, playerId);\r\n    }\r\n\r\n    totalSupply_ = totalSupply_.add(balance);\r\n\r\n    return true;\r\n  }\r\n\r\n  // The vacate method is called by a newer version of the CashBetCoin\r\n  // contract to extract the token state for an address and migrate it\r\n  // to the new contract.\r\n  //\r\n  function vacate(address _addr) public returns (uint256 o_balance,\r\n                                                 uint256 o_lock_value,\r\n                                                 uint256 o_lock_endTime,\r\n                                                 bytes32 o_opId,\r\n                                                 bytes32 o_playerId) {\r\n    require(msg.sender == migrateTo);\r\n    User storage user = users[_addr];\r\n    require(user.balance > 0);\r\n\r\n    o_balance = user.balance;\r\n    o_lock_value = user.lock_value;\r\n    o_lock_endTime = user.lock_endTime;\r\n    o_opId = user.operatorId;\r\n    o_playerId = user.playerId;\r\n\r\n    totalSupply_ = totalSupply_.sub(user.balance);\r\n\r\n    user.balance = 0;\r\n    user.lock_value = 0;\r\n    user.lock_endTime = 0;\r\n    user.operatorId = bytes32(0);\r\n    user.playerId = bytes32(0);\r\n\r\n    Vacate(_addr, o_balance);\r\n  }\r\n\r\n  // Don't accept ETH.\r\n  function () public payable {\r\n    revert();\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrateFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMigrateFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_opId\",\"type\":\"bytes32\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setEmployee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"lockedEndTimeOf\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"employees\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"optIn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"increaseLock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"lockedValueOf\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMigrateTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_opId\",\"type\":\"bytes32\"},{\"name\":\"_playerId\",\"type\":\"bytes32\"}],\"name\":\"associate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_opId\",\"type\":\"bytes32\"},{\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrateTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"lock_value\",\"type\":\"uint256\"},{\"name\":\"lock_endTime\",\"type\":\"uint256\"},{\"name\":\"operatorId\",\"type\":\"bytes32\"},{\"name\":\"playerId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_opId\",\"type\":\"bytes32\"},{\"name\":\"_playerId\",\"type\":\"bytes32\"}],\"name\":\"setAssociation\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"operators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"vacate\",\"outputs\":[{\"name\":\"o_balance\",\"type\":\"uint256\"},{\"name\":\"o_lock_value\",\"type\":\"uint256\"},{\"name\":\"o_lock_endTime\",\"type\":\"uint256\"},{\"name\":\"o_opId\",\"type\":\"bytes32\"},{\"name\":\"o_playerId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"decreaseLock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"associationOf\",\"outputs\":[{\"name\":\"opId\",\"type\":\"bytes32\"},{\"name\":\"playerId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LockIncrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"employee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LockDecrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operatorId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerId\",\"type\":\"bytes32\"}],\"name\":\"Associate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OptIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Vacate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"empl\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operatorId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"Employee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operatorId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"Operator\",\"type\":\"event\"}]","ContractName":"CashBetCoin","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000098c445ad578000","Library":"","SwarmSource":"bzzr://f5804cf8f34bf96d33e3dab7c030b33af38748e7a81d75d9c6fb704b007abe2f"}]}