{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ManageableContract is Ownable {\r\n\r\n    mapping (address => bool) internal pf_manager; // SP maganer, Artificial Intelligence AI in the fuature\r\n    uint256[] internal pf_m_count; // clients tasks counter\r\n\r\n    mapping (address => bool) internal performers;\r\n    uint256[] internal pf_count; // clients tasks counter\r\n\r\n    mapping (address => bool) internal cr_manager; // client relations manager CR-Manager\r\n    uint256[] internal cr_count; // clients tasks counter\r\n\r\n    mapping (address => bool) internal clients;\r\n    uint256[] internal cli_count; // clients tasks counter\r\n\r\n    // MODIFIERS\r\n    modifier is_cli() {\r\n        require(clients[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier is_no_cli() {\r\n        require(clients[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier is_cr_mng() {\r\n        require(cr_manager[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier is_pfm() {\r\n        require(performers[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier is_pf_mng() {\r\n        require(pf_manager[msg.sender] == true);\r\n        _;\r\n    }\r\n    \r\n    modifier is_cli_trust() {\r\n        require(\r\n            owner == msg.sender            ||\r\n            cr_manager[msg.sender] == true\r\n            );\r\n        _;\r\n    }\r\n\r\n    modifier is_cli_or_trust() {\r\n        require(\r\n            clients[msg.sender] == true    ||\r\n            owner == msg.sender            ||\r\n            cr_manager[msg.sender] == true ||\r\n            performers[msg.sender] == true ||\r\n            pf_manager[msg.sender] == true\r\n            );\r\n        _;\r\n    }\r\n    \r\n    modifier is_trust() {\r\n        require(\r\n            owner == msg.sender            ||\r\n            cr_manager[msg.sender] == true ||\r\n            performers[msg.sender] == true ||\r\n            pf_manager[msg.sender] == true\r\n            );\r\n        _;\r\n    }\r\n\r\n    function setPFManager(address _manager) public onlyOwner\r\n        returns (bool, address)\r\n    {\r\n        pf_manager[_manager] = true;\r\n        pf_m_count.push(1);\r\n        return (true, _manager);\r\n    }\r\n    \r\n    function setPerformer(address _to) public onlyOwner\r\n        returns (bool, address)\r\n    {\r\n        performers[_to] = true;\r\n        pf_count.push(1);\r\n        return (true, _to);\r\n    }\r\n\r\n    function setCRManager(address _manager) public onlyOwner\r\n        returns (bool, address)\r\n    {\r\n        cr_manager[_manager] = true;\r\n        cr_count.push(1);\r\n        return (true, _manager);\r\n    }\r\n\r\n    /** get client task length */\r\n    function countPerformers() public view returns (uint256) {\r\n        return pf_m_count.length;\r\n    }\r\n\r\n    /** get client task length */\r\n    function countPerfManagers() public view returns (uint256) {\r\n        return pf_count.length;\r\n    }\r\n\r\n    /** get client task length */\r\n    function countCliManagers() public view returns (uint256) {\r\n        return cr_count.length;\r\n    }\r\n\r\n    /** get client task length */\r\n    function countCliTasks() public view returns (uint256) {\r\n        return cli_count.length;\r\n    }\r\n}\r\n\r\ncontract Converter {\r\n    \r\n        function bytes32ToBytes(bytes32 data) internal pure returns (bytes) {\r\n        uint i = 0;\r\n        while (i < 32 && uint(data[i]) != 0) {\r\n            ++i;\r\n        }\r\n        bytes memory result = new bytes(i);\r\n        i = 0;\r\n        while (i < 32 && data[i] != 0) {\r\n            result[i] = data[i];\r\n            ++i;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    /** @dev concat bytes array */\r\n    function bytes32ArrayToString(bytes32[] data) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(data.length * 32);\r\n        uint urlLength;\r\n        for (uint i=0; i<data.length; i++) {\r\n            for (uint j=0; j<32; j++) {\r\n                byte char = byte(bytes32(uint(data[i]) * 2 ** (8 * j)));\r\n                if (char != 0) {\r\n                    bytesString[urlLength] = char;\r\n                    urlLength += 1;\r\n                }\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(urlLength);\r\n        for (i=0; i<urlLength; i++) {\r\n            bytesStringTrimmed[i] = bytesString[i];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n    \r\n\r\n    function uintToBytes(uint v) internal pure returns (bytes32 ret) {\r\n        if (v == 0) {\r\n            ret = '0';\r\n        }\r\n        else {\r\n            while (v > 0) {\r\n                ret = bytes32(uint(ret) / (2 ** 8));\r\n                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\r\n                v /= 10;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    \r\n    function addressToBytes(address a) internal pure returns (bytes32 b){\r\n       assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n       }\r\n    }\r\n    \r\n    function bytesToBytes32(bytes b, uint offset) internal pure returns (bytes32) {\r\n      bytes32 out;\r\n    \r\n      for (uint i = 0; i < 32; i++) {\r\n        out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\r\n      }\r\n      return out;\r\n    }\r\n    \r\n    function bytes32ToString(bytes32 x) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n//Только чтобы с сайта мечты/задачи и статус исполнителя писался в смарт контракт\r\n/** warning add divide rule beatween accepted tasks and wiev rules for */\r\ncontract ClientsHandler is ManageableContract, Converter {\r\n    \r\n    function ClientsHandler() public {\r\n        setPFManager(owner);\r\n        setCRManager(owner);\r\n    }\r\n\r\n    string name = \"Clients Handler\";\r\n    string descibe = \"Clients data storage, contain methods for their obtaining and auditing\";\r\n    string version = \"0.28\";\r\n    \r\n    // @dev defaul validtor values\r\n    uint256 dml = 3;\r\n    uint256 dmxl = 100;\r\n    uint256 tml = 3;\r\n    uint256 tmxl = 1000;\r\n    \r\n    struct DreamStructData {\r\n        string  hashId;\r\n        string  dream;\r\n        string  target;\r\n        bool    isDream;\r\n        bool    hasPerformer;\r\n        address performer;\r\n        \r\n    }\r\n    \r\n    struct DreamStruct {\r\n        bool      isClient;\r\n        uint256[] key;\r\n\r\n    }\r\n    \r\n    mapping(address => mapping(uint256 => DreamStructData)) internal DSData;\r\n    mapping(address => DreamStruct) internal DStructs;\r\n    address[] public clientsList; //count users\r\n    \r\n    struct DreamStructDataP {\r\n        bool    isValid;\r\n        address client;\r\n        uint256 client_id;\r\n    }\r\n    \r\n    struct DreamStructP {\r\n        bool      isPerformer;\r\n        uint256[] key;\r\n    }\r\n    \r\n    mapping(address => mapping(uint256 => DreamStructDataP)) internal DSDataP;\r\n    mapping(address => DreamStructP) internal DStructsP;\r\n    address[] public performerList; //count users\r\n    \r\n    function watchPreferersTasks(address entityAddress, uint256 _id) public view {\r\n        DSDataP[entityAddress][_id];\r\n    }\r\n    \r\n    /** @dev return data of client's dream by id */\r\n    function getDStructData(address _who, uint256 _dream_id) \r\n        public \r\n        view \r\n        is_cli_or_trust \r\n        returns(string, string) \r\n    {\r\n        require(DSData[_who][_dream_id].isDream == true);\r\n        return (\r\n            DSData[_who][_dream_id].dream, \r\n            DSData[_who][_dream_id].target\r\n        );\r\n    }\r\n    \r\n    function isClient(address entityAddress) public constant returns(bool isIndeed) {\r\n        return DStructs[entityAddress].isClient;\r\n    }\r\n     \r\n    function countClients() public constant returns(uint256 cCount) {\r\n        return clientsList.length;\r\n    }\r\n    \r\n    function countAllCliDrm() public constant returns(uint256 acdCount) {\r\n        uint256 l = countClients();\r\n        uint256 r = 0;\r\n        for(uint256 i=0; i<l; i++) {\r\n            r += countCliDreams(clientsList[i]);\r\n        }\r\n        return r;\r\n    }\r\n    \r\n    function countCliDreams(address _addr) public view returns(uint256 cdCount) {\r\n        return DStructs[_addr].key.length;\r\n    }\r\n    \r\n    function countPerfClients(address _addr) public view returns(uint256 cdpCount) {\r\n        return DStructsP[_addr].key.length;\r\n    }\r\n    \r\n    function findAllCliWithPendingTask(address _addr) public returns(address[] noPerform) {\r\n        \r\n        uint256 l = countClients();\r\n        address[] storage r;\r\n        for(uint256 i=0; i<l; i++) {\r\n            uint256 ll = countCliDreams(clientsList[i]);\r\n            for(uint256 ii=0; ii<ll; ii++) {\r\n                uint256 li = ii + 1;\r\n                if(DSData[_addr][li].hasPerformer == false) {\r\n                    r.push(_addr);\r\n                }\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n    \r\n    /** @dev by the address of client set performer for pending task */\r\n    function findCliPendTAndSetPrfm(address _addr, address _performer) public returns(uint256) {\r\n\r\n        uint256 l = countCliDreams(_addr);\r\n        for(uint256 i=0; i<l; i++) {\r\n            uint256 li = i + 1;\r\n            if(DSData[_addr][li].hasPerformer == false) {\r\n                DSData[_addr][li].hasPerformer = true;\r\n                DSData[_addr][li].performer = _performer;\r\n                \r\n                uint256 pLen = countPerfClients(_performer);\r\n                uint256 iLen = pLen + 1;\r\n                DSDataP[_performer][iLen].client = _addr;\r\n                DSDataP[_performer][iLen].client_id = li;\r\n                DSDataP[_performer][iLen].isValid = true;\r\n                return performerList.push(_addr);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /** @dev change perferfer for uncomplited task if he is fail */\r\n    function changePrefererForTask(address _addr, uint256 _id, address _performer) public is_pf_mng returns(bool) {\r\n        require(performers[_performer] == true);\r\n        if(DSData[_addr][_id].isDream == true) {\r\n            DSData[_addr][_id].hasPerformer = true;\r\n            DSData[_addr][_id].performer = _performer;\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function setValidatorForND(\r\n        uint256 dream_min_len, \r\n        uint256 target_min_len,\r\n        uint256 dream_max_len, \r\n        uint256 target_max_len\r\n    )   \r\n        public \r\n        onlyOwner \r\n        returns (bool) \r\n    {\r\n        dml  = dream_min_len;\r\n        dmxl = dream_max_len;\r\n        tml  = target_min_len;\r\n        tmxl = target_max_len; \r\n        return true;\r\n    }\r\n    \r\n    modifier validatorD(string dream, string target) {\r\n        require(\r\n            (bytes(dream).length  >  dml)  &&\r\n            (bytes(dream).length  <= dmxl) &&\r\n            (bytes(target).length >  tml)  &&\r\n            (bytes(target).length <= tmxl)\r\n        );\r\n        _;\r\n    }\r\n    \r\n    /** @dev allow for all who want stand client */\r\n    function newDream(address entityAddress, string dream, string target) \r\n        public \r\n        validatorD(dream, target) \r\n        returns (uint256 rowNumber) \r\n    {\r\n        clients[entityAddress] = true;\r\n        DStructs[entityAddress].key.push(1);\r\n        DStructs[entityAddress].isClient = true;\r\n        uint256 cliLen = countCliDreams(entityAddress);\r\n        uint256 incLen = cliLen + 1;\r\n        DSData[entityAddress][incLen].dream = dream;\r\n        DSData[entityAddress][incLen].target = target;\r\n        DSData[entityAddress][incLen].isDream = true;\r\n        return clientsList.push(entityAddress);\r\n    }\r\n    \r\n    /** @dev allow for all who want stand client */\r\n    function updateDream(address entityAddress, string dream, string target) \r\n        public \r\n        is_cli_trust \r\n        validatorD(dream, target) \r\n        returns (bool success) \r\n    {\r\n        //DStructs[entityAddress].key.push(1);\r\n        uint256 cliLen = countCliDreams(entityAddress);\r\n        uint256 incLen = cliLen + 1;\r\n        DSData[entityAddress][incLen].dream = dream;\r\n        DSData[entityAddress][incLen].target = target;\r\n        DSData[entityAddress][incLen].isDream = true;\r\n        return true;\r\n    }\r\n        \r\n/*    function makeUnicTaskHashId(address who) internal view returns (bytes32) {\r\n        \r\n        string memory d = bytes32ToString(uintToBytes(block.difficulty));\r\n        string memory bh = bytes32ToString(block.blockhash(block.number));\r\n        string memory t = bytes32ToString(uintToBytes(block.timestamp));\r\n        string memory w = bytes32ToString(addressToBytes(who));\r\n        \r\n        string memory s1 = \" \".toSlice().concat(d.toSlice());  \r\n        string memory sb1 = string(bh.toSlice().concat(s1.toSlice()));\r\n        string memory s2 = \" \".toSlice().concat(sb1.toSlice());\r\n        string memory sb2 = string(t.toSlice().concat(s2.toSlice()));\r\n        string memory s3 = \" \".toSlice().concat(sb2.toSlice());\r\n        string memory sb3 = string(w.toSlice().concat(s3.toSlice()));\r\n        \r\n        return keccak256(sb3);\r\n    }*/\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setCRManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_performer\",\"type\":\"address\"}],\"name\":\"findCliPendTAndSetPrfm\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_dream_id\",\"type\":\"uint256\"}],\"name\":\"getDStructData\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"watchPreferersTasks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countCliTasks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countPerformers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"findAllCliWithPendingTask\",\"outputs\":[{\"name\":\"noPerform\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countCliManagers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"countPerfClients\",\"outputs\":[{\"name\":\"cdpCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countPerfManagers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"},{\"name\":\"dream\",\"type\":\"string\"},{\"name\":\"target\",\"type\":\"string\"}],\"name\":\"newDream\",\"outputs\":[{\"name\":\"rowNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"clientsList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dream_min_len\",\"type\":\"uint256\"},{\"name\":\"target_min_len\",\"type\":\"uint256\"},{\"name\":\"dream_max_len\",\"type\":\"uint256\"},{\"name\":\"target_max_len\",\"type\":\"uint256\"}],\"name\":\"setValidatorForND\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countClients\",\"outputs\":[{\"name\":\"cCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"}],\"name\":\"isClient\",\"outputs\":[{\"name\":\"isIndeed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"countCliDreams\",\"outputs\":[{\"name\":\"cdCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"},{\"name\":\"dream\",\"type\":\"string\"},{\"name\":\"target\",\"type\":\"string\"}],\"name\":\"updateDream\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setPFManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setPerformer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countAllCliDrm\",\"outputs\":[{\"name\":\"acdCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_performer\",\"type\":\"address\"}],\"name\":\"changePrefererForTask\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"performerList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ClientsHandler","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4332ca76008cca63a44dcadc4ec3ed32f29f515e88cd62946c2b60ab1bcedc6f"}]}