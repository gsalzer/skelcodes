{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Authorizable\r\n * @dev The Authorizable contract has authorized addresses, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"multiple user permissions\".\r\n */\r\ncontract Authorizable is Ownable {\r\n    \r\n    mapping(address => bool) public authorized;\r\n    event AuthorizationSet(address indexed addressAuthorized, bool indexed authorization);\r\n\r\n    /**\r\n     * @dev The Authorizable constructor sets the first `authorized` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Authorizable() public {\r\n        authorize(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the authorized.\r\n     */\r\n    modifier onlyAuthorized() {\r\n        require(authorized[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows \r\n     * @param _address The address to change authorization.\r\n     */\r\n    function authorize(address _address) public onlyOwner {\r\n        require(!authorized[_address]);\r\n        emit AuthorizationSet(_address, true);\r\n        authorized[_address] = true;\r\n    }\r\n    /**\r\n     * @dev Disallows\r\n     * @param _address The address to change authorization.\r\n     */\r\n    function deauthorize(address _address) public onlyOwner {\r\n        require(authorized[_address]);\r\n        emit AuthorizationSet(_address, false);\r\n        authorized[_address] = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title PrivateSaleExchangeRate interface\r\n */\r\ncontract PrivateSaleExchangeRate {\r\n    uint256 public rate;\r\n    uint256 public timestamp;\r\n    event UpdateUsdEthRate(uint _rate);\r\n    function updateUsdEthRate(uint _rate) public;\r\n    function getTokenAmount(uint256 _weiAmount) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title Whitelist interface\r\n */\r\ncontract Whitelist {\r\n    mapping(address => bool) whitelisted;\r\n    event AddToWhitelist(address _beneficiary);\r\n    event RemoveFromWhitelist(address _beneficiary);\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n    function addToWhitelist(address _beneficiary) public;\r\n    function removeFromWhitelist(address _beneficiary) public;\r\n}\r\n\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n// Crowdsale\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n\r\ncontract Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    // The token being sold\r\n    ERC20 public token;\r\n\r\n    // Address where funds are collected\r\n    address public wallet;\r\n\r\n    // How many token units a buyer gets per wei\r\n    PrivateSaleExchangeRate public rate;\r\n\r\n    // Amount of wei raised\r\n    uint256 public weiRaised;\r\n    \r\n    // Amount of wei raised (token)\r\n    uint256 public tokenRaised;\r\n\r\n    /**\r\n    * Event for token purchase logging\r\n    * @param purchaser who paid for the tokens\r\n    * @param beneficiary who got the tokens\r\n    * @param value weis paid for purchase\r\n    * @param amount amount of tokens purchased\r\n    */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    /**\r\n    * @param _rate Number of token units a buyer gets per wei\r\n    * @param _wallet Address where collected funds will be forwarded to\r\n    * @param _token Address of the token being sold\r\n    */\r\n    function Crowdsale(PrivateSaleExchangeRate _rate, address _wallet, ERC20 _token) public {\r\n        require(_rate.rate() > 0);\r\n        require(_token != address(0));\r\n        require(_wallet != address(0));\r\n\r\n        rate = _rate;\r\n        token = _token;\r\n        wallet = _wallet;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // Crowdsale external interface\r\n    // -----------------------------------------\r\n\r\n    /**\r\n    * @dev fallback function ***DO NOT OVERRIDE***\r\n    */\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev low level token purchase ***DO NOT OVERRIDE***\r\n    * @param _beneficiary Address performing the token purchase\r\n    */\r\n    function buyTokens(address _beneficiary) public payable {\r\n\r\n        uint256 weiAmount = msg.value;\r\n        \r\n         // calculate token amount to be created\r\n        uint256 tokenAmount = _getTokenAmount(weiAmount);\r\n        \r\n        _preValidatePurchase(_beneficiary, weiAmount, tokenAmount);\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokenRaised = tokenRaised.add(tokenAmount);\r\n\r\n        _processPurchase(_beneficiary, tokenAmount);\r\n        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokenAmount);\r\n\r\n        _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n        _forwardFunds();\r\n        _postValidatePurchase(_beneficiary, weiAmount);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // Internal interface (extensible)\r\n    // -----------------------------------------\r\n\r\n    /**\r\n    * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _weiAmount Value in wei involved in the purchase\r\n    */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal {\r\n        require(_beneficiary != address(0));\r\n        require(_weiAmount > 0);\r\n        require(_tokenAmount > 0);\r\n    }\r\n\r\n    /**\r\n    * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _weiAmount Value in wei involved in the purchase\r\n    */\r\n    function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\r\n        // optional override\r\n    }\r\n\r\n    /**\r\n    * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _tokenAmount Number of tokens to be emitted\r\n    */\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n        token.transfer(_beneficiary, _tokenAmount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n    * @param _beneficiary Address receiving the tokens\r\n    * @param _tokenAmount Number of tokens to be purchased\r\n    */\r\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n        _deliverTokens(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n    * @param _beneficiary Address receiving the tokens\r\n    * @param _weiAmount Value in wei involved in the purchase\r\n    */\r\n    function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\r\n        // optional override\r\n    }\r\n\r\n    /**\r\n    * @dev Override to extend the way in which ether is converted to tokens.\r\n    * @param _weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        return rate.getTokenAmount(_weiAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Determines how ETH is stored/forwarded on purchases.\r\n    */\r\n    function _forwardFunds() internal {\r\n        wallet.transfer(msg.value);\r\n    }\r\n}\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public openingTime;\r\n    uint256 public closingTime;\r\n\r\n    /**\r\n     * @dev Reverts if not in crowdsale time range. \r\n    */\r\n    modifier onlyWhileOpen {\r\n        require(now >= openingTime && now <= closingTime);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor, takes crowdsale opening and closing times.\r\n     * @param _openingTime Crowdsale opening time\r\n     * @param _closingTime Crowdsale closing time\r\n     */\r\n    function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\r\n        \r\n        require(_closingTime >= now);\r\n         \r\n        require(_closingTime >= _openingTime);\r\n        openingTime = _openingTime;\r\n        closingTime = _closingTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n     * @return Whether crowdsale period has elapsed\r\n     */\r\n    function hasClosed() public view returns (bool) {\r\n        return now > closingTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether the period in which the crowdsale is opened.\r\n     * @return Whether crowdsale period has elapsed\r\n     */\r\n    function hasOpening() public view returns (bool) {\r\n        return (now >= openingTime && now <= closingTime);\r\n    }\r\n  \r\n    /**\r\n     * @dev Extend parent behavior requiring to be within contributing period\r\n     * @param _beneficiary Token purchaser\r\n     * @param _weiAmount Amount of wei contributed\r\n     */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal onlyWhileOpen {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title AllowanceCrowdsale\r\n * @dev Extension of Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale.\r\n */\r\ncontract AllowanceCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n    address public tokenWallet;\r\n\r\n    /**\r\n    * @dev Constructor, takes token wallet address. \r\n    * @param _tokenWallet Address holding the tokens, which has approved allowance to the crowdsale\r\n    */\r\n    function AllowanceCrowdsale(address _tokenWallet) public {\r\n        require(_tokenWallet != address(0));\r\n        tokenWallet = _tokenWallet;\r\n    }\r\n\r\n    /**\r\n    * @dev Overrides parent behavior by transferring tokens from wallet.\r\n    * @param _beneficiary Token purchaser\r\n    * @param _tokenAmount Amount of tokens purchased\r\n    */\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n        token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title CappedCrowdsale\r\n * @dev Crowdsale with a limit for total contributions.\r\n */\r\ncontract CappedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public minWei;\r\n    uint256 public capToken;\r\n\r\n    /**\r\n    * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\r\n    * @param _capToken Max amount of token to be contributed\r\n    */\r\n    function CappedCrowdsale(uint256 _capToken, uint256 _minWei) public {\r\n        require(_minWei > 0);\r\n        require(_capToken > 0);\r\n        minWei = _minWei;\r\n        capToken = _capToken;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks whether the cap has been reached. \r\n    * @return Whether the cap was reached\r\n    */\r\n    function capReached() public view returns (bool) {\r\n        if(tokenRaised >= capToken) return true;\r\n        uint256 minTokens = rate.getTokenAmount(minWei);\r\n        if(capToken - tokenRaised <= minTokens) return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Extend parent behavior requiring purchase to respect the funding cap.\r\n    * @param _beneficiary Token purchaser\r\n    * @param _weiAmount Amount of wei contributed\r\n    */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\r\n        require(_weiAmount >= minWei);\r\n        require(tokenRaised.add(_tokenAmount) <= capToken);\r\n    }\r\n}\r\n\r\n/**\r\n * @title WhitelistedCrowdsale\r\n * @dev Crowdsale with a limit for total contributions.\r\n */\r\ncontract WhitelistedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    // Only KYC investor allowed to buy the token\r\n    Whitelist public whitelist;\r\n\r\n    /**\r\n    * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\r\n    * @param _whitelist whitelist contract\r\n    */\r\n    function WhitelistedCrowdsale(Whitelist _whitelist) public {\r\n        whitelist = _whitelist;\r\n    }\r\n\r\n    function isWhitelisted(address _address) public view returns (bool) {\r\n        return whitelist.isWhitelisted(_address);\r\n    }\r\n\r\n    /**\r\n    * @dev Extend parent behavior requiring purchase to respect the funding cap.\r\n    * @param _beneficiary Token purchaser\r\n    * @param _weiAmount Amount of wei contributed\r\n    */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\r\n        require(whitelist.isWhitelisted(_beneficiary));\r\n    }\r\n}\r\n\r\n/**\r\n * @title ClaimedCrowdsale\r\n * @dev Extension of Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale.\r\n */\r\ncontract ClaimCrowdsale is Crowdsale, Authorizable {\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 divider;\r\n    event ClaimToken(address indexed claimant, address indexed beneficiary, uint256 claimAmount);\r\n     \r\n    // Claim remain amount of token\r\n    //addressIndices not use index 0 \r\n    address[] public addressIndices;\r\n\r\n    // get amount of claim token\r\n    mapping(address => uint256) mapAddressToToken;\r\n    \r\n    //get index of addressIndices if = 0 >> not found\r\n    mapping(address => uint256) mapAddressToIndex;\r\n    \r\n     // Amount of wei waiting for claim (token)\r\n    uint256 public waitingForClaimTokens;\r\n\r\n    /**\r\n    * @dev Constructor, takes token wallet address. \r\n    */\r\n    function ClaimCrowdsale(uint256 _divider) public {\r\n        require(_divider > 0);\r\n        divider = _divider;\r\n        addressIndices.push(address(0));\r\n    }\r\n    \r\n    /**\r\n    * @dev Claim remained token after closed time\r\n    */\r\n    function claim(address _beneficiary) public onlyAuthorized {\r\n       \r\n        require(_beneficiary != address(0));\r\n        require(mapAddressToToken[_beneficiary] > 0);\r\n        \r\n        // remove from list\r\n        uint indexToBeDeleted = mapAddressToIndex[_beneficiary];\r\n        require(indexToBeDeleted != 0);\r\n        \r\n        uint arrayLength = addressIndices.length;\r\n        // if index to be deleted is not the last index, swap position.\r\n        if (indexToBeDeleted < arrayLength-1) {\r\n            // swap \r\n            addressIndices[indexToBeDeleted] = addressIndices[arrayLength-1];\r\n            mapAddressToIndex[addressIndices[indexToBeDeleted]] = indexToBeDeleted;\r\n        }\r\n         // we can now reduce the array length by 1\r\n        addressIndices.length--;\r\n        mapAddressToIndex[_beneficiary] = 0;\r\n        \r\n        // deliver token\r\n        uint256 _claimAmount = mapAddressToToken[_beneficiary];\r\n        mapAddressToToken[_beneficiary] = 0;\r\n        waitingForClaimTokens = waitingForClaimTokens.sub(_claimAmount);\r\n        emit ClaimToken(msg.sender, _beneficiary, _claimAmount);\r\n        \r\n        _deliverTokens(_beneficiary, _claimAmount);\r\n    }\r\n    \r\n    function checkClaimTokenByIndex(uint index) public view returns (uint256){\r\n        require(index >= 0);\r\n        require(index < addressIndices.length);\r\n        return checkClaimTokenByAddress(addressIndices[index]);\r\n    }\r\n    \r\n    function checkClaimTokenByAddress(address _beneficiary) public view returns (uint256){\r\n        require(_beneficiary != address(0));\r\n        return mapAddressToToken[_beneficiary];\r\n    }\r\n    function countClaimBackers()  public view returns (uint256) {\r\n        return addressIndices.length-1;\r\n    }\r\n    \r\n    function _addToClaimList(address _beneficiary, uint256 _claimAmount) internal {\r\n        require(_beneficiary != address(0));\r\n        require(_claimAmount > 0);\r\n        \r\n        if(mapAddressToToken[_beneficiary] == 0){\r\n            addressIndices.push(_beneficiary);\r\n            mapAddressToIndex[_beneficiary] = addressIndices.length-1;\r\n        }\r\n        waitingForClaimTokens = waitingForClaimTokens.add(_claimAmount);\r\n        mapAddressToToken[_beneficiary] = mapAddressToToken[_beneficiary].add(_claimAmount);\r\n    }\r\n\r\n   \r\n    /**\r\n     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n     * @param _beneficiary Address receiving the tokens\r\n     * @param _tokenAmount Number of tokens to be purchased\r\n     */\r\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n        \r\n        // To protect our private-sale investors who transfered eth via wallet from exchange.\r\n        // Instead of send all tokens amount back, the private-sale contract will send back in small portion of tokens (ppm). \r\n        // The full amount of tokens will be send later after the investor has confirmed received amount to us.\r\n        uint256 tokenSampleAmount = _tokenAmount.div(divider);\r\n\r\n        _addToClaimList(_beneficiary, _tokenAmount.sub(tokenSampleAmount));\r\n        _deliverTokens(_beneficiary, tokenSampleAmount);\r\n    }\r\n}\r\n\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n// ZMINE\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n\r\n/**\r\n * @title ZminePrivateSale\r\n */\r\ncontract ZminePrivateSale is ClaimCrowdsale\r\n                                , AllowanceCrowdsale\r\n                                , CappedCrowdsale\r\n                                , TimedCrowdsale\r\n                                , WhitelistedCrowdsale {\r\n    using SafeMath for uint256;\r\n    \r\n    /**\r\n     * @param _rate Number of token units a buyer gets per wei\r\n     * @param _whitelist Allowd address of buyer\r\n     * @param _wallet Address where collected funds will be forwarded to\r\n     * @param _token Address of the token being sold\r\n     */\r\n    function ZminePrivateSale(PrivateSaleExchangeRate _rate\r\n                                , Whitelist _whitelist\r\n                                , uint256 _capToken\r\n                                , uint256 _minWei\r\n                                , uint256 _openingTime\r\n                                , uint256 _closingTime\r\n                                , address _wallet\r\n                                , address _tokenWallet\r\n                                , ERC20 _token\r\n    ) public \r\n        Crowdsale(_rate, _wallet, _token) \r\n        ClaimCrowdsale(1000000)\r\n        AllowanceCrowdsale(_tokenWallet) \r\n        CappedCrowdsale(_capToken, _minWei)\r\n        TimedCrowdsale(_openingTime, _closingTime) \r\n        WhitelistedCrowdsale(_whitelist)\r\n    {\r\n        \r\n        \r\n        \r\n    }\r\n\r\n    function calculateTokenAmount(uint256 _weiAmount)  public view returns (uint256) {\r\n        return rate.getTokenAmount(_weiAmount);\r\n    }\r\n    \r\n     /**\r\n      * @dev Checks the amount of tokens left in the allowance.\r\n      * @return Amount of tokens left in the allowance\r\n      */\r\n    function remainingTokenForSale() public view returns (uint256) {\r\n        uint256 allowanceTokenLeft = (token.allowance(tokenWallet, this)).sub(waitingForClaimTokens);\r\n        uint256 balanceTokenLeft = (token.balanceOf(tokenWallet)).sub(waitingForClaimTokens);\r\n        if(allowanceTokenLeft < balanceTokenLeft) return allowanceTokenLeft;\r\n        return balanceTokenLeft;\r\n    }\r\n    \r\n     /**\r\n     * @dev Extend parent behavior requiring to be within contributing period\r\n     * @param _beneficiary Token purchaser\r\n     * @param _weiAmount Amount of wei contributed\r\n     */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount, uint256 _tokenAmount) internal {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\r\n        require(remainingTokenForSale().sub(_tokenAmount) >= 0);\r\n    }\r\n}\r\n\r\n// -----------------------------------------\r\n// -----------------------------------------\r\n// -----------------------------------------","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"checkClaimTokenByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitingForClaimTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countClaimBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"calculateTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"checkClaimTokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokenForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasOpening\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rate\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"address\"},{\"name\":\"_capToken\",\"type\":\"uint256\"},{\"name\":\"_minWei\",\"type\":\"uint256\"},{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_tokenWallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addressAuthorized\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"authorization\",\"type\":\"bool\"}],\"name\":\"AuthorizationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"ZminePrivateSale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002cbb9161049920eba8dc50e520d10605a7ec9584000000000000000000000000bea81fde2822b74674fac9fc743193358c6bb79200000000000000000000000000000000000000000052b7d2dcc80cd2e40000000000000000000000000000000000000000000000000000004563918244f40000000000000000000000000000000000000000000000000000000000005ac19cb0000000000000000000000000000000000000000000000000000000005ae929b000000000000000000000000000d59fec6c0a94b397dd57f601882eeed4d68eee00000000000000000000000000634717249dfea6c2783bbd26e8c0ff31455f38000000000000000000000000554ffc77f4251a9fb3c0e3590a6a205f8d4e067d","Library":"","SwarmSource":"bzzr://99b2a9963f13bc78a24a5031767ded06313794a4164250b5569fb6558967a37d"}]}