{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/land/LANDStorage.sol\r\n\r\ncontract LANDStorage {\r\n\r\n  mapping (address => uint) public latestPing;\r\n\r\n  uint256 constant clearLow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;\r\n  uint256 constant clearHigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n  uint256 constant factor = 0x100000000000000000000000000000000;\r\n\r\n  mapping (address => bool) public authorizedDeploy;\r\n\r\n  mapping (uint256 => address) public updateOperator;\r\n}\r\n\r\n// File: contracts/upgradable/OwnableStorage.sol\r\n\r\ncontract OwnableStorage {\r\n\r\n  address public owner;\r\n\r\n  function OwnableStorage() internal {\r\n    owner = msg.sender;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/upgradable/ProxyStorage.sol\r\n\r\ncontract ProxyStorage {\r\n\r\n  /**\r\n   * Current contract to which we are proxing\r\n   */\r\n  address public currentContract;\r\n  address public proxyOwner;\r\n}\r\n\r\n// File: erc821/contracts/AssetRegistryStorage.sol\r\n\r\ncontract AssetRegistryStorage {\r\n\r\n  string internal _name;\r\n  string internal _symbol;\r\n  string internal _description;\r\n\r\n  /**\r\n   * Stores the total count of assets managed by this registry\r\n   */\r\n  uint256 internal _count;\r\n\r\n  /**\r\n   * Stores an array of assets owned by a given account\r\n   */\r\n  mapping(address => uint256[]) internal _assetsOf;\r\n\r\n  /**\r\n   * Stores the current holder of an asset\r\n   */\r\n  mapping(uint256 => address) internal _holderOf;\r\n\r\n  /**\r\n   * Stores the index of an asset in the `_assetsOf` array of its holder\r\n   */\r\n  mapping(uint256 => uint256) internal _indexOfAsset;\r\n\r\n  /**\r\n   * Stores the data associated with an asset\r\n   */\r\n  mapping(uint256 => string) internal _assetData;\r\n\r\n  /**\r\n   * For a given account, for a given operator, store whether that operator is\r\n   * allowed to transfer and modify assets on behalf of them.\r\n   */\r\n  mapping(address => mapping(address => bool)) internal _operators;\r\n\r\n  /**\r\n   * Approval array\r\n   */\r\n  mapping(uint256 => address) internal _approval;\r\n}\r\n\r\n// File: contracts/Storage.sol\r\n\r\ncontract Storage is ProxyStorage, OwnableStorage, AssetRegistryStorage, LANDStorage {\r\n}\r\n\r\n// File: contracts/upgradable/IApplication.sol\r\n\r\ncontract IApplication {\r\n  function initialize(bytes data) public;\r\n}\r\n\r\n// File: contracts/upgradable/Ownable.sol\r\n\r\ncontract Ownable is Storage {\r\n\r\n  event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n  function bytesToAddress (bytes b) pure public returns (address) {\r\n    uint result = 0;\r\n    for (uint i = b.length-1; i+1 > 0; i--) {\r\n      uint c = uint(b[i]);\r\n      uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\r\n      result += to_inc;\r\n    }\r\n    return address(result);\r\n  }\r\n\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != owner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/land/ILANDRegistry.sol\r\n\r\ninterface ILANDRegistry {\r\n\r\n  // LAND can be assigned by the owner\r\n  function assignNewParcel(int x, int y, address beneficiary) external;\r\n  function assignMultipleParcels(int[] x, int[] y, address beneficiary) external;\r\n\r\n  // After one year, land can be claimed from an inactive public key\r\n  function ping() external;\r\n\r\n  // LAND-centric getters\r\n  function encodeTokenId(int x, int y) pure external returns (uint256);\r\n  function decodeTokenId(uint value) pure external returns (int, int);\r\n  function exists(int x, int y) view external returns (bool);\r\n  function ownerOfLand(int x, int y) view external returns (address);\r\n  function ownerOfLandMany(int[] x, int[] y) view external returns (address[]);\r\n  function landOf(address owner) view external returns (int[], int[]);\r\n  function landData(int x, int y) view external returns (string);\r\n\r\n  // Transfer LAND\r\n  function transferLand(int x, int y, address to) external;\r\n  function transferManyLand(int[] x, int[] y, address to) external;\r\n\r\n  // Update LAND\r\n  function updateLandData(int x, int y, string data) external;\r\n  function updateManyLandData(int[] x, int[] y, string data) external;\r\n\r\n  // Events\r\n\r\n  event Update(  \r\n    uint256 indexed assetId, \r\n    address indexed holder,  \r\n    address indexed operator,  \r\n    string data  \r\n  );\r\n\r\n  event UpdateOperator(\r\n    uint256 indexed assetId, \r\n    address indexed operator\r\n  );\r\n}\r\n\r\n// File: erc821/contracts/ERC165.sol\r\n\r\ninterface ERC165 {\r\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n// File: contracts/land/IMetadataHolder.sol\r\n\r\ncontract IMetadataHolder is ERC165 {\r\n  function getMetadata(uint256 /* assetId */) external view returns (string);\r\n}\r\n\r\n// File: erc821/contracts/IERC721Base.sol\r\n\r\ninterface IERC721Base {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  // function exists(uint256 assetId) external view returns (bool);\r\n  function ownerOf(uint256 assetId) external view returns (address);\r\n\r\n  function balanceOf(address holder) external view returns (uint256);\r\n\r\n  function safeTransferFrom(address from, address to, uint256 assetId) external;\r\n  function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) external;\r\n\r\n  function transferFrom(address from, address to, uint256 assetId) external;\r\n\r\n  function approve(address operator, uint256 assetId) external;\r\n  function setApprovalForAll(address operator, bool authorized) external;\r\n\r\n  function getApprovedAddress(uint256 assetId) external view returns (address);\r\n  function isApprovedForAll(address operator, address assetOwner) external view returns (bool);\r\n\r\n  function isAuthorized(address operator, uint256 assetId) external view returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed assetId,\r\n    address operator,\r\n    bytes userData\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed operator,\r\n    address indexed holder,\r\n    bool authorized\r\n  );\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed operator,\r\n    uint256 indexed assetId\r\n  );\r\n}\r\n\r\n// File: erc821/contracts/IERC721Receiver.sol\r\n\r\ninterface IERC721Receiver {\r\n  function onERC721Received(\r\n    address _oldOwner,\r\n    uint256 _tokenId,\r\n    bytes   _userData\r\n  ) external returns (bytes4);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: erc821/contracts/ERC721Base.sol\r\n\r\ncontract ERC721Base is AssetRegistryStorage, IERC721Base, ERC165 {\r\n  using SafeMath for uint256;\r\n\r\n  //\r\n  // Global Getters\r\n  //\r\n\r\n  /**\r\n   * @dev Gets the total amount of assets stored by the contract\r\n   * @return uint256 representing the total amount of assets\r\n   */\r\n  function totalSupply() external view returns (uint256) {\r\n    return _totalSupply();\r\n  }\r\n  function _totalSupply() internal view returns (uint256) {\r\n    return _count;\r\n  }\r\n\r\n  //\r\n  // Asset-centric getter functions\r\n  //\r\n\r\n  /**\r\n   * @dev Queries what address owns an asset. This method does not throw.\r\n   * In order to check if the asset exists, use the `exists` function or check if the\r\n   * return value of this call is `0`.\r\n   * @return uint256 the assetId\r\n   */\r\n  function ownerOf(uint256 assetId) external view returns (address) {\r\n    return _ownerOf(assetId);\r\n  }\r\n  function _ownerOf(uint256 assetId) internal view returns (address) {\r\n    return _holderOf[assetId];\r\n  }\r\n\r\n  //\r\n  // Holder-centric getter functions\r\n  //\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address owner) external view returns (uint256) {\r\n    return _balanceOf(owner);\r\n  }\r\n  function _balanceOf(address owner) internal view returns (uint256) {\r\n    return _assetsOf[owner].length;\r\n  }\r\n\r\n  //\r\n  // Authorization getters\r\n  //\r\n\r\n  /**\r\n   * @dev Query whether an address has been authorized to move any assets on behalf of someone else\r\n   * @param operator the address that might be authorized\r\n   * @param assetHolder the address that provided the authorization\r\n   * @return bool true if the operator has been authorized to move any assets\r\n   */\r\n  function isApprovedForAll(address operator, address assetHolder)\r\n    external view returns (bool)\r\n  {\r\n    return _isApprovedForAll(assetHolder, operator);\r\n  }\r\n  function _isApprovedForAll(address assetHolder, address operator)\r\n    internal view returns (bool)\r\n  {\r\n    return _operators[assetHolder][operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Query what address has been particularly authorized to move an asset\r\n   * @param assetId the asset to be queried for\r\n   * @return bool true if the asset has been approved by the holder\r\n   */\r\n  function getApproved(uint256 assetId) external view returns (address) {\r\n    return _getApprovedAddress(assetId);\r\n  }\r\n  function getApprovedAddress(uint256 assetId) external view returns (address) {\r\n    return _getApprovedAddress(assetId);\r\n  }\r\n  function _getApprovedAddress(uint256 assetId) internal view returns (address) {\r\n    return _approval[assetId];\r\n  }\r\n\r\n  /**\r\n   * @dev Query if an operator can move an asset.\r\n   * @param operator the address that might be authorized\r\n   * @param assetId the asset that has been `approved` for transfer\r\n   * @return bool true if the asset has been approved by the holder\r\n   */\r\n  function isAuthorized(address operator, uint256 assetId) external view returns (bool) {\r\n    return _isAuthorized(operator, assetId);\r\n  }\r\n  function _isAuthorized(address operator, uint256 assetId) internal view returns (bool)\r\n  {\r\n    require(operator != 0);\r\n    address owner = _ownerOf(assetId);\r\n    if (operator == owner) {\r\n      return true;\r\n    }\r\n    return _isApprovedForAll(owner, operator) || _getApprovedAddress(assetId) == operator;\r\n  }\r\n\r\n  //\r\n  // Authorization\r\n  //\r\n\r\n  /**\r\n   * @dev Authorize a third party operator to manage (send) msg.sender's asset\r\n   * @param operator address to be approved\r\n   * @param authorized bool set to true to authorize, false to withdraw authorization\r\n   */\r\n  function setApprovalForAll(address operator, bool authorized) external {\r\n    return _setApprovalForAll(operator, authorized);\r\n  }\r\n  function _setApprovalForAll(address operator, bool authorized) internal {\r\n    if (authorized) {\r\n      require(!_isApprovedForAll(msg.sender, operator));\r\n      _addAuthorization(operator, msg.sender);\r\n    } else {\r\n      require(_isApprovedForAll(msg.sender, operator));\r\n      _clearAuthorization(operator, msg.sender);\r\n    }\r\n    emit ApprovalForAll(msg.sender, operator, authorized);\r\n  }\r\n\r\n  /**\r\n   * @dev Authorize a third party operator to manage one particular asset\r\n   * @param operator address to be approved\r\n   * @param assetId asset to approve\r\n   */\r\n  function approve(address operator, uint256 assetId) external {\r\n    address holder = _ownerOf(assetId);\r\n    require(msg.sender == holder || _isApprovedForAll(msg.sender, holder));\r\n    require(operator != holder);\r\n\r\n    if (_getApprovedAddress(assetId) != operator) {\r\n      _approval[assetId] = operator;\r\n      emit Approval(holder, operator, assetId);\r\n    }\r\n  }\r\n\r\n  function _addAuthorization(address operator, address holder) private {\r\n    _operators[holder][operator] = true;\r\n  }\r\n\r\n  function _clearAuthorization(address operator, address holder) private {\r\n    _operators[holder][operator] = false;\r\n  }\r\n\r\n  //\r\n  // Internal Operations\r\n  //\r\n\r\n  function _addAssetTo(address to, uint256 assetId) internal {\r\n    _holderOf[assetId] = to;\r\n\r\n    uint256 length = _balanceOf(to);\r\n\r\n    _assetsOf[to].push(assetId);\r\n\r\n    _indexOfAsset[assetId] = length;\r\n\r\n    _count = _count.add(1);\r\n  }\r\n\r\n  function _removeAssetFrom(address from, uint256 assetId) internal {\r\n    uint256 assetIndex = _indexOfAsset[assetId];\r\n    uint256 lastAssetIndex = _balanceOf(from).sub(1);\r\n    uint256 lastAssetId = _assetsOf[from][lastAssetIndex];\r\n\r\n    _holderOf[assetId] = 0;\r\n\r\n    // Insert the last asset into the position previously occupied by the asset to be removed\r\n    _assetsOf[from][assetIndex] = lastAssetId;\r\n\r\n    // Resize the array\r\n    _assetsOf[from][lastAssetIndex] = 0;\r\n    _assetsOf[from].length--;\r\n\r\n    // Remove the array if no more assets are owned to prevent pollution\r\n    if (_assetsOf[from].length == 0) {\r\n      delete _assetsOf[from];\r\n    }\r\n\r\n    // Update the index of positions for the asset\r\n    _indexOfAsset[assetId] = 0;\r\n    _indexOfAsset[lastAssetId] = assetIndex;\r\n\r\n    _count = _count.sub(1);\r\n  }\r\n\r\n  function _clearApproval(address holder, uint256 assetId) internal {\r\n    if (_ownerOf(assetId) == holder && _approval[assetId] != 0) {\r\n      _approval[assetId] = 0;\r\n      emit Approval(holder, 0, assetId);\r\n    }\r\n  }\r\n\r\n  //\r\n  // Supply-altering functions\r\n  //\r\n\r\n  function _generate(uint256 assetId, address beneficiary) internal {\r\n    require(_holderOf[assetId] == 0);\r\n\r\n    _addAssetTo(beneficiary, assetId);\r\n\r\n    emit Transfer(0, beneficiary, assetId, msg.sender, '');\r\n  }\r\n\r\n  function _destroy(uint256 assetId) internal {\r\n    address holder = _holderOf[assetId];\r\n    require(holder != 0);\r\n\r\n    _removeAssetFrom(holder, assetId);\r\n\r\n    emit Transfer(holder, 0, assetId, msg.sender, '');\r\n  }\r\n\r\n  //\r\n  // Transaction related operations\r\n  //\r\n\r\n  modifier onlyHolder(uint256 assetId) {\r\n    require(_ownerOf(assetId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAuthorized(uint256 assetId) {\r\n    require(_isAuthorized(msg.sender, assetId));\r\n    _;\r\n  }\r\n\r\n  modifier isCurrentOwner(address from, uint256 assetId) {\r\n    require(_ownerOf(assetId) == from);\r\n    _;\r\n  }\r\n\r\n  modifier isDestinataryDefined(address destinatary) {\r\n    require(destinatary != 0);\r\n    _;\r\n  }\r\n\r\n  modifier destinataryIsNotHolder(uint256 assetId, address to) {\r\n    require(_ownerOf(assetId) != to);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Alias of `safeTransferFrom(from, to, assetId, '')`\r\n   *\r\n   * @param from address that currently owns an asset\r\n   * @param to address to receive the ownership of the asset\r\n   * @param assetId uint256 ID of the asset to be transferred\r\n   */\r\n  function safeTransferFrom(address from, address to, uint256 assetId) external {\r\n    return _doTransferFrom(from, to, assetId, '', msg.sender, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Securely transfers the ownership of a given asset from one address to\r\n   * another address, calling the method `onNFTReceived` on the target address if\r\n   * there's code associated with it\r\n   *\r\n   * @param from address that currently owns an asset\r\n   * @param to address to receive the ownership of the asset\r\n   * @param assetId uint256 ID of the asset to be transferred\r\n   * @param userData bytes arbitrary user information to attach to this transfer\r\n   */\r\n  function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) external {\r\n    return _doTransferFrom(from, to, assetId, userData, msg.sender, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given asset from one address to another address\r\n   * Warning! This function does not attempt to verify that the target address can send\r\n   * tokens.\r\n   *\r\n   * @param from address sending the asset\r\n   * @param to address to receive the ownership of the asset\r\n   * @param assetId uint256 ID of the asset to be transferred\r\n   */\r\n  function transferFrom(address from, address to, uint256 assetId) external {\r\n    return _doTransferFrom(from, to, assetId, '', msg.sender, false);\r\n  }\r\n\r\n  function _doTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 assetId,\r\n    bytes userData,\r\n    address operator,\r\n    bool doCheck\r\n  )\r\n    onlyAuthorized(assetId)\r\n    internal\r\n  {\r\n    _moveToken(from, to, assetId, userData, operator, doCheck);\r\n  }\r\n\r\n  function _moveToken(\r\n    address from,\r\n    address to,\r\n    uint256 assetId,\r\n    bytes userData,\r\n    address operator,\r\n    bool doCheck\r\n  )\r\n    isDestinataryDefined(to)\r\n    destinataryIsNotHolder(assetId, to)\r\n    isCurrentOwner(from, assetId)\r\n    internal\r\n  {\r\n    address holder = _holderOf[assetId];\r\n    _removeAssetFrom(holder, assetId);\r\n    _clearApproval(holder, assetId);\r\n    _addAssetTo(to, assetId);\r\n\r\n    if (doCheck && _isContract(to)) {\r\n      // Equals to bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))\r\n      bytes4 ERC721_RECEIVED = bytes4(0xf0b9e5ba);\r\n      require(\r\n        IERC721Receiver(to).onERC721Received(\r\n          holder, assetId, userData\r\n        ) == ERC721_RECEIVED\r\n      );\r\n    }\r\n\r\n    emit Transfer(holder, to, assetId, operator, userData);\r\n  }\r\n\r\n  /**\r\n   * Internal function that moves an asset from one holder to another\r\n   */\r\n\r\n  /**\r\n   * @dev Returns `true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise\r\n   * @param  _interfaceID The interface identifier, as specified in ERC-165\r\n   */\r\n  function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n\r\n    if (_interfaceID == 0xffffffff) {\r\n      return false;\r\n    }\r\n    return (_interfaceID == 0x01ffc9a7) || (_interfaceID == 0x7c0633c6);\r\n  }\r\n\r\n  //\r\n  // Utilities\r\n  //\r\n\r\n  function _isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n// File: erc821/contracts/IERC721Enumerable.sol\r\n\r\ncontract IERC721Enumerable {\r\n\r\n  /**\r\n   * @notice Enumerate active tokens\r\n   * @dev Throws if `index` >= `totalSupply()`, otherwise SHALL NOT throw.\r\n   * @param index A counter less than `totalSupply()`\r\n   * @return The identifier for the `index`th asset, (sort order not\r\n   *  specified)\r\n   */\r\n  // TODO (eordano): Not implemented\r\n  // function tokenByIndex(uint256 index) public view returns (uint256 _assetId);\r\n\r\n  /**\r\n   * @notice Count of owners which own at least one asset\r\n   *  Must not throw.\r\n   * @return A count of the number of owners which own asset\r\n   */\r\n  // TODO (eordano): Not implemented\r\n  // function countOfOwners() public view returns (uint256 _count);\r\n\r\n  /**\r\n   * @notice Enumerate owners\r\n   * @dev Throws if `index` >= `countOfOwners()`, otherwise must not throw.\r\n   * @param index A counter less than `countOfOwners()`\r\n   * @return The address of the `index`th owner (sort order not specified)\r\n   */\r\n  // TODO (eordano): Not implemented\r\n  // function ownerByIndex(uint256 index) public view returns (address owner);\r\n\r\n  /**\r\n   * @notice Get all tokens of a given address\r\n   * @dev This is not intended to be used on-chain\r\n   * @param owner address of the owner to query\r\n   * @return a list of all assetIds of a user\r\n   */\r\n  function tokensOf(address owner) external view returns (uint256[]);\r\n\r\n  /**\r\n   * @notice Enumerate tokens assigned to an owner\r\n   * @dev Throws if `index` >= `balanceOf(owner)` or if\r\n   *  `owner` is the zero address, representing invalid assets.\r\n   *  Otherwise this must not throw.\r\n   * @param owner An address where we are interested in assets owned by them\r\n   * @param index A counter less than `balanceOf(owner)`\r\n   * @return The identifier for the `index`th asset assigned to `owner`,\r\n   *   (sort order not specified)\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address owner, uint256 index\r\n  ) external view returns (uint256 tokenId);\r\n}\r\n\r\n// File: erc821/contracts/ERC721Enumerable.sol\r\n\r\ncontract ERC721Enumerable is AssetRegistryStorage, IERC721Enumerable {\r\n\r\n  /**\r\n   * @notice Get all tokens of a given address\r\n   * @dev This is not intended to be used on-chain\r\n   * @param owner address of the owner to query\r\n   * @return a list of all assetIds of a user\r\n   */\r\n  function tokensOf(address owner) external view returns (uint256[]) {\r\n    return _assetsOf[owner];\r\n  }\r\n\r\n  /**\r\n   * @notice Enumerate tokens assigned to an owner\r\n   * @dev Throws if `index` >= `balanceOf(owner)` or if\r\n   *  `owner` is the zero address, representing invalid assets.\r\n   *  Otherwise this must not throw.\r\n   * @param owner An address where we are interested in assets owned by them\r\n   * @param index A counter less than `balanceOf(owner)`\r\n   * @return The identifier for the `index`th asset assigned to `owner`,\r\n   *   (sort order not specified)\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address owner, uint256 index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 assetId)\r\n  {\r\n    require(index < _assetsOf[owner].length);\r\n    require(index < (1<<127));\r\n    return _assetsOf[owner][index];\r\n  }\r\n\r\n}\r\n\r\n// File: erc821/contracts/IERC721Metadata.sol\r\n\r\ncontract IERC721Metadata {\r\n\r\n  /**\r\n   * @notice A descriptive name for a collection of NFTs in this contract\r\n   */\r\n  function name() external view returns (string);\r\n\r\n  /**\r\n   * @notice An abbreviated name for NFTs in this contract\r\n   */\r\n  function symbol() external view returns (string);\r\n\r\n  /**\r\n   * @notice A description of what this DAR is used for\r\n   */\r\n  function description() external view returns (string);\r\n\r\n  /**\r\n   * Stores arbitrary info about a token\r\n   */\r\n  function tokenMetadata(uint256 assetId) external view returns (string);\r\n}\r\n\r\n// File: erc821/contracts/ERC721Metadata.sol\r\n\r\ncontract ERC721Metadata is AssetRegistryStorage, IERC721Metadata {\r\n  function name() external view returns (string) {\r\n    return _name;\r\n  }\r\n  function symbol() external view returns (string) {\r\n    return _symbol;\r\n  }\r\n  function description() external view returns (string) {\r\n    return _description;\r\n  }\r\n  function tokenMetadata(uint256 assetId) external view returns (string) {\r\n    return _assetData[assetId];\r\n  }\r\n  function _update(uint256 assetId, string data) internal {\r\n    _assetData[assetId] = data;\r\n  }\r\n}\r\n\r\n// File: erc821/contracts/FullAssetRegistry.sol\r\n\r\ncontract FullAssetRegistry is ERC721Base, ERC721Enumerable, ERC721Metadata {\r\n  constructor() public {\r\n  }\r\n\r\n  /**\r\n   * @dev Method to check if an asset identified by the given id exists under this DAR.\r\n   * @return uint256 the assetId\r\n   */\r\n  function exists(uint256 assetId) external view returns (bool) {\r\n    return _exists(assetId);\r\n  }\r\n  function _exists(uint256 assetId) internal view returns (bool) {\r\n    return _holderOf[assetId] != 0;\r\n  }\r\n\r\n  function decimals() external pure returns (uint256) {\r\n    return 0;\r\n  }\r\n}\r\n\r\n// File: contracts/land/LANDRegistry.sol\r\n\r\ncontract LANDRegistry is Storage,\r\n  Ownable, FullAssetRegistry,\r\n  ILANDRegistry\r\n{\r\n\r\n  bytes4 public GET_METADATA = bytes4(keccak256(\"getMetadata(uint256)\"));\r\n\r\n  function initialize(bytes) external {\r\n    _name = \"Decentraland LAND\";\r\n    _symbol = \"LAND\";\r\n    _description = \"Contract that stores the Decentraland LAND registry\";\r\n  }\r\n\r\n  modifier onlyProxyOwner() {\r\n    require(msg.sender == proxyOwner, \"this function can only be called by the proxy owner\");\r\n    _;\r\n  }\r\n\r\n  //\r\n  // LAND Create and destroy\r\n  //\r\n\r\n  modifier onlyOwnerOf(uint256 assetId) {\r\n    require(msg.sender == _ownerOf(assetId), \"this function can only be called by the owner of the asset\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyUpdateAuthorized(uint256 tokenId) {\r\n    require(msg.sender == _ownerOf(tokenId) || _isUpdateAuthorized(msg.sender, tokenId), \"msg.sender is not authorized to update\");\r\n    _;\r\n  }\r\n\r\n  function isUpdateAuthorized(address operator, uint256 assetId) external view returns (bool) {\r\n    return _isUpdateAuthorized(operator, assetId);\r\n  }\r\n  function _isUpdateAuthorized(address operator, uint256 assetId) internal view returns (bool) {\r\n    return operator == _ownerOf(assetId) || updateOperator[assetId] == operator;\r\n  }\r\n\r\n  function authorizeDeploy(address beneficiary) external onlyProxyOwner {\r\n    authorizedDeploy[beneficiary] = true;\r\n  }\r\n  function forbidDeploy(address beneficiary) external onlyProxyOwner {\r\n    authorizedDeploy[beneficiary] = false;\r\n  }\r\n\r\n  function assignNewParcel(int x, int y, address beneficiary) external onlyProxyOwner {\r\n    _generate(_encodeTokenId(x, y), beneficiary);\r\n  }\r\n\r\n  function assignMultipleParcels(int[] x, int[] y, address beneficiary) external onlyProxyOwner {\r\n    for (uint i = 0; i < x.length; i++) {\r\n      _generate(_encodeTokenId(x[i], y[i]), beneficiary);\r\n    }\r\n  }\r\n\r\n  //\r\n  // Inactive keys after 1 year lose ownership\r\n  //\r\n\r\n  function ping() external {\r\n    latestPing[msg.sender] = now;\r\n  }\r\n\r\n  function setLatestToNow(address user) external {\r\n    require(msg.sender == proxyOwner || _isApprovedForAll(msg.sender, user));\r\n    latestPing[user] = now;\r\n  }\r\n\r\n  //\r\n  // LAND Getters\r\n  //\r\n\r\n  function encodeTokenId(int x, int y) pure external returns (uint) {\r\n    return _encodeTokenId(x, y);\r\n  }\r\n  function _encodeTokenId(int x, int y) pure internal returns (uint result) {\r\n    require(-1000000 < x && x < 1000000 && -1000000 < y && y < 1000000);\r\n    return _unsafeEncodeTokenId(x, y);\r\n  }\r\n  function _unsafeEncodeTokenId(int x, int y) pure internal returns (uint) {\r\n    return ((uint(x) * factor) & clearLow) | (uint(y) & clearHigh);\r\n  }\r\n\r\n  function decodeTokenId(uint value) pure external returns (int, int) {\r\n    return _decodeTokenId(value);\r\n  }\r\n  function _unsafeDecodeTokenId(uint value) pure internal returns (int x, int y) {\r\n    x = expandNegative128BitCast((value & clearLow) >> 128);\r\n    y = expandNegative128BitCast(value & clearHigh);\r\n  }\r\n  function _decodeTokenId(uint value) pure internal returns (int x, int y) {\r\n    (x, y) = _unsafeDecodeTokenId(value);\r\n    require(-1000000 < x && x < 1000000 && -1000000 < y && y < 1000000);\r\n  }\r\n\r\n  function expandNegative128BitCast(uint value) pure internal returns (int) {\r\n    if (value & (1<<127) != 0) {\r\n      return int(value | clearLow);\r\n    }\r\n    return int(value);\r\n  }\r\n\r\n  function exists(int x, int y) view external returns (bool) {\r\n    return _exists(x, y);\r\n  }\r\n  function _exists(int x, int y) view internal returns (bool) {\r\n    return _exists(_encodeTokenId(x, y));\r\n  }\r\n\r\n  function ownerOfLand(int x, int y) view external returns (address) {\r\n    return _ownerOfLand(x, y);\r\n  }\r\n  function _ownerOfLand(int x, int y) view internal returns (address) {\r\n    return _ownerOf(_encodeTokenId(x, y));\r\n  }\r\n\r\n  function ownerOfLandMany(int[] x, int[] y) view external returns (address[]) {\r\n    require(x.length > 0);\r\n    require(x.length == y.length);\r\n\r\n    address[] memory addrs = new address[](x.length);\r\n    for (uint i = 0; i < x.length; i++) {\r\n      addrs[i] = _ownerOfLand(x[i], y[i]);\r\n    }\r\n\r\n    return addrs;\r\n  }\r\n\r\n  function landOf(address owner) external view returns (int[], int[]) {\r\n    uint256 len = _assetsOf[owner].length;\r\n    int[] memory x = new int[](len);\r\n    int[] memory y = new int[](len);\r\n\r\n    int assetX;\r\n    int assetY;\r\n    for (uint i = 0; i < len; i++) {\r\n      (assetX, assetY) = _decodeTokenId(_assetsOf[owner][i]);\r\n      x[i] = assetX;\r\n      y[i] = assetY;\r\n    }\r\n\r\n    return (x, y);\r\n  }\r\n\r\n  function tokenMetadata(uint256 assetId) external view returns (string) {\r\n    return _tokenMetadata(assetId);\r\n  }\r\n\r\n  function _tokenMetadata(uint256 assetId) internal view returns (string) {\r\n    address _owner = _ownerOf(assetId);\r\n    if (_isContract(_owner)) {\r\n      if (ERC165(_owner).supportsInterface(GET_METADATA)) {\r\n        return IMetadataHolder(_owner).getMetadata(assetId);\r\n      }\r\n    }\r\n    return _assetData[assetId];\r\n  }\r\n\r\n  function landData(int x, int y) external view returns (string) {\r\n    return _tokenMetadata(_encodeTokenId(x, y));\r\n  }\r\n\r\n  //\r\n  // LAND Transfer\r\n  //\r\n\r\n  function transferLand(int x, int y, address to) external {\r\n    uint256 tokenId = _encodeTokenId(x, y);\r\n    _doTransferFrom(_ownerOf(tokenId), to, tokenId, '', msg.sender, true);\r\n  }\r\n\r\n  function transferManyLand(int[] x, int[] y, address to) external {\r\n    require(x.length > 0);\r\n    require(x.length == y.length);\r\n\r\n    for (uint i = 0; i < x.length; i++) {\r\n      uint256 tokenId = _encodeTokenId(x[i], y[i]);\r\n      _doTransferFrom(_ownerOf(tokenId), to, tokenId, '', msg.sender, true);\r\n    }\r\n  }\r\n\r\n  function setUpdateOperator(uint256 assetId, address operator) external onlyOwnerOf(assetId) {\r\n    updateOperator[assetId] = operator;\r\n    emit UpdateOperator(assetId, operator);\r\n  }\r\n\r\n  //\r\n  // LAND Update\r\n  //\r\n\r\n  function updateLandData(int x, int y, string data) external onlyUpdateAuthorized (_encodeTokenId(x, y)) {\r\n    return _updateLandData(x, y, data);\r\n  }\r\n  function _updateLandData(int x, int y, string data) internal onlyUpdateAuthorized (_encodeTokenId(x, y)) {\r\n    uint256 assetId = _encodeTokenId(x, y);\r\n    _update(assetId, data);\r\n\r\n    emit Update(assetId, _holderOf[assetId], msg.sender, data);\r\n  }\r\n\r\n  function updateManyLandData(int[] x, int[] y, string data) external {\r\n    require(x.length > 0);\r\n    require(x.length == y.length);\r\n    for (uint i = 0; i < x.length; i++) {\r\n      _updateLandData(x[i], y[i], data);\r\n    }\r\n  }\r\n\r\n  function _doTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 assetId,\r\n    bytes userData,\r\n    address operator,\r\n    bool doCheck\r\n  ) internal {\r\n    updateOperator[assetId] = address(0);\r\n    super._doTransferFrom(from, to, assetId, userData, operator, doCheck);\r\n  }\r\n\r\n  function _isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"ownerOfLand\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"setLatestToNow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"y\",\"type\":\"int256\"},{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"assignNewParcel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"int256[]\"},{\"name\":\"y\",\"type\":\"int256[]\"}],\"name\":\"ownerOfLandMany\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestPing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"int256[]\"},{\"name\":\"y\",\"type\":\"int256[]\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"updateManyLandData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedDeploy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"authorizeDeploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"y\",\"type\":\"int256\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferLand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"bytesToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"landData\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"int256[]\"},{\"name\":\"y\",\"type\":\"int256[]\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferManyLand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ping\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GET_METADATA\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"isUpdateAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"encodeTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decodeTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"int256[]\"},{\"name\":\"y\",\"type\":\"int256[]\"},{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"assignMultipleParcels\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"landOf\",\"outputs\":[{\"name\":\"\",\"type\":\"int256[]\"},{\"name\":\"\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"updateOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"setUpdateOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"y\",\"type\":\"int256\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"updateLandData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"assetHolder\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"getApprovedAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"forbidDeploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"string\"}],\"name\":\"Update\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"UpdateOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"LANDRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d1e458334c08e50e081e663a6754820cb9607821c7b476026d8534b8340e2cc0"}]}