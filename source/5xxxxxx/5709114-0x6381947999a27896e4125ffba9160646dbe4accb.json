{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\t\r\n\taddress public owner;\r\n\taddress public potentialOwner;\r\n\t\r\n\t\r\n\tevent OwnershipRemoved(address indexed previousOwner);\r\n\tevent OwnershipTransfer(address indexed previousOwner, address indexed newOwner);\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyPotentialOwner() {\r\n\t\trequire(msg.sender == potentialOwner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address of potential new owner to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransfer(owner, newOwner);\r\n\t\tpotentialOwner = newOwner;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allow the potential owner confirm ownership of the contract.\r\n\t */\r\n\tfunction confirmOwnership() public onlyPotentialOwner {\r\n\t\temit OwnershipTransferred(owner, potentialOwner);\r\n\t\towner = potentialOwner;\r\n\t\tpotentialOwner = address(0);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Remove the contract owner permanently\r\n\t */\r\n\tfunction removeOwnership() public onlyOwner {\r\n\t\temit OwnershipRemoved(owner);\r\n\t\towner = address(0);\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title AddressTools\r\n * @dev Useful tools for address type\r\n */\r\nlibrary AddressTools {\r\n\t\r\n\t/**\r\n\t* @dev Returns true if given address is the contract address, otherwise - returns false\r\n\t*/\r\n\tfunction isContract(address a) internal view returns (bool) {\r\n\t\tif(a == address(0)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tuint codeSize;\r\n\t\t// solium-disable-next-line security/no-inline-assembly\r\n\t\tassembly {\r\n\t\t\tcodeSize := extcodesize(a)\r\n\t\t}\r\n\t\t\r\n\t\tif(codeSize > 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n* @title Contract that will work with ERC223 tokens\r\n*/\r\ncontract ERC223Reciever {\r\n\t\r\n\t/**\r\n\t * @dev Standard ERC223 function that will handle incoming token transfers\r\n\t *\r\n\t * @param _from address  Token sender address\r\n\t * @param _value uint256 Amount of tokens\r\n\t * @param _data bytes  Transaction metadata\r\n\t */\r\n\tfunction tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);\r\n\t\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\t\r\n\t/**\r\n\t* @dev Multiplies two numbers, throws on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Integer division of two numbers, truncating the quotient.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a / b;\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Powers the first number to the second, throws on overflow.\r\n\t*/\r\n\tfunction pow(uint a, uint b) internal pure returns (uint) {\r\n\t\tif (b == 0) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tuint c = a ** b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Multiplies the given number by 10**decimals\r\n\t */\r\n\tfunction withDecimals(uint number, uint decimals) internal pure returns (uint) {\r\n\t\treturn mul(number, pow(10, decimals));\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n\tfunction totalSupply() public view returns (uint256);\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n\t\r\n\tusing SafeMath for uint256;\r\n\t\r\n\tmapping(address => uint256) public balances;\r\n\t\r\n\tuint256 public totalSupply_;\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev total number of tokens in existence\r\n\t*/\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn totalSupply_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev transfer token for a specified address\r\n\t* @param _to The address to transfer to.\r\n\t* @param _value The amount to be transferred.\r\n\t*/\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\t\t\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param _owner The address to query the the balance of.\r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t*/\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\t\r\n\tevent Burn(address indexed burner, uint256 value);\r\n\t\r\n\t/**\r\n\t * @dev Burns a specific amount of tokens.\r\n\t * @param _value The amount of token to be burned.\r\n\t */\r\n\tfunction burn(uint256 _value) public {\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\t\t// no need to require value <= totalSupply, since that would imply the\r\n\t\t// sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\t\t\r\n\t\taddress burner = msg.sender;\r\n\t\tbalances[burner] = balances[burner].sub(_value);\r\n\t\ttotalSupply_ = totalSupply_.sub(_value);\r\n\t\temit Burn(burner, _value);\r\n\t\temit Transfer(burner, address(0), _value);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) public view returns (uint256);\r\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\tfunction approve(address spender, uint256 value) public returns (bool);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\t\r\n\tmapping (address => mapping (address => uint256)) internal allowed;\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Transfer tokens from one address to another\r\n\t * @param _from address The address which you want to send tokens from\r\n\t * @param _to address The address which you want to transfer to\r\n\t * @param _value uint256 the amount of tokens to be transferred\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[_from]);\r\n\t\trequire(_value <= allowed[_from][msg.sender]);\r\n\t\t\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\t *\r\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _value The amount of tokens to be spent.\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t * @param _owner address The address which owns the funds.\r\n\t * @param _spender address The address which will spend the funds.\r\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\r\n\t */\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To increment\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _addedValue The amount of tokens to increase the allowance by.\r\n\t */\r\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To decrement\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n\t */\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n\t\tuint oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title ERC223 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/223\r\n */\r\ncontract ERC223 is ERC20 {\r\n\tfunction transfer(address to, uint256 value, bytes data) public returns (bool);\r\n\tevent ERC223Transfer(address indexed from, address indexed to, uint256 value, bytes data);\r\n}\r\n\r\n/**\r\n * @title (Not)Reference implementation of the ERC223 standard token.\r\n */\r\ncontract ERC223Token is ERC223, StandardToken {\r\n\t\r\n\tusing AddressTools for address;\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Transfer the specified amount of tokens to the specified address.\r\n\t *      Invokes the `tokenFallback` function if the recipient is a contract.\r\n\t *      The token transfer fails if the recipient is a contract\r\n\t *      but does not implement the `tokenFallback` function\r\n\t *      or the fallback function to receive funds.\r\n\t *\r\n\t * @param _to    Receiver address\r\n\t * @param _value Amount of tokens that will be transferred\r\n\t * @param _data  Transaction metadata\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\r\n\t\treturn executeTransfer(_to, _value, _data);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Transfer the specified amount of tokens to the specified address.\r\n\t *      This function works the same with the previous one\r\n\t *      but doesn\"t contain `_data` param.\r\n\t *      Added due to backwards compatibility reasons.\r\n\t *\r\n\t * @param _to    Receiver address\r\n\t * @param _value Amount of tokens that will be transferred\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\tbytes memory _data;\r\n\t\t\r\n\t\treturn executeTransfer(_to, _value, _data);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Makes execution of the token fallback method from if reciever address is contract\r\n\t */\r\n\tfunction executeTokenFallback(address _to, uint256 _value, bytes _data) private returns (bool) {\r\n\t\tERC223Reciever receiver = ERC223Reciever(_to);\r\n\t\t\r\n\t\treturn receiver.tokenFallback(msg.sender, _value, _data);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Makes execution of the tokens transfer method from super class\r\n\t */\r\n\tfunction executeTransfer(address _to, uint256 _value, bytes _data) private returns (bool) {\r\n\t\trequire(super.transfer(_to, _value));\r\n\t\t\r\n\t\tif(_to.isContract()) {\r\n\t\t\trequire(executeTokenFallback(_to, _value, _data));\r\n\t\t\temit ERC223Transfer(msg.sender, _to, _value, _data);\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title UKTTokenBasic\r\n * @dev UKTTokenBasic interface\r\n */\r\ncontract UKTTokenBasic is ERC223, BurnableToken {\r\n\t\r\n\tbool public isControlled = false;\r\n\tbool public isConfigured = false;\r\n\tbool public isAllocated = false;\r\n\t\r\n\t// mapping of string labels to initial allocated addresses\r\n\tmapping(bytes32 => address) public allocationAddressesTypes;\r\n\t// mapping of addresses to time lock period\r\n\tmapping(address => uint32) public timelockedAddresses;\r\n\t// mapping of addresses to lock flag\r\n\tmapping(address => bool) public lockedAddresses;\r\n\t\r\n\t\r\n\tfunction setConfiguration(string _name, string _symbol, uint _totalSupply) external returns (bool);\r\n\tfunction setInitialAllocation(address[] addresses, bytes32[] addressesTypes, uint[] amounts) external returns (bool);\r\n\tfunction setInitialAllocationLock(address allocationAddress ) external returns (bool);\r\n\tfunction setInitialAllocationUnlock(address allocationAddress ) external returns (bool);\r\n\tfunction setInitialAllocationTimelock(address allocationAddress, uint32 timelockTillDate ) external returns (bool);\r\n\t\r\n\t// fires when the token contract becomes controlled\r\n\tevent Controlled(address indexed tokenController);\r\n\t// fires when the token contract becomes configured\r\n\tevent Configured(string tokenName, string tokenSymbol, uint totalSupply);\r\n\tevent InitiallyAllocated(address indexed owner, bytes32 addressType, uint balance);\r\n\tevent InitiallAllocationLocked(address indexed owner);\r\n\tevent InitiallAllocationUnlocked(address indexed owner);\r\n\tevent InitiallAllocationTimelocked(address indexed owner, uint32 timestamp);\r\n\t\r\n}\r\n\r\n/**\r\n * @title  Basic UKT token contract\r\n * @author  Oleg Levshin <levshin@ucoz-team.net>\r\n */\r\ncontract UKTToken is UKTTokenBasic, ERC223Token, Ownable {\r\n\t\r\n\tusing AddressTools for address;\r\n\t\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint public constant decimals = 18;\r\n\t\r\n\t// address of the controller contract\r\n\taddress public controller;\r\n\t\r\n\t\r\n\tmodifier onlyController() {\r\n\t\trequire(msg.sender == controller);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier onlyUnlocked(address _address) {\r\n\t\taddress from = _address != address(0) ? _address : msg.sender;\r\n\t\trequire(\r\n\t\t\tlockedAddresses[from] == false &&\r\n\t\t\t(\r\n\t\t\t\ttimelockedAddresses[from] == 0 ||\r\n\t\t\t\ttimelockedAddresses[from] <= now\r\n\t\t\t)\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Sets the controller contract address and removes token contract ownership\r\n\t */\r\n\tfunction setController(\r\n\t\taddress _controller\r\n\t) public onlyOwner {\r\n\t\t// cannot be invoked after initial setting\r\n\t\trequire(!isControlled);\r\n\t\t// _controller should be an address of the smart contract\r\n\t\trequire(_controller.isContract());\r\n\t\t\r\n\t\tcontroller = _controller;\r\n\t\tremoveOwnership();\r\n\t\t\r\n\t\temit Controlled(controller);\r\n\t\t\r\n\t\tisControlled = true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Sets the token contract configuration\r\n\t */\r\n\tfunction setConfiguration(\r\n\t\tstring _name,\r\n\t\tstring _symbol,\r\n\t\tuint _totalSupply\r\n\t) external onlyController returns (bool) {\r\n\t\t// not configured yet\r\n\t\trequire(!isConfigured);\r\n\t\t// not empty name of the token\r\n\t\trequire(bytes(_name).length > 0);\r\n\t\t// not empty ticker symbol of the token\r\n\t\trequire(bytes(_symbol).length > 0);\r\n\t\t// pre-defined total supply\r\n\t\trequire(_totalSupply > 0);\r\n\t\t\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t\ttotalSupply_ = _totalSupply.withDecimals(decimals);\r\n\t\t\r\n\t\temit Configured(name, symbol, totalSupply_);\r\n\t\t\r\n\t\tisConfigured = true;\r\n\t\t\r\n\t\treturn isConfigured;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Sets initial balances allocation\r\n\t */\r\n\tfunction setInitialAllocation(\r\n\t\taddress[] addresses,\r\n\t\tbytes32[] addressesTypes,\r\n\t\tuint[] amounts\r\n\t) external onlyController returns (bool) {\r\n\t\t// cannot be invoked after initial allocation\r\n\t\trequire(!isAllocated);\r\n\t\t// the array of addresses should be the same length as the array of addresses types\r\n\t\trequire(addresses.length == addressesTypes.length);\r\n\t\t// the array of addresses should be the same length as the array of allocating amounts\r\n\t\trequire(addresses.length == amounts.length);\r\n\t\t// sum of the allocating balances should be equal to totalSupply\r\n\t\tuint balancesSum = 0;\r\n\t\tfor(uint b = 0; b < amounts.length; b++) {\r\n\t\t\tbalancesSum = balancesSum.add(amounts[b]);\r\n\t\t}\r\n\t\trequire(balancesSum.withDecimals(decimals) == totalSupply_);\r\n\t\t\r\n\t\tfor(uint a = 0; a < addresses.length; a++) {\r\n\t\t\tbalances[addresses[a]] = amounts[a].withDecimals(decimals);\r\n\t\t\tallocationAddressesTypes[addressesTypes[a]] = addresses[a];\r\n\t\t\temit InitiallyAllocated(addresses[a], addressesTypes[a], balanceOf(addresses[a]));\r\n\t\t}\r\n\t\t\r\n\t\tisAllocated = true;\r\n\t\t\r\n\t\treturn isAllocated;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Sets lock for given allocation address\r\n\t */\r\n\tfunction setInitialAllocationLock(\r\n\t\taddress allocationAddress\r\n\t) external onlyController returns (bool) {\r\n\t\trequire(allocationAddress != address(0));\r\n\t\t\r\n\t\tlockedAddresses[allocationAddress] = true;\r\n\t\t\r\n\t\temit InitiallAllocationLocked(allocationAddress);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Sets unlock for given allocation address\r\n\t */\r\n\tfunction setInitialAllocationUnlock(\r\n\t\taddress allocationAddress\r\n\t) external onlyController returns (bool) {\r\n\t\trequire(allocationAddress != address(0));\r\n\t\t\r\n\t\tlockedAddresses[allocationAddress] = false;\r\n\t\t\r\n\t\temit InitiallAllocationUnlocked(allocationAddress);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Sets time lock for given allocation address\r\n\t */\r\n\tfunction setInitialAllocationTimelock(\r\n\t\taddress allocationAddress,\r\n\t\tuint32 timelockTillDate\r\n\t) external onlyController returns (bool) {\r\n\t\trequire(allocationAddress != address(0));\r\n\t\trequire(timelockTillDate >= now);\r\n\t\t\r\n\t\ttimelockedAddresses[allocationAddress] = timelockTillDate;\r\n\t\t\r\n\t\temit InitiallAllocationTimelocked(allocationAddress, timelockTillDate);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allows transfer of the tokens after locking conditions checking\r\n\t */\r\n\tfunction transfer(\r\n\t\taddress _to,\r\n\t\tuint256 _value\r\n\t) public onlyUnlocked(address(0)) returns (bool) {\r\n\t\trequire(super.transfer(_to, _value));\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allows transfer of the tokens (with additional _data) after locking conditions checking\r\n\t */\r\n\tfunction transfer(\r\n\t\taddress _to,\r\n\t\tuint256 _value,\r\n\t\tbytes _data\r\n\t) public onlyUnlocked(address(0)) returns (bool) {\r\n\t\trequire(super.transfer(_to, _value, _data));\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allows transfer of the tokens after locking conditions checking\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _value\r\n\t) public onlyUnlocked(_from) returns (bool) {\r\n\t\trequire(super.transferFrom(_from, _to, _value));\r\n\t\treturn true;\r\n\t}\r\n\t\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allocationAddress\",\"type\":\"address\"}],\"name\":\"setInitialAllocationUnlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allocationAddress\",\"type\":\"address\"},{\"name\":\"timelockTillDate\",\"type\":\"uint32\"}],\"name\":\"setInitialAllocationTimelock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"allocationAddressesTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potentialOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"addressesTypes\",\"type\":\"bytes32[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"setInitialAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allocationAddress\",\"type\":\"address\"}],\"name\":\"setInitialAllocationLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isConfigured\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"setConfiguration\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isControlled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"timelockedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenController\",\"type\":\"address\"}],\"name\":\"Controlled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"Configured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"addressType\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"InitiallyAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"InitiallAllocationLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"InitiallAllocationUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"InitiallAllocationTimelocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC223Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"UKTToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cfb3ffea447d917f7e80d0811f9d0194c8d3f872ae5baa6ffaac06db4b60c4b2"}]}