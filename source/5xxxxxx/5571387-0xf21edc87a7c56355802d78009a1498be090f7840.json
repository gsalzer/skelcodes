{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint256);\r\n    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public returns (bool success);\r\n    function approve(address spender, uint256 tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\r\n\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        require(owner == msg.sender);\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title AllstocksCrowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override \r\n * the methods to add functionality. Consider using 'super' where appropiate to concatenate\r\n * behavior.\r\n */\r\n\r\ncontract AllstocksCrowdsale is Owned {\r\n  using SafeMath for uint256;\r\n\r\n  // The token being sold\r\n  //ERC20Interface public token;\r\n  address public token;\r\n\r\n  // Address where funds are collected\r\n  address public ethFundDeposit; \r\n\r\n  // How many token units a buyer gets per wei // starts with 625 Allstocks tokens per 1 ETH\r\n  uint256 public tokenExchangeRate = 625;                         \r\n  \r\n  // 25m hard cap\r\n  uint256 public tokenCreationCap =  25 * (10**6) * 10**18; // 25m maximum; \r\n\r\n  //2.5m softcap\r\n  uint256 public tokenCreationMin =  25 * (10**5) * 10**18; // 2.5m minimum\r\n\r\n  // Amount of wei raised\r\n  uint256 public _raised = 0;\r\n  \r\n  // switched to true in after setup\r\n  bool public isActive = false;                 \r\n \r\n  //start time \r\n  uint256 public fundingStartTime = 0;\r\n   \r\n  //end time\r\n  uint256 public fundingEndTime = 0;\r\n\r\n  // switched to true in operational state\r\n  bool public isFinalized = false; \r\n  \r\n  //refund list - will hold a list of all contributers \r\n  mapping(address => uint256) public refunds;\r\n\r\n  /**\r\n   * Event for token Allocate logging\r\n   * @param allocator for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenAllocated(address indexed allocator, address indexed beneficiary, uint256 amount);\r\n\r\n  event LogRefund(address indexed _to, uint256 _value);\r\n\r\n  constructor() public {\r\n      tokenExchangeRate = 625;\r\n  }\r\n\r\n  function setup (uint256 _fundingStartTime, uint256 _fundingEndTime, address _token) onlyOwner external {\r\n    require (isActive == false); \r\n    require (isFinalized == false); \t\t\t        \t   \r\n    require (msg.sender == owner);                // locks finalize to the ultimate ETH owner\r\n    require(_fundingStartTime > 0);\r\n    require(_fundingEndTime > 0 && _fundingEndTime > _fundingStartTime);\r\n    require(_token != address(0));\r\n\r\n    isFinalized = false;                          // controls pre through crowdsale state\r\n    isActive = true;                              // set sale status to be true\r\n    ethFundDeposit = owner;                       // set ETH wallet owner \r\n    fundingStartTime = _fundingStartTime;\r\n    fundingEndTime = _fundingEndTime;\r\n    //set token\r\n    token = _token;\r\n  }\r\n\r\n  /// @dev send funding to safe wallet if minimum is reached \r\n  function vaultFunds() public onlyOwner {\r\n    require(msg.sender == owner);                    // Allstocks double chack\r\n    require(_raised >= tokenCreationMin);            // have to sell minimum to move to operational \r\n    ethFundDeposit.transfer(address(this).balance);  // send the eth to Allstocks\r\n  }  \r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender, msg.value);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary, uint256 _value) internal {\r\n    _preValidatePurchase(_beneficiary, _value);\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(_value);\r\n    // update state\r\n    uint256 checkedSupply = _raised.add(tokens);\r\n    //check that we are not over cap\r\n    require(checkedSupply <= tokenCreationCap);\r\n    _raised = checkedSupply;\r\n    bool mined = ERC20Interface(token).mint(_beneficiary, tokens);\r\n    require(mined);\r\n    //add sent eth to refunds list\r\n    refunds[_beneficiary] = _value.add(refunds[_beneficiary]);  // safeAdd \r\n    emit TokenAllocated(this, _beneficiary, tokens); // log it\r\n    //forward funds to deposite only in minimum was reached\r\n    if(_raised >= tokenCreationMin) {\r\n      _forwardFunds();\r\n    }\r\n  }\r\n\r\n  // @dev method for manageing bonus phases \r\n\tfunction setRate(uint256 _value) external onlyOwner {\r\n    require (isActive == true);\r\n    require(msg.sender == owner); // Allstocks double check owner   \r\n    // Range is set between 500 to 625, based on the bonus program stated in whitepaper.\r\n    // Upper range is set to 1500 (x3 times margin based on ETH price) .\r\n    require (_value >= 500 && _value <= 1500); \r\n    tokenExchangeRate = _value;\r\n  }\r\n\r\n  // @dev method for allocate tokens to beneficiary account \r\n  function allocate(address _beneficiary, uint256 _value) public onlyOwner returns (bool success) {\r\n    require (isActive == true);          // sale have to be active\r\n    require (_value > 0);                // value must be greater then 0 \r\n    require (msg.sender == owner);       // Allstocks double chack \r\n    require(_beneficiary != address(0)); // none empty address\r\n    uint256 checkedSupply = _raised.add(_value); \r\n    require(checkedSupply <= tokenCreationCap); //check that we dont over cap\r\n    _raised = checkedSupply;\r\n    bool sent = ERC20Interface(token).mint(_beneficiary, _value); // mint using ERC20 interface\r\n    require(sent); \r\n    emit TokenAllocated(this, _beneficiary, _value); // log it\r\n    return true;\r\n  }\r\n\r\n  //claim back token ownership \r\n  function transferTokenOwnership(address _newTokenOwner) public onlyOwner {\r\n    require(_newTokenOwner != address(0));\r\n    require(owner == msg.sender);\r\n    Owned(token).transferOwnership(_newTokenOwner);\r\n  }\r\n\r\n  /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n  function refund() external {\r\n    require (isFinalized == false);  // prevents refund if operational\r\n    require (isActive == true);      // only if sale is active\r\n    require (now > fundingEndTime);  // prevents refund until sale period is over\r\n    require(_raised < tokenCreationMin);  // no refunds if we sold enough\r\n    require(msg.sender != owner);         // Allstocks not entitled to a refund\r\n    //get contribution amount in eth\r\n    uint256 ethValRefund = refunds[msg.sender];\r\n    //refund should be greater then zero\r\n    require(ethValRefund > 0);\r\n    //zero sender refund balance\r\n    refunds[msg.sender] = 0;\r\n    //check user balance\r\n    uint256 allstocksVal = ERC20Interface(token).balanceOf(msg.sender);\r\n    //substruct from total raised - please notice main assumption is that tokens are not tradeble at this stage.\r\n    _raised = _raised.sub(allstocksVal);               // extra safe\r\n    //send eth back to user\r\n    msg.sender.transfer(ethValRefund);                 // if you're using a contract; make sure it works with .send gas limits\r\n    emit LogRefund(msg.sender, ethValRefund);          // log it\r\n  }\r\n\r\n   /// @dev Ends the funding period and sends the ETH home\r\n  function finalize() external onlyOwner {\r\n    require (isFinalized == false);\r\n    require(msg.sender == owner); // Allstocks double chack  \r\n    require(_raised >= tokenCreationMin);  // have to sell minimum to move to operational\r\n    require(_raised > 0);\r\n\r\n    if (now < fundingEndTime) {    //if try to close before end time, check that we reach max cap\r\n      require(_raised >= tokenCreationCap);\r\n    }\r\n    else \r\n      require(now >= fundingEndTime); //allow finilize only after time ends\r\n    \r\n    //transfer token ownership back to original owner\r\n    transferTokenOwnership(owner);\r\n    // move to operational\r\n    isFinalized = true;\r\n    vaultFunds();  // send the eth to Allstocks\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) view internal {\r\n    require(now >= fundingStartTime);\r\n    require(now < fundingEndTime); \r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n    return _weiAmount.mul(tokenExchangeRate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    ethFundDeposit.transfer(msg.value);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_fundingStartTime\",\"type\":\"uint256\"},{\"name\":\"_fundingEndTime\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTokenOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"vaultFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"allocate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_raised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"allocator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AllstocksCrowdsale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1c33262d42051211ecc64c850de6aa1cd460e5411e1d63713862e227b2880fdd"}]}