{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n//pragma experimental ABIEncoderV2;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/registry/BancorBuyer.sol\r\n\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\ncontract IMultiToken {\r\n    function changeableTokenCount() external view returns(uint16 count);\r\n    function tokens(uint256 i) public view returns(ERC20);\r\n    function weights(address t) public view returns(uint256);\r\n    function totalSupply() public view returns(uint256);\r\n    function mint(address _to, uint256 _amount) public;\r\n}\r\n\r\n\r\ncontract BancorBuyer {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) public tokenBalances; // [owner][token]\r\n\r\n    function sumWeightOfMultiToken(IMultiToken mtkn) public view returns(uint256 sumWeight) {\r\n        for (uint i = mtkn.changeableTokenCount(); i > 0; i--) {\r\n            sumWeight += mtkn.weights(mtkn.tokens(i - 1));\r\n        }\r\n    }\r\n    \r\n    function allBalances(address _account, address[] _tokens) public view returns(uint256[]) {\r\n        uint256[] memory tokenValues = new uint256[](_tokens.length);\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            tokenValues[i] = tokenBalances[_account][_tokens[i]];\r\n        }\r\n        return tokenValues;\r\n    }\r\n\r\n    function deposit(address _beneficiary, address[] _tokens, uint256[] _tokenValues) payable external {\r\n        if (msg.value > 0) {\r\n            balances[_beneficiary] = balances[_beneficiary].add(msg.value);\r\n        }\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            ERC20 token = ERC20(_tokens[i]);\r\n            uint256 tokenValue = _tokenValues[i];\r\n\r\n            uint256 balance = token.balanceOf(this);\r\n            token.transferFrom(msg.sender, this, tokenValue);\r\n            require(token.balanceOf(this) == balance.add(tokenValue));\r\n            tokenBalances[_beneficiary][token] = tokenBalances[_beneficiary][token].add(tokenValue);\r\n        }\r\n    }\r\n    \r\n    function withdrawInternal(address _to, uint256 _value, address[] _tokens, uint256[] _tokenValues) internal {\r\n        if (_value > 0) {\r\n            _to.transfer(_value);\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        }\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            ERC20 token = ERC20(_tokens[i]);\r\n            uint256 tokenValue = _tokenValues[i];\r\n\r\n            uint256 tokenBalance = token.balanceOf(this);\r\n            token.transfer(_to, tokenValue);\r\n            require(token.balanceOf(this) == tokenBalance.sub(tokenValue));\r\n            tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(tokenValue);\r\n        }\r\n    }\r\n\r\n    function withdraw(address _to, uint256 _value, address[] _tokens, uint256[] _tokenValues) external {\r\n        withdrawInternal(_to, _value, _tokens, _tokenValues);\r\n    }\r\n    \r\n    function withdrawAll(address _to, address[] _tokens) external {\r\n        uint256[] memory tokenValues = allBalances(msg.sender, _tokens);\r\n        withdrawInternal(_to, balances[msg.sender], _tokens, tokenValues);\r\n    }\r\n\r\n    // function approveAndCall(address _to, uint256 _value, bytes _data, address[] _tokens, uint256[] _tokenValues) payable external {\r\n    //     uint256[] memory tempBalances = new uint256[](_tokens.length);\r\n    //     for (uint i = 0; i < _tokens.length; i++) {\r\n    //         ERC20 token = ERC20(_tokens[i]);\r\n    //         uint256 tokenValue = _tokenValues[i];\r\n\r\n    //         tempBalances[i] = token.balanceOf(this);\r\n    //         token.approve(_to, tokenValue);\r\n    //     }\r\n\r\n    //     require(_to.call.value(_value)(_data));\r\n    //     balances[msg.sender] = balances[msg.sender].add(msg.value).sub(_value);\r\n\r\n    //     for (i = 0; i < _tokens.length; i++) {\r\n    //         token = ERC20(_tokens[i]);\r\n    //         tokenValue = _tokenValues[i];\r\n\r\n    //         uint256 tokenSpent = tempBalances[i].sub(token.balanceOf(this));\r\n    //         tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(tokenSpent);\r\n    //         token.approve(_to, 0);\r\n    //     }\r\n    // }\r\n    \r\n    function buyInternal(\r\n        ERC20 token,\r\n        address _exchange,\r\n        uint256 _value,\r\n        bytes _data\r\n    ) \r\n        internal\r\n    {\r\n        require(\r\n            // 0xa9059cbb - transfer(address,uint256)\r\n            !(_data[0] == 0xa9 && _data[1] == 0x05 && _data[2] == 0x9c && _data[3] == 0xbb) &&\r\n            // 0x095ea7b3 - approve(address,uint256)\r\n            !(_data[0] == 0x09 && _data[1] == 0x5e && _data[2] == 0xa7 && _data[3] == 0xb3) &&\r\n            // 0x23b872dd - transferFrom(address,address,uint256)\r\n            !(_data[0] == 0x23 && _data[1] == 0xb8 && _data[2] == 0x72 && _data[3] == 0xdd),\r\n            \"buyInternal: Do not try to call transfer, approve or transferFrom\"\r\n        );\r\n        uint256 tokenBalance = token.balanceOf(this);\r\n        require(_exchange.call.value(_value)(_data));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]\r\n            .add(token.balanceOf(this).sub(tokenBalance));\r\n    }\r\n    \r\n    function mintInternal(\r\n        IMultiToken _mtkn,\r\n        uint256[] _notUsedValues\r\n    ) \r\n        internal\r\n    {\r\n        uint256 totalSupply = _mtkn.totalSupply();\r\n        uint256 bestAmount = uint256(-1);\r\n        uint256 tokensCount = _mtkn.changeableTokenCount();\r\n        for (uint i = 0; i < tokensCount; i++) {\r\n            ERC20 token = _mtkn.tokens(i);\r\n\r\n            // Approve XXX to mtkn\r\n            uint256 thisTokenBalance = tokenBalances[msg.sender][token];\r\n            uint256 mtknTokenBalance = token.balanceOf(_mtkn);\r\n            _notUsedValues[i] = token.balanceOf(this);\r\n            token.approve(_mtkn, thisTokenBalance);\r\n            \r\n            uint256 amount = totalSupply.mul(thisTokenBalance).div(mtknTokenBalance);\r\n            if (amount < bestAmount) {\r\n                bestAmount = amount;\r\n            }\r\n        }\r\n\r\n        // Mint mtkn\r\n        _mtkn.mint(msg.sender, bestAmount);\r\n        \r\n        for (i = 0; i < tokensCount; i++) {\r\n            token = _mtkn.tokens(i);\r\n            token.approve(_mtkn, 0);\r\n            tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]\r\n                .sub(_notUsedValues[i].sub(token.balanceOf(this)));\r\n        }\r\n    }\r\n    \r\n    // function buyAndMintInternal(\r\n    //     IMultiToken _mtkn,\r\n    //     uint256 _minAmount,\r\n    //     address[] _tokens,\r\n    //     address[] _exchanges,\r\n    //     uint256[] _values,\r\n    //     bytes[] _datas\r\n    // ) \r\n    //     internal\r\n    // {\r\n    //     for (uint i = 0; i < _tokens.length; i++) {\r\n    //         buyInternal(ERC20(_tokens[i]), _exchanges[i], _values[i], _datas[i]);\r\n    //     }\r\n    //     mintInternal(_mtkn, _minAmount, _values);\r\n    // }\r\n    \r\n    ////////////////////////////////////////////////////////////////\r\n    \r\n    function buy10(\r\n        address[] _tokens,\r\n        address[] _exchanges,\r\n        uint256[] _values,\r\n        bytes _data1,\r\n        bytes _data2,\r\n        bytes _data3,\r\n        bytes _data4,\r\n        bytes _data5,\r\n        bytes _data6,\r\n        bytes _data7,\r\n        bytes _data8,\r\n        bytes _data9,\r\n        bytes _data10\r\n    ) \r\n        payable\r\n        public\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n        buyInternal(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);\r\n        if (_tokens.length == 1) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);\r\n        if (_tokens.length == 2) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[2]), _exchanges[2], _values[2], _data3);\r\n        if (_tokens.length == 3) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[3]), _exchanges[3], _values[3], _data4);\r\n        if (_tokens.length == 4) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[4]), _exchanges[4], _values[4], _data5);\r\n        if (_tokens.length == 5) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[5]), _exchanges[5], _values[5], _data6);\r\n        if (_tokens.length == 6) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[6]), _exchanges[6], _values[6], _data7);\r\n        if (_tokens.length == 7) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[7]), _exchanges[7], _values[7], _data8);\r\n        if (_tokens.length == 8) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[8]), _exchanges[8], _values[8], _data9);\r\n        if (_tokens.length == 9) {\r\n            return;\r\n        }\r\n        buyInternal(ERC20(_tokens[9]), _exchanges[9], _values[9], _data10);\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////////////\r\n    \r\n    function buy10mint(\r\n        IMultiToken _mtkn,\r\n        address[] _tokens,\r\n        address[] _exchanges,\r\n        uint256[] _values,\r\n        bytes _data1,\r\n        bytes _data2,\r\n        bytes _data3,\r\n        bytes _data4,\r\n        bytes _data5,\r\n        bytes _data6,\r\n        bytes _data7,\r\n        bytes _data8,\r\n        bytes _data9,\r\n        bytes _data10\r\n    ) \r\n        payable\r\n        public\r\n    {\r\n        buy10(_tokens, _exchanges, _values, _data1, _data2, _data3, _data4, _data5, _data6, _data7, _data8, _data9, _data10);\r\n        mintInternal(_mtkn, _values);\r\n    }\r\n    \r\n    ////////////////////////////////////////////////////////////////\r\n    \r\n    function buyOne(\r\n        address _token,\r\n        address _exchange,\r\n        uint256 _value,\r\n        bytes _data\r\n    ) \r\n        payable\r\n        public\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n        buyInternal(ERC20(_token), _exchange, _value, _data);\r\n    }\r\n    \r\n    // function buyMany(\r\n    //     address[] _tokens,\r\n    //     address[] _exchanges,\r\n    //     uint256[] _values,\r\n    //     bytes[] _datas\r\n    // ) \r\n    //     payable\r\n    //     public\r\n    // {\r\n    //     balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n    //     for (uint i = 0; i < _tokens.length; i++) {\r\n    //         buyInternal(ERC20(_tokens[i]), _exchanges[i], _values[i], _datas[i]);\r\n    //     }\r\n    // }\r\n\r\n    // function buy(\r\n    //     IMultiToken _mtkn, // may be 0\r\n    //     address[] _exchanges, // may have 0\r\n    //     uint256[] _values,\r\n    //     bytes[] _datas\r\n    // ) \r\n    //     payable\r\n    //     public\r\n    // {\r\n    //     require(_mtkn.changeableTokenCount() == _exchanges.length, \"\");\r\n\r\n    //     balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n    //     for (uint i = 0; i < _exchanges.length; i++) {\r\n    //         if (_exchanges[i] == 0) {\r\n    //             continue;\r\n    //         }\r\n\r\n    //         ERC20 token = _mtkn.tokens(i);\r\n            \r\n    //         // ETH => XXX\r\n    //         uint256 tokenBalance = token.balanceOf(this);\r\n    //         require(_exchanges[i].call.value(_values[i])(_datas[i]));\r\n    //         balances[msg.sender] = balances[msg.sender].sub(_values[i]);\r\n    //         tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));\r\n    //     }\r\n    // }\r\n\r\n    // function buyAndMint(\r\n    //     IMultiToken _mtkn, // may be 0\r\n    //     uint256 _minAmount,\r\n    //     address[] _exchanges, // may have 0\r\n    //     uint256[] _values,\r\n    //     bytes[] _datas\r\n    // ) \r\n    //     payable\r\n    //     public\r\n    // {\r\n    //     buy(_mtkn, _exchanges, _values, _datas);\r\n\r\n    //     uint256 totalSupply = _mtkn.totalSupply();\r\n    //     uint256 bestAmount = uint256(-1);\r\n    //     for (uint i = 0; i < _exchanges.length; i++) {\r\n    //         ERC20 token = _mtkn.tokens(i);\r\n\r\n    //         // Approve XXX to mtkn\r\n    //         uint256 thisTokenBalance = tokenBalances[msg.sender][token];\r\n    //         uint256 mtknTokenBalance = token.balanceOf(_mtkn);\r\n    //         _values[i] = token.balanceOf(this);\r\n    //         token.approve(_mtkn, thisTokenBalance);\r\n            \r\n    //         uint256 amount = totalSupply.mul(thisTokenBalance).div(mtknTokenBalance);\r\n    //         if (amount < bestAmount) {\r\n    //             bestAmount = amount;\r\n    //         }\r\n    //     }\r\n\r\n    //     require(bestAmount >= _minAmount);\r\n    //     _mtkn.mint(msg.sender, bestAmount);\r\n\r\n    //     for (i = 0; i < _exchanges.length; i++) {\r\n    //         token = _mtkn.tokens(i);\r\n    //         token.approve(_mtkn, 0);\r\n    //         tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(token.balanceOf(this).sub(_values[i]));\r\n    //     }\r\n    // }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_exchange\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"buyOne\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mtkn\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_exchanges\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_data1\",\"type\":\"bytes\"},{\"name\":\"_data2\",\"type\":\"bytes\"},{\"name\":\"_data3\",\"type\":\"bytes\"},{\"name\":\"_data4\",\"type\":\"bytes\"},{\"name\":\"_data5\",\"type\":\"bytes\"},{\"name\":\"_data6\",\"type\":\"bytes\"},{\"name\":\"_data7\",\"type\":\"bytes\"},{\"name\":\"_data8\",\"type\":\"bytes\"},{\"name\":\"_data9\",\"type\":\"bytes\"},{\"name\":\"_data10\",\"type\":\"bytes\"}],\"name\":\"buy10mint\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_tokenValues\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"allBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_exchanges\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_data1\",\"type\":\"bytes\"},{\"name\":\"_data2\",\"type\":\"bytes\"},{\"name\":\"_data3\",\"type\":\"bytes\"},{\"name\":\"_data4\",\"type\":\"bytes\"},{\"name\":\"_data5\",\"type\":\"bytes\"},{\"name\":\"_data6\",\"type\":\"bytes\"},{\"name\":\"_data7\",\"type\":\"bytes\"},{\"name\":\"_data8\",\"type\":\"bytes\"},{\"name\":\"_data9\",\"type\":\"bytes\"},{\"name\":\"_data10\",\"type\":\"bytes\"}],\"name\":\"buy10\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"mtkn\",\"type\":\"address\"}],\"name\":\"sumWeightOfMultiToken\",\"outputs\":[{\"name\":\"sumWeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_tokenValues\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BancorBuyer","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9faaf40b1c46513547cdd9fb488b89a273442b6e8a8a313d45e36e02db4530de"}]}