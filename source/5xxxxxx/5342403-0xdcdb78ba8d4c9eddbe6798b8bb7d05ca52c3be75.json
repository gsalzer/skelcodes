{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title EthealWhitelist\r\n * @author thesved\r\n * @notice EthealWhitelist contract which handles KYC\r\n */\r\ncontract EthealWhitelist is Ownable {\r\n    using ECRecovery for bytes32;\r\n\r\n    // signer address for offchain whitelist signing\r\n    address public signer;\r\n\r\n    // storing whitelisted addresses\r\n    mapping(address => bool) public isWhitelisted;\r\n\r\n    event WhitelistSet(address indexed _address, bool _state);\r\n\r\n    ////////////////\r\n    // Constructor\r\n    ////////////////\r\n    function EthealWhitelist(address _signer) {\r\n        require(_signer != address(0));\r\n\r\n        signer = _signer;\r\n    }\r\n\r\n    /// @notice set signing address after deployment\r\n    function setSigner(address _signer) public onlyOwner {\r\n        require(_signer != address(0));\r\n\r\n        signer = _signer;\r\n    }\r\n\r\n    ////////////////\r\n    // Whitelisting: only owner\r\n    ////////////////\r\n\r\n    /// @notice Set whitelist state for an address.\r\n    function setWhitelist(address _addr, bool _state) public onlyOwner {\r\n        require(_addr != address(0));\r\n        isWhitelisted[_addr] = _state;\r\n        WhitelistSet(_addr, _state);\r\n    }\r\n\r\n    /// @notice Set whitelist state for multiple addresses\r\n    function setManyWhitelist(address[] _addr, bool _state) public onlyOwner {\r\n        for (uint256 i = 0; i < _addr.length; i++) {\r\n            setWhitelist(_addr[i], _state);\r\n        }\r\n    }\r\n\r\n    /// @notice offchain whitelist check\r\n    function isOffchainWhitelisted(address _addr, bytes _sig) public view returns (bool) {\r\n        bytes32 hash = keccak256(\"\\x19Ethereum Signed Message:\\n20\",_addr);\r\n        return hash.recover(_sig) == signer;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address[]\"},{\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setManyWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"isOffchainWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"WhitelistSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthealWhitelist","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003a7689f3b1888207db65ad01966b263a1d6e1c6a","Library":"ECRecovery:7b63308d5c70f3d5eb73c697056fe8d527bd0b6a","SwarmSource":"bzzr://3da7800610911808c6b80500b6f00e2671d9ff5a66bdec04a8f5b0087f251832"}]}