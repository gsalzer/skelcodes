{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract Risk\r\n{\r\n    address owner;\r\n    mapping (address => uint8 []) playerCountries;\r\n    address[178] ownerofCountry; // size must be fixed\r\n    address[] playerList;\r\n    uint256 totalmoney=0;\r\n    uint256 lastR=3;\r\n    address lastgameendWinner=address(0);   \r\n    uint8 winnerLimit=50;\r\n    \r\n    address[15] winnerloser; // first 5 represents attacker last 5 defender\r\n    //uint[5] winnerloserscore; //  attaker wins 2 attacker loses\r\n    \r\n    event attackhappened (address attacker, address defender);\r\n    event buyhappened (address buyer, uint countryID);\r\n\r\n    function Risk() \r\n    {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function buyCountry(uint8 countryID) payable returns(bool)\r\n    {\r\n        assert(ownerofCountry[countryID]==0); //country unowned\r\n        assert(msg.value == 10 finney); //0.01 ether\r\n        \r\n        totalmoney +=msg.value;\r\n        playerCountries[msg.sender].push(countryID);\r\n        ownerofCountry[countryID]=msg.sender;\r\n        playerList.push(msg.sender);\r\n        \r\n        buyhappened(msg.sender,countryID);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function attackCountry(uint8 countryID)\r\n    {\r\n        assert(playerCountries[msg.sender].length!=0); //player owns county\r\n        assert(ownerofCountry[countryID]!=address(0)); //country owned\r\n        assert(msg.sender!=ownerofCountry[countryID]); //not attacking its own country\r\n        \r\n        address attacker = msg.sender;\r\n        address defender = ownerofCountry[countryID];\r\n        \r\n        uint a=playerCountries[attacker].length;\r\n        uint b=playerCountries[defender].length;\r\n        \r\n        if(a<=1)\r\n            a=1;\r\n        else if(a<=4)\r\n            a=2;\r\n        else if(a<=9)\r\n            a=3;\r\n        else if(a<=16)\r\n            a=4;\r\n        else if(a<=25)\r\n            a=5;\r\n        else if(a<=36)\r\n            a=6;\r\n        else if(a<=49)\r\n            a=7;\r\n        else if(a<=64)\r\n            a=8;\r\n        else if(a<=81)\r\n            a=9;\r\n        else\r\n            a=10;\r\n        \r\n        if(b<=1)\r\n            b=1;\r\n        else if(b<=4)\r\n            b=2;\r\n        else if(b<=9)\r\n            b=3;\r\n        else if(b<=16)\r\n            b=4;\r\n        else if(b<=25)\r\n            b=5;\r\n        else if(b<=36)\r\n            b=6;\r\n        else if(b<=49)\r\n            b=7;\r\n        else if(b<=64)\r\n            b=8;\r\n        else if(b<=81)\r\n            b=9;\r\n        else\r\n            b=10;\r\n\r\n        for(uint256 i=14;i>=11;i--)\r\n            winnerloser[i]=winnerloser[i-1];\r\n        for(i=9;i>=6;i--)\r\n            winnerloser[i]=winnerloser[i-1];\r\n        for(i=4;i>=1;i--)\r\n            winnerloser[i]=winnerloser[i-1];\r\n        \r\n        uint256 loopcount=0;\r\n        lastR=uint256(block.blockhash(block.number-1))%(a+b);\r\n        if(lastR<a) //attacker win\r\n        {\r\n            loopcount=playerCountries[defender].length;\r\n            for (i=0;i<loopcount;i++)\r\n            {\r\n                playerCountries[attacker].push(playerCountries[defender][i]);\r\n                ownerofCountry[playerCountries[defender][i]]=attacker;\r\n            }\r\n            playerCountries[defender].length=0;\r\n            winnerloser[0]=attacker;\r\n            winnerloser[5]=defender;\r\n            winnerloser[10]=1; //attacker wins\r\n        }\r\n        else //defender win\r\n        {\r\n            loopcount=playerCountries[attacker].length;\r\n            for (i=0;i<loopcount;i++)\r\n            {\r\n                playerCountries[defender].push(playerCountries[attacker][i]);\r\n                ownerofCountry[playerCountries[attacker][i]]=defender;\r\n            }\r\n            playerCountries[attacker].length=0;\r\n            winnerloser[0]=attacker;\r\n            winnerloser[5]=defender;\r\n            winnerloser[10]=2; //attacker loses\r\n        }\r\n        attackhappened(attacker,defender);\r\n        isGameEnd();\r\n    }\r\n    function isGameEnd()\r\n    {\r\n        uint256 loopcount=playerList.length;\r\n        address winner=owner;\r\n        \r\n        //require 15 country ownership for testing\r\n        bool del=false;\r\n        for (uint8 i=0; i<loopcount;i++)\r\n        {\r\n            if(playerCountries[playerList[i]].length>=winnerLimit) //iswinner\r\n            {\r\n                winner=playerList[i];\r\n                del=true;\r\n                \r\n                break;\r\n            }\r\n        }\r\n        //deleteeverything\r\n        if(del)\r\n        {\r\n            winner.transfer(totalmoney/10*9); //distribute 90%\r\n            owner.transfer(totalmoney/10);\r\n            totalmoney=0;\r\n            lastgameendWinner=winner;\r\n            for (i=0;i<178;i++)\r\n            {\r\n                playerCountries[ownerofCountry[i]].length=0;\r\n                ownerofCountry[i]=0;\r\n            }\r\n            playerList.length=0;\r\n            for(i=0;i<10;i++)\r\n                winnerloser[i]=address(0);\r\n        }\r\n    }\r\n    function setwinnerLimit (uint8 x)\r\n    {\r\n        assert(msg.sender==owner);\r\n        winnerLimit=x;\r\n    }\r\n    function getCountryOwnershipList() constant returns (address[178])\r\n    {\r\n        return ownerofCountry;\r\n    }\r\n    function getTotalBet()constant returns (uint256)\r\n    {\r\n        return totalmoney;\r\n    }\r\n    function getaddr(address ax, uint8 bx) constant returns(address)\r\n    {\r\n        return playerCountries[ax][bx];\r\n    }\r\n    function len(address ax) constant returns(uint)\r\n    {\r\n        return playerCountries[ax].length;\r\n    }\r\n    function lastrandom() constant returns(uint256)\r\n    {\r\n        return lastR;\r\n    }\r\n    function getwinnerloser() constant returns(address[15])\r\n    {\r\n        return winnerloser;\r\n    }\r\n    function lastgamewinner() constant returns(address)\r\n    {\r\n        return lastgameendWinner;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"countryID\",\"type\":\"uint8\"}],\"name\":\"buyCountry\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastrandom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"uint8\"}],\"name\":\"setwinnerLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastgamewinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getwinnerloser\",\"outputs\":[{\"name\":\"\",\"type\":\"address[15]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"countryID\",\"type\":\"uint8\"}],\"name\":\"attackCountry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCountryOwnershipList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[178]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"isGameEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ax\",\"type\":\"address\"},{\"name\":\"bx\",\"type\":\"uint8\"}],\"name\":\"getaddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ax\",\"type\":\"address\"}],\"name\":\"len\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"attacker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"defender\",\"type\":\"address\"}],\"name\":\"attackhappened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"countryID\",\"type\":\"uint256\"}],\"name\":\"buyhappened\",\"type\":\"event\"}]","ContractName":"Risk","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://963b3d2ef2f4ee0d7777cf20f0e7ffffcdbdc8e36dc1e65c3d41bac37b64d60f"}]}