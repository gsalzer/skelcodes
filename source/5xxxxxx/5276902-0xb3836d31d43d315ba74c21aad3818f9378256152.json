{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n* Ponzi Trust Pyramid Game Smart Contracts \r\n* Code is published on https://github.com/PonziTrust/PyramidGame\r\n* Ponzi Trust https://ponzitrust.com/\r\n*/\r\n\r\n// contract to store all info about players \r\ncontract PlayersStorage {\r\n  struct Player {\r\n    uint256 input; \r\n    uint256 timestamp;\r\n    bool exist;\r\n  }\r\n  mapping (address => Player) private m_players;\r\n  address private m_owner;\r\n    \r\n  modifier onlyOwner() {\r\n    require(msg.sender == m_owner);\r\n    _;\r\n  }\r\n  \r\n  function PlayersStorage() public {\r\n    m_owner = msg.sender;  \r\n  }\r\n\r\n  // http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function \r\n  // Contracts that receive Ether directly (without a function call, i.e. using send \r\n  // or transfer) but do not define a fallback function throw an exception, \r\n  // sending back the Ether (this was different before Solidity v0.4.0).\r\n  // function() payable { revert(); }\r\n\r\n\r\n  /**\r\n  * @dev Try create new player in storage.\r\n  * @param addr Adrress of player.\r\n  * @param input Input of player.\r\n  * @param timestamp Timestamp of player.\r\n  */\r\n  function newPlayer(address addr, uint256 input, uint256 timestamp) \r\n    public \r\n    onlyOwner() \r\n    returns(bool)\r\n  {\r\n    if (m_players[addr].exist) {\r\n      return false;\r\n    }\r\n    m_players[addr].input = input;\r\n    m_players[addr].timestamp = timestamp;\r\n    m_players[addr].exist = true;\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * @dev Delet specified player from storage.\r\n  * @param addr Adrress of specified player.\r\n  */\r\n  function deletePlayer(address addr) public onlyOwner() {\r\n    delete m_players[addr];\r\n  }\r\n  \r\n  /**\r\n  * @dev Get info about specified player.\r\n  * @param addr Adrress of specified player.\r\n  * @return input Input of specified player.\r\n  * @return timestamp Timestamp of specified player.\r\n  * @return exist Whether specified player in storage or not.\r\n  */\r\n  function playerInfo(address addr) \r\n    public\r\n    view\r\n    onlyOwner() \r\n    returns(uint256 input, uint256 timestamp, bool exist) \r\n  {\r\n    input = m_players[addr].input;\r\n    timestamp = m_players[addr].timestamp;\r\n    exist = m_players[addr].exist;\r\n  }\r\n  \r\n  /**\r\n  * @dev Get input of specified player.\r\n  * @param addr Adrress of specified player.\r\n  * @return input Input of specified player.\r\n  */\r\n  function playerInput(address addr) \r\n    public\r\n    view\r\n    onlyOwner() \r\n    returns(uint256 input) \r\n  {\r\n    input = m_players[addr].input;\r\n  }\r\n  \r\n  /**\r\n  * @dev Get whether specified player in storage or not.\r\n  * @param addr Adrress of specified player.\r\n  * @return exist Whether specified player in storage or not.\r\n  */\r\n  function playerExist(address addr) \r\n    public\r\n    view\r\n    onlyOwner() \r\n    returns(bool exist) \r\n  {\r\n    exist = m_players[addr].exist;\r\n  }\r\n  \r\n  /**\r\n  * @dev Get Timestamp of specified player.\r\n  * @param addr Adrress of specified player.\r\n  * @return timestamp Timestamp of specified player.\r\n  */\r\n  function playerTimestamp(address addr) \r\n    public\r\n    view\r\n    onlyOwner() \r\n    returns(uint256 timestamp) \r\n  {\r\n    timestamp = m_players[addr].timestamp;\r\n  }\r\n  \r\n  /**\r\n  * @dev Try set input of specified player.\r\n  * @param addr Adrress of specified player.\r\n  * @param newInput New input of specified player.\r\n  * @return  Whether successful or not.\r\n  */\r\n  function playerSetInput(address addr, uint256 newInput)\r\n    public\r\n    onlyOwner()\r\n    returns(bool) \r\n  {\r\n    if (!m_players[addr].exist) {\r\n      return false;\r\n    }\r\n    m_players[addr].input = newInput;\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * @dev Do selfdestruct.\r\n  */\r\n  function kill() public onlyOwner() {\r\n    selfdestruct(m_owner);\r\n  }\r\n}\r\n\r\n\r\n// see: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n// see: https://github.com/ethereum/EIPs/issues/677\r\ncontract ERC677Recipient {\r\n  function tokenFallback(address from, uint256 amount, bytes data) public returns (bool success);\r\n} \r\n\r\n\r\n// Ponzi Token Minimal Interface\r\ncontract PonziTokenMinInterface {\r\n  function balanceOf(address owner) public view returns(uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n}\r\n\r\n\r\n/**\r\n* @dev TheGame contract implement ERC667 Recipient \r\n* see: https://github.com/ethereum/EIPs/issues/677) \r\n* and can receive token/ether only from Ponzi Token\r\n* see: https://github.com/PonziTrust/Token).\r\n*/\r\ncontract TheGame is ERC677Recipient {\r\n  using SafeMath for uint256;\r\n\r\n  enum State {\r\n    NotActive, //NotActive\r\n    Active     //Active\r\n  }\r\n\r\n  State private m_state;\r\n  address private m_owner;\r\n  uint256 private m_level;\r\n  PlayersStorage private m_playersStorage;\r\n  PonziTokenMinInterface private m_ponziToken;\r\n  uint256 private m_interestRateNumerator;\r\n  uint256 private constant INTEREST_RATE_DENOMINATOR = 1000;\r\n  uint256 private m_creationTimestamp;\r\n  uint256 private constant DURATION_TO_ACCESS_FOR_OWNER = 144 days;\r\n  uint256 private constant COMPOUNDING_FREQ = 1 days;\r\n  uint256 private constant DELAY_ON_EXIT = 100 hours;\r\n  uint256 private constant DELAY_ON_NEW_LEVEL = 7 days;\r\n  string private constant NOT_ACTIVE_STR = \"NotActive\";\r\n  uint256 private constant PERCENT_TAX_ON_EXIT = 10;\r\n  string private constant ACTIVE_STR = \"Active\";\r\n  uint256 private constant PERCENT_REFERRAL_BOUNTY = 1;\r\n  uint256 private m_levelStartupTimestamp;\r\n  uint256 private m_ponziPriceInWei;\r\n  address private m_priceSetter;\r\n\r\n////////////////\r\n// EVENTS\r\n// \r\n  event NewPlayer(address indexed addr, uint256 input, uint256 when);\r\n  event DeletePlayer(address indexed addr, uint256 when);\r\n  event NewLevel(uint256 when, uint256 newLevel);\r\n  event StateChanged(address indexed who, State newState);\r\n  event PonziPriceChanged(address indexed who, uint256 newPrice);\r\n  \r\n////////////////\r\n// MODIFIERS - Restricting Access and State Machine patterns\r\n//\r\n  modifier onlyOwner() {\r\n    require(msg.sender == m_owner);\r\n    _;\r\n  }\r\n  modifier onlyPonziToken() {\r\n    require(msg.sender == address(m_ponziToken));\r\n    _;\r\n  }\r\n  modifier atState(State state) {\r\n    require(m_state == state);\r\n    _;\r\n  }\r\n  \r\n  modifier checkAccess() {\r\n    require(m_state == State.NotActive  // solium-disable-line indentation, operator-whitespace\r\n      || now.sub(m_creationTimestamp) <= DURATION_TO_ACCESS_FOR_OWNER); \r\n    _;\r\n  }\r\n  \r\n  modifier isPlayer(address addr) {\r\n    require(m_playersStorage.playerExist(addr));\r\n    _;\r\n  }\r\n  \r\n  modifier gameIsAvailable() {\r\n    require(now >= m_levelStartupTimestamp.add(DELAY_ON_NEW_LEVEL));\r\n    _;\r\n  }\r\n\r\n///////////////\r\n// CONSTRUCTOR\r\n//  \r\n  /**\r\n  * @dev Constructor PonziToken.\r\n  */\r\n  function TheGame(address ponziTokenAddr) public {\r\n    require(ponziTokenAddr != address(0));\r\n    m_ponziToken = PonziTokenMinInterface(ponziTokenAddr);\r\n    m_owner = msg.sender;\r\n    m_creationTimestamp = now;\r\n    m_state = State.NotActive;\r\n    m_level = 1;\r\n    m_interestRateNumerator = calcInterestRateNumerator(m_level);\r\n  }\r\n\r\n  /**\r\n  * @dev Fallback func can recive eth only from Ponzi token\r\n  */\r\n  function() public payable onlyPonziToken() {  }\r\n  \r\n  \r\n  /**\r\n  * Contract calc output of sender and transfer token/eth it to him. \r\n  * If token/ethnot enough on balance, then transfer all and gp to next level.\r\n  * \r\n  * @dev Sender exit from the game. Sender must be player.\r\n  */\r\n  function exit() \r\n    external\r\n    atState(State.Active) \r\n    gameIsAvailable()\r\n    isPlayer(msg.sender) \r\n  {\r\n    uint256 input;\r\n    uint256 timestamp;\r\n    timestamp = m_playersStorage.playerTimestamp(msg.sender);\r\n    input = m_playersStorage.playerInput(msg.sender);\r\n    \r\n    // Check whether the player is DELAY_ON_EXIT hours in the game\r\n    require(now >= timestamp.add(DELAY_ON_EXIT));\r\n    \r\n    // calc output\r\n    uint256 outputInPonzi = calcOutput(input, now.sub(timestamp).div(COMPOUNDING_FREQ));\r\n    \r\n    assert(outputInPonzi > 0);\r\n    \r\n    // convert ponzi to eth\r\n    uint256 outputInWei = ponziToWei(outputInPonzi, m_ponziPriceInWei);\r\n    \r\n    // set zero before sending to prevent Re-Entrancy \r\n    m_playersStorage.deletePlayer(msg.sender);\r\n    \r\n    if (m_ponziPriceInWei > 0 && address(this).balance >= outputInWei) {\r\n      // if we have enough eth on address(this).balance \r\n      // send it to sender\r\n      \r\n      // WARNING\r\n      // untrusted Transfer !!!\r\n      uint256 oldBalance = address(this).balance;\r\n      msg.sender.transfer(outputInWei);\r\n      assert(address(this).balance.add(outputInWei) >= oldBalance);\r\n      \r\n    } else if (m_ponziToken.balanceOf(address(this)) >= outputInPonzi) {\r\n      // else if we have enough ponzi on balance\r\n      // send it to sender\r\n      \r\n      uint256 oldPonziBalance = m_ponziToken.balanceOf(address(this));\r\n      assert(m_ponziToken.transfer(msg.sender, outputInPonzi));\r\n      assert(m_ponziToken.balanceOf(address(this)).add(outputInPonzi) == oldPonziBalance);\r\n    } else {\r\n      // if we dont have nor eth, nor ponzi then transfer all avaliable ponzi to \r\n      // msg.sender and go to next Level\r\n      assert(m_ponziToken.transfer(msg.sender, m_ponziToken.balanceOf(address(this))));\r\n      assert(m_ponziToken.balanceOf(address(this)) == 0);\r\n      nextLevel();\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * @dev Get info about specified player.\r\n  * @param addr Adrress of specified player.\r\n  * @return input Input of specified player.\r\n  * @return timestamp Timestamp of specified player.\r\n  * @return inGame Whether specified player in game or not.\r\n  */\r\n  function playerInfo(address addr) \r\n    public \r\n    view \r\n    atState(State.Active)\r\n    gameIsAvailable()\r\n    returns(uint256 input, uint256 timestamp, bool inGame) \r\n  {\r\n    (input, timestamp, inGame) = m_playersStorage.playerInfo(addr);\r\n  }\r\n  \r\n  /**\r\n  * @dev Get possible output for specified player at now.\r\n  * @param addr Adrress of specified player.\r\n  * @return input Possible output for specified player at now.\r\n  */\r\n  function playerOutputAtNow(address addr) \r\n    public \r\n    view \r\n    atState(State.Active) \r\n    gameIsAvailable()\r\n    returns(uint256 amount)\r\n  {\r\n    if (!m_playersStorage.playerExist(addr)) {\r\n      return 0;\r\n    }\r\n    uint256 input = m_playersStorage.playerInput(addr);\r\n    uint256 timestamp = m_playersStorage.playerTimestamp(addr);\r\n    uint256 numberOfPayout = now.sub(timestamp).div(COMPOUNDING_FREQ);\r\n    amount = calcOutput(input, numberOfPayout);\r\n  }\r\n  \r\n  /**\r\n  * @dev Get delay on opportunity to exit for specified player at now.\r\n  * @param addr Adrress of specified player.\r\n  * @return input Delay for specified player at now.\r\n  */\r\n  function playerDelayOnExit(address addr) \r\n    public \r\n    view \r\n    atState(State.Active) \r\n    gameIsAvailable()\r\n    returns(uint256 delay) \r\n  {\r\n    if (!m_playersStorage.playerExist(addr)) {\r\n      return 0;\r\n    }\r\n    uint256 timestamp = m_playersStorage.playerTimestamp(msg.sender);\r\n    if (now >= timestamp.add(DELAY_ON_EXIT)) {\r\n      delay = 0;\r\n    } else {\r\n      delay = timestamp.add(DELAY_ON_EXIT).sub(now);\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * Sender try enter to the game.\r\n  * \r\n  * @dev Sender enter to the game. Sender must not be player.\r\n  * @param input Input of new player.\r\n  * @param referralAddress The referral address.\r\n  */\r\n  function enter(uint256 input, address referralAddress) \r\n    external \r\n    atState(State.Active)\r\n    gameIsAvailable()\r\n  {\r\n    require(m_ponziToken.transferFrom(msg.sender, address(this), input));\r\n    require(newPlayer(msg.sender, input, referralAddress));\r\n  }\r\n  \r\n  /**\r\n  * @dev Address of the price setter.\r\n  * @return Address of the price setter.\r\n  */\r\n  function priceSetter() external view returns(address) {\r\n    return m_priceSetter;\r\n  }\r\n  \r\n\r\n  /**\r\n  * @dev Price of one Ponzi token in wei.\r\n  * @return Price of one Ponzi token in wei.\r\n  */\r\n  function ponziPriceInWei() \r\n    external \r\n    view \r\n    atState(State.Active)  \r\n    returns(uint256) \r\n  {\r\n    return m_ponziPriceInWei;\r\n  }\r\n  \r\n  /**\r\n  * @dev Ð¡ompounding freq of the game. Olways 1 day.\r\n  * @return Compounding freq of the game.\r\n  */\r\n  function compoundingFreq() \r\n    external \r\n    view \r\n    atState(State.Active) \r\n    returns(uint256) \r\n  {\r\n    return COMPOUNDING_FREQ;\r\n  }\r\n  \r\n  /**\r\n  * @dev Interest rate  of the game as numerator/denominator.From 5% to 0.1%.\r\n  * @return numerator Interest rate numerator of the game.\r\n  * @return denominator Interest rate denominator of the game.\r\n  */\r\n  function interestRate() \r\n    external \r\n    view\r\n    atState(State.Active)\r\n    returns(uint256 numerator, uint256 denominator) \r\n  {\r\n    numerator = m_interestRateNumerator;\r\n    denominator = INTEREST_RATE_DENOMINATOR;\r\n  }\r\n  \r\n  /**\r\n  * @dev Level of the game.\r\n  * @return Level of the game.\r\n  */\r\n  function level() \r\n    external \r\n    view \r\n    atState(State.Active)\r\n    returns(uint256) \r\n  {\r\n    return m_level;\r\n  }\r\n  \r\n  /**\r\n  * @dev Get contract work state.\r\n  * @return Contract work state via string.\r\n  */\r\n  function state() external view returns(string) {\r\n    if (m_state == State.NotActive) \r\n      return NOT_ACTIVE_STR;\r\n    else\r\n      return ACTIVE_STR;\r\n  }\r\n  \r\n  /**\r\n  * @dev Get timestamp of the level startup.\r\n  * @return Timestamp of the level startup.\r\n  */\r\n  function levelStartupTimestamp() \r\n    external \r\n    view \r\n    atState(State.Active)\r\n    returns(uint256) \r\n  {\r\n    return m_levelStartupTimestamp;\r\n  }\r\n  \r\n  /**\r\n  * @dev Get amount of Ponzi tokens in the game.Ponzi tokens balanceOf the game.\r\n  * @return Contract work state via string.\r\n  */\r\n  function totalPonziInGame() \r\n    external \r\n    view \r\n    returns(uint256) \r\n  {\r\n    return m_ponziToken.balanceOf(address(this));\r\n  }\r\n  \r\n  /**\r\n  * @dev Get current delay on new level.\r\n  * @return Current delay on new level.\r\n  */\r\n  function currentDelayOnNewLevel() \r\n    external \r\n    view \r\n    atState(State.Active)\r\n    returns(uint256 delay) \r\n  {\r\n    if (now >= m_levelStartupTimestamp.add(DELAY_ON_NEW_LEVEL)) {\r\n      delay = 0;\r\n    } else {\r\n      delay = m_levelStartupTimestamp.add(DELAY_ON_NEW_LEVEL).sub(now);\r\n    }  \r\n  }\r\n\r\n///////////////////\r\n// ERC677 ERC677Recipient Methods\r\n//\r\n  /**\r\n  * see: https://github.com/ethereum/EIPs/issues/677\r\n  *\r\n  * @dev ERC677 token fallback. Called when received Ponzi token\r\n  * and sender try enter to the game.\r\n  *\r\n  * @param from Received tokens from the address.\r\n  * @param amount Amount of recived tokens.\r\n  * @param data Received extra data.\r\n  * @return Whether successful entrance or not.\r\n  */\r\n  function tokenFallback(address from, uint256 amount, bytes data) \r\n    public\r\n    atState(State.Active)\r\n    gameIsAvailable()\r\n    onlyPonziToken()\r\n    returns (bool)\r\n  {\r\n    address referralAddress = bytesToAddress(data);\r\n    require(newPlayer(from, amount, referralAddress));\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * @dev Set price of one Ponzi token in wei.\r\n  * @param newPrice Price of one Ponzi token in wei.\r\n  */ \r\n  function setPonziPriceinWei(uint256 newPrice) \r\n    public\r\n    atState(State.Active)   \r\n  {\r\n    require(msg.sender == m_owner || msg.sender == m_priceSetter);\r\n    m_ponziPriceInWei = newPrice;\r\n    PonziPriceChanged(msg.sender, m_ponziPriceInWei);\r\n  }\r\n  \r\n  /**\r\n  * @dev Owner do disown.\r\n  */ \r\n  function disown() public onlyOwner() atState(State.Active) {\r\n    delete m_owner;\r\n  }\r\n  \r\n  /**\r\n  * @dev Set state of contract working.\r\n  * @param newState String representation of new state.\r\n  */ \r\n  function setState(string newState) public onlyOwner() checkAccess() {\r\n    if (keccak256(newState) == keccak256(NOT_ACTIVE_STR)) {\r\n      m_state = State.NotActive;\r\n    } else if (keccak256(newState) == keccak256(ACTIVE_STR)) {\r\n      if (address(m_playersStorage) == address(0)) \r\n        m_playersStorage = (new PlayersStorage());\r\n      m_state = State.Active;\r\n    } else {\r\n      // if newState not valid string\r\n      revert();\r\n    }\r\n    StateChanged(msg.sender, m_state);\r\n  }\r\n\r\n  /**\r\n  * @dev Set the PriceSetter address, which has access to set one Ponzi \r\n  * token price in wei.\r\n  * @param newPriceSetter The address of new PriceSetter.\r\n  */\r\n  function setPriceSetter(address newPriceSetter) \r\n    public \r\n    onlyOwner() \r\n    checkAccess()\r\n    atState(State.Active) \r\n  {\r\n    m_priceSetter = newPriceSetter;\r\n  }\r\n  \r\n  /**\r\n  * @dev Try create new player. \r\n  * @param addr Adrress of pretender player.\r\n  * @param inputAmount Input tokens amount of pretender player.\r\n  * @param referralAddr Referral address of pretender player.\r\n  * @return Whether specified player in game or not.\r\n  */\r\n  function newPlayer(address addr, uint256 inputAmount, address referralAddr)\r\n    private\r\n    returns(bool)\r\n  {\r\n    uint256 input = inputAmount;\r\n    // return false if player already in game or if input < 1000,\r\n    // because calcOutput() use INTEREST_RATE_DENOMINATOR = 1000.\r\n    // and input must div by INTEREST_RATE_DENOMINATOR, if \r\n    // input <1000 then dividing always equal 0.\r\n    if (m_playersStorage.playerExist(addr) || input < 1000) \r\n      return false;\r\n    \r\n    // check if referralAddr is player\r\n    if (m_playersStorage.playerExist(referralAddr)) {\r\n      // transfer 1% input form addr to referralAddr :\r\n      // newPlayerInput = input * (100-PERCENT_REFERRAL_BOUNTY) %;\r\n      // referralInput  = (current referral input) + input * PERCENT_REFERRAL_BOUNTY %\r\n      uint256 newPlayerInput = inputAmount.mul(uint256(100).sub(PERCENT_REFERRAL_BOUNTY)).div(100);\r\n      uint256 referralInput = m_playersStorage.playerInput(referralAddr);\r\n      referralInput = referralInput.add(inputAmount.sub(newPlayerInput));\r\n      \r\n      // try set input of referralAddr player\r\n      assert(m_playersStorage.playerSetInput(referralAddr, referralInput));\r\n      // if success, set input of new player = newPlayerInput\r\n      input = newPlayerInput;\r\n    }\r\n    // try create new player\r\n    assert(m_playersStorage.newPlayer(addr, input, now));\r\n    NewPlayer(addr, input, now);\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * @dev Calc possibly output (compounding interest) for specified input and number of payout.\r\n  * @param input Input amount.\r\n  * @param numberOfPayout Number of payout.\r\n  * @return Possibly output.\r\n  */\r\n  function calcOutput(uint256 input, uint256 numberOfPayout) \r\n    private\r\n    view\r\n    returns(uint256 output)\r\n  {\r\n    output = input;\r\n    uint256 counter = numberOfPayout;\r\n    // calc compound interest \r\n    while (counter > 0) {\r\n      output = output.add(output.mul(m_interestRateNumerator).div(INTEREST_RATE_DENOMINATOR));\r\n      counter = counter.sub(1);\r\n    }\r\n    // save tax % on exit; output = output * (100-tax) / 100;\r\n    output = output.mul(uint256(100).sub(PERCENT_TAX_ON_EXIT)).div(100); \r\n  }\r\n  \r\n  /**\r\n  * @dev The game go no next level. \r\n  */\r\n  function nextLevel() private {\r\n    m_playersStorage.kill();\r\n    m_playersStorage = (new PlayersStorage());\r\n    m_level = m_level.add(1);\r\n    m_interestRateNumerator = calcInterestRateNumerator(m_level);\r\n    m_levelStartupTimestamp = now;\r\n    NewLevel(now, m_level);\r\n  }\r\n  \r\n  /**\r\n  * @dev Calc numerator of interest rate for specified level. \r\n  * @param newLevel Specified level.\r\n  * @return Result numerator.\r\n  */\r\n  function calcInterestRateNumerator(uint256 newLevel) \r\n    internal \r\n    pure \r\n    returns(uint256 numerator) \r\n  {\r\n    // constant INTEREST_RATE_DENOMINATOR = 1000\r\n    // numerator we calc\r\n    // \r\n    // level 1 : 5% interest rate = 50 / 1000    |\r\n    // level 2 : 4% interest rate = 40 / 1000    |  first stage\r\n    //        ...                                |\r\n    // level 5 : 1% interest rate = 10 / 1000    |\r\n    \r\n    // level 6 : 0.9% interest rate = 9 / 1000   |  second stage\r\n    // level 7 : 0.8% interest rate = 8 / 1000   |\r\n    //        ...                                |\r\n    // level 14 : 0.1% interest rate = 1 / 1000  |  \r\n    \r\n    // level >14 : 0.1% interest rate = 1 / 1000 |  third stage\r\n\r\n    if (newLevel <= 5) {\r\n      // first stage from 5% to 1%. numerator from 50 to 10\r\n      numerator = uint256(6).sub(newLevel).mul(10);\r\n    } else if ( newLevel >= 6 && newLevel <= 14) {\r\n      // second stage from 0.9% to 0.1%. numerator from 9 to 1\r\n      numerator = uint256(15).sub(newLevel);\r\n    } else {\r\n      // third stage 0.1%. numerator 1\r\n      numerator = 1;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * @dev Convert Ponzi token to wei.\r\n  * @param tokensAmount Amout of tokens.\r\n  * @param tokenPrice One token price in wei.\r\n  * @return weiAmount Result of convertation. \r\n  */\r\n  function ponziToWei(uint256 tokensAmount, uint256 tokenPrice) \r\n    internal\r\n    pure\r\n    returns(uint256 weiAmount)\r\n  {\r\n    weiAmount = tokensAmount.mul(tokenPrice); \r\n  } \r\n\r\n  /**\r\n  * @dev Conver bytes data to address. \r\n  * @param source Bytes data.\r\n  * @return Result address of convertation.\r\n  */\r\n  function bytesToAddress(bytes source) internal pure returns(address parsedReferer) {\r\n    assembly {\r\n      parsedReferer := mload(add(source,0x14))\r\n    }\r\n    return parsedReferer;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"levelStartupTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceSetter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDelayOnNewLevel\",\"outputs\":[{\"name\":\"delay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"playerInfo\",\"outputs\":[{\"name\":\"input\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"inGame\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compoundingFreq\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPriceSetter\",\"type\":\"address\"}],\"name\":\"setPriceSetter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ponziPriceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newState\",\"type\":\"string\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"level\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"playerDelayOnExit\",\"outputs\":[{\"name\":\"delay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPonziInGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"playerOutputAtNow\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"input\",\"type\":\"uint256\"},{\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"enter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPonziPriceinWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ponziTokenAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"input\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"NewPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"DeletePlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newLevel\",\"type\":\"uint256\"}],\"name\":\"NewLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"PonziPriceChanged\",\"type\":\"event\"}]","ContractName":"TheGame","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c2807533832807bf15898778d8a108405e9edfb1","Library":"","SwarmSource":"bzzr://a3660abcc90a0f91bb98248e95e824d90d4e7e89139711916edc9b8ae14a8104"}]}