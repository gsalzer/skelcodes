{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract UserRegistryInterface {\r\n  event AddAddress(address indexed who);\r\n  event AddIdentity(address indexed who);\r\n\r\n  function knownAddress(address _who) public constant returns(bool);\r\n  function hasIdentity(address _who) public constant returns(bool);\r\n  function systemAddresses(address _to, address _from) public constant returns(bool);\r\n}\r\n\r\ncontract MultiOwners {\r\n\r\n    event AccessGrant(address indexed owner);\r\n    event AccessRevoke(address indexed owner);\r\n    \r\n    mapping(address => bool) owners;\r\n    address public publisher;\r\n\r\n    function MultiOwners() public {\r\n        owners[msg.sender] = true;\r\n        publisher = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() { \r\n        require(owners[msg.sender] == true);\r\n        _; \r\n    }\r\n\r\n    function isOwner() public constant returns (bool) {\r\n        return owners[msg.sender] ? true : false;\r\n    }\r\n\r\n    function checkOwner(address maybe_owner) public constant returns (bool) {\r\n        return owners[maybe_owner] ? true : false;\r\n    }\r\n\r\n    function grant(address _owner) onlyOwner public {\r\n        owners[_owner] = true;\r\n        AccessGrant(_owner);\r\n    }\r\n\r\n    function revoke(address _owner) onlyOwner public {\r\n        require(_owner != publisher);\r\n        require(msg.sender != _owner);\r\n\r\n        owners[_owner] = false;\r\n        AccessRevoke(_owner);\r\n    }\r\n}\r\n\r\ncontract TokenRecipient {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; \r\n}\r\n\r\ncontract TokenInterface is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals;\r\n}\r\n\r\ncontract MintableTokenInterface is TokenInterface {\r\n  address public owner;\r\n  function mint(address beneficiary, uint amount) public returns(bool);\r\n  function transferOwnership(address nextOwner) public;\r\n}\r\n\r\n/**\r\n * Complex crowdsale with huge posibilities\r\n * Core features:\r\n * - Whitelisting\r\n *  - Min\\max invest amounts\r\n * - Only known users\r\n * - Buy with allowed tokens\r\n *  - Oraclize based pairs (ETH to TOKEN)\r\n * - Revert\\refund\r\n * - Personal bonuses\r\n * - Amount bonuses\r\n * - Total supply bonuses\r\n * - Early birds bonuses\r\n * - Extra distribution (team, foundation and also)\r\n * - Soft and hard caps\r\n * - Finalization logics\r\n**/\r\ncontract Crowdsale is MultiOwners, TokenRecipient {\r\n  using SafeMath for uint;\r\n\r\n  //  ██████╗ ██████╗ ███╗   ██╗███████╗████████╗███████╗\r\n  // ██╔════╝██╔═══██╗████╗  ██║██╔════╝╚══██╔══╝██╔════╝\r\n  // ██║     ██║   ██║██╔██╗ ██║███████╗   ██║   ███████╗\r\n  // ██║     ██║   ██║██║╚██╗██║╚════██║   ██║   ╚════██║\r\n  // ╚██████╗╚██████╔╝██║ ╚████║███████║   ██║   ███████║\r\n  //  ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚══════╝\r\n  uint public constant VERSION = 0x1;\r\n  enum State {\r\n    Setup,          // Non active yet (require to be setuped)\r\n    Active,         // Crowdsale in a live\r\n    Claim,          // Claim funds by owner\r\n    Refund,         // Unsucceseful crowdsale (refund ether)\r\n    History         // Close and store only historical fact of existence\r\n  }\r\n\r\n\r\n  struct PersonalBonusRecord {\r\n    uint bonus;\r\n    address refererAddress;\r\n    uint refererBonus;\r\n  }\r\n\r\n  struct WhitelistRecord {\r\n    bool allow;\r\n    uint min;\r\n    uint max;\r\n  }\r\n\r\n\r\n  //  ██████╗ ██████╗ ███╗   ██╗███████╗██╗███╗   ██╗ ██████╗ \r\n  // ██╔════╝██╔═══██╗████╗  ██║██╔════╝██║████╗  ██║██╔════╝ \r\n  // ██║     ██║   ██║██╔██╗ ██║█████╗  ██║██╔██╗ ██║██║  ███╗\r\n  // ██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║╚██╗██║██║   ██║\r\n  // ╚██████╗╚██████╔╝██║ ╚████║██║     ██║██║ ╚████║╚██████╔╝\r\n  //  ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝╚═╝  ╚═══╝ ╚═════╝ \r\n                                                           \r\n  bool public isWhitelisted;            // Should be whitelisted to buy tokens\r\n  bool public isKnownOnly;              // Should be known user to buy tokens\r\n  bool public isAmountBonus;            // Enable amount bonuses in crowdsale?\r\n  bool public isEarlyBonus;             // Enable early bird bonus in crowdsale?\r\n  bool public isTokenExchange;          // Allow to buy tokens for another tokens?\r\n  bool public isAllowToIssue;           // Allow to issue tokens with tx hash (ex bitcoin)\r\n  bool public isDisableEther;           // Disable purchase with the Ether\r\n  bool public isExtraDistribution;      // Should distribute extra tokens to special contract?\r\n  bool public isTransferShipment;       // Will ship token via minting?\r\n  bool public isCappedInEther;          // Should be capped in Ether \r\n  bool public isPersonalBonuses;        // Should check personal beneficiary bonus?\r\n  bool public isAllowClaimBeforeFinalization;\r\n                                        // Should allow to claim funds before finalization?\r\n  bool public isMinimumValue;           // Validate minimum amount to purchase\r\n  bool public isMinimumInEther;         // Is minimum amount setuped in Ether or Tokens?\r\n\r\n  uint public minimumPurchaseValue;     // How less buyer could to purchase\r\n\r\n  // List of allowed beneficiaries\r\n  mapping (address => WhitelistRecord) public whitelist;\r\n\r\n  // Known users registry (required to known rules)\r\n  UserRegistryInterface public userRegistry;\r\n\r\n  mapping (uint => uint) public amountBonuses; // Amount bonuses\r\n  uint[] public amountSlices;                  // Key is min amount of buy\r\n  uint public amountSlicesCount;               // 10000 - 100.00% bonus over base pricetotaly free\r\n                                               //  5000 - 50.00% bonus\r\n                                               //     0 - no bonus at all\r\n  mapping (uint => uint) public timeBonuses;   // Time bonuses\r\n  uint[] public timeSlices;                    // Same as amount but key is seconds after start\r\n  uint public timeSlicesCount;\r\n\r\n  mapping (address => PersonalBonusRecord) public personalBonuses; \r\n                                        // personal bonuses\r\n  MintableTokenInterface public token;  // The token being sold\r\n  uint public tokenDecimals;            // Token decimals\r\n\r\n  mapping (address => TokenInterface) public allowedTokens;\r\n                                        // allowed tokens list\r\n  mapping (address => uint) public tokensValues;\r\n                                        // TOKEN to ETH conversion rate (oraclized)\r\n  uint public startTime;                // start and end timestamps where \r\n  uint public endTime;                  // investments are allowed (both inclusive)\r\n  address public wallet;                // address where funds are collected\r\n  uint public price;                    // how many token (1 * 10 ** decimals) a buyer gets per wei\r\n  uint public hardCap;\r\n  uint public softCap;\r\n\r\n  address public extraTokensHolder;     // address to mint/transfer extra tokens (0 – 0%, 1000 - 100.0%)\r\n  uint public extraDistributionPart;    // % of extra distribution\r\n\r\n  // ███████╗████████╗ █████╗ ████████╗███████╗\r\n  // ██╔════╝╚══██╔══╝██╔══██╗╚══██╔══╝██╔════╝\r\n  // ███████╗   ██║   ███████║   ██║   █████╗  \r\n  // ╚════██║   ██║   ██╔══██║   ██║   ██╔══╝  \r\n  // ███████║   ██║   ██║  ██║   ██║   ███████╗\r\n  // ╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝   ╚══════╝\r\n  // amount of raised money in wei\r\n  uint public weiRaised;\r\n  // Current crowdsale state\r\n  State public state;\r\n  // Temporal balances to pull tokens after token sale\r\n  // requires to ship required balance to smart contract\r\n  mapping (address => uint) public beneficiaryInvest;\r\n  uint public soldTokens;\r\n\r\n  mapping (address => uint) public weiDeposit;\r\n  mapping (address => mapping(address => uint)) public altDeposit;\r\n\r\n  modifier inState(State _target) {\r\n    require(state == _target);\r\n    _;\r\n  }\r\n\r\n  // ███████╗██╗   ██╗███████╗███╗   ██╗████████╗███████╗\r\n  // ██╔════╝██║   ██║██╔════╝████╗  ██║╚══██╔══╝██╔════╝\r\n  // █████╗  ██║   ██║█████╗  ██╔██╗ ██║   ██║   ███████╗\r\n  // ██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║╚██╗██║   ██║   ╚════██║\r\n  // ███████╗ ╚████╔╝ ███████╗██║ ╚████║   ██║   ███████║\r\n  // ╚══════╝  ╚═══╝  ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝\r\n  \r\n  event EthBuy(\r\n    address indexed purchaser, \r\n    address indexed beneficiary, \r\n    uint value, \r\n    uint amount);\r\n  event HashBuy(\r\n    address indexed beneficiary, \r\n    uint value, \r\n    uint amount, \r\n    uint timestamp, \r\n    bytes32 indexed bitcoinHash);\r\n  event AltBuy(\r\n    address indexed beneficiary, \r\n    address indexed allowedToken, \r\n    uint allowedTokenValue, \r\n    uint ethValue, \r\n    uint shipAmount);\r\n    \r\n  event ShipTokens(address indexed owner, uint amount);\r\n\r\n  event Sanetize();\r\n  event Finalize();\r\n\r\n  event Whitelisted(address indexed beneficiary, uint min, uint max);\r\n  event PersonalBonus(address indexed beneficiary, address indexed referer, uint bonus, uint refererBonus);\r\n  event FundsClaimed(address indexed owner, uint amount);\r\n\r\n\r\n  // ███████╗███████╗████████╗██╗   ██╗██████╗     ███╗   ███╗███████╗████████╗██╗  ██╗ ██████╗ ██████╗ ███████╗\r\n  // ██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗    ████╗ ████║██╔════╝╚══██╔══╝██║  ██║██╔═══██╗██╔══██╗██╔════╝\r\n  // ███████╗█████╗     ██║   ██║   ██║██████╔╝    ██╔████╔██║█████╗     ██║   ███████║██║   ██║██║  ██║███████╗\r\n  // ╚════██║██╔══╝     ██║   ██║   ██║██╔═══╝     ██║╚██╔╝██║██╔══╝     ██║   ██╔══██║██║   ██║██║  ██║╚════██║\r\n  // ███████║███████╗   ██║   ╚██████╔╝██║         ██║ ╚═╝ ██║███████╗   ██║   ██║  ██║╚██████╔╝██████╔╝███████║\r\n  // ╚══════╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝         ╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝\r\n\r\n  function setFlags(\r\n    // Should be whitelisted to buy tokens\r\n    bool _isWhitelisted,\r\n    // Should be known user to buy tokens\r\n    bool _isKnownOnly,\r\n    // Enable amount bonuses in crowdsale?\r\n    bool _isAmountBonus,\r\n    // Enable early bird bonus in crowdsale?\r\n    bool _isEarlyBonus,\r\n    // Allow to buy tokens for another tokens?\r\n    bool _isTokenExchange,\r\n    // Allow to issue tokens with tx hash (ex bitcoin)\r\n    bool _isAllowToIssue,\r\n    // Should reject purchases with Ether?\r\n    bool _isDisableEther,\r\n    // Should mint extra tokens for future distribution?\r\n    bool _isExtraDistribution,\r\n    // Will ship token via minting? \r\n    bool _isTransferShipment,\r\n    // Should be capped in ether\r\n    bool _isCappedInEther,\r\n    // Should beneficiaries pull their tokens? \r\n    bool _isPersonalBonuses,\r\n    // Should allow to claim funds before finalization?\r\n    bool _isAllowClaimBeforeFinalization)\r\n    inState(State.Setup) onlyOwner public \r\n  {\r\n    isWhitelisted = _isWhitelisted;\r\n    isKnownOnly = _isKnownOnly;\r\n    isAmountBonus = _isAmountBonus;\r\n    isEarlyBonus = _isEarlyBonus;\r\n    isTokenExchange = _isTokenExchange;\r\n    isAllowToIssue = _isAllowToIssue;\r\n    isDisableEther = _isDisableEther;\r\n    isExtraDistribution = _isExtraDistribution;\r\n    isTransferShipment = _isTransferShipment;\r\n    isCappedInEther = _isCappedInEther;\r\n    isPersonalBonuses = _isPersonalBonuses;\r\n    isAllowClaimBeforeFinalization = _isAllowClaimBeforeFinalization;\r\n  }\r\n\r\n  // ! Could be changed in process of sale (since 02.2018)\r\n  function setMinimum(uint _amount, bool _inToken) \r\n    onlyOwner public\r\n  {\r\n    if (_amount == 0) {\r\n      isMinimumValue = false;\r\n      minimumPurchaseValue = 0;\r\n    } else {\r\n      isMinimumValue = true;\r\n      isMinimumInEther = !_inToken;\r\n      minimumPurchaseValue = _amount;\r\n    }\r\n  }\r\n\r\n  function setPrice(uint _price)\r\n    inState(State.Setup) onlyOwner public\r\n  {\r\n    require(_price > 0);\r\n    price = _price;\r\n  }\r\n\r\n  function setSoftHardCaps(uint _softCap, uint _hardCap)\r\n    inState(State.Setup) onlyOwner public\r\n  {\r\n    hardCap = _hardCap;\r\n    softCap = _softCap;\r\n  }\r\n\r\n  function setTime(uint _start, uint _end)\r\n    inState(State.Setup) onlyOwner public \r\n  {\r\n    require(_start < _end);\r\n    require(_end > block.timestamp);\r\n    startTime = _start;\r\n    endTime = _end;\r\n  }\r\n\r\n  function setToken(address _tokenAddress) \r\n    inState(State.Setup) onlyOwner public\r\n  {\r\n    token = MintableTokenInterface(_tokenAddress);\r\n    tokenDecimals = token.decimals();\r\n  }\r\n\r\n  function setWallet(address _wallet) \r\n    inState(State.Setup) onlyOwner public \r\n  {\r\n    require(_wallet != address(0));\r\n    wallet = _wallet;\r\n  }\r\n  \r\n  function setRegistry(address _registry) \r\n    inState(State.Setup) onlyOwner public \r\n  {\r\n    require(_registry != address(0));\r\n    userRegistry = UserRegistryInterface(_registry);\r\n  }\r\n\r\n  function setExtraDistribution(address _holder, uint _extraPart) \r\n    inState(State.Setup) onlyOwner public\r\n  {\r\n    require(_holder != address(0));\r\n    extraTokensHolder = _holder;\r\n    extraDistributionPart = _extraPart;\r\n  }\r\n\r\n  function setAmountBonuses(uint[] _amountSlices, uint[] _bonuses) \r\n    inState(State.Setup) onlyOwner public \r\n  {\r\n    require(_amountSlices.length > 1);\r\n    require(_bonuses.length == _amountSlices.length);\r\n    uint lastSlice = 0;\r\n    for (uint index = 0; index < _amountSlices.length; index++) {\r\n      require(_amountSlices[index] > lastSlice);\r\n      lastSlice = _amountSlices[index];\r\n      amountSlices.push(lastSlice);\r\n      amountBonuses[lastSlice] = _bonuses[index];\r\n    }\r\n\r\n    amountSlicesCount = amountSlices.length;\r\n  }\r\n\r\n  function setTimeBonuses(uint[] _timeSlices, uint[] _bonuses) \r\n    // ! Not need to check state since changes at 02.2018\r\n    // inState(State.Setup)\r\n    onlyOwner \r\n    public \r\n  {\r\n    // Only once in life time\r\n    // ! Time bonuses is changable after 02.2018\r\n    // require(timeSlicesCount == 0);\r\n    require(_timeSlices.length > 0);\r\n    require(_bonuses.length == _timeSlices.length);\r\n    uint lastSlice = 0;\r\n    uint lastBonus = 10000;\r\n    if (timeSlicesCount > 0) {\r\n      // ! Since time bonuses is changable we should take latest first\r\n      lastSlice = timeSlices[timeSlicesCount - 1];\r\n      lastBonus = timeBonuses[lastSlice];\r\n    }\r\n\r\n    for (uint index = 0; index < _timeSlices.length; index++) {\r\n      require(_timeSlices[index] > lastSlice);\r\n\r\n      // ! Add check for next bonus is equal or less than previous\r\n      require(_bonuses[index] <= lastBonus);\r\n\r\n      // ? Should we check bonus in a future\r\n      lastSlice = _timeSlices[index];\r\n      timeSlices.push(lastSlice);\r\n      timeBonuses[lastSlice] = _bonuses[index];\r\n    }\r\n    timeSlicesCount = timeSlices.length;\r\n  }\r\n  \r\n  function setTokenExcange(address _token, uint _value)\r\n    inState(State.Setup) onlyOwner public\r\n  {\r\n    allowedTokens[_token] = TokenInterface(_token);\r\n    updateTokenValue(_token, _value); \r\n  }\r\n\r\n  function saneIt() \r\n    inState(State.Setup) onlyOwner public \r\n  {\r\n    require(startTime < endTime);\r\n    require(endTime > now);\r\n\r\n    require(price > 0);\r\n\r\n    require(wallet != address(0));\r\n    require(token != address(0));\r\n\r\n    if (isKnownOnly) {\r\n      require(userRegistry != address(0));\r\n    }\r\n\r\n    if (isAmountBonus) {\r\n      require(amountSlicesCount > 0);\r\n    }\r\n\r\n    if (isExtraDistribution) {\r\n      require(extraTokensHolder != address(0));\r\n    }\r\n\r\n    if (isTransferShipment) {\r\n      require(token.balanceOf(address(this)) >= hardCap);\r\n    } else {\r\n      require(token.owner() == address(this));\r\n    }\r\n\r\n    state = State.Active;\r\n  }\r\n\r\n  function finalizeIt(address _futureOwner) inState(State.Active) onlyOwner public {\r\n    require(ended());\r\n\r\n    token.transferOwnership(_futureOwner);\r\n\r\n    if (success()) {\r\n      state = State.Claim;\r\n    } else {\r\n      state = State.Refund;\r\n    }\r\n  }\r\n\r\n  function historyIt() inState(State.Claim) onlyOwner public {\r\n    require(address(this).balance == 0);\r\n    state = State.History;\r\n  }\r\n\r\n  // ███████╗██╗  ██╗███████╗ ██████╗██╗   ██╗████████╗███████╗\r\n  // ██╔════╝╚██╗██╔╝██╔════╝██╔════╝██║   ██║╚══██╔══╝██╔════╝\r\n  // █████╗   ╚███╔╝ █████╗  ██║     ██║   ██║   ██║   █████╗  \r\n  // ██╔══╝   ██╔██╗ ██╔══╝  ██║     ██║   ██║   ██║   ██╔══╝  \r\n  // ███████╗██╔╝ ██╗███████╗╚██████╗╚██████╔╝   ██║   ███████╗\r\n  // ╚══════╝╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝    ╚═╝   ╚══════╝\r\n\r\n  function calculateEthAmount(\r\n    address _beneficiary,\r\n    uint _weiAmount,\r\n    uint _time,\r\n    uint _totalSupply\r\n  ) public constant returns(\r\n    uint calculatedTotal, \r\n    uint calculatedBeneficiary, \r\n    uint calculatedExtra, \r\n    uint calculatedreferer, \r\n    address refererAddress) \r\n  {\r\n    _totalSupply;\r\n    uint bonus = 0;\r\n    \r\n    if (isAmountBonus) {\r\n      bonus = bonus.add(calculateAmountBonus(_weiAmount));\r\n    }\r\n\r\n    if (isEarlyBonus) {\r\n      bonus = bonus.add(calculateTimeBonus(_time.sub(startTime)));\r\n    }\r\n\r\n    if (isPersonalBonuses && personalBonuses[_beneficiary].bonus > 0) {\r\n      bonus = bonus.add(personalBonuses[_beneficiary].bonus);\r\n    }\r\n\r\n    calculatedBeneficiary = _weiAmount.mul(10 ** tokenDecimals).div(price);\r\n    if (bonus > 0) {\r\n      calculatedBeneficiary = calculatedBeneficiary.add(calculatedBeneficiary.mul(bonus).div(10000));\r\n    }\r\n\r\n    if (isExtraDistribution) {\r\n      calculatedExtra = calculatedBeneficiary.mul(extraDistributionPart).div(10000);\r\n    }\r\n\r\n    if (isPersonalBonuses && \r\n        personalBonuses[_beneficiary].refererAddress != address(0) && \r\n        personalBonuses[_beneficiary].refererBonus > 0) \r\n    {\r\n      calculatedreferer = calculatedBeneficiary.mul(personalBonuses[_beneficiary].refererBonus).div(10000);\r\n      refererAddress = personalBonuses[_beneficiary].refererAddress;\r\n    }\r\n\r\n    calculatedTotal = calculatedBeneficiary.add(calculatedExtra).add(calculatedreferer);\r\n  }\r\n\r\n  function calculateAmountBonus(uint _changeAmount) public constant returns(uint) {\r\n    uint bonus = 0;\r\n    for (uint index = 0; index < amountSlices.length; index++) {\r\n      if(amountSlices[index] > _changeAmount) {\r\n        break;\r\n      }\r\n\r\n      bonus = amountBonuses[amountSlices[index]];\r\n    }\r\n    return bonus;\r\n  }\r\n\r\n  function calculateTimeBonus(uint _at) public constant returns(uint) {\r\n    uint bonus = 0;\r\n    for (uint index = timeSlices.length; index > 0; index--) {\r\n      if(timeSlices[index - 1] < _at) {\r\n        break;\r\n      }\r\n      bonus = timeBonuses[timeSlices[index - 1]];\r\n    }\r\n\r\n    return bonus;\r\n  }\r\n\r\n  function validPurchase(\r\n    address _beneficiary, \r\n    uint _weiAmount, \r\n    uint _tokenAmount,\r\n    uint _extraAmount,\r\n    uint _totalAmount,\r\n    uint _time) \r\n  public constant returns(bool) \r\n  {\r\n    _tokenAmount;\r\n    _extraAmount;\r\n\r\n    // ! Check min purchase value (since 02.2018)\r\n    if (isMinimumValue) {\r\n      // ! Check min purchase value in ether (since 02.2018)\r\n      if (isMinimumInEther && _weiAmount < minimumPurchaseValue) {\r\n        return false;\r\n      }\r\n\r\n      // ! Check min purchase value in tokens (since 02.2018)\r\n      if (!isMinimumInEther && _tokenAmount < minimumPurchaseValue) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (_time < startTime || _time > endTime) {\r\n      return false;\r\n    }\r\n\r\n    if (isKnownOnly && !userRegistry.knownAddress(_beneficiary)) {\r\n      return false;\r\n    }\r\n\r\n    uint finalBeneficiaryInvest = beneficiaryInvest[_beneficiary].add(_weiAmount);\r\n    uint finalTotalSupply = soldTokens.add(_totalAmount);\r\n\r\n    if (isWhitelisted) {\r\n      WhitelistRecord storage record = whitelist[_beneficiary];\r\n      if (!record.allow || \r\n          record.min > finalBeneficiaryInvest ||\r\n          record.max < finalBeneficiaryInvest) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (isCappedInEther) {\r\n      if (weiRaised.add(_weiAmount) > hardCap) {\r\n        return false;\r\n      }\r\n    } else {\r\n      if (finalTotalSupply > hardCap) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n                                                                                        \r\n  function updateTokenValue(address _token, uint _value) onlyOwner public {\r\n    require(address(allowedTokens[_token]) != address(0x0));\r\n    tokensValues[_token] = _value;\r\n  }\r\n\r\n  // ██████╗ ███████╗ █████╗ ██████╗ \r\n  // ██╔══██╗██╔════╝██╔══██╗██╔══██╗\r\n  // ██████╔╝█████╗  ███████║██║  ██║\r\n  // ██╔══██╗██╔══╝  ██╔══██║██║  ██║\r\n  // ██║  ██║███████╗██║  ██║██████╔╝\r\n  // ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ \r\n  function success() public constant returns(bool) {\r\n    if (isCappedInEther) {\r\n      return weiRaised >= softCap;\r\n    } else {\r\n      return token.totalSupply() >= softCap;\r\n    }\r\n  }\r\n\r\n  function capped() public constant returns(bool) {\r\n    if (isCappedInEther) {\r\n      return weiRaised >= hardCap;\r\n    } else {\r\n      return token.totalSupply() >= hardCap;\r\n    }\r\n  }\r\n\r\n  function ended() public constant returns(bool) {\r\n    return capped() || block.timestamp >= endTime;\r\n  }\r\n\r\n\r\n  //  ██████╗ ██╗   ██╗████████╗███████╗██╗██████╗ ███████╗\r\n  // ██╔═══██╗██║   ██║╚══██╔══╝██╔════╝██║██╔══██╗██╔════╝\r\n  // ██║   ██║██║   ██║   ██║   ███████╗██║██║  ██║█████╗  \r\n  // ██║   ██║██║   ██║   ██║   ╚════██║██║██║  ██║██╔══╝  \r\n  // ╚██████╔╝╚██████╔╝   ██║   ███████║██║██████╔╝███████╗\r\n  //  ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚═╝╚═════╝ ╚══════╝\r\n  // fallback function can be used to buy tokens\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  function buyTokens(address _beneficiary) inState(State.Active) public payable {\r\n    require(!isDisableEther);\r\n    uint shipAmount = sellTokens(_beneficiary, msg.value, block.timestamp);\r\n    require(shipAmount > 0);\r\n    forwardEther();\r\n  }\r\n\r\n  function buyWithHash(address _beneficiary, uint _value, uint _timestamp, bytes32 _hash) \r\n    inState(State.Active) onlyOwner public \r\n  {\r\n    require(isAllowToIssue);\r\n    uint shipAmount = sellTokens(_beneficiary, _value, _timestamp);\r\n    require(shipAmount > 0);\r\n    HashBuy(_beneficiary, _value, shipAmount, _timestamp, _hash);\r\n  }\r\n  \r\n  function receiveApproval(address _from, \r\n                           uint256 _value, \r\n                           address _token, \r\n                           bytes _extraData) public \r\n  {\r\n    if (_token == address(token)) {\r\n      TokenInterface(_token).transferFrom(_from, address(this), _value);\r\n      return;\r\n    }\r\n\r\n    require(isTokenExchange);\r\n    \r\n    require(toUint(_extraData) == tokensValues[_token]);\r\n    require(tokensValues[_token] > 0);\r\n    require(forwardTokens(_from, _token, _value));\r\n\r\n    uint weiValue = _value.mul(tokensValues[_token]).div(10 ** allowedTokens[_token].decimals());\r\n    require(weiValue > 0);\r\n\r\n    uint shipAmount = sellTokens(_from, weiValue, block.timestamp);\r\n    require(shipAmount > 0);\r\n\r\n    AltBuy(_from, _token, _value, weiValue, shipAmount);\r\n  }\r\n\r\n  function claimFunds() onlyOwner public returns(bool) {\r\n    require(state == State.Claim || (isAllowClaimBeforeFinalization && success()));\r\n    wallet.transfer(address(this).balance);\r\n    return true;\r\n  }\r\n\r\n  function claimTokenFunds(address _token) onlyOwner public returns(bool) {\r\n    require(state == State.Claim || (isAllowClaimBeforeFinalization && success()));\r\n    uint balance = allowedTokens[_token].balanceOf(address(this));\r\n    require(balance > 0);\r\n    require(allowedTokens[_token].transfer(wallet, balance));\r\n    return true;\r\n  }\r\n\r\n  function claimRefundEther(address _beneficiary) inState(State.Refund) public returns(bool) {\r\n    require(weiDeposit[_beneficiary] > 0);\r\n    _beneficiary.transfer(weiDeposit[_beneficiary]);\r\n    return true;\r\n  }\r\n\r\n  function claimRefundTokens(address _beneficiary, address _token) inState(State.Refund) public returns(bool) {\r\n    require(altDeposit[_token][_beneficiary] > 0);\r\n    require(allowedTokens[_token].transfer(_beneficiary, altDeposit[_token][_beneficiary]));\r\n    return true;\r\n  }\r\n\r\n  function addToWhitelist(address _beneficiary, uint _min, uint _max) onlyOwner public\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_min <= _max);\r\n\r\n    if (_max == 0) {\r\n      _max = 10 ** 40; // should be huge enough? :0\r\n    }\r\n\r\n    whitelist[_beneficiary] = WhitelistRecord(true, _min, _max);\r\n    Whitelisted(_beneficiary, _min, _max);\r\n  }\r\n  \r\n  function setPersonalBonus(\r\n    address _beneficiary, \r\n    uint _bonus, \r\n    address _refererAddress, \r\n    uint _refererBonus) onlyOwner public {\r\n    personalBonuses[_beneficiary] = PersonalBonusRecord(\r\n      _bonus,\r\n      _refererAddress,\r\n      _refererBonus\r\n    );\r\n\r\n    PersonalBonus(_beneficiary, _refererAddress, _bonus, _refererBonus);\r\n  }\r\n\r\n  // ██╗███╗   ██╗████████╗███████╗██████╗ ███╗   ██╗ █████╗ ██╗     ███████╗\r\n  // ██║████╗  ██║╚══██╔══╝██╔════╝██╔══██╗████╗  ██║██╔══██╗██║     ██╔════╝\r\n  // ██║██╔██╗ ██║   ██║   █████╗  ██████╔╝██╔██╗ ██║███████║██║     ███████╗\r\n  // ██║██║╚██╗██║   ██║   ██╔══╝  ██╔══██╗██║╚██╗██║██╔══██║██║     ╚════██║\r\n  // ██║██║ ╚████║   ██║   ███████╗██║  ██║██║ ╚████║██║  ██║███████╗███████║\r\n  // ╚═╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚══════╝\r\n  // low level token purchase function\r\n  function sellTokens(address _beneficiary, uint _weiAmount, uint timestamp) \r\n    inState(State.Active) internal returns(uint)\r\n  {\r\n    uint beneficiaryTokens;\r\n    uint extraTokens;\r\n    uint totalTokens;\r\n    uint refererTokens;\r\n    address refererAddress;\r\n    (totalTokens, beneficiaryTokens, extraTokens, refererTokens, refererAddress) = calculateEthAmount(\r\n      _beneficiary, \r\n      _weiAmount, \r\n      timestamp, \r\n      token.totalSupply());\r\n\r\n    require(validPurchase(_beneficiary,   // Check if current purchase is valid\r\n                          _weiAmount, \r\n                          beneficiaryTokens,\r\n                          extraTokens,\r\n                          totalTokens,\r\n                          timestamp));\r\n\r\n    weiRaised = weiRaised.add(_weiAmount); // update state (wei amount)\r\n    beneficiaryInvest[_beneficiary] = beneficiaryInvest[_beneficiary].add(_weiAmount);\r\n    shipTokens(_beneficiary, beneficiaryTokens);     // ship tokens to beneficiary\r\n    EthBuy(msg.sender,             // Fire purchase event\r\n                  _beneficiary, \r\n                  _weiAmount, \r\n                  beneficiaryTokens);\r\n    ShipTokens(_beneficiary, beneficiaryTokens);\r\n\r\n    if (isExtraDistribution) {            // calculate and\r\n      shipTokens(extraTokensHolder, extraTokens);\r\n      ShipTokens(extraTokensHolder, extraTokens);\r\n    }\r\n\r\n    if (isPersonalBonuses) {\r\n      PersonalBonusRecord storage record = personalBonuses[_beneficiary];\r\n      if (record.refererAddress != address(0) && record.refererBonus > 0) {\r\n        shipTokens(record.refererAddress, refererTokens);\r\n        ShipTokens(record.refererAddress, refererTokens);\r\n      }\r\n    }\r\n\r\n    soldTokens = soldTokens.add(totalTokens);\r\n    return beneficiaryTokens;\r\n  }\r\n\r\n  function shipTokens(address _beneficiary, uint _amount) \r\n    inState(State.Active) internal \r\n  {\r\n    if (isTransferShipment) {\r\n      token.transfer(_beneficiary, _amount);\r\n    } else {\r\n      token.mint(address(this), _amount);\r\n      token.transfer(_beneficiary, _amount);\r\n    }\r\n  }\r\n\r\n  function forwardEther() internal returns (bool) {\r\n    weiDeposit[msg.sender] = msg.value;\r\n    return true;\r\n  }\r\n\r\n  function forwardTokens(address _beneficiary, address _tokenAddress, uint _amount) internal returns (bool) {\r\n    TokenInterface allowedToken = allowedTokens[_tokenAddress];\r\n    allowedToken.transferFrom(_beneficiary, address(this), _amount);\r\n    altDeposit[_tokenAddress][_beneficiary] = _amount;\r\n    return true;\r\n  }\r\n\r\n  // ██╗   ██╗████████╗██╗██╗     ███████╗\r\n  // ██║   ██║╚══██╔══╝██║██║     ██╔════╝\r\n  // ██║   ██║   ██║   ██║██║     ███████╗\r\n  // ██║   ██║   ██║   ██║██║     ╚════██║\r\n  // ╚██████╔╝   ██║   ██║███████╗███████║\r\n  //  ╚═════╝    ╚═╝   ╚═╝╚══════╝╚══════╝\r\n  function toUint(bytes left) public pure returns (uint) {\r\n      uint out;\r\n      for (uint i = 0; i < 32; i++) {\r\n          out |= uint(left[i]) << (31 * 8 - i * 8);\r\n      }\r\n      \r\n      return out;\r\n  }\r\n}\r\n\r\ncontract BaseAltCrowdsale is Crowdsale {\r\n  function BaseAltCrowdsale(\r\n    address _registry,\r\n    address _token,\r\n    address _extraTokensHolder,\r\n    address _wallet,\r\n    bool _isWhitelisted,\r\n    uint _price,\r\n    uint _start,\r\n    uint _end,\r\n    uint _softCap,\r\n    uint _hardCap\r\n  ) public {\r\n    setFlags(\r\n      // Should be whitelisted to buy tokens\r\n      // _isWhitelisted,\r\n      _isWhitelisted,\r\n      // Should be known user to buy tokens\r\n      // _isKnownOnly,\r\n      true,\r\n      // Enable amount bonuses in crowdsale? \r\n      // _isAmountBonus,\r\n      true,\r\n      // Enable early bird bonus in crowdsale?\r\n      // _isEarlyBonus,\r\n      true,\r\n      // Allow to buy tokens for another tokens?\r\n      // _isTokenExcange,\r\n      false,\r\n      // Allow to issue tokens with tx hash (ex bitcoin)\r\n      // _isAllowToIssue,\r\n      true,\r\n      // Should reject purchases with Ether?\r\n      // _isDisableEther,\r\n      false,\r\n      // Should mint extra tokens for future distribution?\r\n      // _isExtraDistribution,\r\n      true,\r\n      // Will ship token via minting? \r\n      // _isTransferShipment,\r\n      false,\r\n      // Should be capped in ether\r\n      // bool _isCappedInEther,\r\n      true,\r\n      // Should check personal bonuses?\r\n      // _isPersonalBonuses\r\n      true,\r\n      // Should allow to claimFunds before finalizations?\r\n      false\r\n    );\r\n\r\n    setToken(_token); \r\n    setTime(_start, _end);\r\n    setRegistry(_registry);\r\n    setWallet(_wallet);\r\n    setExtraDistribution(\r\n      _extraTokensHolder,\r\n      6667 // 66.67%\r\n    );\r\n\r\n    setSoftHardCaps(\r\n      _softCap, // soft\r\n      _hardCap  // hard\r\n    );\r\n\r\n    // 200 ALT per 1 ETH\r\n    setPrice(_price);\r\n  }\r\n}\r\n\r\ncontract AltCrowdsalePhaseOne is BaseAltCrowdsale {\r\n  function AltCrowdsalePhaseOne (\r\n    address _registry,\r\n    address _token,\r\n    address _extraTokensHolder,\r\n    address _wallet\r\n  )\r\n  BaseAltCrowdsale(\r\n    _registry,\r\n    _token,\r\n    _extraTokensHolder,\r\n    _wallet,\r\n\r\n    // Whitelisted\r\n    false,\r\n\r\n    // price 1 ETH -> 100000 ALT\r\n    uint(1 ether).div(100000), \r\n\r\n    // start\r\n    block.timestamp,\r\n    // end \r\n    1527764400,\r\n\r\n    // _softCap,\r\n    2500 ether,\r\n    // _hardCap\r\n    7500 ether\r\n  ) \r\n  public {\r\n  } \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"success\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeSlices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timeSlices\",\"type\":\"uint256[]\"},{\"name\":\"_bonuses\",\"type\":\"uint256[]\"}],\"name\":\"setTimeBonuses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"buyWithHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateTokenValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimRefundEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountSlices\",\"type\":\"uint256[]\"},{\"name\":\"_bonuses\",\"type\":\"uint256[]\"}],\"name\":\"setAmountBonuses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"calculateEthAmount\",\"outputs\":[{\"name\":\"calculatedTotal\",\"type\":\"uint256\"},{\"name\":\"calculatedBeneficiary\",\"type\":\"uint256\"},{\"name\":\"calculatedExtra\",\"type\":\"uint256\"},{\"name\":\"calculatedreferer\",\"type\":\"uint256\"},{\"name\":\"refererAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"altDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_inToken\",\"type\":\"bool\"}],\"name\":\"setMinimum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAllowToIssue\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCappedInEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amountSlices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTokenExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_futureOwner\",\"type\":\"address\"}],\"name\":\"finalizeIt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"grant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeSlicesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"saneIt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_at\",\"type\":\"uint256\"}],\"name\":\"calculateTimeBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumPurchaseValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"historyIt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"personalBonuses\",\"outputs\":[{\"name\":\"bonus\",\"type\":\"uint256\"},{\"name\":\"refererAddress\",\"type\":\"address\"},{\"name\":\"refererBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPersonalBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaryInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"left\",\"type\":\"bytes\"}],\"name\":\"toUint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_extraPart\",\"type\":\"uint256\"}],\"name\":\"setExtraDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_changeAmount\",\"type\":\"uint256\"}],\"name\":\"calculateAmountBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAllowClaimBeforeFinalization\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publisher\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAmountBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokenFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"allow\",\"type\":\"bool\"},{\"name\":\"min\",\"type\":\"uint256\"},{\"name\":\"max\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinimumValue\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimRefundTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDisableEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_min\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTransferShipment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isExtraDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinimumInEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setTokenExcange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"}],\"name\":\"setSoftHardCaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isWhitelisted\",\"type\":\"bool\"},{\"name\":\"_isKnownOnly\",\"type\":\"bool\"},{\"name\":\"_isAmountBonus\",\"type\":\"bool\"},{\"name\":\"_isEarlyBonus\",\"type\":\"bool\"},{\"name\":\"_isTokenExchange\",\"type\":\"bool\"},{\"name\":\"_isAllowToIssue\",\"type\":\"bool\"},{\"name\":\"_isDisableEther\",\"type\":\"bool\"},{\"name\":\"_isExtraDistribution\",\"type\":\"bool\"},{\"name\":\"_isTransferShipment\",\"type\":\"bool\"},{\"name\":\"_isCappedInEther\",\"type\":\"bool\"},{\"name\":\"_isPersonalBonuses\",\"type\":\"bool\"},{\"name\":\"_isAllowClaimBeforeFinalization\",\"type\":\"bool\"}],\"name\":\"setFlags\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amountBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"weiDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraDistributionPart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maybe_owner\",\"type\":\"address\"}],\"name\":\"checkOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountSlicesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isKnownOnly\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraTokensHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEarlyBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_extraAmount\",\"type\":\"uint256\"},{\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"validPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_bonus\",\"type\":\"uint256\"},{\"name\":\"_refererAddress\",\"type\":\"address\"},{\"name\":\"_refererBonus\",\"type\":\"uint256\"}],\"name\":\"setPersonalBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraTokensHolder\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bitcoinHash\",\"type\":\"bytes32\"}],\"name\":\"HashBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"allowedToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowedTokenValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"shipAmount\",\"type\":\"uint256\"}],\"name\":\"AltBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ShipTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Sanetize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"min\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refererBonus\",\"type\":\"uint256\"}],\"name\":\"PersonalBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AccessGrant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AccessRevoke\",\"type\":\"event\"}]","ContractName":"AltCrowdsalePhaseOne","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002b9b9c4f55a93c4cbf6133a66711d99f78c500910000000000000000000000008b2da472ddcd2aa76e70b86d026e65b176902941000000000000000000000000e746f3be8c69b05e3ca38760f1eb8c55d24da2c900000000000000000000000007ebf23d47c16c9bfc5510c0e931e397a60f7f11","Library":"","SwarmSource":"bzzr://29a6259f5fee4e6ce4069a5c05649496bc0cf24e2c8e9de1eb5aef9af44bff89"}]}