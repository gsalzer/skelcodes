{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\ncontract Withdrawable is Ownable {\r\n    // Allows owner to withdraw ether from the contract\r\n    function withdrawEther(address to) public onlyOwner {\r\n        to.transfer(address(this).balance);\r\n    }\r\n\r\n    // Allows owner to withdraw ERC20 tokens from the contract\r\n    function withdrawERC20Token(address tokenAddress, address to) public onlyOwner {\r\n        ERC20Basic token = ERC20Basic(tokenAddress);\r\n        token.transfer(to, token.balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract RaindropClient is Withdrawable {\r\n    // Events for when a user signs up for Raindrop Client and when their account is deleted\r\n    event UserSignUp(string userName, address userAddress, bool delegated);\r\n    event UserDeleted(string userName);\r\n\r\n    // Variables allowing this contract to interact with the Hydro token\r\n    address public hydroTokenAddress;\r\n    uint public minimumHydroStakeUser;\r\n    uint public minimumHydroStakeDelegatedUser;\r\n\r\n    // User account template\r\n    struct User {\r\n        string userName;\r\n        address userAddress;\r\n        bool delegated;\r\n        bool _initialized;\r\n    }\r\n\r\n    // Mapping from hashed names to users (primary User directory)\r\n    mapping (bytes32 => User) internal userDirectory;\r\n    // Mapping from addresses to hashed names (secondary directory for account recovery based on address)\r\n    mapping (address => bytes32) internal nameDirectory;\r\n\r\n    // Requires an address to have a minimum number of Hydro\r\n    modifier requireStake(address _address, uint stake) {\r\n        ERC20Basic hydro = ERC20Basic(hydroTokenAddress);\r\n        require(hydro.balanceOf(_address) >= stake);\r\n        _;\r\n    }\r\n\r\n    // Allows applications to sign up users on their behalf iff users signed their permission\r\n    function signUpDelegatedUser(string userName, address userAddress, uint8 v, bytes32 r, bytes32 s)\r\n        public\r\n        requireStake(msg.sender, minimumHydroStakeDelegatedUser)\r\n    {\r\n        require(isSigned(userAddress, keccak256(\"Create RaindropClient Hydro Account\"), v, r, s));\r\n        _userSignUp(userName, userAddress, true);\r\n    }\r\n\r\n    // Allows users to sign up with their own address\r\n    function signUpUser(string userName) public requireStake(msg.sender, minimumHydroStakeUser) {\r\n        return _userSignUp(userName, msg.sender, false);\r\n    }\r\n\r\n    // Allows users to delete their accounts\r\n    function deleteUser() public {\r\n        bytes32 userNameHash = nameDirectory[msg.sender];\r\n        require(userDirectory[userNameHash]._initialized);\r\n\r\n        string memory userName = userDirectory[userNameHash].userName;\r\n\r\n        delete nameDirectory[msg.sender];\r\n        delete userDirectory[userNameHash];\r\n\r\n        emit UserDeleted(userName);\r\n    }\r\n\r\n    // Allows the Hydro API to link to the Hydro token\r\n    function setHydroTokenAddress(address _hydroTokenAddress) public onlyOwner {\r\n        hydroTokenAddress = _hydroTokenAddress;\r\n    }\r\n\r\n    // Allows the Hydro API to set minimum hydro balances required for sign ups\r\n    function setMinimumHydroStakes(uint newMinimumHydroStakeUser, uint newMinimumHydroStakeDelegatedUser) public {\r\n        ERC20Basic hydro = ERC20Basic(hydroTokenAddress);\r\n        require(newMinimumHydroStakeUser <= (hydro.totalSupply() / 100 / 10)); // <= .1% of total supply\r\n        require(newMinimumHydroStakeDelegatedUser <= (hydro.totalSupply() / 100)); // <= 1% of total supply\r\n        minimumHydroStakeUser = newMinimumHydroStakeUser;\r\n        minimumHydroStakeDelegatedUser = newMinimumHydroStakeDelegatedUser;\r\n    }\r\n\r\n    // Returns a bool indicated whether a given userName has been claimed\r\n    function userNameTaken(string userName) public view returns (bool taken) {\r\n        bytes32 userNameHash = keccak256(userName);\r\n        return userDirectory[userNameHash]._initialized;\r\n    }\r\n\r\n    // Returns user details by user name\r\n    function getUserByName(string userName) public view returns (address userAddress, bool delegated) {\r\n        bytes32 userNameHash = keccak256(userName);\r\n        User storage _user = userDirectory[userNameHash];\r\n        require(_user._initialized);\r\n\r\n        return (_user.userAddress, _user.delegated);\r\n    }\r\n\r\n    // Returns user details by user address\r\n    function getUserByAddress(address _address) public view returns (string userName, bool delegated) {\r\n        bytes32 userNameHash = nameDirectory[_address];\r\n        User storage _user = userDirectory[userNameHash];\r\n        require(_user._initialized);\r\n\r\n        return (_user.userName, _user.delegated);\r\n    }\r\n\r\n    // Checks whether the provided (v, r, s) signature was created by the private key associated with _address\r\n    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {\r\n        return (_isSigned(_address, messageHash, v, r, s) || _isSignedPrefixed(_address, messageHash, v, r, s));\r\n    }\r\n\r\n    // Checks unprefixed signatures\r\n    function _isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return ecrecover(messageHash, v, r, s) == _address;\r\n    }\r\n\r\n    // Checks prefixed signatures (e.g. those created with web3.eth.sign)\r\n    function _isSignedPrefixed(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedMessageHash = keccak256(prefix, messageHash);\r\n\r\n        return ecrecover(prefixedMessageHash, v, r, s) == _address;\r\n    }\r\n\r\n    // Common internal logic for all user signups\r\n    function _userSignUp(string userName, address userAddress, bool delegated) internal {\r\n        require(bytes(userName).length < 100);\r\n        bytes32 userNameHash = keccak256(userName);\r\n        require(!userDirectory[userNameHash]._initialized);\r\n\r\n        userDirectory[userNameHash] = User(userName, userAddress, delegated, true);\r\n        nameDirectory[userAddress] = userNameHash;\r\n\r\n        emit UserSignUp(userName, userAddress, delegated);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"deleteUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumHydroStakeUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userName\",\"type\":\"string\"},{\"name\":\"userAddress\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signUpDelegatedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userName\",\"type\":\"string\"}],\"name\":\"signUpUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userName\",\"type\":\"string\"}],\"name\":\"getUserByName\",\"outputs\":[{\"name\":\"userAddress\",\"type\":\"address\"},{\"name\":\"delegated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserByAddress\",\"outputs\":[{\"name\":\"userName\",\"type\":\"string\"},{\"name\":\"delegated\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hydroTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumHydroStakeUser\",\"type\":\"uint256\"},{\"name\":\"newMinimumHydroStakeDelegatedUser\",\"type\":\"uint256\"}],\"name\":\"setMinimumHydroStakes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"isSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumHydroStakeDelegatedUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hydroTokenAddress\",\"type\":\"address\"}],\"name\":\"setHydroTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userName\",\"type\":\"string\"}],\"name\":\"userNameTaken\",\"outputs\":[{\"name\":\"taken\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"userName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegated\",\"type\":\"bool\"}],\"name\":\"UserSignUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"userName\",\"type\":\"string\"}],\"name\":\"UserDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RaindropClient","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c66e2fbb69fdfc4476966cc9fdd575e818eccfc120baaa1c2ad280d4186a2399"}]}