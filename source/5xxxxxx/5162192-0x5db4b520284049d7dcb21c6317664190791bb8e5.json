{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\ncontract Tangent is ERC20Interface, Owned {\r\n    using SafeMath for uint;\r\n\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    function Tangent() public {\r\n        symbol = \"TAN\";\r\n        name = \"Tangent\";\r\n        decimals = 18;\r\n        _totalSupply = 1000000000 * 10**uint(decimals);\r\n        balances[owner] = _totalSupply;\r\n        Transfer(address(0), owner, _totalSupply);\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}\r\n\r\ncontract TangentStake is Owned {\r\n    // prevents overflows\r\n    using SafeMath for uint;\r\n    \r\n    // represents a purchase object\r\n    // addr is the buying address\r\n    // amount is the number of wei in the purchase\r\n    // sf is the sum of (purchase amount / sum of previous purchase amounts)\r\n    struct Purchase {\r\n        address addr;\r\n        uint amount;\r\n        uint sf;\r\n    }\r\n    \r\n    // Purchase object array that holds entire purchase history\r\n    Purchase[] purchases;\r\n    \r\n    // tangents are rewarded along with Ether upon cashing out\r\n    Tangent tokenContract;\r\n    \r\n    // the rate of tangents to ether is multiplier / divisor\r\n    uint multiplier;\r\n    uint divisor;\r\n    \r\n    // accuracy multiplier\r\n    uint acm;\r\n    \r\n    uint netStakes;\r\n    \r\n    // logged when a purchase is made\r\n    event PurchaseEvent(uint index, address addr, uint eth, uint sf);\r\n    \r\n    // logged when a person cashes out or the contract is destroyed\r\n    event CashOutEvent(uint index, address addr, uint eth, uint tangles);\r\n    \r\n    event NetStakesChange(uint netStakes);\r\n    \r\n    // logged when the rate of tangents to ether is decreased\r\n    event Revaluation(uint oldMul, uint oldDiv, uint newMul, uint newDiv);\r\n    \r\n    // constructor, sets initial rate to 1000 TAN per 1 Ether\r\n    function TangentStake(address tokenAddress) public {\r\n        tokenContract = Tangent(tokenAddress);\r\n        multiplier = 1000;\r\n        divisor = 1;\r\n        acm = 10**18;\r\n        netStakes = 0;\r\n    }\r\n    \r\n    // decreases the rate of Tangents to Ether, the contract cannot be told\r\n    // to give out more Tangents per Ether, only fewer.\r\n    function revalue(uint newMul, uint newDiv) public onlyOwner {\r\n        require( (newMul.div(newDiv)) <= (multiplier.div(divisor)) );\r\n        Revaluation(multiplier, divisor, newMul, newDiv);\r\n        multiplier = newMul;\r\n        divisor = newDiv;\r\n        return;\r\n    }\r\n    \r\n    // returns the current amount of wei that will be given for the purchase \r\n    // at purchases[index]\r\n    function getEarnings(uint index) public constant returns (uint earnings, uint amount) {\r\n        Purchase memory cpurchase;\r\n        Purchase memory lpurchase;\r\n        \r\n        cpurchase = purchases[index];\r\n        amount = cpurchase.amount;\r\n        \r\n        if (cpurchase.addr == address(0)) {\r\n            return (0, amount);\r\n        }\r\n        \r\n        earnings = (index == 0) ? acm : 0;\r\n        lpurchase = purchases[purchases.length-1];\r\n        earnings = earnings.add( lpurchase.sf.sub(cpurchase.sf) );\r\n        earnings = earnings.mul(amount).div(acm);\r\n        return (earnings, amount);\r\n    }\r\n    \r\n    // Cash out Ether and Tangent at for the purchase at index \"index\".\r\n    // All of the Ether and Tangent associated with with that purchase will\r\n    // be sent to recipient, and no future withdrawals can be made for the\r\n    // purchase.\r\n    function cashOut(uint index) public {\r\n        require(0 <= index && index < purchases.length);\r\n        require(purchases[index].addr == msg.sender);\r\n        \r\n        uint earnings;\r\n        uint amount;\r\n        uint tangles;\r\n        \r\n        (earnings, amount) = getEarnings(index);\r\n        purchases[index].addr = address(0);\r\n        require(earnings != 0 && amount != 0);\r\n        netStakes = netStakes.sub(amount);\r\n        \r\n        tangles = earnings.mul(multiplier).div(divisor);\r\n        CashOutEvent(index, msg.sender, earnings, tangles);\r\n        NetStakesChange(netStakes);\r\n        \r\n        tokenContract.transfer(msg.sender, tangles);\r\n        msg.sender.transfer(earnings);\r\n        return;\r\n    }\r\n    \r\n    \r\n    // The fallback function used to purchase stakes\r\n    // sf is the sum of the proportions of:\r\n    // (ether of current purchase / sum of ether prior to purchase)\r\n    // It is used to calculate earnings upon withdrawal.\r\n    function () public payable {\r\n        require(msg.value != 0);\r\n        \r\n        uint index = purchases.length;\r\n        uint sf;\r\n        uint f;\r\n        \r\n        if (index == 0) {\r\n            sf = 0;\r\n        } else {\r\n            f = msg.value.mul(acm).div(netStakes);\r\n            sf = purchases[index-1].sf.add(f);\r\n        }\r\n        \r\n        netStakes = netStakes.add(msg.value);\r\n        purchases.push(Purchase(msg.sender, msg.value, sf));\r\n        \r\n        NetStakesChange(netStakes);\r\n        PurchaseEvent(index, msg.sender, msg.value, sf);\r\n        return;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newMul\",\"type\":\"uint256\"},{\"name\":\"newDiv\",\"type\":\"uint256\"}],\"name\":\"revalue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"cashOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getEarnings\",\"outputs\":[{\"name\":\"earnings\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sf\",\"type\":\"uint256\"}],\"name\":\"PurchaseEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tangles\",\"type\":\"uint256\"}],\"name\":\"CashOutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"netStakes\",\"type\":\"uint256\"}],\"name\":\"NetStakesChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMul\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldDiv\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newMul\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDiv\",\"type\":\"uint256\"}],\"name\":\"Revaluation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TangentStake","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000071747928e976c48928418c71c52482bdd8e7c61d","Library":"","SwarmSource":"bzzr://fd10ee54578c0b64fc35a5085b768db7aa513868eae12cd89826e489514eb8ef"}]}