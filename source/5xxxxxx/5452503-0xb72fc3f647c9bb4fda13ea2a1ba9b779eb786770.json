{"status":"1","message":"OK","result":[{"SourceCode":"contract SafeMath {\r\n    \r\n    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        require(x <= (MAX_UINT256 / y));\r\n        return x * y;\r\n    }\r\n}\r\ncontract ERC20TokenInterface {\r\n    function totalSupply() public constant returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract tokenRecipientInterface {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\r\n}\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\n\r\ncontract MintableTokenInterface {\r\n    function mint(address _to, uint256 _amount) public;\r\n}\r\ncontract ReentrancyHandlingContract{\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\ncontract KycContractInterface {\r\n    function isAddressVerified(address _address) public view returns (bool);\r\n}\r\ncontract MintingContractInterface {\r\n\r\n    address public crowdsaleContractAddress;\r\n    address public tokenContractAddress;\r\n    uint public tokenTotalSupply;\r\n\r\n    event MintMade(address _to, uint _ethAmount, uint _tokensMinted, string _message);\r\n\r\n    function doPresaleMinting(address _destination, uint _tokensAmount, uint _ethAmount) public;\r\n    function doCrowdsaleMinting(address _destination, uint _tokensAmount, uint _ethAmount) public;\r\n    function doTeamMinting(address _destination) public;\r\n    function setTokenContractAddress(address _newAddress) public;\r\n    function setCrowdsaleContractAddress(address _newAddress) public;\r\n    function killContract() public;\r\n}\r\ncontract Lockable is Owned {\r\n\r\n    uint256 public lockedUntilBlock;\r\n\r\n    event ContractLocked(uint256 _untilBlock, string _reason);\r\n\r\n    modifier lockAffected {\r\n        require(block.number > lockedUntilBlock);\r\n        _;\r\n    }\r\n\r\n    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\r\n        lockedUntilBlock = _untilBlock;\r\n        emit ContractLocked(_untilBlock, _reason);\r\n    }\r\n\r\n\r\n    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\r\n        lockedUntilBlock = _untilBlock;\r\n        emit ContractLocked(_untilBlock, _reason);\r\n    }\r\n}\r\n\r\ncontract Crowdsale is ReentrancyHandlingContract, Owned {\r\n    \r\n    enum state { pendingStart, crowdsale, crowdsaleEnded }\r\n    struct ContributorData {\r\n        uint contributionAmount;\r\n        uint tokensIssued;\r\n    }\r\n\r\n    state public crowdsaleState = state.pendingStart;\r\n    \r\n    address public multisigAddress;\r\n    address public tokenAddress = 0x0;\r\n    address public kycAddress = 0x0;\r\n    address public mintingContractAddress = 0x0;\r\n\r\n    uint public startPhaseLength = 720;\r\n    uint public startPhaseMinimumContribution = 0.1 * 10**18;\r\n    uint public startPhaseMaximumcontribution = 40 * 10**18;\r\n\r\n    uint public crowdsaleStartBlock;\r\n    uint public crowdsaleEndedBlock;\r\n\r\n    mapping(address => ContributorData) public contributorList;\r\n    uint nextContributorIndex;\r\n    mapping(uint => address) contributorIndexes;\r\n\r\n    uint public minCap;\r\n    uint public maxCap;\r\n    uint public ethRaised;\r\n    uint public tokenTotalSupply = 300000000 * 10**18;\r\n    uint public tokensIssued = 0;\r\n    uint blocksInADay;\r\n\r\n    event CrowdsaleStarted(uint blockNumber);\r\n    event CrowdsaleEnded(uint blockNumber);\r\n    event ErrorSendingETH(address to, uint amount);\r\n    event MinCapReached(uint blockNumber);\r\n    event MaxCapReached(uint blockNumber);\r\n\r\n    uint nextContributorToClaim;\r\n    mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n    function() noReentrancy payable public {\r\n        require(msg.value != 0);\r\n        require(crowdsaleState != state.crowdsaleEnded);\r\n        require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));\r\n\r\n        bool stateChanged = checkCrowdsaleState();\r\n\r\n        if (crowdsaleState == state.crowdsale) {\r\n            processTransaction(msg.sender, msg.value);\r\n        } else {\r\n            refundTransaction(stateChanged);\r\n        }\r\n    }\r\n\r\n    function checkCrowdsaleState() internal returns (bool) {\r\n        if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {\r\n            crowdsaleState = state.crowdsaleEnded;\r\n            emit CrowdsaleEnded(block.number);\r\n            return true;\r\n        }\r\n\r\n        if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {\r\n            if (crowdsaleState != state.crowdsale) {\r\n                crowdsaleState = state.crowdsale;\r\n                emit CrowdsaleStarted(block.number);\r\n                return true;\r\n            }\r\n        } else {\r\n            if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {\r\n                crowdsaleState = state.crowdsaleEnded;\r\n                emit CrowdsaleEnded(block.number);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function refundTransaction(bool _stateChanged) internal {\r\n        if (_stateChanged) {\r\n            msg.sender.transfer(msg.value);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\r\n        if (tokensIssued <= 20000000 * 10**18) {\r\n            return _eth * 8640;\r\n        } else if(tokensIssued <= 40000000 * 10**18) {\r\n            return _eth * 8480;\r\n        } else if(tokensIssued <= 60000000 * 10**18) {\r\n            return _eth * 8320;\r\n        } else if(tokensIssued <= 80000000 * 10**18) {\r\n            return _eth * 8160;\r\n        } else {\r\n            return _eth * 8000;\r\n        }\r\n    }\r\n\r\n    function calculateTokenToEth(uint _token, uint _blockNumber) constant public returns(uint) {\r\n        uint tempTokenAmount;\r\n        if (tokensIssued <= 20000000 * 10**18) {\r\n            tempTokenAmount = _token * 1000 / 1008640;\r\n        } else if(tokensIssued <= 40000000 * 10**18) {\r\n            tempTokenAmount = _token * 1000 / 8480;\r\n        } else if(tokensIssued <= 60000000 * 10**18) {\r\n            tempTokenAmount = _token * 1000 / 8320;\r\n        } else if(tokensIssued <= 80000000 * 10**18) {\r\n            tempTokenAmount = _token * 1000 / 8160;\r\n        } else {\r\n            tempTokenAmount = _token * 1000 / 8000;\r\n        }\r\n        return tempTokenAmount / 1000;\r\n    }\r\n\r\n    function processTransaction(address _contributor, uint _amount) internal {\r\n        uint contributionAmount = 0;\r\n        uint returnAmount = 0;\r\n        uint tokensToGive = 0;\r\n\r\n        if (block.number < crowdsaleStartBlock + startPhaseLength && _amount > startPhaseMaximumcontribution) {\r\n            contributionAmount = startPhaseMaximumcontribution;\r\n            returnAmount = _amount - startPhaseMaximumcontribution;\r\n        } else {\r\n            contributionAmount = _amount;\r\n        }\r\n        tokensToGive = calculateEthToToken(contributionAmount, block.number);\r\n\r\n        if (tokensToGive > (maxCap - tokensIssued)) {\r\n            contributionAmount = calculateTokenToEth(maxCap - tokensIssued, block.number);\r\n            returnAmount = _amount - contributionAmount;\r\n            tokensToGive = maxCap - tokensIssued;\r\n            emit MaxCapReached(block.number);\r\n        }\r\n\r\n        if (contributorList[_contributor].contributionAmount == 0) {\r\n            contributorIndexes[nextContributorIndex] = _contributor;\r\n            nextContributorIndex += 1;\r\n        }\r\n\r\n        contributorList[_contributor].contributionAmount += contributionAmount;\r\n        ethRaised += contributionAmount;\r\n\r\n        if (tokensToGive > 0) {\r\n            MintingContractInterface(mintingContractAddress).doCrowdsaleMinting(_contributor, tokensToGive, contributionAmount);\r\n            contributorList[_contributor].tokensIssued += tokensToGive;\r\n            tokensIssued += tokensToGive;\r\n        }\r\n        if (returnAmount != 0) {\r\n            _contributor.transfer(returnAmount);\r\n        } \r\n    }\r\n\r\n    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n\r\n    function withdrawEth() onlyOwner public {\r\n        require(this.balance != 0);\r\n        require(tokensIssued >= minCap);\r\n\r\n        multisigAddress.transfer(this.balance);\r\n    }\r\n\r\n    function claimEthIfFailed() public {\r\n        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\r\n        require(contributorList[msg.sender].contributionAmount > 0);\r\n        require(!hasClaimedEthWhenFail[msg.sender]);\r\n\r\n        uint ethContributed = contributorList[msg.sender].contributionAmount;\r\n        hasClaimedEthWhenFail[msg.sender] = true;\r\n        if (!msg.sender.send(ethContributed)) {\r\n            emit ErrorSendingETH(msg.sender, ethContributed);\r\n        }\r\n    }\r\n\r\n    function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\r\n        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\r\n        address currentParticipantAddress;\r\n        uint contribution;\r\n        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n            currentParticipantAddress = contributorIndexes[nextContributorToClaim];\r\n            if (currentParticipantAddress == 0x0) {\r\n                return;\r\n            }\r\n            if (!hasClaimedEthWhenFail[currentParticipantAddress]) {\r\n                contribution = contributorList[currentParticipantAddress].contributionAmount;\r\n                hasClaimedEthWhenFail[currentParticipantAddress] = true;\r\n                if (!currentParticipantAddress.send(contribution)) {\r\n                    emit ErrorSendingETH(currentParticipantAddress, contribution);\r\n                }\r\n            }\r\n            nextContributorToClaim += 1;\r\n        }\r\n    }\r\n\r\n    function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\r\n        require(this.balance != 0);\r\n        require(block.number > crowdsaleEndedBlock);\r\n        require(contributorIndexes[nextContributorToClaim] == 0x0);\r\n        multisigAddress.transfer(this.balance);\r\n    }\r\n\r\n    function setMultisigAddress(address _newAddress) onlyOwner public {\r\n        multisigAddress = _newAddress;\r\n    }\r\n\r\n    function setToken(address _newAddress) onlyOwner public {\r\n        tokenAddress = _newAddress;\r\n    }\r\n\r\n    function setKycAddress(address _newAddress) onlyOwner public {\r\n        kycAddress = _newAddress;\r\n    }\r\n\r\n    function investorCount() constant public returns(uint) {\r\n        return nextContributorIndex;\r\n    }\r\n\r\n    function setCrowdsaleStartBlock(uint _block) onlyOwner public {\r\n        crowdsaleStartBlock = _block;\r\n    }\r\n}\r\n\r\ncontract ERC20Token is ERC20TokenInterface, SafeMath, Owned, Lockable {\r\n\r\n    string public standard;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public mintingContractAddress;\r\n\r\n    uint256 supply = 0;\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowances;\r\n\r\n    event Mint(address indexed _to, uint256 _value);\r\n    event Burn(address indexed _from, uint _value);\r\n\r\n    function totalSupply() constant public returns (uint256) {\r\n        return supply;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) lockAffected public returns (bool success) {\r\n        require(_to != 0x0 && _to != address(this));\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) lockAffected public returns (bool success) {\r\n        allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) lockAffected public returns (bool success) {\r\n        tokenRecipientInterface spender = tokenRecipientInterface(_spender);\r\n        approve(_spender, _value);\r\n        spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) lockAffected public returns (bool success) {\r\n        require(_to != 0x0 && _to != address(this));\r\n        balances[_from] = safeSub(balanceOf(_from), _value);\r\n        balances[_to] = safeAdd(balanceOf(_to), _value);\r\n        allowances[_from][msg.sender] = safeSub(allowances[_from][msg.sender], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n    function mint(address _to, uint256 _amount) public {\r\n        require(msg.sender == mintingContractAddress);\r\n        supply = safeAdd(supply, _amount);\r\n        balances[_to] = safeAdd(balances[_to], _amount);\r\n        emit Mint(_to, _amount);\r\n        emit Transfer(0x0, _to, _amount);\r\n    }\r\n\r\n    function burn(uint _amount) public {\r\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _amount);\r\n        supply = safeSub(supply, _amount);\r\n        emit Burn(msg.sender, _amount);\r\n        emit Transfer(msg.sender, 0x0, _amount);\r\n    }\r\n\r\n    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n\r\n    function killContract() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\ncontract EligmaMintingContract is Owned{\r\n\r\n    address public crowdsaleContractAddress;\r\n    address public tokenContractAddress;\r\n    uint public tokenTotalSupply;\r\n\r\n    event MintMade(address _to, uint _tokensMinted, string _message);\r\n\r\n    function EligmaMintingContract() public {\r\n        tokenTotalSupply = 500000000 * 10 ** 18;\r\n    }\r\n\r\n    function doPresaleMinting(address _destination, uint _tokensAmount) public onlyOwner {\r\n        require(ERC20TokenInterface(tokenContractAddress).totalSupply() + _tokensAmount <= tokenTotalSupply);\r\n        MintableTokenInterface(tokenContractAddress).mint(_destination, _tokensAmount);\r\n        emit MintMade(_destination, _tokensAmount, \"Presale mint\");\r\n    }\r\n\r\n    function doCrowdsaleMinting(address _destination, uint _tokensAmount) public {\r\n        require(msg.sender == crowdsaleContractAddress);\r\n        require(ERC20TokenInterface(tokenContractAddress).totalSupply() + _tokensAmount <= tokenTotalSupply);\r\n        MintableTokenInterface(tokenContractAddress).mint(_destination, _tokensAmount);\r\n        emit MintMade(_destination, _tokensAmount, \"Crowdsale mint\");\r\n    }\r\n\r\n    function doTeamMinting(address _destination) public onlyOwner {\r\n        require(ERC20TokenInterface(tokenContractAddress).totalSupply() < tokenTotalSupply);\r\n        uint amountToMint = tokenTotalSupply - ERC20TokenInterface(tokenContractAddress).totalSupply();\r\n        MintableTokenInterface(tokenContractAddress).mint(_destination, amountToMint);\r\n        emit MintMade(_destination, amountToMint, \"Team mint\");\r\n    }\r\n\r\n    function setTokenContractAddress(address _newAddress) public onlyOwner {\r\n        tokenContractAddress = _newAddress;\r\n    }\r\n\r\n    function setCrowdsaleContractAddress(address _newAddress) public onlyOwner {\r\n        crowdsaleContractAddress = _newAddress;\r\n    }\r\n\r\n    function killContract() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setCrowdsaleContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_tokensAmount\",\"type\":\"uint256\"}],\"name\":\"doPresaleMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_tokensAmount\",\"type\":\"uint256\"}],\"name\":\"doCrowdsaleMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setTokenContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"doTeamMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"MintMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"EligmaMintingContract","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ad4010ab8c3ca1749d2e8564b9f811c0078c4171cbdf2147f364757c5a6c269f"}]}