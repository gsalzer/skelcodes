{"status":"1","message":"OK","result":[{"SourceCode":"// v7\r\n\r\n/**\r\n * Crowdsale.sol\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, throws on overflow.\r\n   * @param a First number\r\n   * @param b Second number\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   * @param a First number\r\n   * @param b Second number\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param a First number\r\n   * @param b Second number\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   * @param a First number\r\n   * @param b Second number\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title TokenContract\r\n * @dev Token contract interface with transfer and balanceOf functions which need to be implemented\r\n */\r\ninterface TokenContract {\r\n\r\n  /**\r\n   * @dev Transfer funds to recipient address\r\n   * @param _recipient Recipients address\r\n   * @param _amount Amount to transfer\r\n   */\r\n  function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Return balance of holders address\r\n   * @param _holder Holders address\r\n   */\r\n  function balanceOf(address _holder) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title InvestorsStorage\r\n * @dev InvestorStorage contract interface with newInvestment, getInvestedAmount and investmentRefunded functions which need to be implemented\r\n */\r\ninterface InvestorsStorage {\r\n  function newInvestment(address _investor, uint256 _amount) external;\r\n  function getInvestedAmount(address _investor) external view returns (uint256);\r\n  function investmentRefunded(address _investor) external;\r\n}\r\n\r\n/**\r\n * @title CrowdSale\r\n * @dev Main Crowdsale Contract which executes and handles crowdsale of the tokens\r\n */\r\ncontract CrowdSale is Ownable {\r\n  using SafeMath for uint256;\r\n  // variables\r\n\r\n  TokenContract public tkn;\r\n\r\n  InvestorsStorage public investorsStorage;\r\n  uint256 public levelEndDate;\r\n  uint256 public currentLevel;\r\n  uint256 public levelTokens = 1500000;\r\n  uint256 public tokensSold;\r\n  uint256 public weiRised;\r\n  uint256 public ethPrice;\r\n  address[] public investorsList;\r\n  bool public crowdSalePaused;\r\n  bool public crowdSaleEnded;\r\n  uint256[10] private tokenPrice = [52, 54, 56, 58, 60, 62, 64, 66, 68, 70];\r\n  uint256 private baseTokens = 1500000;\r\n  uint256 private usdCentValue;\r\n  uint256 private minInvestment;\r\n  address public affiliatesAddress = 0xFD534c1Fd8f9F230deA015B31B77679a8475052A;\r\n\r\n  /**\r\n   * @dev Constructor of CrowdSale contract\r\n   */\r\n   constructor() public {\r\n    levelEndDate = block.timestamp + (1 * 7 days);\r\n    tkn = TokenContract(0x5313E9783E5b56389b14Cd2a99bE9d283a03f8c6);                    // address of the token contract\r\n    investorsStorage = InvestorsStorage(0x15c7c30B980ef442d3C811A30346bF9Dd8906137);      // address of the storage contract\r\n    minInvestment = 100 finney;\r\n    updatePrice(5000);\r\n  }\r\n\r\n  /**\r\n   * @dev Fallback payable function which executes additional checks and functionality when tokens need to be sent to the investor\r\n   */\r\n  function() payable public {\r\n    require(msg.value >= minInvestment); // check for minimum investment amount\r\n    require(!crowdSalePaused);\r\n    require(!crowdSaleEnded);\r\n    if (currentLevel < 9) { // there are 10 levels, array start with 0\r\n      if (levelEndDate < block.timestamp) { // if the end date of the level is reached\r\n        currentLevel += 1; // next level\r\n        levelTokens += baseTokens; // add remaining tokens to next level\r\n        levelEndDate = levelEndDate.add(1 * 7 days); // restart end date\r\n        }\r\n      prepareSell(msg.sender, msg.value);\r\n    } else {\r\n      if (levelEndDate < block.timestamp) { // on last level, ask for extension, if the crowd sale is not extended then end\r\n        crowdSaleEnded = true;\r\n        msg.sender.transfer(msg.value);\r\n        } else {\r\n        prepareSell(msg.sender, msg.value);\r\n        }\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @dev Prepare sell of the tokens\r\n   * @param _investor Investors address\r\n   * @param _amount Amount invested\r\n   */\r\n  function prepareSell(address _investor, uint256 _amount) private {\r\n    uint256 remaining;\r\n    uint256 pricePerCent;\r\n    uint256 pricePerToken;\r\n    uint256 toSell;\r\n    uint256 amount = _amount;\r\n    uint256 sellInWei;\r\n    address investor = _investor;\r\n\r\n    pricePerCent = getUSDPrice();\r\n    pricePerToken = pricePerCent.mul(tokenPrice[currentLevel]);\r\n    toSell = _amount.div(pricePerToken);\r\n\r\n    if (toSell < levelTokens) { // if there is enough tokens left in the current level, sell from it\r\n      levelTokens = levelTokens.sub(toSell);\r\n      weiRised = weiRised.add(_amount);\r\n      executeSell(investor, toSell, _amount);\r\n      owner.transfer(_amount);\r\n    } else {  // if not, sell from 2 or more different levels\r\n      while (amount > 0) {\r\n        if (toSell > levelTokens) {\r\n          toSell = levelTokens; // sell all the remaining in the level\r\n          sellInWei = toSell.mul(pricePerToken);\r\n          amount = amount.sub(sellInWei);\r\n          if (currentLevel < 9) {\r\n            currentLevel += 1;\r\n            levelTokens = baseTokens;\r\n            if (currentLevel == 9) {\r\n              baseTokens = tkn.balanceOf(address(this));  // on last level, sell the remaining from presale\r\n            }\r\n          } else {\r\n            remaining = amount;\r\n            amount = 0;\r\n          }\r\n        } else {\r\n          sellInWei = amount;\r\n          amount = 0;\r\n        }\r\n\r\n        executeSell(investor, toSell, sellInWei);\r\n        weiRised = weiRised.add(sellInWei);\r\n        owner.transfer(amount);\r\n        if (amount > 0) {\r\n          toSell = amount.div(pricePerToken);\r\n        }\r\n        if (remaining > 0) {\r\n          investor.transfer(remaining);\r\n          owner.transfer(address(this).balance);\r\n          crowdSaleEnded = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Execute sell of the tokens - send investor to investors storage and transfer tokens\r\n   * @param _investor Investors address\r\n   * @param _tokens Amount of tokens to be sent\r\n   * @param _weiAmount Amount invested in wei\r\n   */\r\n  function executeSell(address _investor, uint256 _tokens, uint256 _weiAmount) private {\r\n    uint256 totalTokens = _tokens * (10 ** 18);\r\n    tokensSold += _tokens; // update tokens sold\r\n    investorsStorage.newInvestment(_investor, _weiAmount);\r\n\r\n    require(tkn.transfer(_investor, totalTokens)); // transfer the tokens to the investor\r\n    emit NewInvestment(_investor, totalTokens);\r\n  }\r\n\r\n  /**\r\n   * @dev When the crowdsale ends, tokens left are sent to the affiliate address and crowdsale is terminated\r\n   */\r\n  function terminateCrowdSale() onlyOwner public {\r\n    require(crowdSaleEnded);\r\n    uint256 remainingTokens = tkn.balanceOf(address(this));\r\n    require(tkn.transfer(affiliatesAddress, remainingTokens));\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter for USD price of tokens\r\n   */\r\n  function getUSDPrice() private view returns (uint256) {\r\n    return usdCentValue;\r\n  }\r\n\r\n  /**\r\n   * @dev Change USD price of tokens\r\n   * @param _ethPrice New Ether price\r\n   */\r\n  function updatePrice(uint256 _ethPrice) private {\r\n    uint256 centBase = 1 * 10 ** 16;\r\n    require(_ethPrice > 0);\r\n    ethPrice = _ethPrice;\r\n    usdCentValue = centBase.div(_ethPrice);\r\n  }\r\n\r\n  /**\r\n   * @dev Set USD to ETH value\r\n   * @param _ethPrice New Ether price\r\n   */\r\n  function setUsdEthValue(uint256 _ethPrice) onlyOwner external { // set the ETH value in USD\r\n    updatePrice(_ethPrice);\r\n  }\r\n\r\n  /**\r\n   * @dev Set the crowdsale contract address\r\n   * @param _investorsStorage InvestorsStorage contract address\r\n   */\r\n  function setStorageAddress(address _investorsStorage) onlyOwner public { // set the storage contract address\r\n    investorsStorage = InvestorsStorage(_investorsStorage);\r\n  }\r\n\r\n  /**\r\n   * @dev Pause the crowdsale\r\n   * @param _paused Paused state - true/false\r\n   */\r\n  function pauseCrowdSale(bool _paused) onlyOwner public { // pause the crowdsale\r\n    crowdSalePaused = _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Get funds\r\n   */\r\n  function getFunds() onlyOwner public { // claim the funds\r\n    owner.transfer(address(this).balance);\r\n  }\r\n\r\n  event NewInvestment(address _investor, uint256 tokens);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tkn\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethPrice\",\"type\":\"uint256\"}],\"name\":\"setUsdEthValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminateCrowdSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorsList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"pauseCrowdSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorsStorage\",\"type\":\"address\"}],\"name\":\"setStorageAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levelTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levelEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSalePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affiliatesAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"NewInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CrowdSale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://82926b753297477249248ebfd518128ade838fcb14d27da6a40751e2b8c51566"}]}