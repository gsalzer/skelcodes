{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract CopaDelCrypto\r\n{\r\n  address public owner;\r\n  constructor() public\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner\r\n  {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  struct Forecast\r\n  {\r\n    bytes32 part1;\r\n    bytes32 part2;\r\n    bytes32 part3;\r\n    bytes12 part4;\r\n    bool hasPaidOrWon;\r\n  }\r\n\r\n  uint256 public prizeValue;\r\n  uint256 public resultsPublishedTime;\r\n\r\n  bytes32 public worldCupResultPart1;\r\n  bytes32 public worldCupResultPart2;\r\n  bytes32 public worldCupResultPart3;\r\n  bytes12 public worldCupResultPart4;\r\n\r\n  bool public forecastingClosed;\r\n  bool public resultsPublished;\r\n\r\n  uint32 public resultsValidationStep;\r\n  uint32 public verifiedWinnersCount;\r\n  uint32 public verifiedWinnersLastCount;\r\n\r\n  uint16 public publishedWinningScoreThreshold;\r\n  uint16 public expectedWinnersCount;\r\n\r\n  address[] public players;\r\n\r\n  mapping(address => Forecast) public forecasts;\r\n\r\n  function PlaceNewForecast(bytes32 f1, bytes32 f2, bytes32 f3, bytes12 f4)\r\n  public payable\r\n  {\r\n    require(!forecastingClosed && msg.value == 50000000000000000 && !forecasts[msg.sender].hasPaidOrWon);\r\n\r\n    forecasts[msg.sender].part1 = f1;\r\n    forecasts[msg.sender].part2 = f2;\r\n    forecasts[msg.sender].part3 = f3;\r\n    forecasts[msg.sender].part4 = f4;\r\n    forecasts[msg.sender].hasPaidOrWon = true;\r\n\r\n    players.push(msg.sender);\r\n  }\r\n\r\n  function UpdateForecast(bytes32 f1, bytes32 f2, bytes32 f3, bytes12 f4)\r\n  public\r\n  {\r\n    require(!forecastingClosed && forecasts[msg.sender].hasPaidOrWon);\r\n\r\n    forecasts[msg.sender].part1 = f1;\r\n    forecasts[msg.sender].part2 = f2;\r\n    forecasts[msg.sender].part3 = f3;\r\n    forecasts[msg.sender].part4 = f4;\r\n  }\r\n\r\n  function CloseForecasting(uint16 exWinCount)\r\n  public onlyOwner\r\n  {\r\n    require(!forecastingClosed);\r\n    require((exWinCount == 0 && players.length > 10000)\r\n             || (exWinCount > 0 && (uint32(exWinCount) * uint32(exWinCount) >= players.length\r\n                 && uint32(exWinCount - 1) * uint32(exWinCount - 1) < players.length)));\r\n    expectedWinnersCount = (players.length) > 10000 ? uint16(players.length / 100) : exWinCount;\r\n\r\n    forecastingClosed = true;\r\n  }\r\n\r\n  function PublishWorldCupResults(bytes32 res1, bytes32 res2, bytes32 res3, bytes12 res4)\r\n  public onlyOwner\r\n  {\r\n    require(forecastingClosed && !resultsPublished);\r\n\r\n    worldCupResultPart1 = res1;\r\n    worldCupResultPart2 = res2;\r\n    worldCupResultPart3 = res3;\r\n    worldCupResultPart4 = res4;\r\n\r\n    resultsValidationStep = 0;\r\n    verifiedWinnersCount = 0;\r\n    verifiedWinnersLastCount = 0;\r\n    resultsPublishedTime = block.timestamp;\r\n  }\r\n\r\n  function PublishWinnersScoreThres(uint16 scoreThres)\r\n  public onlyOwner\r\n  {\r\n    require(forecastingClosed && !resultsPublished);\r\n\r\n    publishedWinningScoreThreshold = scoreThres;\r\n  }\r\n\r\n  function VerifyPublishedResults(uint16 stepSize)\r\n  public onlyOwner\r\n  {\r\n    require(forecastingClosed && !resultsPublished);\r\n    require(stepSize > 0 && resultsValidationStep + stepSize <= players.length);\r\n\r\n    uint32 wins;\r\n    uint32 lasts;\r\n\r\n    for (uint32 i = resultsValidationStep; i < resultsValidationStep + stepSize; i++) {\r\n\r\n      Forecast memory fc = forecasts[players[i]];\r\n\r\n      uint16 score = scoreGroups(fc.part1, fc.part2, worldCupResultPart1, worldCupResultPart2)\r\n                     + scoreKnockouts(fc.part2, fc.part3, fc.part4);\r\n\r\n      if (score >= publishedWinningScoreThreshold) {\r\n        wins++;\r\n        if (score == publishedWinningScoreThreshold) {\r\n          lasts++;\r\n        }\r\n        forecasts[players[i]].hasPaidOrWon = true;\r\n      } else {\r\n        forecasts[players[i]].hasPaidOrWon = false;\r\n      }\r\n    }\r\n\r\n    resultsValidationStep += stepSize;\r\n    verifiedWinnersCount += wins;\r\n    verifiedWinnersLastCount += lasts;\r\n\r\n    if (resultsValidationStep == players.length) {\r\n      verifiedWinnersCount = validateWinnersCount(verifiedWinnersCount, verifiedWinnersLastCount, expectedWinnersCount);\r\n      verifiedWinnersLastCount = 0;\r\n      expectedWinnersCount = 0;\r\n\r\n      if (verifiedWinnersCount > 0) {\r\n        prizeValue = address(this).balance / verifiedWinnersCount;\r\n        resultsPublished = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  function WithdrawPrize()\r\n  public\r\n  returns(bool)\r\n  {\r\n    require(prizeValue > 0);\r\n\r\n    if (forecasts[msg.sender].hasPaidOrWon) {\r\n      forecasts[msg.sender].hasPaidOrWon = false;\r\n      if (!msg.sender.send(prizeValue)) {\r\n        forecasts[msg.sender].hasPaidOrWon = true;\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function CancelGame()\r\n  public onlyOwner\r\n  {\r\n    forecastingClosed = true;\r\n    resultsPublished = true;\r\n    resultsPublishedTime = block.timestamp;\r\n    prizeValue = address(this).balance / players.length;\r\n  }\r\n\r\n  function CancelGameAfterResultsPublished()\r\n  public onlyOwner\r\n  {\r\n    CancelGame();\r\n    for (uint32 i = 0; i < players.length; i++) {\r\n    \tforecasts[players[i]].hasPaidOrWon = true;\r\n    }\r\n  }\r\n\r\n  function WithdrawUnclaimed()\r\n  public onlyOwner\r\n  returns(bool)\r\n  {\r\n    require(resultsPublished && block.timestamp >= (resultsPublishedTime + 10 weeks));\r\n\r\n    uint256 amount = address(this).balance;\r\n    if (amount > 0) {\r\n      if (!msg.sender.send(amount)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function getForecastData(bytes32 pred2, bytes32 pred3, bytes12 pred4, uint8 index)\r\n  public pure\r\n  returns(uint8)\r\n  {\r\n    assert(index >= 32 && index < 108);\r\n    if (index < 64) {\r\n      return uint8(pred2[index - 32]);\r\n    } else if (index < 96) {\r\n      return uint8(pred3[index - 64]);\r\n    } else {\r\n      return uint8(pred4[index - 96]);\r\n    }\r\n  }\r\n\r\n  function getResultData(uint8 index)\r\n  public view\r\n  returns(uint8)\r\n  {\r\n    assert(index >= 32 && index < 108);\r\n    if (index < 64) {\r\n      return uint8(worldCupResultPart2[index - 32]);\r\n    } else if (index < 96) {\r\n      return uint8(worldCupResultPart3[index - 64]);\r\n    } else {\r\n      return uint8(worldCupResultPart4[index - 96]);\r\n    }\r\n  }\r\n\r\n  function computeGroupPhasePoints(uint8 pred, uint8 result)\r\n  public pure\r\n  returns(uint8)\r\n  {\r\n    uint8 gamePoint = 0;\r\n\r\n    int8 predLeft = int8(pred % 16);\r\n    int8 predRight = int8(pred >> 4);\r\n    int8 resultLeft = int8(result % 16);\r\n    int8 resultRight = int8(result >> 4);\r\n\r\n    int8 outcome = resultLeft - resultRight;\r\n    int8 predOutcome = predLeft - predRight;\r\n\r\n    if ((outcome > 0 && predOutcome > 0)\r\n        || (outcome < 0 && predOutcome < 0)\r\n        || (outcome == 0 && predOutcome == 0)) {\r\n      gamePoint += 4;\r\n    }\r\n\r\n    if (predLeft == resultLeft) {\r\n      gamePoint += 2;\r\n    }\r\n\r\n    if (predRight == resultRight) {\r\n      gamePoint += 2;\r\n    }\r\n    return gamePoint;\r\n  }\r\n\r\n  function computeKnockoutPoints(uint8 pred, uint8 result, uint8 shootPred, uint8 shootResult,\r\n                                 uint8 roundFactorLeft, uint8 roundFactorRight, bool isInverted)\r\n  public pure\r\n  returns (uint16)\r\n  {\r\n    uint16 gamePoint = 0;\r\n    int8 predLeft = int8(pred % 16);\r\n    int8 predRight = int8(pred >> 4);\r\n    int8 resultLeft = int8(result % 16);\r\n    int8 resultRight = int8(result >> 4);\r\n\r\n    int8 predOutcome = predLeft - predRight;\r\n    int8 outcome = resultLeft - resultRight;\r\n\r\n    if (predOutcome == 0) {\r\n       predOutcome = int8(shootPred % 16) - int8(shootPred >> 4);\r\n    }\r\n    if (outcome == 0) { \r\n       outcome = int8(shootResult % 16) - int8(shootResult >> 4);\r\n    }\r\n\r\n    if (isInverted) {\r\n      resultLeft = resultLeft + resultRight;\r\n      resultRight = resultLeft - resultRight;\r\n      resultLeft = resultLeft - resultRight;\r\n      outcome = -outcome;\r\n    }\r\n\r\n    if ((outcome > 0 && predOutcome > 0) || (outcome < 0 && predOutcome < 0)) {\r\n      gamePoint += 4 * (roundFactorLeft + roundFactorRight);\r\n    }\r\n\r\n    gamePoint += 4 * ((predLeft == resultLeft ? roundFactorLeft : 0)\r\n                      + (predRight == resultRight ? roundFactorRight: 0));\r\n\r\n    return gamePoint;\r\n  }\r\n\r\n  function scoreGroups(bytes32 pred1, bytes32 pred2, bytes32 res1, bytes32 res2)\r\n  public pure\r\n  returns(uint16)\r\n  {\r\n    uint16 points = 0;\r\n    for (uint8 f = 0; f < 48; f++) {\r\n      if (f < 32) {\r\n        points += computeGroupPhasePoints(uint8(pred1[f]), uint8(res1[f]));\r\n      } else {\r\n        points += computeGroupPhasePoints(uint8(pred2[f - 32]), uint8(res2[f - 32]));\r\n      }\r\n    }\r\n    return points;\r\n  }\r\n\r\n  function scoreKnockouts(bytes32 pred2, bytes32 pred3, bytes12 pred4)\r\n  public view\r\n  returns(uint16)\r\n  {\r\n    uint8 f = 48;\r\n    uint16 points = 0;\r\n\r\n    int8[15] memory twinShift = [int8(16), 16, 16, 16, -16, -16, -16, -16, 8, 8, -8, -8, 4, -4, 0];\r\n    uint8[15] memory roundFactor = [uint8(2), 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 8, 8, 16];\r\n\r\n    for (uint8 i = 0; i < 15; i++) {\r\n\r\n      bool teamLeftOK = getForecastData(pred2, pred3, pred4, f) == getResultData(f);\r\n      bool teamRightOK = getForecastData(pred2, pred3, pred4, f + 1) == getResultData(f + 1);\r\n\r\n      if (teamLeftOK || teamRightOK) {\r\n        points += computeKnockoutPoints(getForecastData(pred2, pred3, pred4, f + 2), getResultData(f + 2),\r\n                                        getForecastData(pred2, pred3, pred4, f + 3), getResultData(f + 3),\r\n                                        teamLeftOK ? roundFactor[i] : 0, teamRightOK ? roundFactor[i] : 0,\r\n                                        false);\r\n        if (i < 8) {\r\n          points += (teamLeftOK ? 4 : 0) + (teamRightOK ? 4 : 0);\r\n        }\r\n      }\r\n\r\n      bool isInverted = (i < 8) || i == 14;\r\n      teamLeftOK = getForecastData(pred2, pred3, pred4, f) ==\r\n                   (getResultData(uint8(int8(f + (isInverted ? 1 : 0)) + twinShift[i])));\r\n      teamRightOK = getForecastData(pred2, pred3, pred4, f + 1) ==\r\n                   (getResultData(uint8(int8(f + (isInverted ? 0 : 1)) + twinShift[i])));\r\n\r\n      if (teamLeftOK || teamRightOK) {\r\n        points += computeKnockoutPoints(getForecastData(pred2, pred3, pred4, f + 2),\r\n                                        getResultData(uint8(int8(f + 2) + twinShift[i])),\r\n                                        getForecastData(pred2, pred3, pred4, f + 3),\r\n                                        getResultData(uint8(int8(f + 3) + twinShift[i])),\r\n                                        teamLeftOK ? roundFactor[i] : 0, teamRightOK ? roundFactor[i] : 0,\r\n                                        isInverted);\r\n        if (i < 8) {\r\n          points += (teamLeftOK ? 2 : 0) + (teamRightOK ? 2 : 0);\r\n        }\r\n      }\r\n      f = f + 4;\r\n    }\r\n    return points;\r\n  }\r\n\r\n  function validateWinnersCount(uint32 winners, uint32 last, uint32 expected)\r\n  public pure\r\n  returns(uint32)\r\n  {\r\n    if (winners < expected) {\r\n      return 0;\r\n    } else if ((winners == expected && last >= 1)\r\n                || (last > 1 && (winners - last) < expected)) {\r\n      return winners;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"pred2\",\"type\":\"bytes32\"},{\"name\":\"pred3\",\"type\":\"bytes32\"},{\"name\":\"pred4\",\"type\":\"bytes12\"}],\"name\":\"scoreKnockouts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expectedWinnersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resultsValidationStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"winners\",\"type\":\"uint32\"},{\"name\":\"last\",\"type\":\"uint32\"},{\"name\":\"expected\",\"type\":\"uint32\"}],\"name\":\"validateWinnersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pred\",\"type\":\"uint8\"},{\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"computeGroupPhasePoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"forecasts\",\"outputs\":[{\"name\":\"part1\",\"type\":\"bytes32\"},{\"name\":\"part2\",\"type\":\"bytes32\"},{\"name\":\"part3\",\"type\":\"bytes32\"},{\"name\":\"part4\",\"type\":\"bytes12\"},{\"name\":\"hasPaidOrWon\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"f1\",\"type\":\"bytes32\"},{\"name\":\"f2\",\"type\":\"bytes32\"},{\"name\":\"f3\",\"type\":\"bytes32\"},{\"name\":\"f4\",\"type\":\"bytes12\"}],\"name\":\"UpdateForecast\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stepSize\",\"type\":\"uint16\"}],\"name\":\"VerifyPublishedResults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resultsPublished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exWinCount\",\"type\":\"uint16\"}],\"name\":\"CloseForecasting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"worldCupResultPart4\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes12\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"worldCupResultPart3\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pred1\",\"type\":\"bytes32\"},{\"name\":\"pred2\",\"type\":\"bytes32\"},{\"name\":\"res1\",\"type\":\"bytes32\"},{\"name\":\"res2\",\"type\":\"bytes32\"}],\"name\":\"scoreGroups\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pred\",\"type\":\"uint8\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"shootPred\",\"type\":\"uint8\"},{\"name\":\"shootResult\",\"type\":\"uint8\"},{\"name\":\"roundFactorLeft\",\"type\":\"uint8\"},{\"name\":\"roundFactorRight\",\"type\":\"uint8\"},{\"name\":\"isInverted\",\"type\":\"bool\"}],\"name\":\"computeKnockoutPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"res1\",\"type\":\"bytes32\"},{\"name\":\"res2\",\"type\":\"bytes32\"},{\"name\":\"res3\",\"type\":\"bytes32\"},{\"name\":\"res4\",\"type\":\"bytes12\"}],\"name\":\"PublishWorldCupResults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifiedWinnersLastCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"CancelGameAfterResultsPublished\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifiedWinnersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resultsPublishedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawUnclaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publishedWinningScoreThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forecastingClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pred2\",\"type\":\"bytes32\"},{\"name\":\"pred3\",\"type\":\"bytes32\"},{\"name\":\"pred4\",\"type\":\"bytes12\"},{\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getForecastData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"worldCupResultPart1\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"worldCupResultPart2\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"scoreThres\",\"type\":\"uint16\"}],\"name\":\"PublishWinnersScoreThres\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"CancelGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"f1\",\"type\":\"bytes32\"},{\"name\":\"f2\",\"type\":\"bytes32\"},{\"name\":\"f3\",\"type\":\"bytes32\"},{\"name\":\"f4\",\"type\":\"bytes12\"}],\"name\":\"PlaceNewForecast\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getResultData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"CopaDelCrypto","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4827e58c66ef6f002c7fad84473f238246be6d5dc6b5a2565ef62f2282518122"}]}