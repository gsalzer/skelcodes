{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/*\r\n                                                                                                             \r\n\r\n███████╗██╗   ██╗██████╗ ███████╗██████╗                                    \r\n██╔════╝██║   ██║██╔══██╗██╔════╝██╔══██╗                                   \r\n███████╗██║   ██║██████╔╝█████╗  ██████╔╝                                   \r\n╚════██║██║   ██║██╔═══╝ ██╔══╝  ██╔══██╗                                   \r\n███████║╚██████╔╝██║     ███████╗██║  ██║                                   \r\n╚══════╝ ╚═════╝ ╚═╝     ╚══════╝╚═╝  ╚═╝                                   \r\n                                                                            \r\n     ██████╗ ██████╗ ██╗   ██╗███╗   ██╗████████╗██████╗ ██╗███████╗███████╗\r\n    ██╔════╝██╔═══██╗██║   ██║████╗  ██║╚══██╔══╝██╔══██╗██║██╔════╝██╔════╝\r\n    ██║     ██║   ██║██║   ██║██╔██╗ ██║   ██║   ██████╔╝██║█████╗  ███████╗\r\n    ██║     ██║   ██║██║   ██║██║╚██╗██║   ██║   ██╔══██╗██║██╔══╝  ╚════██║\r\n    ╚██████╗╚██████╔╝╚██████╔╝██║ ╚████║   ██║   ██║  ██║██║███████╗███████║\r\n     ╚═════╝ ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝╚═╝╚══════╝╚══════╝\r\n                                                                           \r\n\r\n© 2018 SuperCountries\r\n\r\n所有权 - 4CE434B6058EC7C24889EC2512734B5DBA26E39891C09DF50C3CE3191CE9C51E\r\n\r\nXuxuxu - LB - Xufo\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \r\n*/\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SuperCountriesEth {\r\n  using SafeMath for uint256;\r\n\r\n \r\n////////////////////////////\r\n/// \tCONSTRUCTOR\t\t ///\t\r\n////////////////////////////\r\n   \r\n\tconstructor () public {\r\n    owner = msg.sender;\r\n\t}\r\n\t\r\n\taddress public owner;  \r\n\r\n  \r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner == msg.sender);\r\n\t\t_;\r\n\t}\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n \r\n \r\n\r\n\r\n////////////////////////\r\n/// \tEVENTS\t\t ///\t\r\n////////////////////////\r\n  \r\n  event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price);\r\n  event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  \r\n  event SetReferrerEvent(address indexed referral, address indexed referrer);\r\n  event PayReferrerEvent(address indexed oldOwner, address indexed referrer1, address indexed referrer2, uint256 referralPart);\r\n  \r\n  event BonusConstant(uint256 bonusToDispatch_, uint256 bonusDispatched_, uint256 notYetDispatched_, uint256 indexed _itemSoldId_, uint256 kBonus, uint256 indexed countryScore);\r\n  event BonusDispatch(uint256 bonusToGet_, uint256 indexed playerScoreForThisCountry_, address indexed player_, uint256 pendingBalanceTotal_, uint256 indexed _itemSoldId);\r\n  event DivsDispatch(uint256 dividendsCut_, uint256 dividendsScore, uint256 indexed _itemId, uint256 price, uint256 worldScore_);\r\n  event newRichest(address indexed richest_, uint256 richestScore_, uint256 indexed blocktimestamp_, uint256 indexed blocknumber_);\r\n  \r\n  event Withdrawal(address indexed playerAddress, uint256 indexed ethereumWithdrawn, uint256 indexed potVersion_);\r\n  event ConfirmWithdraw(address indexed playerAddress, uint256 refbonus_, uint256 divs_, uint256 totalPending_, uint256 playerSc_, uint256 _handicap_);\r\n  event ConfirmPotWithdraw(uint256 contractBalance, address indexed richest_, uint256 richestBalance_, address indexed lastBuyer_, uint256 lastBalance_, uint256 indexed potVersion);\r\n  event PotWithdrawConstant(uint256 indexed blocktimestamp_, uint256 indexed timestamplimit_, uint256 dividendsScore_, uint256 indexed potVersion, uint256 lastWithdrawPotVersion_);\r\n  event WithdrawOwner(uint256 indexed potVersion, uint256 indexed lastWithdrawPotVersion_, uint256 indexed balance_);\r\n\r\n \r\n \r\n\r\n\r\n///////////////////////////////////////////\r\n/// \tVARIABLES, MAPPINGS, STRUCTS \t///\t\r\n///////////////////////////////////////////\r\n  \r\n  bool private erc721Enabled = false;\r\n\r\n  /// Price increase limits\r\n  uint256 private increaseLimit1 = 0.04 ether;\r\n  uint256 private increaseLimit2 = 0.6 ether;\r\n  uint256 private increaseLimit3 = 2.5 ether;\r\n  uint256 private increaseLimit4 = 7.0 ether;\r\n\r\n  /// All countries\r\n  uint256[] private listedItems;\r\n  mapping (uint256 => address) private ownerOfItem;\r\n  mapping (uint256 => uint256) private priceOfItem;\r\n  mapping (uint256 => uint256) private previousPriceOfItem;\r\n  mapping (uint256 => address) private approvedOfItem;\r\n   \r\n  \r\n  /// Referrals and their referrers\r\n  mapping(address => address) public referrerOf;\r\n  \r\n  /// Dividends and score\r\n  uint256 private worldScore ; /// Worldscore = cumulated price of all owned countries + all spent ethers in this game\r\n  mapping (address => uint256) private playerScore; /// For each player, the sum of each owned country + the sum of all spent ethers since the beginning of the game\r\n  uint256 private dividendsScore ; /// Balance of dividends divided by the worldScore \r\n  mapping(uint256 => mapping(address => uint256)) private pendingBalance; /// Divs from referrals, bonus and dividends calculated after the playerScore change ; if the playerScore didn't change recently, there are some pending divs that can be calculated using dividendsScore and playerScore. The first mapping (uint256) is the jackpot version to use, the value goes up after each pot distribution and the previous pendingBalance are reseted.\r\n  mapping(uint256 => mapping(address => uint256)) private handicap; /// a player cannot claim a % of all dividends but a % of the cumulated dividends after his join date, this is a handicap\r\n  mapping(uint256 => mapping(address => uint256)) private balanceToWithdraw; /// A player cannot withdraw pending divs, he must request a withdraw first (pending divs move to balanceToWithdraw) then withdraw.\t\r\n\r\n  uint256 private potVersion = 1; /// Number of jackpots\r\n  uint256 private lastWithdrawPotVersion = 1; /// Latest withdraw in the game (pot version)\r\n  address private richestBuyer ; /// current player with the highest PlayerScore\r\n  address private lastBuyer ; /// current latest buyer in the game\r\n  uint256 private timestampLimit = 1528108990; /// after this timestamp, the richestBuyer and the lastBuyer will be allowed to withdraw 1/2 of the contract balance (1/4 each)\r\n  \r\n  struct CountryStruct {\r\n\t\taddress[] itemToAddressArray; /// addresses that owned the same country\t \r\n\t\tuint256 priceHistory; /// cumulated price of the country\r\n\t\tuint256 startingPrice; /// starting price of the country\r\n\t\t}\r\n\r\n  mapping (uint256 => CountryStruct) public countryStructs;\r\n  \r\n  mapping (uint256 => mapping(address => uint256)) private itemHistory; /// Store price history (cumulated) for each address for each country\r\n  \r\n  uint256 private HUGE = 1e13;\r\n \r\n \r\n \r\n\r\n\r\n////////////////////////////////\r\n/// \tUSEFUL MODIFIER\t\t ///\t\r\n////////////////////////////////\r\n\r\n\tmodifier onlyRealAddress() {\r\n\t\trequire(msg.sender != address(0));\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\t\r\n\r\n\t\r\n////////////////////////////////\r\n/// \tERC721 PRIVILEGES\t ///\t\r\n////////////////////////////////\r\n\r\n\tmodifier onlyERC721() {\r\n\t\trequire(erc721Enabled);\r\n\t\t_;\r\n\t} \r\n\r\n\r\n  /**\r\n   * @dev Unlocks ERC721 behaviour, allowing for trading on third party platforms.\r\n   */\t \r\n\tfunction enableERC721 () onlyOwner() public {\r\n\t\terc721Enabled = true;\r\n\t} \r\n\r\n  \r\n \r\n\r\n \r\n///////////////////////////////////\r\n///\t\tLISTING NEW COUNTRIES \t///\r\n///////////////////////////////////\r\n\t\r\n\tfunction listMultipleItems (uint256[] _itemIds, uint256 _price, address _owner) onlyOwner() external {\r\n\t\tfor (uint256 i = 0; i < _itemIds.length; i++) {\r\n\t\t\tlistItem(_itemIds[i], _price, _owner);\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfunction listItem (uint256 _itemId, uint256 _price, address _owner) onlyOwner() public {\r\n\t\trequire(_price > 0);\r\n\t\trequire(priceOfItem[_itemId] == 0);\r\n\t\trequire(ownerOfItem[_itemId] == address(0));\r\n\r\n\t\townerOfItem[_itemId] = _owner;\r\n\t\tpriceOfItem[_itemId] = _price;\r\n\t\tpreviousPriceOfItem[_itemId] = 0;\r\n\t\tlistedItems.push(_itemId);\r\n\t\tnewEntity(_itemId, _price);\r\n\t}\r\n\r\n\t\r\n  /**\r\n   * @dev Creates new Struct for a country each time a new country is listed.\r\n   */\t\r\n\tfunction newEntity(uint256 countryId, uint256 startPrice) private returns(bool success) {\r\n\t\tcountryStructs[countryId].startingPrice = startPrice;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t\r\n  /**\r\n   * @dev Update the Struc each time a country is sold.\r\n   * Push the newOwner, update the price history\r\n   */\t\r\n\tfunction updateEntity(uint256 countryId, address newOwner, uint256 priceUpdate) internal {\r\n\t\tcountryStructs[countryId].priceHistory += priceUpdate;\r\n\t\tif (itemHistory[countryId][newOwner] == 0 ){\r\n\t\t\tcountryStructs[countryId].itemToAddressArray.push(newOwner);\r\n\t\t}\r\n\t  }\r\n \r\n\r\n\r\n\r\n \r\n///////////////////////\r\n/// CALCULATE PRICE ///\r\n///////////////////////\r\n\r\n\tfunction calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\r\n\t\tif (_price < increaseLimit1) {\r\n\t\t\treturn _price.mul(200).div(95);\r\n\t\t} else if (_price < increaseLimit2) {\r\n\t\t\treturn _price.mul(160).div(96);\r\n\t\t} else if (_price < increaseLimit3) {\r\n\t\t\treturn _price.mul(148).div(97);\r\n\t\t} else if (_price < increaseLimit4) {\r\n\t\t\treturn _price.mul(136).div(97);\r\n\t\t} else {\r\n\t\t\treturn _price.mul(124).div(98);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction calculateDevCut (uint256 _price) public view returns (uint256 _devCut) {\r\n\t\tif (_price < increaseLimit1) {\r\n\t\t\treturn _price.mul(5).div(100); // 5%\r\n\t\t} else if (_price < increaseLimit2) {\r\n\t\t\treturn _price.mul(4).div(100); // 4%\r\n\t\t} else if (_price < increaseLimit4) {\r\n\t\t\treturn _price.mul(3).div(100); // 3%\r\n\t\t} else {\r\n\t\t\treturn _price.mul(2).div(100); // 2%\r\n\t\t}\r\n\t}\r\n \r\n\r\n\r\n\r\n \r\n//////////////////////////////\r\n/// BALANCES & WITHDRAWALS ///\r\n//////////////////////////////\r\n\r\n\tfunction getBalance(address _playerAddress)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns(uint256 pendingRefBonus_, uint256 pendingFromScore_, uint256 totalPending_, uint256 balanceReadyToWithdraw_, uint256 playerScore_, uint256 handicap_, uint256 dividendsScore_)\r\n\t\t{\r\n\t\t\tuint256 refbonus = pendingBalance[potVersion][_playerAddress];\r\n\t\t\tuint256 playerSc = playerScore[_playerAddress];\r\n\t\t\tuint256 playerHandicap = handicap[potVersion][_playerAddress];\r\n\t\t\tuint256 divs = playerSc.mul(dividendsScore.sub(playerHandicap)).div(HUGE);\r\n\t\t\tuint256 totalPending = refbonus.add(divs);\r\n\t\t\tuint256 ready = balanceToWithdraw[potVersion][_playerAddress];\r\n\t\t\treturn (refbonus, divs, totalPending, ready, playerSc, playerHandicap, dividendsScore);\t\t\t\t\r\n\t\t}\r\n\r\n\r\n\t\t\r\n\tfunction getOldBalance(uint256 _potVersion, address _playerAddress)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns(uint256 oldPendingRefBonus_, uint256 oldHandicap_, uint256 oldReadyToWithdraw_)\r\n\t\t{\r\n\t\t\tuint256 oldRefBonus = pendingBalance[_potVersion][_playerAddress];\r\n\t\t\tuint256 oldPlayerHandicap = handicap[_potVersion][_playerAddress];\r\n\t\t\tuint256 oldReady = balanceToWithdraw[_potVersion][_playerAddress];\r\n\t\t\treturn (oldRefBonus, oldPlayerHandicap, oldReady);\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n  /**\r\n   * @dev First step to withdraw : players must confirm their pending Divs before withdrawing\r\n   * this function sums the pending balances (pendingDividends and the pending divs from playerScore)\r\n   * Then this sum moves to balanceReadyToWithdraw, the player can call the next function and withdraw divs\r\n   */\r\n\tfunction confirmDividends() public onlyRealAddress {\r\n\t\trequire(playerScore[msg.sender] > 0);/// the player exists\r\n\t\trequire (dividendsScore >= handicap[potVersion][msg.sender]);\r\n\t\trequire (dividendsScore >= 0);\r\n\t\t\r\n\t\taddress _playerAddress = msg.sender;\r\n\t\tuint256 playerSc = playerScore[_playerAddress];\r\n\t\tuint256 handicap_ = handicap[potVersion][_playerAddress];\r\n\t\t\r\n\t\tuint256 refbonus = pendingBalance[potVersion][_playerAddress];\r\n\t\tuint256 divs = playerSc.mul(dividendsScore.sub(handicap_)).div(HUGE);\r\n\t\tuint256 totalPending = refbonus.add(divs);\t\r\n\t\t\t\t\t\t\r\n\t\t/// Reset the values\r\n\t\tpendingBalance[potVersion][_playerAddress] = 0; /// Reset the pending balance\r\n\t\thandicap[potVersion][_playerAddress] = dividendsScore;\r\n\t\t\r\n\t\t/// Now the player is ready to withdraw ///\r\n\t\tbalanceToWithdraw[potVersion][_playerAddress] += totalPending;\r\n\t\t\r\n\t\t// fire event\r\n\t\temit ConfirmWithdraw(_playerAddress, refbonus, divs, totalPending, playerSc, handicap_);\r\n\t\t\r\n\t}\r\n\r\n\r\n  /**\r\n   * @dev Second step to withdraw : after confirming divs, players can withdraw divs to their wallet\r\n   */\t\r\n\tfunction withdraw() public onlyRealAddress {\r\n\t\trequire(balanceOf(msg.sender) > 0);\r\n\t\trequire(balanceToWithdraw[potVersion][msg.sender] > 0);\r\n\t\t\t\t\r\n\t\taddress _playerAddress = msg.sender;\r\n\t\t\r\n\t\t\tif (lastWithdrawPotVersion != potVersion){\r\n\t\t\t\t\tlastWithdrawPotVersion = potVersion;\r\n\t\t\t}\r\n\r\n        \r\n        /// Add referrals earnings, bonus and divs\r\n\t\tuint256 divToTransfer = balanceToWithdraw[potVersion][_playerAddress];\r\n\t\tbalanceToWithdraw[potVersion][_playerAddress] = 0;\r\n\t\t\r\n        _playerAddress.transfer(divToTransfer);\r\n\t\t\r\n        /// fire event\r\n        emit Withdrawal(_playerAddress, divToTransfer, potVersion);\r\n    }\r\n\t\r\n\r\n\t\r\n  /**\r\n   * @dev After 7 days without any buy, the richest user and the latest player will share the contract balance !\r\n   */\t\t\r\n\tfunction confirmDividendsFromPot() public {\r\n\t\trequire(richestBuyer != address(0) && lastBuyer != address(0)) ;\r\n\t\trequire(address(this).balance > 100000000);\t/// mini 1e8 wei\r\n\t\trequire(block.timestamp > timestampLimit);\r\n\t\t\r\n\t\tuint256 confirmation_TimeStamp = timestampLimit;\r\n\t\tpotVersion ++;\r\n\t\tuint256 balance = address(this).balance;\r\n\t\tuint256 balanceQuarter = balance.div(4);\r\n\t\tdividendsScore = 0; /// reset dividends\r\n\t\tupdateTimestampLimit(); /// Reset the timer, if no new buys, the richest and the last buyers will be able to withdraw the left quarter in a week or so\r\n\t\tbalanceToWithdraw[potVersion][richestBuyer] = balanceQuarter;\r\n\t\tbalanceToWithdraw[potVersion][lastBuyer] += balanceQuarter; /// if the richest = last, dividends cumulate\r\n\t\t\r\n\t\t\r\n\t\t// fire events\r\n        emit ConfirmPotWithdraw(\t\r\n\t\t\t balance, \r\n\t\t\t richestBuyer, \r\n\t\t\t balanceToWithdraw[potVersion][richestBuyer],\r\n\t\t\t lastBuyer,\r\n\t\t\t balanceToWithdraw[potVersion][lastBuyer],\r\n\t\t\t potVersion\r\n\t\t);\r\n\t\t\r\n\t\temit PotWithdrawConstant(\t\r\n\t\t\t block.timestamp,\r\n\t\t\t confirmation_TimeStamp,\r\n\t\t\t dividendsScore,\r\n\t\t\t potVersion,\r\n\t\t\t lastWithdrawPotVersion\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\r\n\t\r\n  /**\r\n   * @dev If no new buys occur (dividendsScore = 0) and the richest and latest players don't withdraw their dividends after 3 jackpots, the game can be stuck forever\r\n   * Prevent from jackpot vicious circle : same dividends are shared between latest and richest users again and again\r\n   * If the richest and/or the latest player withdraw(s) at least once between 3 jackpots, it means the game is alive\r\n   * Or if contract balance drops down to 1e8 wei (that means many successful jackpots and that a current withdrawal could cost too much gas for players)\r\n   */\t\r\n\tfunction withdrawAll() public onlyOwner {\r\n\t\trequire((potVersion > lastWithdrawPotVersion.add(3) && dividendsScore == 0) || (address(this).balance < 100000001) );\r\n\t\trequire (address(this).balance >0);\r\n\t\t\r\n\t\tpotVersion ++;\r\n\t\tupdateTimestampLimit();\r\n\t\tuint256 balance = address(this).balance;\r\n\t\t\r\n\t\towner.transfer(balance);\r\n\t\t\r\n        // fire event\r\n        emit WithdrawOwner(potVersion, lastWithdrawPotVersion, balance);\r\n    } \t\r\n\r\n\t\r\n\t\r\n\t\r\n\t\r\n///////////////////////////////////////\r\n/// REFERRERS - Setting and payment ///   \r\n///////////////////////////////////////\t\r\n\r\n  /**\r\n   * @dev Get the referrer of a player.\r\n   * @param player The address of the player to get the referrer of.\r\n   */\r\n    function getReferrerOf(address player) public view returns (address) {\r\n        return referrerOf[player];\r\n    }\r\n\r\n\t\r\n  /**\r\n   * @dev Set a referrer.\r\n   * @param newReferral The address to set the referrer for.\r\n   * @param referrer The address of the referrer to set.\r\n   * The referrer must own at least one country to keep his reflink active\r\n   * Referrals got with an active link are forever, even if all the referrer's countries are sold\r\n   */\r\n    function setReferrer(address newReferral, address referrer) internal {\r\n\t\tif (getReferrerOf(newReferral) == address(0x0) && newReferral != referrer && balanceOf(referrer) > 0 && playerScore[newReferral] == 0) {\r\n\t\t\t\r\n\t\t\t/// Set the referrer, if no referrer has been set yet, and the player\r\n\t\t\t/// and referrer are not the same address.\r\n\t\t\t\treferrerOf[newReferral] = referrer;\r\n        \r\n\t\t\t/// Emit event.\r\n\t\t\t\temit SetReferrerEvent(newReferral, referrer);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n\t\r\n\r\n  /**\r\n   * @dev Dispatch the referrer bonus when a country is sold\r\n   * @param referralDivToPay which dividends percentage will be dispatched to refererrs : 0 if no referrer, 2.5% if 1 referrer, 5% if 2\r\n   */\r\n\tfunction payReferrer (address _oldOwner, uint256 _netProfit) internal returns (uint256 referralDivToPay) {\r\n\t\taddress referrer_1 = referrerOf[_oldOwner];\r\n\t\t\r\n\t\tif (referrer_1 != 0x0) {\r\n\t\t\treferralDivToPay = _netProfit.mul(25).div(1000);\r\n\t\t\tpendingBalance[potVersion][referrer_1] += referralDivToPay;  /// 2.5% for the first referrer\r\n\t\t\taddress referrer_2 = referrerOf[referrer_1];\r\n\t\t\t\t\r\n\t\t\t\tif (referrer_2 != 0x0) {\r\n\t\t\t\t\t\tpendingBalance[potVersion][referrer_2] += referralDivToPay;  /// 2.5% for the 2nd referrer\r\n\t\t\t\t\t\treferralDivToPay += referralDivToPay;\r\n\t\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\temit PayReferrerEvent(_oldOwner, referrer_1, referrer_2, referralDivToPay);\r\n\t\t\r\n\t\treturn referralDivToPay;\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\r\n\t\r\n///////////////////////////////////\r\n/// INTERNAL FUNCTIONS WHEN BUY ///   \r\n///////////////////////////////////\t\r\n\r\n  /**\r\n   * @dev Dispatch dividends to former owners of a country\r\n   */\r\n\tfunction bonusPreviousOwner(uint256 _itemSoldId, uint256 _paidPrice, uint256 _bonusToDispatch) private {\r\n\t\trequire(_bonusToDispatch < (_paidPrice.mul(5).div(100)));\r\n\t\trequire(countryStructs[_itemSoldId].priceHistory > 0);\r\n\r\n\t\tCountryStruct storage c = countryStructs[_itemSoldId];\r\n\t\tuint256 countryScore = c.priceHistory;\r\n\t\tuint256 kBonus = _bonusToDispatch.mul(HUGE).div(countryScore);\r\n\t\tuint256 bonusDispatched = 0;\r\n\t\t  \r\n\t\tfor (uint256 i = 0; i < c.itemToAddressArray.length && bonusDispatched < _bonusToDispatch ; i++) {\r\n\t\t\taddress listedBonusPlayer = c.itemToAddressArray[i];\r\n\t\t\tuint256 playerBonusScore = itemHistory[_itemSoldId][listedBonusPlayer];\r\n\t\t\tuint256 bonusToGet = playerBonusScore.mul(kBonus).div(HUGE);\r\n\t\t\t\t\r\n\t\t\t\tif (bonusDispatched.add(bonusToGet) <= _bonusToDispatch) {\r\n\t\t\t\t\tpendingBalance[potVersion][listedBonusPlayer] += bonusToGet;\r\n\t\t\t\t\tbonusDispatched += bonusToGet;\r\n\t\t\t\t\t\r\n\t\t\t\t\temitInfo(bonusToGet, playerBonusScore, listedBonusPlayer, pendingBalance[potVersion][listedBonusPlayer], _itemSoldId);\r\n\t\t\t\t}\r\n\t\t}  \r\n\t\t\t\r\n\t\temit BonusConstant(_bonusToDispatch, bonusDispatched, _bonusToDispatch.sub(bonusDispatched), _itemSoldId, kBonus, countryScore);\r\n\t}\r\n\r\n\r\n\t\r\n\tfunction emitInfo(uint256 dividendsToG_, uint256 playerSc_, address player_, uint256 divsBalance_, uint256 itemId_) private {\r\n\t\temit BonusDispatch(dividendsToG_, playerSc_, player_, divsBalance_, itemId_);\r\n  \r\n\t}\r\n\r\n  \r\n\r\n  /**\r\n   * @dev we need to update the oldOwner and newOwner balances each time a country is sold, their handicap and playerscore will also change\r\n   * Worldscore and dividendscore : we don't care, it will be updated later.\r\n   * If accurate, set a new richest player\r\n   */\r\n\tfunction updateScoreAndBalance(uint256 _paidPrice, uint256 _itemId, address _oldOwner, address _newOwner) internal {\t\r\n\t\tuint256 _previousPaidPrice = previousPriceOfItem[_itemId];\r\n\t\tassert (_paidPrice > _previousPaidPrice);\r\n\r\n\t\t\r\n\t\t/// OLD OWNER ///\r\n\t\t\tuint256 scoreSubHandicap = dividendsScore.sub(handicap[potVersion][_oldOwner]);\r\n\t\t\tuint256 playerScore_ = playerScore[_oldOwner];\r\n\t\t\r\n\t\t\t/// If the old owner is the owner of this contract, we skip this part, the owner of the contract won't get dividends\r\n\t\t\t\tif (_oldOwner != owner && scoreSubHandicap >= 0 && playerScore_ > _previousPaidPrice) {\r\n\t\t\t\t\tpendingBalance[potVersion][_oldOwner] += playerScore_.mul(scoreSubHandicap).div(HUGE);\r\n\t\t\t\t\tplayerScore[_oldOwner] -= _previousPaidPrice; ///for the oldOwner, the playerScore goes down the previous price\r\n\t\t\t\t\thandicap[potVersion][_oldOwner] = dividendsScore; /// and setting his handicap to dividendsScore after updating his balance\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\r\n\t\t/// NEW OWNER ///\r\n\t\t\tscoreSubHandicap = dividendsScore.sub(handicap[potVersion][_newOwner]); /// Rewrite the var with the newOwner values\r\n\t\t\tplayerScore_ = playerScore[_newOwner]; /// Rewrite the var playerScore with the newOwner PlayerScore\r\n\t\t\t\t\r\n\t\t\t/// If new player, his playerscore = 0, handicap = 0, so the pendingBalance math = 0\r\n\t\t\t\tif (scoreSubHandicap >= 0) {\r\n\t\t\t\t\tpendingBalance[potVersion][_newOwner] += playerScore_.mul(scoreSubHandicap).div(HUGE);\r\n\t\t\t\t\tplayerScore[_newOwner] += _paidPrice.mul(2); ///for the newOwner, the playerScore goes up twice the value of the purchase price\r\n\t\t\t\t\thandicap[potVersion][_newOwner] = dividendsScore; /// and setting his handicap to dividendsScore after updating his balance\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\r\n\t\t/// Change the richest user if this is the case...\r\n\t\t\t\tif (playerScore[_newOwner] > playerScore[richestBuyer]) {\r\n\t\t\t\t\trichestBuyer = _newOwner;\r\n\t\t\t\t\t\r\n\t\t\t\t\temit newRichest(_newOwner, playerScore[_newOwner], block.timestamp, block.number);\r\n\t\t\t\t}\t\t\r\n\r\n\t\t\t\t\r\n\t\t/// Change the last Buyer in any case\r\n\t\t\tlastBuyer = _newOwner;\r\n\t\t\r\n\t}\r\n\t\t\r\n\r\n\t\t\r\n\r\n  /**\r\n   * @dev Update the worldScore\r\n   * After each buy, the worldscore increases : 2x current purchase price - 1x previousPrice\r\n   */\r\n\tfunction updateWorldScore(uint256 _countryId, uint256 _price) internal\t{\r\n\t\tworldScore += _price.mul(2).sub(previousPriceOfItem[_countryId]);\r\n\t}\r\n\t\t\r\n\r\n\t\t\r\n  /**\r\n   * @dev Update timestampLimit : the date on which the richest player and the last buyer will be able to share the contract balance (1/4 each)\r\n   */ \r\n\tfunction updateTimestampLimit() internal {\r\n\t\ttimestampLimit = block.timestamp.add(604800).add(potVersion.mul(28800)); /// add 7 days + (pot version * X 8hrs)\r\n\t}\r\n\r\n\r\n\t\r\n  /**\r\n   * @dev Refund the buyer if excess\r\n   */ \r\n\tfunction excessRefund(address _newOwner, uint256 _price) internal {\t\t\r\n\t\tuint256 excess = msg.value.sub(_price);\r\n\t\t\tif (excess > 0) {\r\n\t\t\t\t_newOwner.transfer(excess);\r\n\t\t\t}\r\n\t}\t\r\n\t\r\n\r\n\t\r\n\r\n\r\n///////////////////////////   \r\n/// \tBUY A COUNTRY \t///\r\n///////////////////////////\r\n/*\r\n     Buy a country directly from the contract for the calculated price\r\n     which ensures that the owner gets a profit.  All countries that\r\n     have been listed can be bought by this method. User funds are sent\r\n     directly to the previous owner and are never stored in the contract.\r\n*/\r\n\t\r\n\tfunction buy (uint256 _itemId, address referrerAddress) payable public onlyRealAddress {\r\n\t\trequire(priceOf(_itemId) > 0);\r\n\t\trequire(ownerOf(_itemId) != address(0));\r\n\t\trequire(msg.value >= priceOf(_itemId));\r\n\t\trequire(ownerOf(_itemId) != msg.sender);\r\n\t\trequire(!isContract(msg.sender));\r\n\t\trequire(msg.sender != owner);\r\n\t\trequire(block.timestamp < timestampLimit || block.timestamp > timestampLimit.add(3600));\r\n\t\t\r\n\t\t\r\n\t\taddress oldOwner = ownerOf(_itemId);\r\n\t\taddress newOwner = msg.sender;\r\n\t\tuint256 price = priceOf(_itemId);\r\n\r\n\t\t\r\n\t\t\r\n\t\r\n\t////////////////////////\r\n\t/// Set the referrer ///\r\n\t////////////////////////\r\n\t\t\r\n\t\tsetReferrer(newOwner, referrerAddress);\r\n\t\t\r\n\t\r\n\r\n\t\r\n\t///////////////////////////////////\r\n\t/// Update scores and timestamp ///\r\n\t///////////////////////////////////\r\n\t\t\r\n\t\t/// Dividends are dispatched among players accordingly to their \"playerScore\".\r\n\t\t/// The playerScore equals the sum of all their countries (owned now, paid price) + sum of all their previously owned countries \r\n\t\t/// After each sell / buy, players that owned at least one country can claim dividends\r\n\t\t/// DIVS of a player = playerScore * DIVS to dispatch / worldScore\r\n\t\t/// If a player is a seller or a buyer, his playerScore will change, we need to adjust his parameters\r\n\t\t/// If a player is not a buyer / seller, his playerScore doesn't change, no need to adjust\r\n\t\t\tupdateScoreAndBalance(price, _itemId, oldOwner, newOwner);\r\n\t\t\t\r\n\t\t/// worldScore change after each flip, we need to adjust\r\n\t\t/// To calculate the worldScore after a flip: add buy price x 2, subtract previous price\r\n\t\t\tupdateWorldScore(_itemId, price);\r\n\t\t\r\n\t\t/// If 7 days with no buys, the richest player and the last buyer win the jackpot (1/2 of contract balance ; 1/4 each)\r\n\t\t/// Waiting time increases after each pot distribution\r\n\t\t\tupdateTimestampLimit();\r\n\t\r\n\r\n\r\n\t\r\n\t///////////////////////\r\n\t/// Who earns what? ///\r\n\t///////////////////////\t\r\n\t\r\n\t\t/// When a country flips, who earns how much?\r\n\t\t/// Devs : 2% to 5% of country price\r\n\t\t/// Seller's reward : current paidPrice - previousPrice - devsCut = net profit. The seller gets the previous Price + ca.65% of net Profit\r\n\t\t/// The referrers of the seller : % of netProfit from their referrals R+1 & R+2. If no referrers, all the referrers' cut goes to dividends to all players.\r\n\t\t/// All players, with or without a country now : dividends (% of netProfit)\r\n\t\t/// All previous owners of the flipped country : a special part of dividends called Bonus. If no previous buyer, all the bonus is also added up to dividends to all players.\r\n\t\t\t\r\n\t\t/// Calculate the devs cut\r\n\t\t\tuint256 devCut_ = calculateDevCut(price);\r\n\t\t\t\r\n\t\t/// Calculate the netProfit\r\n\t\t\tuint256 netProfit = price.sub(devCut_).sub(previousPriceOfItem[_itemId]);\r\n\t\t\r\n\t\t/// Calculate dividends cut from netProfit and what referrers left\r\n\t\t\tuint256 dividendsCut_ = netProfit.mul(30).div(100);\r\n\t\t\t\r\n\t\t/// Calculate the seller's reward\r\n\t\t/// Price sub the cuts : dev cut and 35% including referrer cut (5% max), 30% (25% if referrers) dividends (including 80% divs / 20% bonus max) and 5% (jackpot)\r\n\t\t\tuint256 oldOwnerReward = price.sub(devCut_).sub(netProfit.mul(35).div(100));\r\n\r\n\t\t/// Calculate the referrers cut and store the referrer's cut in the referrer's pending balance ///\r\n\t\t/// Update dividend's cut : 30% max ; 27,5% if 1 referrer ; 25% if 2 referrers\r\n\t\t\tuint256 refCut = payReferrer(oldOwner, netProfit);\r\n\t\t\tdividendsCut_ -= refCut;\r\n\t\t\r\n\t\r\n\r\n\t\r\n\t////////////////////////////////////////////////////////////\r\n\t///          Dispatch dividends to all players           ///\r\n\t/// Dispatch bonuses to previous owners of this country  ///\r\n\t////////////////////////////////////////////////////////////\r\n\t\t\r\n\t\t/// Dividends = 80% to all country owners (previous and current owners, no matter the country) + 20% bonus to previous owners of this country\r\n\t\t/// If no previous owners, 100% to all countries owners\r\n\t\r\n\t\t/// Are there previous owners for the current flipped country?\r\n\t\t\tif (price > countryStructs[_itemId].startingPrice && dividendsCut_ > 1000000 && worldScore > 0) {\r\n\t\t\t\t\r\n\t\t\t\t/// Yes, there are previous owners, they will get 20% of dividends of this country\r\n\t\t\t\t\tbonusPreviousOwner(_itemId, price, dividendsCut_.mul(20).div(100));\r\n\t\t\t\t\r\n\t\t\t\t/// So dividends for all the country owners are 100% - 20% = 80%\r\n\t\t\t\t\tdividendsCut_ = dividendsCut_.mul(80).div(100); \r\n\t\t\t} \r\n\t\r\n\t\t\t\t/// If else... nothing special to do, there are no previous owners, dividends remain 100%\t\r\n\t\t\r\n\t\t/// Dispatch dividends to all country owners, no matter the country\r\n\t\t/// Note : to avoid floating numbers, we divide a constant called HUGE (1e13) by worldScore, of course we will multiply by HUGE when retrieving\r\n\t\t\tif (worldScore > 0) { /// worldScore must be greater than 0, the opposite is impossible and dividends are not calculated\r\n\t\t\t\t\r\n\t\t\t\tdividendsScore += HUGE.mul(dividendsCut_).div(worldScore);\r\n\t\t\t}\r\n\t\r\n\r\n\t\r\n\t////////////////////////////////////////////////\r\n\t/// Update the price history of the newOwner ///\r\n\t////////////////////////////////////////////////\r\n\t\r\n\t\t/// The newOwner is now known as an OWNER for this country\r\n\t\t/// We'll store his cumulated buy price for this country in a mapping\r\n\t\t/// Bonus : each time a country is flipped, players that previously owned this country get bonuses proportionally to the sum of their buys\t\r\n\t\t\tupdateEntity(_itemId, newOwner, price);\r\n\t\t\titemHistory[_itemId][newOwner] += price;\r\n\r\n\t\r\n\r\n\t\r\n\t////////////////////////\r\n\t/// Update the price ///\r\n\t////////////////////////\r\n\t\r\n\t\t/// The price of purchase becomes the \"previousPrice\", and the \"price\" is the next price \r\n\t\t\tpreviousPriceOfItem[_itemId] = price;\r\n\t\t\tpriceOfItem[_itemId] = nextPriceOf(_itemId);\r\n\t\r\n\r\n\t\r\n\t/////////////////////////////////////////\r\n\t/// Transfer the reward to the seller ///\r\n\t/////////////////////////////////////////\r\n\r\n\t\t/// The seller's reward is transfered automatically to his wallet\r\n\t\t/// The dev cut is transfered automatically out the contract\r\n\t\t/// The other rewards (bonus, dividends, referrer's cut) will be stored in a pending balance\r\n\t\t\toldOwner.transfer(oldOwnerReward);\r\n\t\t\towner.transfer(devCut_);\r\n\t\t\t\r\n\t\t/// Transfer the token from oldOwner to newOwner\r\n\t\t\t_transfer(oldOwner, newOwner, _itemId);  \t\r\n\t\r\n\t\t/// Emit the events\r\n\t\t\temit Bought(_itemId, newOwner, price);\r\n\t\t\temit Sold(_itemId, oldOwner, price);\t\r\n\t\t\r\n\t\r\n\r\n\t\r\n\t///////////////////////////////////////////\r\n\t/// Transfer the excess to the newOwner ///\r\n\t///////////////////////////////////////////\r\n\t\r\n\t\t/// If the newOwner sent a higher price than the asked price, the excess is refunded\r\n\t\t\texcessRefund(newOwner, price);\r\n\t\t\r\n\r\n\t\r\n\t/// Send informations\r\n\t\temit DivsDispatch(dividendsCut_, dividendsScore, _itemId, price, worldScore);\t\t\r\n\t\t\r\n/// END OF THE BUY FUNCTION ///\r\n  \r\n\t}\r\n  \r\n \r\n  \r\n//////////////////////////////\r\n/// Practical informations ///\r\n//////////////////////////////\r\n\r\n\tfunction itemHistoryOfPlayer(uint256 _itemId, address _owner) public view returns (uint256 _valueAddressOne) {\r\n\t\treturn itemHistory[_itemId][_owner];\r\n\t}\r\n  \r\n  \r\n\tfunction implementsERC721() public view returns (bool _implements) {\r\n\t\treturn erc721Enabled;\r\n\t}\r\n\r\n\t\r\n\tfunction name() public pure returns (string _name) {\r\n\t\treturn \"SuperCountries\";\r\n\t}\r\n\r\n\t\r\n\tfunction symbol() public pure returns (string _symbol) {\r\n\t\treturn \"SUP\";\r\n\t}\r\n\r\n\t\r\n\tfunction totalSupply() public view returns (uint256 _totalSupply) {\r\n\t\treturn listedItems.length;\r\n\t}\r\n\r\n\t\r\n\tfunction balanceOf (address _owner) public view returns (uint256 _balance) {\r\n\t\tuint256 counter = 0;\r\n\r\n\t\t\tfor (uint256 i = 0; i < listedItems.length; i++) {\r\n\t\t\t\tif (ownerOf(listedItems[i]) == _owner) {\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\treturn counter;\r\n\t}\r\n\r\n\r\n\tfunction ownerOf (uint256 _itemId) public view returns (address _owner) {\r\n\t\treturn ownerOfItem[_itemId];\r\n\t}\r\n\r\n\t\r\n\tfunction tokensOf (address _owner) public view returns (uint256[] _tokenIds) {\r\n\t\tuint256[] memory items = new uint256[](balanceOf(_owner));\r\n\t\tuint256 itemCounter = 0;\r\n\t\t\t\r\n\t\t\tfor (uint256 i = 0; i < listedItems.length; i++) {\r\n\t\t\t\tif (ownerOf(listedItems[i]) == _owner) {\r\n\t\t\t\t\titems[itemCounter] = listedItems[i];\r\n\t\t\t\t\titemCounter += 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\treturn items;\r\n\t}\r\n\r\n\r\n\tfunction tokenExists (uint256 _itemId) public view returns (bool _exists) {\r\n\t\treturn priceOf(_itemId) > 0;\r\n\t}\r\n\r\n\t\r\n\tfunction approvedFor(uint256 _itemId) public view returns (address _approved) {\r\n\t\treturn approvedOfItem[_itemId];\r\n\t}\r\n\r\n\r\n\tfunction approve(address _to, uint256 _itemId) onlyERC721() public {\r\n\t\trequire(msg.sender != _to);\r\n\t\trequire(tokenExists(_itemId));\r\n\t\trequire(ownerOf(_itemId) == msg.sender);\r\n\r\n\t\tif (_to == 0) {\r\n\t\t\tif (approvedOfItem[_itemId] != 0) {\r\n\t\t\t\tdelete approvedOfItem[_itemId];\r\n\t\t\t\temit Approval(msg.sender, 0, _itemId);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tapprovedOfItem[_itemId] = _to;\r\n\t\t\temit Approval(msg.sender, _to, _itemId);\r\n\t\t}\r\n\t  }\r\n\r\n\t  \r\n  /* Transferring a country to another owner will entitle the new owner the profits from `buy` */\r\n\tfunction transfer(address _to, uint256 _itemId) onlyERC721() public {\r\n\t\trequire(msg.sender == ownerOf(_itemId));\r\n\t\t_transfer(msg.sender, _to, _itemId);\r\n\t}\r\n\r\n\t\r\n\tfunction transferFrom(address _from, address _to, uint256 _itemId) onlyERC721() public {\r\n\t\trequire(approvedFor(_itemId) == msg.sender);\r\n\t\t_transfer(_from, _to, _itemId);\r\n\t}\r\n\r\n\t\r\n\tfunction _transfer(address _from, address _to, uint256 _itemId) internal {\r\n\t\trequire(tokenExists(_itemId));\r\n\t\trequire(ownerOf(_itemId) == _from);\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_to != address(this));\r\n\r\n\t\townerOfItem[_itemId] = _to;\r\n\t\tapprovedOfItem[_itemId] = 0;\r\n\r\n\t\temit Transfer(_from, _to, _itemId);\r\n\t}\r\n\r\n\r\n\t\r\n///////////////////////////\t\r\n/// READ ONLY FUNCTIONS ///\r\n///////////////////////////\r\n\r\n\tfunction gameInfo() public view returns (address richestPlayer_, address lastBuyer_, uint256 thisBalance_, uint256 lastWithdrawPotVersion_, uint256 worldScore_, uint256 potVersion_,  uint256 timestampLimit_) {\r\n\t\t\r\n\t\treturn (richestBuyer, lastBuyer, address(this).balance, lastWithdrawPotVersion, worldScore, potVersion, timestampLimit);\r\n\t}\r\n\t\r\n\t\r\n\tfunction priceOf(uint256 _itemId) public view returns (uint256 _price) {\r\n\t\treturn priceOfItem[_itemId];\r\n\t}\r\n\t\r\n\t\r\n\tfunction nextPriceOf(uint256 _itemId) public view returns (uint256 _nextPrice) {\r\n\t\treturn calculateNextPrice(priceOf(_itemId));\r\n\t}\r\n\r\n\t\r\n\tfunction allOf(uint256 _itemId) external view returns (address _owner, uint256 _price, uint256 previous_, uint256 _nextPrice) {\r\n\t\treturn (ownerOf(_itemId), priceOf(_itemId), previousPriceOfItem[_itemId], nextPriceOf(_itemId));\r\n\t}\r\n\r\n\r\n///  is Contract ///\r\n\tfunction isContract(address addr) internal view returns (bool) {\r\n\t\tuint size;\r\n\t\tassembly { size := extcodesize(addr) } // solium-disable-line\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\r\n\r\n\r\n////////////////////////\r\n/// USEFUL FUNCTIONS ///\r\n////////////////////////\r\n\r\n  /** \r\n   * @dev Fallback function to accept all ether sent directly to the contract\r\n   * Nothing is lost, it will raise the jackpot !\r\n   */\r\n\r\n    function() payable public\r\n    {    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"tokenExists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"_implements\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"approvedFor\",\"outputs\":[{\"name\":\"_approved\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"allOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"previous_\",\"type\":\"uint256\"},{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmDividendsFromPot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"listItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"nextPriceOf\",\"outputs\":[{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"calculateDevCut\",\"outputs\":[{\"name\":\"_devCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableERC721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"},{\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_potVersion\",\"type\":\"uint256\"},{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getOldBalance\",\"outputs\":[{\"name\":\"oldPendingRefBonus_\",\"type\":\"uint256\"},{\"name\":\"oldHandicap_\",\"type\":\"uint256\"},{\"name\":\"oldReadyToWithdraw_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"itemHistoryOfPlayer\",\"outputs\":[{\"name\":\"_valueAddressOne\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_itemIds\",\"type\":\"uint256[]\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"listMultipleItems\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getReferrerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"countryStructs\",\"outputs\":[{\"name\":\"priceHistory\",\"type\":\"uint256\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameInfo\",\"outputs\":[{\"name\":\"richestPlayer_\",\"type\":\"address\"},{\"name\":\"lastBuyer_\",\"type\":\"address\"},{\"name\":\"thisBalance_\",\"type\":\"uint256\"},{\"name\":\"lastWithdrawPotVersion_\",\"type\":\"uint256\"},{\"name\":\"worldScore_\",\"type\":\"uint256\"},{\"name\":\"potVersion_\",\"type\":\"uint256\"},{\"name\":\"timestampLimit_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"calculateNextPrice\",\"outputs\":[{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"pendingRefBonus_\",\"type\":\"uint256\"},{\"name\":\"pendingFromScore_\",\"type\":\"uint256\"},{\"name\":\"totalPending_\",\"type\":\"uint256\"},{\"name\":\"balanceReadyToWithdraw_\",\"type\":\"uint256\"},{\"name\":\"playerScore_\",\"type\":\"uint256\"},{\"name\":\"handicap_\",\"type\":\"uint256\"},{\"name\":\"dividendsScore_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_itemId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_itemId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"SetReferrerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer1\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer2\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referralPart\",\"type\":\"uint256\"}],\"name\":\"PayReferrerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bonusToDispatch_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusDispatched_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"notYetDispatched_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_itemSoldId_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"kBonus\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"countryScore\",\"type\":\"uint256\"}],\"name\":\"BonusConstant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bonusToGet_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerScoreForThisCountry_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pendingBalanceTotal_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_itemSoldId\",\"type\":\"uint256\"}],\"name\":\"BonusDispatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dividendsCut_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dividendsScore\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_itemId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"worldScore_\",\"type\":\"uint256\"}],\"name\":\"DivsDispatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"richest_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"richestScore_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"blocktimestamp_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"blocknumber_\",\"type\":\"uint256\"}],\"name\":\"newRichest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"potVersion_\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"refbonus_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"divs_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPending_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerSc_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_handicap_\",\"type\":\"uint256\"}],\"name\":\"ConfirmWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractBalance\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"richest_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"richestBalance_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"lastBuyer_\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lastBalance_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"potVersion\",\"type\":\"uint256\"}],\"name\":\"ConfirmPotWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blocktimestamp_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"timestamplimit_\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dividendsScore_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"potVersion\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lastWithdrawPotVersion_\",\"type\":\"uint256\"}],\"name\":\"PotWithdrawConstant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"potVersion\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"lastWithdrawPotVersion_\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"balance_\",\"type\":\"uint256\"}],\"name\":\"WithdrawOwner\",\"type\":\"event\"}]","ContractName":"SuperCountriesEth","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b191ed1a8bdcdc035763bb752add4a85ba678083b74d57e4430ece4780fc1f66"}]}