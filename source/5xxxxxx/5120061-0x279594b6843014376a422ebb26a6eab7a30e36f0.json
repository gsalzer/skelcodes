{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract OtcInterface {\r\n    function sellAllAmount(address, uint, address, uint) public returns (uint);\r\n    function buyAllAmount(address, uint, address, uint) public returns (uint);\r\n    function getPayAmount(address, address, uint) public constant returns (uint);\r\n}\r\n\r\ncontract TokenInterface {\r\n    function balanceOf(address) public returns (uint);\r\n    function allowance(address, address) public returns (uint);\r\n    function approve(address, uint) public;\r\n    function transfer(address,uint) public returns (bool);\r\n    function transferFrom(address, address, uint) public returns (bool);\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\ncontract OasisDirectProxy is DSMath {\r\n    function withdrawAndSend(TokenInterface wethToken, uint wethAmt) internal {\r\n        wethToken.withdraw(wethAmt);\r\n        require(msg.sender.call.value(wethAmt)());\r\n    }\r\n\r\n    function sellAllAmount(OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface buyToken, uint minBuyAmt) public returns (uint buyAmt) {\r\n        require(payToken.transferFrom(msg.sender, this, payAmt));\r\n        if (payToken.allowance(this, otc) < payAmt) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        buyAmt = otc.sellAllAmount(payToken, payAmt, buyToken, minBuyAmt);\r\n        require(buyToken.transfer(msg.sender, buyAmt));\r\n    }\r\n\r\n    function sellAllAmountPayEth(OtcInterface otc, TokenInterface wethToken, TokenInterface buyToken, uint minBuyAmt) public payable returns (uint buyAmt) {\r\n        wethToken.deposit.value(msg.value)();\r\n        if (wethToken.allowance(this, otc) < msg.value) {\r\n            wethToken.approve(otc, uint(-1));\r\n        }\r\n        buyAmt = otc.sellAllAmount(wethToken, msg.value, buyToken, minBuyAmt);\r\n        require(buyToken.transfer(msg.sender, buyAmt));\r\n    }\r\n\r\n    function sellAllAmountBuyEth(OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface wethToken, uint minBuyAmt) public returns (uint wethAmt) {\r\n        require(payToken.transferFrom(msg.sender, this, payAmt));\r\n        if (payToken.allowance(this, otc) < payAmt) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt);\r\n        withdrawAndSend(wethToken, wethAmt);\r\n    }\r\n\r\n    function buyAllAmount(OtcInterface otc, TokenInterface buyToken, uint buyAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) {\r\n        uint payAmtNow = otc.getPayAmount(payToken, buyToken, buyAmt);\r\n        require(payAmtNow <= maxPayAmt);\r\n        require(payToken.transferFrom(msg.sender, this, payAmtNow));\r\n        if (payToken.allowance(this, otc) < payAmtNow) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        payAmt = otc.buyAllAmount(buyToken, buyAmt, payToken, payAmtNow);\r\n        require(buyToken.transfer(msg.sender, min(buyAmt, buyToken.balanceOf(this)))); // To avoid rounding issues we check the minimum value\r\n    }\r\n\r\n    function buyAllAmountPayEth(OtcInterface otc, TokenInterface buyToken, uint buyAmt, TokenInterface wethToken) public payable returns (uint wethAmt) {\r\n        // In this case user needs to send more ETH than a estimated value, then contract will send back the rest\r\n        wethToken.deposit.value(msg.value)();\r\n        if (wethToken.allowance(this, otc) < msg.value) {\r\n            wethToken.approve(otc, uint(-1));\r\n        }\r\n        wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);\r\n        require(buyToken.transfer(msg.sender, min(buyAmt, buyToken.balanceOf(this)))); // To avoid rounding issues we check the minimum value\r\n        withdrawAndSend(wethToken, sub(msg.value, wethAmt));\r\n    }\r\n\r\n    function buyAllAmountBuyEth(OtcInterface otc, TokenInterface wethToken, uint wethAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) {\r\n        uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt);\r\n        require(payAmtNow <= maxPayAmt);\r\n        require(payToken.transferFrom(msg.sender, this, payAmtNow));\r\n        if (payToken.allowance(this, otc) < payAmtNow) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow);\r\n        withdrawAndSend(wethToken, wethAmt);\r\n    }\r\n\r\n    function() public payable {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmountBuyEth\",\"outputs\":[{\"name\":\"wethAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmount\",\"outputs\":[{\"name\":\"buyAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"buyAllAmount\",\"outputs\":[{\"name\":\"payAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"name\":\"wethToken\",\"type\":\"address\"}],\"name\":\"buyAllAmountPayEth\",\"outputs\":[{\"name\":\"wethAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmountPayEth\",\"outputs\":[{\"name\":\"buyAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"wethAmt\",\"type\":\"uint256\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"buyAllAmountBuyEth\",\"outputs\":[{\"name\":\"payAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"OasisDirectProxy","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a760e37815f1101d40877e0d7313bf2b012a21447034a8911508cbbbd71d51e8"}]}