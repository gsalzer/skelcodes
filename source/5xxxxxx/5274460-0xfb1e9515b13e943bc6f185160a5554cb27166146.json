{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.18;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) internal pure  returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure  returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure  returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n// @notice  Whitelist interface which will hold whitelisted users\r\ncontract WhiteList is Ownable {\r\n\r\n    function isWhiteListed(address _user) external view returns (bool);        \r\n}\r\n\r\n// Crowdsale Smart Contract\r\n// This smart contract collects ETH and in return sends tokens to contributors\r\ncontract Crowdsale is Pausable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Backer {\r\n        uint weiReceived; // amount of ETH contributed\r\n        uint tokensToSend; // amount of tokens  sent      \r\n        bool refunded;\r\n    }\r\n\r\n    Token public token; // Token contract reference   \r\n    address public multisig; // Multisig contract that will receive the ETH    \r\n    address public team; // Address at which the team tokens will be sent        \r\n    uint public ethReceivedPresale; // Number of ETH received in presale\r\n    uint public ethReceivedMain; // Number of ETH received in public sale\r\n    uint public tokensSentPresale; // Tokens sent during presale\r\n    uint public tokensSentMain; // Tokens sent during public ICO   \r\n    uint public totalTokensSent; // Total number of tokens sent to contributors\r\n    uint public startBlock; // Crowdsale start block\r\n    uint public endBlock; // Crowdsale end block\r\n    uint public maxCap; // Maximum number of tokens to sell    \r\n    uint public minInvestETH; // Minimum amount to invest   \r\n    bool public crowdsaleClosed; // Is crowdsale still in progress\r\n    Step public currentStep;  // To allow for controlled steps of the campaign \r\n    uint public refundCount;  // Number of refunds\r\n    uint public totalRefunded; // Total amount of Eth refunded          \r\n    uint public dollarToEtherRatio; // how many dollars are in one eth. Amount uses two decimal values. e.g. $333.44/ETH would be passed as 33344 \r\n    uint public numOfBlocksInMinute; // number of blocks in one minute * 100. eg. \r\n    WhiteList public whiteList;     // whitelist contract\r\n\r\n    mapping(address => Backer) public backers; // contributors list\r\n    address[] public backersIndex; // to be able to iterate through backers for verification.              \r\n    uint public priorTokensSent; \r\n    uint public presaleCap;\r\n   \r\n\r\n    // @notice to verify if action is not performed out of the campaign range\r\n    modifier respectTimeFrame() {\r\n        require(block.number >= startBlock && block.number <= endBlock);\r\n        _;\r\n    }\r\n\r\n    // @notice to set and determine steps of crowdsale\r\n    enum Step {      \r\n        FundingPreSale,     // presale mode\r\n        FundingPublicSale,  // public mode\r\n        Refunding  // in case campaign failed during this step contributors will be able to receive refunds\r\n    }\r\n\r\n    // Events\r\n    event ReceivedETH(address indexed backer, uint amount, uint tokenAmount);\r\n    event RefundETH(address indexed backer, uint amount);\r\n\r\n    // Crowdsale  {constructor}\r\n    // @notice fired when contract is crated. Initializes all constant and initial values.\r\n    // @param _dollarToEtherRatio {uint} how many dollars are in one eth.  $333.44/ETH would be passed as 33344\r\n    function Crowdsale(WhiteList _whiteList) public {               \r\n        multisig = 0x10f78f2a70B52e6c3b490113c72Ba9A90ff1b5CA; \r\n        team = 0x10f78f2a70B52e6c3b490113c72Ba9A90ff1b5CA; \r\n        maxCap = 1510000000e8;             \r\n        minInvestETH = 1 ether/2;    \r\n        currentStep = Step.FundingPreSale;\r\n        dollarToEtherRatio = 56413;       \r\n        numOfBlocksInMinute = 408;          // E.g. 4.38 block/per minute wold be entered as 438                  \r\n        priorTokensSent = 4365098999e7;     //tokens distributed in private sale and airdrops\r\n        whiteList = _whiteList;             // white list address\r\n        presaleCap = 107000000e8;           // max for sell in presale\r\n\r\n    }\r\n\r\n    // @notice to populate website with status of the sale and minimize amout of calls for each variable\r\n    function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, Step, bool, bool) {            \r\n    \r\n        return (startBlock, endBlock, backersIndex.length, ethReceivedPresale + ethReceivedMain, maxCap, totalTokensSent, currentStep, paused, crowdsaleClosed);\r\n    }\r\n\r\n    // @notice Specify address of token contract\r\n    // @param _tokenAddress {address} address of token contract\r\n    // @return res {bool}\r\n    function setTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\r\n        require(token == address(0));\r\n        token = _tokenAddress;\r\n        return true;\r\n    }\r\n\r\n    // @notice set the step of the campaign from presale to public sale\r\n    // contract is deployed in presale mode\r\n    // WARNING: there is no way to go back\r\n    function advanceStep() public onlyOwner() {\r\n\r\n        currentStep = Step.FundingPublicSale;                                             \r\n        minInvestETH = 1 ether/4;                                     \r\n    }\r\n\r\n    // @notice in case refunds are needed, money can be returned to the contract\r\n    // and contract switched to mode refunding\r\n    function prepareRefund() public payable onlyOwner() {\r\n        \r\n        require(msg.value == ethReceivedPresale.add(ethReceivedMain)); // make sure that proper amount of ether is sent\r\n        currentStep = Step.Refunding;\r\n    }\r\n\r\n    // @notice return number of contributors\r\n    // @return  {uint} number of contributors   \r\n    function numberOfBackers() public view returns(uint) {\r\n        return backersIndex.length;\r\n    }\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handles allocation of Ether and calculates tokens.\r\n    // Contributor will be instructed to specify sufficient amount of gas. e.g. 250,000 \r\n    function () external payable {           \r\n        contribute(msg.sender);\r\n    }\r\n\r\n    // @notice It will be called by owner to start the sale    \r\n    function start(uint _block) external onlyOwner() {   \r\n\r\n        require(_block <= (numOfBlocksInMinute * 60 * 24 * 55)/100);  // allow max 55 days for campaign 323136\r\n        startBlock = block.number;\r\n        endBlock = startBlock.add(_block); \r\n    }\r\n\r\n    // @notice Due to changing average of block time\r\n    // this function will allow on adjusting duration of campaign closer to the end \r\n    function adjustDuration(uint _block) external onlyOwner() {\r\n\r\n        require(_block < (numOfBlocksInMinute * 60 * 24 * 60)/100); // allow for max of 60 days for campaign\r\n        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\r\n        endBlock = startBlock.add(_block); \r\n    }   \r\n\r\n    // @notice due to Ether to Dollar flacutation this value will be adjusted during the campaign\r\n    // @param _dollarToEtherRatio {uint} new value of dollar to ether ratio\r\n    function adjustDollarToEtherRatio(uint _dollarToEtherRatio) external onlyOwner() {\r\n        require(_dollarToEtherRatio > 0);\r\n        dollarToEtherRatio = _dollarToEtherRatio;\r\n    }\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _backer {address} address of contributor\r\n    // @return res {bool} true if transaction was successful\r\n    function contribute(address _backer) internal whenNotPaused() respectTimeFrame() returns(bool res) {\r\n\r\n        require(whiteList.isWhiteListed(_backer));      // ensure that user is whitelisted\r\n\r\n        uint tokensToSend = determinePurchase();\r\n            \r\n        Backer storage backer = backers[_backer];\r\n\r\n        if (backer.weiReceived == 0)\r\n            backersIndex.push(_backer);\r\n       \r\n        backer.tokensToSend += tokensToSend; // save contributor's total tokens sent\r\n        backer.weiReceived = backer.weiReceived.add(msg.value);  // save contributor's total ether contributed\r\n\r\n        if (Step.FundingPublicSale == currentStep) { // Update the total Ether received and tokens sent during public sale\r\n            ethReceivedMain = ethReceivedMain.add(msg.value);\r\n            tokensSentMain += tokensToSend;\r\n        }else {                                                 // Update the total Ether recived and tokens sent during presale\r\n            ethReceivedPresale = ethReceivedPresale.add(msg.value); \r\n            tokensSentPresale += tokensToSend;\r\n        }\r\n                                                     \r\n        totalTokensSent += tokensToSend;     // update the total amount of tokens sent        \r\n        multisig.transfer(this.balance);   // transfer funds to multisignature wallet    \r\n\r\n        if (!token.transfer(_backer, tokensToSend)) \r\n            revert(); // Transfer tokens             \r\n\r\n        ReceivedETH(_backer, msg.value, tokensToSend); // Register event\r\n        return true;\r\n    }\r\n\r\n    // @notice determine if purchase is valid and return proper number of tokens\r\n    // @return tokensToSend {uint} proper number of tokens based on the timline\r\n    function determinePurchase() internal view  returns (uint) {\r\n\r\n        require(msg.value >= minInvestETH);   // ensure that min contributions amount is met  \r\n        uint tokenAmount = dollarToEtherRatio.mul(msg.value)/4e10;  // price of token is $0.01 and there are 8 decimals for the token\r\n        \r\n        uint tokensToSend;\r\n          \r\n        if (Step.FundingPublicSale == currentStep) {  // calculate price of token in public sale\r\n            tokensToSend = tokenAmount;\r\n            require(totalTokensSent + tokensToSend + priorTokensSent <= maxCap); // Ensure that max cap hasn't been reached  \r\n        }else {\r\n            tokensToSend = tokenAmount + (tokenAmount * 50) / 100; \r\n            require(totalTokensSent + tokensToSend <= presaleCap); // Ensure that max cap hasn't been reached for presale            \r\n        }                                                        \r\n       \r\n        return tokensToSend;\r\n    }\r\n\r\n    \r\n    // @notice This function will finalize the sale.\r\n    // It will only execute if predetermined sale time passed or all tokens are sold.\r\n    // it will fail if minimum cap is not reached\r\n    function finalize() external onlyOwner() {\r\n\r\n        require(!crowdsaleClosed);        \r\n        // purchasing precise number of tokens might be impractical, thus subtract 1000 \r\n        // tokens so finalization is possible near the end \r\n        require(block.number >= endBlock || totalTokensSent + priorTokensSent >= maxCap - 1000);                        \r\n        crowdsaleClosed = true; \r\n        \r\n        if (!token.transfer(team, token.balanceOf(this))) // transfer all remaining tokens to team address\r\n            revert();        \r\n        token.unlock();                      \r\n    }\r\n\r\n    // @notice Fail-safe drain\r\n    function drain() external onlyOwner() {\r\n        multisig.transfer(this.balance);               \r\n    }\r\n\r\n    // @notice Fail-safe token transfer\r\n    function tokenDrain() external onlyOwner() {\r\n        if (block.number > endBlock) {\r\n            if (!token.transfer(multisig, token.balanceOf(this))) \r\n                revert();\r\n        }\r\n    }\r\n    \r\n    // @notice it will allow contributors to get refund in case campaign failed\r\n    // @return {bool} true if successful\r\n    function refund() external whenNotPaused() returns (bool) {\r\n\r\n        require(currentStep == Step.Refunding);                        \r\n\r\n        Backer storage backer = backers[msg.sender];\r\n\r\n        require(backer.weiReceived > 0);  // ensure that user has sent contribution\r\n        require(!backer.refunded);        // ensure that user hasn't been refunded yet\r\n\r\n        backer.refunded = true;  // save refund status to true\r\n        refundCount++;\r\n        totalRefunded = totalRefunded + backer.weiReceived;\r\n\r\n        if (!token.transfer(msg.sender, backer.tokensToSend)) // return allocated tokens\r\n            revert();                            \r\n        msg.sender.transfer(backer.weiReceived);  // send back the contribution \r\n        RefundETH(msg.sender, backer.weiReceived);\r\n        return true;\r\n    }\r\n\r\n   \r\n\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns(uint);\r\n\r\n    function allowance(address owner, address spender) public view returns(uint);\r\n\r\n    function transfer(address to, uint value) public returns(bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) public returns(bool ok);\r\n\r\n    function approve(address spender, uint value) public returns(bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// The token\r\ncontract Token is ERC20, Ownable {\r\n   \r\n    function unlock() public;\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnWebsiteData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dollarToEtherRatio\",\"type\":\"uint256\"}],\"name\":\"adjustDollarToEtherRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"advanceStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"prepareRefund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priorTokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenDrain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"adjustDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfBlocksInMinute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSentPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"backers\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"tokensToSend\",\"type\":\"uint256\"},{\"name\":\"refunded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSentMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dollarToEtherRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backersIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_whiteList\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ced4eb91efe1b708782afd33aa529a6a9ace6671","Library":"","SwarmSource":"bzzr://2dd97d0b8d4d0629c32fd1eb2ee4a2e35994e71157b6b5f289356dd05b81305b"}]}