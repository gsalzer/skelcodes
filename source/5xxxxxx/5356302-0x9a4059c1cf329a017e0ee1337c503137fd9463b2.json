{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n\r\npragma solidity ^0.4.15;\r\n\r\n/**\r\n * @title Safe math operations that throw error on overflow.\r\n *\r\n * Credit: Taking ideas from FirstBlood token\r\n */\r\nlibrary SafeMath {\r\n\r\n    /** \r\n     * @dev Safely add two numbers.\r\n     *\r\n     * @param x First operant.\r\n     * @param y Second operant.\r\n     * @return The result of x+y.\r\n     */\r\n    function add(uint256 x, uint256 y)\r\n    internal constant\r\n    returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n\r\n    /** \r\n     * @dev Safely substract two numbers.\r\n     *\r\n     * @param x First operant.\r\n     * @param y Second operant.\r\n     * @return The result of x-y.\r\n     */\r\n    function sub(uint256 x, uint256 y)\r\n    internal constant\r\n    returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n\r\n    /** \r\n     * @dev Safely multiply two numbers.\r\n     *\r\n     * @param x First operant.\r\n     * @param y Second operant.\r\n     * @return The result of x*y.\r\n     */\r\n    function mul(uint256 x, uint256 y)\r\n    internal constant\r\n    returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0) || (z/x == y));\r\n        return z;\r\n    }\r\n\r\n    /**\r\n    * @dev Parse a floating point number from String to uint, e.g. \"250.56\" to \"25056\"\r\n     */\r\n    function parse(string s) \r\n    internal constant \r\n    returns (uint256) \r\n    {\r\n    bytes memory b = bytes(s);\r\n    uint result = 0;\r\n    for (uint i = 0; i < b.length; i++) {\r\n        if (b[i] >= 48 && b[i] <= 57) {\r\n            result = result * 10 + (uint(b[i]) - 48); \r\n        }\r\n    }\r\n    return result; \r\n}\r\n}\r\n\r\n\r\n/**\r\n * @title The abstract ERC-20 Token Standard definition.\r\n *\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract Token {\r\n    /// @dev Returns the total token supply.\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    /// @dev MUST trigger when tokens are transferred, including zero value transfers.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /// @dev MUST trigger on any successful call to approve(address _spender, uint256 _value).\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * @title Default implementation of the ERC-20 Token Standard.\r\n */\r\ncontract StandardToken is Token {\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. \r\n     * @dev The function SHOULD throw if the _from account balance does not have enough tokens to spend.\r\n     *\r\n     * @dev A token contract which creates new tokens SHOULD trigger a Transfer event with the _from address set to 0x0 when tokens are created.\r\n     *\r\n     * Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n     *\r\n     * @param _to The receiver of the tokens.\r\n     * @param _value The amount of tokens to send.\r\n     * @return True on success, false otherwise.\r\n     */\r\n    function transfer(address _to, uint256 _value)\r\n    public\r\n    returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\r\n            balances[_to] = SafeMath.add(balances[_to], _value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.\r\n     *\r\n     * @dev The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. \r\n     * @dev This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in \r\n     * @dev sub-currencies. The function SHOULD throw unless the _from account has deliberately authorized the sender of \r\n     * @dev the message via some mechanism.\r\n     *\r\n     * Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n     *\r\n     * @param _from The sender of the tokens.\r\n     * @param _to The receiver of the tokens.\r\n     * @param _value The amount of tokens to send.\r\n     * @return True on success, false otherwise.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] = SafeMath.add(balances[_to], _value);\r\n            balances[_from] = SafeMath.sub(balances[_from], _value);\r\n            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the account balance of another account with address _owner.\r\n     *\r\n     * @param _owner The address of the account to check.\r\n     * @return The account balance.\r\n     */\r\n    function balanceOf(address _owner)\r\n    public constant\r\n    returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. \r\n     * @dev If this function is called again it overwrites the current allowance with _value.\r\n     *\r\n     * @dev NOTE: To prevent attack vectors like the one described in [1] and discussed in [2], clients \r\n     * @dev SHOULD make sure to create user interfaces in such a way that they set the allowance first \r\n     * @dev to 0 before setting it to another value for the same spender. THOUGH The contract itself \r\n     * @dev shouldn't enforce it, to allow backwards compatilibilty with contracts deployed before.\r\n     * @dev [1] https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/\r\n     * @dev [2] https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     * @return True on success, false otherwise.\r\n     */\r\n    function approve(address _spender, uint256 _value)\r\n    public\r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\r\n     *\r\n     * @param _owner The address of the sender.\r\n     * @param _spender The address of the receiver.\r\n     * @return The allowed withdrawal amount.\r\n     */\r\n    function allowance(address _owner, address _spender)\r\n    public constant\r\n    onlyPayloadSize(2)\r\n    returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title The LCDToken Token contract.\r\n *\r\n * Credit: Taking ideas from BAT token and NET token\r\n */\r\n /*is StandardToken */\r\ncontract LCDToken is StandardToken {\r\n\r\n    // Token metadata\r\n    string public constant name = \"Lucyd\";\r\n    string public constant symbol = \"LCD\";\r\n    uint256 public constant decimals = 18;\r\n\r\n    uint256 public constant TOKEN_COMPANY_OWNED = 10 * (10**6) * 10**decimals; // 10 million LCDs\r\n    uint256 public constant TOKEN_MINTING = 30 * (10**6) * 10**decimals;       // 30 million LCDs\r\n    uint256 public constant TOKEN_BUSINESS = 10 * (10**6) * 10**decimals;       // 10 million LCDs\r\n\r\n    // wallet that is allowed to distribute tokens on behalf of the app store\r\n    address public APP_STORE;\r\n\r\n    // Administrator for multi-sig mechanism\r\n    address public admin1;\r\n    address public admin2;\r\n\r\n    // Accounts that are allowed to deliver tokens\r\n    address public tokenVendor1;\r\n    address public tokenVendor2;\r\n\r\n    // Keep track of holders and icoBuyers\r\n    mapping (address => bool) public isHolder; // track if a user is a known token holder to the smart contract - important for payouts later\r\n    address[] public holders;                  // array of all known holders - important for payouts later\r\n\r\n    // store the hashes of admins' msg.data\r\n    mapping (address => bytes32) private multiSigHashes;\r\n\r\n    // to track if management already got their tokens\r\n    bool public managementTokensDelivered;\r\n\r\n    // current amount of disbursed tokens\r\n    uint256 public tokensSold;\r\n\r\n    // Events used for logging\r\n    event LogLCDTokensDelivered(address indexed _to, uint256 _value);\r\n    event LogManagementTokensDelivered(address indexed distributor, uint256 _value);\r\n    event Auth(string indexed authString, address indexed user);\r\n\r\n    modifier onlyOwner() {\r\n        // check if transaction sender is admin.\r\n        require (msg.sender == admin1 || msg.sender == admin2);\r\n        // if yes, store his msg.data. \r\n        multiSigHashes[msg.sender] = keccak256(msg.data);\r\n        // check if his stored msg.data hash equals to the one of the other admin\r\n        if ((multiSigHashes[admin1]) == (multiSigHashes[admin2])) {\r\n            // if yes, both admins agreed - continue.\r\n            _;\r\n\r\n            // Reset hashes after successful execution\r\n            multiSigHashes[admin1] = 0x0;\r\n            multiSigHashes[admin2] = 0x0;\r\n        } else {\r\n            // if not (yet), return.\r\n            return;\r\n        }\r\n    }\r\n\r\n    modifier onlyVendor() {\r\n        require((msg.sender == tokenVendor1) || (msg.sender == tokenVendor2));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new LCDToken contract.\r\n     *\r\n     *  _admin1 The first admin account that owns this contract.\r\n     *  _admin2 The second admin account that owns this contract.\r\n     *  _tokenVendor1 The first token vendor\r\n     *  _tokenVendor2 The second token vendor\r\n     */\r\n    function LCDToken(\r\n        address _admin1,\r\n        address _admin2,\r\n        address _tokenVendor1,\r\n        address _tokenVendor2,\r\n        address _appStore,\r\n        address _business_development)\r\n    public\r\n    {\r\n        // admin1 and admin2 address must be set and must be different\r\n        require (_admin1 != 0x0);\r\n        require (_admin2 != 0x0);\r\n        require (_admin1 != _admin2);\r\n\r\n        // tokenVendor1 and tokenVendor2 must be set and must be different\r\n        require (_tokenVendor1 != 0x0);\r\n        require (_tokenVendor2 != 0x0);\r\n        require (_tokenVendor1 != _tokenVendor2);\r\n\r\n        // tokenVendors must be different from admins\r\n        require (_tokenVendor1 != _admin1);\r\n        require (_tokenVendor1 != _admin2);\r\n        require (_tokenVendor2 != _admin1);\r\n        require (_tokenVendor2 != _admin2);\r\n        require (_appStore != 0x0);\r\n\r\n        admin1 = _admin1;\r\n        admin2 = _admin2;\r\n        tokenVendor1 = _tokenVendor1;\r\n        tokenVendor2 = _tokenVendor2;\r\n\r\n        // Init app store balance\r\n        APP_STORE = _appStore;\r\n        balances[_appStore] = TOKEN_MINTING;\r\n        trackHolder(_appStore);\r\n\r\n        // Init business development balance to admin1 \r\n        balances[_admin1] = TOKEN_BUSINESS;\r\n        trackHolder(_business_development);\r\n\r\n        totalSupply = SafeMath.add(TOKEN_MINTING, TOKEN_BUSINESS);\r\n    }\r\n\r\n    // Allows to figure out the amount of known token holders\r\n    function getHolderCount()\r\n    public\r\n    constant\r\n    returns (uint256 _holderCount)\r\n    {\r\n        return holders.length;\r\n    }\r\n\r\n    // Allows for easier retrieval of holder by array index\r\n    function getHolder(uint256 _index)\r\n    public\r\n    constant\r\n    returns (address _holder)\r\n    {\r\n        return holders[_index];\r\n    }\r\n\r\n    function trackHolder(address _to)\r\n    private\r\n    returns (bool success)\r\n    {\r\n        // Check if the recipient is a known token holder\r\n        if (isHolder[_to] == false) {\r\n            // if not, add him to the holders array and mark him as a known holder\r\n            holders.push(_to);\r\n            isHolder[_to] = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer LCD tokens\r\n    function deliverTokens(address _buyer, uint256 _amount) // amount input will  be in cents\r\n    external\r\n    onlyVendor\r\n    returns(bool success)\r\n    {\r\n        // check if the function is called before May 1, 2018\r\n        require(block.timestamp <= 1525125600);\r\n\r\n        // Calculate the number of tokens from the given amount in cents\r\n        uint256 tokens = SafeMath.mul(_amount, 10**decimals / 100);\r\n\r\n        // update state\r\n        uint256 oldBalance = balances[_buyer];\r\n        balances[_buyer] = SafeMath.add(oldBalance, tokens);\r\n        tokensSold = SafeMath.add(tokensSold, tokens);\r\n        totalSupply = SafeMath.add(totalSupply, tokens);\r\n        trackHolder(_buyer);\r\n\r\n        // Log the transfer of these tokens\r\n        Transfer(msg.sender, _buyer, tokens);\r\n        LogLCDTokensDelivered(_buyer, tokens);\r\n        return true;\r\n    }\r\n\r\n    // @dev Transfer tokens to management wallet\r\n    function deliverManagementTokens(address _managementWallet)\r\n    external\r\n    onlyOwner\r\n    returns (bool success)\r\n    {\r\n        // check if management tokens are already unlocked, if the function is called after March 31., 2019\r\n        require(block.timestamp >= 1553990400);\r\n\r\n        // Deliver management tokens only once\r\n        require(managementTokensDelivered == false);\r\n\r\n        // update state\r\n        balances[_managementWallet] = TOKEN_COMPANY_OWNED;\r\n        totalSupply = SafeMath.add(totalSupply, TOKEN_COMPANY_OWNED);\r\n        managementTokensDelivered = true;\r\n        trackHolder(_managementWallet);\r\n\r\n        // Log the transfer of these tokens\r\n        Transfer(address(this), _managementWallet, TOKEN_COMPANY_OWNED);\r\n        LogManagementTokensDelivered(_managementWallet, TOKEN_COMPANY_OWNED);\r\n        return true;\r\n    }\r\n\r\n    // Using this for creating a reference between ETH wallets and accounts in the Lucyd backend\r\n    function auth(string _authString)\r\n    external\r\n    {\r\n        Auth(_authString, msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"admin2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deliverTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenVendor2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHolderCount\",\"outputs\":[{\"name\":\"_holderCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_MINTING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managementTokensDelivered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_BUSINESS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"APP_STORE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authString\",\"type\":\"string\"}],\"name\":\"auth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getHolder\",\"outputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenVendor1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_managementWallet\",\"type\":\"address\"}],\"name\":\"deliverManagementTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_COMPANY_OWNED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin1\",\"type\":\"address\"},{\"name\":\"_admin2\",\"type\":\"address\"},{\"name\":\"_tokenVendor1\",\"type\":\"address\"},{\"name\":\"_tokenVendor2\",\"type\":\"address\"},{\"name\":\"_appStore\",\"type\":\"address\"},{\"name\":\"_business_development\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogLCDTokensDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"distributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogManagementTokensDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authString\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Auth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"LCDToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000490153246ef146281625cadd47a410592f548780000000000000000000000000c347a6af34481b0fb08dd8f8e73572a2a95aab0b0000000000000000000000004a20a727c87647eeae9cf98ce56b87de2541e7cd00000000000000000000000041fa9627d27185cacb9e39e31e7b570dd69f87ea000000000000000000000000ba0b0d4929b1d7b64686d4f933d9f20b3227ac8a000000000000000000000000490153246ef146281625cadd47a410592f548780","Library":"","SwarmSource":"bzzr://ff9f32443c49325be7a72116614a61080b95ebb8435259549d65d76d54850891"}]}