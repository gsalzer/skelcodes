{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  Crowdsale for m+plus coin phase 2\r\n *\r\n *  Based on OpenZeppelin framework.\r\n *  https://openzeppelin.org\r\n **/\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * Safe Math library from OpenZeppelin framework\r\n * https://openzeppelin.org\r\n *\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale for m+plus coin phase 1\r\n */\r\ncontract MplusCrowdsaleB {\r\n    using SafeMath for uint256;\r\n\r\n    // Number of stages\r\n    uint256 internal constant NUM_STAGES = 4;\r\n\r\n    // 05/02 - 05/16\r\n    uint256 internal constant ICO_START1 = 1525190400;\r\n    // 05/17 - 06/01\r\n    uint256 internal constant ICO_START2 = 1526486400;\r\n    // 06/02 - 06/16\r\n    uint256 internal constant ICO_START3 = 1527868800;\r\n    // 06/17 - 07/01\r\n    uint256 internal constant ICO_START4 = 1529164800;\r\n    // 07/01\r\n    uint256 internal constant ICO_END = 1530460799;\r\n\r\n    // Exchange rate for each term periods\r\n    uint256 internal constant ICO_RATE1 = 13000;\r\n    uint256 internal constant ICO_RATE2 = 12500;\r\n    uint256 internal constant ICO_RATE3 = 12000;\r\n    uint256 internal constant ICO_RATE4 = 11500;\r\n\r\n    // Funding goal and soft cap in Token\r\n    //uint256 internal constant HARD_CAP = 2000000000 * (10 ** 18);\r\n    // Cap for each term periods in ETH\r\n    // Exchange rate for each term periods\r\n    uint256 internal constant ICO_CAP1 = 8000 * (10 ** 18);\r\n    uint256 internal constant ICO_CAP2 = 16000 * (10 ** 18);\r\n    uint256 internal constant ICO_CAP3 = 24000 * (10 ** 18);\r\n    uint256 internal constant ICO_CAP4 = 32000 * (10 ** 18);\r\n\r\n    // Caps per a purchase\r\n    uint256 internal constant MIN_CAP = (10 ** 17);\r\n    uint256 internal constant MAX_CAP = 1000 * (10 ** 18);\r\n\r\n    // Owner of this contract\r\n    address internal owner;\r\n\r\n    // The token being sold\r\n    ERC20 public tokenReward;\r\n\r\n    // Tokens will be transfered from this address\r\n    address internal tokenOwner;\r\n\r\n    // Address where funds are collected\r\n    address internal wallet;\r\n\r\n    // Stage of ICO\r\n    uint256 public stage = 0;\r\n\r\n    // Amount of tokens sold\r\n    uint256 public tokensSold = 0;\r\n\r\n    // Amount of raised money in wei\r\n    uint256 public weiRaised = 0;\r\n\r\n    /**\r\n     * Event for token purchase logging\r\n     *\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    event IcoStageStarted(uint256 stage);\r\n    event IcoEnded();\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function MplusCrowdsaleB(address _tokenAddress, address _wallet) public {\r\n        require(_tokenAddress != address(0));\r\n        require(_wallet != address(0));\r\n\r\n        owner = msg.sender;\r\n        tokenOwner = msg.sender;\r\n        wallet = _wallet;\r\n\r\n        tokenReward = ERC20(_tokenAddress);\r\n    }\r\n\r\n    // Fallback function can be used to buy tokens\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    // Low level token purchase function\r\n    function buyTokens(address _beneficiary) public payable {\r\n        require(_beneficiary != address(0));\r\n        require(msg.value >= MIN_CAP);\r\n        require(msg.value <= MAX_CAP);\r\n        require(now >= ICO_START1);\r\n        require(now <= ICO_END);\r\n        require(stage <= NUM_STAGES);\r\n\r\n        determineCurrentStage();\r\n//        require(stage >= 1 && stage <= NUM_STAGES);\r\n\r\n        uint256 weiAmount = msg.value;\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = getTokenAmount(weiAmount);\r\n        require(tokens > 0);\r\n\r\n        // Update totals\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokensSold = tokensSold.add(tokens);\r\n        checkCap();\r\n\r\n        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n        require(tokenReward.transferFrom(tokenOwner, _beneficiary, tokens));\r\n        forwardFunds();\r\n    }\r\n\r\n    // Send ether to the fund collection wallet\r\n    function forwardFunds() internal {\r\n        wallet.transfer(msg.value);\r\n    }\r\n\r\n    function determineCurrentStage() internal {\r\n//        uint256 prevStage = stage;\r\n        if (stage < 4 && now >= ICO_START4) {\r\n            stage = 4;\r\n            emit IcoStageStarted(4);\r\n        } else if (stage < 3 && now >= ICO_START3) {\r\n            stage = 3;\r\n            emit IcoStageStarted(3);\r\n        } else if (stage < 2 && now >= ICO_START2) {\r\n            stage = 2;\r\n            emit IcoStageStarted(2);\r\n        } else if (stage < 1 && now >= ICO_START1) {\r\n            stage = 1;\r\n            emit IcoStageStarted(1);\r\n        }\r\n    }\r\n\r\n    function checkCap() internal {\r\n        if (weiRaised >= ICO_CAP4) {\r\n            stage = 5;\r\n            emit IcoEnded();\r\n        } else if (stage < 4 && weiRaised >= ICO_CAP3) {\r\n            stage = 4;\r\n            emit IcoStageStarted(4);\r\n        } else if (stage < 3 && weiRaised >= ICO_CAP2) {\r\n            stage = 3;\r\n            emit IcoStageStarted(3);\r\n        } else if (stage < 2 && weiRaised >= ICO_CAP1) {\r\n            stage = 2;\r\n            emit IcoStageStarted(2);\r\n        }\r\n    }\r\n\r\n    function getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        uint256 rate = 0;\r\n\r\n        if (stage == 1) {\r\n            rate = ICO_RATE1;\r\n        } else if (stage == 2) {\r\n            rate = ICO_RATE2;\r\n        } else if (stage == 3) {\r\n            rate = ICO_RATE3;\r\n        } else if (stage == 4) {\r\n            rate = ICO_RATE4;\r\n        }\r\n\r\n        return rate.mul(_weiAmount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stage\",\"type\":\"uint256\"}],\"name\":\"IcoStageStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"IcoEnded\",\"type\":\"event\"}]","ContractName":"MplusCrowdsaleB","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000218f1de2ea9ae3e9fdea347b6e707ebfda2d6233000000000000000000000000c2b0177ece66854b7c92300bb5d0cec49401a5b3","Library":"","SwarmSource":"bzzr://9add0fa5759d2a015a22976837f373cfdc8cc0c3c77301f6efc1556f088c4e7d"}]}