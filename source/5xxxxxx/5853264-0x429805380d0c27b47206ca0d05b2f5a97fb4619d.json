{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract ERC20 {\r\n  function balanceOf (address owner) public view returns (uint256);\r\n  function transfer (address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract FSTSaleServiceWindowReferral {\r\n  using Math for uint256;\r\n\r\n  address public owner;\r\n  address private rf = address(0);\r\n\r\n  bytes32 private secretHash;\r\n  ERC20 public funderSmartToken;\r\n  Math.Fraction public fstPrice;\r\n\r\n  uint256 public totalEtherReceived = 0;\r\n\r\n  bool public isEnabled = true;\r\n  bool public finalized = false;\r\n\r\n  event TokenPurchase(\r\n    ERC20 indexed token,\r\n    address indexed buyer,\r\n    address indexed receiver,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n  \r\n  event RFDeclare(address rf);\r\n  event Finalize(address receiver, address rf, uint256 fstkRevenue);\r\n\r\n  constructor (\r\n    address _fstAddress,\r\n    bytes32 _secretHash\r\n  ) public {\r\n    owner = msg.sender;\r\n    secretHash = _secretHash;\r\n    funderSmartToken = ERC20(_fstAddress);\r\n    fstPrice.numerator = 1;\r\n    fstPrice.denominator = 3600;\r\n  }\r\n\r\n  function () public payable {\r\n    uint256 available = funderSmartToken.balanceOf(address(this));\r\n    uint256 revenue;\r\n    uint256 purchaseAmount = msg.value.div(fstPrice);\r\n\r\n    require(\r\n      isEnabled &&\r\n      finalized == false &&\r\n      available > 0 &&\r\n      purchaseAmount > 0\r\n    );\r\n\r\n    if (available >= purchaseAmount) {\r\n      revenue = msg.value;\r\n    } else {\r\n      purchaseAmount = available;\r\n      revenue = available.mulCeil(fstPrice);\r\n      isEnabled = false;\r\n\r\n      msg.sender.transfer(msg.value - revenue);\r\n    }\r\n\r\n    funderSmartToken.transfer(msg.sender, purchaseAmount);\r\n\r\n    emit TokenPurchase(funderSmartToken, msg.sender, msg.sender, revenue, purchaseAmount);\r\n    \r\n    totalEtherReceived += revenue;\r\n  }\r\n  \r\n  function declareRF(string _secret) public {\r\n    require(\r\n      secretHash == keccak256(abi.encodePacked(_secret)) &&\r\n      rf == address(0)\r\n    );\r\n\r\n    rf = msg.sender;\r\n    \r\n    emit RFDeclare(rf);\r\n  }\r\n\r\n  function finalize (address _receiver) public {\r\n    require(\r\n      msg.sender == owner &&\r\n      isEnabled == false &&\r\n      finalized == false &&\r\n      rf != address(0)\r\n    );\r\n\r\n    finalized = true;\r\n\r\n    // 15% referral\r\n    rf.transfer(address(this).balance * 15 / 100);\r\n    _receiver.transfer(address(this).balance);\r\n\r\n    uint256 available = funderSmartToken.balanceOf(address(this));\r\n    if (available > 0) {\r\n      funderSmartToken.transfer(_receiver, available);\r\n    }\r\n\r\n    emit Finalize(_receiver, rf, totalEtherReceived * 85 / 100);\r\n  }\r\n\r\n  function setOwner (address _ownder) public {\r\n    require(msg.sender == owner);\r\n    owner = _ownder;\r\n  }\r\n\r\n  function setFunderSmartToken(address _fstAddress) public {\r\n    require(msg.sender == owner);\r\n    funderSmartToken = ERC20(_fstAddress);\r\n  }\r\n\r\n  function setFSTPrice(uint256 numerator, uint256 denominator) public {\r\n    require(msg.sender == owner);\r\n    require(\r\n      numerator > 0 &&\r\n      denominator > 0\r\n    );\r\n\r\n    fstPrice.numerator = numerator;\r\n    fstPrice.denominator = denominator;\r\n  }\r\n\r\n  function setEnabled (bool _isEnabled) public {\r\n    require(msg.sender == owner);\r\n    isEnabled = _isEnabled;\r\n  }\r\n\r\n}\r\n\r\nlibrary Math {\r\n\r\n  struct Fraction {\r\n    uint256 numerator;\r\n    uint256 denominator;\r\n  }\r\n\r\n  function isPositive(Fraction memory fraction) internal pure returns (bool) {\r\n    return fraction.numerator > 0 && fraction.denominator > 0;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    r = a * b;\r\n    require((a == 0) || (r / a == b));\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    r = a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    require((r = a - b) <= a);\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    require((r = a + b) >= a);\r\n  }\r\n\r\n  function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n    return x <= y ? x : y;\r\n  }\r\n\r\n  function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n    return x >= y ? x : y;\r\n  }\r\n\r\n  function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\r\n    // try mul\r\n    r = value * m;\r\n    if (r / value == m) {\r\n      // if mul not overflow\r\n      r /= d;\r\n    } else {\r\n      // else div first\r\n      r = mul(value / d, m);\r\n    }\r\n  }\r\n\r\n  function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\r\n    // try mul\r\n    r = value * m;\r\n    if (r / value == m) {\r\n      // mul not overflow\r\n      if (r % d == 0) {\r\n        r /= d;\r\n      } else {\r\n        r = (r / d) + 1;\r\n      }\r\n    } else {\r\n      // mul overflow then div first\r\n      r = mul(value / d, m);\r\n      if (value % d != 0) {\r\n        r += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDiv(x, f.numerator, f.denominator);\r\n  }\r\n\r\n  function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDivCeil(x, f.numerator, f.denominator);\r\n  }\r\n\r\n  function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDiv(x, f.denominator, f.numerator);\r\n  }\r\n\r\n  function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDivCeil(x, f.denominator, f.numerator);\r\n  }\r\n\r\n  function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\r\n    return Math.Fraction({\r\n      numerator: mul(x.numerator, y.numerator),\r\n      denominator: mul(x.denominator, y.denominator)\r\n    });\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"funderSmartToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownder\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"setEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fstPrice\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"setFSTPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fstAddress\",\"type\":\"address\"}],\"name\":\"setFunderSmartToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"declareRF\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fstAddress\",\"type\":\"address\"},{\"name\":\"_secretHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rf\",\"type\":\"address\"}],\"name\":\"RFDeclare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rf\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fstkRevenue\",\"type\":\"uint256\"}],\"name\":\"Finalize\",\"type\":\"event\"}]","ContractName":"FSTSaleServiceWindowReferral","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000216a774d40296b54d95352ce5b0460343b7d199856b1290c724c05a040cb1531116624a3cb0f708f61db9dcb8e2195c49ec0548","Library":"","SwarmSource":"bzzr://f91e22881e043c9ae5e51dcb85eaf80ccf73cfea4dc14e7ac0ee1db4bfc6d5b4"}]}