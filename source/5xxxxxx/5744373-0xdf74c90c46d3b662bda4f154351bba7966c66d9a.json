{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n// File: contracts/ACOTokenCrowdsale.sol\r\n\r\ninterface ACOTokenCrowdsale {\r\n    function buyTokens(address beneficiary) external payable;\r\n    function hasEnded() external view returns (bool);\r\n}\r\n\r\n// File: contracts/lib/DS-Math.sol\r\n\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.4.23;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    // function max(uint x, uint y) internal pure returns (uint z) {\r\n    //     return x >= y ? x : y;\r\n    // }\r\n    // function imin(int x, int y) internal pure returns (int z) {\r\n    //     return x <= y ? x : y;\r\n    // }\r\n    // function imax(int x, int y) internal pure returns (int z) {\r\n    //     return x >= y ? x : y;\r\n    // }\r\n\r\n    // uint constant WAD = 10 ** 18;\r\n    // uint constant RAY = 10 ** 27;\r\n\r\n    // function wmul(uint x, uint y) internal pure returns (uint z) {\r\n    //     z = add(mul(x, y), WAD / 2) / WAD;\r\n    // }\r\n    // function rmul(uint x, uint y) internal pure returns (uint z) {\r\n    //     z = add(mul(x, y), RAY / 2) / RAY;\r\n    // }\r\n    // function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n    //     z = add(mul(x, WAD), y / 2) / y;\r\n    // }\r\n    // function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n    //     z = add(mul(x, RAY), y / 2) / y;\r\n    // }\r\n\r\n    // // This famous algorithm is called \"exponentiation by squaring\"\r\n    // // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    // //\r\n    // // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    // //\r\n    // // These facts are why it works:\r\n    // //\r\n    // //  If n is even, then x^n = (x^2)^(n/2).\r\n    // //  If n is odd,  then x^n = x * x^(n-1),\r\n    // //   and applying the equation for even x gives\r\n    // //    x^n = x * (x^2)^((n-1) / 2).\r\n    // //\r\n    // //  Also, EVM division is flooring and\r\n    // //    floor[(n-1) / 2] = floor[n / 2].\r\n    // //\r\n    // function rpow(uint x, uint n) internal pure returns (uint z) {\r\n    //     z = n % 2 != 0 ? x : RAY;\r\n\r\n    //     for (n /= 2; n != 0; n /= 2) {\r\n    //         x = rmul(x, x);\r\n\r\n    //         if (n % 2 != 0) {\r\n    //             z = rmul(z, x);\r\n    //         }\r\n    //     }\r\n    // }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/TokenDestructible.sol\r\n\r\n/**\r\n * @title TokenDestructible:\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev Base contract that can be destroyed by owner. All funds in contract including\r\n * listed tokens will be sent to the owner.\r\n */\r\ncontract TokenDestructible is Ownable {\r\n\r\n  constructor() public payable { }\r\n\r\n  /**\r\n   * @notice Terminate contract and refund to owner\r\n   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to\r\n   refund.\r\n   * @notice The called token contracts could try to re-enter this contract. Only\r\n   supply token contracts you trust.\r\n   */\r\n  function destroy(address[] tokens) onlyOwner public {\r\n\r\n    // Transfer tokens to owner\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      ERC20Basic token = ERC20Basic(tokens[i]);\r\n      uint256 balance = token.balanceOf(this);\r\n      token.transfer(owner, balance);\r\n    }\r\n\r\n    // Transfer Eth to owner and terminate contract\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: contracts/TokenBuy.sol\r\n\r\n/// @title Group-buy contract for Token ICO\r\n/// @author Joe Wasson\r\n/// @notice Allows for group purchase of the Token ICO. This is done\r\n///   in two phases:\r\n///     a) contributions initiate a purchase on demand.\r\n///     b) tokens are collected when they are unfrozen\r\ncontract TokenBuy is Pausable, Claimable, TokenDestructible, DSMath {\r\n    using SafeERC20 for ERC20Basic;\r\n\r\n    /// @notice Token ICO contract\r\n    ACOTokenCrowdsale public crowdsaleContract;\r\n\r\n    /// @notice Token contract\r\n    ERC20Basic public tokenContract;\r\n\r\n    /// @notice Map of contributors and their token balances\r\n    mapping(address => uint) public balances;\r\n\r\n    /// @notice List of contributors to the sale\r\n    address[] public contributors;\r\n\r\n    /// @notice Total amount contributed to the sale\r\n    uint public totalContributions;\r\n\r\n    /// @notice Total number of tokens purchased\r\n    uint public totalTokensPurchased;\r\n\r\n    /// @notice Emitted whenever a contribution is made\r\n    event Purchase(address indexed sender, uint ethAmount, uint tokensPurchased);\r\n\r\n    /// @notice Emitted whenever tokens are collected fromthe contract\r\n    event Collection(address indexed recipient, uint amount);\r\n\r\n    /// @notice Time when locked funds in the contract can be retrieved.\r\n    uint constant unlockTime = 1543622400; // 2018-12-01 00:00:00 GMT\r\n\r\n    /// @notice Guards against executing the function if the sale\r\n    ///    is not running.\r\n    modifier whenSaleRunning() {\r\n        require(!crowdsaleContract.hasEnded());\r\n        _;\r\n    }\r\n\r\n    /// @param crowdsale the Crowdsale contract (or a wrapper around it)\r\n    /// @param token the token contract\r\n    constructor(ACOTokenCrowdsale crowdsale, ERC20Basic token) public {\r\n        require(crowdsale != address(0x0));\r\n        require(token != address(0x0));\r\n        crowdsaleContract = crowdsale;\r\n        tokenContract = token;\r\n    }\r\n\r\n    /// @notice returns the number of contributors in the list of contributors\r\n    /// @return count of contributors\r\n    /// @dev As the `collectAll` function is called the contributor array is cleaned up\r\n    ///     consequently this method only returns the remaining contributor count.\r\n    function contributorCount() public view returns (uint) {\r\n        return contributors.length;\r\n    }\r\n\r\n    /// @dev Dispatches between buying and collecting\r\n    function() public payable {\r\n        if (msg.value == 0) {\r\n            collectFor(msg.sender);\r\n        } else {\r\n            buy();\r\n        }\r\n    }\r\n\r\n    /// @notice Executes a purchase.\r\n    function buy() whenNotPaused whenSaleRunning private {\r\n        address buyer = msg.sender;\r\n        totalContributions += msg.value;\r\n        uint tokensPurchased = purchaseTokens();\r\n        totalTokensPurchased = add(totalTokensPurchased, tokensPurchased);\r\n\r\n        uint previousBalance = balances[buyer];\r\n        balances[buyer] = add(previousBalance, tokensPurchased);\r\n\r\n        // new contributor\r\n        if (previousBalance == 0) {\r\n            contributors.push(buyer);\r\n        }\r\n\r\n        emit Purchase(buyer, msg.value, tokensPurchased);\r\n    }\r\n\r\n    function purchaseTokens() private returns (uint tokensPurchased) {\r\n        address me = address(this);\r\n        uint previousBalance = tokenContract.balanceOf(me);\r\n        crowdsaleContract.buyTokens.value(msg.value)(me);\r\n        uint newBalance = tokenContract.balanceOf(me);\r\n\r\n        require(newBalance > previousBalance); // Fail on underflow or purchase of 0\r\n        return newBalance - previousBalance;\r\n    }\r\n\r\n    /// @notice Allows users to collect purchased tokens after the sale.\r\n    /// @param recipient the address to collect tokens for\r\n    /// @dev Here we don't transfer zero tokens but this is an arbitrary decision.\r\n    function collectFor(address recipient) private {\r\n        uint tokensOwned = balances[recipient];\r\n        if (tokensOwned == 0) return;\r\n\r\n        delete balances[recipient];\r\n        tokenContract.safeTransfer(recipient, tokensOwned);\r\n        emit Collection(recipient, tokensOwned);\r\n    }\r\n\r\n    /// @notice Collects the balances for members of the purchase\r\n    /// @param max the maximum number of members to process (for gas purposes)\r\n    function collectAll(uint8 max) public returns (uint8 collected) {\r\n        max = uint8(min(max, contributors.length));\r\n        require(max > 0, \"can't collect for zero users\");\r\n\r\n        uint index = contributors.length - 1;\r\n        for(uint offset = 0; offset < max; ++offset) {\r\n            address recipient = contributors[index - offset];\r\n\r\n            if (balances[recipient] > 0) {\r\n                collected++;\r\n                collectFor(recipient);\r\n            }\r\n        }\r\n\r\n        contributors.length -= offset;\r\n    }\r\n\r\n    /// @notice Shuts down the contract\r\n    function destroy(address[] tokens) onlyOwner public {\r\n        require(now > unlockTime || (contributorCount() == 0 && paused));\r\n\r\n        super.destroy(tokens);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensPurchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"max\",\"type\":\"uint8\"}],\"name\":\"collectAll\",\"outputs\":[{\"name\":\"collected\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"crowdsale\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensPurchased\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Collection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenBuy","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000025beb989d3ef4e6e0fef8220944bb74e2aa6ff450000000000000000000000005e888b83b7287eed4fb7da7b7d0a0d4c735d94b3","Library":"","SwarmSource":"bzzr://dcc951eb25fd1c683b968c89796ff78a2bc49a2ca7475eae2bae264445d0a25a"}]}