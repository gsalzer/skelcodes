{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n//\r\n/* CONTRACT */\r\n\r\ncontract SafeMath {\r\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n// END_OF_contract_SafeMath\r\n//_________________________________________________________\r\n//\r\n/* INTERFACES */\r\n//\r\ninterface tokenRecipient {\r\n\t\r\n\tfunction receiveApproval(address _from, uint256 _tokenAmountApproved, address tokenMacroansy, bytes _extraData) public returns(bool success); \r\n}   \r\n//________________________________________________________\r\n//\r\n    interface ICO {\r\n\r\n        function buy( uint payment, address buyer, bool isPreview) public returns(bool success, uint amount, uint retPayment);\r\n        function redeemCoin(uint256 amount, address redeemer, bool isPreview) public returns (bool success, uint redeemPayment);\r\n        function sell(uint256 amount, address seller, bool isPreview) public returns (bool success, uint sellPayment );\r\n        function paymentAction(uint paymentValue, address beneficiary, uint paytype) public returns(bool success);\r\n\r\n        function recvShrICO( address _spender, uint256 _value, uint ShrID)  public returns (bool success);\r\n        function burn( uint256 value, bool unburn, uint totalSupplyStart, uint balOfOwner)  public returns( bool success);\r\n\r\n        function getSCF() public returns(uint seriesCapFactorMulByTenPowerEighteen);\r\n        function getMinBal() public returns(uint minBalForAccnts_ );\r\n        function getAvlShares(bool show) public  returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding);\r\n    }\r\n//_________________________________________________________\r\n//\r\n    interface Exchg{\r\n        \r\n        function sell_Exchg_Reg( uint amntTkns, uint tknPrice, address seller) public returns(bool success);\r\n        function buy_Exchg_booking( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment ) public returns(bool success);\r\n        function buy_Exchg_BkgChk( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment) public returns(bool success);\r\n        function updateSeller( address seller, uint tknsApr, address buyer, uint payment) public returns(bool success);  \r\n\r\n        function getExchgComisnMulByThousand() public returns(uint exchgCommissionMulByThousand_);  \r\n\r\n  \t    function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_);\r\n\r\n    }\r\n//_________________________________________________________\r\n//\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n\r\n/* CONTRACT */\r\n//\r\n    contract TokenERC20Interface {\r\n\r\n        function totalSupply() public constant returns (uint coinLifeTimeTotalSupply);\r\n        function balanceOf(address tokenOwner) public constant returns (uint coinBalance);\r\n        function allowance(address tokenOwner, address spender) public constant returns (uint coinsRemaining);\r\n        function transfer(address to, uint tokens) public returns (bool success);\r\n        function approve(address spender, uint tokens) public returns (bool success);\r\n        function transferFrom(address _from, address to, uint tokens) public returns (bool success);\r\n        event Transfer(address indexed _from, address indexed to, uint tokens);\r\n        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    }\r\n//END_OF_contract_ERC20Interface \r\n//_________________________________________________________________\r\n/* CONTRACT */\r\n/**\r\n* COPYRIGHT Macroansy \r\n* http://www.macroansy.org\r\n*/\r\ncontract TokenMacroansyPower is TokenERC20Interface, SafeMath { \r\n    \r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 3;\r\n    //\r\n    address internal owner; \r\n    address private  beneficiaryFunds;\r\n    //\r\n    uint256 public totalSupply;\r\n    uint256 internal totalSupplyStart;\r\n    //\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    mapping( address => bool) internal frozenAccount;\r\n    //\r\n    mapping(address => uint) private msgSndr;\r\n    //\r\n    address internal tkn_addr; address internal ico_addr; address internal exchg_addr;\r\n    address internal cs_addr;  \r\n    //\r\n    uint256 internal allowedIndividualShare;\r\n    uint256 internal allowedPublicShare;\r\n    //\r\n    bool public crowdSaleOpen;\r\n//_________________________________________________________\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);    \r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn);\r\n    event FundOrPaymentTransfer(address beneficiary, uint amount); \r\n    // event FrozenFunds(address target, bool frozen);\r\n    //event BuyAtMacroansyExchg(address buyer, address seller, uint tokenAmount, uint payment);\r\n//_________________________________________________________\r\n//\r\n//CONSTRUCTOR\r\n    /* Initializes contract with initial supply tokens to the creator of the contract \r\n    */\r\n    function TokenMacroansyPower()  public {\r\n        \r\n        owner = msg.sender;\r\n        beneficiaryFunds = owner; \r\n        totalSupplyStart = 270000000 * 10** uint256(decimals);     \r\n        totalSupply = totalSupplyStart; \r\n        //\r\n        balanceOf[msg.sender] = totalSupplyStart;    \r\n        Transfer(address(0), msg.sender, totalSupplyStart);\r\n        //                 \r\n        name = \"TokenMacroansyPower\";  \r\n        symbol = \"$BEEPower\";\r\n        //  \r\n        allowedIndividualShare = uint(1)*totalSupplyStart/100; \r\n        allowedPublicShare = uint(20)* totalSupplyStart/100;     \r\n        //\r\n        crowdSaleOpen = false;\r\n    } \r\n//_________________________________________________________\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    } \r\n    function transferOr(address _Or) public onlyOwner {\r\n        owner = _Or;\r\n    }          \r\n//_________________________________________________________\r\n   /**\r\n     * @notice Show the `totalSupply` for this Token contract\r\n     */\r\n    function totalSupply() constant public returns (uint coinLifeTimeTotalSupply) {\r\n        return totalSupply ;   \r\n    }  \r\n//_________________________________________________________\r\n   /**\r\n     * @notice Show the `tokenOwner` balances for this contract\r\n     * @param tokenOwner the token owners address\r\n     */\r\n    function balanceOf(address tokenOwner) constant public  returns (uint coinBalance) {\r\n        return balanceOf[tokenOwner];\r\n    } \r\n//_________________________________________________________\r\n   /**\r\n     * @notice Show the allowance given by `tokenOwner` to the `spender`\r\n     * @param tokenOwner the token owner address allocating allowance\r\n     * @param spender the allowance spenders address\r\n     */\r\n    function allowance(address tokenOwner, address spender) constant public returns (uint coinsRemaining) {\r\n        return allowance[tokenOwner][spender];\r\n    }\r\n//_________________________________________________________\r\n//\r\n    function setContrAddrAndCrwSale(bool setAddress,  address icoAddr, address exchAddr, address csAddr, bool setCrowdSale, bool crowdSaleOpen_ ) public onlyOwner returns(bool success){\r\n\r\n       if(setAddress == true){\r\n       \t\tico_addr = icoAddr; exchg_addr = exchAddr; cs_addr = csAddr;       \t\t\r\n       }\r\n       //\r\n       if( setCrowdSale == true )crowdSaleOpen = crowdSaleOpen_;\r\n       \r\n       return true;   \r\n    }          \r\n    //\r\n    function _getIcoAddr() internal  returns(address ico_ma_addr){  return(ico_addr); } \r\n    function _getExchgAddr() internal returns(address exchg_ma_addr){ return(exchg_addr); } \r\n    function _getCsAddr() internal returns(address cs_ma_addr){ return(cs_addr); } \r\n//_________________________________________________________\r\n//\r\n    /* Internal transfer, only can be called by this contract */\r\n    //\r\n    function _transfer(address _from, address _to, uint _value) internal  {\r\n        require (_to != 0x0);                                       \r\n        require(!frozenAccount[_from]);                             \r\n        require(!frozenAccount[_to]);                               \r\n        uint valtmp = _value;\r\n        uint _valueA = valtmp;\r\n        valtmp = 0;                       \r\n        require (balanceOf[_from] >= _valueA);                       \r\n        require (balanceOf[_to] + _valueA > balanceOf[_to]);                   \r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];                               \r\n        balanceOf[_from] = safeSub(balanceOf[_from], _valueA);                                  \r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _valueA); \r\n        Transfer(_from, _to, _valueA);\r\n        _valueA = 0;\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);       \r\n    }\r\n//________________________________________________________\r\n    /**\r\n     * Transfer tokens\r\n     */\r\n     function transfer(address _to, uint256 _value) public returns(bool success) {\r\n\r\n        //check sender and receiver allw limits in accordance with ico contract\r\n        if(msg.sender != owner){\r\n\t        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);    \r\n\t        bool sucsByrLmt = _chkBuyerLmts( _to, _value);\r\n\t        require(sucsSlrLmt == true && sucsByrLmt == true);\r\n        }\r\n        //\r\n        uint valtmp = _value;    \r\n        uint _valueTemp = valtmp; \r\n        valtmp = 0;                 \r\n        _transfer(msg.sender, _to, _valueTemp);\r\n        _valueTemp = 0;\r\n        return true;      \r\n    }  \r\n//_________________________________________________________\r\n    /**\r\n     * Transfer tokens from other address\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        \r\n        uint valtmp = _value;\r\n        uint _valueA = valtmp;\r\n        valtmp = 0;\r\n        require(_valueA <= allowance[_from][msg.sender]);     \r\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _valueA);\r\n        _transfer(_from, _to, _valueA);\r\n        _valueA = 0;\r\n        return true;\r\n    }\r\n//_________________________________________________________\r\n    /**\r\n     * Set allowance for other address\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        \r\n        //check sender and receiver allw limits in accordance with ico contract\r\n        if(msg.sender != owner){\r\n\t        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);          \r\n\t        bool sucsByrLmt = _chkBuyerLmts( _spender, _value);\r\n\t        require(sucsSlrLmt == true && sucsByrLmt == true);\r\n        }\r\n        //\r\n        uint valtmp = _value;\r\n        uint _valueA = valtmp;\r\n        valtmp = 0;         \r\n        allowance[msg.sender][_spender] = _valueA;\r\n        Approval(msg.sender, _spender, _valueA);\r\n         _valueA =0;\r\n        return true;\r\n    }\r\n//_________________________________________________________\r\n    /**\r\n     * Set allowance for other address and notify\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        \r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        uint valtmp = _value;\r\n        uint _valueA = valtmp;\r\n        valtmp = 0;         \r\n        if (approve(_spender, _valueA)) {           \r\n            spender.receiveApproval(msg.sender, _valueA, this, _extraData);            \r\n        }\r\n        _valueA = 0; \r\n        return true;\r\n    }\r\n//_________________________________________________________\r\n//\r\n    function freezeAccount(address target, bool freeze) onlyOwner public returns(bool success) {\r\n        frozenAccount[target] = freeze;      \r\n        //FrozenFunds(target, freeze);\r\n        return true;\r\n    }\r\n//________________________________________________________\r\n//\r\n    function _safeTransferTkn( address _from, address _to, uint amount) internal returns(bool sucsTrTk){\r\n          \r\n          uint tkA = amount;\r\n          uint tkAtemp = tkA;\r\n          tkA = 0;\r\n                   _transfer(_from, _to, tkAtemp); \r\n          tkAtemp = 0;\r\n          return true;\r\n    }      \r\n//_________________________________________________________\r\n//\r\n    function _safeTransferPaymnt( address paymentBenfcry, uint payment) internal returns(bool sucsTrPaymnt){\r\n              \r\n          uint pA = payment; \r\n          uint paymentTemp = pA;\r\n          pA = 0;\r\n                  paymentBenfcry.transfer(paymentTemp); \r\n          FundOrPaymentTransfer(paymentBenfcry, paymentTemp);                       \r\n          paymentTemp = 0; \r\n          \r\n          return true;\r\n    }\r\n//_________________________________________________________\r\n//\r\n    function _safePaymentActionAtIco( uint payment, address paymentBenfcry, uint paytype) internal returns(bool success){\r\n              \r\n    // payment req to ico\r\n          uint Pm = payment;\r\n          uint PmTemp = Pm;\r\n          Pm = 0;  \r\n          ICO ico = ICO(_getIcoAddr());       \r\n          // paytype 1 for redeempayment and 2 for sell payment\r\n          bool pymActSucs = ico.paymentAction( PmTemp, paymentBenfcry, paytype);\r\n          require(pymActSucs ==  true);\r\n          PmTemp = 0;\r\n          \r\n          return true;\r\n    }\r\n//_____________________________________________________________\r\n//\r\n\r\n\tfunction buyCoinsCrowdSale(address buyer, uint payment, address crowdSaleContr) public returns(bool success, uint retPayment) { \r\n\t\t\r\n\t\trequire(crowdSaleOpen == true && crowdSaleContr == _getCsAddr());\r\n\r\n\t\tsuccess = false;\r\n\t\t(success , retPayment) = _buyCoins( buyer, payment);\r\n\t\trequire(success == true);\r\n\t\treturn (success, retPayment);\r\n\t}\r\n//_____________________________________________________________\r\n//\r\n    function _buyCoins(address buyer, uint payment) internal returns(bool success, uint retPayment) { \r\n\r\n        msgSndr[buyer] = payment;\r\n\r\n        ICO ico = ICO(_getIcoAddr() );\r\n\r\n        require(  payment > 0 );\r\n        \r\n        bool icosuccess;  uint tknsBuyAppr;  \r\n        (icosuccess, tknsBuyAppr, retPayment ) = ico.buy( payment, buyer, false);         \r\n        require( icosuccess == true );\r\n        \r\n        if(crowdSaleOpen == false) {\r\n        // return payment to buyer \r\n\t        if( retPayment > 0 ) {\r\n\t                \r\n\t          bool sucsTrPaymnt;\r\n\t          sucsTrPaymnt = _safeTransferPaymnt( buyer, retPayment );\r\n\t          require(sucsTrPaymnt == true );\r\n\t        }\r\n        }\r\n        // tkn transfer\r\n        bool sucsTrTk =  _safeTransferTkn( owner, buyer, tknsBuyAppr);\r\n        require(sucsTrTk == true);\r\n\r\n        msgSndr[buyer] = 0;\r\n\r\n        return (true, retPayment);\r\n    }   \r\n//_____________________________________________________________\r\n  \r\n    function redeemOrSellCoinsToICO(uint enter1forRedeemOR2forSell, uint256 amountOfCoinPartsToRedeemOrSell) public returns (bool success ) {\r\n\r\n    require(crowdSaleOpen == false);\r\n\r\n    uint amount = amountOfCoinPartsToRedeemOrSell;\r\n\r\n    msgSndr[msg.sender] = amount;  \r\n      bool isPreview = false;\r\n\r\n      ICO ico = ICO(_getIcoAddr());\r\n\r\n      // redeem exe at ico\r\n        bool icosuccess ; uint redeemOrSellPaymentValue;\r\n      \r\n\t      if(enter1forRedeemOR2forSell == 1){\r\n\r\n\t      \t(icosuccess , redeemOrSellPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview);\r\n\t      }\r\n\t      if(enter1forRedeemOR2forSell == 2){\r\n\r\n\t      \t(icosuccess , redeemOrSellPaymentValue) = ico.sell( amount, msg.sender, isPreview);\r\n\t      }\t      \r\n\r\n      require( icosuccess == true);  \r\n\r\n        require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemOrSellPaymentValue) );\r\n\r\n      bool sucsTrTk = false; bool pymActSucs = false;\r\n      if(isPreview == false) {\r\n\r\n        // transfer tkns\r\n        sucsTrTk =  _safeTransferTkn( msg.sender, owner, amount);\r\n        require(sucsTrTk == true);        \r\n\r\n        // payment req to ico  1 for redeempayment and 2 for sell payment         \r\n      msgSndr[msg.sender] = redeemOrSellPaymentValue;\r\n        pymActSucs = _safePaymentActionAtIco( redeemOrSellPaymentValue, msg.sender, enter1forRedeemOR2forSell);\r\n        require(pymActSucs ==  true);\r\n      } \r\n     \r\n    msgSndr[msg.sender] = 0;  \r\n\r\n      return (true);        \r\n    } \r\n//________________________________________________________\r\n\r\n    function _chkSellerLmts( address seller, uint amountOfCoinsSellerCanSell) internal returns(bool success){   \r\n\r\n      uint amountTkns = amountOfCoinsSellerCanSell; \r\n      success = false;\r\n      ICO ico = ICO( _getIcoAddr() );\r\n      uint seriesCapFactor = ico.getSCF();\r\n      \r\n\t      if( amountTkns <= balanceOf[seller]  &&  balanceOf[seller] <=  safeDiv(allowedIndividualShare*seriesCapFactor,10**18) ){\r\n\t        success = true;\r\n\t      }\r\n\r\n      return success;\r\n    }\r\n    // bool sucsSlrLmt = _chkSellerLmts( address seller, uint amountTkns);\r\n//_________________________________________________________    \r\n//\r\n    function _chkBuyerLmts( address buyer, uint amountOfCoinsBuyerCanBuy)  internal  returns(bool success){\r\n\r\n    \tuint amountTkns = amountOfCoinsBuyerCanBuy;\r\n        success = false;\r\n        ICO ico = ICO( _getIcoAddr() );\r\n        uint seriesCapFactor = ico.getSCF();\r\n\r\n\t        if( amountTkns <= safeSub( safeDiv(allowedIndividualShare*seriesCapFactor,10**18), balanceOf[buyer] )) {\r\n\t          success = true;\r\n\t        } \r\n\r\n        return success;        \r\n    }\r\n//_________________________________________________________\r\n//\r\n    function _chkBuyerLmtsAndFinl( address buyer, uint amountTkns, uint priceOfr) internal returns(bool success){\r\n       \r\n       success = false;\r\n\r\n      // buyer limits\r\n       bool sucs1 = false; \r\n       sucs1 = _chkBuyerLmts( buyer, amountTkns);\r\n\r\n      // buyer funds\r\n       ICO ico = ICO( _getIcoAddr() );\r\n       bool sucs2 = false;\r\n       if( buyer.balance >=  safeAdd( safeMul(amountTkns , priceOfr) , ico.getMinBal() )  )  sucs2 = true;\r\n       if( sucs1 == true && sucs2 == true)  success = true;   \r\n\r\n       return success;\r\n    }\r\n//_________________________________________________________\r\n//\r\n     function _slrByrLmtChk( address seller, uint amountTkns, uint priceOfr, address buyer) internal returns(bool success){\r\n     \r\n      // seller limits check\r\n        bool successSlrl; \r\n        (successSlrl) = _chkSellerLmts( seller, amountTkns); \r\n\r\n      // buyer limits check\r\n        bool successByrlAFinl;\r\n        (successByrlAFinl) = _chkBuyerLmtsAndFinl( buyer, amountTkns, priceOfr);\r\n        \r\n        require( successSlrl == true && successByrlAFinl == true);\r\n\r\n        return true;\r\n    }\r\n//___________________________________________________________\r\n\r\n    function () public payable {\r\n       \r\n        if(msg.sender != owner){\r\n\r\n            require(crowdSaleOpen == false);\r\n            bool success = false;\r\n            uint retPayment;\r\n\t\t\t(success , retPayment) = _buyCoins( msg.sender, msg.value);\r\n\t\t\trequire(success == true);    \r\n        }\r\n    }\r\n//_________________________________________________________\r\n\r\n\t\t    function burn( uint256 value, bool unburn) onlyOwner public returns( bool success ) { \r\n\r\n\t\t    \trequire(crowdSaleOpen == false);\r\n\r\n\t\t        msgSndr[msg.sender] = value;\r\n\t\t         ICO ico = ICO( _getIcoAddr() );\r\n\t\t            if( unburn == false) {\r\n\r\n\t\t                balanceOf[owner] = safeSub( balanceOf[owner] , value);\r\n\t\t                totalSupply = safeSub( totalSupply, value);\r\n\t\t                BurnOrUnBurn(owner, value, 1);\r\n\r\n\t\t            }\r\n\t\t            if( unburn == true) {\r\n\r\n\t\t                balanceOf[owner] = safeAdd( balanceOf[owner] , value);\r\n\t\t                totalSupply = safeAdd( totalSupply , value);\r\n\t\t                BurnOrUnBurn(owner, value, 2);\r\n\r\n\t\t            }\r\n\t\t        \r\n\t\t        bool icosuccess = ico.burn( value, unburn, totalSupplyStart, balanceOf[owner] );\r\n\t\t        require( icosuccess == true);             \r\n\t\t        \r\n\t\t        return true;   \r\n\t                    \r\n           }\r\n//_________________________________________________________\r\n\r\n    function withdrawFund(uint withdrawAmount) onlyOwner public returns(bool success) {\r\n      \r\n        success = _withdraw(withdrawAmount);          \r\n        return success;      \r\n    }   \r\n//_________________________________________________________\r\n\r\n    function _withdraw(uint _withdrawAmount) internal returns(bool success) {\r\n\r\n        bool sucsTrPaymnt = _safeTransferPaymnt( beneficiaryFunds, _withdrawAmount); \r\n        require(sucsTrPaymnt == true);         \r\n        return true;     \r\n    }\r\n//_________________________________________________________\r\n\r\n    function receiveICOcoins( uint256 amountOfCoinsToReceive, uint ShrID )  public returns (bool success){ \r\n\r\n      require(crowdSaleOpen == false);\r\n\r\n      msgSndr[msg.sender] = amountOfCoinsToReceive;\r\n        ICO ico = ICO( _getIcoAddr() );\r\n        bool  icosuccess;  \r\n        icosuccess = ico.recvShrICO(msg.sender, amountOfCoinsToReceive, ShrID ); \r\n        require (icosuccess == true);\r\n\r\n        bool sucsTrTk;\r\n        sucsTrTk =  _safeTransferTkn( owner, msg.sender, amountOfCoinsToReceive);\r\n        require(sucsTrTk == true);\r\n\r\n      msgSndr[msg.sender] = 0;\r\n\r\n        return  true;\r\n    }\r\n//___________________________________________________________________\r\n\r\n      function sellBkgAtExchg( uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) public returns(bool success){\r\n        \r\n        require(crowdSaleOpen == false);\r\n\r\n        uint amntTkns = sellerCoinPartsForSale;\r\n        uint tknPrice = sellerPricePerCoinPartInWEI;\r\n      \r\n        // seller limits\r\n        bool successSlrl;\r\n        (successSlrl) = _chkSellerLmts( msg.sender, amntTkns); \r\n        require(successSlrl == true);\r\n\r\n      msgSndr[msg.sender] = amntTkns;  \r\n\r\n      // bkg registration at exchange\r\n\r\n        Exchg em = Exchg(_getExchgAddr());\r\n\r\n        bool  emsuccess; \r\n        (emsuccess) = em.sell_Exchg_Reg( amntTkns, tknPrice, msg.sender );\r\n        require(emsuccess == true );\r\n            \r\n      msgSndr[msg.sender] = 0;\r\n\r\n        return true;         \r\n    }\r\n//_________________________________________________________ \r\n//     \r\n      function buyBkgAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI, uint myProposedPaymentInWEI) public returns(bool success){ \r\n\r\n        require(crowdSaleOpen == false);\r\n\r\n        uint amountTkns = sellerCoinPartsForSale;\r\n        uint priceOfr = sellerPricePerCoinPartInWEI;\r\n        uint payment = myProposedPaymentInWEI;   \r\n\r\n\t\t// calc tokens that can be bought         \r\n        uint tknsBuyAppr = 0;    \r\n        if( amountTkns > 2 &&  payment >=  (2 * priceOfr) &&  payment <= (amountTkns * priceOfr) ) {\r\n\r\n        \ttknsBuyAppr = safeDiv( payment , priceOfr );\r\n        }\r\n        require(tknsBuyAppr > 0);\r\n\r\n      msgSndr[msg.sender] = amountTkns;\r\n\r\n        // seller buyer limits check\r\n        bool sucsLmt = _slrByrLmtChk( seller, amountTkns, priceOfr, msg.sender);\r\n        require(sucsLmt == true);\r\n\r\n        // booking at exchange\r\n     \r\n        Exchg em = Exchg(_getExchgAddr()); \r\n\r\n        bool emBkgsuccess;\r\n        (emBkgsuccess)= em.buy_Exchg_booking( seller, amountTkns, priceOfr, msg.sender, payment);\r\n            require( emBkgsuccess == true );\r\n\r\n      msgSndr[msg.sender] = 0;  \r\n\r\n        return true;        \r\n    }\r\n//________________________________________________________\r\n\r\n    function buyCoinsAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) payable public returns(bool success) {\r\n        \r\n        require(crowdSaleOpen == false);\r\n\r\n        uint amountTkns = sellerCoinPartsForSale;\r\n        uint priceOfr = sellerPricePerCoinPartInWEI;\t  \r\n\t\t\r\n\t\t// calc tokens that can be bought         \r\n        uint tknsBuyAppr = 0;  // this var as used as the indicator to update buyerbkg and seller update for ok or no txn.\r\n\r\n        if( amountTkns > 2 &&  msg.value >=  (2 * priceOfr) &&  msg.value <= (amountTkns * priceOfr) ) {\r\n\r\n        \ttknsBuyAppr = safeDiv( msg.value , priceOfr );\r\n        }\r\n        // calc return payment to buyer\r\n        uint retPayment = 0;\r\n        if(  msg.value > 0 ){\r\n            retPayment = safeSub( msg.value , tknsBuyAppr * priceOfr);\r\n        }\r\n\r\n      msgSndr[msg.sender] = amountTkns;               \r\n        \r\n        // check buyer booking at exchange\r\n        Exchg em = Exchg(_getExchgAddr()); \r\n\r\n        bool sucsBkgChk = false;\r\n        if(tknsBuyAppr > 0){\r\n\t        sucsBkgChk = em.buy_Exchg_BkgChk(seller, amountTkns, priceOfr, msg.sender, msg.value); \r\n        }\r\n        if(sucsBkgChk == false) tknsBuyAppr = 0;\r\n        //\r\n\r\n\t\t\tmsgSndr[msg.sender] = tknsBuyAppr;  \r\n \r\n        \tbool emUpdateSuccess;\r\n       \t\t(emUpdateSuccess) = em.updateSeller(seller, tknsBuyAppr, msg.sender, msg.value); \r\n        \trequire( emUpdateSuccess == true );\r\n        \r\n        //\r\n        if(sucsBkgChk == true && tknsBuyAppr > 0){\r\n      \r\n\t       // token transfer in this token contract\r\n\r\n\t        bool sucsTrTkn = _safeTransferTkn( seller, msg.sender, tknsBuyAppr);\r\n\t        require(sucsTrTkn == true);\r\n\r\n\t        // payment to seller        \r\n\t        bool sucsTrPaymnt;\r\n\t        sucsTrPaymnt = _safeTransferPaymnt( seller,  safeSub( msg.value , safeDiv(msg.value*em.getExchgComisnMulByThousand(),1000) ) );\r\n\t        require(sucsTrPaymnt == true );        \r\n        }\r\n    \t// return payment to buyer \r\n        if( retPayment > 0 ) {\r\n                \r\n          bool sucsTrRetPaymnt;\r\n          sucsTrRetPaymnt = _safeTransferPaymnt( msg.sender, retPayment );\r\n          require(sucsTrRetPaymnt == true );\r\n        }         \r\n      msgSndr[msg.sender] = 0; \r\n        \r\n        return true;\r\n    } \r\n//_______________________________________________________\r\n//  called by other contracts\r\n    function sendMsgSndr(address caller, address origin) public returns(bool success, uint value){\r\n        \r\n        (success, value) = _sendMsgSndr(caller, origin);        \r\n         return(success, value);  \r\n    }\r\n//_______________________________________________________\r\n//\r\n    function _sendMsgSndr(address caller,  address origin) internal returns(bool success, uint value){ \r\n       \r\n        require( caller == _getIcoAddr() || caller == _getExchgAddr() || caller == _getCsAddr() ); \r\n          //require(origin == tx.origin);          \r\n        return(true, msgSndr[origin]);  \r\n    }\r\n//_________________________________________________________\r\n//\r\n    function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime){\r\n\r\n      if(show == true){\r\n\r\n        Exchg em = Exchg(_getExchgAddr()); \r\n       \r\n        ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, ) = em.viewSellOffersAtExchangeMacroansy( seller, show) ; \r\n\r\n        return ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime);\r\n      }\r\n    }\r\n//_________________________________________________________\r\n//\r\n\t\tfunction viewCoinSupplyAndFunding(bool show) public view returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding){\r\n\r\n\t\t    if(show == true){\r\n\t\t      ICO ico = ICO( _getIcoAddr() );\r\n\r\n\t\t      ( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding) = ico.getAvlShares(show);\r\n\r\n\t\t      return( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding);\r\n\t\t    }\r\n\t\t}\r\n//_________________________________________________________\r\n//\r\n/*    \t\t\t\r\n\t\t\tbool private isEndOk;\r\n\t\t\t\tfunction endOfRewards(bool isEndNow) public onlyOwner {\r\n\r\n\t\t\t\t\t\tisEndOk == isEndNow;\r\n\t\t\t\t}\r\n\t\t\t\tfunction endOfRewardsConfirmed(bool isEndNow) public onlyOwner{\r\n\r\n\t\t\t\t\tif(isEndOk == true && isEndNow == true) selfdestruct(owner);\r\n\t\t\t\t}\r\n*/\t\t\t\r\n//_______________________________________________________\r\n}\r\n// END_OF_CONTRACT","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"sellerCoinPartsForSale\",\"type\":\"uint256\"},{\"name\":\"sellerPricePerCoinPartInWEI\",\"type\":\"uint256\"},{\"name\":\"myProposedPaymentInWEI\",\"type\":\"uint256\"}],\"name\":\"buyBkgAtExchg\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"sellerCoinPartsForSale\",\"type\":\"uint256\"},{\"name\":\"sellerPricePerCoinPartInWEI\",\"type\":\"uint256\"}],\"name\":\"buyCoinsAtExchg\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFund\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfCoinsToReceive\",\"type\":\"uint256\"},{\"name\":\"ShrID\",\"type\":\"uint256\"}],\"name\":\"receiveICOcoins\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"coinLifeTimeTotalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"caller\",\"type\":\"address\"},{\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"sendMsgSndr\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"show\",\"type\":\"bool\"}],\"name\":\"viewCoinSupplyAndFunding\",\"outputs\":[{\"name\":\"totalSupplyOfCoinsInSeriesNow\",\"type\":\"uint256\"},{\"name\":\"coinsAvailableForSale\",\"type\":\"uint256\"},{\"name\":\"icoFunding\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellerCoinPartsForSale\",\"type\":\"uint256\"},{\"name\":\"sellerPricePerCoinPartInWEI\",\"type\":\"uint256\"}],\"name\":\"sellBkgAtExchg\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enter1forRedeemOR2forSell\",\"type\":\"uint256\"},{\"name\":\"amountOfCoinPartsToRedeemOrSell\",\"type\":\"uint256\"}],\"name\":\"redeemOrSellCoinsToICO\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"payment\",\"type\":\"uint256\"},{\"name\":\"crowdSaleContr\",\"type\":\"address\"}],\"name\":\"buyCoinsCrowdSale\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"retPayment\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"coinBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"setAddress\",\"type\":\"bool\"},{\"name\":\"icoAddr\",\"type\":\"address\"},{\"name\":\"exchAddr\",\"type\":\"address\"},{\"name\":\"csAddr\",\"type\":\"address\"},{\"name\":\"setCrowdSale\",\"type\":\"bool\"},{\"name\":\"crowdSaleOpen_\",\"type\":\"bool\"}],\"name\":\"setContrAddrAndCrwSale\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Or\",\"type\":\"address\"}],\"name\":\"transferOr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"unburn\",\"type\":\"bool\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"coinsRemaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"show\",\"type\":\"bool\"}],\"name\":\"viewSellOffersAtExchangeMacroansy\",\"outputs\":[{\"name\":\"sellersCoinAmountOffer\",\"type\":\"uint256\"},{\"name\":\"sellersPriceOfOneCoinInWEI\",\"type\":\"uint256\"},{\"name\":\"sellerBookedTime\",\"type\":\"uint256\"},{\"name\":\"buyerWhoBooked\",\"type\":\"address\"},{\"name\":\"buyPaymentBooked\",\"type\":\"uint256\"},{\"name\":\"buyerBookedTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"burnOrUnburn\",\"type\":\"uint256\"}],\"name\":\"BurnOrUnBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundOrPaymentTransfer\",\"type\":\"event\"}]","ContractName":"TokenMacroansyPower","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c85c731054040f1047c7a20be186808a64684ef33582b38b2bf0f284ae8f2e7a"}]}