{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() public onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  function unpause() public onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract TrueloveAccessControl {\r\n  event ContractUpgrade(address newContract);\r\n\r\n  address public ceoAddress;\r\n  address public cfoAddress;\r\n  address public cooAddress;\r\n\r\n  bool public paused = false;\r\n\r\n  modifier onlyCEO() {\r\n    require(msg.sender == ceoAddress);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCFO() {\r\n    require(msg.sender == cfoAddress);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCOO() {\r\n    require(msg.sender == cooAddress);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCLevel() {\r\n    require(\r\n      msg.sender == cooAddress ||\r\n      msg.sender == ceoAddress ||\r\n      msg.sender == cfoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  function setCEO(address _newCEO) external onlyCEO {\r\n    require(_newCEO != address(0));\r\n\r\n    ceoAddress = _newCEO;\r\n  }\r\n\r\n  function setCFO(address _newCFO) external onlyCEO {\r\n    require(_newCFO != address(0));\r\n\r\n    cfoAddress = _newCFO;\r\n  }\r\n\r\n  function setCOO(address _newCOO) external onlyCEO {\r\n    require(_newCOO != address(0));\r\n\r\n    cooAddress = _newCOO;\r\n  }\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() external onlyCLevel whenNotPaused {\r\n    paused = true;\r\n  }\r\n\r\n  function unpause() public onlyCEO whenPaused {\r\n    paused = false;\r\n  }\r\n}\r\n\r\ncontract TrueloveBase is TrueloveAccessControl {\r\n\tDiamond[] diamonds;\r\n\tmapping (uint256 => address) public diamondIndexToOwner;\r\n\tmapping (address => uint256) ownershipTokenCount;\r\n\tmapping (uint256 => address) public diamondIndexToApproved;\r\n\r\n\tmapping (address => uint256) public flowerBalances;\r\n\r\n\tstruct Diamond {\r\n\t\tbytes24 model;\r\n\t\tuint16 year;\r\n\t\tuint16 no;\r\n\t\tuint activateAt;\r\n\t}\r\n\r\n\tstruct Model {\r\n\t\tbytes24 model;\r\n\t\tuint current;\r\n\t\tuint total;\r\n\t\tuint16 year;\r\n\t\tuint256 price;\r\n\t}\r\n\r\n\tModel diamond1;\r\n\tModel diamond2;\r\n\tModel diamond3;\r\n\tModel flower;\r\n\r\n\tuint sendGiftPrice;\r\n\tuint beginSaleTime;\r\n\tuint nextSaleTime;\r\n\tuint registerPrice;\r\n\r\n\tDiamondAuction public diamondAuction;\r\n\tFlowerAuction public flowerAuction;\r\n\r\n\tfunction TrueloveBase() internal {\r\n\t\tsendGiftPrice = 0.001 ether; // MARK: Modify it\r\n\t\tregisterPrice = 0.01 ether; // MARK: Modify it\r\n\t\t_setVars();\r\n\r\n\t\tdiamond1 = Model({model: \"OnlyOne\", current: 0, total: 1, year: 2018, price: 1000 ether}); // MARK: Modify it\r\n\t\tdiamond2 = Model({model: \"Eternity2018\", current: 0, total: 5, year: 2018, price: 50 ether}); // MARK: Modify it\r\n\t\tdiamond3 = Model({model: \"Memorial\", current: 0, total: 1000, year: 2018, price: 1 ether}); // MARK: Modify it\r\n\t\tflower = Model({model: \"MySassyGirl\", current: 0, total: 10000000, year: 2018, price: 0.01 ether}); // MARK: Modify it\r\n\t}\r\n\r\n\tfunction _setVars() internal {\r\n\t\tbeginSaleTime = now;\r\n\t\tnextSaleTime = beginSaleTime + 300 days; // MARK: Modify it\r\n\t}\r\n\r\n\tfunction setSendGiftPrice(uint _sendGiftPrice) external onlyCOO {\r\n\t\tsendGiftPrice = _sendGiftPrice;\r\n\t}\r\n\r\n\tfunction setRegisterPrice(uint _registerPrice) external onlyCOO {\r\n\t\tregisterPrice = _registerPrice;\r\n\t}\r\n\r\n\tfunction _getModel(uint _index) internal view returns(Model storage) {\r\n\t\tif (_index == 1) {\r\n\t\t\treturn diamond1;\r\n\t\t} else if (_index == 2) {\r\n\t\t\treturn diamond2;\r\n\t\t} else if (_index == 3) {\r\n\t\t\treturn diamond3;\r\n\t\t} else if (_index == 4) {\r\n\t\t\treturn flower;\r\n\t\t}\r\n\t\trevert();\r\n\t}\r\n\tfunction getModel(uint _index) external view returns(\r\n\t\tbytes24 model,\r\n\t\tuint current,\r\n\t\tuint total,\r\n\t\tuint16 year,\r\n\t\tuint256 price\r\n\t) {\r\n\t\tModel storage _model = _getModel(_index);\r\n\t\tmodel = _model.model;\r\n\t\tcurrent = _model.current;\r\n\t\ttotal = _model.total;\r\n\t\tyear = _model.year;\r\n\t\tprice = _model.price;\r\n\t}\r\n}\r\n\r\ncontract EIP20Interface {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public flowerTotalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOfFlower(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFlower(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFromFlower(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approveFlower(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowanceFlower(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name  \r\n    event TransferFlower(address from, address to, uint256 value); \r\n    event ApprovalFlower(address owner, address spender, uint256 value);\r\n\r\n    function supportsEIP20Interface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract ERC721Metadata {\r\n\tfunction getMetadata(uint256 _tokenId, string) public pure returns (bytes32[4] buffer, uint256 count) {\r\n\t\tif (_tokenId == 1) {\r\n\t\t\tbuffer[0] = \"Hello World! :D\";\r\n\t\t\tcount = 15;\r\n\t\t} else if (_tokenId == 2) {\r\n\t\t\tbuffer[0] = \"I would definitely choose a medi\";\r\n\t\t\tbuffer[1] = \"um length string.\";\r\n\t\t\tcount = 49;\r\n\t\t} else if (_tokenId == 3) {\r\n\t\t\tbuffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n\t\t\tbuffer[1] = \"st accumsan dapibus augue lorem,\";\r\n\t\t\tbuffer[2] = \" tristique vestibulum id, libero\";\r\n\t\t\tbuffer[3] = \" suscipit varius sapien aliquam.\";\r\n\t\t\tcount = 128;\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract TrueloveOwnership is TrueloveBase, ERC721 {\r\n\tstring public constant name = \"CryptoTruelove\";\r\n\tstring public constant symbol = \"CT\";\r\n\r\n\t// The contract that will return kitty metadata\r\n\tERC721Metadata public erc721Metadata;\r\n\r\n\tbytes4 constant InterfaceSignature_ERC165 = bytes4(0x9a20483d);\r\n\t\t\t// bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n\r\n\tbytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\r\n\t\t\t// bytes4(keccak256(\"name()\")) ^\r\n\t\t\t// bytes4(keccak256(\"symbol()\")) ^\r\n\t\t\t// bytes4(keccak256(\"totalSupply()\")) ^\r\n\t\t\t// bytes4(keccak256(\"balanceOf(address)\")) ^\r\n\t\t\t// bytes4(keccak256(\"ownerOf(uint256)\")) ^\r\n\t\t\t// bytes4(keccak256(\"approve(address,uint256)\")) ^\r\n\t\t\t// bytes4(keccak256(\"transfer(address,uint256)\")) ^\r\n\t\t\t// bytes4(keccak256(\"transferFrom(address,address,uint256)\")) ^\r\n\t\t\t// bytes4(keccak256(\"tokensOfOwner(address)\")) ^\r\n\t\t\t// bytes4(keccak256(\"tokenMetadata(uint256,string)\"));\r\n\r\n\t/// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n\t///  Returns true for any standardized interfaces implemented by this contract. We implement\r\n\t///  ERC-165 (obviously!) and ERC-721.\r\n\tfunction supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n\t\t// DEBUG ONLY\r\n\t\t//require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\r\n\r\n\t\treturn ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n\t}\r\n\r\n\tfunction setMetadataAddress(address _contractAddress) public onlyCEO {\r\n\t\terc721Metadata = ERC721Metadata(_contractAddress);\r\n\t}\r\n\r\n\tfunction _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n\t\t\treturn diamondIndexToOwner[_tokenId] == _claimant;\r\n\t}\r\n\r\n\tfunction _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n\t\townershipTokenCount[_to]++;\r\n\t\tdiamondIndexToOwner[_tokenId] = _to;\r\n\t\tif (_from != address(0)) {\r\n\t\t\townershipTokenCount[_from]--;\r\n\t\t\tdelete diamondIndexToApproved[_tokenId];\r\n\t\t}\r\n\t\tTransfer(_from, _to, _tokenId);\r\n\t}\r\n\r\n\tfunction _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n\t\t\treturn diamondIndexToApproved[_tokenId] == _claimant;\r\n\t}\r\n\r\n\tfunction _approve(uint256 _tokenId, address _approved) internal {\r\n\t\t\tdiamondIndexToApproved[_tokenId] = _approved;\r\n\t}\r\n\r\n\t/// @notice Returns the number of Kitties owned by a specific address.\r\n\t/// @param _owner The owner address to check.\r\n\t/// @dev Required for ERC-721 compliance\r\n\tfunction balanceOf(address _owner) public view returns (uint256 count) {\r\n\t\t\treturn ownershipTokenCount[_owner];\r\n\t}\r\n\r\n\tfunction transfer(\r\n\t\t\taddress _to,\r\n\t\t\tuint256 _tokenId\r\n\t)\r\n\t\t\texternal\r\n\t\t\twhenNotPaused\r\n\t{\r\n\t\t\trequire(_to != address(0));\r\n\t\t\trequire(_to != address(this));\r\n\t\t\trequire(_to != address(diamondAuction));\r\n\t\t\trequire(_owns(msg.sender, _tokenId));\r\n\r\n\t\t\t_transfer(msg.sender, _to, _tokenId);\r\n\t}\r\n\r\n\tfunction approve(\r\n\t\t\taddress _to,\r\n\t\t\tuint256 _tokenId\r\n\t)\r\n\t\t\texternal\r\n\t\t\twhenNotPaused\r\n\t{\r\n\t\t\trequire(_owns(msg.sender, _tokenId));\r\n\r\n\t\t\t_approve(_tokenId, _to);\r\n\r\n\t\t\tApproval(msg.sender, _to, _tokenId);\r\n\t}\r\n\r\n\tfunction transferFrom(\r\n\t\t\taddress _from,\r\n\t\t\taddress _to,\r\n\t\t\tuint256 _tokenId\r\n\t)\r\n\t\t\texternal\r\n\t\t\twhenNotPaused\r\n\t{\r\n\t\t\trequire(_to != address(0));\r\n\t\t\trequire(_to != address(this));\r\n\t\t\trequire(_approvedFor(msg.sender, _tokenId));\r\n\t\t\trequire(_owns(_from, _tokenId));\r\n\r\n\t\t\t_transfer(_from, _to, _tokenId);\r\n\t}\r\n\r\n\tfunction totalSupply() public view returns (uint) {\r\n\t\t\treturn diamonds.length - 1;\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 _tokenId)\r\n\t\t\texternal\r\n\t\t\tview\r\n\t\t\treturns (address owner)\r\n\t{\r\n\t\t\towner = diamondIndexToOwner[_tokenId];\r\n\r\n\t\t\trequire(owner != address(0));\r\n\t}\r\n\r\n\t/// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n\t///  expensive (it walks the entire Kitty array looking for cats belonging to owner),\r\n\t///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n\t///  not contract-to-contract calls.\r\n\tfunction tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n\t\t\tuint256 tokenCount = balanceOf(_owner);\r\n\r\n\t\t\tif (tokenCount == 0) {\r\n\t\t\t\t\t// Return an empty array\r\n\t\t\t\t\treturn new uint256[](0);\r\n\t\t\t} else {\r\n\t\t\t\t\tuint256[] memory result = new uint256[](tokenCount);\r\n\t\t\t\t\tuint256 totalDiamonds = totalSupply();\r\n\t\t\t\t\tuint256 resultIndex = 0;\r\n\r\n\t\t\t\t\tuint256 diamondId;\r\n\r\n\t\t\t\t\tfor (diamondId = 1; diamondId <= totalDiamonds; diamondId++) {\r\n\t\t\t\t\t\t\tif (diamondIndexToOwner[diamondId] == _owner) {\r\n\t\t\t\t\t\t\t\t\tresult[resultIndex] = diamondId;\r\n\t\t\t\t\t\t\t\t\tresultIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn result;\r\n\t\t\t}\r\n\t}\r\n\r\n\tfunction _memcpy(uint _dest, uint _src, uint _len) private pure {\r\n\t\t\t// Copy word-length chunks while possible\r\n\t\t\tfor(; _len >= 32; _len -= 32) {\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\t\tmstore(_dest, mload(_src))\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_dest += 32;\r\n\t\t\t\t\t_src += 32;\r\n\t\t\t}\r\n\r\n\t\t\t// Copy remaining bytes\r\n\t\t\tuint256 mask = 256 ** (32 - _len) - 1;\r\n\t\t\tassembly {\r\n\t\t\t\t\tlet srcpart := and(mload(_src), not(mask))\r\n\t\t\t\t\tlet destpart := and(mload(_dest), mask)\r\n\t\t\t\t\tmstore(_dest, or(destpart, srcpart))\r\n\t\t\t}\r\n\t}\r\n\r\n\tfunction _toString(bytes32[4] _rawBytes, uint256 _stringLength) private pure returns (string) {\r\n\t\t\tvar outputString = new string(_stringLength);\r\n\t\t\tuint256 outputPtr;\r\n\t\t\tuint256 bytesPtr;\r\n\r\n\t\t\tassembly {\r\n\t\t\t\t\toutputPtr := add(outputString, 32)\r\n\t\t\t\t\tbytesPtr := _rawBytes\r\n\t\t\t}\r\n\r\n\t\t\t_memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n\t\t\treturn outputString;\r\n\t}\r\n\r\n\tfunction tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\r\n\t\t\trequire(erc721Metadata != address(0));\r\n\t\t\tbytes32[4] memory buffer;\r\n\t\t\tuint256 count;\r\n\t\t\t(buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\r\n\r\n\t\t\treturn _toString(buffer, count);\r\n\t}\r\n\r\n\tfunction getDiamond(uint256 _id)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\tbytes24 model,\r\n\t\tuint16 year,\r\n\t\tuint16 no,\r\n\t\tuint activateAt\r\n\t) {\r\n\t\tDiamond storage diamond = diamonds[_id];\r\n\r\n\t\tmodel = diamond.model;\r\n\t\tyear = diamond.year;\r\n\t\tno = diamond.no;\r\n\t\tactivateAt = diamond.activateAt;\r\n\t}\r\n}\r\n\r\ncontract TrueloveFlowerOwnership is TrueloveBase, EIP20Interface {\r\n\tuint256 constant private MAX_UINT256 = 2**256 - 1;\r\n\tmapping (address => mapping (address => uint256)) public flowerAllowed;\r\n\r\n\tbytes4 constant EIP20InterfaceSignature = bytes4(0x98474109);\r\n\t\t// bytes4(keccak256(\"balanceOfFlower(address)\")) ^\r\n\t\t// bytes4(keccak256(\"approveFlower(address,uint256)\")) ^\r\n\t\t// bytes4(keccak256(\"transferFlower(address,uint256)\")) ^\r\n\t\t// bytes4(keccak256(\"transferFromFlower(address,address,uint256)\"));\r\n\r\n\tfunction supportsEIP20Interface(bytes4 _interfaceID) external view returns (bool) {\r\n\t\treturn _interfaceID == EIP20InterfaceSignature;\r\n\t}\r\n\r\n\tfunction _transferFlower(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n\t\tif (_from != address(0)) {\r\n\t\t\trequire(flowerBalances[_from] >= _value);\r\n\t\t\tflowerBalances[_from] -= _value;\r\n\t\t}\r\n\t\tflowerBalances[_to] += _value;\r\n\t\tTransferFlower(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFlower(address _to, uint256 _value) public returns (bool success) {\r\n\t\trequire(flowerBalances[msg.sender] >= _value);\r\n\t\tflowerBalances[msg.sender] -= _value;\r\n\t\tflowerBalances[_to] += _value;\r\n\t\tTransferFlower(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFromFlower(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\tuint256 allowance = flowerAllowed[_from][msg.sender];\r\n\t\trequire(flowerBalances[_from] >= _value && allowance >= _value);\r\n\t\tflowerBalances[_to] += _value;\r\n\t\tflowerBalances[_from] -= _value;\r\n\t\tif (allowance < MAX_UINT256) {\r\n\t\t\tflowerAllowed[_from][msg.sender] -= _value;\r\n\t\t}\r\n\t\tTransferFlower(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction balanceOfFlower(address _owner) public view returns (uint256 balance) {\r\n\t\treturn flowerBalances[_owner];\r\n\t}\r\n\r\n\tfunction approveFlower(address _spender, uint256 _value) public returns (bool success) {\r\n\t\tflowerAllowed[msg.sender][_spender] = _value;\r\n\t\tApprovalFlower(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowanceFlower(address _owner, address _spender) public view returns (uint256 remaining) {\r\n\t\treturn flowerAllowed[_owner][_spender];\r\n\t}\r\n\r\n\tfunction _addFlower(uint256 _amount) internal {\r\n\t\tflower.current += _amount;\r\n\t\tflowerTotalSupply += _amount;\r\n\t}\r\n}\r\n\r\ncontract TrueloveNextSale is TrueloveOwnership, TrueloveFlowerOwnership {\r\n\tuint256 constant REMAINING_AMOUNT = 50000; // MARK: Modify it\r\n\r\n\tfunction TrueloveNextSale() internal {\r\n\t\t_giveRemainingFlower();\r\n\t}\r\n\r\n\tfunction openNextSale(uint256 _diamond1Price, bytes24 _diamond2Model, uint256 _diamond2Price, bytes24 _flowerModel, uint256 _flowerPrice)\r\n\t\texternal onlyCOO\r\n\t\t{\r\n\t\trequire(now >= nextSaleTime);\r\n\r\n\t\t_setVars();\r\n\t\tdiamond1.price = _diamond1Price;\r\n\t\t_openSaleDiamond2(_diamond2Model, _diamond2Price);\r\n\t\t_openSaleFlower(_flowerModel, _flowerPrice);\r\n\t\t_giveRemainingFlower();\r\n\t}\r\n\r\n\tfunction _openSaleDiamond2(bytes24 _diamond2Model, uint256 _diamond2Price) private {\r\n\t\tdiamond2.model = _diamond2Model;\r\n\t\tdiamond2.current = 0;\r\n\t\tdiamond2.year++;\r\n\t\tdiamond2.price = _diamond2Price;\r\n\t}\r\n\r\n\tfunction _openSaleFlower(bytes24 _flowerModel, uint256 _flowerPrice) private {\r\n\t\tflower.model = _flowerModel;\r\n\t\tflower.current = 0;\r\n\t\tflower.year++;\r\n\t\tflower.price = _flowerPrice;\r\n\t\tflower.total = 1000000; // MARK: Modify it\r\n\t}\r\n\r\n\tfunction _giveRemainingFlower() internal {\r\n\t\t_transferFlower(0, msg.sender, REMAINING_AMOUNT);\r\n\t\t_addFlower(REMAINING_AMOUNT);\r\n\t}\r\n}\r\n\r\ncontract TrueloveRegistration is TrueloveNextSale {\r\n\tmapping (address => RegistrationRight) public registrationRights;\r\n\tmapping (bytes32 => Registration) public registrations;\r\n\r\n\tstruct RegistrationRight {\r\n\t\tbool able;\r\n\t\tbool used;\r\n\t}\r\n\r\n\tstruct Registration {\r\n\t\tbool signed;\r\n\t\tstring secret; // including both names\r\n\t\tstring topSecret; // including SSN and birthdate\r\n\t}\r\n\r\n\tfunction giveRegistration(address _addr) external onlyCOO {\r\n\t\tif (registrationRights[_addr].able == false) {\r\n\t\t\tregistrationRights[_addr].able = true;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buyRegistration() external payable whenNotPaused {\r\n\t\trequire(registerPrice <= msg.value);\r\n\t\tif (registrationRights[msg.sender].able == false) {\r\n\t\t\tregistrationRights[msg.sender].able = true;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _giveSenderRegistration() internal {\r\n\t\tif (registrationRights[msg.sender].able == false) {\r\n\t\t\tregistrationRights[msg.sender].able = true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getRegistrationRight(address _addr) external view returns (bool able, bool used) {\r\n\t\table = registrationRights[_addr].able;\r\n\t\tused = registrationRights[_addr].used;\r\n\t}\r\n\r\n\tfunction getRegistration(bytes32 _unique) external view returns (bool signed, string secret, string topSecret) {\r\n\t\tsigned = registrations[_unique].signed;\r\n\t\tsecret = registrations[_unique].secret;\r\n\t\ttopSecret = registrations[_unique].topSecret;\r\n\t}\r\n\r\n\tfunction signTruelove(bytes32 _registerID, string _secret, string _topSecret) public {\r\n\t\trequire(registrationRights[msg.sender].able == true);\r\n\t\trequire(registrationRights[msg.sender].used == false);\r\n\t\tregistrationRights[msg.sender].used = true;\r\n\t\t_signTruelove(_registerID, _secret, _topSecret);\r\n\t}\r\n\r\n\tfunction signTrueloveByCOO(bytes32 _registerID, string _secret, string _topSecret) external onlyCOO {\r\n\t\t_signTruelove(_registerID, _secret, _topSecret);\r\n\t}\r\n\r\n\tfunction _signTruelove(bytes32 _registerID, string _secret, string _topSecret) internal {\r\n\t\trequire(registrations[_registerID].signed == false);\r\n\r\n\t\tregistrations[_registerID].signed = true;\r\n\t\tregistrations[_registerID].secret = _secret;\r\n\t\tregistrations[_registerID].topSecret = _topSecret;\r\n\t}\r\n}\r\n\r\ncontract TrueloveShop is TrueloveRegistration {\r\n\tfunction buyDiamond(uint _index) external payable whenNotPaused returns(uint256) {\r\n\t\trequire(_index == 1 || _index == 2 || _index == 3);\r\n\t\tModel storage model = _getModel(_index);\r\n\r\n\t\trequire(model.current < model.total);\r\n\t\trequire(model.price <= msg.value);\r\n\t\t_giveSenderRegistration();\r\n\r\n\t\tuint256 newDiamondId = diamonds.push(Diamond({model: model.model, year: model.year, no: uint16(model.current + 1), activateAt: 0})) - 1;\r\n\t\t_transfer(0, msg.sender, newDiamondId);\r\n\t\t\r\n\t\tmodel.current++;\r\n\t\treturn newDiamondId;\r\n\t}\r\n\r\n\tfunction buyFlower(uint _amount) external payable whenNotPaused {\r\n\t\trequire(flower.current + _amount < flower.total);\r\n\t\tuint256 price = currentFlowerPrice();\r\n\t\trequire(price * _amount <= msg.value);\r\n\t\t_giveSenderRegistration();\r\n\r\n\t\t_transferFlower(0, msg.sender, _amount);\r\n\t\t_addFlower(_amount);\r\n\t}\r\n\r\n\tfunction currentFlowerPrice() public view returns(uint256) {\r\n\t\tif (flower.current < 100000 + REMAINING_AMOUNT) { // MARK: Modify it\r\n\t\t\treturn flower.price;\r\n\t\t} else if (flower.current < 300000 + REMAINING_AMOUNT) { // MARK: Modify it\r\n\t\t\treturn flower.price * 4;\r\n\t\t} else {\r\n\t\t\treturn flower.price * 10;\r\n\t\t}\r\n\t}\r\n}\r\ncontract TrueloveDelivery is TrueloveShop {\r\n\tenum GiftType { Diamond, Flower }\r\n\r\n\tevent GiftSend(uint indexed index, address indexed receiver, address indexed from, bytes32 registerID, string letter, bytes16 date,\r\n\t\tGiftType gtype,\r\n\t\tbytes24 model,\r\n\t\tuint16 year,\r\n\t\tuint16 no,\r\n\t\tuint amount\r\n\t\t);\r\n\r\n\tuint public giftSendIndex = 1;\r\n\t\r\n\tmodifier sendCheck(bytes32 _registerID) {\r\n    require(sendGiftPrice <= msg.value);\r\n\t\trequire(registrations[_registerID].signed);\r\n    _;\r\n  }\r\n\r\n\tfunction signSendDiamond(bytes32 _registerID, string _secret, string _topSecret, address _truelove, string _letter, bytes16 _date, uint _tokenId) external payable {\r\n\t\tsignTruelove(_registerID, _secret, _topSecret);\r\n\t\tsendDiamond(_truelove, _registerID, _letter, _date, _tokenId);\r\n\t}\r\n\r\n\tfunction sendDiamond(address _truelove, bytes32 _registerID, string _letter, bytes16 _date, uint _tokenId) public payable sendCheck(_registerID) {\r\n\t\trequire(_owns(msg.sender, _tokenId));\r\n\t\trequire(now > diamonds[_tokenId].activateAt);\r\n\t\t\r\n\t\t_transfer(msg.sender, _truelove, _tokenId);\r\n\t\t\r\n\t\tdiamonds[_tokenId].activateAt = now + 3 days;\r\n\r\n\t\tGiftSend(giftSendIndex, _truelove, msg.sender, _registerID, _letter, _date,\r\n\t\t\tGiftType.Diamond,\r\n\t\t\tdiamonds[_tokenId].model,\r\n\t\t\tdiamonds[_tokenId].year,\r\n\t\t\tdiamonds[_tokenId].no,\r\n\t\t\t1\r\n\t\t\t);\r\n\t\tgiftSendIndex++;\r\n\t}\r\n\r\n\tfunction signSendFlower(bytes32 _registerID, string _secret, string _topSecret, address _truelove, string _letter, bytes16 _date, uint _amount) external payable {\r\n\t\tsignTruelove(_registerID, _secret, _topSecret);\r\n\t\tsendFlower(_truelove, _registerID, _letter, _date, _amount);\r\n\t}\r\n\r\n\tfunction sendFlower(address _truelove, bytes32 _registerID, string _letter, bytes16 _date, uint _amount) public payable sendCheck(_registerID) {\r\n\t\trequire(flowerBalances[msg.sender] >= _amount);\r\n\r\n\t\tflowerBalances[msg.sender] -= _amount;\r\n\t\tflowerBalances[_truelove] += (_amount * 9 / 10);\r\n\r\n\t\tGiftSend(giftSendIndex, _truelove, msg.sender, _registerID, _letter, _date,\r\n\t\t\tGiftType.Flower,\r\n\t\t\tflower.model,\r\n\t\t\tflower.year,\r\n\t\t\t0,\r\n\t\t\t_amount\r\n\t\t\t);\r\n\t\tgiftSendIndex++;\r\n\t}\r\n}\r\n\r\ncontract TrueloveAuction is TrueloveDelivery {\r\n\tfunction setDiamondAuctionAddress(address _address) external onlyCEO {\r\n\t\tDiamondAuction candidateContract = DiamondAuction(_address);\r\n\r\n\t\t// NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n\t\trequire(candidateContract.isDiamondAuction());\r\n\t\tdiamondAuction = candidateContract;\r\n\t}\r\n\r\n\tfunction createDiamondAuction(\r\n\t\tuint256 _tokenId,\r\n\t\tuint256 _startingPrice,\r\n\t\tuint256 _endingPrice,\r\n\t\tuint256 _duration\r\n\t)\r\n\t\texternal\r\n\t\twhenNotPaused\r\n\t{\r\n\t\trequire(_owns(msg.sender, _tokenId));\r\n\t\t// require(!isPregnant(_tokenId));\r\n\t\t_approve(_tokenId, diamondAuction);\r\n\t\tdiamondAuction.createAuction(\r\n\t\t\t_tokenId,\r\n\t\t\t_startingPrice,\r\n\t\t\t_endingPrice,\r\n\t\t\t_duration,\r\n\t\t\tmsg.sender\r\n\t\t);\r\n\t}\r\n\r\n\tfunction setFlowerAuctionAddress(address _address) external onlyCEO {\r\n\t\tFlowerAuction candidateContract = FlowerAuction(_address);\r\n\r\n\t\t// NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n\t\trequire(candidateContract.isFlowerAuction());\r\n\t\tflowerAuction = candidateContract;\r\n\t}\r\n\r\n\tfunction createFlowerAuction(\r\n\t\tuint256 _amount,\r\n\t\tuint256 _startingPrice,\r\n\t\tuint256 _endingPrice,\r\n\t\tuint256 _duration\r\n\t)\r\n\t\texternal\r\n\t\twhenNotPaused\r\n\t{\r\n\t\tapproveFlower(flowerAuction, _amount);\r\n\t\tflowerAuction.createAuction(\r\n\t\t\t_amount,\r\n\t\t\t_startingPrice,\r\n\t\t\t_endingPrice,\r\n\t\t\t_duration,\r\n\t\t\tmsg.sender\r\n\t\t);\r\n\t}\r\n\r\n\tfunction withdrawAuctionBalances() external onlyCLevel {\r\n\t\tdiamondAuction.withdrawBalance();\r\n\t\tflowerAuction.withdrawBalance();\r\n\t}\r\n}\r\n\r\ncontract TrueloveCore is TrueloveAuction {\r\n\taddress public newContractAddress;\r\n\r\n\tevent Transfer(address from, address to, uint256 tokenId);\r\n\tevent Approval(address owner, address approved, uint256 tokenId);\r\n\r\n\tevent TransferFlower(address from, address to, uint256 value); \r\n\tevent ApprovalFlower(address owner, address spender, uint256 value);\r\n\r\n\tevent GiftSend(uint indexed index, address indexed receiver, address indexed from, bytes32 registerID, string letter, bytes16 date,\r\n\t\tGiftType gtype,\r\n\t\tbytes24 model,\r\n\t\tuint16 year,\r\n\t\tuint16 no,\r\n\t\tuint amount\r\n\t\t);\r\n\t\t\r\n\tfunction TrueloveCore() public {\r\n\t\tceoAddress = msg.sender;\r\n\t\tcooAddress = msg.sender;\r\n\t}\r\n\r\n\tfunction setNewAddress(address _v2Address) external onlyCEO whenPaused {\r\n    newContractAddress = _v2Address;\r\n    ContractUpgrade(_v2Address);\r\n  }\r\n\r\n  function() external payable {\r\n    require(\r\n      msg.sender == address(diamondAuction) ||\r\n      msg.sender == address(flowerAuction)\r\n    );\r\n  }\r\n\tfunction withdrawBalance(uint256 amount) external onlyCFO {\r\n\t\tcfoAddress.transfer(amount);\r\n\t}\r\n}\r\n\r\ncontract ClockAuctionBase {\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) at beginning of auction\r\n        uint128 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint128 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint64 duration;\r\n        // Time when auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    ERC721 public nonFungibleContract;\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n    event AuctionCreated(uint256 indexed tokenId, address indexed seller, uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 indexed tokenId, uint256 totalPrice, address winner);\r\n    event AuctionCancelled(uint256 indexed tokenId);\r\n\r\n    /// @dev Returns true if the claimant owns the token.\r\n    /// @param _claimant - Address claiming to own the token.\r\n    /// @param _tokenId - ID of token whose ownership to verify.\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /// @dev Escrows the NFT, assigning ownership to this contract.\r\n    /// Throws if the escrow fails.\r\n    /// @param _owner - Current owner address of token to escrow.\r\n    /// @param _tokenId - ID of token whose approval to verify.\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    /// @dev Transfers an NFT owned by this contract to another address.\r\n    /// Returns true if the transfer succeeds.\r\n    /// @param _receiver - Address to transfer NFT to.\r\n    /// @param _tokenId - ID of token to transfer.\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n\r\n    /// @dev Adds an auction to the list of open auctions. Also fires the\r\n    ///  AuctionCreated event.\r\n    /// @param _tokenId The ID of the token to be put on auction.\r\n    /// @param _auction Auction to add.\r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\r\n        // Require that all auctions have a duration of\r\n        // at least one minute. (Keeps our math from getting hairy!)\r\n        require(_auction.duration >= 1 minutes);\r\n\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        AuctionCreated(\r\n            uint256(_tokenId),\r\n            _auction.seller,\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.duration)\r\n        );\r\n    }\r\n\r\n    /// @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        AuctionCancelled(_tokenId);\r\n    }\r\n\r\n    /// @dev Computes the price and transfers winnings.\r\n    /// Does NOT transfer ownership of token.\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // Get a reference to the auction struct\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n        // Explicitly check that this auction is currently live.\r\n        // (Because of how Ethereum mappings work, we can't just count\r\n        // on the lookup above failing. An invalid _tokenId will just\r\n        // return an auction object that is all zeros.)\r\n        require(_isOnAuction(auction));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(auction);\r\n        require(_bidAmount >= price);\r\n\r\n        // Grab a reference to the seller before the auction struct\r\n        // gets deleted.\r\n        address seller = auction.seller;\r\n\r\n        // The bid is good! Remove the auction before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        _removeAuction(_tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the auctioneer's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            // value <= price, so this subtraction can't go negative.)\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - auctioneerCut;\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the auction\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelAuction(). )\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the auction is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        AuctionSuccessful(_tokenId, price, msg.sender);\r\n\r\n        return price;\r\n    }\r\n\r\n    /// @dev Removes an auction from the list of open auctions.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    /// @dev Returns true if the NFT is on auction.\r\n    /// @param _auction - Auction to check.\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Returns current price of an NFT on auction. Broken into two\r\n    ///  functions (this one, that computes the duration from the auction\r\n    ///  structure, and the other that does the price computation) so we\r\n    ///  can easily test that the price computation works correctly.\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarnatees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    /// @dev Computes the current price of an auction. Factored out\r\n    ///  from _currentPrice so we can run extensive unit tests.\r\n    ///  When testing, make this function public and turn on\r\n    ///  `Current price computation` test suite.\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our public functions carefully cap the maximum values for\r\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\r\n        //  also known to be non-zero (see the require() statement in\r\n        //  _addAuction())\r\n        if (_secondsPassed >= _duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the auction, just return the end price.\r\n            return _endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that _startingPrice. Thus, this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    /// @dev Computes owner's cut of a sale.\r\n    /// @param _price - Sale price of NFT.\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our entry functions carefully cap the maximum values for\r\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\r\n        //  statement in the ClockAuction constructor). The result of this\r\n        //  function is always guaranteed to be <= _price.\r\n        return _price * ownerCut / 10000;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract ClockAuction is Pausable, ClockAuctionBase {\r\n\r\n    /// @dev The ERC-165 interface signature for ERC-721.\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\r\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\r\n\r\n    /// @dev Constructor creates a reference to the NFT ownership contract\r\n    ///  and verifies the owner cut is in the valid range.\r\n    /// @param _nftAddress - address of a deployed contract implementing\r\n    ///  the Nonfungible Interface.\r\n    /// @param _cut - percent cut the owner takes on each auction, must be\r\n    ///  between 0-10,000.\r\n    function ClockAuction(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\r\n    ///  as well as any Ether sent directly to the contract address.\r\n    ///  Always transfers to the NFT contract, but can be called either by\r\n    ///  the owner or the NFT contract.\r\n    function withdrawBalance() external {\r\n        address nftAddress = address(nonFungibleContract);\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == nftAddress\r\n        );\r\n        // We are using this boolean method to make sure that even if one fails it will still work\r\n        // bool res = nftAddress.send(this.balance);\r\n        nftAddress.send(this.balance);\r\n    }\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of time to move between starting\r\n    ///  price and ending price (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(_owns(msg.sender, _tokenId));\r\n        _escrow(msg.sender, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /// @dev Bids on an open auction, completing the auction and transferring\r\n    ///  ownership of the NFT if enough Ether is supplied.\r\n    /// @param _tokenId - ID of token to bid on.\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        // _bid will throw if the bid or funds transfer fails\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels an auction that hasn't been won yet.\r\n    ///  Returns the NFT to original owner.\r\n    /// @notice This is a state-modifying function that can\r\n    ///  be called while the contract is paused.\r\n    /// @param _tokenId - ID of token on auction\r\n    function cancelAuction(uint256 _tokenId)\r\n        external\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    /// @dev Cancels an auction when the contract is paused.\r\n    ///  Only the owner may do this, and NFTs are returned to\r\n    ///  the seller. This should only be used in emergencies.\r\n    /// @param _tokenId - ID of the NFT on auction to cancel.\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n        whenPaused\r\n        onlyOwner\r\n        external\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    /// @dev Returns auction info for an NFT on auction.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n            auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the current price of an auction.\r\n    /// @param _tokenId - ID of the token price we are checking.\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n\r\n}\r\n\r\ncontract DiamondAuction is ClockAuction {\r\n\r\n    // @dev Sanity check that allows us to ensure that we are pointing to the\r\n    //  right auction in our setSaleAuctionAddress() call.\r\n    bool public isDiamondAuction = true;\r\n\r\n    event AuctionCreated(uint256 indexed tokenId, address indexed seller, uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 indexed tokenId, uint256 totalPrice, address winner);\r\n    event AuctionCancelled(uint256 indexed tokenId);\r\n    \r\n    // Delegate constructor\r\n    function DiamondAuction(address _nftAddr) public\r\n        ClockAuction(_nftAddr, 0) {}\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of auction (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /// @dev Updates lastSalePrice if seller is the nft contract\r\n    /// Otherwise, works the same as default bid method.\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        // _bid verifies token ID size\r\n        tokenIdToAuction[_tokenId].seller;\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n}\r\n\r\ncontract FlowerAuction is Pausable {\r\n    struct Auction {\r\n        address seller;\r\n        uint256 amount;\r\n        uint128 startingPrice;\r\n        uint128 endingPrice;\r\n        uint64 duration;\r\n        uint64 startedAt;\r\n    }\r\n\r\n    EIP20Interface public tokenContract;\r\n\r\n    uint256 public ownerCut;\r\n\r\n    mapping (uint256 => Auction) auctions;\r\n    mapping (address => uint256) sellerToAuction;\r\n    uint256 public currentAuctionId;\r\n\r\n    event AuctionCreated(uint256 indexed auctionId, address indexed seller, uint256 amount, uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 indexed auctionId, uint256 amount, address winner);\r\n    event AuctionSoldOut(uint256 indexed auctionId);\r\n    event AuctionCancelled(uint256 indexed auctionId);\r\n\r\n    bytes4 constant InterfaceSignature_EIP20 = bytes4(0x98474109);\r\n\r\n    bool public isFlowerAuction = true;\r\n\r\n    function FlowerAuction(address _nftAddress) public {\r\n        ownerCut = 0;\r\n\r\n        EIP20Interface candidateContract = EIP20Interface(_nftAddress);\r\n        require(candidateContract.supportsEIP20Interface(InterfaceSignature_EIP20));\r\n        tokenContract = candidateContract;\r\n    }\r\n\r\n    function createAuction(\r\n        uint256 _amount,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n    {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(tokenContract));\r\n        _escrow(_seller, _amount);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            _amount,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(auction);\r\n    }\r\n\r\n    function bid(uint256 _auctionId, uint256 _amount)\r\n        external\r\n        payable\r\n    {\r\n        _bid(_auctionId, _amount, msg.value);\r\n        _transfer(msg.sender, _amount);\r\n    }\r\n\r\n\r\n\r\n\r\n    function withdrawBalance() external {\r\n        address nftAddress = address(tokenContract);\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == nftAddress\r\n        );\r\n        nftAddress.send(this.balance);\r\n    }\r\n\r\n\r\n    function cancelAuction(uint256 _auctionId)\r\n        external\r\n    {\r\n        Auction storage auction = auctions[_auctionId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_auctionId, seller);\r\n    }\r\n\r\n    function cancelAuctionWhenPaused(uint256 _auctionId)\r\n        whenPaused\r\n        onlyOwner\r\n        external\r\n    {\r\n        Auction storage auction = auctions[_auctionId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_auctionId, auction.seller);\r\n    }\r\n\r\n    function getAuction(uint256 _auctionId)\r\n        external\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 amount,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        Auction storage auction = auctions[_auctionId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n            auction.seller,\r\n            auction.amount,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    function getCurrentPrice(uint256 _auctionId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = auctions[_auctionId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function _escrow(address _owner, uint256 _amount) internal {\r\n        tokenContract.transferFromFlower(_owner, this, _amount);\r\n    }\r\n\r\n    function _transfer(address _receiver, uint256 _amount) internal {\r\n        tokenContract.transferFlower(_receiver, _amount);\r\n    }\r\n\r\n    function _addAuction(Auction _auction) internal {\r\n        require(_auction.duration >= 1 minutes);\r\n\r\n        currentAuctionId++;\r\n        auctions[currentAuctionId] = _auction;\r\n        sellerToAuction[_auction.seller] = currentAuctionId;\r\n\r\n        AuctionCreated(\r\n            currentAuctionId,\r\n            _auction.seller,\r\n            _auction.amount,\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.duration)\r\n        );\r\n    }\r\n\r\n    function _cancelAuction(uint256 _auctionId, address _seller) internal {\r\n        uint256 amount = auctions[_auctionId].amount;\r\n        delete sellerToAuction[auctions[_auctionId].seller];\r\n        delete auctions[_auctionId];\r\n        _transfer(_seller, amount);\r\n        AuctionCancelled(_auctionId);\r\n    }\r\n\r\n    function _bid(uint256 _auctionId, uint256 _amount, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = auctions[_auctionId];\r\n        require(_isOnAuction(auction));\r\n        uint256 price = _currentPrice(auction);\r\n        uint256 totalPrice = price * _amount;\r\n        require(_bidAmount >= totalPrice);\r\n        auction.amount -= _amount;\r\n\r\n        address seller = auction.seller;\r\n\r\n        if (totalPrice > 0) {\r\n            uint256 auctioneerCut = _computeCut(totalPrice);\r\n            uint256 sellerProceeds = totalPrice - auctioneerCut;\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n        uint256 bidExcess = _bidAmount - totalPrice;\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        if (auction.amount == 0) {\r\n            AuctionSoldOut(_auctionId);\r\n            delete auctions[_auctionId];\r\n        } else {\r\n            AuctionSuccessful(_auctionId, _amount, msg.sender);\r\n        }\r\n\r\n        return totalPrice;\r\n    }\r\n\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_secondsPassed >= _duration) {\r\n            return _endingPrice;\r\n        } else {\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        return _price * ownerCut / 10000;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"flowerAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_truelove\",\"type\":\"address\"},{\"name\":\"_registerID\",\"type\":\"bytes32\"},{\"name\":\"_letter\",\"type\":\"string\"},{\"name\":\"_date\",\"type\":\"bytes16\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendFlower\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getRegistrationRight\",\"outputs\":[{\"name\":\"able\",\"type\":\"bool\"},{\"name\":\"used\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveFlower\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registerPrice\",\"type\":\"uint256\"}],\"name\":\"setRegisterPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"diamondIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"flowerAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_diamond1Price\",\"type\":\"uint256\"},{\"name\":\"_diamond2Model\",\"type\":\"bytes24\"},{\"name\":\"_diamond2Price\",\"type\":\"uint256\"},{\"name\":\"_flowerModel\",\"type\":\"bytes24\"},{\"name\":\"_flowerPrice\",\"type\":\"uint256\"}],\"name\":\"openNextSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registerID\",\"type\":\"bytes32\"},{\"name\":\"_secret\",\"type\":\"string\"},{\"name\":\"_topSecret\",\"type\":\"string\"},{\"name\":\"_truelove\",\"type\":\"address\"},{\"name\":\"_letter\",\"type\":\"string\"},{\"name\":\"_date\",\"type\":\"bytes16\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"signSendDiamond\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"buyDiamond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"diamondAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createDiamondAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registerID\",\"type\":\"bytes32\"},{\"name\":\"_secret\",\"type\":\"string\"},{\"name\":\"_topSecret\",\"type\":\"string\"}],\"name\":\"signTruelove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentFlowerPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createFlowerAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"flowerBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getModel\",\"outputs\":[{\"name\":\"model\",\"type\":\"bytes24\"},{\"name\":\"current\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"flowerTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"giveRegistration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOfFlower\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAuctionBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_unique\",\"type\":\"bytes32\"}],\"name\":\"getRegistration\",\"outputs\":[{\"name\":\"signed\",\"type\":\"bool\"},{\"name\":\"secret\",\"type\":\"string\"},{\"name\":\"topSecret\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowanceFlower\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registrationRights\",\"outputs\":[{\"name\":\"able\",\"type\":\"bool\"},{\"name\":\"used\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setDiamondAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"diamondIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setFlowerAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sendGiftPrice\",\"type\":\"uint256\"}],\"name\":\"setSendGiftPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registerID\",\"type\":\"bytes32\"},{\"name\":\"_secret\",\"type\":\"string\"},{\"name\":\"_topSecret\",\"type\":\"string\"},{\"name\":\"_truelove\",\"type\":\"address\"},{\"name\":\"_letter\",\"type\":\"string\"},{\"name\":\"_date\",\"type\":\"bytes16\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"signSendFlower\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_truelove\",\"type\":\"address\"},{\"name\":\"_registerID\",\"type\":\"bytes32\"},{\"name\":\"_letter\",\"type\":\"string\"},{\"name\":\"_date\",\"type\":\"bytes16\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"sendDiamond\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registerID\",\"type\":\"bytes32\"},{\"name\":\"_secret\",\"type\":\"string\"},{\"name\":\"_topSecret\",\"type\":\"string\"}],\"name\":\"signTrueloveByCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyFlower\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"registrations\",\"outputs\":[{\"name\":\"signed\",\"type\":\"bool\"},{\"name\":\"secret\",\"type\":\"string\"},{\"name\":\"topSecret\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromFlower\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDiamond\",\"outputs\":[{\"name\":\"model\",\"type\":\"bytes24\"},{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"no\",\"type\":\"uint16\"},{\"name\":\"activateAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyRegistration\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsEIP20Interface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFlower\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"giftSendIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferFlower\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ApprovalFlower\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"registerID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"letter\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"gtype\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"model\",\"type\":\"bytes24\"},{\"indexed\":false,\"name\":\"year\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"no\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GiftSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"TrueloveCore","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e072db836f9fecef81d62da76d9006cd9c5ebdc8308b69eaee496b5e207ac22e"}]}