{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\ncontract ERC20Interface {\r\n \r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    \r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Common uitility functions\r\n// ----------------------------------------------------------------------------\r\ncontract Common {\r\n    \r\n    function Common() internal {\r\n\r\n    }\r\n\r\n    function getIndexOfTarget(address[] list, address addr) internal pure returns (int) {\r\n        for (uint i = 0; i < list.length; i++) {\r\n            if (list[i] == addr) {\r\n                return int(i);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n    address public operator;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    event OperatorTransfered(address indexed _from, address indexed _to);\r\n\r\n    function Owned() internal {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrOperator {\r\n        require(msg.sender == owner || msg.sender == operator);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function transferOperator(address _newOperator) public onlyOwner {\r\n        address originalOperator = operator;\r\n        operator = _newOperator;\r\n        OperatorTransfered(originalOperator, _newOperator);\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract TokenHeld {\r\n    \r\n    address[] public addressIndices;\r\n\r\n    event OnPushedAddress(address addr, uint index);\r\n\r\n    function TokenHeld() internal {\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Scan the addressIndices for ensuring the target address is included\r\n    // ------------------------------------------------------------------------\r\n    function scanAddresses(address addr) internal {\r\n        bool isAddrExist = false;\r\n        for (uint i = 0;i < addressIndices.length; i++) {\r\n            if (addressIndices[i] == addr) {\r\n                isAddrExist = true;\r\n                break;\r\n            }\r\n        }\r\n        if (isAddrExist == false) {\r\n            addressIndices.push(addr);\r\n            OnPushedAddress(addr, addressIndices.length);\r\n        }\r\n    }\r\n}\r\n\r\ncontract Restricted is Common, Owned {\r\n\r\n    bool isChargingTokenTransferFee;\r\n    bool isAllocatingInterest;\r\n    bool isChargingManagementFee;\r\n    bool isTokenTransferOpen;\r\n\r\n    address[] tokenTransferDisallowedAddresses;\r\n\r\n    event OnIsChargingTokenTransferFeeUpdated(bool from, bool to);\r\n    event OnIsAllocatingInterestUpdated(bool from, bool to);\r\n    event OnIsChargingManagementFeeUpdated(bool from, bool to);\r\n    event OnIsTokenTransferOpenUpdated(bool from, bool to);\r\n    event OnTransferDisallowedAddressesChanged(string action, address indexed addr);\r\n    \r\n    modifier onlyWhenAllocatingInterestOpen {\r\n        require(isAllocatingInterest == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenChargingManagementFeeOpen {\r\n        require(isChargingManagementFee == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenTokenTransferOpen {\r\n        require(isTokenTransferOpen == true);\r\n        _;\r\n    }\r\n\r\n    modifier shouldBeAllowed(address[] list, address addr) {\r\n        require(getIndexOfTarget(list, addr) == -1);\r\n        _;\r\n    }\r\n    \r\n    function Restricted() internal {\r\n        isChargingTokenTransferFee = false;\r\n        isAllocatingInterest = false;\r\n        isChargingManagementFee = false;\r\n        isTokenTransferOpen = true;\r\n    }\r\n    \r\n    function setIsChargingTokenTransferFee(bool onOff) public onlyOwnerOrOperator {\r\n        bool original = isChargingTokenTransferFee;\r\n        isChargingTokenTransferFee = onOff;\r\n        OnIsChargingTokenTransferFeeUpdated(original, onOff);\r\n    }\r\n\r\n    function setIsAllocatingInterest(bool onOff) public onlyOwnerOrOperator {\r\n        bool original = isAllocatingInterest;\r\n        isAllocatingInterest = onOff;\r\n        OnIsAllocatingInterestUpdated(original, onOff);\r\n    }\r\n\r\n    function setIsChargingManagementFee(bool onOff) public onlyOwnerOrOperator {\r\n        bool original = isChargingManagementFee;\r\n        isChargingManagementFee = onOff;\r\n        OnIsChargingManagementFeeUpdated(original, onOff);\r\n    }\r\n\r\n    function setIsTokenTransferOpen(bool onOff) public onlyOwnerOrOperator {\r\n        bool original = isTokenTransferOpen;\r\n        isTokenTransferOpen = onOff;\r\n        OnIsTokenTransferOpenUpdated(original, onOff);\r\n    }\r\n\r\n    function addToTokenTransferDisallowedList(address addr) public onlyOwnerOrOperator {\r\n        int idx = getIndexOfTarget(tokenTransferDisallowedAddresses, addr);\r\n        if (idx == -1) {\r\n            tokenTransferDisallowedAddresses.push(addr);\r\n            OnTransferDisallowedAddressesChanged(\"add\", addr);\r\n        }\r\n    }\r\n\r\n    function removeFromTokenTransferDisallowedAddresses(address addr) public onlyOwnerOrOperator {\r\n        int idx = getIndexOfTarget(tokenTransferDisallowedAddresses, addr);\r\n        if (idx >= 0) {\r\n            uint uidx = uint(idx);\r\n            delete tokenTransferDisallowedAddresses[uidx];\r\n            OnTransferDisallowedAddressesChanged(\"remove\", addr);\r\n        }\r\n    }\r\n}\r\n\r\ncontract TokenTransaction is Common, Owned {\r\n\r\n    bool isTokenTransactionOpen;\r\n\r\n    address[] transactionDisallowedAddresses;\r\n\r\n    uint exchangeRateFor1Eth;\r\n\r\n    event OnIsTokenTransactionOpenUpdated(bool from, bool to);\r\n    event OnTransactionDisallowedAddressesChanged(string action, address indexed addr);\r\n    event OnExchangeRateUpdated(uint from, uint to);\r\n\r\n    modifier onlyWhenTokenTransactionOpen {\r\n        require(isTokenTransactionOpen == true);\r\n        _;\r\n    }\r\n\r\n    function TokenTransaction() internal {\r\n        isTokenTransactionOpen = true;\r\n        exchangeRateFor1Eth = 1000;\r\n    }\r\n\r\n    function setIsTokenTransactionOpen(bool onOff) public onlyOwnerOrOperator {\r\n        bool original = isTokenTransactionOpen;\r\n        isTokenTransactionOpen = onOff;\r\n        OnIsTokenTransactionOpenUpdated(original, onOff);\r\n    }\r\n\r\n    function addToTransactionDisallowedList(address addr) public constant onlyOwnerOrOperator {\r\n        int idx = getIndexOfTarget(transactionDisallowedAddresses, addr);\r\n        if (idx == -1) {\r\n            transactionDisallowedAddresses.push(addr);\r\n            OnTransactionDisallowedAddressesChanged(\"add\", addr);\r\n        }\r\n    }\r\n\r\n    function removeFromTransactionDisallowedList(address addr) public constant onlyOwnerOrOperator {\r\n        int idx = getIndexOfTarget(transactionDisallowedAddresses, addr);\r\n        if (idx >= 0) {\r\n            uint uidx = uint(idx);\r\n            delete transactionDisallowedAddresses[uidx];\r\n            OnTransactionDisallowedAddressesChanged(\"remove\", addr);\r\n        }\r\n    }\r\n\r\n    function updateExchangeRate(uint newExchangeRate) public onlyOwner {\r\n        uint originalRate = exchangeRateFor1Eth;\r\n        exchangeRateFor1Eth = newExchangeRate;\r\n        OnExchangeRateUpdated(originalRate, newExchangeRate);\r\n    }\r\n}\r\n\r\ncontract Distributed is Owned {\r\n    using SafeMath for uint;\r\n    \r\n    // Allocation related\r\n    uint tokenTransferPercentageNumerator;\r\n    uint tokenTransferPercentageDenominator;\r\n    uint interestAllocationPercentageNumerator;\r\n    uint interestAllocationPercentageDenominator;\r\n    uint managementFeeChargePercentageNumerator;\r\n    uint managementFeeChargePercentageDenominator;\r\n\r\n    uint distCompanyPercentage;\r\n    uint distTeamPercentage;\r\n    uint distOfferPercentage;\r\n\r\n    event OnPercentageChanged(string state, uint _m, uint _d, uint m, uint d);\r\n    event OnDistributionChanged(uint _c, uint _t, uint _o, uint c, uint t, uint o);\r\n    \r\n    modifier onlyWhenPercentageSettingIsValid(uint c, uint t, uint o) {\r\n        require((c.add(t).add(o)) == 100);\r\n        _;\r\n    }\r\n\r\n    function Distributed() internal {\r\n\r\n        tokenTransferPercentageNumerator = 1;\r\n        tokenTransferPercentageDenominator = 100;\r\n        interestAllocationPercentageNumerator = 1;\r\n        interestAllocationPercentageDenominator = 100;\r\n        managementFeeChargePercentageNumerator = 1;\r\n        managementFeeChargePercentageDenominator = 100;\r\n\r\n        distCompanyPercentage = 20;\r\n        distTeamPercentage = 10;\r\n        distOfferPercentage = 70;\r\n    }\r\n\r\n    function setTokenTransferPercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\r\n        uint m = tokenTransferPercentageNumerator;\r\n        uint d = tokenTransferPercentageDenominator;\r\n        tokenTransferPercentageNumerator = numerator;\r\n        tokenTransferPercentageDenominator = denominator;\r\n        OnPercentageChanged(\"TokenTransferFee\", m, d, numerator, denominator);\r\n    }\r\n\r\n    function setInterestAllocationPercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\r\n        uint m = interestAllocationPercentageNumerator;\r\n        uint d = interestAllocationPercentageDenominator;\r\n        interestAllocationPercentageNumerator = numerator;\r\n        interestAllocationPercentageDenominator = denominator;\r\n        OnPercentageChanged(\"InterestAllocation\", m, d, numerator, denominator);\r\n    }\r\n\r\n    function setManagementFeeChargePercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\r\n        uint m = managementFeeChargePercentageNumerator;\r\n        uint d = managementFeeChargePercentageDenominator;\r\n        managementFeeChargePercentageNumerator = numerator;\r\n        managementFeeChargePercentageDenominator = denominator;\r\n        OnPercentageChanged(\"ManagementFee\", m, d, numerator, denominator);\r\n    }\r\n\r\n    function setDistributionPercentage(uint c, uint t, uint o) public onlyWhenPercentageSettingIsValid(c, t, o) onlyOwner {\r\n        uint _c = distCompanyPercentage;\r\n        uint _t = distTeamPercentage;\r\n        uint _o = distOfferPercentage;\r\n        distCompanyPercentage = c;\r\n        distTeamPercentage = t;\r\n        distOfferPercentage = o;\r\n        OnDistributionChanged(_c, _t, _o, distCompanyPercentage, distTeamPercentage, distOfferPercentage);\r\n    }\r\n}\r\n\r\ncontract FeeCalculation {\r\n    using SafeMath for uint;\r\n    \r\n    function FeeCalculation() internal {\r\n\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the fee tokens for transferring.\r\n    // ------------------------------------------------------------------------\r\n    function calculateTransferFee(uint tokens) internal pure returns (uint) {\r\n        uint calFee = 0;\r\n        if (tokens > 0 && tokens <= 1000)\r\n            calFee = 1;\r\n        else if (tokens > 1000 && tokens <= 5000)\r\n            calFee = tokens.mul(1).div(1000);\r\n        else if (tokens > 5000 && tokens <= 10000)\r\n            calFee = tokens.mul(2).div(1000);\r\n        else if (tokens > 10000)\r\n            calFee = 30;\r\n        return calFee;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// initial fixed supply\r\n// ----------------------------------------------------------------------------\r\ncontract FixedSupplyToken is ERC20Interface, Distributed, TokenHeld, Restricted, TokenTransaction, FeeCalculation {\r\n    using SafeMath for uint;\r\n\r\n    // Token information related\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    event OnAllocated(address indexed addr, uint allocatedTokens);\r\n    event OnCharged(address indexed addr, uint chargedTokens);\r\n    \r\n    modifier onlyWhenOfferredIsLowerThanDistOfferPercentage {\r\n        uint expectedTokens = msg.value.mul(1000);\r\n        uint totalOfferredTokens = 0;\r\n        for (uint i = 0; i < addressIndices.length; i++) {\r\n            totalOfferredTokens += balances[addressIndices[i]];\r\n        }\r\n        require(_totalSupply.mul(distOfferPercentage).div(100) - expectedTokens >= 0);\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function FixedSupplyToken() public {\r\n        symbol = \"AGC\";\r\n        name = \"Agile Coin\";\r\n        decimals = 0;\r\n        _totalSupply = 100000000 * 10**uint(decimals);\r\n\r\n        balances[owner] = _totalSupply;\r\n        Transfer(address(0), owner, _totalSupply);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        uint balance = balances[address(0)];\r\n        return _totalSupply - balance;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public onlyWhenTokenTransferOpen shouldBeAllowed(transactionDisallowedAddresses, msg.sender) returns (bool success) {\r\n        uint calFee = isChargingTokenTransferFee ? calculateTransferFee(tokens) : 0;\r\n        scanAddresses(to);\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens + calFee);\r\n\t\tbalances[owner] = balances[owner].add(calFee);\r\n        balances[to] = balances[to].add(tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        Transfer(msg.sender, owner, calFee);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public onlyWhenTokenTransferOpen shouldBeAllowed(tokenTransferDisallowedAddresses, msg.sender) returns (bool success) {\r\n        uint calFee = isChargingTokenTransferFee ? calculateTransferFee(tokens) : 0;\r\n        scanAddresses(to);\r\n        balances[from] = balances[from].sub(tokens + calFee);\r\n        balances[owner] = balances[owner].add(calFee);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        Transfer(from, to, tokens);\r\n        Transfer(from, owner, calFee);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account. The `spender` contract function\r\n    // `receiveApproval(...)` is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable onlyWhenTokenTransactionOpen onlyWhenOfferredIsLowerThanDistOfferPercentage {\r\n        // Exchange: ETH --> ETTA Coin\r\n        revert();\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Allocate interest.\r\n    // ------------------------------------------------------------------------\r\n    function allocateTokens() public onlyOwnerOrOperator onlyWhenAllocatingInterestOpen {\r\n        for (uint i = 0; i < addressIndices.length; i++) {\r\n            address crntAddr = addressIndices[i];\r\n            uint balanceOfCrntAddr = balances[crntAddr];\r\n            uint allocatedTokens = balanceOfCrntAddr.mul(interestAllocationPercentageNumerator).div(interestAllocationPercentageDenominator);\r\n            balances[crntAddr] = balances[crntAddr].add(allocatedTokens);\r\n            balances[owner] = balances[owner].sub(allocatedTokens);\r\n            Transfer(owner, crntAddr, allocatedTokens);\r\n            OnAllocated(crntAddr, allocatedTokens);\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Charge investers for management fee.\r\n    // ------------------------------------------------------------------------\r\n    function chargeTokensForManagement() public onlyOwnerOrOperator onlyWhenChargingManagementFeeOpen {\r\n        for (uint i = 0; i < addressIndices.length; i++) {\r\n            address crntAddr = addressIndices[i];\r\n            uint balanceOfCrntAddr = balances[crntAddr];\r\n            uint chargedTokens = balanceOfCrntAddr.mul(managementFeeChargePercentageNumerator).div(managementFeeChargePercentageDenominator);\r\n            balances[crntAddr] = balances[crntAddr].sub(chargedTokens);\r\n            balances[owner] = balances[owner].add(chargedTokens);\r\n            Transfer(crntAddr,owner, chargedTokens);\r\n            OnCharged(crntAddr, chargedTokens);\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Distribute more token of contract and transfer to owner \r\n    // ------------------------------------------------------------------------\r\n    function mintToken(uint256 mintedAmount) public onlyOwner {\r\n        require(mintedAmount > 0);\r\n        balances[owner] = balances[owner].add(mintedAmount);\r\n        _totalSupply = _totalSupply.add(mintedAmount);\r\n        Transfer(address(0), owner, mintedAmount);\r\n    }\r\n\r\n    event OnTokenBurned(uint256 totalBurnedTokens);\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Remove `numerator / denominator` % of tokens from the system irreversibly\r\n    // ------------------------------------------------------------------------\r\n    function burnByPercentage(uint8 m, uint8 d) public onlyOwner returns (bool success) {\r\n        require(m > 0 && d > 0 && m <= d);\r\n        uint totalBurnedTokens = balances[owner].mul(m).div(d);\r\n        balances[owner] = balances[owner].sub(totalBurnedTokens);\r\n        _totalSupply = _totalSupply.sub(totalBurnedTokens);\r\n        Transfer(owner, address(0), totalBurnedTokens);\r\n        OnTokenBurned(totalBurnedTokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Remove a quantity of tokens\r\n    // ------------------------------------------------------------------------\r\n    function burnByAmount(uint256 tokens) public onlyOwner returns (bool success) {\r\n        require(tokens > 0 && tokens <= balances[owner]);\r\n        balances[owner] = balances[owner].sub(tokens);\r\n        _totalSupply = _totalSupply.sub(tokens);\r\n        Transfer(owner, address(0), tokens);\r\n        OnTokenBurned(tokens);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"allocateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onOff\",\"type\":\"bool\"}],\"name\":\"setIsTokenTransactionOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addToTokenTransferDisallowedList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"setTokenTransferPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onOff\",\"type\":\"bool\"}],\"name\":\"setIsAllocatingInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addToTransactionDisallowedList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"setManagementFeeChargePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeFromTransactionDisallowedList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"burnByAmount\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"m\",\"type\":\"uint8\"},{\"name\":\"d\",\"type\":\"uint8\"}],\"name\":\"burnByPercentage\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"setInterestAllocationPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onOff\",\"type\":\"bool\"}],\"name\":\"setIsTokenTransferOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"chargeTokensForManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newExchangeRate\",\"type\":\"uint256\"}],\"name\":\"updateExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"c\",\"type\":\"uint256\"},{\"name\":\"t\",\"type\":\"uint256\"},{\"name\":\"o\",\"type\":\"uint256\"}],\"name\":\"setDistributionPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeFromTokenTransferDisallowedAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onOff\",\"type\":\"bool\"}],\"name\":\"setIsChargingManagementFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onOff\",\"type\":\"bool\"}],\"name\":\"setIsChargingTokenTransferFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allocatedTokens\",\"type\":\"uint256\"}],\"name\":\"OnAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"chargedTokens\",\"type\":\"uint256\"}],\"name\":\"OnCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"totalBurnedTokens\",\"type\":\"uint256\"}],\"name\":\"OnTokenBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"bool\"}],\"name\":\"OnIsTokenTransactionOpenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OnTransactionDisallowedAddressesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"OnExchangeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"bool\"}],\"name\":\"OnIsChargingTokenTransferFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"bool\"}],\"name\":\"OnIsAllocatingInterestUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"bool\"}],\"name\":\"OnIsChargingManagementFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"bool\"}],\"name\":\"OnIsTokenTransferOpenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OnTransferDisallowedAddressesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"OnPushedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_m\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_d\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"m\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"OnPercentageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_c\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_o\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"c\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"t\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"o\",\"type\":\"uint256\"}],\"name\":\"OnDistributionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OperatorTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FixedSupplyToken","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e8c0dcd29d716fded4c5494b12fb216065fe7291a97b016cacc804e9fcb271d9"}]}