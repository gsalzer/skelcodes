{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n    public\r\n    auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n    public\r\n    auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant public returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant public returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract LemoSale is DSAuth, DSMath {\r\n    ERC20 public token;                  // The LemoCoin token\r\n\r\n    bool public funding = true; // funding state\r\n\r\n    uint256 public startTime = 0; // crowdsale start time (in seconds)\r\n    uint256 public endTime = 0; // crowdsale end time (in seconds)\r\n    uint256 public finney2LemoRate = 0; // how many tokens one wei equals\r\n    uint256 public tokenContributionCap = 0; // max amount raised during crowdsale\r\n    uint256 public tokenContributionMin = 0; // min amount raised during crowdsale\r\n    uint256 public soldAmount = 0; // total sold token amount\r\n    uint256 public minPayment = 0; // min eth each time\r\n    uint256 public contributionCount = 0;\r\n\r\n    // triggered when contribute successful\r\n    event Contribution(address indexed _contributor, uint256 _amount, uint256 _return);\r\n    // triggered when refund successful\r\n    event Refund(address indexed _from, uint256 _value);\r\n    // triggered when crowdsale is over\r\n    event Finalized(uint256 _time);\r\n\r\n    modifier between(uint256 _startTime, uint256 _endTime) {\r\n        require(block.timestamp >= _startTime && block.timestamp < _endTime);\r\n        _;\r\n    }\r\n\r\n    function LemoSale(uint256 _tokenContributionMin, uint256 _tokenContributionCap, uint256 _finney2LemoRate) public {\r\n        require(_finney2LemoRate > 0);\r\n        require(_tokenContributionMin > 0);\r\n        require(_tokenContributionCap > 0);\r\n        require(_tokenContributionCap > _tokenContributionMin);\r\n\r\n        finney2LemoRate = _finney2LemoRate;\r\n        tokenContributionMin = _tokenContributionMin;\r\n        tokenContributionCap = _tokenContributionCap;\r\n    }\r\n\r\n    function initialize(uint256 _startTime, uint256 _endTime, uint256 _minPaymentFinney) public auth {\r\n        require(_startTime < _endTime);\r\n        require(_minPaymentFinney > 0);\r\n\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        // Ether is to big to pass in the function, So we use Finney. 1 Finney = 0.001 Ether\r\n        minPayment = _minPaymentFinney * 1 finney;\r\n    }\r\n\r\n    function setTokenContract(ERC20 tokenInstance) public auth {\r\n        assert(address(token) == address(0));\r\n        require(tokenInstance.balanceOf(owner) > tokenContributionMin);\r\n\r\n        token = tokenInstance;\r\n    }\r\n\r\n    function() public payable {\r\n        contribute();\r\n    }\r\n\r\n    function contribute() public payable between(startTime, endTime) {\r\n        uint256 max = tokenContributionCap;\r\n        uint256 oldSoldAmount = soldAmount;\r\n        require(oldSoldAmount < max);\r\n        require(msg.value >= minPayment);\r\n\r\n        uint256 reward = mul(msg.value, finney2LemoRate) / 1 finney;\r\n        uint256 refundEth = 0;\r\n\r\n        uint256 newSoldAmount = add(oldSoldAmount, reward);\r\n        if (newSoldAmount > max) {\r\n            uint over = newSoldAmount - max;\r\n            refundEth = over / finney2LemoRate * 1 finney;\r\n            reward = max - oldSoldAmount;\r\n            soldAmount = max;\r\n        } else {\r\n            soldAmount = newSoldAmount;\r\n        }\r\n\r\n        token.transferFrom(owner, msg.sender, reward);\r\n        Contribution(msg.sender, msg.value, reward);\r\n        contributionCount++;\r\n        if (refundEth > 0) {\r\n            Refund(msg.sender, refundEth);\r\n            msg.sender.transfer(refundEth);\r\n        }\r\n    }\r\n\r\n    function finalize() public auth {\r\n        require(funding);\r\n        require(block.timestamp >= endTime);\r\n        require(soldAmount >= tokenContributionMin);\r\n\r\n        funding = false;\r\n        Finalized(block.timestamp);\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    // Withdraw in 3 month after failed. So funds not locked in contract forever\r\n    function withdraw() public auth {\r\n        require(this.balance > 0);\r\n        require(block.timestamp >= endTime + 3600 * 24 * 30 * 3);\r\n\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    function destroy() public auth {\r\n        require(block.timestamp >= endTime + 3600 * 24 * 30 * 3);\r\n\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function refund() public {\r\n        require(funding);\r\n        require(block.timestamp >= endTime && soldAmount <= tokenContributionMin);\r\n\r\n        uint256 tokenAmount = token.balanceOf(msg.sender);\r\n        require(tokenAmount > 0);\r\n\r\n        // need user approve first\r\n        token.transferFrom(msg.sender, owner, tokenAmount);\r\n        soldAmount = sub(soldAmount, tokenAmount);\r\n\r\n        uint256 refundEth = tokenAmount / finney2LemoRate * 1 finney;\r\n        Refund(msg.sender, refundEth);\r\n        msg.sender.transfer(refundEth);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finney2LemoRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContributionCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContributionMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_minPaymentFinney\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenInstance\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"funding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContributionMin\",\"type\":\"uint256\"},{\"name\":\"_tokenContributionCap\",\"type\":\"uint256\"},{\"name\":\"_finney2LemoRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_return\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"LemoSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000a4cb8000000000000000000000000000000000000000000000000000000000066ff3000000000000000000000000000000000000000000000000000000000000000009","Library":"","SwarmSource":"bzzr://18e423b416b0be50b2aa27122e12633bd14950e2bf250ceea44bc599074d690c"}]}