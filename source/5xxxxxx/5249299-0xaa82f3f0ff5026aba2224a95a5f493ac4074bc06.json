{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Ownable {\r\n\r\n\t// Contract's owner.\r\n\taddress owner;\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire (msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Constructor.\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t// Returns current contract's owner.\r\n\tfunction getOwner() public constant returns(address) {\r\n\t\treturn owner;\r\n\t}\r\n\r\n\t// Transfers contract's ownership.\r\n\tfunction transferOwnership(address newOwner) onlyOwner public {\r\n\t\trequire(newOwner != address(0));\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\ncontract ICKBase {\r\n\r\n\tfunction ownerOf(uint256) public pure returns (address);\r\n}\r\n\r\ncontract IKittyKendoStorage {\r\n\r\n\tfunction createProposal(uint proposal, address proposalOwner) public;\r\n\tfunction createVoter(address account) public;\r\n\r\n\tfunction updateProposalOwner(uint proposal, address voter) public;\r\n\r\n\tfunction voterExists(address voter) public constant returns (bool);\r\n\tfunction proposalExists(uint proposal) public constant returns (bool);\r\n\r\n\tfunction proposalOwner(uint proposal) public constant returns (address);\r\n\tfunction proposalCreateTime(uint proposal) public constant returns (uint);\r\n\r\n\tfunction voterVotingTime(address voter) public constant returns (uint);\r\n\r\n\tfunction addProposalVote(uint proposal, address voter) public;\r\n\tfunction addVoterVote(address voter) public;\r\n\r\n\tfunction updateVoterTimes(address voter, uint time) public;\r\n\r\n\tfunction getProposalTTL() public constant returns (uint);\r\n\tfunction setProposalTTL(uint time) public;\r\n\r\n\tfunction getVotesPerProposal() public constant returns (uint);\r\n\tfunction setVotesPerProposal(uint votes) public;\r\n\r\n\tfunction getTotalProposalsCount() public constant returns(uint);\r\n\tfunction getTotalVotersCount() public constant returns(uint);\r\n\r\n\tfunction getProposalVotersCount(uint proposal) public constant returns(uint);\r\n\tfunction getProposalVotesCount(uint proposal) public constant returns(uint);\r\n\tfunction getProposalVoterVotesCount(uint proposal, address voter) public constant returns(uint);\r\n\r\n\tfunction getVoterProposalsCount(address voter) public constant returns(uint);\r\n\tfunction getVoterVotesCount(address voter) public constant returns(uint);\r\n\tfunction getVoterProposal(address voter, uint index) public constant returns(uint);\r\n}\r\n\r\ncontract KittyKendoCore is Ownable {\r\n\r\n\tIKittyKendoStorage kks;\r\n\taddress kksAddress;\r\n\r\n\t// Event is emitted when new votes have been recorded.\r\n\tevent VotesRecorded (\r\n\t\taddress indexed from,\r\n\t\tuint[] votes\r\n\t);\r\n\r\n\t// Event is emitted when new proposal has been added.\r\n\tevent ProposalAdded (\r\n\t\taddress indexed from,\r\n\t\tuint indexed proposal\r\n\t);\r\n\r\n\t// Registering fee.\r\n\tuint fee;\r\n\r\n\t// Constructor.\r\n\tfunction KittyKendoCore() public {\r\n\t\tfee = 0;\r\n\t\tkksAddress = address(0);\r\n\t}\r\n\t\r\n\t// Returns storage's address.\r\n\tfunction storageAddress() onlyOwner public constant returns(address) {\r\n\t\treturn kksAddress;\r\n\t}\r\n\r\n\t// Sets storage's address.\r\n\tfunction setStorageAddress(address addr) onlyOwner public {\r\n\t\tkksAddress = addr;\r\n\t\tkks = IKittyKendoStorage(kksAddress);\r\n\t}\r\n\r\n\t// Returns default register fee.\r\n\tfunction getFee() public constant returns(uint) {\r\n\t\treturn fee;\r\n\t}\r\n\r\n\t// Sets default register fee.\r\n\tfunction setFee(uint val) onlyOwner public {\r\n\t\tfee = val;\r\n\t}\r\n\r\n\t// Contract balance withdrawal.\r\n\tfunction withdraw(uint amount) onlyOwner public {\r\n\t\trequire(amount <= address(this).balance);\r\n\t\towner.transfer(amount);\r\n\t}\r\n\t\r\n\t// Returns contract's balance.\r\n\tfunction getBalance() onlyOwner public constant returns(uint) {\r\n\t    return address(this).balance;\r\n\t}\r\n\r\n\t// Registering proposal in replacement for provided votes.\r\n\tfunction registerProposal(uint proposal, uint[] votes) public payable {\r\n\r\n\t\t// Value must be at least equal to default fee.\r\n\t\trequire(msg.value >= fee);\r\n\r\n\t\trecordVotes(votes);\r\n\r\n\t\tif (proposal > 0) {\r\n\t\t\taddProposal(proposal);\r\n\t\t}\r\n\t}\r\n\r\n\t// Recording proposals votes.\r\n\tfunction recordVotes(uint[] votes) private {\r\n\r\n        require(kksAddress != address(0));\r\n\r\n\t\t// Checking if voter already exists, otherwise adding it.\r\n\t\tif (!kks.voterExists(msg.sender)) {\r\n\t\t\tkks.createVoter(msg.sender);\r\n\t\t}\r\n\r\n\t\t// Recording all passed votes from voter.\r\n\t\tfor (uint i = 0; i < votes.length; i++) {\r\n\t\t\t// Checking if proposal exists.\r\n\t\t\tif (kks.proposalExists(votes[i])) {\r\n\t\t\t\t// Proposal owner can't vote for own proposal.\r\n\t\t\t\trequire(kks.proposalOwner(votes[i]) != msg.sender);\r\n\r\n\t\t\t\t// Checking if proposal isn't expired yet.\r\n\t\t\t\tif (kks.proposalCreateTime(votes[i]) + kks.getProposalTTL() <= now) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Voter can vote for each proposal only once.\r\n\t\t\t\trequire(kks.getProposalVoterVotesCount(votes[i], msg.sender) == uint(0));\r\n\r\n\t\t\t\t// Adding proposal's voter and updating total votes count per proposal.\r\n\t\t\t\tkks.addProposalVote(votes[i], msg.sender);\r\n\t\t\t}\r\n\r\n\t\t\t// Recording vote per voter.\r\n\t\t\tkks.addVoterVote(msg.sender);\r\n\t\t}\r\n\r\n\t\t// Updating voter's last voting time and updating create time for voter's proposals.\r\n\t\tkks.updateVoterTimes(msg.sender, now);\r\n\r\n\t\t// Emitting event.\r\n\t\tVotesRecorded(msg.sender, votes);\r\n\t}\r\n\r\n\t// Adding new voter's proposal.\r\n\tfunction addProposal(uint proposal) private {\r\n\r\n        require(kksAddress != address(0));\r\n\r\n\t\t// Only existing voters can add own proposals.\r\n\t\trequire(kks.voterExists(msg.sender));\r\n\r\n\t\t// Checking if voter has enough votes count to add own proposal.\r\n\t\trequire(kks.getVoterVotesCount(msg.sender) / kks.getVotesPerProposal() > kks.getVoterProposalsCount(msg.sender));\r\n\r\n\t\t// Prevent voter from adding own proposal's too often.\r\n\t\t//require(now - kks.voterVotingTime(msg.sender) > 1 minutes);\r\n\r\n\t\t// Checking if proposal(i.e. Crypto Kitty Token) belongs to sender.\r\n\t\trequire(getCKOwner(proposal) == msg.sender);\r\n\r\n\t\t// Checking if proposal already exists.\r\n\t\tif (!kks.proposalExists(proposal)) {\r\n\t\t\t// Adding new proposal.\r\n\t\t\tkks.createProposal(proposal, msg.sender);\r\n\t\t} else {\r\n\t\t\t// Updating proposal's owner.\r\n\t\t\tkks.updateProposalOwner(proposal, msg.sender);\r\n\t\t}\r\n\r\n\t\t// Emitting event.\r\n\t\tProposalAdded(msg.sender, proposal);\r\n\t}\r\n\r\n\t// Returns the CryptoKitty's owner address.\r\n\tfunction getCKOwner(uint proposal) private pure returns(address) {\r\n\t\tICKBase ckBase = ICKBase(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d);\r\n\t\treturn ckBase.ownerOf(uint256(proposal));\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposal\",\"type\":\"uint256\"},{\"name\":\"votes\",\"type\":\"uint256[]\"}],\"name\":\"registerProposal\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setStorageAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"storageAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256[]\"}],\"name\":\"VotesRecorded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"}]","ContractName":"KittyKendoCore","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://67a5e89f24436226eb86ba55c95fb300abc1cf04933f5c45a6cc76f073c7acb6"}]}