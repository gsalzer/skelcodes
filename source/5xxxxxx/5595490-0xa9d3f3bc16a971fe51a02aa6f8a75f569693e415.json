{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/Utils/Math.sol\r\n\r\nlibrary MathUtils {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint result = a + b;\r\n\r\n        if (a == 0 || b == 0) {\r\n            return result;\r\n        }\r\n\r\n        require(result > a && result > b);\r\n\r\n        return result;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(a >= b);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint result = a * b;\r\n\r\n        require(result / a == b);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/Utils/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function isOwner() view public returns (bool) {\r\n        return msg.sender == owner;\r\n    }\r\n\r\n    modifier grantOwner {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/Crowdsale/CrowdsaleToken.sol\r\n\r\ninterface CrowdsaleToken {\r\n    function transfer(address destination, uint amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function burn(uint amount) external;\r\n}\r\n\r\n// File: contracts/Crowdsale/CryptoPoliceCrowdsale.sol\r\n\r\ncontract CryptoPoliceCrowdsale is Ownable {\r\n    using MathUtils for uint;\r\n    \r\n    enum CrowdsaleState {\r\n        Pending, Started, Ended, Paused, SoldOut\r\n    }\r\n\r\n    struct ExchangeRate {\r\n        uint tokens;\r\n        uint price;\r\n    }\r\n\r\n    struct Participant {\r\n        bool identified;\r\n        uint processedDirectWeiAmount;\r\n        uint processedExternalWeiAmount;\r\n        uint suspendedDirectWeiAmount;\r\n        uint suspendedExternalWeiAmount;\r\n    }\r\n\r\n    event ExternalPaymentReminder(uint weiAmount, bytes32 paymentChecksum);\r\n    event PaymentSuspended(address participant);\r\n    event PaymentProcessed(uint weiAmount, address participant, bytes32 paymentChecksum, uint tokenAmount);\r\n\r\n    uint public constant THRESHOLD1 = 270000000e18;\r\n    uint public constant THRESHOLD2 = 350000000e18;\r\n    uint public constant THRESHOLD3 = 490000000e18;\r\n    uint public constant THRESHOLD4 = 510000000e18;\r\n\r\n    uint public constant RELEASE_THRESHOLD = 27000500e18;\r\n\r\n    address public admin;\r\n\r\n    /**\r\n     * Amount of tokens sold in this crowdsale\r\n     */\r\n    uint public tokensSold;\r\n\r\n    /**\r\n     * Minimum number of Wei that can be exchanged for tokens\r\n     */\r\n    uint public minSale = 0.01 ether;\r\n    \r\n    /**\r\n     * Amount of direct Wei paid to the contract that has not yet been processed\r\n     */\r\n    uint public suspendedPayments = 0;\r\n\r\n    /**\r\n     * Token that will be sold\r\n     */\r\n    CrowdsaleToken public token;\r\n    \r\n    /**\r\n     * State in which the crowdsale is in\r\n     */\r\n    CrowdsaleState public state = CrowdsaleState.Pending;\r\n\r\n    /**\r\n     * List of exchange rates for each token volume\r\n     */\r\n    ExchangeRate[4] public exchangeRates;\r\n    \r\n    bool public crowdsaleEndedSuccessfully = false;\r\n\r\n    /**\r\n     * Number of Wei that can be paid without carrying out KYC process\r\n     */\r\n    uint public unidentifiedSaleLimit = 1 ether;\r\n\r\n    /**\r\n     * Crowdsale participants that have made payments\r\n     */\r\n    mapping(address => Participant) public participants;\r\n\r\n    /**\r\n     * Map external payment reference hash to that payment description\r\n     */\r\n    mapping(bytes32 => string) public externalPaymentDescriptions;\r\n\r\n    /**\r\n     * Map participants to list of their external payment reference hashes\r\n     */\r\n    mapping(address => bytes32[]) public participantExternalPaymentChecksums;\r\n\r\n    mapping(address => bytes32[]) public participantSuspendedExternalPaymentChecksums;\r\n\r\n    /**\r\n     * Map external payment checksum to payment amount\r\n     */\r\n    mapping(bytes32 => uint) public suspendedExternalPayments;\r\n\r\n    mapping(address => bool) public bannedParticipants;\r\n\r\n    bool public revertSuspendedPayment = false;\r\n\r\n    /**\r\n     * 1) Process payment when crowdsale started by sending tokens in return\r\n     * 2) Issue a refund when crowdsale ended unsuccessfully \r\n     */\r\n    function () public payable {\r\n        if (state == CrowdsaleState.Ended) {\r\n            msg.sender.transfer(msg.value);\r\n            refundParticipant(msg.sender);\r\n        } else {\r\n            require(state == CrowdsaleState.Started, \"Crowdsale currently inactive\");\r\n            processPayment(msg.sender, msg.value, \"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recursively caluclates number of tokens that can be exchanged for given payment \r\n     *\r\n     * @param salePosition Number of tokens processed in crowdsale so far\r\n     * @param _paymentReminder Number of Wei remaining from payment so far\r\n     * @param _processedTokenCount Number of tokens that can be exchanged so far\r\n     *\r\n     * @return paymentReminder Number of Wei remaining from payment\r\n     * @return processedTokenCount Number of tokens that can be exchanged\r\n     * @return soldOut Indicates whether or not there would be no more tokens left after this exchange\r\n     */\r\n    function exchangeCalculator(uint salePosition, uint _paymentReminder, uint _processedTokenCount)\r\n    internal view returns (uint paymentReminder, uint processedTokenCount, bool soldOut)\r\n    {\r\n        uint threshold = getTreshold(salePosition);\r\n        ExchangeRate memory currentExchangeRate = getExchangeRate(threshold);\r\n\r\n        // how many round number of portions are left for exchange\r\n        uint availablePortions = (threshold - salePosition) / currentExchangeRate.tokens;\r\n\r\n        // this indicates that there are no leftover tokens that can be exchanged\r\n        // without stepping over threshold\r\n        if (availablePortions == 0) {\r\n            if (threshold == THRESHOLD4) {\r\n                return (_paymentReminder, _processedTokenCount, true);\r\n            }\r\n            // move sale position to current threshold\r\n            return exchangeCalculator(threshold, _paymentReminder, _processedTokenCount);\r\n        }\r\n\r\n        uint requestedPortions = _paymentReminder / currentExchangeRate.price;\r\n        uint portions = requestedPortions > availablePortions ? availablePortions : requestedPortions;\r\n        uint newProcessedTokenCount = _processedTokenCount + portions * currentExchangeRate.tokens;\r\n        uint newPaymentReminder = _paymentReminder - portions * currentExchangeRate.price;\r\n        uint newSalePosition = salePosition + newProcessedTokenCount;\r\n\r\n        if (newPaymentReminder < currentExchangeRate.price) {\r\n            return (newPaymentReminder, newProcessedTokenCount, false);\r\n        }\r\n        \r\n        return exchangeCalculator(newSalePosition, newPaymentReminder, newProcessedTokenCount);\r\n    }\r\n\r\n    function processPayment(address participant, uint payment, bytes32 externalPaymentChecksum) internal {\r\n        require(payment >= minSale, \"Payment must be greather or equal to sale minimum\");\r\n        require(bannedParticipants[participant] == false, \"Participant is banned\");\r\n\r\n        uint paymentReminder;\r\n        uint processedTokenCount;\r\n        bool soldOut;\r\n\r\n        (paymentReminder, processedTokenCount, soldOut) = exchangeCalculator(tokensSold, payment, 0);\r\n\r\n        // how much was actually spent from this payment\r\n        uint spent = payment - paymentReminder;\r\n        bool directPayment = externalPaymentChecksum == \"\";\r\n\r\n        if (participants[participant].identified == false) {\r\n            // how much participant has spent in crowdsale so far\r\n            uint spendings = participants[participant].processedDirectWeiAmount\r\n                .add(participants[participant].processedExternalWeiAmount).add(spent);\r\n\r\n            bool hasSuspendedPayments = participants[participant].suspendedDirectWeiAmount > 0 || participants[participant].suspendedExternalWeiAmount > 0;\r\n\r\n            // due to fluctuations of unidentified payment limit, it might not be reached\r\n            // suspend current payment if participant currently has suspended payments or limit reached\r\n            if (hasSuspendedPayments || spendings > unidentifiedSaleLimit) {\r\n                require(revertSuspendedPayment == false, \"Participant does not comply with KYC\");\r\n\r\n                suspendedPayments = suspendedPayments + payment;\r\n\r\n                if (directPayment) {\r\n                    participants[participant].suspendedDirectWeiAmount = participants[participant].suspendedDirectWeiAmount.add(payment);\r\n                } else {\r\n                    participantSuspendedExternalPaymentChecksums[participant].push(externalPaymentChecksum);\r\n                    participants[participant].suspendedExternalWeiAmount = participants[participant].suspendedExternalWeiAmount.add(payment);\r\n                    suspendedExternalPayments[externalPaymentChecksum] = payment;\r\n                }\r\n\r\n                emit PaymentSuspended(participant);\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        // unspent reminder must be returned back to participant\r\n        if (paymentReminder > 0) {\r\n            if (directPayment) {\r\n                participant.transfer(paymentReminder);\r\n            } else {\r\n                emit ExternalPaymentReminder(paymentReminder, externalPaymentChecksum);\r\n            }\r\n        }\r\n\r\n        if (directPayment) {\r\n            participants[participant].processedDirectWeiAmount = participants[participant].processedDirectWeiAmount.add(spent);\r\n        } else {\r\n            participants[participant].processedExternalWeiAmount = participants[participant].processedExternalWeiAmount.add(spent);\r\n        }\r\n\r\n        require(token.transfer(participant, processedTokenCount), \"Failed to transfer tokens\");\r\n        \r\n        if (soldOut) {\r\n            state = CrowdsaleState.SoldOut;\r\n        }\r\n        \r\n        tokensSold = tokensSold + processedTokenCount;\r\n\r\n        emit PaymentProcessed(spent, participant, externalPaymentChecksum, processedTokenCount);\r\n    }\r\n\r\n    /**\r\n     * Intended when other currencies are received and owner has to carry out exchange\r\n     * for those payments aligned to Wei\r\n     */\r\n    function proxyExchange(address beneficiary, uint payment, string description, bytes32 checksum)\r\n    public grantOwnerOrAdmin\r\n    {\r\n        require(beneficiary != address(0), \"Beneficiary not specified\");\r\n        require(bytes(description).length > 0, \"Description not specified\");\r\n        require(checksum.length > 0, \"Checksum not specified\");\r\n        // make sure that payment has not been processed yet\r\n        require(bytes(externalPaymentDescriptions[checksum]).length == 0, \"Payment already processed\");\r\n\r\n        processPayment(beneficiary, payment, checksum);\r\n        \r\n        externalPaymentDescriptions[checksum] = description;\r\n        participantExternalPaymentChecksums[beneficiary].push(checksum);\r\n    }\r\n\r\n    /**\r\n     * Command for owner to start crowdsale\r\n     */\r\n    function startCrowdsale(address crowdsaleToken, address adminAddress) public grantOwner {\r\n        require(state == CrowdsaleState.Pending);\r\n        setAdmin(adminAddress);\r\n        token = CrowdsaleToken(crowdsaleToken);\r\n        require(token.balanceOf(address(this)) == 510000000e18);\r\n        state = CrowdsaleState.Started;\r\n    }\r\n\r\n    function pauseCrowdsale() public grantOwnerOrAdmin {\r\n        require(state == CrowdsaleState.Started);\r\n        state = CrowdsaleState.Paused;\r\n    }\r\n\r\n    function unPauseCrowdsale() public grantOwnerOrAdmin {\r\n        require(state == CrowdsaleState.Paused);\r\n        state = CrowdsaleState.Started;\r\n    }\r\n\r\n    /**\r\n     * Command for owner to end crowdsale\r\n     */\r\n    function endCrowdsale(bool success) public grantOwner notEnded {\r\n        state = CrowdsaleState.Ended;\r\n        crowdsaleEndedSuccessfully = success;\r\n\r\n        uint balance = address(this).balance;\r\n\r\n        if (success && balance > 0) {\r\n            uint amount = balance.sub(suspendedPayments);\r\n            owner.transfer(amount);\r\n        }\r\n    }\r\n\r\n    function markParticipantIdentifiend(address participant) public grantOwnerOrAdmin notEnded {\r\n        participants[participant].identified = true;\r\n\r\n        if (participants[participant].suspendedDirectWeiAmount > 0) {\r\n            processPayment(participant, participants[participant].suspendedDirectWeiAmount, \"\");\r\n            suspendedPayments = suspendedPayments.sub(participants[participant].suspendedDirectWeiAmount);\r\n            participants[participant].suspendedDirectWeiAmount = 0;\r\n        }\r\n\r\n        if (participants[participant].suspendedExternalWeiAmount > 0) {\r\n            bytes32[] storage checksums = participantSuspendedExternalPaymentChecksums[participant];\r\n            for (uint i = 0; i < checksums.length; i++) {\r\n                processPayment(participant, suspendedExternalPayments[checksums[i]], checksums[i]);\r\n                suspendedExternalPayments[checksums[i]] = 0;\r\n            }\r\n            participants[participant].suspendedExternalWeiAmount = 0;\r\n            participantSuspendedExternalPaymentChecksums[participant] = new bytes32[](0);\r\n        }\r\n    }\r\n\r\n    function unidentifyParticipant(address participant) public grantOwnerOrAdmin notEnded {\r\n        participants[participant].identified = false;\r\n    }\r\n\r\n    function returnSuspendedPayments(address participant) public grantOwnerOrAdmin {\r\n        returnDirectPayments(participant, false, true);\r\n        returnExternalPayments(participant, false, true);\r\n    }\r\n\r\n    function updateUnidentifiedSaleLimit(uint limit) public grantOwnerOrAdmin notEnded {\r\n        unidentifiedSaleLimit = limit;\r\n    }\r\n\r\n    function updateMinSale(uint weiAmount) public grantOwnerOrAdmin {\r\n        minSale = weiAmount;\r\n    }\r\n\r\n    /**\r\n     * Allow crowdsale participant to get refunded\r\n     */\r\n    function refundParticipant(address participant) internal {\r\n        require(state == CrowdsaleState.Ended);\r\n        require(crowdsaleEndedSuccessfully == false);\r\n        \r\n        returnDirectPayments(participant, true, true);\r\n        returnExternalPayments(participant, true, true);\r\n    }\r\n\r\n    function refund(address participant) public grantOwner {\r\n        refundParticipant(participant);\r\n    }\r\n\r\n    function burnLeftoverTokens(uint8 percentage) public grantOwner {\r\n        require(state == CrowdsaleState.Ended);\r\n        require(percentage <= 100 && percentage > 0);\r\n\r\n        uint balance = token.balanceOf(address(this));\r\n\r\n        if (balance > 0) {\r\n            uint amount = balance / (100 / percentage);\r\n            token.burn(amount);\r\n        }\r\n    }\r\n\r\n    function updateExchangeRate(uint8 idx, uint tokens, uint price) public grantOwnerOrAdmin {\r\n        require(tokens > 0 && price > 0);\r\n        require(idx >= 0 && idx <= 3);\r\n\r\n        exchangeRates[idx] = ExchangeRate({\r\n            tokens: tokens,\r\n            price: price\r\n        });\r\n    }\r\n\r\n    function ban(address participant) public grantOwnerOrAdmin {\r\n        bannedParticipants[participant] = true;\r\n    }\r\n\r\n    function unBan(address participant) public grantOwnerOrAdmin {\r\n        bannedParticipants[participant] = false;\r\n    }\r\n\r\n    function getExchangeRate(uint threshold) internal view returns (ExchangeRate) {\r\n        uint8 idx = exchangeRateIdx(threshold);\r\n\r\n        ExchangeRate storage rate = exchangeRates[idx];\r\n\r\n        require(rate.tokens > 0 && rate.price > 0, \"Exchange rate not set\");\r\n\r\n        return rate;\r\n    }\r\n\r\n    function getTreshold(uint salePosition) internal pure returns (uint) {\r\n        if (salePosition < THRESHOLD1) {\r\n            return THRESHOLD1;\r\n        }\r\n        if (salePosition < THRESHOLD2) {\r\n            return THRESHOLD2;\r\n        }\r\n        if (salePosition < THRESHOLD3) {\r\n            return THRESHOLD3;\r\n        }\r\n        if (salePosition < THRESHOLD4) {\r\n            return THRESHOLD4;\r\n        }\r\n\r\n        assert(false);\r\n    }\r\n\r\n    function exchangeRateIdx(uint threshold) internal pure returns (uint8) {\r\n        if (threshold == THRESHOLD1) {\r\n            return 0;\r\n        }\r\n        if (threshold == THRESHOLD2) {\r\n            return 1;\r\n        }\r\n        if (threshold == THRESHOLD3) {\r\n            return 2;\r\n        }\r\n        if (threshold == THRESHOLD4) {\r\n            return 3;\r\n        }\r\n\r\n        assert(false);\r\n    }\r\n\r\n    function updateRevertSuspendedPayment(bool value) public grantOwnerOrAdmin {\r\n        revertSuspendedPayment = value;\r\n    }\r\n\r\n    /**\r\n     * Transfer Wei sent to the contract directly back to the participant\r\n     *\r\n     * @param participant Participant\r\n     * @param processed Whether or not processed payments should be included\r\n     * @param suspended Whether or not suspended payments should be included\r\n     */\r\n    function returnDirectPayments(address participant, bool processed, bool suspended) internal {\r\n        if (processed && participants[participant].processedDirectWeiAmount > 0) {\r\n            participant.transfer(participants[participant].processedDirectWeiAmount);\r\n            participants[participant].processedDirectWeiAmount = 0;\r\n        }\r\n\r\n        if (suspended && participants[participant].suspendedDirectWeiAmount > 0) {\r\n            participant.transfer(participants[participant].suspendedDirectWeiAmount);\r\n            participants[participant].suspendedDirectWeiAmount = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Signal that externally made payments should be returned back to the participant\r\n     *\r\n     * @param participant Participant\r\n     * @param processed Whether or not processed payments should be included\r\n     * @param suspended Whether or not suspended payments should be included\r\n     */\r\n    function returnExternalPayments(address participant, bool processed, bool suspended) internal {\r\n        if (processed && participants[participant].processedExternalWeiAmount > 0) {\r\n            participants[participant].processedExternalWeiAmount = 0;\r\n        }\r\n        \r\n        if (suspended && participants[participant].suspendedExternalWeiAmount > 0) {\r\n            participants[participant].suspendedExternalWeiAmount = 0;\r\n        }\r\n    }\r\n\r\n    function setAdmin(address adminAddress) public grantOwner {\r\n        admin = adminAddress;\r\n        require(isAdminSet());\r\n    }\r\n\r\n    function transwerFunds(uint amount) public grantOwner {\r\n        require(RELEASE_THRESHOLD <= tokensSold, \"There are not enaugh tokens sold\");\r\n        \r\n        uint transferAmount = amount;\r\n        uint balance = address(this).balance;\r\n\r\n        if (balance < amount) {\r\n            transferAmount = balance;\r\n        }\r\n\r\n        owner.transfer(transferAmount);\r\n    } \r\n\r\n    function isAdminSet() internal view returns(bool) {\r\n        return admin != address(0);\r\n    }\r\n\r\n    function isAdmin() internal view returns(bool) {\r\n        return isAdminSet() && msg.sender == admin;\r\n    }\r\n\r\n    function isCrowdsaleSuccessful() public view returns(bool) {\r\n        return state == CrowdsaleState.Ended && crowdsaleEndedSuccessfully;\r\n    }\r\n\r\n    modifier notEnded {\r\n        require(state != CrowdsaleState.Ended, \"Crowdsale ended\");\r\n        _;\r\n    }\r\n\r\n    modifier grantOwnerOrAdmin() {\r\n        require(isOwner() || isAdmin());\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"identified\",\"type\":\"bool\"},{\"name\":\"processedDirectWeiAmount\",\"type\":\"uint256\"},{\"name\":\"processedExternalWeiAmount\",\"type\":\"uint256\"},{\"name\":\"suspendedDirectWeiAmount\",\"type\":\"uint256\"},{\"name\":\"suspendedExternalWeiAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"markParticipantIdentifiend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndedSuccessfully\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"percentage\",\"type\":\"uint8\"}],\"name\":\"burnLeftoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"suspendedPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint8\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updateExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"suspendedExternalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"THRESHOLD4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unPauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"returnSuspendedPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"crowdsaleToken\",\"type\":\"address\"},{\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"externalPaymentDescriptions\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"THRESHOLD3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exchangeRates\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"payment\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"checksum\",\"type\":\"bytes32\"}],\"name\":\"proxyExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"updateMinSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"updateRevertSuspendedPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participantSuspendedExternalPaymentChecksums\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"ban\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revertSuspendedPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"updateUnidentifiedSaleLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participantExternalPaymentChecksums\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsaleSuccessful\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"unBan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bannedParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unidentifiedSaleLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"unidentifyParticipant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RELEASE_THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transwerFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"THRESHOLD2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"THRESHOLD1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentChecksum\",\"type\":\"bytes32\"}],\"name\":\"ExternalPaymentReminder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"PaymentSuspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"paymentChecksum\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"PaymentProcessed\",\"type\":\"event\"}]","ContractName":"CryptoPoliceCrowdsale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://21071822b9b33c0cb33d2145fbc3b0bf3be58020674ff94b650a573f11c14682"}]}