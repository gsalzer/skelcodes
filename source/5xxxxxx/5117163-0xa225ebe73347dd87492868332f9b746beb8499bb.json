{"status":"1","message":"OK","result":[{"SourceCode":"//A BurnablePayment is instantiated with one \"opening agent\" (Payer or Worker), a title, an initial deposit, a commitThreshold, and an autoreleaseInterval.\r\n//If the opening agent is the payer:\r\n//    The contract starts in the PayerOpened state.\r\n//    Payer is expected to request some service via the title and additional statements.\r\n//    The initial deposit represents the amount Payer will pay for the service.\r\n//    Another user can claim the job by calling commit() and becoming the worker.\r\n//If the opening agent is the worker:\r\n//    The contract starts in the WorkerOpened state.\r\n//    Worker is expected to offer some service via the title and additional statements.\r\n//    The initial deposit serves as collateral that a payer will have control over.\r\n//    Another user can claim the service by calling commit() and becoming the payer.\r\n\r\n//While in either Open state,\r\n//    The opening agent can call recover() to destroy the contract and refund all deposited funds.\r\n//    The opening agent can log statements to add additional details, clarifications, or corrections.\r\n//    Anyone can enter the contract as the open role by contributing the commitThreshold with commit();\r\n//        this changes the state to Committed.\r\n\r\n//Upon changing from either Open state -> Committed:\r\n//    AutoreleaseTime is set to (now + autoreleaseInterval).\r\n\r\n//In the Committed state:\r\n//    Both roles are permanent.\r\n//    Both Payer and Worker can log statements.\r\n//    Payer can at any time choose to burn() or release() to Worker any amount of funds.\r\n//    Payer can delayAutorelease(), setting the autoreleaseTime to (now + autoreleaseInterval), any number of times.\r\n//    If autoreleaseTime comes, Worker can triggerAutorelease() to claim all ether remaining in the payment.\r\n//    Once the balance of the payment is 0, the state changes to Closed.\r\n\r\n//In the Closed state:\r\n//    Payer and Worker can still log statements.\r\n//    If addFunds() is called, the contract returns to the Committed state.\r\n\r\npragma solidity ^ 0.4.2;\r\n\r\ncontract BurnablePaymentFactory {\r\n    \r\n    //contract address array\r\n    address[]public BPs;\r\n\r\n    event NewBurnablePayment(\r\n        address indexed bpAddress, \r\n        bool payerOpened, \r\n        address creator, \r\n        uint deposited, \r\n        uint commitThreshold, \r\n        uint autoreleaseInterval, \r\n        string title, \r\n        string initialStatement\r\n    );  \r\n\r\n    function newBP(bool payerOpened, address creator, uint commitThreshold, uint autoreleaseInterval, string title, string initialStatement)\r\n    public\r\n    payable\r\n    returns (address newBPAddr) \r\n    {\r\n        //pass along any ether to the constructor\r\n        newBPAddr = (new BurnablePayment).value(msg.value)(payerOpened, creator, commitThreshold, autoreleaseInterval, title, initialStatement);\r\n        NewBurnablePayment(newBPAddr, payerOpened, creator, msg.value, commitThreshold, autoreleaseInterval, title, initialStatement);\r\n\r\n        BPs.push(newBPAddr);\r\n\r\n        return newBPAddr;\r\n    }\r\n\r\n    function getBPCount()\r\n    public\r\n    constant\r\n    returns(uint) \r\n    {\r\n        return BPs.length;\r\n    }\r\n}\r\n\r\ncontract BurnablePayment {\r\n    //title will never change\r\n    string public title;\r\n    \r\n    //BP will start with a payer or a worker but not both\r\n    address public payer;\r\n    address public worker;\r\n    address constant BURN_ADDRESS = 0x0;\r\n    \r\n    //Set to true if fundsRecovered is called\r\n    bool recovered = false;\r\n\r\n    //Note that these will track, but not influence the BP logic.\r\n    uint public amountDeposited;\r\n    uint public amountBurned;\r\n    uint public amountReleased;\r\n\r\n    //Amount of ether that must be deposited via commit() to become the second party of the BP.\r\n    uint public commitThreshold;\r\n\r\n    //How long should we wait before allowing the default release to be called?\r\n    uint public autoreleaseInterval;\r\n\r\n    //Calculated from autoreleaseInterval in commit(),\r\n    //and recaluclated whenever the payer (or possibly the worker) calls delayhasDefaultRelease()\r\n    //After this time, auto-release can be called by the Worker.\r\n    uint public autoreleaseTime;\r\n\r\n    //Most action happens in the Committed state.\r\n    enum State {\r\n        PayerOpened,\r\n        WorkerOpened,\r\n        Committed,\r\n        Closed\r\n    }\r\n\r\n    //Note that a BP cannot go from Committed back to either Open state, but it can go from Closed back to Committed\r\n    //Search for Closed and Unclosed events to see how this works.\r\n    State public state;\r\n\r\n    modifier inState(State s) {\r\n        require(s == state);\r\n        _;\r\n    }\r\n    modifier inOpenState() {\r\n        require(state == State.PayerOpened || state == State.WorkerOpened);\r\n        _;\r\n    }\r\n    modifier onlyPayer() {\r\n        require(msg.sender == payer);\r\n        _;\r\n    }\r\n    modifier onlyWorker() {\r\n        require(msg.sender == worker);\r\n        _;\r\n    }\r\n    modifier onlyPayerOrWorker() {\r\n        require((msg.sender == payer) || (msg.sender == worker));\r\n        _;\r\n    }\r\n    modifier onlyCreatorWhileOpen() {\r\n        if (state == State.PayerOpened) {\r\n            require(msg.sender == payer);\r\n        } else if (state == State.WorkerOpened) {\r\n            require(msg.sender == worker);\r\n        } else {\r\n            revert();        \r\n        }\r\n        _;\r\n    }\r\n\r\n    event Created(address indexed contractAddress, bool payerOpened, address creator, uint commitThreshold, uint autoreleaseInterval, string title);\r\n    event FundsAdded(address from, uint amount); //The payer has added funds to the BP.\r\n    event PayerStatement(string statement);\r\n    event WorkerStatement(string statement);\r\n    event FundsRecovered();\r\n    event Committed(address committer);\r\n    event FundsBurned(uint amount);\r\n    event FundsReleased(uint amount);\r\n    event Closed();\r\n    event Unclosed();\r\n    event AutoreleaseDelayed();\r\n    event AutoreleaseTriggered();\r\n\r\n    function BurnablePayment(bool payerIsOpening, address creator, uint _commitThreshold, uint _autoreleaseInterval, string _title, string initialStatement)\r\n    public\r\n    payable \r\n    {\r\n        Created(this, payerIsOpening, creator, _commitThreshold, autoreleaseInterval, title);\r\n\r\n        if (msg.value > 0) {\r\n            //Here we use tx.origin instead of msg.sender (msg.sender is just the factory contract)\r\n            FundsAdded(tx.origin, msg.value);\r\n            amountDeposited += msg.value;\r\n        }\r\n        \r\n        title = _title;\r\n\r\n        if (payerIsOpening) {\r\n            state = State.PayerOpened;\r\n            payer = creator;\r\n        } else {\r\n            state = State.WorkerOpened;\r\n            worker = creator;\r\n        }\r\n\r\n        commitThreshold = _commitThreshold;\r\n        autoreleaseInterval = _autoreleaseInterval;\r\n\r\n        if (bytes(initialStatement).length > 0) {\r\n            if (payerIsOpening) {\r\n                PayerStatement(initialStatement);\r\n            } else {\r\n                WorkerStatement(initialStatement);              \r\n            }\r\n        }\r\n    }\r\n\r\n    function addFunds()\r\n    public\r\n    payable\r\n    onlyPayerOrWorker()\r\n    {\r\n        require(msg.value > 0);\r\n\r\n        FundsAdded(msg.sender, msg.value);\r\n        amountDeposited += msg.value;\r\n        if (state == State.Closed) {\r\n            state = State.Committed;\r\n            Unclosed();\r\n        }\r\n    }\r\n\r\n    function recoverFunds()\r\n    public\r\n    onlyCreatorWhileOpen()\r\n    {\r\n        recovered = true;\r\n        FundsRecovered();\r\n        \r\n        if (state == State.PayerOpened)\r\n            selfdestruct(payer);\r\n        else if (state == State.WorkerOpened)\r\n            selfdestruct(worker);\r\n    }\r\n\r\n    function commit()\r\n    public\r\n    inOpenState()\r\n    payable \r\n    {\r\n        require(msg.value == commitThreshold);\r\n\r\n        if (msg.value > 0) {\r\n            FundsAdded(msg.sender, msg.value);\r\n            amountDeposited += msg.value;\r\n        }\r\n\r\n        if (state == State.PayerOpened)\r\n            worker = msg.sender;\r\n        else\r\n            payer = msg.sender;\r\n        state = State.Committed;\r\n        \r\n        Committed(msg.sender);\r\n\r\n        autoreleaseTime = now + autoreleaseInterval;\r\n    }\r\n\r\n    function internalBurn(uint amount)\r\n    private \r\n    {\r\n        BURN_ADDRESS.transfer(amount);\r\n\r\n        amountBurned += amount;\r\n        FundsBurned(amount);\r\n\r\n        if (this.balance == 0) {\r\n            state = State.Closed;\r\n            Closed();\r\n        }\r\n    }\r\n\r\n    function burn(uint amount)\r\n    public\r\n    inState(State.Committed)\r\n    onlyPayer() \r\n    {\r\n        internalBurn(amount);\r\n    }\r\n\r\n    function internalRelease(uint amount)\r\n    private \r\n    {\r\n        worker.transfer(amount);\r\n\r\n        amountReleased += amount;\r\n        FundsReleased(amount);\r\n\r\n        if (this.balance == 0) {\r\n            state = State.Closed;\r\n            Closed();\r\n        }\r\n    }\r\n\r\n    function release(uint amount)\r\n    public\r\n    inState(State.Committed)\r\n    onlyPayer() \r\n    {\r\n        internalRelease(amount);\r\n    }\r\n\r\n    function logPayerStatement(string statement)\r\n    public\r\n    onlyPayer() \r\n    {\r\n        PayerStatement(statement);\r\n    }\r\n\r\n    function logWorkerStatement(string statement)\r\n    public\r\n    onlyWorker() \r\n    {\r\n        WorkerStatement(statement);\r\n    }\r\n\r\n    function delayAutorelease()\r\n    public\r\n    onlyPayer()\r\n    inState(State.Committed) \r\n    {\r\n        autoreleaseTime = now + autoreleaseInterval;\r\n        AutoreleaseDelayed();\r\n    }\r\n\r\n    function triggerAutorelease()\r\n    public\r\n    onlyWorker()\r\n    inState(State.Committed) \r\n    {\r\n        require(now >= autoreleaseTime);\r\n\r\n        AutoreleaseTriggered();\r\n        internalRelease(this.balance);\r\n    }\r\n    \r\n    function getFullState()\r\n    public\r\n    constant\r\n    returns(State, address, address, string, uint, uint, uint, uint, uint, uint, uint) {\r\n        return (state, payer, worker, title, this.balance, commitThreshold, amountDeposited, amountBurned, amountReleased, autoreleaseInterval, autoreleaseTime);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BPs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payerOpened\",\"type\":\"bool\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"commitThreshold\",\"type\":\"uint256\"},{\"name\":\"autoreleaseInterval\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"initialStatement\",\"type\":\"string\"}],\"name\":\"newBP\",\"outputs\":[{\"name\":\"newBPAddr\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBPCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bpAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payerOpened\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deposited\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"commitThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"autoreleaseInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"title\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"initialStatement\",\"type\":\"string\"}],\"name\":\"NewBurnablePayment\",\"type\":\"event\"}]","ContractName":"BurnablePaymentFactory","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://741a7a39a3e19ff0d4fbca0be68af7c88dde7858eaa0d358808ece68f3af60c3"}]}