{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2018-04-20\r\n*/\r\n\r\npragma solidity 0.4.19;\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/DisbursementHandler.sol\r\n\r\n/// @title Disbursement handler - Manages time locked disbursements of ERC20 tokens\r\ncontract DisbursementHandler is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Disbursement {\r\n        // Tokens cannot be withdrawn before this timestamp\r\n        uint256 timestamp;\r\n\r\n        // Amount of tokens to be disbursed\r\n        uint256 tokens;\r\n    }\r\n\r\n    event LogSetup(address indexed vestor, uint256 timestamp, uint256 tokens);\r\n    event LogWithdraw(address indexed to, uint256 value);\r\n\r\n    ERC20 public token;\r\n    uint256 public totalAmount;\r\n    mapping(address => Disbursement[]) public disbursements;\r\n    mapping(address => uint256) public withdrawnTokens;\r\n\r\n    function DisbursementHandler(address _token) public {\r\n        token = ERC20(_token);\r\n    }\r\n\r\n    /// @dev Called by the sale contract to create a disbursement.\r\n    /// @param vestor The address of the beneficiary.\r\n    /// @param tokens Amount of tokens to be locked.\r\n    /// @param timestamp Funds will be locked until this timestamp.\r\n    function setupDisbursement(\r\n        address vestor,\r\n        uint256 tokens,\r\n        uint256 timestamp\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(block.timestamp < timestamp);\r\n        disbursements[vestor].push(Disbursement(timestamp, tokens));\r\n        totalAmount = totalAmount.add(tokens);\r\n        LogSetup(vestor, timestamp, tokens);\r\n    }\r\n\r\n    /// @dev Transfers tokens to the withdrawer\r\n    function withdraw()\r\n        external\r\n    {\r\n        uint256 withdrawAmount = calcMaxWithdraw(msg.sender);\r\n        require(withdrawAmount != 0);\r\n        withdrawnTokens[msg.sender] = withdrawnTokens[msg.sender].add(withdrawAmount);\r\n        require(token.transfer(msg.sender, withdrawAmount));\r\n        LogWithdraw(msg.sender, withdrawAmount);\r\n    }\r\n\r\n    /// @dev Calculates the maximum amount of vested tokens\r\n    /// @return Number of vested tokens that can be withdrawn\r\n    function calcMaxWithdraw(address beneficiary)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 maxTokens = 0;\r\n\r\n        // Go over all the disbursements and calculate how many tokens can be withdrawn\r\n        Disbursement[] storage temp = disbursements[beneficiary];\r\n        uint256 tempLength = temp.length;\r\n        for (uint256 i = 0; i < tempLength; i++) {\r\n            if (block.timestamp > temp[i].timestamp) {\r\n                maxTokens = maxTokens.add(temp[i].tokens);\r\n            }\r\n        }\r\n\r\n        // Return the computed amount minus the tokens already withdrawn\r\n        return maxTokens.sub(withdrawnTokens[beneficiary]);\r\n    }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/Vault.sol\r\n\r\n// Adapted from Open Zeppelin's RefundVault\r\n\r\n/**\r\n * @title Vault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\n * and forwarding it if crowdsale is successful.\r\n */\r\ncontract Vault is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    enum State { Active, Success, Refunding, Closed }\r\n\r\n    uint256 public constant DISBURSEMENT_DURATION = 4 weeks;\r\n\r\n    mapping (address => uint256) public deposited;\r\n    uint256 public disbursementAmount; // The amount to be disbursed to the wallet every month\r\n    address public trustedWallet; // Wallet from the project team\r\n\r\n    uint256 public initialAmount; // The eth amount the team will get initially if the sale is successful\r\n\r\n    uint256 public lastDisbursement; // Timestamp of the last disbursement made\r\n\r\n    uint256 public totalDeposited; // Total amount that was deposited\r\n    uint256 public refundable; // Amount that can be refunded\r\n\r\n    uint256 public closingDuration;\r\n    uint256 public closingDeadline; // Vault can't be closed before this deadline\r\n\r\n    State public state;\r\n\r\n    event LogClosed();\r\n    event LogRefundsEnabled();\r\n    event LogRefunded(address indexed contributor, uint256 amount);\r\n\r\n    modifier atState(State _state) {\r\n        require(state == _state);\r\n        _;\r\n    }\r\n\r\n    function Vault(\r\n        address wallet,\r\n        uint256 _initialAmount,\r\n        uint256 _disbursementAmount,\r\n        uint256 _closingDuration\r\n    ) \r\n        public \r\n    {\r\n        require(wallet != address(0));\r\n        require(_disbursementAmount != 0);\r\n        require(_closingDuration != 0);\r\n        trustedWallet = wallet;\r\n        initialAmount = _initialAmount;\r\n        disbursementAmount = _disbursementAmount;\r\n        closingDuration = _closingDuration;\r\n        state = State.Active;\r\n    }\r\n\r\n    /// @dev Called by the sale contract to deposit ether for a contributor.\r\n    function deposit(address contributor) onlyOwner external payable {\r\n        require(state == State.Active || state == State.Success);\r\n        totalDeposited = totalDeposited.add(msg.value);\r\n        refundable = refundable.add(msg.value);\r\n        deposited[contributor] = deposited[contributor].add(msg.value);\r\n    }\r\n\r\n    /// @dev Sends initial funds to the wallet.\r\n    function saleSuccessful() onlyOwner external atState(State.Active){\r\n        state = State.Success;\r\n        refundable = refundable.sub(initialAmount);\r\n        if (initialAmount != 0) {\r\n          trustedWallet.transfer(initialAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Called by the owner if the project didn't deliver the testnet contracts or if we need to stop disbursements for any reasone.\r\n    function enableRefunds() onlyOwner external {\r\n        state = State.Refunding;\r\n        LogRefundsEnabled();\r\n    }\r\n\r\n    /// @dev Refunds ether to the contributors if in the Refunding state.\r\n    function refund(address contributor) external atState(State.Refunding) {\r\n        uint256 refundAmount = deposited[contributor].mul(refundable).div(totalDeposited);\r\n        deposited[contributor] = 0;\r\n        contributor.transfer(refundAmount);\r\n        LogRefunded(contributor, refundAmount);\r\n    }\r\n\r\n    /// @dev Sets the closingDeadline variable\r\n    function beginClosingPeriod() external onlyOwner atState(State.Success) {\r\n        require(closingDeadline == 0);\r\n        closingDeadline = now.add(closingDuration);\r\n    }\r\n\r\n    /// @dev Called by anyone if the sale was successful and the project delivered.\r\n    function close() external atState(State.Success) {\r\n        require(closingDeadline != 0 && closingDeadline <= now);\r\n        state = State.Closed;\r\n        LogClosed();\r\n    }\r\n\r\n    /// @dev Sends the disbursement amount to the wallet after the disbursement period has passed. Can be called by anyone.\r\n    function sendFundsToWallet() external atState(State.Closed) {\r\n        require(lastDisbursement.add(DISBURSEMENT_DURATION) <= now);\r\n\r\n        lastDisbursement = now;\r\n        uint256 amountToSend = Math.min256(address(this).balance, disbursementAmount);\r\n        refundable = amountToSend > refundable ? 0 : refundable.sub(amountToSend);\r\n        trustedWallet.transfer(amountToSend);\r\n    }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/Whitelistable.sol\r\n\r\n/**\r\n * @title Whitelistable\r\n * @dev This contract is used to implement a signature based whitelisting mechanism\r\n */\r\ncontract Whitelistable is Ownable {\r\n    bytes constant PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    address public whitelistAdmin;\r\n\r\n    // addresses map to false by default\r\n    mapping(address => bool) public blacklist;\r\n\r\n    event LogAdminUpdated(address indexed newAdmin);\r\n\r\n    modifier validAdmin(address _admin) {\r\n        require(_admin != 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == whitelistAdmin);\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor for Whitelistable contract\r\n    /// @param _admin the address of the admin that will generate the signatures\r\n    function Whitelistable(address _admin) public validAdmin(_admin) {\r\n        whitelistAdmin = _admin;        \r\n    }\r\n\r\n    /// @dev Updates whitelistAdmin address \r\n    /// @dev Can only be called by the current owner\r\n    /// @param _admin the new admin address\r\n    function changeAdmin(address _admin)\r\n        external\r\n        onlyOwner\r\n        validAdmin(_admin)\r\n    {\r\n        LogAdminUpdated(_admin);\r\n        whitelistAdmin = _admin;\r\n    }\r\n\r\n    // @dev blacklists the given address to ban them from contributing\r\n    // @param _contributor Address of the contributor to blacklist \r\n    function addToBlacklist(address _contributor)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        blacklist[_contributor] = true;\r\n    }\r\n\r\n    // @dev removes a previously blacklisted contributor from the blacklist\r\n    // @param _contributor Address of the contributor remove \r\n    function removeFromBlacklist(address _contributor)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        blacklist[_contributor] = false;\r\n    }\r\n\r\n    /// @dev Checks if contributor is whitelisted (main Whitelistable function)\r\n    /// @param contributor Address of who was whitelisted\r\n    /// @param contributionLimit Limit for the user contribution\r\n    /// @param currentSaleCap Cap of contributions to the sale at the current point in time\r\n    /// @param v Recovery id\r\n    /// @param r Component of the ECDSA signature\r\n    /// @param s Component of the ECDSA signature\r\n    /// @return Is the signature correct?\r\n    function checkWhitelisted(\r\n        address contributor,\r\n        uint256 contributionLimit,\r\n        uint256 currentSaleCap,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public view returns(bool) {\r\n        bytes32 prefixed = keccak256(PREFIX, keccak256(contributor, contributionLimit, currentSaleCap));\r\n        return !(blacklist[contributor]) && (whitelistAdmin == ecrecover(prefixed, v, r, s));\r\n    }\r\n}\r\n\r\n// File: @tokenfoundry/state-machine/contracts/StateMachine.sol\r\n\r\ncontract StateMachine {\r\n\r\n    struct State { \r\n        bytes32 nextStateId;\r\n        mapping(bytes4 => bool) allowedFunctions;\r\n        function() internal[] transitionCallbacks;\r\n        function(bytes32) internal returns(bool)[] startConditions;\r\n    }\r\n\r\n    mapping(bytes32 => State) states;\r\n\r\n    // The current state id\r\n    bytes32 private currentStateId;\r\n\r\n    event LogTransition(bytes32 stateId, uint256 blockNumber);\r\n\r\n    /* This modifier performs the conditional transitions and checks that the function \r\n     * to be executed is allowed in the current State\r\n     */\r\n    modifier checkAllowed {\r\n        conditionalTransitions();\r\n        require(states[currentStateId].allowedFunctions[msg.sig]);\r\n        _;\r\n    }\r\n\r\n    ///@dev transitions the state machine into the state it should currently be in\r\n    ///@dev by taking into account the current conditions and how many further transitions can occur \r\n    function conditionalTransitions() public {\r\n\r\n        bytes32 next = states[currentStateId].nextStateId;\r\n        bool stateChanged;\r\n\r\n        while (next != 0) {\r\n            // If one of the next state's conditions is met, go to this state and continue\r\n            stateChanged = false;\r\n            for (uint256 i = 0; i < states[next].startConditions.length; i++) {\r\n                if (states[next].startConditions[i](next)) {\r\n                    goToNextState();\r\n                    next = states[next].nextStateId;\r\n                    stateChanged = true;\r\n                    break;\r\n                }\r\n            }\r\n            // If none of the next state's conditions are met, then we are in the right current state\r\n            if (!stateChanged) break;\r\n        }\r\n    }\r\n\r\n    function getCurrentStateId() view public returns(bytes32) {\r\n        return currentStateId;\r\n    }\r\n\r\n\r\n    /// @dev Setup the state machine with the given states.\r\n    /// @param _stateIds Array of state ids.\r\n    function setStates(bytes32[] _stateIds) internal {\r\n        require(_stateIds.length > 0);\r\n        require(currentStateId == 0);\r\n\r\n        require(_stateIds[0] != 0);\r\n\r\n        currentStateId = _stateIds[0];\r\n\r\n        for (uint256 i = 1; i < _stateIds.length; i++) {\r\n            require(_stateIds[i] != 0);\r\n\r\n            states[_stateIds[i - 1]].nextStateId = _stateIds[i];\r\n\r\n            // Check that the state appears only once in the array\r\n            require(states[_stateIds[i]].nextStateId == 0);\r\n        }\r\n    }\r\n\r\n    /// @dev Allow a function in the given state.\r\n    /// @param _stateId The id of the state\r\n    /// @param _functionSelector A function selector (bytes4[keccak256(functionSignature)])\r\n    function allowFunction(bytes32 _stateId, bytes4 _functionSelector) internal {\r\n        states[_stateId].allowedFunctions[_functionSelector] = true;\r\n    }\r\n\r\n    /// @dev Goes to the next state if possible (if the next state is valid)\r\n    function goToNextState() internal {\r\n        bytes32 next = states[currentStateId].nextStateId;\r\n        require(next != 0);\r\n\r\n        currentStateId = next;\r\n        for (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\r\n            states[next].transitionCallbacks[i]();\r\n        }\r\n\r\n        LogTransition(next, block.number);\r\n    }\r\n\r\n    ///@dev add a function returning a boolean as a start condition for a state\r\n    ///@param _stateId The ID of the state to add the condition for\r\n    ///@param _condition Start condition function - returns true if a start condition (for a given state ID) is met\r\n    function addStartCondition(bytes32 _stateId, function(bytes32) internal returns(bool) _condition) internal {\r\n        states[_stateId].startConditions.push(_condition);\r\n    }\r\n\r\n    ///@dev add a callback function for a state\r\n    ///@param _stateId The ID of the state to add a callback function for\r\n    ///@param _callback The callback function to add\r\n    function addCallback(bytes32 _stateId, function() internal _callback) internal {\r\n        states[_stateId].transitionCallbacks.push(_callback);\r\n    }\r\n\r\n}\r\n\r\n// File: @tokenfoundry/state-machine/contracts/TimedStateMachine.sol\r\n\r\n/// @title A contract that implements the state machine pattern and adds time dependant transitions.\r\ncontract TimedStateMachine is StateMachine {\r\n\r\n    event LogSetStateStartTime(bytes32 indexed _stateId, uint256 _startTime);\r\n\r\n    // Stores the start timestamp for each state (the value is 0 if the state doesn't have a start timestamp).\r\n    mapping(bytes32 => uint256) private startTime;\r\n\r\n    /// @dev Returns the timestamp for the given state id.\r\n    /// @param _stateId The id of the state for which we want to set the start timestamp.\r\n    function getStateStartTime(bytes32 _stateId) public view returns(uint256) {\r\n        return startTime[_stateId];\r\n    }\r\n\r\n    /// @dev Sets the starting timestamp for a state.\r\n    /// @param _stateId The id of the state for which we want to set the start timestamp.\r\n    /// @param _timestamp The start timestamp for the given state. It should be bigger than the current one.\r\n    function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\r\n        require(block.timestamp < _timestamp);\r\n\r\n        if (startTime[_stateId] == 0) {\r\n            addStartCondition(_stateId, hasStartTimePassed);\r\n        }\r\n\r\n        startTime[_stateId] = _timestamp;\r\n\r\n        LogSetStateStartTime(_stateId, _timestamp);\r\n    }\r\n\r\n    function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\r\n        return startTime[_stateId] <= block.timestamp;\r\n    }\r\n\r\n}\r\n\r\n// File: @tokenfoundry/token-contracts/contracts/TokenControllerI.sol\r\n\r\n/// @title Interface for token controllers. The controller specifies whether a transfer can be done.\r\ncontract TokenControllerI {\r\n\r\n    /// @dev Specifies whether a transfer is allowed or not.\r\n    /// @return True if the transfer is allowed\r\n    function transferAllowed(address _from, address _to) external view returns (bool);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: @tokenfoundry/token-contracts/contracts/ControllableToken.sol\r\n\r\n/**\r\n * @title Controllable ERC20 token\r\n *\r\n * @dev Token that queries a token controller contract to check if a transfer is allowed.\r\n * @dev controller state var is going to be set with the address of a TokenControllerI contract that has \r\n * implemented transferAllowed() function.\r\n */\r\ncontract ControllableToken is Ownable, StandardToken {\r\n    TokenControllerI public controller;\r\n\r\n    /// @dev Executes transferAllowed() function from the Controller. \r\n    modifier isAllowed(address _from, address _to) {\r\n        require(controller.transferAllowed(_from, _to));\r\n        _;\r\n    }\r\n\r\n    /// @dev Sets the controller that is going to be used by isAllowed modifier\r\n    function setController(TokenControllerI _controller) onlyOwner public {\r\n        require(_controller != address(0));\r\n        controller = _controller;\r\n    }\r\n\r\n    /// @dev It calls parent BasicToken.transfer() function. It will transfer an amount of tokens to an specific address\r\n    /// @return True if the token is transfered with success\r\n    function transfer(address _to, uint256 _value) isAllowed(msg.sender, _to) public returns (bool) {        \r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /// @dev It calls parent StandardToken.transferFrom() function. It will transfer from an address a certain amount of tokens to another address \r\n    /// @return True if the token is transfered with success \r\n    function transferFrom(address _from, address _to, uint256 _value) isAllowed(_from, _to) public returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\r\n\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n// File: @tokenfoundry/token-contracts/contracts/Token.sol\r\n\r\n/**\r\n * @title Token base contract - Defines basic structure for a token\r\n *\r\n * @dev ControllableToken is a StandardToken, an OpenZeppelin ERC20 implementation library. DetailedERC20 is also an OpenZeppelin contract.\r\n * More info about them is available here: https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC20\r\n */\r\ncontract Token is ControllableToken, DetailedERC20 {\r\n\r\n\t/**\r\n\t* @dev Transfer is an event inherited from ERC20Basic.sol interface (OpenZeppelin).\r\n\t* @param _supply Total supply of tokens.\r\n    * @param _name Is the long name by which the token contract should be known\r\n    * @param _symbol The set of capital letters used to represent the token e.g. DTH.\r\n    * @param _decimals The number of decimal places the tokens can be split up into. This should be between 0 and 18.\r\n\t*/\r\n    function Token(\r\n        uint256 _supply,\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals\r\n    ) DetailedERC20(_name, _symbol, _decimals) public {\r\n        require(_supply != 0);\r\n        totalSupply_ = _supply;\r\n        balances[msg.sender] = _supply;\r\n        Transfer(address(0), msg.sender, _supply);  //event\r\n    }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/Sale.sol\r\n\r\n/// @title Sale base contract\r\ncontract Sale is Ownable, Whitelistable, TimedStateMachine, TokenControllerI {\r\n    using SafeMath for uint256;\r\n\r\n    // State machine states\r\n    bytes32 private constant SETUP = 'setup';\r\n    bytes32 private constant FREEZE = 'freeze';\r\n    bytes32 private constant SALE_IN_PROGRESS = 'saleInProgress';\r\n    bytes32 private constant SALE_ENDED = 'saleEnded';\r\n    bytes32[] public states = [SETUP, FREEZE, SALE_IN_PROGRESS, SALE_ENDED];\r\n\r\n    // Stores the contribution for each user\r\n    mapping(address => uint256) public contributions;\r\n    // Records which users have contributed throughout the sale\r\n    mapping(address => bool) public hasContributed;\r\n\r\n    DisbursementHandler public disbursementHandler;\r\n\r\n    uint256 public weiContributed = 0;\r\n    uint256 public totalSaleCap;\r\n    uint256 public minContribution;\r\n    uint256 public minThreshold;\r\n\r\n    // How many tokens a user will receive per each wei contributed\r\n    uint256 public tokensPerWei;\r\n    uint256 public tokensForSale;\r\n\r\n    Token public trustedToken;\r\n    Vault public trustedVault;\r\n\r\n    event LogContribution(address indexed contributor, uint256 value, uint256 excess);\r\n    event LogTokensAllocated(address indexed contributor, uint256 amount);\r\n\r\n    function Sale(\r\n        uint256 _totalSaleCap,\r\n        uint256 _minContribution,\r\n        uint256 _minThreshold,\r\n        uint256 _maxTokens,\r\n        address _whitelistAdmin,\r\n        address _wallet,\r\n        uint256 _closingDuration,\r\n        uint256 _vaultInitialAmount,\r\n        uint256 _vaultDisbursementAmount,\r\n        uint256 _startTime,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals\r\n    ) \r\n        Whitelistable(_whitelistAdmin)\r\n        public \r\n    {\r\n        require(_totalSaleCap != 0);\r\n        require(_maxTokens != 0);\r\n        require(_wallet != 0);\r\n        require(_minThreshold <= _totalSaleCap);\r\n        require(_vaultInitialAmount <= _minThreshold);\r\n        require(now < _startTime);\r\n\r\n        totalSaleCap = _totalSaleCap;\r\n        minContribution = _minContribution;\r\n        minThreshold = _minThreshold;\r\n\r\n        // Setup the necessary contracts\r\n        trustedToken = new Token(_maxTokens, _tokenName, _tokenSymbol, _tokenDecimals);\r\n        disbursementHandler = new DisbursementHandler(trustedToken);\r\n\r\n        trustedToken.setController(this);\r\n\r\n        trustedVault = new Vault(\r\n            _wallet,\r\n            _vaultInitialAmount,\r\n            _vaultDisbursementAmount, // disbursement amount\r\n            _closingDuration\r\n        );\r\n\r\n        // Set the states\r\n        setStates(states);\r\n\r\n        allowFunction(SETUP, this.setup.selector);\r\n        allowFunction(FREEZE, this.setEndTime.selector);\r\n        allowFunction(SALE_IN_PROGRESS, this.setEndTime.selector);\r\n        allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\r\n        allowFunction(SALE_IN_PROGRESS, this.endSale.selector);\r\n        allowFunction(SALE_ENDED, this.allocateTokens.selector);\r\n\r\n        // End the sale when the cap is reached\r\n        addStartCondition(SALE_ENDED, wasCapReached);\r\n\r\n        // Set the onSaleEnded callback (will be called when the sale ends)\r\n        addCallback(SALE_ENDED, onSaleEnded);\r\n\r\n        // Set the start and end times for the sale\r\n        setStateStartTime(SALE_IN_PROGRESS, _startTime);\r\n    }\r\n\r\n    /// @dev Setup the disbursements and tokens for sale.\r\n    /// @dev This needs to be outside the constructor because the token needs to query the sale for allowed transfers.\r\n    function setup() public onlyOwner checkAllowed {\r\n        require(trustedToken.transfer(disbursementHandler, disbursementHandler.totalAmount()));\r\n        tokensForSale = trustedToken.balanceOf(this);       \r\n        require(tokensForSale >= totalSaleCap);\r\n\r\n        // Go to freeze state\r\n        goToNextState();\r\n    }\r\n\r\n    /// @dev Called by users to contribute ETH to the sale.\r\n    function contribute(uint256 contributionLimit, uint256 currentSaleCap, uint8 v, bytes32 r, bytes32 s) \r\n        external \r\n        payable\r\n        checkAllowed \r\n    {\r\n        // Check that the signature is valid\r\n        require(currentSaleCap <= totalSaleCap);\r\n        require(weiContributed < currentSaleCap);\r\n        require(checkWhitelisted(msg.sender, contributionLimit, currentSaleCap, v, r, s));\r\n\r\n        uint256 current = contributions[msg.sender];\r\n        require(current < contributionLimit);\r\n\r\n        // Get the max amount that the user can contribute\r\n        uint256 remaining = Math.min256(contributionLimit.sub(current), currentSaleCap.sub(weiContributed));\r\n\r\n        // Check if it goes over the contribution limit of the user or the eth cap. \r\n        uint256 contribution = Math.min256(msg.value, remaining);\r\n\r\n        // Get the total contribution for the contributor after the previous checks\r\n        uint256 totalContribution = current.add(contribution);\r\n        require(totalContribution >= minContribution);\r\n\r\n        contributions[msg.sender] = totalContribution;\r\n        hasContributed[msg.sender] = true;\r\n\r\n        weiContributed = weiContributed.add(contribution);\r\n\r\n        trustedVault.deposit.value(contribution)(msg.sender);\r\n\r\n        if (weiContributed >= minThreshold && trustedVault.state() != Vault.State.Success) trustedVault.saleSuccessful();\r\n\r\n        // If there is an excess, return it to the user\r\n        uint256 excess = msg.value.sub(contribution);\r\n        if (excess > 0) msg.sender.transfer(excess);\r\n\r\n        LogContribution(msg.sender, contribution, excess);\r\n\r\n        assert(totalContribution <= contributionLimit);\r\n    }\r\n\r\n    /// @dev Sets the end time for the sale\r\n    /// @param _endTime The timestamp at which the sale will end.\r\n    function setEndTime(uint256 _endTime) external onlyOwner checkAllowed {\r\n        require(now < _endTime);\r\n        require(getStateStartTime(SALE_ENDED) == 0);\r\n        setStateStartTime(SALE_ENDED, _endTime);\r\n    }\r\n\r\n    /// @dev Called to allocate the tokens depending on eth contributed by the end of the sale.\r\n    /// @param _contributor The address of the contributor.\r\n    function allocateTokens(address _contributor) external checkAllowed {\r\n        require(contributions[_contributor] != 0);\r\n\r\n        // Transfer the respective tokens to the contributor\r\n        uint256 amount = contributions[_contributor].mul(tokensPerWei);\r\n\r\n        // Set contributions to 0\r\n        contributions[_contributor] = 0;\r\n\r\n        require(trustedToken.transfer(_contributor, amount));\r\n\r\n        LogTokensAllocated(_contributor, amount);\r\n    }\r\n\r\n    /// @dev Called to end the sale by the owner. Can only be called in SALE_IN_PROGRESS state\r\n    function endSale() external onlyOwner checkAllowed {\r\n        goToNextState();\r\n    }\r\n\r\n    /// @dev Since Sale is TokenControllerI, it has to implement transferAllowed() function\r\n    /// @notice only the Sale and DisbursementHandler can disburse the initial tokens to their future owners\r\n    function transferAllowed(address _from, address) external view returns (bool) {\r\n        return _from == address(this) || _from == address(disbursementHandler);\r\n    }\r\n\r\n    /// @dev Called internally by the sale to setup a disbursement (it has to be called in the constructor of child sales)\r\n    /// param _beneficiary Tokens will be disbursed to this address.\r\n    /// param _amount Number of tokens to be disbursed.\r\n    /// param _duration Tokens will be locked for this long.\r\n    function setupDisbursement(address _beneficiary, uint256 _amount, uint256 _duration) internal {\r\n        require(tokensForSale == 0);\r\n        disbursementHandler.setupDisbursement(_beneficiary, _amount, now.add(_duration));\r\n    }\r\n   \r\n    /// @dev Returns true if the cap was reached.\r\n    function wasCapReached(bytes32) internal returns (bool) {\r\n        return totalSaleCap <= weiContributed;\r\n    }\r\n\r\n    /// @dev Callback that gets called when entering the SALE_ENDED state.\r\n    function onSaleEnded() internal {\r\n        // If the minimum threshold wasn't reached, enable refunds\r\n        if (weiContributed < minThreshold) {\r\n            trustedVault.enableRefunds();\r\n        } else {\r\n            trustedVault.beginClosingPeriod();\r\n            tokensPerWei = tokensForSale.div(weiContributed);\r\n        }\r\n\r\n        trustedToken.transferOwnership(owner); \r\n        trustedVault.transferOwnership(owner);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/VirtuePokerSale.sol\r\n\r\ncontract VirtuePokerSale is Sale {\r\n\r\n    function VirtuePokerSale() \r\n        Sale(\r\n            25000 ether, // Total sale cap\r\n            1 ether, // Min contribution\r\n            12000 ether, // Min threshold\r\n            500000000 * (10 ** 18), // Max tokens\r\n            0x13ebf15f2e32d05ea944927ef5e6a3cad8187440, // Whitelist Admin\r\n            0xaa0aE3459F9f3472d1237015CaFC1aAfc6F03C63, // Wallet\r\n            28 days, // Closing duration\r\n            12000 ether, // Vault initial amount\r\n            25000 ether, // Vault disbursement amount\r\n            1524218400, // Start time\r\n            \"Virtue Player Points\", // Token name\r\n            \"VPP\", // Token symbol\r\n            18 // Token decimals\r\n        )\r\n        public \r\n    {\r\n        // Team Wallet (50,000,000 VPP, 25% per year)\r\n        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 1 years);\r\n        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 2 years);\r\n        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 3 years);\r\n        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 4 years);\r\n\r\n        // Company Wallet (250,000,000 VPP, no lock-up)\r\n        setupDisbursement(0xaa0aE3459F9f3472d1237015CaFC1aAfc6F03C63, 250000000 * (10 ** 18), 1 days);\r\n\r\n        // Founder Allocations (total 100,000,000, 12.5% per 6 months)\r\n        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 0.5 years);\r\n        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 1 years);\r\n        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 1.5 years);\r\n        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 2 years);\r\n        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 2.5 years);\r\n        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 3 years);\r\n        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 3.5 years);\r\n        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 4 years);\r\n\r\n        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 0.5 years);\r\n        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 1 years);\r\n        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 1.5 years);\r\n        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 2 years);\r\n        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 2.5 years);\r\n        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 3 years);\r\n        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 3.5 years);\r\n        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 4 years);\r\n\r\n        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 0.5 years);\r\n        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 1 years);\r\n        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 1.5 years);\r\n        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 2 years);\r\n        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 2.5 years);\r\n        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 3 years);\r\n        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 3.5 years);\r\n        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 4 years);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000019d971e4fe8401e74000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001456697274756520506c6179657220506f696e747300000000000000000000000000000000000000000000000000000000000000000000000000000000000000035650500000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b8c87ee973e0c1f7ba5d0646c429316821ea8f0d8cc6a7c13de230301ead2ff8"}]}