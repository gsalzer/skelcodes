{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/*\r\n  Copyright 2017, Anton Egorov (Mothership Foundation)\r\n  Copyright 2017, An Hoang Phan Ngo (Mothership Foundation)\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU General Public License as published by\r\n  the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n  along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n// File: contracts/interface/Controlled.sol\r\n\r\ncontract Controlled {\r\n  /// @notice The address of the controller is the only address that can call\r\n  ///  a function with this modifier\r\n  modifier onlyController {\r\n    require(msg.sender == controller);\r\n    _;\r\n  }\r\n\r\n  address public controller;\r\n\r\n  function Controlled() public { controller = msg.sender; }\r\n\r\n  /// @notice Changes the controller of the contract\r\n  /// @param _newController The new controller of the contract\r\n  function changeController(address _newController) public onlyController {\r\n    controller = _newController;\r\n  }\r\n}\r\n\r\n// File: contracts/interface/Burnable.sol\r\n\r\n/// @dev Burnable introduces a burner role, which could be used to destroy\r\n///  tokens. The burner address could be changed by himself.\r\ncontract Burnable is Controlled {\r\n  address public burner;\r\n\r\n  /// @notice The function with this modifier could be called by a controller\r\n  /// as well as by a burner. But burner could use the onlt his/her address as\r\n  /// a target.\r\n  modifier onlyControllerOrBurner(address target) {\r\n    assert(msg.sender == controller || (msg.sender == burner && msg.sender == target));\r\n    _;\r\n  }\r\n\r\n  modifier onlyBurner {\r\n    assert(msg.sender == burner);\r\n    _;\r\n  }\r\n\r\n  /// Contract creator become a burner by default\r\n  function Burnable() public { burner = msg.sender;}\r\n\r\n  /// @notice Change a burner address\r\n  /// @param _newBurner The new burner address\r\n  function changeBurner(address _newBurner) public onlyBurner {\r\n    burner = _newBurner;\r\n  }\r\n}\r\n\r\n// File: contracts/interface/ERC20Token.sol\r\n\r\n// @dev Abstract contract for the full ERC 20 Token standard\r\n//  https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Token {\r\n  /// total amount of tokens\r\n  function totalSupply() public view returns (uint256 balance);\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of tokens to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// File: contracts/interface/MiniMeTokenI.sol\r\n\r\n/// @dev MiniMeToken interface. Using this interface instead of whole contracts\r\n///  will reduce contract sise and gas cost\r\ncontract MiniMeTokenI is ERC20Token, Burnable {\r\n\r\n  string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n  uint8 public decimals;             //Number of decimals of the smallest unit\r\n  string public symbol;              //An identifier: e.g. REP\r\n  string public version = \"MMT_0.1\"; //An arbitrary versioning scheme\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n\r\n  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n  ///  its behalf, and then a function is triggered in the contract that is\r\n  ///  being approved, `_spender`. This allows users to use their tokens to\r\n  ///  interact with contracts in one function call instead of two\r\n  /// @param _spender The address of the contract able to transfer the tokens\r\n  /// @param _amount The amount of tokens to be approved for transfer\r\n  /// @return True if the function call was successful\r\n  function approveAndCall(\r\n    address _spender,\r\n    uint256 _amount,\r\n    bytes _extraData) public returns (bool success);\r\n\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n\r\n  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @param _blockNumber The block number when the balance is queried\r\n  /// @return The balance at `_blockNumber`\r\n  function balanceOfAt(\r\n    address _owner,\r\n    uint _blockNumber) public constant returns (uint);\r\n\r\n  /// @notice Total amount of tokens at a specific `_blockNumber`.\r\n  /// @param _blockNumber The block number when the totalSupply is queried\r\n  /// @return The total amount of tokens at `_blockNumber`\r\n  function totalSupplyAt(uint _blockNumber) public constant returns(uint);\r\n\r\n////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n\r\n  /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n  /// @param _owner The address that will be assigned the new tokens\r\n  /// @param _amount The quantity of tokens generated\r\n  /// @return True if the tokens are generated correctly\r\n  function mintTokens(address _owner, uint _amount) public returns (bool);\r\n\r\n\r\n  /// @notice Burns `_amount` tokens from `_owner`\r\n  /// @param _owner The address that will lose the tokens\r\n  /// @param _amount The quantity of tokens to burn\r\n  /// @return True if the tokens are burned correctly\r\n  function destroyTokens(address _owner, uint _amount) public returns (bool);\r\n\r\n/////////////////\r\n// Finalize \r\n////////////////\r\n  function finalize() public;\r\n\r\n//////////\r\n// Safety Methods\r\n//////////\r\n\r\n  /// @notice This method can be used by the controller to extract mistakenly\r\n  ///  sent tokens to this contract.\r\n  /// @param _token The address of the token contract that you want to recover\r\n  ///  set to 0 in case you want to extract ether.\r\n  function claimTokens(address _token) public;\r\n\r\n////////////////\r\n// Events\r\n////////////////\r\n\r\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n}\r\n\r\n// File: contracts/interface/TokenController.sol\r\n\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n  function proxyMintTokens(\r\n    address _owner, \r\n    uint _amount,\r\n    bytes32 _paidTxID) public returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n  function onApprove(address _owner, address _spender, uint _amount) public\r\n    returns(bool);\r\n}\r\n\r\n// File: contracts/Distribution.sol\r\n\r\ncontract Distribution is Controlled, TokenController {\r\n\r\n  /// Record tx details for each minting operation\r\n  struct Transaction {\r\n    uint256 amount;\r\n    bytes32 paidTxID;\r\n  }\r\n\r\n  MiniMeTokenI public token;\r\n\r\n  address public reserveWallet; // Team's wallet address\r\n\r\n  uint256 public totalSupplyCap; // Total Token supply to be generated\r\n  uint256 public totalReserve; // A number of tokens to reserve for the team/bonuses\r\n\r\n  uint256 public finalizedBlock;\r\n\r\n  /// Record all transaction details for all minting operations\r\n  mapping (address => Transaction[]) allTransactions;\r\n\r\n  /// @param _token Address of the SEN token contract\r\n  ///  the contribution finalizes.\r\n  /// @param _reserveWallet Team's wallet address to distribute reserved pool\r\n  /// @param _totalSupplyCap Maximum amount of tokens to generate during the contribution\r\n  /// @param _totalReserve A number of tokens to reserve for the team/bonuses\r\n  function Distribution(\r\n    address _token,\r\n    address _reserveWallet,\r\n    uint256 _totalSupplyCap,\r\n    uint256 _totalReserve\r\n  ) public onlyController\r\n  {\r\n    // Initialize only once\r\n    assert(address(token) == 0x0);\r\n\r\n    token = MiniMeTokenI(_token);\r\n    reserveWallet = _reserveWallet;\r\n\r\n    require(_totalReserve < _totalSupplyCap);\r\n    totalSupplyCap = _totalSupplyCap;\r\n    totalReserve = _totalReserve;\r\n\r\n    assert(token.totalSupply() == 0);\r\n    assert(token.decimals() == 18); // Same amount of decimals as ETH\r\n  }\r\n\r\n  function distributionCap() public constant returns (uint256) {\r\n    return totalSupplyCap - totalReserve;\r\n  }\r\n\r\n  /// @notice This method can be called the distribution cap is reached only\r\n  function finalize() public onlyController {\r\n    assert(token.totalSupply() >= distributionCap());\r\n\r\n    // Mint reserve pool\r\n    doMint(reserveWallet, totalReserve);\r\n\r\n    finalizedBlock = getBlockNumber();\r\n    token.finalize(); // Token becomes unmintable after this\r\n\r\n    // Distribution controller becomes a Token controller\r\n    token.changeController(controller);\r\n\r\n    Finalized();\r\n  }\r\n\r\n//////////\r\n// TokenController functions\r\n//////////\r\n\r\n  function proxyMintTokens(\r\n    address _th,\r\n    uint256 _amount,\r\n    bytes32 _paidTxID\r\n  ) public onlyController returns (bool)\r\n  {\r\n    require(_th != 0x0);\r\n\r\n    require(_amount + token.totalSupply() <= distributionCap());\r\n\r\n    doMint(_th, _amount);\r\n    addTransaction(\r\n      allTransactions[_th],\r\n      _amount,\r\n      _paidTxID);\r\n\r\n    Purchase(\r\n      _th,\r\n      _amount,\r\n      _paidTxID);\r\n\r\n    return true;\r\n  }\r\n\r\n  function onTransfer(address, address, uint256) public returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  function onApprove(address, address, uint256) public returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  //////////\r\n  // Safety Methods\r\n  //////////\r\n\r\n  /// @notice This method can be used by the controller to extract mistakenly\r\n  ///  sent tokens to this contract.\r\n  /// @param _token The address of the token contract that you want to recover\r\n  ///  set to 0 in case you want to extract ether.\r\n  function claimTokens(address _token) public onlyController {\r\n    if (token.controller() == address(this)) {\r\n      token.claimTokens(_token);\r\n    }\r\n    if (_token == 0x0) {\r\n      controller.transfer(this.balance);\r\n      return;\r\n    }\r\n\r\n    ERC20Token otherToken = ERC20Token(_token);\r\n    uint256 balance = otherToken.balanceOf(this);\r\n    otherToken.transfer(controller, balance);\r\n    ClaimedTokens(_token, controller, balance);\r\n  }\r\n\r\n  //////////////////////////////////\r\n  // Minting tokens and oraclization\r\n  //////////////////////////////////\r\n\r\n  /// Total transaction count belong to an address\r\n  function totalTransactionCount(address _owner) public constant returns(uint) {\r\n    return allTransactions[_owner].length;\r\n  }\r\n\r\n  /// Query a transaction details by address and its index in transactions array\r\n  function getTransactionAtIndex(address _owner, uint index) public constant returns(\r\n    uint256 _amount,\r\n    bytes32 _paidTxID\r\n  ) {\r\n    _amount = allTransactions[_owner][index].amount;\r\n    _paidTxID = allTransactions[_owner][index].paidTxID;\r\n  }\r\n\r\n  /// Save transaction details belong to an address\r\n  /// @param  transactions all transactions belong to an address\r\n  /// @param _amount amount of tokens issued in the transaction\r\n  /// @param _paidTxID blockchain tx_hash\r\n  function addTransaction(\r\n    Transaction[] storage transactions,\r\n    uint _amount,\r\n    bytes32 _paidTxID\r\n    ) internal\r\n  {\r\n    Transaction storage newTx = transactions[transactions.length++];\r\n    newTx.amount = _amount;\r\n    newTx.paidTxID = _paidTxID;\r\n  }\r\n\r\n  function doMint(address _th, uint256 _amount) internal {\r\n    assert(token.mintTokens(_th, _amount));\r\n  }\r\n\r\n//////////\r\n// Testing specific methods\r\n//////////\r\n\r\n  /// @notice This function is overridden by the test Mocks.\r\n  function getBlockNumber() internal constant returns (uint256) { return block.number; }\r\n\r\n\r\n////////////////\r\n// Events\r\n////////////////\r\n  event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n  event Purchase(\r\n    address indexed _owner,\r\n    uint256 _amount,\r\n    bytes32 _paidTxID\r\n  );\r\n  event Finalized();\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getTransactionAtIndex\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_paidTxID\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_th\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_paidTxID\",\"type\":\"bytes32\"}],\"name\":\"proxyMintTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"totalTransactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_reserveWallet\",\"type\":\"address\"},{\"name\":\"_totalSupplyCap\",\"type\":\"uint256\"},{\"name\":\"_totalReserve\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_paidTxID\",\"type\":\"bytes32\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"}]","ContractName":"Distribution","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d53370acf66044910bb49cbcfe8f3cd020337f600000000000000000000000004bfa66cf4f1c94a947d01c820a5bc4c20d07866b00000000000000000000000000000000000000000554d9173ae4d397b200000000000000000000000000000000000000000000000316f1bce0bd4debc3b00000","Library":"","SwarmSource":"bzzr://a030e4401b3b3092432296387c6d6dd4e16ed6ce7e11b7424d023e6583958310"}]}