{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/// @title ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/issues/20)\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n    function balanceOf(address _owner) constant public returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\r\n/// @title Basic ERC20 token contract implementation.\r\n/// @dev Based on OpenZeppelin's StandardToken.\r\ncontract BasicToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public totalSupply;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => uint256) balances;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve (see NOTE)\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\r\n            revert();\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    /// @param _owner address The address which owns the funds.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @return uint256 specifying the amount of tokens still available for the spender.\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner address The address to query the the balance of.\r\n    /// @return uint256 representing the amount owned by the passed address.\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @dev Transfer token to a specified address.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another.\r\n    /// @param _from address The address which you want to send tokens from.\r\n    /// @param _to address The address which you want to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title ERC Token Standard #677 Interface (https://github.com/ethereum/EIPs/issues/677)\r\ncontract ERC677 is ERC20 {\r\n    function transferAndCall(address to, uint value, bytes data) public returns (bool ok);\r\n\r\n    event TransferAndCall(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\n/// @title Math operations with safety checks\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // require(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function toPower2(uint256 a) internal pure returns (uint256) {\r\n        return mul(a, a);\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        uint256 c = (a + 1) / 2;\r\n        uint256 b = a;\r\n        while (c < b) {\r\n            b = c;\r\n            c = (a / c + c) / 2;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Standard677Token implentation, base on https://github.com/ethereum/EIPs/issues/677\r\n\r\ncontract Standard677Token is ERC677, BasicToken {\r\n\r\n  /// @dev ERC223 safe token transfer from one address to another\r\n  /// @param _to address the address which you want to transfer to.\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function transferAndCall(address _to, uint _value, bytes _data) public returns (bool) {\r\n    require(super.transfer(_to, _value)); // do a normal token transfer\r\n    TransferAndCall(msg.sender, _to, _value, _data);\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (isContract(_to)) return contractFallback(_to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  /// @dev called when transaction target is a contract\r\n  /// @param _to address the address which you want to transfer to.\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function contractFallback(address _to, uint _value, bytes _data) private returns (bool) {\r\n    ERC223Receiver receiver = ERC223Receiver(_to);\r\n    require(receiver.tokenFallback(msg.sender, _value, _data));\r\n    return true;\r\n  }\r\n\r\n  /// @dev check if the address is contract\r\n  /// assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  /// @param _addr address the address to check\r\n  function isContract(address _addr) private constant returns (bool is_contract) {\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }\r\n}\r\n\r\n\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic authorization control functions,\r\n/// this simplifies the implementation of \"user permissions\".\r\n/// @dev Based on OpenZeppelin's Ownable.\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed _by, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    /// @dev Constructor sets the original `owner` of the contract to the sender account.\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerCandidate() {\r\n        require(msg.sender == newOwnerCandidate);\r\n        _;\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        require(_newOwnerCandidate != address(0));\r\n\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accept ownership transfer. This method needs to be called by the perviously proposed owner.\r\n    function acceptOwnership() external onlyOwnerCandidate {\r\n        address previousOwner = owner;\r\n\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = address(0);\r\n\r\n        OwnershipTransferred(previousOwner, owner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title Token holder contract.\r\ncontract TokenHolder is Ownable {\r\n    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n    /// @param _tokenAddress address The address of the ERC20 contract.\r\n    /// @param _amount uint256 The amount of tokens to be transferred.\r\n    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\r\n        return ERC20(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Colu Local Currency contract.\r\n/// @author Rotem Lev.\r\ncontract ColuLocalCurrency is Ownable, Standard677Token, TokenHolder {\r\n    using SafeMath for uint256;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n   \r\n    /// @dev cotract to use when issuing a CC (Local Currency)\r\n    /// @param _name string name for CC token that is created.\r\n    /// @param _symbol string symbol for CC token that is created.\r\n    /// @param _decimals uint8 percison for CC token that is created.\r\n    /// @param _totalSupply uint256 total supply of the CC token that is created. \r\n    function ColuLocalCurrency(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\r\n        require(_totalSupply != 0);     \r\n        require(bytes(_name).length != 0);\r\n        require(bytes(_symbol).length != 0);\r\n\r\n        totalSupply = _totalSupply;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n}\r\n\r\n/// @title ERC223Receiver Interface\r\n/// @dev Based on the specs form: https://github.com/ethereum/EIPs/issues/223\r\ncontract ERC223Receiver {\r\n    function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\r\n}\r\n\r\n\r\n\r\n /// @title Standard ERC223 Token Receiver implementing tokenFallback function and tokenPayable modifier\r\n\r\ncontract Standard223Receiver is ERC223Receiver {\r\n  Tkn tkn;\r\n\r\n  struct Tkn {\r\n    address addr;\r\n    address sender; // the transaction caller\r\n    uint256 value;\r\n  }\r\n\r\n  bool __isTokenFallback;\r\n\r\n  modifier tokenPayable {\r\n    require(__isTokenFallback);\r\n    _;\r\n  }\r\n\r\n  /// @dev Called when the receiver of transfer is contract\r\n  /// @param _sender address the address of tokens sender\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\r\n    if (!supportsToken(msg.sender)) {\r\n      return false;\r\n    }\r\n\r\n    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\r\n    // Solution: Remove the the data\r\n    tkn = Tkn(msg.sender, _sender, _value);\r\n    __isTokenFallback = true;\r\n    if (!address(this).delegatecall(_data)) {\r\n      __isTokenFallback = false;\r\n      return false;\r\n    }\r\n    // avoid doing an overwrite to .token, which would be more expensive\r\n    // makes accessing .tkn values outside tokenPayable functions unsafe\r\n    __isTokenFallback = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function supportsToken(address token) public constant returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title TokenOwnable\r\n/// @dev The TokenOwnable contract adds a onlyTokenOwner modifier as a tokenReceiver with ownable addaptation\r\n\r\ncontract TokenOwnable is Standard223Receiver, Ownable {\r\n    /// @dev Reverts if called by any account other than the owner for token sending.\r\n    modifier onlyTokenOwner() {\r\n        require(tkn.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Market Maker Interface.\r\n/// @author Tal Beja.\r\ncontract MarketMaker is ERC223Receiver {\r\n\r\n  function getCurrentPrice() public constant returns (uint _price);\r\n  function change(address _fromToken, uint _amount, address _toToken) public returns (uint _returnAmount);\r\n  function change(address _fromToken, uint _amount, address _toToken, uint _minReturn) public returns (uint _returnAmount);\r\n  function change(address _toToken) public returns (uint _returnAmount);\r\n  function change(address _toToken, uint _minReturn) public returns (uint _returnAmount);\r\n  function quote(address _fromToken, uint _amount, address _toToken) public constant returns (uint _returnAmount);\r\n  function openForPublicTrade() public returns (bool success);\r\n  function isOpenForPublic() public returns (bool success);\r\n\r\n  event Change(address indexed fromToken, uint inAmount, address indexed toToken, uint returnAmount, address indexed account);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Ellipse Market Maker contract.\r\n/// @dev market maker, using ellipse equation.\r\n/// @author Tal Beja.\r\ncontract EllipseMarketMaker is TokenOwnable {\r\n\r\n  // precision for price representation (as in ether or tokens).\r\n  uint256 public constant PRECISION = 10 ** 18;\r\n\r\n  // The tokens pair.\r\n  ERC20 public token1;\r\n  ERC20 public token2;\r\n\r\n  // The tokens reserves.\r\n  uint256 public R1;\r\n  uint256 public R2;\r\n\r\n  // The tokens full suplly.\r\n  uint256 public S1;\r\n  uint256 public S2;\r\n\r\n  // State flags.\r\n  bool public operational;\r\n  bool public openForPublic;\r\n\r\n  // Library contract address.\r\n  address public mmLib;\r\n\r\n  /// @dev Constructor calling the library contract using delegate.\r\n  function EllipseMarketMaker(address _mmLib, address _token1, address _token2) public {\r\n    require(_mmLib != address(0));\r\n    // Signature of the mmLib's constructor function\r\n    // bytes4 sig = bytes4(keccak256(\"constructor(address,address,address)\"));\r\n    bytes4 sig = 0x6dd23b5b;\r\n\r\n    // 3 arguments of size 32\r\n    uint256 argsSize = 3 * 32;\r\n    // sig + arguments size\r\n    uint256 dataSize = 4 + argsSize;\r\n\r\n\r\n    bytes memory m_data = new bytes(dataSize);\r\n\r\n    assembly {\r\n        // Add the signature first to memory\r\n        mstore(add(m_data, 0x20), sig)\r\n        // Add the parameters\r\n        mstore(add(m_data, 0x24), _mmLib)\r\n        mstore(add(m_data, 0x44), _token1)\r\n        mstore(add(m_data, 0x64), _token2)\r\n    }\r\n\r\n    // delegatecall to the library contract\r\n    require(_mmLib.delegatecall(m_data));\r\n  }\r\n\r\n  /// @dev returns true iff token is supperted by this contract (for erc223/677 tokens calls)\r\n  /// @param token can be token1 or token2\r\n  function supportsToken(address token) public constant returns (bool) {\r\n    return (token1 == token || token2 == token);\r\n  }\r\n\r\n  /// @dev gets called when no other function matches, delegate to the lib contract.\r\n  function() public {\r\n    address _mmLib = mmLib;\r\n    if (msg.data.length > 0) {\r\n      assembly {\r\n        calldatacopy(0xff, 0, calldatasize)\r\n        let retVal := delegatecall(gas, _mmLib, 0xff, calldatasize, 0, 0x20)\r\n        switch retVal case 0 { revert(0,0) } default { return(0, 0x20) }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Ellipse Market Maker Interfase\r\n/// @author Tal Beja\r\ncontract IEllipseMarketMaker is MarketMaker {\r\n\r\n    // precision for price representation (as in ether or tokens).\r\n    uint256 public constant PRECISION = 10 ** 18;\r\n\r\n    // The tokens pair.\r\n    ERC20 public token1;\r\n    ERC20 public token2;\r\n\r\n    // The tokens reserves.\r\n    uint256 public R1;\r\n    uint256 public R2;\r\n\r\n    // The tokens full suplly.\r\n    uint256 public S1;\r\n    uint256 public S2;\r\n\r\n    // State flags.\r\n    bool public operational;\r\n    bool public openForPublic;\r\n\r\n    // Library contract address.\r\n    address public mmLib;\r\n\r\n    function supportsToken(address token) public constant returns (bool);\r\n\r\n    function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256);\r\n\r\n    function validateReserves() public view returns (bool);\r\n\r\n    function withdrawExcessReserves() public returns (uint256);\r\n\r\n    function initializeAfterTransfer() public returns (bool);\r\n\r\n    function initializeOnTransfer() public returns (bool);\r\n\r\n    function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Colu Local Currency + Market Maker factory contract.\r\n/// @author Rotem Lev.\r\ncontract CurrencyFactory is Standard223Receiver, TokenHolder {\r\n\r\n  struct CurrencyStruct {\r\n    string name;\r\n    uint8 decimals;\r\n    uint256 totalSupply;\r\n    address owner;\r\n    address mmAddress;\r\n  }\r\n\r\n\r\n  // map of Market Maker owners: token address => currency struct\r\n  mapping (address => CurrencyStruct) public currencyMap;\r\n  // address of the deployed CLN contract (ERC20 Token)\r\n  address public clnAddress;\r\n  // address of the deployed elipse market maker contract\r\n  address public mmLibAddress;\r\n\r\n  address[] public tokens;\r\n\r\n  event MarketOpen(address indexed marketMaker);\r\n  event TokenCreated(address indexed token, address indexed owner);\r\n\r\n  // modifier to check if called by issuer of the token\r\n  modifier tokenIssuerOnly(address token, address owner) {\r\n    require(currencyMap[token].owner == owner);\r\n    _;\r\n  }\r\n  // modifier to only accept transferAndCall from CLN token\r\n  modifier CLNOnly() {\r\n    require(msg.sender == clnAddress);\r\n    _;\r\n  }\r\n\r\n  /// @dev constructor only reuires the address of the CLN token which must use the ERC20 interface\r\n  /// @param _mmLib address for the deployed market maker elipse contract\r\n  /// @param _clnAddress address for the deployed ERC20 CLN token\r\n  function CurrencyFactory(address _mmLib, address _clnAddress) public {\r\n  \trequire(_mmLib != address(0));\r\n  \trequire(_clnAddress != address(0));\r\n  \tmmLibAddress = _mmLib;\r\n  \tclnAddress = _clnAddress;\r\n  }\r\n\r\n  /// @dev create the MarketMaker and the CC token put all the CC token in the Market Maker reserve\r\n  /// @param _name string name for CC token that is created.\r\n  /// @param _symbol string symbol for CC token that is created.\r\n  /// @param _decimals uint8 percison for CC token that is created.\r\n  /// @param _totalSupply uint256 total supply of the CC token that is created.\r\n  function createCurrency(string _name,\r\n                          string _symbol,\r\n                          uint8 _decimals,\r\n                          uint256 _totalSupply) public\r\n                          returns (address) {\r\n\r\n  \tColuLocalCurrency subToken = new ColuLocalCurrency(_name, _symbol, _decimals, _totalSupply);\r\n  \tEllipseMarketMaker newMarketMaker = new EllipseMarketMaker(mmLibAddress, clnAddress, subToken);\r\n  \t//set allowance\r\n  \trequire(subToken.transfer(newMarketMaker, _totalSupply));\r\n  \trequire(IEllipseMarketMaker(newMarketMaker).initializeAfterTransfer());\r\n  \tcurrencyMap[subToken] = CurrencyStruct({ name: _name, decimals: _decimals, totalSupply: _totalSupply, mmAddress: newMarketMaker, owner: msg.sender});\r\n    tokens.push(subToken);\r\n  \tTokenCreated(subToken, msg.sender);\r\n  \treturn subToken;\r\n  }\r\n\r\n  /// @dev normal send cln to the market maker contract, sender must approve() before calling method. can only be called by owner\r\n  /// @dev sending CLN will return CC from the reserve to the sender.\r\n  /// @param _token address address of the cc token managed by this factory.\r\n  /// @param _clnAmount uint256 amount of CLN to transfer into the Market Maker reserve.\r\n  function insertCLNtoMarketMaker(address _token,\r\n                                  uint256 _clnAmount) public\r\n                                  tokenIssuerOnly(_token, msg.sender)\r\n                                  returns (uint256 _subTokenAmount) {\r\n  \trequire(_clnAmount > 0);\r\n  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\r\n  \trequire(ERC20(clnAddress).transferFrom(msg.sender, this, _clnAmount));\r\n  \trequire(ERC20(clnAddress).approve(marketMakerAddress, _clnAmount));\r\n  \t_subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, _clnAmount, _token);\r\n    require(ERC20(_token).transfer(msg.sender, _subTokenAmount));\r\n  }\r\n\r\n  /// @dev ERC223 transferAndCall, send cln to the market maker contract can only be called by owner (see MarketMaker)\r\n  /// @dev sending CLN will return CC from the reserve to the sender.\r\n  /// @param _token address address of the cc token managed by this factory.\r\n  function insertCLNtoMarketMaker(address _token) public\r\n                                  tokenPayable\r\n                                  CLNOnly\r\n                                  tokenIssuerOnly(_token, tkn.sender)\r\n                                  returns (uint256 _subTokenAmount) {\r\n  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\r\n  \trequire(ERC20(clnAddress).approve(marketMakerAddress, tkn.value));\r\n  \t_subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, tkn.value, _token);\r\n    require(ERC20(_token).transfer(tkn.sender, _subTokenAmount));\r\n  }\r\n\r\n  /// @dev normal send cc to the market maker contract, sender must approve() before calling method. can only be called by owner\r\n  /// @dev sending CC will return CLN from the reserve to the sender.\r\n  /// @param _token address address of the cc token managed by this factory.\r\n  /// @param _ccAmount uint256 amount of CC to transfer into the Market Maker reserve.\r\n  function extractCLNfromMarketMaker(address _token,\r\n                                     uint256 _ccAmount) public\r\n                                     tokenIssuerOnly(_token, msg.sender)\r\n                                     returns (uint256 _clnTokenAmount) {\r\n  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\r\n  \trequire(ERC20(_token).transferFrom(msg.sender, this, _ccAmount));\r\n  \trequire(ERC20(_token).approve(marketMakerAddress, _ccAmount));\r\n  \t_clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(_token, _ccAmount, clnAddress);\r\n  \trequire(ERC20(clnAddress).transfer(msg.sender, _clnTokenAmount));\r\n  }\r\n\r\n  /// @dev ERC223 transferAndCall, send CC to the market maker contract can only be called by owner (see MarketMaker)\r\n  /// @dev sending CC will return CLN from the reserve to the sender.\r\n  function extractCLNfromMarketMaker() public\r\n                                    tokenPayable\r\n                                    tokenIssuerOnly(msg.sender, tkn.sender)\r\n                                    returns (uint256 _clnTokenAmount) {\r\n  \taddress marketMakerAddress = getMarketMakerAddressFromToken(msg.sender);\r\n  \trequire(ERC20(msg.sender).approve(marketMakerAddress, tkn.value));\r\n  \t_clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(msg.sender, tkn.value, clnAddress);\r\n  \trequire(ERC20(clnAddress).transfer(tkn.sender, _clnTokenAmount));\r\n  }\r\n\r\n  /// @dev opens the Market Maker to recvice transactions from all sources.\r\n  /// @dev Request to transfer ownership of Market Maker contract to Owner instead of factory.\r\n  /// @param _token address address of the cc token managed by this factory.\r\n  function openMarket(address _token) public\r\n                      tokenIssuerOnly(_token, msg.sender)\r\n                      returns (bool) {\r\n  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\r\n  \trequire(MarketMaker(marketMakerAddress).openForPublicTrade());\r\n  \tOwnable(marketMakerAddress).requestOwnershipTransfer(msg.sender);\r\n  \tMarketOpen(marketMakerAddress);\r\n  \treturn true;\r\n  }\r\n\r\n  /// @dev implementation for standard 223 reciver.\r\n  /// @param _token address of the token used with transferAndCall.\r\n  function supportsToken(address _token) public constant returns (bool) {\r\n  \treturn (clnAddress == _token || currencyMap[_token].totalSupply > 0);\r\n  }\r\n\r\n  /// @dev helper function to get the market maker address form token\r\n  /// @param _token address of the token used with transferAndCall.\r\n  function getMarketMakerAddressFromToken(address _token) public constant returns (address _marketMakerAddress) {\r\n  \t_marketMakerAddress = currencyMap[_token].mmAddress;\r\n    require(_marketMakerAddress != address(0));\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The IssuanceFactory creates an issuance contract that accepts on one side CLN\r\n * locks then up in an elipse market maker up to the supplied softcap\r\n * and returns a CC token based on price that is derived form the two supplies and reserves of each\r\n */\r\n\r\n/// @title Colu Issuance factoy with CLN for CC tokens.\r\n/// @author Rotem Lev.\r\ncontract IssuanceFactory is CurrencyFactory {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public PRECISION;\r\n\r\n  struct IssuanceStruct {\r\n  \tuint256 hardcap;\r\n  \tuint256 reserve;\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    uint256 targetPrice;\r\n    uint256 clnRaised;\r\n  }\r\n\r\n  uint256 public totalCLNcustodian;\r\n\r\n  //map of Market Maker owners\r\n  mapping (address => IssuanceStruct) public issueMap;\r\n  // total supply of CLN\r\n  uint256 public CLNTotalSupply;\r\n\r\n  event CLNRaised(address indexed token, address indexed participant, uint256 amount);\r\n  event CLNRefunded(address indexed token, address indexed participant, uint256 amount);\r\n\r\n  event SaleFinalized(address indexed token, uint256 clnRaised);\r\n\r\n  // sale has begun based on time and status\r\n  modifier saleOpen(address _token) {\r\n  \trequire(now >= issueMap[_token].startTime && issueMap[_token].endTime >= now);\r\n    require(issueMap[_token].clnRaised < issueMap[_token].hardcap);\r\n  \t_;\r\n  }\r\n\r\n  // sale is passed its endtime\r\n  modifier hasEnded(address _token) {\r\n    require(issueMap[_token].endTime < now);\r\n  \t_;\r\n  }\r\n\r\n  // sale considered successful when it raised equal to or more than the softcap\r\n  modifier saleWasSuccessfull(address _token) {\r\n  \trequire(issueMap[_token].clnRaised >= issueMap[_token].reserve);\r\n  \t_;\r\n  }\r\n\r\n   // sale considerd failed when it raised less than the softcap\r\n  modifier saleHasFailed(address _token) {\r\n  \trequire(issueMap[_token].clnRaised < issueMap[_token].reserve);\r\n  \t_;\r\n  }\r\n\r\n  // checks if the instance of market maker contract is closed for public\r\n  modifier marketClosed(address _token) {\r\n  \trequire(!MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic());\r\n  \t_;\r\n  }\r\n  /// @dev constructor\r\n  /// @param _mmLib address for the deployed elipse market maker contract\r\n  /// @param _clnAddress address for the deployed CLN ERC20 token\r\n  function IssuanceFactory(address _mmLib, address _clnAddress) public CurrencyFactory(_mmLib, _clnAddress) {\r\n    CLNTotalSupply = ERC20(_clnAddress).totalSupply();\r\n    PRECISION = IEllipseMarketMaker(_mmLib).PRECISION();\r\n  }\r\n\r\n\t/// @dev createIssuance create local currency issuance sale\r\n\t/// @param _startTime uint256 blocktime for sale start\r\n\t/// @param _durationTime uint 256 duration of the sale\r\n\t/// @param _hardcap uint CLN hardcap for issuance\r\n\t/// @param _reserveAmount uint CLN reserve ammount\r\n\t/// @param _name string name of the token\r\n\t/// @param _symbol string symbol of the token\r\n\t/// @param _decimals uint8 ERC20 decimals of local currency\r\n\t/// @param _totalSupply uint total supply of the local currency\r\n  function createIssuance( uint256 _startTime,\r\n                            uint256 _durationTime,\r\n                            uint256 _hardcap,\r\n                            uint256 _reserveAmount,\r\n                            string _name,\r\n                            string _symbol,\r\n                            uint8 _decimals,\r\n                            uint256 _totalSupply) public\r\n                            returns (address) {\r\n    require(_startTime > now);\r\n    require(_durationTime > 0);\r\n\trequire(_hardcap > 0);\r\n\r\n    uint256 R2 = IEllipseMarketMaker(mmLibAddress).calcReserve(_reserveAmount, CLNTotalSupply, _totalSupply);\r\n    uint256 targetPrice = IEllipseMarketMaker(mmLibAddress).getPrice(_reserveAmount, R2, CLNTotalSupply, _totalSupply);\r\n    require(isValidIssuance(_hardcap, targetPrice, _totalSupply, R2));\r\n    address tokenAddress = super.createCurrency(_name,  _symbol,  _decimals,  _totalSupply);\r\n    addToMap(tokenAddress, _startTime, _startTime + _durationTime, _hardcap, _reserveAmount, targetPrice);\r\n\r\n    return tokenAddress;\r\n  }\r\n\r\n  /// @dev internal helper to add currency data to the issuance map\r\n  /// @param _token address token address for this issuance (same as CC adress)\r\n  /// @param _startTime uint256 blocktime for sale start\r\n  /// @param _endTime uint256 blocktime for sale end\r\n  /// @param _hardcap uint256 sale hardcap\r\n  /// @param _reserveAmount uint256 sale softcap\r\n  /// @param _targetPrice uint256 sale CC price per CLN if it were to pass the softcap\r\n  function addToMap(address _token,\r\n                    uint256 _startTime,\r\n                    uint256 _endTime,\r\n                    uint256 _hardcap,\r\n                    uint256 _reserveAmount,\r\n                    uint256 _targetPrice) private {\r\n  \tissueMap[_token] = IssuanceStruct({ hardcap: _hardcap,\r\n\t\t\t\t\t\t\t\t\t\treserve: _reserveAmount,\r\n\t\t\t\t\t\t\t\t\t\tstartTime: _startTime,\r\n\t\t\t\t\t\t\t\t\t\tendTime: _endTime,\r\n\t\t\t\t\t\t\t\t\t\tclnRaised: 0,\r\n\t\t\t\t\t\t\t\t\t\ttargetPrice: _targetPrice});\r\n  }\r\n\r\n  /// @dev participate in the issuance of the local currency\r\n  /// @param _token address token address for this issuance (same as CC adress)\r\n  /// @param _clnAmount uint256 amount of CLN to try and participate\r\n  /// @return releaseAmount uint ammount of CC tokens released and transfered to sender\r\n  function participate(address _token,\r\n\t\t\t\t\t\tuint256 _clnAmount) public\r\n\t\t\t\t\t\tsaleOpen(_token)\r\n\t\t\t\t\t\treturns (uint256 releaseAmount) {\r\n\trequire(_clnAmount > 0);\r\n    address marketMakerAddress = getMarketMakerAddressFromToken(_token);\r\n\r\n    // how much do we need to actually send to market maker of the incomming amount\r\n    // and how much of the amount can participate\r\n    uint256 transferToReserveAmount;\r\n    uint256 participationAmount;\r\n    (transferToReserveAmount, participationAmount) = getParticipationAmounts(_clnAmount, _token);\r\n    // send what we need to the market maker for reserve\r\n    require(ERC20(clnAddress).transferFrom(msg.sender, this, participationAmount));\r\n  \tapproveAndChange(clnAddress, _token, transferToReserveAmount, marketMakerAddress);\r\n    // pay back to participant with the participated amount * price\r\n    releaseAmount = participationAmount.mul(issueMap[_token].targetPrice).div(PRECISION);\r\n\r\n    issueMap[_token].clnRaised = issueMap[_token].clnRaised.add(participationAmount);\r\n    totalCLNcustodian = totalCLNcustodian.add(participationAmount);\r\n    CLNRaised(_token, msg.sender, participationAmount);\r\n    require(ERC20(_token).transfer(msg.sender, releaseAmount));\r\n  }\r\n\r\n  /// @dev Participate in the CLN based issuance (for contract)\r\n  /// @param _token address token address for this issuance (same as CC adress)\r\n  function participate(address _token)\r\n\t\t\t\t\t\tpublic\r\n\t\t\t\t\t\ttokenPayable\r\n\t\t\t\t\t\tsaleOpen(_token)\r\n\t\t\t\t\t\treturns (uint256 releaseAmount) {\r\n  \trequire(tkn.value > 0 && msg.sender == clnAddress);\r\n    //check if we need to send cln to mm or save it\r\n    uint256 transferToReserveAmount;\r\n    uint256 participationAmount;\r\n    (transferToReserveAmount, participationAmount) = getParticipationAmounts(tkn.value, _token);\r\n    address marketMakerAddress = getMarketMakerAddressFromToken(_token);\r\n  \tapproveAndChange(clnAddress, _token, transferToReserveAmount, marketMakerAddress);\r\n    // transfer only what we need\r\n    releaseAmount = participationAmount.mul(issueMap[_token].targetPrice).div(PRECISION);\r\n    issueMap[_token].clnRaised = issueMap[_token].clnRaised.add(participationAmount);\r\n    totalCLNcustodian = totalCLNcustodian.add(participationAmount);\r\n    CLNRaised(_token, tkn.sender, participationAmount);\r\n    require(ERC20(_token).transfer(tkn.sender, releaseAmount));\r\n    // send CLN change to the participent since its transferAndCall\r\n    if (tkn.value > participationAmount)\r\n       require(ERC20(clnAddress).transfer(tkn.sender, tkn.value.sub(participationAmount)));\r\n  }\r\n\r\n  /// @dev called by the creator to finish the sale, open the market maker and get his tokens\r\n  /// @dev can only be called after the sale end time and if the sale passed the softcap\r\n  /// @param _token address token address for this issuance (same as CC adress)\r\n  function finalize(address _token) public\r\n  \t\t\t\t\t\t\ttokenIssuerOnly(_token, msg.sender)\r\n  \t\t\t\t\t\t\thasEnded(_token)\r\n\t\t\t\t\t\t\tsaleWasSuccessfull(_token)\r\n  \t\t\t\t\t\t\tmarketClosed(_token)\r\n  \t\t\t\t\t\t\treturns (bool) {\r\n    // move all CC and CLN that were raised and not in the reserves to the issuer\r\n    address marketMakerAddress = getMarketMakerAddressFromToken(_token);\r\n    uint256 clnAmount = issueMap[_token].clnRaised.sub(issueMap[_token].reserve);\r\n    totalCLNcustodian = totalCLNcustodian.sub(clnAmount);\r\n    uint256 ccAmount = ERC20(_token).balanceOf(this);\r\n    // open Market Maker for public trade.\r\n    require(MarketMaker(marketMakerAddress).openForPublicTrade());\r\n\r\n    require(ERC20(_token).transfer(msg.sender, ccAmount));\r\n    require(ERC20(clnAddress).transfer(msg.sender, clnAmount));\r\n    SaleFinalized(_token, issueMap[_token].clnRaised);\r\n    return true;\r\n}\r\n\r\n  /// @dev Give back CC and get a refund back in CLN,\r\n  /// dev can only be called after sale ended and the softcap not reached\r\n  /// @param _token address token address for this issuance (same as CC adress)\r\n  /// @param _ccAmount uint256 amount of CC to try and refund\r\n  function refund(address _token,\r\n                  uint256 _ccAmount) public\r\n  \t\t\t\t\t\t\thasEnded(_token)\r\n  \t\t\t\t\t\t\tsaleHasFailed(_token)\r\n  \t\t\t\t\t\t\tmarketClosed(_token)\r\n  \t\t\t\t\t\t\treturns (bool) {\r\n\trequire(_ccAmount > 0);\r\n\t// exchange CC for CLN throuh Market Maker\r\n  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\r\n  \trequire(ERC20(_token).transferFrom(msg.sender, this, _ccAmount));\r\n  \tuint256 factoryCCAmount = ERC20(_token).balanceOf(this);\r\n  \trequire(ERC20(_token).approve(marketMakerAddress, factoryCCAmount));\r\n  \trequire(MarketMaker(marketMakerAddress).change(_token, factoryCCAmount, clnAddress) > 0);\r\n\r\n  \tuint256 returnAmount = _ccAmount.mul(PRECISION).div(issueMap[_token].targetPrice);\r\n    issueMap[_token].clnRaised = issueMap[_token].clnRaised.sub(returnAmount);\r\n    totalCLNcustodian = totalCLNcustodian.sub(returnAmount);\r\n    CLNRefunded(_token, msg.sender, returnAmount);\r\n  \trequire(ERC20(clnAddress).transfer(msg.sender, returnAmount));\r\n    return true;\r\n  }\r\n\r\n\r\n  /// @dev Give back CC and get a refund back in CLN,\r\n  /// dev can only be called after sale ended and the softcap not\r\n  function refund() public\r\n\t                tokenPayable\r\n\t\t\t\t\thasEnded(msg.sender)\r\n\t\t\t\t\tsaleHasFailed(msg.sender)\r\n\t\t\t\t\tmarketClosed(msg.sender)\r\n\t\t\t\t\treturns (bool) {\r\n\trequire(tkn.value > 0);\r\n  \t// if we have CC time to thorw it to the Market Maker\r\n  \taddress marketMakerAddress = getMarketMakerAddressFromToken(msg.sender);\r\n  \tuint256 factoryCCAmount = ERC20(msg.sender).balanceOf(this);\r\n  \trequire(ERC20(msg.sender).approve(marketMakerAddress, factoryCCAmount));\r\n  \trequire(MarketMaker(marketMakerAddress).change(msg.sender, factoryCCAmount, clnAddress) > 0);\r\n\r\n  \tuint256 returnAmount = tkn.value.mul(PRECISION).div(issueMap[msg.sender].targetPrice);\r\n    issueMap[msg.sender].clnRaised = issueMap[msg.sender].clnRaised.sub(returnAmount);\r\n    totalCLNcustodian = totalCLNcustodian.sub(returnAmount);\r\n    CLNRefunded(msg.sender, tkn.sender, returnAmount);\r\n  \trequire(ERC20(clnAddress).transfer(tkn.sender, returnAmount));\r\n    return true;\r\n\r\n  }\r\n\r\n  /// @dev normal send cln to the market maker contract, sender must approve() before calling method. can only be called by owner\r\n  /// @dev sending CLN will return CC from the reserve to the sender.\r\n  function insertCLNtoMarketMaker(address, uint256) public returns (uint256) {\r\n    require(false);\r\n    return 0;\r\n  }\r\n\r\n  /// @dev ERC223 transferAndCall, send cln to the market maker contract can only be called by owner (see MarketMaker)\r\n  /// @dev sending CLN will return CC from the reserve to the sender.\r\n  function insertCLNtoMarketMaker(address) public returns (uint256) {\r\n    require(false);\r\n    return 0;\r\n  }\r\n\r\n  /// @dev normal send CC to the market maker contract, sender must approve() before calling method. can only be called by owner\r\n  /// @dev sending CC will return CLN from the reserve to the sender.\r\n  function extractCLNfromMarketMaker(address, uint256) public returns (uint256) {\r\n    require(false);\r\n    return 0;\r\n  }\r\n\r\n  /// @dev ERC223 transferAndCall, send CC to the market maker contract can only be called by owner (see MarketMaker)\r\n  /// @dev sending CC will return CLN from the reserve to the sender.\r\n  function extractCLNfromMarketMaker() public returns (uint256) {\r\n    require(false);\r\n    return 0;\r\n  }\r\n\r\n  /// @dev opens the Market Maker to recvice transactions from all sources.\r\n  /// @dev Request to transfer ownership of Market Maker contract to Owner instead of factory.\r\n  function openMarket(address) public returns (bool) {\r\n\t\trequire(false);\r\n\t\treturn false;\r\n  }\r\n\r\n  /// @dev checks if the parameters that were sent to the create are valid for a promised price and buyback\r\n  /// @param _hardcap uint256 CLN hardcap for issuance\r\n  /// @param _price uint256 computed through the market maker using the supplies and reserves\r\n  /// @param _S2 uint256 supply of the CC token\r\n  /// @param _R2 uint256 reserve of the CC token\r\n  function isValidIssuance(uint256 _hardcap,\r\n                            uint256 _price,\r\n                            uint256 _S2,\r\n                            uint256 _R2) public view\r\n                            returns (bool) {\r\n \t  return (_S2 > _R2 && _S2.sub(_R2).mul(PRECISION) >= _hardcap.mul(_price));\r\n  }\r\n\r\n\r\n  /// @dev helper function to fetch market maker contract address deploed with the CC\r\n  /// @param _token address token address for this issuance (same as CC adress)\r\n  function getMarketMakerAddressFromToken(address _token) public constant returns (address) {\r\n  \treturn currencyMap[_token].mmAddress;\r\n  }\r\n\r\n  /// @dev helper function to approve tokens for market maker and then change tokens\r\n  /// @param _token address deployed ERC20 token address to spend\r\n  /// @param _token2 address deployed ERC20 token address to buy\r\n  /// @param _amount uint256 amount of _token to spend\r\n  /// @param _marketMakerAddress address for the deploed market maker with this CC\r\n  function approveAndChange(address _token,\r\n                            address _token2,\r\n                            uint256 _amount,\r\n                            address _marketMakerAddress) private\r\n                            returns (uint256) {\r\n  \tif (_amount > 0) {\r\n\t  \trequire(ERC20(_token).approve(_marketMakerAddress, _amount));\r\n\t  \treturn MarketMaker(_marketMakerAddress).change(_token, _amount, _token2);\r\n\t  }\r\n\t  return 0;\r\n  }\r\n\r\n  /// @dev helper function participation with CLN\r\n  /// @dev returns the amount to send to reserve and amount to participate\r\n  /// @param _clnAmount amount of cln the user wants to participate with\r\n  /// @param _token address token address for this issuance (same as CC adress)\r\n  /// @return {\r\n  ///\t\"transferToReserveAmount\": ammount of CLN to transfer to reserves\r\n  ///\t\"participationAmount\": ammount of CLN that the sender will participate with in the sale\r\n  ///}\r\n  function getParticipationAmounts(uint256 _clnAmount,\r\n                                   address _token) private view\r\n                                   returns (uint256 transferToReserveAmount, uint256 participationAmount) {\r\n    uint256 clnRaised = issueMap[_token].clnRaised;\r\n    uint256 reserve = issueMap[_token].reserve;\r\n    uint256 hardcap = issueMap[_token].hardcap;\r\n    participationAmount = SafeMath.min256(_clnAmount, hardcap.sub(clnRaised));\r\n    if (reserve > clnRaised) {\r\n      transferToReserveAmount = SafeMath.min256(participationAmount, reserve.sub(clnRaised));\r\n    }\r\n  }\r\n\r\n  /// @dev Returns total number of issuances after filters are applied.\r\n  /// @dev this function is gas wasteful so do not call this from a state changing transaction\r\n  /// @param _pending include pending currency issuances.\r\n  /// @param _started include started currency issuances.\r\n  /// @param _successful include successful and ended currency issuances.\r\n  /// @param _failed include failed and ended currency issuances.\r\n  /// @return Total number of currency issuances after filters are applied.\r\n  function getIssuanceCount(bool _pending, bool _started, bool _successful, bool _failed)\r\n    public\r\n    view\r\n    returns (uint _count)\r\n  {\r\n    for (uint i = 0; i < tokens.length; i++) {\r\n      IssuanceStruct memory issuance = issueMap[tokens[i]];\r\n      if ((_pending && issuance.startTime > now)\r\n        || (_started && now >= issuance.startTime && issuance.endTime >= now && issuance.clnRaised < issuance.hardcap)\r\n        || (_successful && issuance.endTime < now && issuance.clnRaised >= issuance.reserve)\r\n        || (_successful && issuance.endTime >= now && issuance.clnRaised == issuance.hardcap)\r\n        || (_failed && issuance.endTime < now && issuance.clnRaised < issuance.reserve))\r\n        _count += 1;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns list of issuance ids (allso the token address of the issuance) in defined range after filters are applied.\r\n  /// @dev _offset and _limit parameters are intended for pagination\r\n  /// @dev this function is gas wasteful so do not call this from a state changing transaction\r\n  /// @param _pending include pending currency issuances.\r\n  /// @param _started include started currency issuances.\r\n  /// @param _successful include successful and ended currency issuances.\r\n  /// @param _failed include failed and ended currency issuances.\r\n  /// @param _offset index start position of issuance ids array.\r\n  /// @param _limit maximum number of issuance ids to return.\r\n  /// @return Returns array of token adresses for issuance.\r\n  function getIssuanceIds(bool _pending, bool _started, bool _successful, bool _failed, uint _offset, uint _limit)\r\n    public\r\n    view\r\n    returns (address[] _issuanceIds)\r\n  {\r\n\trequire(_limit >= 1);\r\n\trequire(_limit <= 100);\r\n    _issuanceIds = new address[](_limit);\r\n    uint filteredIssuancesCount = 0;\r\n\tuint retrieveIssuancesCount = 0;\r\n    for (uint i = 0; i < tokens.length; i++) {\r\n      IssuanceStruct memory issuance = issueMap[tokens[i]];\r\n      if ((_pending && issuance.startTime > now)\r\n        || (_started && now >= issuance.startTime && issuance.endTime >= now && issuance.clnRaised < issuance.hardcap)\r\n        || (_successful && issuance.endTime < now && issuance.clnRaised >= issuance.reserve)\r\n        || (_successful && issuance.endTime >= now && issuance.clnRaised == issuance.hardcap)\r\n        || (_failed && issuance.endTime < now && issuance.clnRaised < issuance.reserve))\r\n      {\r\n\t\tif (filteredIssuancesCount >= _offset) {\r\n\t\t\t_issuanceIds[retrieveIssuancesCount] = tokens[i];\r\n\t\t\tretrieveIssuancesCount += 1;\r\n\t\t}\r\n\t\tif (retrieveIssuancesCount == _limit) {\r\n\t\t\treturn _issuanceIds;\r\n\t\t}\r\n        filteredIssuancesCount += 1;\r\n      }\r\n    }\r\n\r\n\tif (retrieveIssuancesCount < _limit) {\r\n\t\taddress[] memory _issuanceIdsTemp = new address[](retrieveIssuancesCount);\r\n\t\tfor (i = 0; i < retrieveIssuancesCount; i++) {\r\n\t\t\t_issuanceIdsTemp[i] = _issuanceIds[i];\r\n\t\t}\r\n\t\treturn _issuanceIdsTemp;\r\n\t}\r\n  }\r\n\r\n  /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n  /// @param _tokenAddress address The address of the ERC20 contract.\r\n  /// @param _amount uint256 The amount of tokens to be transferred.\r\n  function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\r\n    if (_tokenAddress == clnAddress) {\r\n      uint256 excessCLN = ERC20(clnAddress).balanceOf(this).sub(totalCLNcustodian);\r\n      require(excessCLN <= _amount);\r\n    }\r\n\r\n    if (issueMap[_tokenAddress].hardcap > 0) {\r\n      require(MarketMaker(currencyMap[_tokenAddress].mmAddress).isOpenForPublic());\r\n    }\r\n    return ERC20(_tokenAddress).transfer(owner, _amount);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"supportsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pending\",\"type\":\"bool\"},{\"name\":\"_started\",\"type\":\"bool\"},{\"name\":\"_successful\",\"type\":\"bool\"},{\"name\":\"_failed\",\"type\":\"bool\"}],\"name\":\"getIssuanceCount\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"currencyMap\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"mmAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"openMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hardcap\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_S2\",\"type\":\"uint256\"},{\"name\":\"_R2\",\"type\":\"uint256\"}],\"name\":\"isValidIssuance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_ccAmount\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_durationTime\",\"type\":\"uint256\"},{\"name\":\"_hardcap\",\"type\":\"uint256\"},{\"name\":\"_reserveAmount\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"createIssuance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clnAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCLNcustodian\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mmLibAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"extractCLNfromMarketMaker\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"finalize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getMarketMakerAddressFromToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"issueMap\",\"outputs\":[{\"name\":\"hardcap\",\"type\":\"uint256\"},{\"name\":\"reserve\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"name\":\"clnRaised\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_clnAmount\",\"type\":\"uint256\"}],\"name\":\"participate\",\"outputs\":[{\"name\":\"releaseAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"insertCLNtoMarketMaker\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"participate\",\"outputs\":[{\"name\":\"releaseAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLNTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pending\",\"type\":\"bool\"},{\"name\":\"_started\",\"type\":\"bool\"},{\"name\":\"_successful\",\"type\":\"bool\"},{\"name\":\"_failed\",\"type\":\"bool\"},{\"name\":\"_offset\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"getIssuanceIds\",\"outputs\":[{\"name\":\"_issuanceIds\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"createCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extractCLNfromMarketMaker\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"insertCLNtoMarketMaker\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_mmLib\",\"type\":\"address\"},{\"name\":\"_clnAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CLNRaised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CLNRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"clnRaised\",\"type\":\"uint256\"}],\"name\":\"SaleFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"marketMaker\",\"type\":\"address\"}],\"name\":\"MarketOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"IssuanceFactory","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c70636e0886ec4a4f2b7e42ac57ccd1b976352d00000000000000000000000004162178b78d6985480a308b2190ee5517460406d","Library":"","SwarmSource":"bzzr://94513e9f55e7a023d460b6dc293d3284c748adb3dbae2a07a2d74dc6f9fd94a1"}]}