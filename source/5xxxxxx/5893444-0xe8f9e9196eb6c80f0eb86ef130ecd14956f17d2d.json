{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;        // v0.4.18 was the latest possible version. 0.4.19 and above were not allowed\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\nlibrary SafeMath \r\n{\r\n    //--------------------------------------------------------------------------\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0)     return 0;\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nlibrary StringLib \r\n{\r\n    function concat(string strA, string strB) internal pure returns (string)\r\n    {\r\n        uint            i;\r\n        uint            g;\r\n        uint            finalLen;\r\n        bytes memory    dataStrA;\r\n        bytes memory    dataStrB;\r\n        bytes memory    buffer;\r\n\r\n        dataStrA  = bytes(strA);\r\n        dataStrB  = bytes(strB);\r\n\r\n        finalLen  = dataStrA.length + dataStrB.length;\r\n        buffer    = new bytes(finalLen);\r\n\r\n        for (g=i=0; i<dataStrA.length; i++)   buffer[g++] = dataStrA[i];\r\n        for (i=0;   i<dataStrB.length; i++)   buffer[g++] = dataStrB[i];\r\n\r\n        return string(buffer);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function same(string strA, string strB) internal pure returns(bool)\r\n    {\r\n        return keccak256(strA)==keccak256(strB);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function uintToAscii(uint number) internal pure returns(byte) \r\n    {\r\n             if (number < 10)         return byte(48 + number);\r\n        else if (number < 16)         return byte(87 + number);\r\n\r\n        revert();\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function asciiToUint(byte char) internal pure returns (uint) \r\n    {\r\n        uint asciiNum = uint(char);\r\n\r\n             if (asciiNum > 47 && asciiNum < 58)    return asciiNum - 48;\r\n        else if (asciiNum > 96 && asciiNum < 103)   return asciiNum - 87;\r\n\r\n        revert();\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function bytes32ToString (bytes32 data) internal pure returns (string) \r\n    {\r\n        bytes memory bytesString = new bytes(64);\r\n\r\n        for (uint j=0; j < 32; j++) \r\n        {\r\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\r\n\r\n            bytesString[j*2+0] = uintToAscii(uint(char) / 16);\r\n            bytesString[j*2+1] = uintToAscii(uint(char) % 16);\r\n        }\r\n        return string(bytesString);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function stringToBytes32(string str) internal pure returns (bytes32) \r\n    {\r\n        bytes memory bString = bytes(str);\r\n        uint uintString;\r\n\r\n        if (bString.length != 64) { revert(); }\r\n\r\n        for (uint i = 0; i < 64; i++) \r\n        {\r\n            uintString = uintString*16 + uint(asciiToUint(bString[i]));\r\n        }\r\n        return bytes32(uintString);\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract ERC20 \r\n{\r\n    function balanceOf(   address _owner)                               public constant returns (uint256 balance);\r\n    function transfer(    address toAddr,  uint256 amount)              public returns (bool success);\r\n    function allowance(   address owner,   address spender)             public constant returns (uint256);\r\n    function approve(     address spender, uint256 value)               public returns (bool);\r\n\r\n    event Transfer(address indexed fromAddr, address indexed toAddr,   uint256 amount);\r\n    event Approval(address indexed _owner,   address indexed _spender, uint256 amount);\r\n\r\n    uint256 public totalSupply;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract Ownable \r\n{\r\n    address public owner;\r\n\r\n    //-------------------------------------------------------------------------- @dev The Ownable constructor sets the original `owner` of the contract to the sender account\r\n    function Ownable() public \r\n    {\r\n        owner = msg.sender;\r\n    }\r\n    //-------------------------------------------------------------------------- @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract Lockable is Ownable \r\n{\r\n    uint256 internal constant lockedUntil = 1530604800;     // 2018-07-03 08:00 (GMT+0)\r\n\r\n    address internal allowedSender;     // the address that can make transactions when the transaction is locked \r\n\r\n    //-------------------------------------------------------------------------- @dev Allow access only when is unlocked. This function is good when you make crowdsale to avoid token expose in exchanges\r\n    modifier unlocked() \r\n    {\r\n        require((now > lockedUntil) || (allowedSender == msg.sender));\r\n        _;\r\n    }\r\n    //-------------------------------------------------------------------------- @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    function transferOwnership(address newOwner) public onlyOwner               // @param newOwner The address to transfer ownership to.\r\n    {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n\r\n        allowedSender = newOwner;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract Token is ERC20, Lockable \r\n{\r\n    using SafeMath for uint256;\r\n\r\n    address public                                      owner;          // Owner of this contract\r\n    mapping(address => uint256)                         balances;       // Maintain balance in a mapping\r\n    mapping(address => mapping (address => uint256))    allowances;     // Allowances index-1 = Owner account   index-2 = spender account\r\n\r\n    //------ TOKEN SPECIFICATION\r\n\r\n    string public constant      name     = \"TESTGVINE1\";\r\n    string public constant      symbol   = \"TESTGVINE1\";\r\n\r\n    uint256 public constant     decimals = 18;      // Handle the coin as FIAT (2 decimals). ETH Handles 18 decimal places\r\n\r\n    uint256 public constant     initSupply = 825000000 * 10**decimals;        // 10**18 max\r\n\r\n    string private constant     supplyReserveMode=\"percent\";        // \"quantity\" or \"percent\"\r\n    uint256 public constant     supplyReserveVal = 58;          // if quantity => (val * 10**decimals)   if percent => val;\r\n\r\n    uint256 public              icoSalesSupply   = 0;                   // Needed when burning tokens\r\n    uint256 public              icoReserveSupply = 0;\r\n\r\n    //-------------------------------------------------------------------------- Functions with this modifier can only be executed by the owner\r\n    modifier onlyOwner() \r\n    {\r\n        if (msg.sender != allowedSender) \r\n        {\r\n            assert(true==false);\r\n        }\r\n        _;\r\n    }\r\n    //-------------------------------------------------------------------------- Functions with this modifier can only be executed by the owner\r\n    modifier onlyOwnerDuringIco() \r\n    {\r\n        if (msg.sender!=allowedSender || now > lockedUntil) \r\n        {\r\n            assert(true==false);\r\n        }\r\n        _;\r\n    }\r\n    //-------------------------------------------------------------------------- Constructor\r\n    function Token() public \r\n    {\r\n        owner           = msg.sender;\r\n        totalSupply     = initSupply;\r\n        balances[owner] = initSupply;   // send the tokens to the owner\r\n\r\n        //-----\r\n\r\n        allowedSender = owner;          // In this contract, only the contract owner can send token while ICO is active.\r\n\r\n        //----- Handling if there is a special maximum amount of tokens to spend during the ICO or not\r\n\r\n        icoSalesSupply = totalSupply;   \r\n\r\n        if (StringLib.same(supplyReserveMode, \"quantity\"))\r\n        {\r\n            icoSalesSupply = totalSupply.sub(supplyReserveVal);\r\n        }\r\n        else if (StringLib.same(supplyReserveMode, \"percent\"))\r\n        {\r\n            icoSalesSupply = totalSupply.mul(supplyReserveVal).div(100);\r\n        }\r\n\r\n        icoReserveSupply = totalSupply.sub(icoSalesSupply);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function transfer(address toAddr, uint256 amount)  public   unlocked returns (bool success) \r\n    {\r\n        require(toAddr!=0x0 && toAddr!=msg.sender && amount>0);     // Prevent transfer to 0x0 address and to self, amount must be >0\r\n\r\n        uint256 availableTokens      = balances[msg.sender];\r\n\r\n        if (msg.sender==allowedSender)                              // Special handling on contract owner \r\n        {\r\n            if (now <= lockedUntil)                                 // The ICO is now running\r\n            {\r\n                uint256 balanceAfterTransfer = availableTokens.sub(amount);      \r\n\r\n                assert(balanceAfterTransfer >= icoReserveSupply);          // don't sell more than allowed during ICO\r\n            }\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(amount);\r\n        balances[toAddr]     = balances[toAddr].add(amount);\r\n\r\n        emit Transfer(msg.sender, toAddr, amount);\r\n        //Transfer(msg.sender, toAddr, amount);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function balanceOf(address _owner)  public   constant returns (uint256 balance) \r\n    {\r\n        return balances[_owner];\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function approve(address _spender, uint256 amount)  public   returns (bool) \r\n    {\r\n        require((amount == 0) || (allowances[msg.sender][_spender] == 0));\r\n\r\n        allowances[msg.sender][_spender] = amount;\r\n\r\n        emit Approval(msg.sender, _spender, amount);\r\n        //Approval(msg.sender, _spender, amount);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function allowance(address _owner, address _spender)  public   constant returns (uint remaining)\r\n    {\r\n        return allowances[_owner][_spender];    // Return the allowance for _spender approved by _owner\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function() public                       \r\n    {\r\n        assert(true == false);      // If Ether is sent to this address, don't handle it -> send it back.\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n\r\n\r\n    //--------------------------------------------------------------------------\r\n    //\r\n    // When ICO is closed, send the relaining (unsold) tokens to address 0x0\r\n    // So no one will be able to use it anymore... \r\n    // Anyone can check address 0x0, so to proove unsold tokens belong to no one anymore\r\n    //\r\n    //--------------------------------------------------------------------------\r\n    function destroyRemainingTokens() public unlocked /*view*/ returns(uint)\r\n    {\r\n        require(msg.sender==allowedSender && now>lockedUntil);\r\n\r\n        address   toAddr = 0x0000000000000000000000000000000000000000;\r\n\r\n        uint256   amountToBurn = balances[allowedSender];\r\n\r\n        if (amountToBurn > icoReserveSupply)\r\n        {\r\n            amountToBurn = amountToBurn.sub(icoReserveSupply);\r\n        }\r\n\r\n        balances[owner]  = balances[allowedSender].sub(amountToBurn);\r\n        balances[toAddr] = balances[toAddr].add(amountToBurn);\r\n\r\n        //emit Transfer(msg.sender, toAddr, amount);\r\n        Transfer(msg.sender, toAddr, amountToBurn);\r\n\r\n        return 1;\r\n    }        \r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoReserveSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoSalesSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyReserveVal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyRemainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5d0f906721d35f3eddacbe3d910936a9f9f462b399875c97359aeebfc7045baf"}]}