{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function decimals() public view returns(uint digits);\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ninterface tokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\r\n}\r\n\r\ncontract BurnableToken is ERC20 {\r\n\r\n    function burn(uint256 _value) public returns (bool success);\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success);\r\n\r\n    event Burn(address indexed _from, uint256 _value);\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address newOwner=0x0;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    ///change the owner\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /// accept the ownership\r\n    function acceptOwnership() public{\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    /// `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Controlled is Ownable{\r\n\r\n    function Controlled() public {\r\n        exclude[msg.sender] = true;\r\n        exclude[this] = true;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        if(msg.sender != owner){\r\n            require(admins[msg.sender]);\r\n        }\r\n        _;\r\n    }\r\n\r\n    mapping(address => bool) admins;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transferEnabled = false;\r\n\r\n    // frozen account\r\n    mapping(address => bool) exclude;\r\n    mapping(address => bool) locked;\r\n    mapping(address => bool) public frozenAccount;\r\n\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n\r\n    function setAdmin(address _addr, bool isAdmin) public onlyOwner\r\n    returns (bool success){\r\n        admins[_addr]=isAdmin;\r\n        return true;\r\n    }\r\n\r\n\r\n    function enableTransfer(bool _enable) public onlyOwner{\r\n        transferEnabled=_enable;\r\n    }\r\n\r\n\r\n    function setExclude(address _addr, bool isExclude) public onlyOwner returns (bool success){\r\n        exclude[_addr]=isExclude;\r\n        return true;\r\n    }\r\n\r\n    function setLock(address _addr, bool isLock) public onlyAdmin returns (bool success){\r\n        locked[_addr]=isLock;\r\n        return true;\r\n    }\r\n\r\n\r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\r\n    modifier transferAllowed(address _addr) {\r\n        require(!frozenAccount[_addr]);\r\n        if (!exclude[_addr]) {\r\n            require(transferEnabled);\r\n            require(!locked[_addr]);\r\n        }\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract TokenERC20 is  ERC20, BurnableToken, Controlled {\r\n\r\n    using SafeMath for uint256;\r\n\r\n   // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    string public version = 'v1.0';\r\n\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balanceOf\r\n    mapping (address => uint256)  public balanceOf;\r\n    mapping (address => mapping (address => uint256))  public allowance;\r\n\r\n\r\n    function totalSupply() public view returns (uint supply){\r\n        return totalSupply;\r\n    }\r\n    function decimals() public view returns(uint digits){\r\n        return decimals;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance){\r\n        return balanceOf[_owner];\r\n    }\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining){\r\n        return allowance[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) transferAllowed(_from) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) transferAllowed(_from) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n    returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n    public\r\n    returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n     /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract AdvancedToken is  TokenERC20 {\r\n\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    uint  constant internal PRECISION = (10**18);\r\n\r\n    // allocate end time, default is now plus 1 days\r\n    uint256 public allocateEndTime;\r\n\r\n    function AdvancedToken() public {\r\n       allocateEndTime = now + 1 days;\r\n    }\r\n\r\n    // Allocate tokens to the users\r\n    // @param _owners The owners list of the token\r\n    // @param _values The value list of the token (value = _value * 10 ** decimals)\r\n    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {\r\n        require(allocateEndTime > now);\r\n        require(_owners.length == _values.length);\r\n        for(uint256 i = 0; i < _owners.length ; i++){\r\n            address to = _owners[i];\r\n            uint256 value = _values[i] * 10 ** uint256(decimals);\r\n            require(totalSupply + value > totalSupply && balanceOf[to] + value > balanceOf[to]) ;\r\n            totalSupply += value;\r\n            balanceOf[to] += value;\r\n        }\r\n    }\r\n\r\n\r\n    //Early stage investing\r\n    bool enableEarlyStage = false;\r\n    uint256 public totalEarlyStage;\r\n    uint256 remainEarlyStage;\r\n    uint256 earlyStagePrice;   //PRECISION=10**18\r\n    uint256 earlyStageGiftRate;     //x/10000\r\n\r\n    // air drop token\r\n    bool enableAirdrop = false;\r\n    uint256 public totalAirdrop;\r\n    uint256 remainAirdrop;\r\n    mapping (address => bool) dropList;\r\n    uint256 public airdropValue;\r\n\r\n\r\n    modifier canEarlyStage() {\r\n        require(enableEarlyStage && remainEarlyStage>0 && earlyStagePrice>0 && balanceOf[this]>0);\r\n        _;\r\n    }\r\n\r\n    modifier canAirdrop() {\r\n        require(enableAirdrop && remainAirdrop>0);\r\n        _;\r\n    }\r\n\r\n    modifier canGetTokens() {\r\n        require(enableAirdrop && remainAirdrop>0 &&  airdropValue>0);\r\n        require(dropList[msg.sender] == false);\r\n        _;\r\n    }\r\n\r\n    function setEarlyParams (bool isEarlyStage, uint256 _price, uint256 _earlyStageGiftRate) onlyOwner public {\r\n        if(isEarlyStage){\r\n            require(_price>0);\r\n            require(_earlyStageGiftRate>=0 && _earlyStageGiftRate<= 10000 );\r\n        }\r\n        enableEarlyStage = isEarlyStage;\r\n        if(_price>0){\r\n            earlyStagePrice = _price;\r\n        }\r\n        if(_earlyStageGiftRate>0){\r\n            earlyStageGiftRate = _earlyStageGiftRate;\r\n        }\r\n\r\n    }\r\n\r\n    function setAirdropParams (bool isAirdrop, uint256 _value) onlyAdmin public {\r\n        if(isAirdrop){\r\n            require(_value>0);\r\n        }\r\n        airdropValue = _value;\r\n    }\r\n\r\n\r\n    function setAirdorpList(address[] addresses, bool hasDrop) onlyAdmin public {\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            dropList[addresses[i]] = hasDrop;\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Buy tokens from contract by sending ether\r\n     function buy() payable public {\r\n         _buy(msg.value);\r\n     }\r\n\r\n    function _buy(uint256 value)  private returns(uint256){\r\n        uint256 amount = 0;\r\n        if(value>0){\r\n            amount = uint256(PRECISION).mul(value).div(earlyStagePrice).div(10**uint256(ETH_DECIMALS-decimals));    // calculates the amount\r\n        }\r\n        if(amount>0){\r\n            _transfer(this, msg.sender, amount);\r\n            if(earlyStageGiftRate>0){\r\n                _transfer(this, msg.sender, amount.mul(earlyStageGiftRate).div(10000));\r\n            }\r\n        }\r\n        return amount;\r\n    }\r\n\r\n\r\n    function () payable public {\r\n        if(msg.value>0){\r\n            _buy(msg.value);\r\n        }\r\n        if( enableAirdrop && remainAirdrop>0  &&  airdropValue>0 && dropList[msg.sender] == false){\r\n             _getTokens();\r\n        }\r\n    }\r\n\r\n\r\n    function _airdrop(address _owner, uint256 _value)  canAirdrop private returns(bool) {\r\n        require(_value>0);\r\n        _transfer(this, _owner, _value);\r\n        return true;\r\n    }\r\n\r\n     // drop token\r\n    function airdrop(address[] _owners, uint256 _value) onlyAdmin canAirdrop public {\r\n         require(_value>0 && remainAirdrop>= _value * _owners.length);\r\n         for(uint256 i = 0; i < _owners.length ; i++){\r\n             _airdrop(_owners[i], _value);\r\n        }\r\n     }\r\n\r\n\r\n    function _getTokens()  private returns(bool) {\r\n        address investor = msg.sender;\r\n        uint256 toGive = airdropValue;\r\n        if (toGive > 0) {\r\n            _airdrop(investor, toGive);\r\n            dropList[investor] = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * Proxy transfer  token. When some users of the ethereum account has no ether,\r\n    * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\r\n    * @param _from\r\n    * @param _to\r\n    * @param _value\r\n    * @param feeProxy\r\n    * @param _v\r\n    * @param _r\r\n    * @param _s\r\n    */\r\n    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeProxy,\r\n        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\r\n        require(_value + _feeProxy >= _value);\r\n        require(balanceOf[_from] >=_value  + _feeProxy);\r\n        uint256 nonce = nonces[_from];\r\n        bytes32 h = keccak256(_from,_to,_value,_feeProxy,nonce);\r\n        require(_from == ecrecover(h,_v,_r,_s));\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        require(balanceOf[msg.sender] + _feeProxy > balanceOf[msg.sender]);\r\n        balanceOf[_from] -= (_value  + _feeProxy);\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        if(_feeProxy>0){\r\n            balanceOf[msg.sender] += _feeProxy;\r\n            Transfer(_from, msg.sender, _feeProxy);\r\n        }\r\n        nonces[_from] = nonce + 1;\r\n        return true;\r\n    }\r\n\r\n    // support withdraw\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyOwner {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyOwner {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n\r\n\r\n    // The nonce for avoid transfer replay attacks\r\n    mapping(address => uint256) nonces;\r\n\r\n    /*\r\n     * Get the nonce\r\n     * @param _addr\r\n     */\r\n    function getNonce(address _addr) public constant returns (uint256){\r\n        return nonces[_addr];\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SafeasyToken is AdvancedToken {\r\n\r\n   function SafeasyToken() public{\r\n        name = \"Safeasy Token\";\r\n        decimals = 6;\r\n        symbol = \"SET\";\r\n        version = 'v1.1';\r\n\r\n        uint256 initialSupply = uint256(2* 10 ** 9);\r\n        totalSupply = initialSupply.mul( 10 ** uint256(decimals));\r\n\r\n        enableEarlyStage = true;\r\n        totalEarlyStage = totalSupply.div(100).mul(30);\r\n        remainEarlyStage = totalEarlyStage;\r\n        earlyStagePrice = 10 ** 14; // 10**18=1:1eth, 10**15=1000:1eth\r\n        earlyStageGiftRate = 2000;  // 100=1%\r\n        enableAirdrop = true;\r\n        totalAirdrop = totalSupply.div(100).mul(15);\r\n        remainAirdrop = totalAirdrop;\r\n        airdropValue = 50000000;\r\n\r\n        uint256 totalDistributed = totalEarlyStage.add(totalAirdrop);\r\n        balanceOf[this] = totalDistributed;\r\n        balanceOf[msg.sender] = totalSupply.sub(totalDistributed);\r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"digits\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"hasDrop\",\"type\":\"bool\"}],\"name\":\"setAirdorpList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isAirdrop\",\"type\":\"bool\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setAirdropParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAirdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isEarlyStage\",\"type\":\"bool\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_earlyStageGiftRate\",\"type\":\"uint256\"}],\"name\":\"setEarlyParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"isExclude\",\"type\":\"bool\"}],\"name\":\"setExclude\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"allocateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"isLock\",\"type\":\"bool\"}],\"name\":\"setLock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocateEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEarlyStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_feeProxy\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"transferProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"enableTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SafeasyToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://12676e875f1c7c5b6db3cf4f61cd23dd3f6172bce64e7409dd6ef36fbff89330"}]}