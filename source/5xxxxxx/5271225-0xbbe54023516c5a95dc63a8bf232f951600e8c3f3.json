{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/*\r\n * ERC223 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n * see https://github.com/ethereum/EIPs/issues/223\r\n */\r\ncontract ERC223 {\r\n    function totalSupply() constant public returns (uint256 outTotalSupply);\r\n    function balanceOf( address _owner) constant public returns (uint256 balance);\r\n    function transfer( address _to, uint256 _value) public returns (bool success);\r\n    function transfer( address _to, uint256 _value, bytes _data) public returns (bool success);\r\n    function transferFrom( address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve( address _spender, uint256 _value) public returns (bool success);\r\n    function allowance( address _owner, address _spender) constant public returns (uint256 remaining);\r\n    event Transfer( address indexed _from, address indexed _to, uint _value, bytes _data);\r\n    event Approval( address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract ERC223Receiver { \r\n    /**\r\n     * @dev Standard ERC223 function that will handle incoming token transfers.\r\n     *\r\n     * @param _from  Token sender address.\r\n     * @param _value Amount of tokens.\r\n     * @param _data  Transaction metadata.\r\n     */\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n \r\n}\r\n\r\n\r\n\r\n/**\r\n * Standard ERC223\r\n */\r\ncontract StandardToken is ERC223, SafeMath {\r\n        \r\n    uint256 public supplyNum;\r\n\t\r\n\tuint256 public decimals;\r\n\r\n    /* Actual mapBalances of token holders */\r\n    mapping(address => uint) mapBalances;\r\n\r\n    /* approve() allowances */\r\n    mapping (address => mapping (address => uint)) mapApproved;\r\n\r\n    /* Interface declaration */\r\n    function isToken() public pure returns (bool weAre) {\r\n        return true;\r\n    }\r\n\r\n\r\n    function totalSupply() constant public returns (uint256 outTotalSupply) {\r\n        return supplyNum;\r\n    }\r\n\r\n    \r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        mapBalances[msg.sender] = safeSub(mapBalances[msg.sender], _value);\r\n        mapBalances[_to] = safeAdd(mapBalances[_to], _value);\r\n        \r\n        if (codeLength > 0) {\r\n            ERC223Receiver receiver = ERC223Receiver(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        uint codeLength;\r\n        bytes memory empty;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        mapBalances[msg.sender] = safeSub(mapBalances[msg.sender], _value);\r\n        mapBalances[_to] = safeAdd(mapBalances[_to], _value);\r\n        \r\n        if (codeLength > 0) {\r\n            ERC223Receiver receiver = ERC223Receiver(_to);\r\n            receiver.tokenFallback(msg.sender, _value, empty);\r\n        }\r\n        Transfer(msg.sender, _to, _value, empty);\r\n        return true;\r\n    }\r\n    \r\n    \r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        mapApproved[_from][msg.sender] = safeSub(mapApproved[_from][msg.sender], _value);\r\n        mapBalances[_from] = safeSub(mapBalances[_from], _value);\r\n        mapBalances[_to] = safeAdd(mapBalances[_to], _value);\r\n        \r\n        bytes memory empty;\r\n        Transfer(_from, _to, _value, empty);\r\n                \r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) view public returns (uint balance)    {\r\n        return mapBalances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success)    {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //    allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //    already 0 to mitigate the race condition described here:\r\n        //    https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require (_value != 0); \r\n        require (mapApproved[msg.sender][_spender] == 0);\r\n\r\n        mapApproved[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) view public returns (uint remaining)    {\r\n        return mapApproved[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Centrally issued Ethereum token.\r\n *\r\n * We mix in burnable and upgradeable traits.\r\n *\r\n * Token supply is created in the token contract creation and allocated to owner.\r\n * The owner can then transfer from its supply to crowdsale participants.\r\n * The owner, or anybody, can burn any excessive tokens they are holding.\r\n *\r\n */\r\ncontract MiewGold is StandardToken {\r\n\r\n    string public name = \"Miew Gold\";\r\n    string public symbol = \"MIEW\";\r\n    \r\n\t\r\n\taddress public coinMaster;\r\n    \r\n    \r\n    /** Name and symbol were updated. */\r\n    event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n    function MiewGold() public {\r\n\t\tsupplyNum = 10000000000 * (10 ** 18);\r\n\t\tdecimals = 18;\r\n        coinMaster = msg.sender;\r\n\r\n        // Allocate initial balance to the owner\r\n        mapBalances[coinMaster] = supplyNum;\r\n    }\r\n\r\n    /**\r\n     * Owner can update token information here.\r\n     *\r\n     * It is often useful to conceal the actual token association, until\r\n     * the token operations, like central issuance or reissuance have been completed.\r\n     * In this case the initial token can be supplied with empty name and symbol information.\r\n     *\r\n     * This function allows the token owner to rename the token after the operations\r\n     * have been completed and then point the audience to use the token contract.\r\n     */\r\n    function setTokenInformation(string _name, string _symbol) public {\r\n        require(msg.sender == coinMaster) ;\r\n\r\n        require(bytes(name).length > 0 && bytes(symbol).length > 0);\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        UpdatedTokenInformation(name, symbol);\r\n    }\r\n    \r\n    \r\n    \r\n    /// transfer dead tokens to contract master\r\n    function withdrawTokens() external {\r\n        uint256 fundNow = balanceOf(this);\r\n        transfer(coinMaster, fundNow);//token\r\n\t\t\r\n\t\tuint256 balance = this.balance;\r\n\t\tcoinMaster.transfer(balance);//eth\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"outTotalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setTokenInformation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isToken\",\"outputs\":[{\"name\":\"weAre\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"UpdatedTokenInformation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MiewGold","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6955195f2c3bb9a991e0eef692de3f9da35c793ae2c71758499852dc9847a4cf"}]}