{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\n//import \"./SafeMathLib.sol\";\r\n/**\r\n * Safe unsigned safe math.\r\n *\r\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\n *\r\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\r\n *\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\n *\r\n */\r\nlibrary SafeMathLib {\r\n\r\n  function times(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function minus(uint a, uint b) internal pure returns (uint) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function plus(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a);\r\n    return c;\r\n  }\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    require(b > 0);\r\n    uint c = a / b;\r\n    require(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint);\r\n  function allowance(address owner, address spender) public constant returns (uint);\r\n\r\n  function transfer(address to, uint value) public  returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n  function approve(address spender, uint value) public returns (bool ok);\r\n   event Transfer(address indexed from, address indexed to, uint value);\r\n   event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal pure returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    require(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal pure returns (uint) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  //function assert(bool assertion) internal pure{\r\n  //  require (assertion);\r\n  //}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  /* Token supply got increased and a new owner received these tokens */\r\n   event Minted(address receiver, uint amount);\r\n\r\n  /* Actual balances of token holders */\r\n  mapping(address => uint) balances;\r\n\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  /* Interface declaration */\r\n  function isToken() public pure returns (bool weAre) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http://vessenes.com/the-erc20-short-address-attack-explained/\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     //require(msg.data.length < size + 4);\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\r\n    require(_value >= 0);\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    //requre the alloced greater than _value\r\n    require(_allowance >= _value);\r\n    require(_value >= 0);\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value)public returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    //if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n    require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /* Util */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) } // solium-disable-line\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  mapping (address => bool) private admins;\r\n  mapping (address => bool) private developers;\r\n  mapping (address => bool) private founds;\r\n\r\n  function Ownable()  internal{\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyAdmins(){\r\n    require(admins[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner()  {\r\n    require (msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n function getOwner() view public returns (address){\r\n     return owner;\r\n  }\r\n\r\n function isDeveloper () view internal returns (bool) {\r\n     return developers[msg.sender];\r\n  }\r\n\r\n function isFounder () view internal returns (bool){\r\n     return founds[msg.sender];\r\n  }\r\n\r\n  function addDeveloper (address _dev) onlyOwner() public {\r\n    developers[_dev] = true;\r\n  }\r\n\r\n  function removeDeveloper (address _dev) onlyOwner() public {\r\n    delete developers[_dev];\r\n  }\r\n\r\n    function addFound (address _found) onlyOwner() public {\r\n    founds[_found] = true;\r\n  }\r\n\r\n  function removeFound (address _found) onlyOwner() public {\r\n    delete founds[_found];\r\n  }\r\n\r\n  function addAdmin (address _admin) onlyOwner() public {\r\n    admins[_admin] = true;\r\n  }\r\n\r\n  function removeAdmin (address _admin) onlyOwner() public {\r\n    delete admins[_admin];\r\n  }\r\n  \r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Define interface for distrible the token \r\n */\r\ncontract DistributeToken is StandardToken, Ownable{\r\n\r\n  event AirDrop(address from, address to, uint amount);\r\n  event CrowdDistribute(address from, address to, uint amount);\r\n\r\n  using SafeMathLib for uint;\r\n\r\n  /* The finalizer contract that allows Distribute token */\r\n  address public distAgent;\r\n\r\n  uint public maxAirDrop = 1000*10**18;//need below 1000 TTG\r\n\r\n  uint public havedAirDrop = 0;\r\n  uint public totalAirDrop = 0; //totalSupply * 5%\r\n\r\n  bool public finishCrowdCoin = false;\r\n  uint public havedCrowdCoin = 0;\r\n  uint public totalCrowdCoin = 0; //totalSupply * 50%\r\n\r\n  uint public havedDistDevCoin = 0;\r\n  uint public totalDevCoin = 0;  //totalSupply * 20%\r\n\r\n  uint public havedDistFoundCoin = 0;\r\n  uint public totalFoundCoin = 0;  //totalSupply * 20%\r\n\r\n  /**\r\n   * 0：1：100000；1：1：50000 2：1：25000  3：1：12500  4：1：12500\r\n   */\r\n  uint private crowState = 0;//\r\n  /**\r\n   * .\r\n   */\r\n  function setDistributeAgent(address addr) onlyOwner  public {\r\n     \r\n     require(addr != address(0));\r\n\r\n    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n    distAgent = addr;\r\n  }\r\n\r\n\r\n  /** The function can be called only by a whitelisted release agent. */\r\n  modifier onlyDistributeAgent() {\r\n    require(msg.sender == distAgent) ;\r\n    _;\r\n  }\r\n\r\n  /* Withdraw */\r\n  /*\r\n    NOTICE: These functions withdraw the ETH which remained in the contract account when user call CrowdDistribute\r\n  */\r\n  function withdrawAll () onlyOwner() public {\r\n    owner.transfer(this.balance);\r\n  }\r\n\r\n  function withdrawAmount (uint256 _amount) onlyOwner() public {\r\n    owner.transfer(_amount);\r\n  }\r\n\r\n /**发token给基金会*/\r\n function distributeToFound(address receiver, uint amount) onlyOwner() public  returns (uint actual){ \r\n  \r\n    require((amount+havedDistFoundCoin) < totalFoundCoin);\r\n  \r\n    balances[owner] = balances[owner].sub(amount);\r\n    balances[receiver] = balances[receiver].plus(amount);\r\n    havedDistFoundCoin = havedDistFoundCoin.plus(amount);\r\n\r\n    addFound(receiver);\r\n\r\n    // This will make the mint transaction apper in EtherScan.io\r\n    // We can remove this after there is a standardized minting event\r\n    emit Transfer(0, receiver, amount);\r\n   \r\n    return amount;\r\n }\r\n\r\n /**发token给开发者*/\r\n function  distributeToDev(address receiver, uint amount) onlyOwner()  public  returns (uint actual){\r\n\r\n    require((amount+havedDistDevCoin) < totalDevCoin);\r\n\r\n    balances[owner] = balances[owner].sub(amount);\r\n    balances[receiver] = balances[receiver].plus(amount);\r\n    havedDistDevCoin = havedDistDevCoin.plus(amount);\r\n\r\n    addDeveloper(receiver);\r\n    // This will make the mint transaction apper in EtherScan.io\r\n    // We can remove this after there is a standardized minting event\r\n    emit Transfer(0, receiver, amount);\r\n\r\n    return amount;\r\n }\r\n\r\n /**空投总量及单次量由发行者来控制， agent不能修改，空投接口只能由授权的agent进行*/\r\n function airDrop(address transmitter, address receiver, uint amount) public  returns (uint actual){\r\n\r\n    require(receiver != address(0));\r\n    require(amount <= maxAirDrop);\r\n    require((amount+havedAirDrop) < totalAirDrop);\r\n    require(transmitter == distAgent);\r\n\r\n    balances[owner] = balances[owner].sub(amount);\r\n    balances[receiver] = balances[receiver].plus(amount);\r\n    havedAirDrop = havedAirDrop.plus(amount);\r\n\r\n    // This will make the mint transaction apper in EtherScan.io\r\n    // We can remove this after there is a standardized minting event\r\n    emit AirDrop(0, receiver, amount);\r\n\r\n    return amount;\r\n  }\r\n\r\n /**用户ICO众筹，由用户发固定的ETH，回馈用户固定的TTG，并添加ICO账户，控制交易规则*/\r\n function crowdDistribution() payable public  returns (uint actual) {\r\n      \r\n    require(msg.sender != address(0));\r\n    require(!isContract(msg.sender));\r\n    require(msg.value != 0);\r\n    require(totalCrowdCoin > havedCrowdCoin);\r\n    require(finishCrowdCoin == false);\r\n    \r\n    uint actualAmount = calculateCrowdAmount(msg.value);\r\n\r\n    require(actualAmount != 0);\r\n\r\n    havedCrowdCoin = havedCrowdCoin.plus(actualAmount);\r\n    balances[owner] = balances[owner].sub(actualAmount);\r\n    balances[msg.sender] = balances[msg.sender].plus(actualAmount);\r\n    \r\n    switchCrowdState();\r\n    \r\n    // This will make the mint transaction apper in EtherScan.io\r\n    // We can remove this after there is a standardized minting event\r\n    emit CrowdDistribute(0, msg.sender, actualAmount);\r\n\r\n    return actualAmount;\r\n  }\r\n\r\n function  switchCrowdState () internal{\r\n\r\n    if (havedCrowdCoin < totalCrowdCoin.mul(10).div(100) ){\r\n       crowState = 0;\r\n\r\n    }else  if (havedCrowdCoin < totalCrowdCoin.mul(20).div(100) ){\r\n       crowState = 1;\r\n    \r\n    } else if (havedCrowdCoin < totalCrowdCoin.mul(30).div(100) ){\r\n       crowState = 2;\r\n\r\n    } else if (havedCrowdCoin < totalCrowdCoin.mul(40).div(100) ){\r\n       crowState = 3;\r\n\r\n    } else if (havedCrowdCoin < totalCrowdCoin.mul(50).div(100) ){\r\n       crowState = 4;\r\n    }\r\n      \r\n    if (havedCrowdCoin >= totalCrowdCoin) {\r\n       finishCrowdCoin = true;\r\n  }\r\n }\r\n\r\nfunction calculateCrowdAmount (uint _price) internal view returns (uint _crow) {\r\n        \r\n    if (crowState == 0) {\r\n      return _price.mul(50000);\r\n    }\r\n    \r\n     else if (crowState == 1) {\r\n      return _price.mul(30000);\r\n    \r\n    } else if (crowState == 2) {\r\n      return  _price.mul(20000);\r\n\r\n    } else if (crowState == 3) {\r\n     return  _price.mul(15000);\r\n\r\n    } else if (crowState == 4) {\r\n     return  _price.mul(10000);\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\n */\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n  /* The finalizer contract that allows unlift the transfer limits on this token */\r\n  address public releaseAgent;\r\n\r\n  /** A TTG contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\r\n  bool public released = false;\r\n\r\n  uint private maxTransferForDev  = 40000000*10**18;\r\n  uint private maxTransferFoFounds= 20000000*10**18;\r\n  uint private maxTransfer = 0;//other user is not limited.\r\n\r\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\r\n  mapping (address => bool) public transferAgents;\r\n\r\n  /**\r\n   * Limit token transfer until the crowdsale is over.\r\n   *\r\n   */\r\n  modifier canTransfer(address _sender, uint _value) {\r\n\r\n    //if owner can Transfer all the time\r\n    if(_sender != owner){\r\n      \r\n      if(isDeveloper()){\r\n        require(_value < maxTransferForDev);\r\n\r\n      }else if(isFounder()){\r\n        require(_value < maxTransferFoFounds);\r\n\r\n      }else if(maxTransfer != 0){\r\n        require(_value < maxTransfer);\r\n      }\r\n\r\n      if(!released) {\r\n          require(transferAgents[_sender]);\r\n      }\r\n     }\r\n    _;\r\n  }\r\n\r\n\r\n function setMaxTranferLimit(uint dev, uint found, uint other) onlyOwner  public {\r\n\r\n      require(dev < totalSupply);\r\n      require(found < totalSupply);\r\n      require(other < totalSupply);\r\n\r\n      maxTransferForDev = dev;\r\n      maxTransferFoFounds = found;\r\n      maxTransfer = other;\r\n  }\r\n\r\n\r\n  /**\r\n   * Set the contract that can call release and make the token transferable.\r\n   *\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\n   */\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n\r\n    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n    releaseAgent = addr;\r\n  }\r\n\r\n  /**\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\n   */\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n    transferAgents[addr] = state;\r\n  }\r\n\r\n  /**\r\n   * One way function to release the tokens to the wild.\r\n   *\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\n   */\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    released = true;\r\n  }\r\n\r\n  /** The function can be called only before or after the tokens have been releasesd */\r\n  modifier inReleaseState(bool releaseState) {\r\n    require(releaseState == released);\r\n    _;\r\n  }\r\n\r\n  /** The function can be called only by a whitelisted release agent. */\r\n  modifier onlyReleaseAgent() {\r\n    require(msg.sender == releaseAgent);\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) public canTransfer(msg.sender,_value) returns (bool success)  {\r\n    // Call StandardToken.transfer()\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) public canTransfer(_from,_value) returns (bool success)  {\r\n    // Call StandardToken.transferForm()\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\ncontract RecycleToken is StandardToken, Ownable {\r\n\r\n  using SafeMathLib for uint;\r\n\r\n  /**\r\n   * recycle user token to owner account\r\n   * \r\n   */\r\n  function recycle(address from, uint amount) onlyAdmins public {\r\n  \r\n    require(from != address(0));\r\n    require(balances[from] >=  amount);\r\n\r\n    balances[owner] = balances[owner].add(amount);\r\n    balances[from]  = balances[from].sub(amount);\r\n\r\n    // This will make the mint transaction apper in EtherScan.io\r\n    // We can remove this after there is a standardized minting event\r\n    emit Transfer(from, owner, amount);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * A token that can increase its supply by another contract.\r\n *\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\n *\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n\r\n  using SafeMathLib for uint;\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  /** List of agents that are allowed to create new tokens */\r\n  mapping (address => bool) public mintAgents;\r\n\r\n  event MintingAgentChanged(address addr, bool state  );\r\n\r\n  /**\r\n   * Create new tokens and allocate them to an address..\r\n   *\r\n   * Only callably by a crowdsale contract (mint agent). \r\n   */\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\n\r\n    //totalsupply is not changed, send amount TTG to receiver from owner account.\r\n    balances[owner] = balances[owner].sub(amount);\r\n    balances[receiver] = balances[receiver].plus(amount);\r\n    \r\n    // This will make the mint transaction apper in EtherScan.io\r\n    // We can remove this after there is a standardized minting event\r\n    emit Transfer(0, receiver, amount);\r\n  }\r\n\r\n  /**\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\n   */\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n    mintAgents[addr] = state;\r\n    emit MintingAgentChanged(addr, state);\r\n  }\r\n\r\n  modifier onlyMintAgent() {\r\n    // Only crowdsale contracts are allowed to mint new tokens\r\n    require(mintAgents[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function enableMint() onlyOwner public {\r\n    mintingFinished = false;\r\n  }\r\n\r\n  /** Make sure we are not done yet. */\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * A crowdsaled token.\r\n *\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\n *\r\n * - The token transfer() is disabled until the crowdsale is over\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\n *\r\n */\r\ncontract TTGCoin is ReleasableToken, MintableToken , DistributeToken, RecycleToken{\r\n\r\n  /** Name and symbol were updated. */\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n  string public name;\r\n\r\n  string public symbol;\r\n\r\n  uint public decimals;\r\n\r\n  /**\r\n   * Construct the token.\r\n   *\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\n   *\r\n   */\r\n  function TTGCoin() public {\r\n    // Create any address, can be transferred\r\n    // to team multisig via changeOwner(),\r\n    owner = msg.sender;\r\n\r\n    addAdmin(owner);\r\n\r\n    name  = \"TotalGame Coin\";\r\n    symbol = \"TGC\";\r\n    totalSupply = 2000000000*10**18;\r\n    decimals = 18;\r\n\r\n    // Create initially all balance on the team multisig\r\n    balances[msg.sender] = totalSupply;\r\n\r\n    //Mint feature is not allow  now\r\n    mintingFinished = true;\r\n\r\n    //Set the distribute totaltoken strategy\r\n    totalAirDrop = totalSupply.mul(10).div(100);\r\n    totalCrowdCoin = totalSupply.mul(50).div(100);\r\n    totalDevCoin = totalSupply.mul(20).div(100);\r\n    totalFoundCoin = totalSupply.mul(20).div(100);\r\n\r\n    emit Minted(owner, totalSupply);\r\n  }\r\n\r\n\r\n  /**\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\n   */\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    super.releaseTokenTransfer();\r\n  }\r\n\r\n  /**\r\n   * Owner can update token information here.\r\n   *\r\n   * It is often useful to conceal the actual token association, until\r\n   * the token operations, like central issuance or reissuance have been completed.\r\n   *\r\n   * This function allows the token owner to rename the token after the operations\r\n   * have been completed and then point the audience to use the token contract.\r\n   */\r\n  function setTokenInformation(string _name, string _symbol) public onlyOwner {\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    emit UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\n  function getTotalSupply() public view returns (uint) {\r\n    return totalSupply;\r\n  }\r\n\r\n  function tokenName() public view returns (string _name) {\r\n    return name;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setTransferAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_found\",\"type\":\"address\"}],\"name\":\"addFound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributeToDev\",\"outputs\":[{\"name\":\"actual\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dev\",\"type\":\"uint256\"},{\"name\":\"found\",\"type\":\"uint256\"},{\"name\":\"other\",\"type\":\"uint256\"}],\"name\":\"setMaxTranferLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributeToFound\",\"outputs\":[{\"name\":\"actual\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dev\",\"type\":\"address\"}],\"name\":\"addDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReleaseAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transmitter\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"airDrop\",\"outputs\":[{\"name\":\"actual\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"havedDistFoundCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setMintAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setTokenInformation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"crowdDistribution\",\"outputs\":[{\"name\":\"actual\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"havedAirDrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recycle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenName\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCrowdCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"havedDistDevCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFoundCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dev\",\"type\":\"address\"}],\"name\":\"removeDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finishCrowdCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"havedCrowdCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDistributeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDevCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAirDrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_found\",\"type\":\"address\"}],\"name\":\"removeFound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isToken\",\"outputs\":[{\"name\":\"weAre\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAirDrop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"UpdatedTokenInformation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CrowdDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"MintingAgentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"TTGCoin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://323240ff9b27fd9ceea351e50ac3b09362575bd4588e38a5b0d595a973a4e374"}]}