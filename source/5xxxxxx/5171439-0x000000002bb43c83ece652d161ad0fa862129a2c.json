{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;// blaze it\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external constant returns (uint supply);\r\n    function balanceOf(address _owner) external constant returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\ncontract TokenRescue {\r\n    // use this method to rescue your tokens if you sent them by mistake but be quick or someone else will get them\r\n    function rescueToken(ERC20 _token)\r\n    external\r\n    {\r\n        _token.transfer(msg.sender, _token.balanceOf(this));\r\n    }\r\n    // require data for transactions\r\n    function() external payable {\r\n        revert();\r\n    }\r\n}\r\ninterface AccountRegistryInterface {\r\n    function canVoteOnProposal(address _voter, address _proposal) external view returns (bool);\r\n}\r\ncontract Vote is ERC20, TokenRescue {\r\n    uint256 supply = 0;\r\n    AccountRegistryInterface public accountRegistry = AccountRegistryInterface(0x000000002bb43c83eCe652d161ad0fa862129A2C);\r\n    address public owner = 0x4a6f6B9fF1fc974096f9063a45Fd12bD5B928AD1;\r\n\r\n    uint8 public constant decimals = 1;\r\n    string public symbol = \"FV\";\r\n    string public name = \"FinneyVote\";\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) approved;\r\n\r\n    function totalSupply() external constant returns (uint256) {\r\n        return supply;\r\n    }\r\n    function balanceOf(address _owner) external constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n    function approve(address _spender, uint256 _value) external returns (bool) {\r\n        approved[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    function allowance(address _owner, address _spender) external constant returns (uint256) {\r\n        return approved[_owner][_spender];\r\n    }\r\n    function transfer(address _to, uint256 _value) external returns (bool) {\r\n        if (balances[msg.sender] < _value) {\r\n            return false;\r\n        }\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\r\n        if (balances[_from] < _value\r\n         || approved[_from][msg.sender] < _value\r\n         || _value == 0) {\r\n            return false;\r\n        }\r\n        approved[_from][msg.sender] -= _value;\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    function grant(address _to, uint256 _grant) external {\r\n        require(msg.sender == address(accountRegistry));\r\n        balances[_to] += _grant;\r\n        supply += _grant;\r\n        Transfer(address(0), _to, _grant);\r\n    }\r\n    // vote5 and vote1 are available for future use\r\n    function vote5(address _voter, address _votee) external {\r\n        require(balances[_voter] >= 10);\r\n        require(accountRegistry.canVoteOnProposal(_voter, msg.sender));\r\n        balances[_voter] -= 10;\r\n        balances[owner] += 5;\r\n        balances[_votee] += 5;\r\n        Transfer(_voter, owner, 5);\r\n        Transfer(_voter, _votee, 5);\r\n    }\r\n    function vote1(address _voter, address _votee) external {\r\n        require(balances[_voter] >= 10);\r\n        require(accountRegistry.canVoteOnProposal(_voter, msg.sender));\r\n        balances[_voter] -= 10;\r\n        balances[owner] += 9;\r\n        balances[_votee] += 1;\r\n        Transfer(_voter, owner, 9);\r\n        Transfer(_voter, _votee, 1);\r\n    }\r\n    function vote9(address _voter, address _votee) external {\r\n        require(balances[_voter] >= 10);\r\n        require(accountRegistry.canVoteOnProposal(_voter, msg.sender));\r\n        balances[_voter] -= 10;\r\n        balances[owner] += 1;\r\n        balances[_votee] += 9;\r\n        Transfer(_voter, owner, 1);\r\n        Transfer(_voter, _votee, 9);\r\n    }\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    event Owner(address indexed owner);\r\n    event Registry(address indexed registry);\r\n    function transferOwnership(address _newOwner)\r\n    external onlyOwner {\r\n        uint256 balance = balances[owner];\r\n        balances[_newOwner] += balance;\r\n        balances[owner] = 0;\r\n        Transfer(owner, _newOwner, balance);\r\n        owner = _newOwner;\r\n        Owner(_newOwner);\r\n    }\r\n    function migrateAccountRegistry(AccountRegistryInterface _newAccountRegistry)\r\n    external onlyOwner {\r\n        accountRegistry = _newAccountRegistry;\r\n        Registry(_newAccountRegistry);\r\n    }\r\n}\r\ninterface ProposalInterface {\r\n    /* uint8:\r\n        enum Position {\r\n            SKIP, // default\r\n            APPROVE,\r\n            REJECT,\r\n            AMEND, // == (APPROVE | REJECT)\r\n            LOL\r\n            // more to be determined by community\r\n        }\r\n    */\r\n    function getPosition(address _user) external view returns (uint8);\r\n    function argumentCount() external view returns (uint256);\r\n    function vote(uint256 _argumentId) external;\r\n    // bytes could be:\r\n    // utf8 string\r\n    // swarm hash\r\n    // ipfs hash\r\n    // and others tbd\r\n    event Case(bytes content);\r\n}\r\ncontract ProperProposal is ProposalInterface, TokenRescue {\r\n    struct Argument {\r\n        address source;\r\n        uint8 position;\r\n        uint256 count;\r\n    }\r\n    Argument[] public arguments;\r\n    mapping (address => uint256) public votes;\r\n    Vote public constant voteToken = Vote(0x000000002647e16d9BaB9e46604D75591D289277);\r\n\r\n    function getPosition(address _user)\r\n    external view\r\n    returns (uint8) {\r\n        return arguments[votes[_user]].position;\r\n    }\r\n\r\n    function argumentCount() external view returns (uint256) {\r\n        return arguments.length;\r\n    }\r\n    function argumentSource(uint256 _index)\r\n    external view\r\n    returns (address) {\r\n        return arguments[_index].source;\r\n    }\r\n\r\n    function argumentPosition(uint256 _index)\r\n    external view\r\n    returns (uint8) {\r\n        return arguments[_index].position;\r\n    }\r\n\r\n    function argumentVoteCount(uint256 _index)\r\n    external view\r\n    returns (uint256) {\r\n        return arguments[_index].count;\r\n    }\r\n\r\n    function source()\r\n    external view\r\n    returns (address) {\r\n        return arguments[0].source;\r\n    }\r\n\r\n    function voteCount()\r\n    external view\r\n    returns (uint256) {\r\n        return -arguments[0].count;\r\n    }\r\n\r\n    function vote(uint256 _argumentId)\r\n    external {\r\n        address destination = arguments[_argumentId].source;\r\n        voteToken.vote9(msg.sender, destination);\r\n        arguments[votes[msg.sender]].count--;\r\n        arguments[\r\n            votes[msg.sender] = _argumentId\r\n        ].count++;\r\n    }\r\n\r\n    event Case(bytes content);\r\n\r\n    function argue(uint8 _position, bytes _text)\r\n    external\r\n    returns (uint256) {\r\n        address destination = arguments[0].source;\r\n        voteToken.vote9(msg.sender, destination);\r\n        uint256 argumentId = arguments.length;\r\n        arguments.push(Argument(msg.sender, _position, 1));\r\n        Case(_text);\r\n        arguments[votes[msg.sender]].count--;\r\n        votes[msg.sender] = argumentId;\r\n        return argumentId;\r\n    }\r\n\r\n    function init(address _source, bytes _resolution)\r\n    external {\r\n        assert(msg.sender == 0x000000002bb43c83eCe652d161ad0fa862129A2C);\r\n        arguments.push(Argument(_source, 0/*SKIP*/, 0));\r\n        Case(_resolution);\r\n    }\r\n}\r\ninterface CabalInterface {\r\n    // TBD\r\n    function canonCount() external view returns (uint256);\r\n}\r\ncontract AccountRegistry is AccountRegistryInterface, TokenRescue {\r\n    \r\n    uint256 constant public registrationDeposit = 1 finney;\r\n    uint256 constant public proposalCensorshipFee = 50 finney;\r\n\r\n    // this is the first deterministic contract address for 0x24AE90765668938351075fB450892800d9A52E39\r\n    address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1;\r\n\r\n    Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277);\r\n\r\n    /* uint8 membership bitmap:\r\n     * 0 - proposer\r\n     * 1 - registered to vote\r\n     * 2 - pending proposal\r\n     * 3 - proposal\r\n     * 4 - board member\r\n     * 5 - pending cabal\r\n     * 6 - cabal\r\n     * 7 - board\r\n     */\r\n    uint8 constant UNCONTACTED = 0;\r\n    uint8 constant PROPOSER = 1;\r\n    uint8 constant VOTER = 2;\r\n    uint8 constant PENDING_PROPOSAL = 4;\r\n    uint8 constant PROPOSAL = 8;\r\n    uint8 constant PENDING_CABAL = 16;\r\n    uint8 constant CABAL = 32;\r\n    uint8 constant BOARD = 64;\r\n    struct Account {\r\n        uint256 lastAccess;\r\n        uint8 membership;\r\n        address appointer;//nominated this account for BOARD\r\n        address denouncer;//denounced this BOARD account\r\n        address voucher;//nominated this account for PROPOSER\r\n        address devoucher;//denounced this account for PROPOSER\r\n    }\r\n    mapping (address => Account) accounts;\r\n\r\n    function AccountRegistry()\r\n    public\r\n    {\r\n        accounts[0x4a6f6B9fF1fc974096f9063a45Fd12bD5B928AD1].membership = BOARD;\r\n        Board(0x4a6f6B9fF1fc974096f9063a45Fd12bD5B928AD1);\r\n        accounts[0x90Fa310397149A7a9058Ae2d56e66e707B12D3A7].membership = BOARD;\r\n        Board(0x90Fa310397149A7a9058Ae2d56e66e707B12D3A7);\r\n        accounts[0x424a6e871E8cea93791253B47291193637D6966a].membership = BOARD;\r\n        Board(0x424a6e871E8cea93791253B47291193637D6966a);\r\n        accounts[0xA4caDe6ecbed8f75F6fD50B8be92feb144400CC4].membership = BOARD;\r\n        Board(0xA4caDe6ecbed8f75F6fD50B8be92feb144400CC4);\r\n    }\r\n\r\n    event Voter(address indexed voter);\r\n    event Deregistered(address indexed voter);\r\n    event Nominated(address indexed board, string endorsement);\r\n    event Board(address indexed board);\r\n    event Denounced(address indexed board, string reason);\r\n    event Revoked(address indexed board);\r\n    event Proposal(ProposalInterface indexed proposal);\r\n    event Cabal(CabalInterface indexed cabal);\r\n    event BannedProposal(ProposalInterface indexed proposal, string reason);\r\n    event Vouch(address indexed proposer, string vouch);\r\n    event Proposer(address indexed proposer);\r\n    event Devouch(address indexed proposer, string vouch);\r\n    event Shutdown(address indexed proposer);\r\n\r\n    // To register a Cabal, you must\r\n    // - implement CabalInterface\r\n    // - open-source your Cabal on Etherscan or equivalent\r\n    function registerCabal(CabalInterface _cabal)\r\n    external {\r\n        Account storage account = accounts[_cabal];\r\n        require(account.membership & (PENDING_CABAL | CABAL) == 0);\r\n        account.membership |= PENDING_CABAL;\r\n    }\r\n\r\n    function confirmCabal(CabalInterface _cabal)\r\n    external {\r\n        require(accounts[msg.sender].membership & BOARD != 0);\r\n        Account storage account = accounts[_cabal];\r\n        require(account.membership & PENDING_CABAL != 0);\r\n        account.membership ^= (CABAL | PENDING_CABAL);\r\n        Cabal(_cabal);\r\n    }\r\n\r\n    function register()\r\n    external payable\r\n    {\r\n        require(msg.value == registrationDeposit);\r\n        Account storage account = accounts[msg.sender];\r\n        require(account.membership & VOTER == 0);\r\n        account.lastAccess = now;\r\n        account.membership |= VOTER;\r\n        token.grant(msg.sender, 40);\r\n        Voter(msg.sender);\r\n    }\r\n\r\n    // smart contracts must implement the fallback function in order to deregister\r\n    function deregister()\r\n    external\r\n    {\r\n        Account storage account = accounts[msg.sender];\r\n        require(account.membership & VOTER != 0);\r\n        require(account.lastAccess + 7 days <= now);\r\n        account.membership ^= VOTER;\r\n        account.lastAccess = 0;\r\n        // the MANDATORY transfer keeps population() meaningful\r\n        msg.sender.transfer(registrationDeposit);\r\n        Deregistered(msg.sender);\r\n    }\r\n\r\n    function population()\r\n    external view\r\n    returns (uint256)\r\n    {\r\n        return this.balance / 1 finney;\r\n    }\r\n\r\n    function deregistrationDate()\r\n    external view\r\n    returns (uint256)\r\n    {\r\n        return accounts[msg.sender].lastAccess + 7 days;\r\n    }\r\n\r\n    // always true for deregistered accounts\r\n    function canDeregister(address _voter)\r\n    external view\r\n    returns (bool)\r\n    {\r\n        return accounts[_voter].lastAccess + 7 days <= now;\r\n    }\r\n\r\n    function canVoteOnProposal(address _voter, address _proposal)\r\n    external view\r\n    returns (bool)\r\n    {\r\n        return accounts[_voter].membership & VOTER != 0\r\n            && accounts[_proposal].membership & PROPOSAL != 0;\r\n    }\r\n\r\n    function canVote(address _voter)\r\n    external view\r\n    returns (bool)\r\n    {\r\n        return accounts[_voter].membership & VOTER != 0;\r\n    }\r\n\r\n    function isProposal(address _proposal)\r\n    external view\r\n    returns (bool)\r\n    {\r\n        return accounts[_proposal].membership & PROPOSAL != 0;\r\n    }\r\n\r\n    function isPendingProposal(address _proposal)\r\n    external view\r\n    returns (bool)\r\n    {\r\n        return accounts[_proposal].membership & PENDING_PROPOSAL != 0;\r\n    }\r\n\r\n    function isPendingCabal(address _account)\r\n    external view\r\n    returns (bool)\r\n    {\r\n        return accounts[_account].membership & PENDING_CABAL != 0;\r\n    }\r\n\r\n    function isCabal(address _account)\r\n    external view\r\n    returns (bool)\r\n    {\r\n        return accounts[_account].membership & CABAL != 0;\r\n    }\r\n\r\n    // under no condition should you let anyone control two BOARD accounts\r\n    function appoint(address _board, string _vouch)\r\n    external {\r\n        require(accounts[msg.sender].membership & BOARD != 0);\r\n        Account storage candidate = accounts[_board];\r\n        if (candidate.membership & BOARD != 0) {\r\n            return;\r\n        }\r\n        address appt = candidate.appointer;\r\n        if (accounts[appt].membership & BOARD == 0) {\r\n            candidate.appointer = msg.sender;\r\n            Nominated(_board, _vouch);\r\n            return;\r\n        }\r\n        if (appt == msg.sender) {\r\n            return;\r\n        }\r\n        Nominated(_board, _vouch);\r\n        candidate.membership |= BOARD;\r\n        Board(_board);\r\n    }\r\n\r\n    function denounce(address _board, string _reason)\r\n    external {\r\n        require(accounts[msg.sender].membership & BOARD != 0);\r\n        Account storage board = accounts[_board];\r\n        if (board.membership & BOARD == 0) {\r\n            return;\r\n        }\r\n        address dncr = board.denouncer;\r\n        if (accounts[dncr].membership & BOARD == 0) {\r\n            board.denouncer = msg.sender;\r\n            Denounced(_board, _reason);\r\n            return;\r\n        }\r\n        if (dncr == msg.sender) {\r\n            return;\r\n        }\r\n        Denounced(_board, _reason);\r\n        board.membership ^= BOARD;\r\n        Revoked(_board);\r\n    }\r\n\r\n    function vouchProposer(address _proposer, string _vouch)\r\n    external {\r\n        require(accounts[msg.sender].membership & BOARD != 0);\r\n        Account storage candidate = accounts[_proposer];\r\n        if (candidate.membership & PROPOSER != 0) {\r\n            return;\r\n        }\r\n        address appt = candidate.voucher;\r\n        if (accounts[appt].membership & BOARD == 0) {\r\n            candidate.voucher = msg.sender;\r\n            Vouch(_proposer, _vouch);\r\n            return;\r\n        }\r\n        if (appt == msg.sender) {\r\n            return;\r\n        }\r\n        Vouch(_proposer, _vouch);\r\n        candidate.membership |= PROPOSER;\r\n        Proposer(_proposer);\r\n    }\r\n\r\n    function devouchProposer(address _proposer, string _devouch)\r\n    external {\r\n        require(accounts[msg.sender].membership & BOARD != 0);\r\n        Account storage candidate = accounts[_proposer];\r\n        if (candidate.membership & PROPOSER == 0) {\r\n            return;\r\n        }\r\n        address appt = candidate.devoucher;\r\n        if (accounts[appt].membership & BOARD == 0) {\r\n            candidate.devoucher = msg.sender;\r\n            Devouch(_proposer, _devouch);\r\n            return;\r\n        }\r\n        if (appt == msg.sender) {\r\n            return;\r\n        }\r\n        Devouch(_proposer, _devouch);\r\n        candidate.membership &= ~PROPOSER;\r\n        Shutdown(_proposer);\r\n    }\r\n\r\n    function proposeProper(bytes _resolution)\r\n    external\r\n    returns (ProposalInterface)\r\n    {\r\n        ProperProposal proposal = new ProperProposal();\r\n        proposal.init(msg.sender, _resolution);\r\n        accounts[proposal].membership |= PROPOSAL;\r\n        Proposal(proposal);\r\n        return proposal;\r\n    }\r\n\r\n    function proposeProxy(bytes _resolution)\r\n    external\r\n    returns (ProposalInterface)\r\n    {\r\n        ProperProposal proposal;\r\n        bytes memory clone = hex\"600034603b57602f80600f833981f3600036818037808036816f5fbe2cc9b1b684ec445caf176042348e5af415602c573d81803e3d81f35b80fd\";\r\n        assembly {\r\n            let data := add(clone, 0x20)\r\n            proposal := create(0, data, 58)\r\n        }\r\n        proposal.init(msg.sender, _resolution);\r\n        accounts[proposal].membership |= PROPOSAL;\r\n        Proposal(proposal);\r\n        return proposal;\r\n    }\r\n\r\n    function sudoPropose(ProposalInterface _proposal)\r\n    external {\r\n        require(accounts[msg.sender].membership & PROPOSER != 0);\r\n        uint8 membership = accounts[_proposal].membership;\r\n        require(membership == 0);\r\n        accounts[_proposal].membership = PROPOSAL;\r\n        Proposal(_proposal);\r\n    }\r\n\r\n    // To submit an outside proposal contract, you must:\r\n    // - ensure it conforms to ProposalInterface\r\n    // - ensure it properly transfers the VOTE token, calling Vote.voteX\r\n    // - open-source it using Etherscan or equivalent\r\n    function proposeExternal(ProposalInterface _proposal)\r\n    external\r\n    {\r\n        Account storage account = accounts[_proposal];\r\n        require(account.membership & (PENDING_PROPOSAL | PROPOSAL) == 0);\r\n        account.membership |= PENDING_PROPOSAL;\r\n    }\r\n\r\n    function confirmProposal(ProposalInterface _proposal)\r\n    external\r\n    {\r\n        require(accounts[msg.sender].membership & BOARD != 0);\r\n        Account storage account = accounts[_proposal];\r\n        require(account.membership & PENDING_PROPOSAL != 0);\r\n        account.membership ^= (PROPOSAL | PENDING_PROPOSAL);\r\n        Proposal(_proposal);\r\n    }\r\n\r\n    // bans prevent accounts from voting through this proposal\r\n    // this should only be used to stop a proposal that is abusing the VOTE token\r\n    // the burn is to penalize bans, so that they cannot suppress ideas\r\n    function banProposal(ProposalInterface _proposal, string _reason)\r\n    external payable\r\n    {\r\n        require(msg.value == proposalCensorshipFee);\r\n        require(accounts[msg.sender].membership & BOARD != 0);\r\n        Account storage account = accounts[_proposal];\r\n        require(account.membership & PROPOSAL != 0);\r\n        account.membership &= ~PROPOSAL;\r\n        burn.transfer(proposalCensorshipFee);\r\n        BannedProposal(_proposal, _reason);\r\n    }\r\n\r\n    // board members reserve the right to reject outside proposals for any reason\r\n    function rejectProposal(ProposalInterface _proposal)\r\n    external\r\n    {\r\n        require(accounts[msg.sender].membership & BOARD != 0);\r\n        Account storage account = accounts[_proposal];\r\n        require(account.membership & PENDING_PROPOSAL != 0);\r\n        account.membership &= PENDING_PROPOSAL;\r\n    }\r\n\r\n    // this code lives here instead of in the token so that it can be upgraded with account registry migration\r\n    function faucet()\r\n    external {\r\n        Account storage account = accounts[msg.sender];\r\n        require(account.membership & VOTER != 0);\r\n        uint256 lastAccess = account.lastAccess;\r\n        uint256 grant = (now - lastAccess) / 72 minutes;\r\n        if (grant > 40) {\r\n            grant = 40;\r\n            account.lastAccess = now;\r\n        } else {\r\n            account.lastAccess = lastAccess + grant * 72 minutes;\r\n        }\r\n        token.grant(msg.sender, grant);\r\n    }\r\n\r\n    function availableFaucet(address _account)\r\n    external view\r\n    returns (uint256) {\r\n        uint256 grant = (now - accounts[_account].lastAccess) / 72 minutes;\r\n        if (grant > 40) {\r\n            grant = 40;\r\n        }\r\n        return grant;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isPendingCabal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCensorshipFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deregistrationDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_board\",\"type\":\"address\"},{\"name\":\"_vouch\",\"type\":\"string\"}],\"name\":\"appoint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cabal\",\"type\":\"address\"}],\"name\":\"confirmCabal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isCabal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"canDeregister\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"isProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"availableFaucet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"banProposal\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_resolution\",\"type\":\"bytes\"}],\"name\":\"proposeProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"sudoPropose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"population\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"confirmProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"canVoteOnProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposer\",\"type\":\"address\"},{\"name\":\"_vouch\",\"type\":\"string\"}],\"name\":\"vouchProposer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"isPendingProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"canVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deregister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"proposeExternal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposer\",\"type\":\"address\"},{\"name\":\"_devouch\",\"type\":\"string\"}],\"name\":\"devouchProposer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cabal\",\"type\":\"address\"}],\"name\":\"registerCabal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposal\",\"type\":\"address\"}],\"name\":\"rejectProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_resolution\",\"type\":\"bytes\"}],\"name\":\"proposeProper\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"faucet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_board\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"denounce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Deregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"board\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"endorsement\",\"type\":\"string\"}],\"name\":\"Nominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"board\",\"type\":\"address\"}],\"name\":\"Board\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"board\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"Denounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"board\",\"type\":\"address\"}],\"name\":\"Revoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"address\"}],\"name\":\"Proposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cabal\",\"type\":\"address\"}],\"name\":\"Cabal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposal\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"BannedProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vouch\",\"type\":\"string\"}],\"name\":\"Vouch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"Proposer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vouch\",\"type\":\"string\"}],\"name\":\"Devouch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"Shutdown\",\"type\":\"event\"}]","ContractName":"AccountRegistry","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a6b7df0aa14346833c127740034defdaf51df17700584c3bb17f518ea3b03160"}]}