{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\nlibrary SafeMath { //standard library for uint\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0){\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  function pow(uint256 a, uint256 b) internal pure returns (uint256){ //power function\r\n    if (b == 0){\r\n      return 1;\r\n    }\r\n    uint256 c = a**b;\r\n    assert (c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable { //standart contract to identify owner\r\n  address public owner;\r\n\r\n  address public newOwner;\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));\r\n    newOwner = _newOwner;\r\n  }\r\n  function acceptOwnership() public {\r\n    if (msg.sender == newOwner) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n}\r\n\r\ncontract SpyceToken{\r\n  function sendCrowdsaleTokens(address, uint256)  public;\r\n  function setCrowdsaleContract (address) public;\r\n  function burnContributorTokens (address _address) public;\r\n}\r\n\r\ncontract SpyceCrowdsale is Ownable{\r\n  using SafeMath for uint;\r\n\r\n  uint decimals = 18;\r\n\r\n  // Token contract address\r\n  SpyceToken public token;\r\n\r\n  function SpyceCrowdsale(address _tokenAddress) public{\r\n    token = SpyceToken(_tokenAddress);\r\n\r\n    owner = msg.sender;\r\n    token.setCrowdsaleContract(this);\r\n\r\n    stageStruct memory buffer;\r\n\r\n    buffer.startDate = 0; \r\n    \r\n    //1522195199 is equivalent to 03/27/2018 @ 11:59pm (UTC)\r\n    buffer.finishDate = 1522195199;\r\n    buffer.tokenPrice = 0.00016 ether;\r\n    buffer.minCap = 108 ether;\r\n    buffer.maxCap = 24000 ether;\r\n\r\n    stages.push(buffer);\r\n  }\r\n\r\n  /* Destribution addresses */\r\n  //All ether will be send to this address\r\n  address distributionAddress = 0xe6997e8359599d0B5f17B7E1bF77f7fFC509Afbe;\r\n\r\n\r\n  function () public payable {\r\n    require (buy(msg.sender, msg.value, now));\r\n  }\r\n\r\n\r\n  function buy (address _address, uint _value, uint _time) internal returns(bool) {\r\n\r\n    uint currentStage = getCurrentStage(_time);\r\n    \r\n    require(currentStage != 1000);\r\n\r\n    uint tokensToSend = _value.mul((uint)(10).pow(decimals))/stages[currentStage].tokenPrice;\r\n\r\n    require (tokensToSend.add(stages[currentStage].tokensSold) <= stages[currentStage].maxCap);\r\n\r\n    stages[currentStage].tokensSold = stages[currentStage].tokensSold.add(tokensToSend);\r\n\r\n    stages[currentStage].ethContributors[_address] = stages[currentStage].ethContributors[_address].add(_value);\r\n\r\n    stages[currentStage].ethCollected = stages[currentStage].ethCollected.add(_value);\r\n\r\n    token.sendCrowdsaleTokens(_address, tokensToSend);\r\n\r\n    autoDistribute(currentStage);\r\n\r\n    return true;\r\n  }\r\n\r\n  function autoDistribute (uint currentStage) internal {\r\n    if (stages[currentStage].minCap <= stages[currentStage].tokensSold){\r\n\r\n      distributionAddress.transfer(stages[currentStage].ethCollected.sub(stages[currentStage].ethSended));\r\n\r\n      stages[currentStage].ethSended = stages[currentStage].ethCollected;\r\n    }\r\n  }\r\n  \r\n  \r\nfunction manualSendTokens (address _address, uint _value) public onlyOwner {\r\n\r\n    uint currentStage = getCurrentStage(now);\r\n    require(currentStage != 1000);\r\n\r\n    stages[currentStage].tokensSold = stages[currentStage].tokensSold.add(_value.mul((uint)(10).pow(decimals)));\r\n\r\n    token.sendCrowdsaleTokens(_address,_value.mul((uint)(10).pow(decimals)));\r\n\r\n    autoDistribute(currentStage);\r\n  }\r\n  \r\n  struct stageStruct {\r\n    uint startDate;\r\n    uint finishDate;\r\n    uint tokenPrice;\r\n    uint minCap;\r\n    uint maxCap;\r\n    uint tokensSold;\r\n\r\n    uint ethCollected;\r\n    uint ethSended;\r\n\r\n    mapping (address => uint) ethContributors; \r\n  }\r\n\r\n  stageStruct[] public stages;\r\n\r\n\r\n  function addNewStage (uint _start, uint _finish, uint _price, uint _mincap, uint _maxcap) public onlyOwner {\r\n    stageStruct memory buffer;\r\n\r\n    buffer.startDate = _start;\r\n    buffer.finishDate = _finish;\r\n    buffer.tokenPrice = _price;\r\n    buffer.minCap = _mincap.mul((uint)(10).pow(decimals));\r\n    buffer.maxCap = _maxcap.mul((uint)(10).pow(decimals));\r\n\r\n    stages.push(buffer);\r\n  }\r\n  \r\n  function getCurrentStage (uint _time) public view returns (uint) {\r\n    uint currentStage = 0;\r\n    for (uint i = 0; i < stages.length; i++){\r\n      if (stages[i].startDate < _time && _time <= stages[i].finishDate){\r\n        currentStage = i;\r\n        break;\r\n      }\r\n    }\r\n    if (stages[currentStage].startDate < _time && _time <= stages[currentStage].finishDate){\r\n      return currentStage;\r\n    }else{\r\n      return 1000; //NO ACTIVE STAGE\r\n    }\r\n  }\r\n  \r\n  \r\n  function refund () public {\r\n    uint currentStage = getCurrentStage(now);\r\n\r\n    for (uint i = 0; i < currentStage; i++){\r\n      if(stages[i].ethContributors[msg.sender] > 0 && stages[i].tokensSold < stages[i].minCap){\r\n        msg.sender.transfer(stages[i].ethContributors[msg.sender]);\r\n        stages[i].ethContributors[msg.sender] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"manualSendTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getCurrentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stages\",\"outputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"finishDate\",\"type\":\"uint256\"},{\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"name\":\"minCap\",\"type\":\"uint256\"},{\"name\":\"maxCap\",\"type\":\"uint256\"},{\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"name\":\"ethCollected\",\"type\":\"uint256\"},{\"name\":\"ethSended\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_finish\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_mincap\",\"type\":\"uint256\"},{\"name\":\"_maxcap\",\"type\":\"uint256\"}],\"name\":\"addNewStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"SpyceCrowdsale","CompilerVersion":"v0.4.20-nightly.2017.11.30+commit.cb16a5d3","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000032cf443489822d049591e2f92ae52bbe53efd525","Library":"","SwarmSource":"bzzr://23cfd533754cdb7cb807a9d8ff93241a2d26a530cb1ccef3f9ebffa0d007d39e"}]}