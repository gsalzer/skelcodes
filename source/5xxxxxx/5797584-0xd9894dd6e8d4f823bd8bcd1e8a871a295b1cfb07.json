{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function getOwner() public view returns(address retOwnerAddress) {\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n\r\ncontract AccessControl is Ownable {\r\n    address private ceoAddress;\r\n    address private cfoAddress;\r\n    address private cooAddress;\r\n\r\n    bool private paused = false;\r\n\r\n    constructor() public {\r\n        paused = true;\r\n\r\n        ceoAddress = getOwner();\r\n        cooAddress = getOwner();\r\n        cfoAddress = getOwner();\r\n    }\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    function getCFO() public view returns(address retCFOAddress) {\r\n        return cfoAddress;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\n\r\ncontract Base {\r\n    uint8 constant internal INIT = 0;\r\n    uint8 constant internal WIN = 1;\r\n    uint8 constant internal LOSE = 2;\r\n    uint8 constant internal TIE = 3;\r\n    uint8 constant internal MATCH_CNT = 64;\r\n\r\n    struct AccountInfo {\r\n        uint invested;\r\n        uint prize;\r\n        uint claimed;\r\n    }\r\n\r\n    struct Match {\r\n        uint8 matchId;\r\n        uint8 hostTeamId;\r\n        uint8 guestTeamId;\r\n        uint startTime;\r\n        uint8 outcome;\r\n\r\n        uint totalInvest;\r\n\r\n        mapping(address => Better) betters;\r\n        mapping(uint8 => uint) mPredictionInvest;\r\n    }\r\n\r\n    struct Better {\r\n        uint invested;\r\n        uint prize;\r\n\r\n        mapping(uint8 => uint) bPredictionInvest;\r\n    }\r\n\r\n    // 0.001 ETH =< msg.value =< 100 ETH\r\n    modifier validValue() {\r\n        require(msg.value >= 1000000000000000 && msg.value <= 100000000000000000000);\r\n        _;\r\n    }\r\n\r\n    // 1-32 teams\r\n    modifier validTeam(uint8 _teamId) {\r\n        require(_teamId > 0 && _teamId < 33);\r\n        _;\r\n    }\r\n\r\n    // 1-64 matches\r\n    modifier validMatch(uint8 _matchId) {\r\n        require(_matchId > 0 && _matchId < 65);\r\n        _;\r\n    }\r\n\r\n    modifier validPredictionOrOutcome(uint8 _predictionOrOutcome) {\r\n        require(_predictionOrOutcome == WIN || _predictionOrOutcome == LOSE || _predictionOrOutcome == TIE);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract WorldCup2018 is Base, AccessControl {\r\n    using SafeMath for uint256;\r\n\r\n    //<------------------------------------------------------------------------------------->\r\n    // /**\r\n    //  * @title PullPayment\r\n    //  * @dev Base contract supporting async send for pull payments. Inherit from this\r\n    //  * contract and use asyncSend instead of send or transfer.\r\n    //  */\r\n\r\n    // / @dev WithdrawPayments event is emitted whenever a player withdraws the payments.\r\n    event WithdrawPayments(address indexed _player, uint256 _value);\r\n\r\n    mapping(address => uint256) private payments;\r\n    uint256 private totalPayments;\r\n\r\n    /**\r\n     * @dev To make sure the totalPayments by calling this method.\r\n     */\r\n    function getTotalPayments() public view returns(uint retTotalPayments) {\r\n        return totalPayments;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw accumulated balance, called by payee.\r\n     */\r\n    function withdrawPayments() public whenNotPaused {\r\n        address payee = msg.sender;\r\n        uint256 payment = payments[payee];\r\n\r\n        require(payment != 0);\r\n        require(address(this).balance >= payment);\r\n\r\n        totalPayments = totalPayments.sub(payment);\r\n        payments[payee] = 0;\r\n        payee.transfer(payment);\r\n\r\n        emit WithdrawPayments(payee, payment);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n     * @param dest The destination address of the funds.\r\n     * @param amount The amount to transfer.\r\n     */\r\n    function asyncSend(address dest, uint256 amount) internal onlyCLevel whenNotPaused {\r\n        require(address(this).balance >= amount);\r\n\r\n        uint tempTotalPayments = totalPayments.add(amount);\r\n        require(address(this).balance >= tempTotalPayments);\r\n\r\n        payments[dest] = payments[dest].add(amount);\r\n        // totalPayments = totalPayments.add(amount);\r\n        totalPayments = tempTotalPayments;\r\n    }\r\n    //<------------------------------------------------------------------------------------->\r\n\r\n    event ContractUpgrade(address newContract);\r\n    event BetMatch(address indexed _betterAddress, uint _invested, uint8 _matchId, uint8 _prediction);\r\n    event SetOutcome(address indexed _setterAddress, uint8 _matchId, uint8 _outcome);\r\n    event UpdateMatch(address indexed _setterAddress, uint8 _matchId, uint8 _hostTeamId, uint8 _guestTeamId);\r\n    event UpdateMatchStartTime(address indexed _setterAddress, uint8 _matchId, uint _startTime);\r\n\r\n    //<------------------------------------------------------------------------------------->\r\n    mapping(address => AccountInfo) private accountInfos;\r\n    uint8[MATCH_CNT] private match_pools;\r\n    mapping(uint8 => Match) private matchs;\r\n    address[][MATCH_CNT] private nm_players;\r\n    //<------------------------------------------------------------------------------------->\r\n    uint private totalInvest;\r\n    uint8 private CLAIM_TAX = 10;\r\n    //<------------------------------------------------------------------------------------->\r\n\r\n    constructor() public {\r\n        init();\r\n        unpause();\r\n    }\r\n\r\n    function init() \r\n        private onlyCLevel {\r\n\r\n        // 1\t1 vs 2\t    1528988400\r\n        initRegistMatch(1, 1, 2, 1528988400);\r\n        // 2\t3 vs 4\t    1529064000\r\n        initRegistMatch(2, 3, 4, 1529064000);\r\n        // 3\t5 vs 6\t    1529085600\r\n        initRegistMatch(3, 5, 6, 1529085600);\r\n        // 4\t7 vs 8\t    1529074800\r\n        initRegistMatch(4, 7, 8, 1529074800);\r\n        // 5\t9 vs 10\t    1529143200\r\n        initRegistMatch(5, 9, 10, 1529143200);\r\n        // 6\t11 vs 12\t1529164800\r\n        initRegistMatch(6, 11, 12, 1529164800);\r\n        // 7\t13 vs 14\t1529154000\r\n        initRegistMatch(7, 13, 14, 1529154000);\r\n        // 8\t15 vs 16\t1529175600\r\n        initRegistMatch(8, 15, 16, 1529175600);\r\n        // 9\t17 vs 18\t1529258400\r\n        initRegistMatch(9, 17, 18, 1529258400);\r\n        // 10\t19 vs 20\t1529236800\r\n        initRegistMatch(10, 19, 20, 1529236800);\r\n        // 11\t21 vs 22\t1529247600\r\n        initRegistMatch(11, 21, 22, 1529247600);\r\n        // 12\t23 vs 24\t1529323200\r\n        initRegistMatch(12, 23, 24, 1529323200);\r\n        // 13\t25 vs 26\t1529334000\r\n        initRegistMatch(13, 25, 26, 1529334000);\r\n        // 14\t27 vs 28\t1529344800\r\n        initRegistMatch(14, 27, 28, 1529344800);\r\n        // 15\t29 vs 30\t1529420400\r\n        initRegistMatch(15, 29, 30, 1529420400);\r\n        // 16\t31 vs 32\t1529409600\r\n        initRegistMatch(16, 31, 32, 1529409600);\r\n        // 17\t1 vs 3\t    1529431200\r\n        initRegistMatch(17, 1, 3, 1529431200);\r\n        // 18\t4 vs 2\t    1529506800\r\n        initRegistMatch(18, 4, 2, 1529506800);\r\n        // 19\t5 vs 7\t    1529496000\r\n        initRegistMatch(19, 5, 7, 1529496000);\r\n        // 20\t8 vs 6\t    1529517600\r\n        initRegistMatch(20, 8, 6, 1529517600);\r\n        // 21\t9 vs 11\t    1529593200\r\n        initRegistMatch(21, 9, 11, 1529593200);\r\n        // 22\t12 vs 10\t1529582400\r\n        initRegistMatch(22, 12, 10, 1529582400);\r\n        // 23\t13 vs 15\t1529604000\r\n        initRegistMatch(23, 13, 15, 1529604000);\r\n        // 24\t16 vs 14\t1529679600\r\n        initRegistMatch(24, 16, 14, 1529679600);\r\n        // 25\t17 vs 19\t1529668800\r\n        initRegistMatch(25, 17, 19, 1529668800);\r\n        // 26\t20 vs 18\t1529690400\r\n        initRegistMatch(26, 20, 18, 1529690400);\r\n        // 27\t21 vs 23\t1529776800\r\n        initRegistMatch(27, 21, 23, 1529776800);\r\n        // 28\t24 vs 22\t1529766000\r\n        initRegistMatch(28, 24, 22, 1529766000);\r\n        // 29\t25 vs 27\t1529755200\r\n        initRegistMatch(29, 25, 27, 1529755200);\r\n        // 30\t28 vs 26\t1529841600\r\n        initRegistMatch(30, 28, 26, 1529841600);\r\n        // 31\t29 vs 31\t1529863200\r\n        initRegistMatch(31, 29, 31, 1529863200);\r\n        // 32\t32 vs 30\t1529852400\r\n        initRegistMatch(32, 32, 30, 1529852400);\r\n        // 33\t4 vs 1\t    1529935200\r\n        initRegistMatch(33, 4, 1, 1529935200);\r\n        // 34\t2 vs 3\t    1529935200\r\n        initRegistMatch(34, 2, 3, 1529935200);\r\n        // 35\t8 vs 5\t    1529949600\r\n        initRegistMatch(35, 8, 5, 1529949600);\r\n        // 36\t6 vs 7\t    1529949600\r\n        initRegistMatch(36, 6, 7, 1529949600);\r\n        // 37\t12 vs 9\t    1530021600\r\n        initRegistMatch(37, 12, 9, 1530021600);\r\n        // 38\t10 vs 11\t1530021600\r\n        initRegistMatch(38, 10, 11, 1530021600);\r\n        // 39\t16 vs 13\t1530036000\r\n        initRegistMatch(39, 16, 13, 1530036000);\r\n        // 40\t14 vs 15\t1530036000\r\n        initRegistMatch(40, 14, 15, 1530036000);\r\n        // 41\t20 vs 17\t1530122400\r\n        initRegistMatch(41, 20, 17, 1530122400);\r\n        // 42\t18 vs 19\t1530122400\r\n        initRegistMatch(42, 18, 19, 1530122400);\r\n        // 43\t24 vs 21\t1530108000\r\n        initRegistMatch(43, 24, 21, 1530108000);\r\n        // 44\t22 vs 23\t1530108000\r\n        initRegistMatch(44, 22, 23, 1530108000);\r\n        // 45\t28 vs 25\t1530208800\r\n        initRegistMatch(45, 28, 25, 1530208800);\r\n        // 46\t26 vs 27\t1530208800\r\n        initRegistMatch(46, 26, 27, 1530208800);\r\n        // 47\t32 vs 29\t1530194400\r\n        initRegistMatch(47, 32, 29, 1530194400);\r\n        // 48\t30 vs 31\t1530194400\r\n        initRegistMatch(48, 30, 31, 1530194400);\r\n        // 49\t\t\t\t1530367200\r\n        initRegistMatch(49, 0, 0, 1530367200);\r\n        // 50\t\t\t\t1530381600\r\n        initRegistMatch(50, 0, 0, 1530381600);\r\n        // 51\t\t\t\t1530453600\r\n        initRegistMatch(51, 0, 0, 1530453600);\r\n        // 52\t\t\t\t1530468000\r\n        initRegistMatch(52, 0, 0, 1530468000);\r\n        // 53\t\t\t\t1530540000\r\n        initRegistMatch(53, 0, 0, 1530540000);\r\n        // 54\t\t\t\t1530554400\r\n        initRegistMatch(54, 0, 0, 1530554400);\r\n        // 55\t\t\t\t1530626400\r\n        initRegistMatch(55, 0, 0, 1530626400);\r\n        // 56\t\t\t\t1530640800\r\n        initRegistMatch(56, 0, 0, 1530640800);\r\n        // 57\t\t\t\t1530885600\r\n        initRegistMatch(57, 0, 0, 1530885600);\r\n        // 58\t\t\t\t1530900000\r\n        initRegistMatch(58, 0, 0, 1530900000);\r\n        // 59\t\t\t\t1530972000\r\n        initRegistMatch(59, 0, 0, 1530972000);\r\n        // 60\t\t\t\t1530986400\r\n        initRegistMatch(60, 0, 0, 1530986400);\r\n        // 61\t\t\t\t1531245600\r\n        initRegistMatch(61, 0, 0, 1531245600);\r\n        // 62\t\t\t\t1531332000\r\n        initRegistMatch(62, 0, 0, 1531332000);\r\n        // 63\t\t\t\t1531576800\r\n        initRegistMatch(63, 0, 0, 1531576800);\r\n        // 64\t\t\t\t1531666800\r\n        initRegistMatch(64, 0, 0, 1531666800);\r\n\r\n        totalInvest = 0;\r\n    }\r\n\r\n    function initRegistMatch(uint8 _matchId, uint8 _hostTeamId, uint8 _guestTeamId, uint _startTime) \r\n        private onlyCLevel {\r\n\r\n        Match memory _match = Match(_matchId, _hostTeamId, _guestTeamId, _startTime, 0, 0);\r\n        matchs[_matchId] = _match;\r\n        match_pools[_matchId - 1] = _matchId;\r\n    }\r\n\r\n    function setClamTax(uint8 _tax) external onlyCLevel {\r\n        require(_tax > 0);\r\n        CLAIM_TAX = _tax;\r\n    }\r\n\r\n    function getClamTax() public view returns(uint8 claimTax) {\r\n        return CLAIM_TAX;\r\n    }\r\n\r\n    function getTotalInvest() \r\n        public view returns(uint) {\r\n        return totalInvest;\r\n    }\r\n\r\n    function updateMatch(uint8 _matchId, uint8 _hostTeamId, uint8 _guestTeamId) \r\n        external onlyCLevel validMatch(_matchId) validTeam(_hostTeamId) validTeam(_guestTeamId) whenNotPaused {\r\n\r\n        Match storage _match = matchs[_matchId];\r\n        require(_match.outcome == INIT);\r\n        require(now < _match.startTime);\r\n\r\n        _match.hostTeamId = _hostTeamId;\r\n        _match.guestTeamId = _guestTeamId;\r\n\r\n        emit UpdateMatch(msg.sender, _matchId, _hostTeamId, _guestTeamId);\r\n    }\r\n\r\n    function updateMatchStartTime(uint8 _matchId, uint _startTime) \r\n        external onlyCLevel validMatch(_matchId) whenNotPaused {\r\n\r\n        Match storage _match = matchs[_matchId];\r\n        require(_match.outcome == INIT);\r\n        require(now < _startTime);\r\n\r\n        _match.startTime = _startTime;\r\n\r\n        emit UpdateMatchStartTime(msg.sender, _matchId, _startTime);\r\n    }\r\n\r\n    function getMatchIndex(uint8 _matchId) \r\n        private pure validMatch(_matchId) returns(uint8) {\r\n        return _matchId - 1;\r\n    }\r\n\r\n    function betMatch(uint8 _matchId, uint8 _prediction) \r\n        external payable validValue validMatch(_matchId) validPredictionOrOutcome(_prediction) whenNotPaused {\r\n\r\n        Match storage _match = matchs[_matchId];\r\n        require(_match.outcome == INIT);\r\n        require(now < _match.startTime);\r\n\r\n        {\r\n            Better storage better = _match.betters[msg.sender];\r\n            if (better.invested > 0) {\r\n                better.invested = better.invested.add(msg.value);\r\n            } else {\r\n                _match.betters[msg.sender] = Better(msg.value, 0);\r\n            }\r\n            _match.betters[msg.sender].bPredictionInvest[_prediction] = _match.betters[msg.sender].bPredictionInvest[_prediction].add(msg.value);\r\n        }\r\n\r\n        {\r\n            _match.mPredictionInvest[_prediction] = _match.mPredictionInvest[_prediction].add(msg.value);\r\n            _match.totalInvest = _match.totalInvest.add(msg.value);\r\n        }\r\n\r\n        {\r\n            totalInvest = totalInvest.add(msg.value);\r\n        }\r\n\r\n        {\r\n            AccountInfo storage accountInfo = accountInfos[msg.sender];\r\n            if (accountInfo.invested > 0) {\r\n                accountInfo.invested = accountInfo.invested.add(msg.value);\r\n            } else {\r\n                accountInfos[msg.sender] = AccountInfo({\r\n                    invested: msg.value, prize: 0, claimed: 0\r\n                });\r\n            }\r\n        }\r\n\r\n        {\r\n            uint8 index = getMatchIndex(_matchId);\r\n            address[] memory match_betters = nm_players[index];\r\n\r\n            bool ext = false;\r\n            for (uint i = 0; i < match_betters.length; i++) {\r\n                if (match_betters[i] == msg.sender) {\r\n                    ext = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (ext == false) {\r\n                nm_players[index].push(msg.sender);\r\n            }\r\n        }\r\n\r\n        emit BetMatch(msg.sender, msg.value, _matchId, _prediction);\r\n    }\r\n\r\n    function setOutcome(uint8 _matchId, uint8 _outcome) \r\n        external onlyCLevel validMatch(_matchId) validPredictionOrOutcome(_outcome) whenNotPaused {\r\n\r\n        Match storage _match = matchs[_matchId];\r\n        require(_match.outcome == INIT);\r\n        _match.outcome = _outcome;\r\n\r\n        noticeWinner(_matchId);\r\n\r\n        emit SetOutcome(msg.sender, _matchId, _outcome);\r\n    }\r\n\r\n    function noticeWinner(uint8 _matchId) \r\n        private onlyCLevel {\r\n\r\n        Match storage _match = matchs[_matchId];\r\n        uint totalInvestForWinners = _match.mPredictionInvest[_match.outcome];\r\n\r\n        uint fee = 0;\r\n        uint prizeDistributionTotal = 0;\r\n\r\n        if (_match.totalInvest > totalInvestForWinners) {\r\n            (prizeDistributionTotal, fee) = feesTakenFromPrize(_match.totalInvest, totalInvestForWinners);\r\n        }\r\n\r\n        if (fee > 0) {\r\n            asyncSend(getCFO(), fee);\r\n        }\r\n\r\n        if (prizeDistributionTotal > 0 || _match.totalInvest == totalInvestForWinners) {\r\n            uint8 index = getMatchIndex(_matchId);\r\n            address[] memory match_betters = nm_players[index];\r\n\r\n            for(uint i = 0; i < match_betters.length; i++) {\r\n                Better storage better = _match.betters[match_betters[i]];\r\n\r\n                uint totalInvestForBetter = better.bPredictionInvest[_match.outcome];\r\n                if (totalInvestForBetter > 0) {\r\n                    uint prize = calculatePrize(prizeDistributionTotal, totalInvestForBetter, totalInvestForWinners);\r\n\r\n                    better.prize = prize;\r\n\r\n                    uint refundVal = totalInvestForBetter.add(prize);\r\n                    asyncSend(match_betters[i], refundVal);\r\n\r\n                    {\r\n                        AccountInfo storage accountInfo = accountInfos[match_betters[i]];\r\n                        accountInfo.prize = accountInfo.prize.add(prize);\r\n                        accountInfo.claimed = accountInfo.claimed.add(refundVal);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function feesTakenFromPrize(uint _totalInvestForMatch, uint _totalInvestForWinners) \r\n        private view returns(uint prizeDistributionTotal, uint fee) {\r\n\r\n        require(_totalInvestForMatch >= _totalInvestForWinners);\r\n\r\n        if (_totalInvestForWinners > 0) {\r\n            if (_totalInvestForMatch > _totalInvestForWinners) {\r\n                uint prizeTotal = _totalInvestForMatch.sub(_totalInvestForWinners);\r\n                fee = prizeTotal.div(getClamTax());\r\n                prizeDistributionTotal = prizeTotal.sub(fee);\r\n            }\r\n        } else {\r\n            fee = _totalInvestForMatch;\r\n        }\r\n\r\n        return (prizeDistributionTotal, fee);\r\n    }\r\n\r\n    function calculatePrize(uint _prizeDistributionTotal, uint _totalInvestForBetter, uint _totalInvestForWinners) \r\n        private pure returns(uint) {\r\n        return (_prizeDistributionTotal.mul(_totalInvestForBetter)).div(_totalInvestForWinners);\r\n    }\r\n\r\n    function getUserAccountInfo() public view returns(\r\n        uint invested, \r\n        uint prize, \r\n        uint balance\r\n    ) {\r\n        AccountInfo storage accountInfo = accountInfos[msg.sender];\r\n\r\n        invested = accountInfo.invested;\r\n        prize = accountInfo.prize;\r\n        balance = payments[msg.sender];\r\n\r\n        return (invested, prize, balance);\r\n    }\r\n\r\n    function getMatchInfoList01() public view returns(\r\n        uint8[MATCH_CNT] matchIdArray, \r\n        uint8[MATCH_CNT] hostTeamIdArray, \r\n        uint8[MATCH_CNT] guestTeamIdArray, \r\n        uint[MATCH_CNT] startTimeArray, \r\n        uint8[MATCH_CNT] outcomeArray \r\n    ) {\r\n        for (uint8 intI = 0; intI < MATCH_CNT; intI++) {\r\n            Match storage _match = matchs[match_pools[intI]];\r\n\r\n            matchIdArray[intI] = _match.matchId;\r\n\r\n            hostTeamIdArray[intI] = _match.hostTeamId;\r\n            guestTeamIdArray[intI] = _match.guestTeamId;\r\n            startTimeArray[intI] = _match.startTime;\r\n            outcomeArray[intI] = _match.outcome;\r\n        }\r\n\r\n        return (\r\n            matchIdArray,\r\n\r\n            hostTeamIdArray,\r\n            guestTeamIdArray,\r\n            startTimeArray,\r\n\r\n            outcomeArray\r\n        );\r\n    }\r\n\r\n    function getMatchInfoList02() public view returns(\r\n        uint[MATCH_CNT] winPredictionArray, \r\n        uint[MATCH_CNT] losePredictionArray, \r\n        uint[MATCH_CNT] tiePredictionArray\r\n    ) {\r\n        for (uint8 intI = 0; intI < MATCH_CNT; intI++) {\r\n            Match storage _match = matchs[match_pools[intI]];\r\n\r\n            winPredictionArray[intI] = _match.mPredictionInvest[WIN];\r\n            losePredictionArray[intI] = _match.mPredictionInvest[LOSE];\r\n            tiePredictionArray[intI] = _match.mPredictionInvest[TIE];\r\n        }\r\n\r\n        return (\r\n            winPredictionArray,\r\n            losePredictionArray,\r\n            tiePredictionArray\r\n        );\r\n    }\r\n\r\n    function getMatchInfoList03() public view returns(\r\n        uint[MATCH_CNT] winPredictionArrayForLoginUser, \r\n        uint[MATCH_CNT] losePredictionArrayForLoginUser, \r\n        uint[MATCH_CNT] tiePredictionArrayForLoginUser\r\n    ) {\r\n        for (uint8 intI = 0; intI < MATCH_CNT; intI++) {\r\n            Match storage _match = matchs[match_pools[intI]];\r\n\r\n            Better storage better = _match.betters[msg.sender];\r\n\r\n            winPredictionArrayForLoginUser[intI] = better.bPredictionInvest[WIN];\r\n            losePredictionArrayForLoginUser[intI] = better.bPredictionInvest[LOSE];\r\n            tiePredictionArrayForLoginUser[intI] = better.bPredictionInvest[TIE];\r\n        }\r\n\r\n        return (\r\n            winPredictionArrayForLoginUser,\r\n            losePredictionArrayForLoginUser,\r\n            tiePredictionArrayForLoginUser\r\n        );\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    function kill() \r\n        public onlyOwner whenNotPaused {\r\n\r\n        require(getTotalPayments() == 0);\r\n\r\n        for (uint8 intI = 0; intI < MATCH_CNT; intI++) {\r\n            Match storage _match = matchs[match_pools[intI]];\r\n            require(_match.outcome > INIT);\r\n        }\r\n\r\n        selfdestruct(getOwner());\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tax\",\"type\":\"uint8\"}],\"name\":\"setClamTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint8\"},{\"name\":\"_prediction\",\"type\":\"uint8\"}],\"name\":\"betMatch\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getClamTax\",\"outputs\":[{\"name\":\"claimTax\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserAccountInfo\",\"outputs\":[{\"name\":\"invested\",\"type\":\"uint256\"},{\"name\":\"prize\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMatchInfoList01\",\"outputs\":[{\"name\":\"matchIdArray\",\"type\":\"uint8[64]\"},{\"name\":\"hostTeamIdArray\",\"type\":\"uint8[64]\"},{\"name\":\"guestTeamIdArray\",\"type\":\"uint8[64]\"},{\"name\":\"startTimeArray\",\"type\":\"uint256[64]\"},{\"name\":\"outcomeArray\",\"type\":\"uint8[64]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalPayments\",\"outputs\":[{\"name\":\"retTotalPayments\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint8\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"updateMatchStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCFO\",\"outputs\":[{\"name\":\"retCFOAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"retOwnerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMatchInfoList02\",\"outputs\":[{\"name\":\"winPredictionArray\",\"type\":\"uint256[64]\"},{\"name\":\"losePredictionArray\",\"type\":\"uint256[64]\"},{\"name\":\"tiePredictionArray\",\"type\":\"uint256[64]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint8\"},{\"name\":\"_hostTeamId\",\"type\":\"uint8\"},{\"name\":\"_guestTeamId\",\"type\":\"uint8\"}],\"name\":\"updateMatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint8\"},{\"name\":\"_outcome\",\"type\":\"uint8\"}],\"name\":\"setOutcome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMatchInfoList03\",\"outputs\":[{\"name\":\"winPredictionArrayForLoginUser\",\"type\":\"uint256[64]\"},{\"name\":\"losePredictionArrayForLoginUser\",\"type\":\"uint256[64]\"},{\"name\":\"tiePredictionArrayForLoginUser\",\"type\":\"uint256[64]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"WithdrawPayments\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_betterAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_invested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_matchId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_prediction\",\"type\":\"uint8\"}],\"name\":\"BetMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_setterAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_matchId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_outcome\",\"type\":\"uint8\"}],\"name\":\"SetOutcome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_setterAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_matchId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_hostTeamId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_guestTeamId\",\"type\":\"uint8\"}],\"name\":\"UpdateMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_setterAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_matchId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"UpdateMatchStartTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"WorldCup2018","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b7b8292443653a0cdb26580a071bcd65fc4301303b32f4cc8834bf3ff5244ba4"}]}