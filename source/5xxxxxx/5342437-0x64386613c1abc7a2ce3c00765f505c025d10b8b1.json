{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20\r\n * @dev ERC20 interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() public { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n/**\r\n * @title MiniMe interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20MiniMe is ERC20, Controlled {\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool);\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint);\r\n    function createCloneToken(string _cloneTokenName, uint8 _cloneDecimalUnits, string _cloneTokenSymbol, uint _snapshotBlock, bool _transfersEnabled) public returns(address);\r\n    function generateTokens(address _owner, uint _amount) public returns (bool);\r\n    function destroyTokens(address _owner, uint _amount)  public returns (bool);\r\n    function enableTransfers(bool _transfersEnabled) public;\r\n    function isContract(address _addr) constant internal returns(bool);\r\n    function claimTokens(address _token) public;\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // The token being sold\r\n  ERC20MiniMe public token;\r\n\r\n  // start and end timestamps where investments are allowed (both inclusive)\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n\r\n  // address where funds are collected\r\n  address public wallet;\r\n\r\n  // how many token units a buyer gets per wei\r\n  uint256 public rate;\r\n\r\n  // amount of raised money in wei\r\n  uint256 public weiRaised;\r\n\r\n  /**\r\n   * event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\r\n  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) {\r\n    require(_startTime >= now);\r\n    require(_endTime >= _startTime);\r\n    require(_rate > 0);\r\n    require(_wallet != 0x0);\r\n\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n  }\r\n\r\n\r\n  // fallback function can be used to buy tokens\r\n  function () payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  // low level token purchase function\r\n  function buyTokens(address beneficiary) public payable {\r\n    buyTokens(beneficiary, msg.value);\r\n  }\r\n\r\n  // implementation of low level token purchase function\r\n  function buyTokens(address beneficiary, uint256 weiAmount) internal {\r\n    require(beneficiary != 0x0);\r\n    require(validPurchase(weiAmount));\r\n\r\n    transferToken(beneficiary, weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    forwardFunds(weiAmount);\r\n  }\r\n\r\n  // low level transfer token\r\n  // override to create custom token transfer mechanism, eg. pull pattern\r\n  function transferToken(address beneficiary, uint256 weiAmount) internal {\r\n    // calculate token amount to be created\r\n    uint256 tokens = weiAmount.mul(rate);\r\n\r\n    token.generateTokens(beneficiary, tokens);\r\n\r\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n  }\r\n\r\n  // send ether to the fund collection wallet\r\n  // override to create custom fund forwarding mechanisms\r\n  function forwardFunds(uint256 weiAmount) internal {\r\n    wallet.transfer(weiAmount);\r\n  }\r\n\r\n  // @return true if the transaction can buy tokens\r\n  function validPurchase(uint256 weiAmount) internal constant returns (bool) {\r\n    bool withinPeriod = now >= startTime && now <= endTime;\r\n    bool nonZeroPurchase = weiAmount != 0;\r\n    return withinPeriod && nonZeroPurchase;\r\n  }\r\n\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public constant returns (bool) {\r\n    return now > endTime;\r\n  }\r\n\r\n  // @return true if crowdsale has started\r\n  function hasStarted() public constant returns (bool) {\r\n    return now >= startTime;\r\n  }\r\n}\r\n\r\n/**\r\n * @title CappedCrowdsale\r\n * @dev Extension of Crowdsale with a max amount of funds raised\r\n */\r\ncontract CappedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public cap;\r\n\r\n  function CappedCrowdsale(uint256 _cap) {\r\n    require(_cap > 0);\r\n    cap = _cap;\r\n  }\r\n\r\n  // overriding Crowdsale#validPurchase to add extra cap logic\r\n  // @return true if investors can buy at the moment\r\n  function validPurchase(uint256 weiAmount) internal constant returns (bool) {\r\n    return super.validPurchase(weiAmount) && !capReached();\r\n  }\r\n\r\n  // overriding Crowdsale#hasEnded to add cap logic\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public constant returns (bool) {\r\n    return super.hasEnded() || capReached();\r\n  }\r\n\r\n  // @return true if cap has been reached\r\n  function capReached() internal constant returns (bool) {\r\n   return weiRaised >= cap;\r\n  }\r\n\r\n  // overriding Crowdsale#buyTokens to add partial refund logic\r\n  function buyTokens(address beneficiary) public payable {\r\n     uint256 weiToCap = cap.sub(weiRaised);\r\n     uint256 weiAmount = weiToCap < msg.value ? weiToCap : msg.value;\r\n\r\n     buyTokens(beneficiary, weiAmount);\r\n\r\n     uint256 refund = msg.value.sub(weiAmount);\r\n     if (refund > 0) {\r\n       msg.sender.transfer(refund);\r\n     }\r\n   }\r\n}\r\n\r\n\r\n\r\n\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    ERC20MiniMe public ethealToken;\r\n    address public SALE; // address where sale tokens are located\r\n\r\n    /// @notice needed for hodler handling\r\n    function addHodlerStake(address _beneficiary, uint256 _stake) public;\r\n    function setHodlerStake(address _beneficiary, uint256 _stake) public;\r\n    function setHodlerTime(uint256 _time) public;\r\n\r\n\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of Crowdsale where an owner can do extra work\r\n * after finishing.\r\n */\r\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  bool public isFinalized = false;\r\n\r\n  event Finalized();\r\n\r\n  /**\r\n   * @dev Must be called after crowdsale ends, to do some extra finalization\r\n   * work. Calls the contract's finalization function.\r\n   */\r\n  function finalize() onlyOwner public {\r\n    require(!isFinalized);\r\n    require(hasEnded());\r\n\r\n    finalization();\r\n    Finalized();\r\n\r\n    isFinalized = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Can be overridden to add finalization logic. The overriding function\r\n   * should call super.finalization() to ensure the chain of finalization is\r\n   * executed entirely.\r\n   */\r\n  function finalization() internal {\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title EthealWhitelist\r\n * @author thesved\r\n * @notice EthealWhitelist contract which handles KYC\r\n */\r\ncontract EthealWhitelist is Ownable {\r\n    using ECRecovery for bytes32;\r\n\r\n    // signer address for offchain whitelist signing\r\n    address public signer;\r\n\r\n    // storing whitelisted addresses\r\n    mapping(address => bool) public isWhitelisted;\r\n\r\n    event WhitelistSet(address indexed _address, bool _state);\r\n\r\n    ////////////////\r\n    // Constructor\r\n    ////////////////\r\n    function EthealWhitelist(address _signer) {\r\n        require(_signer != address(0));\r\n\r\n        signer = _signer;\r\n    }\r\n\r\n    /// @notice set signing address after deployment\r\n    function setSigner(address _signer) public onlyOwner {\r\n        require(_signer != address(0));\r\n\r\n        signer = _signer;\r\n    }\r\n\r\n    ////////////////\r\n    // Whitelisting: only owner\r\n    ////////////////\r\n\r\n    /// @notice Set whitelist state for an address.\r\n    function setWhitelist(address _addr, bool _state) public onlyOwner {\r\n        require(_addr != address(0));\r\n        isWhitelisted[_addr] = _state;\r\n        WhitelistSet(_addr, _state);\r\n    }\r\n\r\n    /// @notice Set whitelist state for multiple addresses\r\n    function setManyWhitelist(address[] _addr, bool _state) public onlyOwner {\r\n        for (uint256 i = 0; i < _addr.length; i++) {\r\n            setWhitelist(_addr[i], _state);\r\n        }\r\n    }\r\n\r\n    /// @notice offchain whitelist check\r\n    function isOffchainWhitelisted(address _addr, bytes _sig) public view returns (bool) {\r\n        bytes32 hash = keccak256(\"\\x19Ethereum Signed Message:\\n20\",_addr);\r\n        return hash.recover(_sig) == signer;\r\n    }\r\n}\r\n\r\n/**\r\n * @title EthealNormalSale\r\n * @author thesved\r\n * @notice Etheal Token Sale contract, with softcap and hardcap (cap)\r\n * @dev This contract has to be finalized before token claims are enabled\r\n */\r\ncontract EthealNormalSale is Pausable, FinalizableCrowdsale, CappedCrowdsale {\r\n    // the token is here\r\n    TokenController public ethealController;\r\n\r\n    // after reaching {weiRaised} >= {softCap}, there is {softCapTime} seconds until the sale closes\r\n    // {softCapClose} contains the closing time\r\n    uint256 public rate = 700;\r\n    uint256 public softCap = 6800 ether;\r\n    uint256 public softCapTime = 120 hours;\r\n    uint256 public softCapClose;\r\n    uint256 public cap = 14300 ether;\r\n\r\n    // how many token is sold and not claimed, used for refunding to token controller\r\n    uint256 public tokenBalance;\r\n\r\n    // total token sold\r\n    uint256 public tokenSold;\r\n\r\n    // minimum contribution, 0.1ETH\r\n    uint256 public minContribution = 0.1 ether;\r\n\r\n    // whitelist: above threshold the contract has to approve each transaction\r\n    EthealWhitelist public whitelist;\r\n    uint256 public whitelistThreshold = 1 ether;\r\n\r\n    // deposit address from which it can get funds before sale\r\n    address public deposit;\r\n    \r\n    // stakes contains token bought and contirbutions contains the value in wei\r\n    mapping (address => uint256) public stakes;\r\n    mapping (address => uint256) public contributions;\r\n\r\n    // promo token bonus\r\n    address public promoTokenController;\r\n    mapping (address => uint256) public bonusExtra;\r\n\r\n    // addresses of contributors to handle finalization after token sale end (refunds or token claims)\r\n    address[] public contributorsKeys; \r\n\r\n    // events for token purchase during sale and claiming tokens after sale\r\n    event LogTokenClaimed(address indexed _claimer, address indexed _beneficiary, uint256 _amount);\r\n    event LogTokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount, uint256 _participants, uint256 _weiRaised);\r\n    event LogTokenSoftCapReached(uint256 _closeTime);\r\n    event LogTokenHardCapReached();\r\n\r\n    ////////////////\r\n    // Constructor and inherited function overrides\r\n    ////////////////\r\n\r\n    /// @notice Constructor to create PreSale contract\r\n    /// @param _ethealController Address of ethealController\r\n    /// @param _startTime The start time of token sale in seconds.\r\n    /// @param _endTime The end time of token sale in seconds.\r\n    /// @param _minContribution The minimum contribution per transaction in wei (0.1 ETH)\r\n    /// @param _rate Number of HEAL tokens per 1 ETH\r\n    /// @param _softCap Softcap in wei, reaching it ends the sale in _softCapTime seconds\r\n    /// @param _softCapTime Seconds until the sale remains open after reaching _softCap\r\n    /// @param _cap Maximum cap in wei, we can't raise more funds\r\n    /// @param _wallet Address of multisig wallet, which will get all the funds after successful sale\r\n    function EthealNormalSale(\r\n        address _ethealController,\r\n        uint256 _startTime, \r\n        uint256 _endTime, \r\n        uint256 _minContribution, \r\n        uint256 _rate, \r\n        uint256 _softCap, \r\n        uint256 _softCapTime, \r\n        uint256 _cap, \r\n        address _wallet\r\n    )\r\n        CappedCrowdsale(_cap)\r\n        FinalizableCrowdsale()\r\n        Crowdsale(_startTime, _endTime, _rate, _wallet)\r\n    {\r\n        // ethealController must be valid\r\n        require(_ethealController != address(0));\r\n        ethealController = TokenController(_ethealController);\r\n\r\n        // caps have to be consistent with each other\r\n        require(_softCap <= _cap);\r\n        softCap = _softCap;\r\n        softCapTime = _softCapTime;\r\n\r\n        // this is needed since super constructor wont overwite overriden variables\r\n        cap = _cap;\r\n        rate = _rate;\r\n\r\n        minContribution = _minContribution;\r\n    }\r\n\r\n    ////////////////\r\n    // Administer contract details\r\n    ////////////////\r\n\r\n    /// @notice Sets min contribution\r\n    function setMinContribution(uint256 _minContribution) public onlyOwner {\r\n        minContribution = _minContribution;\r\n    }\r\n\r\n    /// @notice Sets soft cap and max cap\r\n    function setCaps(uint256 _softCap, uint256 _softCapTime, uint256 _cap) public onlyOwner {\r\n        require(_softCap <= _cap);\r\n        softCap = _softCap;\r\n        softCapTime = _softCapTime;\r\n        cap = _cap;\r\n    }\r\n\r\n    /// @notice Sets crowdsale start and end time\r\n    function setTimes(uint256 _startTime, uint256 _endTime) public onlyOwner {\r\n        require(_startTime <= _endTime);\r\n        require(!hasEnded());\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n    /// @notice Set rate\r\n    function setRate(uint256 _rate) public onlyOwner {\r\n        require(_rate > 0);\r\n        rate = _rate;\r\n    }\r\n\r\n    /// @notice Set address of promo token\r\n    function setPromoTokenController(address _addr) public onlyOwner {\r\n        require(_addr != address(0));\r\n        promoTokenController = _addr;\r\n    }\r\n\r\n    /// @notice Set whitelist contract address and minimum threshold\r\n    function setWhitelist(address _whitelist, uint256 _threshold) public onlyOwner {\r\n        // if whitelist contract address is provided we set it\r\n        if (_whitelist != address(0)) {\r\n            whitelist = EthealWhitelist(_whitelist);\r\n        }\r\n        whitelistThreshold = _threshold;\r\n    }\r\n\r\n    /// @notice Set deposit contract address from which it can receive money before sale\r\n    function setDeposit(address _deposit) public onlyOwner {\r\n        deposit = _deposit;\r\n    }\r\n\r\n    /// @notice move excess tokens, eg to hodler/sale contract\r\n    function moveTokens(address _to, uint256 _amount) public onlyOwner {\r\n        require(_to != address(0));\r\n        require(_amount <= getHealBalance().sub(tokenBalance));\r\n        require(ethealController.ethealToken().transfer(_to, _amount));\r\n    }\r\n\r\n    ////////////////\r\n    // Purchase functions\r\n    ////////////////\r\n\r\n    /// @dev Overriding Crowdsale#buyTokens to add partial refund\r\n    /// @param _beneficiary Beneficiary of the token purchase\r\n    function buyTokens(address _beneficiary) public payable whenNotPaused {\r\n        handlePayment(_beneficiary, msg.value, now, \"\");\r\n    }\r\n\r\n    /// @dev buying tokens for someone with offchain whitelist signature\r\n    function buyTokensSigned(address _beneficiary, bytes _whitelistSign) public payable whenNotPaused {\r\n        handlePayment(_beneficiary, msg.value, now, _whitelistSign);\r\n    }\r\n\r\n    /// @dev Internal function for handling transactions with ether.\r\n    function handlePayment(address _beneficiary, uint256 _amount, uint256 _time, bytes memory _whitelistSign) internal {\r\n        require(_beneficiary != address(0));\r\n\r\n        uint256 weiAmount = handleContribution(_beneficiary, _amount, _time, _whitelistSign);      \r\n        forwardFunds(weiAmount);  \r\n\r\n        // handle refund excess tokens\r\n        uint256 refund = _amount.sub(weiAmount);\r\n        if (refund > 0) {\r\n            _beneficiary.transfer(refund);\r\n        }\r\n    }\r\n\r\n    /// @dev Handling the amount of contribution and cap logic. Internal function.\r\n    /// @return Wei successfully contributed.\r\n    function handleContribution(address _beneficiary, uint256 _amount, uint256 _time, bytes memory _whitelistSign) internal returns (uint256) {\r\n        require(_beneficiary != address(0));\r\n\r\n        uint256 weiToCap = howMuchCanXContributeNow(_beneficiary);\r\n        uint256 weiAmount = uint256Min(weiToCap, _amount);\r\n\r\n        // account the new contribution\r\n        transferToken(_beneficiary, weiAmount, _time, _whitelistSign);\r\n\r\n        // close sale in softCapTime seconds after reaching softCap\r\n        if (weiRaised >= softCap && softCapClose == 0) {\r\n            softCapClose = now.add(softCapTime);\r\n            LogTokenSoftCapReached(uint256Min(softCapClose, endTime));\r\n        }\r\n\r\n        // event for hard cap reached\r\n        if (weiRaised >= cap) {\r\n            LogTokenHardCapReached();\r\n        }\r\n\r\n        return weiAmount;\r\n    }\r\n\r\n    /// @dev Handling token distribution and accounting. Overriding Crowdsale#transferToken.\r\n    /// @param _beneficiary Address of the recepient of the tokens\r\n    /// @param _weiAmount Contribution in wei\r\n    /// @param _time When the contribution was made\r\n    function transferToken(address _beneficiary, uint256 _weiAmount, uint256 _time, bytes memory _whitelistSign) internal {\r\n        require(_beneficiary != address(0));\r\n        require(validPurchase(_weiAmount));\r\n\r\n        // increase wei Raised\r\n        weiRaised = weiRaised.add(_weiAmount);\r\n\r\n        // require whitelist above threshold\r\n        contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);\r\n        require(contributions[_beneficiary] <= whitelistThreshold \r\n                || whitelist.isWhitelisted(_beneficiary)\r\n                || whitelist.isOffchainWhitelisted(_beneficiary, _whitelistSign)\r\n        );\r\n\r\n        // calculate tokens, so we can refund excess tokens to EthealController after token sale\r\n        uint256 _bonus = getBonus(_beneficiary, _weiAmount, _time);\r\n        uint256 tokens = _weiAmount.mul(rate).mul(_bonus).div(100);\r\n        tokenBalance = tokenBalance.add(tokens);\r\n\r\n        if (stakes[_beneficiary] == 0) {\r\n            contributorsKeys.push(_beneficiary);\r\n        }\r\n        stakes[_beneficiary] = stakes[_beneficiary].add(tokens);\r\n\r\n        LogTokenPurchase(msg.sender, _beneficiary, _weiAmount, tokens, contributorsKeys.length, weiRaised);\r\n    }\r\n\r\n    /// @dev Get eth deposit from Deposit contract\r\n    function depositEth(address _beneficiary, uint256 _time, bytes _whitelistSign) public payable whenNotPaused {\r\n        require(msg.sender == deposit);\r\n\r\n        handlePayment(_beneficiary, msg.value, _time, _whitelistSign);\r\n    }\r\n\r\n    /// @dev Deposit from other currencies\r\n    function depositOffchain(address _beneficiary, uint256 _amount, uint256 _time, bytes _whitelistSign) public onlyOwner whenNotPaused {\r\n        handleContribution(_beneficiary, _amount, _time, _whitelistSign);\r\n    }\r\n\r\n    /// @dev Overriding Crowdsale#validPurchase to add min contribution logic\r\n    /// @param _weiAmount Contribution amount in wei\r\n    /// @return true if contribution is okay\r\n    function validPurchase(uint256 _weiAmount) internal constant returns (bool) {\r\n        bool nonEnded = !hasEnded();\r\n        bool nonZero = _weiAmount != 0;\r\n        bool enoughContribution = _weiAmount >= minContribution;\r\n        return nonEnded && nonZero && enoughContribution;\r\n    }\r\n\r\n    /// @dev Overriding Crowdsale#hasEnded to add soft cap logic\r\n    /// @return true if crowdsale event has ended or a softCapClose time is set and passed\r\n    function hasEnded() public constant returns (bool) {\r\n        return super.hasEnded() || softCapClose > 0 && now > softCapClose;\r\n    }\r\n\r\n    /// @dev Extending RefundableCrowdsale#finalization sending back excess tokens to ethealController\r\n    function finalization() internal {\r\n        uint256 _balance = getHealBalance();\r\n\r\n        // saving token balance for future reference\r\n        tokenSold = tokenBalance; \r\n\r\n        // send back the excess token to ethealController\r\n        if (_balance > tokenBalance) {\r\n            ethealController.ethealToken().transfer(ethealController.SALE(), _balance.sub(tokenBalance));\r\n        }\r\n\r\n        // hodler stake counting starts 14 days after closing normal sale\r\n        ethealController.setHodlerTime(now + 14 days);\r\n\r\n        super.finalization();\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // AFTER token sale\r\n    ////////////////\r\n\r\n    /// @notice Modifier for after sale finalization\r\n    modifier afterSale() {\r\n        require(isFinalized);\r\n        _;\r\n    }\r\n\r\n    /// @notice Claim token for msg.sender after token sale based on stake.\r\n    function claimToken() public afterSale {\r\n        claimTokenFor(msg.sender);\r\n    }\r\n\r\n    /// @notice Claim token after token sale based on stake.\r\n    /// @dev Anyone can call this function and distribute tokens after successful token sale\r\n    /// @param _beneficiary Address of the beneficiary who gets the token\r\n    function claimTokenFor(address _beneficiary) public afterSale whenNotPaused {\r\n        uint256 tokens = stakes[_beneficiary];\r\n        require(tokens > 0);\r\n\r\n        // set the stake 0 for beneficiary\r\n        stakes[_beneficiary] = 0;\r\n\r\n        // decrease tokenBalance, to make it possible to withdraw excess HEAL funds\r\n        tokenBalance = tokenBalance.sub(tokens);\r\n\r\n        // distribute hodlr stake\r\n        ethealController.addHodlerStake(_beneficiary, tokens);\r\n\r\n        // distribute token\r\n        require(ethealController.ethealToken().transfer(_beneficiary, tokens));\r\n        LogTokenClaimed(msg.sender, _beneficiary, tokens);\r\n    }\r\n\r\n    /// @notice claimToken() for multiple addresses\r\n    /// @dev Anyone can call this function and distribute tokens after successful token sale\r\n    /// @param _beneficiaries Array of addresses for which we want to claim tokens\r\n    function claimManyTokenFor(address[] _beneficiaries) external afterSale {\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n            claimTokenFor(_beneficiaries[i]);\r\n        }\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // Bonus functions\r\n    ////////////////\r\n\r\n    /// @notice Sets extra 5% bonus for those addresses who send back a promo token\r\n    /// @notice It contains an easter egg.\r\n    /// @param _addr this address gets the bonus\r\n    /// @param _value how many tokens are transferred\r\n    function setPromoBonus(address _addr, uint256 _value) public {\r\n        require(msg.sender == promoTokenController || msg.sender == owner);\r\n        require(_value>0);\r\n\r\n        uint256 _bonus = keccak256(_value) == 0xbeced09521047d05b8960b7e7bcc1d1292cf3e4b2a6b63f48335cbde5f7545d2 ? 6 : 5;\r\n\r\n        if (bonusExtra[ _addr ] < _bonus) {\r\n            bonusExtra[ _addr ] = _bonus;\r\n        }\r\n    }\r\n\r\n    /// @notice Manual set extra bonus for addresses\r\n    function setBonusExtra(address _addr, uint256 _bonus) public onlyOwner {\r\n        require(_addr != address(0));\r\n        bonusExtra[_addr] = _bonus;\r\n    }\r\n\r\n    /// @notice Mass set extra bonus for addresses\r\n    function setManyBonusExtra(address[] _addr, uint256 _bonus) external onlyOwner {\r\n        for (uint256 i = 0; i < _addr.length; i++) {\r\n            setBonusExtra(_addr[i],_bonus);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns bonus for now\r\n    function getBonusNow(address _addr, uint256 _size) public view returns (uint256) {\r\n        return getBonus(_addr, _size, now);\r\n    }\r\n\r\n    /// @notice Returns the bonus in percentage, eg 130 means 30% bonus\r\n    function getBonus(address _addr, uint256 _size, uint256 _time) public view returns (uint256 _bonus) {\r\n        // detailed bonus structure: https://etheal.com/#heal-token\r\n        _bonus = 100;\r\n        \r\n        // time based bonuses\r\n        uint256 _day = getSaleDay(_time);\r\n        uint256 _hour = getSaleHour(_time);\r\n        if (_day <= 1) {\r\n            if (_hour <= 1) _bonus = 130;\r\n            else if (_hour <= 5) _bonus = 125;\r\n            else if (_hour <= 8) _bonus = 120;\r\n            else _bonus = 118;\r\n        } \r\n        else if (_day <= 2) { _bonus = 116; }\r\n        else if (_day <= 3) { _bonus = 115; }\r\n        else if (_day <= 5) { _bonus = 114; }\r\n        else if (_day <= 7) { _bonus = 113; }\r\n        else if (_day <= 9) { _bonus = 112; }\r\n        else if (_day <= 11) { _bonus = 111; }\r\n        else if (_day <= 13) { _bonus = 110; }\r\n        else if (_day <= 15) { _bonus = 108; }\r\n        else if (_day <= 17) { _bonus = 107; }\r\n        else if (_day <= 19) { _bonus = 106; }\r\n        else if (_day <= 21) { _bonus = 105; }\r\n        else if (_day <= 23) { _bonus = 104; }\r\n        else if (_day <= 25) { _bonus = 103; }\r\n        else if (_day <= 27) { _bonus = 102; }\r\n\r\n        // size based bonuses\r\n        if (_size >= 100 ether) { _bonus = _bonus + 4; }\r\n        else if (_size >= 10 ether) { _bonus = _bonus + 2; }\r\n\r\n        // manual bonus\r\n        _bonus += bonusExtra[ _addr ];\r\n\r\n        return _bonus;\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // Constant, helper functions\r\n    ////////////////\r\n\r\n    /// @notice How many wei can the msg.sender contribute now.\r\n    function howMuchCanIContributeNow() view public returns (uint256) {\r\n        return howMuchCanXContributeNow(msg.sender);\r\n    }\r\n\r\n    /// @notice How many wei can an ethereum address contribute now.\r\n    /// @param _beneficiary Ethereum address\r\n    /// @return Number of wei the _beneficiary can contribute now.\r\n    function howMuchCanXContributeNow(address _beneficiary) view public returns (uint256) {\r\n        require(_beneficiary != address(0));\r\n\r\n        if (hasEnded() || paused) \r\n            return 0;\r\n\r\n        // wei to hard cap\r\n        uint256 weiToCap = cap.sub(weiRaised);\r\n\r\n        return weiToCap;\r\n    }\r\n\r\n    /// @notice For a give date how many 24 hour blocks have ellapsed since token sale start\r\n    ///  Before sale return 0, first day 1, second day 2, ...\r\n    /// @param _time Date in seconds for which we want to know which sale day it is\r\n    /// @return Number of 24 hour blocks ellapsing since token sale start starting from 1\r\n    function getSaleDay(uint256 _time) view public returns (uint256) {\r\n        uint256 _day = 0;\r\n        if (_time > startTime) {\r\n            _day = _time.sub(startTime).div(60*60*24).add(1);\r\n        }\r\n        return _day;\r\n    }\r\n\r\n    /// @notice How many 24 hour blocks have ellapsed since token sale start\r\n    /// @return Number of 24 hour blocks ellapsing since token sale start starting from 1\r\n    function getSaleDayNow() view public returns (uint256) {\r\n        return getSaleDay(now);\r\n    }\r\n\r\n    /// @notice Returns sale hour: 0 before sale, 1 for the first hour, ...\r\n    /// @param _time Date in seconds for which we want to know which sale hour it is\r\n    /// @return Number of 1 hour blocks ellapsing since token sale start starting from 1\r\n    function getSaleHour(uint256 _time) view public returns (uint256) {\r\n        uint256 _hour = 0;\r\n        if (_time > startTime) {\r\n            _hour = _time.sub(startTime).div(60*60).add(1);\r\n        }\r\n        return _hour;\r\n    }\r\n\r\n    /// @notice How many 1 hour blocks have ellapsed since token sale start\r\n    /// @return Number of 1 hour blocks ellapsing since token sale start starting from 1\r\n    function getSaleHourNow() view public returns (uint256) {\r\n        return getSaleHour(now);\r\n    }\r\n\r\n    /// @notice Minimum between two uint256 numbers\r\n    function uint256Min(uint256 a, uint256 b) pure internal returns (uint256) {\r\n        return a > b ? b : a;\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // Test and contribution web app, NO audit is needed\r\n    ////////////////\r\n\r\n    /// @notice How many contributors we have.\r\n    /// @return Number of different contributor ethereum addresses\r\n    function getContributorsCount() view public returns (uint256) {\r\n        return contributorsKeys.length;\r\n    }\r\n\r\n    /// @notice Get contributor addresses to manage refunds or token claims.\r\n    /// @dev If the sale is not yet successful, then it searches in the RefundVault.\r\n    ///  If the sale is successful, it searches in contributors.\r\n    /// @param _pending If true, then returns addresses which didn't get their tokens distributed to them\r\n    /// @param _claimed If true, then returns already distributed addresses\r\n    /// @return Array of addresses of contributors\r\n    function getContributors(bool _pending, bool _claimed) view public returns (address[] contributors) {\r\n        uint256 i = 0;\r\n        uint256 results = 0;\r\n        address[] memory _contributors = new address[](contributorsKeys.length);\r\n\r\n        // search in contributors\r\n        for (i = 0; i < contributorsKeys.length; i++) {\r\n            if (_pending && stakes[contributorsKeys[i]] > 0 || _claimed && stakes[contributorsKeys[i]] == 0) {\r\n                _contributors[results] = contributorsKeys[i];\r\n                results++;\r\n            }\r\n        }\r\n\r\n        contributors = new address[](results);\r\n        for (i = 0; i < results; i++) {\r\n            contributors[i] = _contributors[i];\r\n        }\r\n\r\n        return contributors;\r\n    }\r\n\r\n    /// @notice How many HEAL tokens do this contract have\r\n    function getHealBalance() view public returns (uint256) {\r\n        return ethealController.ethealToken().balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice Get current date for web3\r\n    function getNow() view public returns (uint256) {\r\n        return now;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"getBonusNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address[]\"},{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"setManyBonusExtra\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address\"},{\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"setBonusExtra\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_whitelistSign\",\"type\":\"bytes\"}],\"name\":\"depositEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setTimes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHealBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getSaleHour\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pending\",\"type\":\"bool\"},{\"name\":\"_claimed\",\"type\":\"bool\"}],\"name\":\"getContributors\",\"outputs\":[{\"name\":\"contributors\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deposit\",\"type\":\"address\"}],\"name\":\"setDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributorsKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minContribution\",\"type\":\"uint256\"}],\"name\":\"setMinContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"claimManyTokenFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howMuchCanIContributeNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"},{\"name\":\"_whitelistSign\",\"type\":\"bytes\"}],\"name\":\"depositOffchain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_size\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethealController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_whitelistSign\",\"type\":\"bytes\"}],\"name\":\"buyTokensSigned\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleDayNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusExtra\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapClose\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleHourNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"howMuchCanXContributeNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPromoTokenController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promoTokenController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"getSaleDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimTokenFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_softCapTime\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setCaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setPromoBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContributorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ethealController\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_minContribution\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_softCapTime\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LogTokenClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_participants\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_weiRaised\",\"type\":\"uint256\"}],\"name\":\"LogTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_closeTime\",\"type\":\"uint256\"}],\"name\":\"LogTokenSoftCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogTokenHardCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"EthealNormalSale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b565726e2e44e4ae9e3ce750fc4ba8fa65e701e0000000000000000000000000000000000000000000000000000000005b108c80000000000000000000000000000000000000000000000000000000005b381980000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000000000000000002bc00000000000000000000000000000000000000000000028a857425466f800000000000000000000000000000000000000000000000000000000000000028de8000000000000000000000000000000000000000000000054b40b1f852bda00000000000000000000000000000fc5c6c8015962e7035f3bdc5fe7ec94bedc77833","Library":"","SwarmSource":"bzzr://f6fcdff934a92a2e554c996651bf834b7f60f12831e1855cf0b25720ce49fb08"}]}