{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId);\r\n}\r\n\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));\r\n    OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\ncontract LicenseAccessControl {\r\n  /**\r\n   * @notice ContractUpgrade is the event that will be emitted if we set a new contract address\r\n   */\r\n  event ContractUpgrade(address newContract);\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  /**\r\n   * @notice CEO's address FOOBAR\r\n   */\r\n  address public ceoAddress;\r\n\r\n  /**\r\n   * @notice CFO's address\r\n   */\r\n  address public cfoAddress;\r\n\r\n  /**\r\n   * @notice COO's address\r\n   */\r\n  address public cooAddress;\r\n\r\n  /**\r\n   * @notice withdrawal address\r\n   */\r\n  address public withdrawalAddress;\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function only callable by the CEO\r\n   */\r\n  modifier onlyCEO() {\r\n    require(msg.sender == ceoAddress);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function only callable by the CFO\r\n   */\r\n  modifier onlyCFO() {\r\n    require(msg.sender == cfoAddress);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function only callable by the COO\r\n   */\r\n  modifier onlyCOO() {\r\n    require(msg.sender == cooAddress);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function only callable by C-level execs\r\n   */\r\n  modifier onlyCLevel() {\r\n    require(\r\n      msg.sender == cooAddress ||\r\n      msg.sender == ceoAddress ||\r\n      msg.sender == cfoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function only callable by CEO or CFO\r\n   */\r\n  modifier onlyCEOOrCFO() {\r\n    require(\r\n      msg.sender == cfoAddress ||\r\n      msg.sender == ceoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function only callable by CEO or COO\r\n   */\r\n  modifier onlyCEOOrCOO() {\r\n    require(\r\n      msg.sender == cooAddress ||\r\n      msg.sender == ceoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new CEO\r\n   * @param _newCEO - the address of the new CEO\r\n   */\r\n  function setCEO(address _newCEO) external onlyCEO {\r\n    require(_newCEO != address(0));\r\n    ceoAddress = _newCEO;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new CFO\r\n   * @param _newCFO - the address of the new CFO\r\n   */\r\n  function setCFO(address _newCFO) external onlyCEO {\r\n    require(_newCFO != address(0));\r\n    cfoAddress = _newCFO;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new COO\r\n   * @param _newCOO - the address of the new COO\r\n   */\r\n  function setCOO(address _newCOO) external onlyCEO {\r\n    require(_newCOO != address(0));\r\n    cooAddress = _newCOO;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new withdrawalAddress\r\n   * @param _newWithdrawalAddress - the address where we'll send the funds\r\n   */\r\n  function setWithdrawalAddress(address _newWithdrawalAddress) external onlyCEO {\r\n    require(_newWithdrawalAddress != address(0));\r\n    withdrawalAddress = _newWithdrawalAddress;\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraw the balance to the withdrawalAddress\r\n   * @dev We set a withdrawal address seperate from the CFO because this allows us to withdraw to a cold wallet.\r\n   */\r\n  function withdrawBalance() external onlyCEOOrCFO {\r\n    require(withdrawalAddress != address(0));\r\n    withdrawalAddress.transfer(this.balance);\r\n  }\r\n\r\n  /** Pausable functionality adapted from OpenZeppelin **/\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice called by any C-level to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyCLevel whenNotPaused {\r\n    paused = true;\r\n    Paused();\r\n  }\r\n\r\n  /**\r\n   * @notice called by the CEO to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyCEO whenPaused {\r\n    paused = false;\r\n    Unpaused();\r\n  }\r\n}\r\n\r\ncontract LicenseBase is LicenseAccessControl {\r\n  /**\r\n   * @notice Issued is emitted when a new license is issued\r\n   */\r\n  event LicenseIssued(\r\n    address indexed owner,\r\n    address indexed purchaser,\r\n    uint256 licenseId,\r\n    uint256 productId,\r\n    uint256 attributes,\r\n    uint256 issuedTime,\r\n    uint256 expirationTime,\r\n    address affiliate\r\n  );\r\n\r\n  event LicenseRenewal(\r\n    address indexed owner,\r\n    address indexed purchaser,\r\n    uint256 licenseId,\r\n    uint256 productId,\r\n    uint256 expirationTime\r\n  );\r\n\r\n  struct License {\r\n    uint256 productId;\r\n    uint256 attributes;\r\n    uint256 issuedTime;\r\n    uint256 expirationTime;\r\n    address affiliate;\r\n  }\r\n\r\n  /**\r\n   * @notice All licenses in existence.\r\n   * @dev The ID of each license is an index in this array.\r\n   */\r\n  License[] licenses;\r\n\r\n  /** internal **/\r\n  function _isValidLicense(uint256 _licenseId) internal view returns (bool) {\r\n    return licenseProductId(_licenseId) != 0;\r\n  }\r\n\r\n  /** anyone **/\r\n\r\n  /**\r\n   * @notice Get a license's productId\r\n   * @param _licenseId the license id\r\n   */\r\n  function licenseProductId(uint256 _licenseId) public view returns (uint256) {\r\n    return licenses[_licenseId].productId;\r\n  }\r\n\r\n  /**\r\n   * @notice Get a license's attributes\r\n   * @param _licenseId the license id\r\n   */\r\n  function licenseAttributes(uint256 _licenseId) public view returns (uint256) {\r\n    return licenses[_licenseId].attributes;\r\n  }\r\n\r\n  /**\r\n   * @notice Get a license's issueTime\r\n   * @param _licenseId the license id\r\n   */\r\n  function licenseIssuedTime(uint256 _licenseId) public view returns (uint256) {\r\n    return licenses[_licenseId].issuedTime;\r\n  }\r\n\r\n  /**\r\n   * @notice Get a license's issueTime\r\n   * @param _licenseId the license id\r\n   */\r\n  function licenseExpirationTime(uint256 _licenseId) public view returns (uint256) {\r\n    return licenses[_licenseId].expirationTime;\r\n  }\r\n\r\n  /**\r\n   * @notice Get a the affiliate credited for the sale of this license\r\n   * @param _licenseId the license id\r\n   */\r\n  function licenseAffiliate(uint256 _licenseId) public view returns (address) {\r\n    return licenses[_licenseId].affiliate;\r\n  }\r\n\r\n  /**\r\n   * @notice Get a license's info\r\n   * @param _licenseId the license id\r\n   */\r\n  function licenseInfo(uint256 _licenseId)\r\n    public view returns (uint256, uint256, uint256, uint256, address)\r\n  {\r\n    return (\r\n      licenseProductId(_licenseId),\r\n      licenseAttributes(_licenseId),\r\n      licenseIssuedTime(_licenseId),\r\n      licenseExpirationTime(_licenseId),\r\n      licenseAffiliate(_licenseId)\r\n    );\r\n  }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\ncontract AffiliateProgram is Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  event AffiliateCredit(\r\n    // The address of the affiliate\r\n    address affiliate,\r\n    // The store's ID of what was sold (e.g. a tokenId)\r\n    uint256 productId,\r\n    // The amount owed this affiliate in this sale\r\n    uint256 amount\r\n  );\r\n\r\n  event Withdraw(address affiliate, address to, uint256 amount);\r\n  event Whitelisted(address affiliate, uint256 amount);\r\n  event RateChanged(uint256 rate, uint256 amount);\r\n\r\n  // @notice A mapping from affiliate address to their balance\r\n  mapping (address => uint256) public balances;\r\n\r\n  // @notice A mapping from affiliate address to the time of last deposit\r\n  mapping (address => uint256) public lastDepositTimes;\r\n\r\n  // @notice The last deposit globally\r\n  uint256 public lastDepositTime;\r\n\r\n  // @notice The maximum rate for any affiliate\r\n  // @dev The hard-coded maximum affiliate rate (in basis points)\r\n  // All rates are measured in basis points (1/100 of a percent)\r\n  // Values 0-10,000 map to 0%-100%\r\n  uint256 private constant hardCodedMaximumRate = 5000;\r\n\r\n  // @notice The commission exiration time\r\n  // @dev Affiliate commissions expire if they are unclaimed after this amount of time\r\n  uint256 private constant commissionExpiryTime = 30 days;\r\n\r\n  // @notice The baseline affiliate rate (in basis points) for non-whitelisted referrals\r\n  uint256 public baselineRate = 0;\r\n\r\n  // @notice A mapping from whitelisted referrals to their individual rates\r\n  mapping (address => uint256) public whitelistRates;\r\n\r\n  // @notice The maximum rate for any affiliate\r\n  // @dev overrides individual rates. This can be used to clip the rate used in bulk, if necessary\r\n  uint256 public maximumRate = 5000;\r\n\r\n  // @notice The address of the store selling products\r\n  address public storeAddress;\r\n\r\n  // @notice The contract is retired\r\n  // @dev If we decide to retire this program, this value will be set to true\r\n  // and then the contract cannot be unpaused\r\n  bool public retired = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function only callable by the store or the owner\r\n   */\r\n  modifier onlyStoreOrOwner() {\r\n    require(\r\n      msg.sender == storeAddress ||\r\n      msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev AffiliateProgram constructor - keeps the address of it's parent store\r\n   * and pauses the contract\r\n   */\r\n  function AffiliateProgram(address _storeAddress) public {\r\n    require(_storeAddress != address(0));\r\n    storeAddress = _storeAddress;\r\n    paused = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Exposes that this contract thinks it is an AffiliateProgram\r\n   */\r\n  function isAffiliateProgram() public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice returns the commission rate for a sale\r\n   *\r\n   * @dev rateFor returns the rate which should be used to calculate the comission\r\n   *  for this affiliate/sale combination, in basis points (1/100th of a percent).\r\n   *\r\n   *  We may want to completely blacklist a particular address (e.g. a known bad actor affilite).\r\n   *  To that end, if the whitelistRate is exactly 1bp, we use that as a signal for blacklisting\r\n   *  and return a rate of zero. The upside is that we can completely turn off\r\n   *  sending transactions to a particular address when this is needed. The\r\n   *  downside is that you can't issued 1/100th of a percent commission.\r\n   *  However, since this is such a small amount its an acceptable tradeoff.\r\n   *\r\n   *  This implementation does not use the _productId, _pruchaseId,\r\n   *  _purchaseAmount, but we include them here as part of the protocol, because\r\n   *  they could be useful in more advanced affiliate programs.\r\n   *\r\n   * @param _affiliate - the address of the affiliate to check for\r\n   */\r\n  function rateFor(\r\n    address _affiliate,\r\n    uint256 /*_productId*/,\r\n    uint256 /*_purchaseId*/,\r\n    uint256 /*_purchaseAmount*/)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 whitelistedRate = whitelistRates[_affiliate];\r\n    if(whitelistedRate > 0) {\r\n      // use 1 bp as a blacklist signal\r\n      if(whitelistedRate == 1) {\r\n        return 0;\r\n      } else {\r\n        return Math.min256(whitelistedRate, maximumRate);\r\n      }\r\n    } else {\r\n      return Math.min256(baselineRate, maximumRate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice cutFor returns the affiliate cut for a sale\r\n   * @dev cutFor returns the cut (amount in wei) to give in comission to the affiliate\r\n   *\r\n   * @param _affiliate - the address of the affiliate to check for\r\n   * @param _productId - the productId in the sale\r\n   * @param _purchaseId - the purchaseId in the sale\r\n   * @param _purchaseAmount - the purchaseAmount\r\n   */\r\n  function cutFor(\r\n    address _affiliate,\r\n    uint256 _productId,\r\n    uint256 _purchaseId,\r\n    uint256 _purchaseAmount)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 rate = rateFor(\r\n      _affiliate,\r\n      _productId,\r\n      _purchaseId,\r\n      _purchaseAmount);\r\n    require(rate <= hardCodedMaximumRate);\r\n    return (_purchaseAmount.mul(rate)).div(10000);\r\n  }\r\n\r\n  /**\r\n   * @notice credit an affiliate for a purchase\r\n   * @dev credit accepts eth and credits the affiliate's balance for the amount\r\n   *\r\n   * @param _affiliate - the address of the affiliate to credit\r\n   * @param _purchaseId - the purchaseId of the sale\r\n   */\r\n  function credit(\r\n    address _affiliate,\r\n    uint256 _purchaseId)\r\n    public\r\n    onlyStoreOrOwner\r\n    whenNotPaused\r\n    payable\r\n  {\r\n    require(msg.value > 0);\r\n    require(_affiliate != address(0));\r\n    balances[_affiliate] += msg.value;\r\n    lastDepositTimes[_affiliate] = now; // solium-disable-line security/no-block-members\r\n    lastDepositTime = now; // solium-disable-line security/no-block-members\r\n    AffiliateCredit(_affiliate, _purchaseId, msg.value);\r\n  }\r\n\r\n  /**\r\n   * @dev _performWithdraw performs a withdrawal from address _from and\r\n   * transfers it to _to. This can be different because we allow the owner\r\n   * to withdraw unclaimed funds after a period of time.\r\n   *\r\n   * @param _from - the address to subtract balance from\r\n   * @param _to - the address to transfer ETH to\r\n   */\r\n  function _performWithdraw(address _from, address _to) private {\r\n    require(balances[_from] > 0);\r\n    uint256 balanceValue = balances[_from];\r\n    balances[_from] = 0;\r\n    _to.transfer(balanceValue);\r\n    Withdraw(_from, _to, balanceValue);\r\n  }\r\n\r\n  /**\r\n   * @notice withdraw\r\n   * @dev withdraw the msg.sender's balance\r\n   */\r\n  function withdraw() public whenNotPaused {\r\n    _performWithdraw(msg.sender, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice withdraw from a specific account\r\n   * @dev withdrawFrom allows the owner to withdraw an affiliate's unclaimed\r\n   * ETH, after the alotted time.\r\n   *\r\n   * This function can be called even if the contract is paused\r\n   *\r\n   * @param _affiliate - the address of the affiliate\r\n   * @param _to - the address to send ETH to\r\n   */\r\n  function withdrawFrom(address _affiliate, address _to) onlyOwner public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(now > lastDepositTimes[_affiliate].add(commissionExpiryTime));\r\n    _performWithdraw(_affiliate, _to);\r\n  }\r\n\r\n  /**\r\n   * @notice retire the contract (dangerous)\r\n   * @dev retire - withdraws the entire balance and marks the contract as retired, which\r\n   * prevents unpausing.\r\n   *\r\n   * If no new comissions have been deposited for the alotted time,\r\n   * then the owner may pause the program and retire this contract.\r\n   * This may only be performed once as the contract cannot be unpaused.\r\n   *\r\n   * We do this as an alternative to selfdestruct, because certain operations\r\n   * can still be performed after the contract has been selfdestructed, such as\r\n   * the owner withdrawing ETH accidentally sent here.\r\n   */\r\n  function retire(address _to) onlyOwner whenPaused public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(now > lastDepositTime.add(commissionExpiryTime));\r\n    _to.transfer(this.balance);\r\n    retired = true;\r\n  }\r\n\r\n  /**\r\n   * @notice whitelist an affiliate address\r\n   * @dev whitelist - white listed affiliates can receive a different\r\n   *   rate than the general public (whitelisted accounts would generally get a\r\n   *   better rate).\r\n   * @param _affiliate - the affiliate address to whitelist\r\n   * @param _rate - the rate, in basis-points (1/100th of a percent) to give this affiliate in each sale. NOTE: a rate of exactly 1 is the signal to blacklist this affiliate. That is, a rate of 1 will set the commission to 0.\r\n   */\r\n  function whitelist(address _affiliate, uint256 _rate) onlyOwner public {\r\n    require(_rate <= hardCodedMaximumRate);\r\n    whitelistRates[_affiliate] = _rate;\r\n    Whitelisted(_affiliate, _rate);\r\n  }\r\n\r\n  /**\r\n   * @notice set the rate for non-whitelisted affiliates\r\n   * @dev setBaselineRate - sets the baseline rate for any affiliate that is not whitelisted\r\n   * @param _newRate - the rate, in bp (1/100th of a percent) to give any non-whitelisted affiliate. Set to zero to \"turn off\"\r\n   */\r\n  function setBaselineRate(uint256 _newRate) onlyOwner public {\r\n    require(_newRate <= hardCodedMaximumRate);\r\n    baselineRate = _newRate;\r\n    RateChanged(0, _newRate);\r\n  }\r\n\r\n  /**\r\n   * @notice set the maximum rate for any affiliate\r\n   * @dev setMaximumRate - Set the maximum rate for any affiliate, including whitelists. That is, this overrides individual rates.\r\n   * @param _newRate - the rate, in bp (1/100th of a percent)\r\n   */\r\n  function setMaximumRate(uint256 _newRate) onlyOwner public {\r\n    require(_newRate <= hardCodedMaximumRate);\r\n    maximumRate = _newRate;\r\n    RateChanged(1, _newRate);\r\n  }\r\n\r\n  /**\r\n   * @notice unpause the contract\r\n   * @dev called by the owner to unpause, returns to normal state. Will not\r\n   * unpause if the contract is retired.\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    require(!retired);\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n\r\n}\r\n\r\ncontract ERC721 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n  function transfer(address _to, uint256 _tokenId) external;\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) external;\r\n  function setApprovalForAll(address _to, bool _approved) external;\r\n  function getApproved(uint256 _tokenId) public view returns (address);\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n}\r\n\r\ncontract LicenseInventory is LicenseBase {\r\n  using SafeMath for uint256;\r\n\r\n  event ProductCreated(\r\n    uint256 id,\r\n    uint256 price,\r\n    uint256 available,\r\n    uint256 supply,\r\n    uint256 interval,\r\n    bool renewable\r\n  );\r\n  event ProductInventoryAdjusted(uint256 productId, uint256 available);\r\n  event ProductPriceChanged(uint256 productId, uint256 price);\r\n  event ProductRenewableChanged(uint256 productId, bool renewable);\r\n\r\n\r\n  /**\r\n   * @notice Product defines a product\r\n   * * renewable: There may come a time when we which to disable the ability to renew a subscription. For example, a plan we no longer wish to support. Obviously care needs to be taken with how we communicate this to customers, but contract-wise, we want to support the ability to discontinue renewal of certain plans.\r\n  */\r\n  struct Product {\r\n    uint256 id;\r\n    uint256 price;\r\n    uint256 available;\r\n    uint256 supply;\r\n    uint256 sold;\r\n    uint256 interval;\r\n    bool renewable;\r\n  }\r\n\r\n  // @notice All products in existence\r\n  uint256[] public allProductIds;\r\n\r\n  // @notice A mapping from product ids to Products\r\n  mapping (uint256 => Product) public products;\r\n\r\n  /*** internal ***/\r\n\r\n  /**\r\n   * @notice _productExists checks to see if a product exists\r\n   */\r\n  function _productExists(uint256 _productId) internal view returns (bool) {\r\n    return products[_productId].id != 0;\r\n  }\r\n\r\n  function _productDoesNotExist(uint256 _productId) internal view returns (bool) {\r\n    return products[_productId].id == 0;\r\n  }\r\n\r\n  function _createProduct(\r\n    uint256 _productId,\r\n    uint256 _initialPrice,\r\n    uint256 _initialInventoryQuantity,\r\n    uint256 _supply,\r\n    uint256 _interval)\r\n    internal\r\n  {\r\n    require(_productDoesNotExist(_productId));\r\n    require(_initialInventoryQuantity <= _supply);\r\n\r\n    Product memory _product = Product({\r\n      id: _productId,\r\n      price: _initialPrice,\r\n      available: _initialInventoryQuantity,\r\n      supply: _supply,\r\n      sold: 0,\r\n      interval: _interval,\r\n      renewable: _interval == 0 ? false : true\r\n    });\r\n\r\n    products[_productId] = _product;\r\n    allProductIds.push(_productId);\r\n\r\n    ProductCreated(\r\n      _product.id,\r\n      _product.price,\r\n      _product.available,\r\n      _product.supply,\r\n      _product.interval,\r\n      _product.renewable\r\n      );\r\n  }\r\n\r\n  function _incrementInventory(\r\n    uint256 _productId,\r\n    uint256 _inventoryAdjustment)\r\n    internal\r\n  {\r\n    require(_productExists(_productId));\r\n    uint256 newInventoryLevel = products[_productId].available.add(_inventoryAdjustment);\r\n\r\n    // A supply of \"0\" means \"unlimited\". Otherwise we need to ensure that we're not over-creating this product\r\n    if(products[_productId].supply > 0) {\r\n      // you have to take already sold into account\r\n      require(products[_productId].sold.add(newInventoryLevel) <= products[_productId].supply);\r\n    }\r\n\r\n    products[_productId].available = newInventoryLevel;\r\n  }\r\n\r\n  function _decrementInventory(\r\n    uint256 _productId,\r\n    uint256 _inventoryAdjustment)\r\n    internal\r\n  {\r\n    require(_productExists(_productId));\r\n    uint256 newInventoryLevel = products[_productId].available.sub(_inventoryAdjustment);\r\n    // unnecessary because we're using SafeMath and an unsigned int\r\n    // require(newInventoryLevel >= 0);\r\n    products[_productId].available = newInventoryLevel;\r\n  }\r\n\r\n  function _clearInventory(uint256 _productId) internal\r\n  {\r\n    require(_productExists(_productId));\r\n    products[_productId].available = 0;\r\n  }\r\n\r\n  function _setPrice(uint256 _productId, uint256 _price) internal\r\n  {\r\n    require(_productExists(_productId));\r\n    products[_productId].price = _price;\r\n  }\r\n\r\n  function _setRenewable(uint256 _productId, bool _isRenewable) internal\r\n  {\r\n    require(_productExists(_productId));\r\n    products[_productId].renewable = _isRenewable;\r\n  }\r\n\r\n  function _purchaseOneUnitInStock(uint256 _productId) internal {\r\n    require(_productExists(_productId));\r\n    require(availableInventoryOf(_productId) > 0);\r\n\r\n    // lower inventory\r\n    _decrementInventory(_productId, 1);\r\n\r\n    // record that one was sold\r\n    products[_productId].sold = products[_productId].sold.add(1);\r\n  }\r\n\r\n  function _requireRenewableProduct(uint256 _productId) internal view {\r\n    // productId must exist\r\n    require(_productId != 0);\r\n    // You can only renew a subscription product\r\n    require(isSubscriptionProduct(_productId));\r\n    // The product must currently be renewable\r\n    require(renewableOf(_productId));\r\n  }\r\n\r\n  /*** public ***/\r\n\r\n  /** executives-only **/\r\n\r\n  /**\r\n   * @notice createProduct creates a new product in the system\r\n   * @param _productId - the id of the product to use (cannot be changed)\r\n   * @param _initialPrice - the starting price (price can be changed)\r\n   * @param _initialInventoryQuantity - the initial inventory (inventory can be changed)\r\n   * @param _supply - the total supply - use `0` for \"unlimited\" (cannot be changed)\r\n   */\r\n  function createProduct(\r\n    uint256 _productId,\r\n    uint256 _initialPrice,\r\n    uint256 _initialInventoryQuantity,\r\n    uint256 _supply,\r\n    uint256 _interval)\r\n    external\r\n    onlyCEOOrCOO\r\n  {\r\n    _createProduct(\r\n      _productId,\r\n      _initialPrice,\r\n      _initialInventoryQuantity,\r\n      _supply,\r\n      _interval);\r\n  }\r\n\r\n  /**\r\n   * @notice incrementInventory - increments the inventory of a product\r\n   * @param _productId - the product id\r\n   * @param _inventoryAdjustment - the amount to increment\r\n   */\r\n  function incrementInventory(\r\n    uint256 _productId,\r\n    uint256 _inventoryAdjustment)\r\n    external\r\n    onlyCLevel\r\n  {\r\n    _incrementInventory(_productId, _inventoryAdjustment);\r\n    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\r\n  }\r\n\r\n  /**\r\n  * @notice decrementInventory removes inventory levels for a product\r\n  * @param _productId - the product id\r\n  * @param _inventoryAdjustment - the amount to decrement\r\n  */\r\n  function decrementInventory(\r\n    uint256 _productId,\r\n    uint256 _inventoryAdjustment)\r\n    external\r\n    onlyCLevel\r\n  {\r\n    _decrementInventory(_productId, _inventoryAdjustment);\r\n    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\r\n  }\r\n\r\n  /**\r\n  * @notice clearInventory clears the inventory of a product.\r\n  * @dev decrementInventory verifies inventory levels, whereas this method\r\n  * simply sets the inventory to zero. This is useful, for example, if an\r\n  * executive wants to take a product off the market quickly. There could be a\r\n  * race condition with decrementInventory where a product is sold, which could\r\n  * cause the admins decrement to fail (because it may try to decrement more\r\n  * than available).\r\n  *\r\n  * @param _productId - the product id\r\n  */\r\n  function clearInventory(uint256 _productId)\r\n    external\r\n    onlyCLevel\r\n  {\r\n    _clearInventory(_productId);\r\n    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\r\n  }\r\n\r\n  /**\r\n  * @notice setPrice - sets the price of a product\r\n  * @param _productId - the product id\r\n  * @param _price - the product price\r\n  */\r\n  function setPrice(uint256 _productId, uint256 _price)\r\n    external\r\n    onlyCLevel\r\n  {\r\n    _setPrice(_productId, _price);\r\n    ProductPriceChanged(_productId, _price);\r\n  }\r\n\r\n  /**\r\n  * @notice setRenewable - sets if a product is renewable\r\n  * @param _productId - the product id\r\n  * @param _newRenewable - the new renewable setting\r\n  */\r\n  function setRenewable(uint256 _productId, bool _newRenewable)\r\n    external\r\n    onlyCLevel\r\n  {\r\n    _setRenewable(_productId, _newRenewable);\r\n    ProductRenewableChanged(_productId, _newRenewable);\r\n  }\r\n\r\n  /** anyone **/\r\n\r\n  /**\r\n  * @notice The price of a product\r\n  * @param _productId - the product id\r\n  */\r\n  function priceOf(uint256 _productId) public view returns (uint256) {\r\n    return products[_productId].price;\r\n  }\r\n\r\n  /**\r\n  * @notice The available inventory of a product\r\n  * @param _productId - the product id\r\n  */\r\n  function availableInventoryOf(uint256 _productId) public view returns (uint256) {\r\n    return products[_productId].available;\r\n  }\r\n\r\n  /**\r\n  * @notice The total supply of a product\r\n  * @param _productId - the product id\r\n  */\r\n  function totalSupplyOf(uint256 _productId) public view returns (uint256) {\r\n    return products[_productId].supply;\r\n  }\r\n\r\n  /**\r\n  * @notice The total sold of a product\r\n  * @param _productId - the product id\r\n  */\r\n  function totalSold(uint256 _productId) public view returns (uint256) {\r\n    return products[_productId].sold;\r\n  }\r\n\r\n  /**\r\n  * @notice The renewal interval of a product in seconds\r\n  * @param _productId - the product id\r\n  */\r\n  function intervalOf(uint256 _productId) public view returns (uint256) {\r\n    return products[_productId].interval;\r\n  }\r\n\r\n  /**\r\n  * @notice Is this product renewable?\r\n  * @param _productId - the product id\r\n  */\r\n  function renewableOf(uint256 _productId) public view returns (bool) {\r\n    return products[_productId].renewable;\r\n  }\r\n\r\n\r\n  /**\r\n  * @notice The product info for a product\r\n  * @param _productId - the product id\r\n  */\r\n  function productInfo(uint256 _productId)\r\n    public\r\n    view\r\n    returns (uint256, uint256, uint256, uint256, bool)\r\n  {\r\n    return (\r\n      priceOf(_productId),\r\n      availableInventoryOf(_productId),\r\n      totalSupplyOf(_productId),\r\n      intervalOf(_productId),\r\n      renewableOf(_productId));\r\n  }\r\n\r\n  /**\r\n  * @notice Get all product ids\r\n  */\r\n  function getAllProductIds() public view returns (uint256[]) {\r\n    return allProductIds;\r\n  }\r\n\r\n  /**\r\n   * @notice returns the total cost to renew a product for a number of cycles\r\n   * @dev If a product is a subscription, the interval defines the period of\r\n   * time, in seconds, users can subscribe for. E.g. 1 month or 1 year.\r\n   * _numCycles is the number of these intervals we want to use in the\r\n   * calculation of the price.\r\n   *\r\n   * We require that the end user send precisely the amount required (instead\r\n   * of dealing with excess refunds). This method is public so that clients can\r\n   * read the exact amount our contract expects to receive.\r\n   *\r\n   * @param _productId - the product we're calculating for\r\n   * @param _numCycles - the number of cycles to calculate for\r\n   */\r\n  function costForProductCycles(uint256 _productId, uint256 _numCycles)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return priceOf(_productId).mul(_numCycles);\r\n  }\r\n\r\n  /**\r\n   * @notice returns if this product is a subscription or not\r\n   * @dev Some products are subscriptions and others are not. An interval of 0\r\n   * means the product is not a subscription\r\n   * @param _productId - the product we're checking\r\n   */\r\n  function isSubscriptionProduct(uint256 _productId) public view returns (bool) {\r\n    return intervalOf(_productId) > 0;\r\n  }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract LicenseOwnership is LicenseInventory, ERC721, ERC165, ERC721Metadata, ERC721Enumerable {\r\n  using SafeMath for uint256;\r\n\r\n  // Total amount of tokens\r\n  uint256 private totalTokens;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) private tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) private tokenApprovals;\r\n\r\n  // Mapping from owner address to operator address to approval\r\n  mapping (address => mapping (address => bool)) private operatorApprovals;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping (address => uint256[]) private ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) private ownedTokensIndex;\r\n\r\n  /*** Constants ***/\r\n  // Configure these for your own deployment\r\n  string public constant NAME = \"Dottabot\";\r\n  string public constant SYMBOL = \"DOTTA\";\r\n  string public tokenMetadataBaseURI = \"https://api.dottabot.com/\";\r\n\r\n  /**\r\n   * @notice token's name\r\n   */\r\n  function name() external pure returns (string) {\r\n    return NAME;\r\n  }\r\n\r\n  /**\r\n   * @notice symbols's name\r\n   */\r\n  function symbol() external pure returns (string) {\r\n    return SYMBOL;\r\n  }\r\n\r\n  function implementsERC721() external pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string infoUrl)\r\n  {\r\n    return Strings.strConcat(\r\n      tokenMetadataBaseURI,\r\n      Strings.uint2str(_tokenId));\r\n  }\r\n\r\n  function supportsInterface(\r\n    bytes4 interfaceID) // solium-disable-line dotta/underscore-function-arguments\r\n    external view returns (bool)\r\n  {\r\n    return\r\n      interfaceID == this.supportsInterface.selector || // ERC165\r\n      interfaceID == 0x5b5e139f || // ERC721Metadata\r\n      interfaceID == 0x6466353c || // ERC-721 on 3/7/2018\r\n      interfaceID == 0x780e9d63; // ERC721Enumerable\r\n  }\r\n\r\n  function setTokenMetadataBaseURI(string _newBaseURI) external onlyCEOOrCOO {\r\n    tokenMetadataBaseURI = _newBaseURI;\r\n  }\r\n\r\n  /**\r\n  * @notice Guarantees msg.sender is owner of the given token\r\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n  */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the total amount of tokens stored by the contract\r\n  * @return uint256 representing the total amount of tokens\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalTokens;\r\n  }\r\n\r\n  /**\r\n  * @notice Enumerate valid NFTs\r\n  * @dev Our Licenses are kept in an array and each new License-token is just\r\n  * the next element in the array. This method is required for ERC721Enumerable\r\n  * which may support more complicated storage schemes. However, in our case the\r\n  * _index is the tokenId\r\n  * @param _index A counter less than `totalSupply()`\r\n  * @return The token identifier for the `_index`th NFT\r\n  */\r\n  function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n    require(_index < totalSupply());\r\n    return _index;\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the balance of the specified address\r\n  * @param _owner address to query the balance of\r\n  * @return uint256 representing the amount owned by the passed address\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokens[_owner].length;\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the list of tokens owned by a given address\r\n  * @param _owner address to query the tokens of\r\n  * @return uint256[] representing the list of tokens owned by the passed address\r\n  */\r\n  function tokensOf(address _owner) public view returns (uint256[]) {\r\n    return ownedTokens[_owner];\r\n  }\r\n\r\n  /**\r\n  * @notice Enumerate NFTs assigned to an owner\r\n  * @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  *  `_owner` is the zero address, representing invalid NFTs.\r\n  * @param _owner An address where we are interested in NFTs owned by them\r\n  * @param _index A counter less than `balanceOf(_owner)`\r\n  * @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n    external\r\n    view\r\n    returns (uint256 _tokenId)\r\n  {\r\n    require(_index < balanceOf(_owner));\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the owner of the specified token ID\r\n  * @param _tokenId uint256 ID of the token to query the owner of\r\n  * @return owner address currently marked as the owner of the given token ID\r\n  */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the approved address to take ownership of a given token ID\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved to take ownership of the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\r\n   * Checks both for specific approval and operator approval\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether transfer by msg.sender is approved for the given token ID or not\r\n   */\r\n  function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {\r\n    return\r\n      ownerOf(_tokenId) == msg.sender ||\r\n      isSpecificallyApprovedFor(msg.sender, _tokenId) ||\r\n      isApprovedForAll(ownerOf(_tokenId), msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether the msg.sender is approved for the given token ID or not\r\n   * @param _asker address of asking for approval\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether the msg.sender is approved for the given token ID or not\r\n   */\r\n  function isSpecificallyApprovedFor(address _asker, uint256 _tokenId) internal view returns (bool) {\r\n    return getApproved(_tokenId) == _asker;\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\r\n  {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n  * @notice Transfers the ownership of a given token ID to another address\r\n  * @param _to address to receive the ownership of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transfer(address _to, uint256 _tokenId)\r\n    external\r\n    whenNotPaused\r\n    onlyOwnerOf(_tokenId)\r\n  {\r\n    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Approves another address to claim for the ownership of the given token ID\r\n  * @param _to address to be approved for the given token ID\r\n  * @param _tokenId uint256 ID of the token to be approved\r\n  */\r\n  function approve(address _to, uint256 _tokenId)\r\n    external\r\n    whenNotPaused\r\n    onlyOwnerOf(_tokenId)\r\n  {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    if (getApproved(_tokenId) != 0 || _to != 0) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      Approval(owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Enable or disable approval for a third party (\"operator\") to manage all your assets\r\n  * @dev Emits the ApprovalForAll event\r\n  * @param _to Address to add to the set of authorized operators.\r\n  * @param _approved True if the operators is approved, false to revoke approval\r\n  */\r\n  function setApprovalForAll(address _to, bool _approved)\r\n    external\r\n    whenNotPaused\r\n  {\r\n    if(_approved) {\r\n      approveAll(_to);\r\n    } else {\r\n      disapproveAll(_to);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Approves another address to claim for the ownership of any tokens owned by this account\r\n  * @param _to address to be approved for the given token ID\r\n  */\r\n  function approveAll(address _to)\r\n    public\r\n    whenNotPaused\r\n  {\r\n    require(_to != msg.sender);\r\n    require(_to != address(0));\r\n    operatorApprovals[msg.sender][_to] = true;\r\n    ApprovalForAll(msg.sender, _to, true);\r\n  }\r\n\r\n  /**\r\n  * @notice Removes approval for another address to claim for the ownership of any\r\n  *  tokens owned by this account.\r\n  * @dev Note that this only removes the operator approval and\r\n  *  does not clear any independent, specific approvals of token transfers to this address\r\n  * @param _to address to be disapproved for the given token ID\r\n  */\r\n  function disapproveAll(address _to)\r\n    public\r\n    whenNotPaused\r\n  {\r\n    require(_to != msg.sender);\r\n    delete operatorApprovals[msg.sender][_to];\r\n    ApprovalForAll(msg.sender, _to, false);\r\n  }\r\n\r\n  /**\r\n  * @notice Claims the ownership of a given token ID\r\n  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\r\n  */\r\n  function takeOwnership(uint256 _tokenId)\r\n   external\r\n   whenNotPaused\r\n  {\r\n    require(isSenderApprovedFor(_tokenId));\r\n    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Transfer a token owned by another address, for which the calling address has\r\n  *  previously been granted transfer approval by the owner.\r\n  * @param _from The address that owns the token\r\n  * @param _to The address that will take ownership of the token. Can be any address, including the caller\r\n  * @param _tokenId The ID of the token to be transferred\r\n  */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    require(isSenderApprovedFor(_tokenId));\r\n    require(ownerOf(_tokenId) == _from);\r\n    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Transfers the ownership of an NFT from one address to another address\r\n  * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  * operator, or the approved address for this NFT. Throws if `_from` is\r\n  * not the current owner. Throws if `_to` is the zero address. Throws if\r\n  * `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  * `onERC721Received` on `_to` and throws if the return value is not\r\n  * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n  * @param _from The current owner of the NFT\r\n  * @param _to The new owner\r\n  * @param _tokenId The NFT to transfer\r\n  * @param _data Additional data with no specified format, sent in call to `_to`\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    require(_to != address(0));\r\n    require(_isValidLicense(_tokenId));\r\n    transferFrom(_from, _to, _tokenId);\r\n    if (_isContract(_to)) {\r\n      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\r\n        _from, _tokenId, _data\r\n      );\r\n      require(tokenReceiverResponse == bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")));\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @notice Transfers the ownership of an NFT from one address to another address\r\n   * @dev This works identically to the other function with an extra data parameter,\r\n   *  except this function just sets data to \"\"\r\n   * @param _from The current owner of the NFT\r\n   * @param _to The new owner\r\n   * @param _tokenId The NFT to transfer\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    whenNotPaused\r\n  {\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n  * @notice Mint token function\r\n  * @param _to The address that will own the minted token\r\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n  */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    _addToken(_to, _tokenId);\r\n    Transfer(0x0, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\r\n  * @param _from address which you want to send tokens from\r\n  * @param _to address which you want to transfer the token to\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function _clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    require(_to != ownerOf(_tokenId));\r\n    require(ownerOf(_tokenId) == _from);\r\n    require(_isValidLicense(_tokenId));\r\n\r\n    _clearApproval(_from, _tokenId);\r\n    _removeToken(_from, _tokenId);\r\n    _addToken(_to, _tokenId);\r\n    Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to clear current approval of a given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function _clearApproval(address _owner, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    tokenApprovals[_tokenId] = 0;\r\n    Approval(_owner, 0, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to add a token ID to the list of a given address\r\n  * @param _to address representing the new owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n  */\r\n  function _addToken(address _to, uint256 _tokenId) private {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    uint256 length = balanceOf(_to);\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n    totalTokens = totalTokens.add(1);\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to remove a token ID from the list of a given address\r\n  * @param _from address representing the previous owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n  */\r\n  function _removeToken(address _from, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _from);\r\n\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = balanceOf(_from).sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    tokenOwner[_tokenId] = 0;\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n    totalTokens = totalTokens.sub(1);\r\n  }\r\n\r\n  function _isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\ncontract LicenseSale is LicenseOwnership {\r\n  AffiliateProgram public affiliateProgram;\r\n\r\n  /**\r\n   * @notice We credit affiliates for renewals that occur within this time of\r\n   * original purchase. E.g. If this is set to 1 year, and someone subscribes to\r\n   * a monthly plan, the affiliate will receive credits for that whole year, as\r\n   * the user renews their plan\r\n   */\r\n  uint256 public renewalsCreditAffiliatesFor = 1 years;\r\n\r\n  /** internal **/\r\n  function _performPurchase(\r\n    uint256 _productId,\r\n    uint256 _numCycles,\r\n    address _assignee,\r\n    uint256 _attributes,\r\n    address _affiliate)\r\n    internal returns (uint)\r\n  {\r\n    _purchaseOneUnitInStock(_productId);\r\n    return _createLicense(\r\n      _productId,\r\n      _numCycles,\r\n      _assignee,\r\n      _attributes,\r\n      _affiliate\r\n      );\r\n  }\r\n\r\n  function _createLicense(\r\n    uint256 _productId,\r\n    uint256 _numCycles,\r\n    address _assignee,\r\n    uint256 _attributes,\r\n    address _affiliate)\r\n    internal\r\n    returns (uint)\r\n  {\r\n    // You cannot create a subscription license with zero cycles\r\n    if(isSubscriptionProduct(_productId)) {\r\n      require(_numCycles != 0);\r\n    }\r\n\r\n    // Non-subscription products have an expiration time of 0, meaning \"no-expiration\"\r\n    uint256 expirationTime = isSubscriptionProduct(_productId) ?\r\n      now.add(intervalOf(_productId).mul(_numCycles)) : // solium-disable-line security/no-block-members\r\n      0;\r\n\r\n    License memory _license = License({\r\n      productId: _productId,\r\n      attributes: _attributes,\r\n      issuedTime: now, // solium-disable-line security/no-block-members\r\n      expirationTime: expirationTime,\r\n      affiliate: _affiliate\r\n    });\r\n\r\n    uint256 newLicenseId = licenses.push(_license) - 1; // solium-disable-line zeppelin/no-arithmetic-operations\r\n    LicenseIssued(\r\n      _assignee,\r\n      msg.sender,\r\n      newLicenseId,\r\n      _license.productId,\r\n      _license.attributes,\r\n      _license.issuedTime,\r\n      _license.expirationTime,\r\n      _license.affiliate);\r\n    _mint(_assignee, newLicenseId);\r\n    return newLicenseId;\r\n  }\r\n\r\n  function _handleAffiliate(\r\n    address _affiliate,\r\n    uint256 _productId,\r\n    uint256 _licenseId,\r\n    uint256 _purchaseAmount)\r\n    internal\r\n  {\r\n    uint256 affiliateCut = affiliateProgram.cutFor(\r\n      _affiliate,\r\n      _productId,\r\n      _licenseId,\r\n      _purchaseAmount);\r\n    if(affiliateCut > 0) {\r\n      require(affiliateCut < _purchaseAmount);\r\n      affiliateProgram.credit.value(affiliateCut)(_affiliate, _licenseId);\r\n    }\r\n  }\r\n\r\n  function _performRenewal(uint256 _tokenId, uint256 _numCycles) internal {\r\n    // You cannot renew a non-expiring license\r\n    // ... but in what scenario can this happen?\r\n    // require(licenses[_tokenId].expirationTime != 0);\r\n    uint256 productId = licenseProductId(_tokenId);\r\n\r\n    // If our expiration is in the future, renewing adds time to that future expiration\r\n    // If our expiration has passed already, then we use `now` as the base.\r\n    uint256 renewalBaseTime = Math.max256(now, licenses[_tokenId].expirationTime);\r\n\r\n    // We assume that the payment has been validated outside of this function\r\n    uint256 newExpirationTime = renewalBaseTime.add(intervalOf(productId).mul(_numCycles));\r\n\r\n    licenses[_tokenId].expirationTime = newExpirationTime;\r\n\r\n    LicenseRenewal(\r\n      ownerOf(_tokenId),\r\n      msg.sender,\r\n      _tokenId,\r\n      productId,\r\n      newExpirationTime\r\n    );\r\n  }\r\n\r\n  function _affiliateProgramIsActive() internal view returns (bool) {\r\n    return\r\n      affiliateProgram != address(0) &&\r\n      affiliateProgram.storeAddress() == address(this) &&\r\n      !affiliateProgram.paused();\r\n  }\r\n\r\n  /** executives **/\r\n  function setAffiliateProgramAddress(address _address) external onlyCEO {\r\n    AffiliateProgram candidateContract = AffiliateProgram(_address);\r\n    require(candidateContract.isAffiliateProgram());\r\n    affiliateProgram = candidateContract;\r\n  }\r\n\r\n  function setRenewalsCreditAffiliatesFor(uint256 _newTime) external onlyCEO {\r\n    renewalsCreditAffiliatesFor = _newTime;\r\n  }\r\n\r\n  function createPromotionalPurchase(\r\n    uint256 _productId,\r\n    uint256 _numCycles,\r\n    address _assignee,\r\n    uint256 _attributes\r\n    )\r\n    external\r\n    onlyCEOOrCOO\r\n    whenNotPaused\r\n    returns (uint256)\r\n  {\r\n    return _performPurchase(\r\n      _productId,\r\n      _numCycles,\r\n      _assignee,\r\n      _attributes,\r\n      address(0));\r\n  }\r\n\r\n  function createPromotionalRenewal(\r\n    uint256 _tokenId,\r\n    uint256 _numCycles\r\n    )\r\n    external\r\n    onlyCEOOrCOO\r\n    whenNotPaused\r\n  {\r\n    uint256 productId = licenseProductId(_tokenId);\r\n    _requireRenewableProduct(productId);\r\n\r\n    return _performRenewal(_tokenId, _numCycles);\r\n  }\r\n\r\n  /** anyone **/\r\n\r\n  /**\r\n  * @notice Makes a purchase of a product.\r\n  * @dev Requires that the value sent is exactly the price of the product\r\n  * @param _productId - the product to purchase\r\n  * @param _numCycles - the number of cycles being purchased. This number should be `1` for non-subscription products and the number of cycles for subscriptions.\r\n  * @param _assignee - the address to assign the purchase to (doesn't have to be msg.sender)\r\n  * @param _affiliate - the address to of the affiliate - use address(0) if none\r\n  */\r\n  function purchase(\r\n    uint256 _productId,\r\n    uint256 _numCycles,\r\n    address _assignee,\r\n    address _affiliate\r\n    )\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    returns (uint256)\r\n  {\r\n    require(_productId != 0);\r\n    require(_numCycles != 0);\r\n    require(_assignee != address(0));\r\n    // msg.value can be zero: free products are supported\r\n\r\n    // Don't bother dealing with excess payments. Ensure the price paid is\r\n    // accurate. No more, no less.\r\n    require(msg.value == costForProductCycles(_productId, _numCycles));\r\n\r\n    // Non-subscription products should send a _numCycle of 1 -- you can't buy a\r\n    // multiple quantity of a non-subscription product with this function\r\n    if(!isSubscriptionProduct(_productId)) {\r\n      require(_numCycles == 1);\r\n    }\r\n\r\n    // this can, of course, be gamed by malicious miners. But it's adequate for our application\r\n    // Feel free to add your own strategies for product attributes\r\n    // solium-disable-next-line security/no-block-members, zeppelin/no-arithmetic-operations\r\n    uint256 attributes = uint256(keccak256(block.blockhash(block.number-1)))^_productId^(uint256(_assignee));\r\n    uint256 licenseId = _performPurchase(\r\n      _productId,\r\n      _numCycles,\r\n      _assignee,\r\n      attributes,\r\n      _affiliate);\r\n\r\n    if(\r\n      priceOf(_productId) > 0 &&\r\n      _affiliate != address(0) &&\r\n      _affiliateProgramIsActive()\r\n    ) {\r\n      _handleAffiliate(\r\n        _affiliate,\r\n        _productId,\r\n        licenseId,\r\n        msg.value);\r\n    }\r\n\r\n    return licenseId;\r\n  }\r\n\r\n  /**\r\n   * @notice Renews a subscription\r\n   */\r\n  function renew(\r\n    uint256 _tokenId,\r\n    uint256 _numCycles\r\n    )\r\n    external\r\n    payable\r\n    whenNotPaused\r\n  {\r\n    require(_numCycles != 0);\r\n    require(ownerOf(_tokenId) != address(0));\r\n\r\n    uint256 productId = licenseProductId(_tokenId);\r\n    _requireRenewableProduct(productId);\r\n\r\n    // No excess payments. Ensure the price paid is exactly accurate. No more,\r\n    // no less.\r\n    uint256 renewalCost = costForProductCycles(productId, _numCycles);\r\n    require(msg.value == renewalCost);\r\n\r\n    _performRenewal(_tokenId, _numCycles);\r\n\r\n    if(\r\n      renewalCost > 0 &&\r\n      licenseAffiliate(_tokenId) != address(0) &&\r\n      _affiliateProgramIsActive() &&\r\n      licenseIssuedTime(_tokenId).add(renewalsCreditAffiliatesFor) > now\r\n    ) {\r\n      _handleAffiliate(\r\n        licenseAffiliate(_tokenId),\r\n        productId,\r\n        _tokenId,\r\n        msg.value);\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract LicenseCore is LicenseSale {\r\n  address public newContractAddress;\r\n\r\n  function LicenseCore() public {\r\n    paused = true;\r\n\r\n    ceoAddress = msg.sender;\r\n    cooAddress = msg.sender;\r\n    cfoAddress = msg.sender;\r\n    withdrawalAddress = msg.sender;\r\n  }\r\n\r\n  function setNewAddress(address _v2Address) external onlyCEO whenPaused {\r\n    newContractAddress = _v2Address;\r\n    ContractUpgrade(_v2Address);\r\n  }\r\n\r\n  function() external {\r\n    assert(false);\r\n  }\r\n\r\n  function unpause() public onlyCEO whenPaused {\r\n    require(newContractAddress == address(0));\r\n    super.unpause();\r\n  }\r\n}\r\n\r\nlibrary Strings {\r\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n      bytes memory _ba = bytes(_a);\r\n      bytes memory _bb = bytes(_b);\r\n      bytes memory _bc = bytes(_c);\r\n      bytes memory _bd = bytes(_d);\r\n      bytes memory _be = bytes(_e);\r\n      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n      bytes memory babcde = bytes(abcde);\r\n      uint k = 0;\r\n      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n      for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n      for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n      for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n      for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n      return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"isSubscriptionProduct\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"approveAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_licenseId\",\"type\":\"uint256\"}],\"name\":\"licenseAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_licenseId\",\"type\":\"uint256\"}],\"name\":\"licenseIssuedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_licenseId\",\"type\":\"uint256\"}],\"name\":\"licenseInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBaseURI\",\"type\":\"string\"}],\"name\":\"setTokenMetadataBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWithdrawalAddress\",\"type\":\"address\"}],\"name\":\"setWithdrawalAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"},{\"name\":\"_numCycles\",\"type\":\"uint256\"}],\"name\":\"costForProductCycles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"},{\"name\":\"_numCycles\",\"type\":\"uint256\"},{\"name\":\"_assignee\",\"type\":\"address\"},{\"name\":\"_attributes\",\"type\":\"uint256\"}],\"name\":\"createPromotionalPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"},{\"name\":\"_newRenewable\",\"type\":\"bool\"}],\"name\":\"setRenewable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"renewableOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"disapproveAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"clearInventory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllProductIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"totalSupplyOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"products\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"available\",\"type\":\"uint256\"},{\"name\":\"supply\",\"type\":\"uint256\"},{\"name\":\"sold\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"renewable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_numCycles\",\"type\":\"uint256\"}],\"name\":\"createPromotionalRenewal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"availableInventoryOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"},{\"name\":\"_initialPrice\",\"type\":\"uint256\"},{\"name\":\"_initialInventoryQuantity\",\"type\":\"uint256\"},{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"createProduct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"totalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_licenseId\",\"type\":\"uint256\"}],\"name\":\"licenseProductId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"},{\"name\":\"_numCycles\",\"type\":\"uint256\"},{\"name\":\"_assignee\",\"type\":\"address\"},{\"name\":\"_affiliate\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"intervalOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affiliateProgram\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMetadataBaseURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"}],\"name\":\"productInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAffiliateProgramAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_numCycles\",\"type\":\"uint256\"}],\"name\":\"renew\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTime\",\"type\":\"uint256\"}],\"name\":\"setRenewalsCreditAffiliatesFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allProductIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_licenseId\",\"type\":\"uint256\"}],\"name\":\"licenseExpirationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"},{\"name\":\"_inventoryAdjustment\",\"type\":\"uint256\"}],\"name\":\"incrementInventory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"renewalsCreditAffiliatesFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_licenseId\",\"type\":\"uint256\"}],\"name\":\"licenseAttributes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_productId\",\"type\":\"uint256\"},{\"name\":\"_inventoryAdjustment\",\"type\":\"uint256\"}],\"name\":\"decrementInventory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"available\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"supply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interval\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"renewable\",\"type\":\"bool\"}],\"name\":\"ProductCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"ProductInventoryAdjusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ProductPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"renewable\",\"type\":\"bool\"}],\"name\":\"ProductRenewableChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"licenseId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"attributes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"issuedTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"LicenseIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"licenseId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"productId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"name\":\"LicenseRenewal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"}]","ContractName":"LicenseCore","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0be6b83cce0244fc84b08c9dfa44e10341734a9c740f5d8b0e30f7d7e1a390fe"}]}