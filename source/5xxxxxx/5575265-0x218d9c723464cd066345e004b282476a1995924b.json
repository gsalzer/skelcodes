{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint a, uint b) internal pure returns(uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint a, uint b) internal pure returns(uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint a, uint b) internal pure returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\n\r\ncontract ERC721 {\r\n    // Required methods\r\n    function approve(address _to, uint _tokenId) public;\r\n    function balanceOf(address _owner) public view returns(uint balance);\r\n    function implementsERC721() public pure returns(bool);\r\n    function ownerOf(uint _tokenId) public view returns(address addr);\r\n    function takeOwnership(uint _tokenId) public;\r\n    function totalSupply() public view returns(uint total);\r\n    function transferFrom(address _from, address _to, uint _tokenId) public;\r\n    function transfer(address _to, uint _tokenId) public;\r\n\r\n    //event Transfer(uint tokenId, address indexed from, address indexed to);\r\n    event Approval(uint tokenId, address indexed owner, address indexed approved);\r\n    \r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint tokenId);\r\n    // function tokenMetadata(uint _tokenId) public view returns (string infoUrl);\r\n}\r\ncontract CryptoCovfefes is ERC721 {\r\n    /*** CONSTANTS ***/\r\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant NAME = \"CryptoCovfefes\";\r\n    string public constant SYMBOL = \"Covfefe Token\";\r\n    \r\n    uint private constant startingPrice = 0.001 ether;\r\n    \r\n    uint private constant PROMO_CREATION_LIMIT = 5000;\r\n    uint private constant CONTRACT_CREATION_LIMIT = 45000;\r\n    uint private constant SaleCooldownTime = 12 hours;\r\n    \r\n    uint private randNonce = 0;\r\n    uint private constant duelVictoryProbability = 51;\r\n    uint private constant duelFee = .001 ether;\r\n    \r\n    uint private addMeaningFee = .001 ether;\r\n\r\n    /*** EVENTS ***/\r\n        /// @dev The Creation event is fired whenever a new Covfefe comes into existence.\r\n    event NewCovfefeCreated(uint tokenId, string term, string meaning, uint generation, address owner);\r\n    \r\n    /// @dev The Meaning added event is fired whenever a Covfefe is defined\r\n    event CovfefeMeaningAdded(uint tokenId, string term, string meaning);\r\n    \r\n    /// @dev The CovfefeSold event is fired whenever a token is bought and sold.\r\n    event CovfefeSold(uint tokenId, string term, string meaning, uint generation, uint sellingpPice, uint currentPrice, address buyer, address seller);\r\n    \r\n     /// @dev The Add Value To Covfefe event is fired whenever value is added to the Covfefe token\r\n    event AddedValueToCovfefe(uint tokenId, string term, string meaning, uint generation, uint currentPrice);\r\n    \r\n     /// @dev The Transfer Covfefe event is fired whenever a Covfefe token is transferred\r\n     event CovfefeTransferred(uint tokenId, address from, address to);\r\n     \r\n    /// @dev The ChallengerWinsCovfefeDuel event is fired whenever the Challenging Covfefe wins a duel\r\n    event ChallengerWinsCovfefeDuel(uint tokenIdChallenger, string termChallenger, uint tokenIdDefender, string termDefender);\r\n    \r\n    /// @dev The DefenderWinsCovfefeDuel event is fired whenever the Challenging Covfefe wins a duel\r\n    event DefenderWinsCovfefeDuel(uint tokenIdDefender, string termDefender, uint tokenIdChallenger, string termChallenger);\r\n\r\n    /*** STORAGE ***/\r\n    /// @dev A mapping from covfefe IDs to the address that owns them. All covfefes have\r\n    ///  some valid owner address.\r\n    mapping(uint => address) public covfefeIndexToOwner;\r\n    \r\n    // @dev A mapping from owner address to count of tokens that address owns.\r\n    //  Used internally inside balanceOf() to resolve ownership count.\r\n    mapping(address => uint) private ownershipTokenCount;\r\n    \r\n    /// @dev A mapping from CovfefeIDs to an address that has been approved to call\r\n    ///  transferFrom(). Each Covfefe can only have one approved address for transfer\r\n    ///  at any time. A zero value means no approval is outstanding.\r\n    mapping(uint => address) public covfefeIndexToApproved;\r\n    \r\n    // @dev A mapping from CovfefeIDs to the price of the token.\r\n    mapping(uint => uint) private covfefeIndexToPrice;\r\n    \r\n    // @dev A mapping from CovfefeIDs to the price of the token.\r\n    mapping(uint => uint) private covfefeIndexToLastPrice;\r\n    \r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public covmanAddress;\r\n    address public covmanagerAddress;\r\n    uint public promoCreatedCount;\r\n    uint public contractCreatedCount;\r\n    \r\n    /*** DATATYPES ***/\r\n    struct Covfefe {\r\n        string term;\r\n        string meaning;\r\n        uint16 generation;\r\n        uint16 winCount;\r\n        uint16 lossCount;\r\n        uint64 saleReadyTime;\r\n    }\r\n    \r\n    Covfefe[] private covfefes;\r\n    /*** ACCESS MODIFIERS ***/\r\n    /// @dev Access modifier for Covman-only functionality\r\n    modifier onlyCovman() {\r\n        require(msg.sender == covmanAddress);\r\n        _;\r\n    }\r\n    /// @dev Access modifier for Covmanager-only functionality\r\n    modifier onlyCovmanager() {\r\n        require(msg.sender == covmanagerAddress);\r\n        _;\r\n    }\r\n    /// Access modifier for contract owner only functionality\r\n    modifier onlyCovDwellers() {\r\n        require(msg.sender == covmanAddress || msg.sender == covmanagerAddress);\r\n        _;\r\n    }\r\n    \r\n    /*** CONSTRUCTOR ***/\r\n    function CryptoCovfefes() public {\r\n        covmanAddress = msg.sender;\r\n        covmanagerAddress = msg.sender;\r\n    }\r\n    /*** PUBLIC FUNCTIONS ***/\r\n    /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\r\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\r\n    ///  clear all approvals.\r\n    /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function approve(address _to, uint _tokenId) public {\r\n        // Caller must own token.\r\n        require(_owns(msg.sender, _tokenId));\r\n        covfefeIndexToApproved[_tokenId] = _to;\r\n        emit Approval(_tokenId, msg.sender, _to);\r\n    }\r\n    \r\n    /// For querying balance of a particular account\r\n    /// @param _owner The address for balance query\r\n    /// @dev Required for ERC-721 compliance.\r\n    function balanceOf(address _owner) public view returns(uint balance) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n    ///////////////////Create Covfefe///////////////////////////\r\n\r\n    /// @dev Creates a new promo Covfefe with the given term, with given _price and assignes it to an address.\r\n    function createPromoCovfefe(address _owner, string _term, string _meaning, uint16 _generation, uint _price) public onlyCovmanager {\r\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\r\n        address covfefeOwner = _owner;\r\n        if (covfefeOwner == address(0)) {\r\n            covfefeOwner = covmanagerAddress;\r\n        }\r\n        if (_price <= 0) {\r\n            _price = startingPrice;\r\n        }\r\n        promoCreatedCount++;\r\n        _createCovfefe(_term, _meaning, _generation, covfefeOwner, _price);\r\n    }\r\n    \r\n    /// @dev Creates a new Covfefe with the given term.\r\n    function createContractCovfefe(string _term, string _meaning, uint16 _generation) public onlyCovmanager {\r\n        require(contractCreatedCount < CONTRACT_CREATION_LIMIT);\r\n        contractCreatedCount++;\r\n        _createCovfefe(_term, _meaning, _generation, address(this), startingPrice);\r\n    }\r\n\r\n    function _triggerSaleCooldown(Covfefe storage _covfefe) internal {\r\n        _covfefe.saleReadyTime = uint64(now + SaleCooldownTime);\r\n    }\r\n\r\n    function _ripeForSale(Covfefe storage _covfefe) internal view returns(bool) {\r\n        return (_covfefe.saleReadyTime <= now);\r\n    }\r\n    /// @notice Returns all the relevant information about a specific covfefe.\r\n    /// @param _tokenId The tokenId of the covfefe of interest.\r\n    function getCovfefe(uint _tokenId) public view returns(string Term, string Meaning, uint Generation, uint ReadyTime, uint WinCount, uint LossCount, uint CurrentPrice, uint LastPrice, address Owner) {\r\n        Covfefe storage covfefe = covfefes[_tokenId];\r\n        Term = covfefe.term;\r\n        Meaning = covfefe.meaning;\r\n        Generation = covfefe.generation;\r\n        ReadyTime = covfefe.saleReadyTime;\r\n        WinCount = covfefe.winCount;\r\n        LossCount = covfefe.lossCount;\r\n        CurrentPrice = covfefeIndexToPrice[_tokenId];\r\n        LastPrice = covfefeIndexToLastPrice[_tokenId];\r\n        Owner = covfefeIndexToOwner[_tokenId];\r\n    }\r\n\r\n    function implementsERC721() public pure returns(bool) {\r\n        return true;\r\n    }\r\n    /// @dev Required for ERC-721 compliance.\r\n    function name() public pure returns(string) {\r\n        return NAME;\r\n    }\r\n    \r\n    /// For querying owner of token\r\n    /// @param _tokenId The tokenID for owner inquiry\r\n    /// @dev Required for ERC-721 compliance.\r\n    \r\n    function ownerOf(uint _tokenId)\r\n    public\r\n    view\r\n    returns(address owner) {\r\n        owner = covfefeIndexToOwner[_tokenId];\r\n        require(owner != address(0));\r\n    }\r\n    modifier onlyOwnerOf(uint _tokenId) {\r\n        require(msg.sender == covfefeIndexToOwner[_tokenId]);\r\n        _;\r\n    }\r\n    \r\n    ///////////////////Add Meaning /////////////////////\r\n    \r\n    function addMeaningToCovfefe(uint _tokenId, string _newMeaning) external payable onlyOwnerOf(_tokenId) {\r\n        \r\n        /// Making sure the transaction is not from another smart contract\r\n        require(!isContract(msg.sender));\r\n        \r\n        /// Making sure the addMeaningFee is included\r\n        require(msg.value == addMeaningFee);\r\n        \r\n        /// Add the new meaning\r\n        covfefes[_tokenId].meaning = _newMeaning;\r\n    \r\n        /// Emit the term meaning added event.\r\n        emit CovfefeMeaningAdded(_tokenId, covfefes[_tokenId].term, _newMeaning);\r\n    }\r\n\r\n    function payout(address _to) public onlyCovDwellers {\r\n        _payout(_to);\r\n    }\r\n    /////////////////Buy Token ////////////////////\r\n    \r\n    // Allows someone to send ether and obtain the token\r\n    function buyCovfefe(uint _tokenId) public payable {\r\n        address oldOwner = covfefeIndexToOwner[_tokenId];\r\n        address newOwner = msg.sender;\r\n        \r\n        // Making sure sale cooldown is not in effect\r\n        Covfefe storage myCovfefe = covfefes[_tokenId];\r\n        require(_ripeForSale(myCovfefe));\r\n        \r\n        // Making sure the transaction is not from another smart contract\r\n        require(!isContract(msg.sender));\r\n        \r\n        covfefeIndexToLastPrice[_tokenId] = covfefeIndexToPrice[_tokenId];\r\n        uint sellingPrice = covfefeIndexToPrice[_tokenId];\r\n        \r\n        // Making sure token owner is not sending to self\r\n        require(oldOwner != newOwner);\r\n        \r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_addressNotNull(newOwner));\r\n        \r\n        // Making sure sent amount is greater than or equal to the sellingPrice\r\n        require(msg.value >= sellingPrice);\r\n        uint payment = uint(SafeMath.div(SafeMath.mul(sellingPrice, 95), 100));\r\n        uint purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\r\n        \r\n        // Update prices\r\n        covfefeIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 115), 95);\r\n        _transfer(oldOwner, newOwner, _tokenId);\r\n        \r\n        ///Trigger Sale cooldown\r\n        _triggerSaleCooldown(myCovfefe);\r\n        \r\n        // Pay previous tokenOwner if owner is not contract\r\n        if (oldOwner != address(this)) {\r\n            oldOwner.transfer(payment); //(1-0.05)\r\n        }\r\n        \r\n        emit CovfefeSold(_tokenId, covfefes[_tokenId].term, covfefes[_tokenId].meaning, covfefes[_tokenId].generation, covfefeIndexToLastPrice[_tokenId], covfefeIndexToPrice[_tokenId], newOwner, oldOwner);\r\n        msg.sender.transfer(purchaseExcess);\r\n    }\r\n\r\n    function priceOf(uint _tokenId) public view returns(uint price) {\r\n        return covfefeIndexToPrice[_tokenId];\r\n    }\r\n\r\n    function lastPriceOf(uint _tokenId) public view returns(uint price) {\r\n        return covfefeIndexToLastPrice[_tokenId];\r\n    }\r\n    \r\n    /// @dev Assigns a new address to act as the Covman. Only available to the current Covman\r\n    /// @param _newCovman The address of the new Covman\r\n    function setCovman(address _newCovman) public onlyCovman {\r\n        require(_newCovman != address(0));\r\n        covmanAddress = _newCovman;\r\n    }\r\n    \r\n    /// @dev Assigns a new address to act as the Covmanager. Only available to the current Covman\r\n    /// @param _newCovmanager The address of the new Covmanager\r\n    function setCovmanager(address _newCovmanager) public onlyCovman {\r\n        require(_newCovmanager != address(0));\r\n        covmanagerAddress = _newCovmanager;\r\n    }\r\n    \r\n    /// @dev Required for ERC-721 compliance.\r\n    function symbol() public pure returns(string) {\r\n        return SYMBOL;\r\n    }\r\n    \r\n    /// @notice Allow pre-approved user to take ownership of a token\r\n    /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function takeOwnership(uint _tokenId) public {\r\n        address newOwner = msg.sender;\r\n        address oldOwner = covfefeIndexToOwner[_tokenId];\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_addressNotNull(newOwner));\r\n        // Making sure transfer is approved\r\n        require(_approved(newOwner, _tokenId));\r\n        _transfer(oldOwner, newOwner, _tokenId);\r\n    }\r\n    \r\n    ///////////////////Add Value to Covfefe/////////////////////////////\r\n    //////////////There's no fee for adding value//////////////////////\r\n\r\n    function addValueToCovfefe(uint _tokenId) external payable onlyOwnerOf(_tokenId) {\r\n        \r\n        // Making sure the transaction is not from another smart contract\r\n        require(!isContract(msg.sender));\r\n        \r\n        //Making sure amount is within the min and max range\r\n        require(msg.value >= 0.001 ether);\r\n        require(msg.value <= 9999.000 ether);\r\n        \r\n        //Keeping a record of lastprice before updating price\r\n        covfefeIndexToLastPrice[_tokenId] = covfefeIndexToPrice[_tokenId];\r\n        \r\n        uint newValue = msg.value;\r\n\r\n        // Update prices\r\n        newValue = SafeMath.div(SafeMath.mul(newValue, 115), 100);\r\n        covfefeIndexToPrice[_tokenId] = SafeMath.add(newValue, covfefeIndexToPrice[_tokenId]);\r\n        \r\n        ///Emit the AddValueToCovfefe event\r\n        emit AddedValueToCovfefe(_tokenId, covfefes[_tokenId].term, covfefes[_tokenId].meaning, covfefes[_tokenId].generation, covfefeIndexToPrice[_tokenId]);\r\n    }\r\n    \r\n    /// @param _owner The owner whose covfefe tokens we are interested in.\r\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n    ///  expensive (it walks the entire Covfefes array looking for covfefes belonging to owner),\r\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n    ///  not contract-to-contract calls.\r\n    \r\n    function getTokensOfOwner(address _owner) external view returns(uint[] ownerTokens) {\r\n        uint tokenCount = balanceOf(_owner);\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint[](0);\r\n        } else {\r\n            uint[] memory result = new uint[](tokenCount);\r\n            uint totalCovfefes = totalSupply();\r\n            uint resultIndex = 0;\r\n            uint covfefeId;\r\n            for (covfefeId = 0; covfefeId <= totalCovfefes; covfefeId++) {\r\n                if (covfefeIndexToOwner[covfefeId] == _owner) {\r\n                    result[resultIndex] = covfefeId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    \r\n    /// For querying totalSupply of token\r\n    /// @dev Required for ERC-721 compliance.\r\n    function totalSupply() public view returns(uint total) {\r\n        return covfefes.length;\r\n    }\r\n    /// Owner initates the transfer of the token to another account\r\n    /// @param _to The address for the token to be transferred to.\r\n    /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transfer(address _to, uint _tokenId) public {\r\n        require(_owns(msg.sender, _tokenId));\r\n        require(_addressNotNull(_to));\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n    /// Third-party initiates transfer of token from address _from to address _to\r\n    /// @param _from The address for the token to be transferred from.\r\n    /// @param _to The address for the token to be transferred to.\r\n    /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transferFrom(address _from, address _to, uint _tokenId) public {\r\n        require(_owns(_from, _tokenId));\r\n        require(_approved(_to, _tokenId));\r\n        require(_addressNotNull(_to));\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n    /*** PRIVATE FUNCTIONS ***/\r\n    /// Safety check on _to address to prevent against an unexpected 0x0 default.\r\n    function _addressNotNull(address _to) private pure returns(bool) {\r\n        return _to != address(0);\r\n    }\r\n    /// For checking approval of transfer for address _to\r\n    function _approved(address _to, uint _tokenId) private view returns(bool) {\r\n        return covfefeIndexToApproved[_tokenId] == _to;\r\n    }\r\n    \r\n    /////////////Covfefe Creation////////////\r\n    \r\n    function _createCovfefe(string _term, string _meaning, uint16 _generation, address _owner, uint _price) private {\r\n        Covfefe memory _covfefe = Covfefe({\r\n            term: _term,\r\n            meaning: _meaning,\r\n            generation: _generation,\r\n            saleReadyTime: uint64(now),\r\n            winCount: 0,\r\n            lossCount: 0\r\n        });\r\n        \r\n        uint newCovfefeId = covfefes.push(_covfefe) - 1;\r\n        // It's probably never going to happen, 4 billion tokens are A LOT, but\r\n        // let's just be 100% sure we never let this happen.\r\n        require(newCovfefeId == uint(uint32(newCovfefeId)));\r\n        \r\n        //Emit the Covfefe creation event\r\n        emit NewCovfefeCreated(newCovfefeId, _term, _meaning, _generation, _owner);\r\n        \r\n        covfefeIndexToPrice[newCovfefeId] = _price;\r\n        \r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(address(0), _owner, newCovfefeId);\r\n    }\r\n    \r\n    /// Check for token ownership\r\n    function _owns(address claimant, uint _tokenId) private view returns(bool) {\r\n        return claimant == covfefeIndexToOwner[_tokenId];\r\n    }\r\n    \r\n    /// For paying out balance on contract\r\n    function _payout(address _to) private {\r\n        if (_to == address(0)) {\r\n            covmanAddress.transfer(address(this).balance);\r\n        } else {\r\n            _to.transfer(address(this).balance);\r\n        }\r\n    }\r\n    \r\n    /////////////////////Transfer//////////////////////\r\n    /// @dev Transfer event as defined in current draft of ERC721. \r\n    ///  ownership is assigned, including births.\r\n    \r\n    /// @dev Assigns ownership of a specific Covfefe to an address.\r\n    function _transfer(address _from, address _to, uint _tokenId) private {\r\n        // Since the number of covfefes is capped to 2^32 we can't overflow this\r\n        ownershipTokenCount[_to]++;\r\n        //transfer ownership\r\n        covfefeIndexToOwner[_tokenId] = _to;\r\n        // When creating new covfefes _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n            // clear any previously approved ownership exchange\r\n            delete covfefeIndexToApproved[_tokenId];\r\n        }\r\n        // Emit the transfer event.\r\n        emit CovfefeTransferred(_tokenId, _from, _to);\r\n    }\r\n    \r\n    ///////////////////Covfefe Duel System//////////////////////\r\n    \r\n    //Simple Randomizer for the covfefe duelling system\r\n    function randMod(uint _modulus) internal returns(uint) {\r\n        randNonce++;\r\n        return uint(keccak256(now, msg.sender, randNonce)) % _modulus;\r\n    }\r\n    \r\n    function duelAnotherCovfefe(uint _tokenId, uint _targetId) external payable onlyOwnerOf(_tokenId) {\r\n        //Load the covfefes from storage\r\n        Covfefe storage myCovfefe = covfefes[_tokenId];\r\n        \r\n        // Making sure the transaction is not from another smart contract\r\n        require(!isContract(msg.sender));\r\n        \r\n        //Making sure the duelling fee is included\r\n        require(msg.value == duelFee);\r\n        \r\n        //\r\n        Covfefe storage enemyCovfefe = covfefes[_targetId];\r\n        uint rand = randMod(100);\r\n        \r\n        if (rand <= duelVictoryProbability) {\r\n            myCovfefe.winCount++;\r\n            enemyCovfefe.lossCount++;\r\n        \r\n        ///Emit the ChallengerWins event\r\n            emit ChallengerWinsCovfefeDuel(_tokenId, covfefes[_tokenId].term, _targetId, covfefes[_targetId].term);\r\n            \r\n        } else {\r\n        \r\n            myCovfefe.lossCount++;\r\n            enemyCovfefe.winCount++;\r\n        \r\n            ///Emit the DefenderWins event\r\n            emit DefenderWinsCovfefeDuel(_targetId, covfefes[_targetId].term, _tokenId, covfefes[_tokenId].term);\r\n        }\r\n    }\r\n    \r\n    ////////////////// Utility //////////////////\r\n    \r\n    function isContract(address addr) internal view returns(bool) {\r\n        uint size;\r\n        assembly {\r\n            size: = extcodesize(addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"promoCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCovman\",\"type\":\"address\"}],\"name\":\"setCovman\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"covfefeIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"covfefeIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"covmanagerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"lastPriceOf\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newMeaning\",\"type\":\"string\"}],\"name\":\"addMeaningToCovfefe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCovmanager\",\"type\":\"address\"}],\"name\":\"setCovmanager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buyCovfefe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_term\",\"type\":\"string\"},{\"name\":\"_meaning\",\"type\":\"string\"},{\"name\":\"_generation\",\"type\":\"uint16\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"createPromoCovfefe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_term\",\"type\":\"string\"},{\"name\":\"_meaning\",\"type\":\"string\"},{\"name\":\"_generation\",\"type\":\"uint16\"}],\"name\":\"createContractCovfefe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"covmanAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCovfefe\",\"outputs\":[{\"name\":\"Term\",\"type\":\"string\"},{\"name\":\"Meaning\",\"type\":\"string\"},{\"name\":\"Generation\",\"type\":\"uint256\"},{\"name\":\"ReadyTime\",\"type\":\"uint256\"},{\"name\":\"WinCount\",\"type\":\"uint256\"},{\"name\":\"LossCount\",\"type\":\"uint256\"},{\"name\":\"CurrentPrice\",\"type\":\"uint256\"},{\"name\":\"LastPrice\",\"type\":\"uint256\"},{\"name\":\"Owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"addValueToCovfefe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_targetId\",\"type\":\"uint256\"}],\"name\":\"duelAnotherCovfefe\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"term\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"meaning\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"generation\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewCovfefeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"term\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"meaning\",\"type\":\"string\"}],\"name\":\"CovfefeMeaningAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"term\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"meaning\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"generation\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellingpPice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"CovfefeSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"term\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"meaning\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"generation\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentPrice\",\"type\":\"uint256\"}],\"name\":\"AddedValueToCovfefe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"CovfefeTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenIdChallenger\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"termChallenger\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenIdDefender\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"termDefender\",\"type\":\"string\"}],\"name\":\"ChallengerWinsCovfefeDuel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenIdDefender\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"termDefender\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenIdChallenger\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"termChallenger\",\"type\":\"string\"}],\"name\":\"DefenderWinsCovfefeDuel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CryptoCovfefes","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8d625c05a5d5bbd6a4b4faffc75163a183a8a927f589a11a4956c8b775fe0d5a"}]}