{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/******* USING Registry **************************\r\n\r\nGives the inherting contract access to:\r\n    .addressOf(bytes32): returns current address mapped to the name.\r\n    [modifier] .fromOwner(): requires the sender is owner.\r\n\r\n*************************************************/\r\n// Returned by .getRegistry()\r\ninterface IRegistry {\r\n    function owner() external view returns (address _addr);\r\n    function addressOf(bytes32 _name) external view returns (address _addr);\r\n}\r\n\r\ncontract UsingRegistry {\r\n    IRegistry private registry;\r\n\r\n    modifier fromOwner(){\r\n        require(msg.sender == getOwner());\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry)\r\n        public\r\n    {\r\n        require(_registry != 0);\r\n        registry = IRegistry(_registry);\r\n    }\r\n\r\n    function addressOf(bytes32 _name)\r\n        internal\r\n        view\r\n        returns(address _addr)\r\n    {\r\n        return registry.addressOf(_name);\r\n    }\r\n\r\n    function getOwner()\r\n        public\r\n        view\r\n        returns (address _addr)\r\n    {\r\n        return registry.owner();\r\n    }\r\n\r\n    function getRegistry()\r\n        public\r\n        view\r\n        returns (IRegistry _addr)\r\n    {\r\n        return registry;\r\n    }\r\n}\r\n\r\n/******* USING ADMIN ***********************\r\n\r\nGives the inherting contract access to:\r\n    .getAdmin(): returns the current address of the admin\r\n    [modifier] .fromAdmin: requires the sender is the admin\r\n\r\n*************************************************/\r\ncontract UsingAdmin is\r\n    UsingRegistry\r\n{\r\n    constructor(address _registry)\r\n        UsingRegistry(_registry)\r\n        public\r\n    {}\r\n\r\n    modifier fromAdmin(){\r\n        require(msg.sender == getAdmin());\r\n        _;\r\n    }\r\n    \r\n    function getAdmin()\r\n        public\r\n        constant\r\n        returns (address _addr)\r\n    {\r\n        return addressOf(\"ADMIN\");\r\n    }\r\n}\r\n\r\n/******* USING MONARCHYFACTORY **************************\r\n\r\nGives the inherting contract access to:\r\n    .getPaf(): returns current IPaf instance\r\n    [modifier] .fromPaf(): requires the sender is current Paf.\r\n\r\n*************************************************/\r\n// Returned by .getMonarchyFactory()\r\ninterface IMonarchyFactory {\r\n    function lastCreatedGame() external view returns (address _game);\r\n    function getCollector() external view returns (address _collector);\r\n}\r\n\r\ncontract UsingMonarchyFactory is\r\n    UsingRegistry\r\n{\r\n    constructor(address _registry)\r\n        UsingRegistry(_registry)\r\n        public\r\n    {}\r\n\r\n    modifier fromMonarchyFactory(){ \r\n        require(msg.sender == address(getMonarchyFactory()));\r\n        _;\r\n    }\r\n\r\n    function getMonarchyFactory()\r\n        public\r\n        view\r\n        returns (IMonarchyFactory)\r\n    {\r\n        return IMonarchyFactory(addressOf(\"MONARCHY_FACTORY\"));\r\n    }\r\n}\r\n\r\n\r\n/******* USING TREASURY **************************\r\n\r\nGives the inherting contract access to:\r\n    .getTreasury(): returns current ITreasury instance\r\n    [modifier] .fromTreasury(): requires the sender is current Treasury\r\n\r\n*************************************************/\r\n// Returned by .getTreasury()\r\ninterface ITreasury {\r\n    function issueDividend() external returns (uint _profits);\r\n    function profitsSendable() external view returns (uint _profits);\r\n}\r\n\r\ncontract UsingTreasury is\r\n    UsingRegistry\r\n{\r\n    constructor(address _registry)\r\n        UsingRegistry(_registry)\r\n        public\r\n    {}\r\n\r\n    modifier fromTreasury(){\r\n        require(msg.sender == address(getTreasury()));\r\n        _;\r\n    }\r\n    \r\n    function getTreasury()\r\n        public\r\n        view\r\n        returns (ITreasury)\r\n    {\r\n        return ITreasury(addressOf(\"TREASURY\"));\r\n    }\r\n}\r\n\r\n\r\n/*\r\n    Exposes the following internal methods:\r\n        - _useFromDailyLimit(uint)\r\n        - _setDailyLimit(uint)\r\n        - getDailyLimit()\r\n        - getDailyLimitUsed()\r\n        - getDailyLimitUnused()\r\n*/\r\ncontract HasDailyLimit {\r\n    // squeeze all vars into one storage slot.\r\n    struct DailyLimitVars {\r\n        uint112 dailyLimit; // Up to 5e15 * 1e18.\r\n        uint112 usedToday;  // Up to 5e15 * 1e18.\r\n        uint32 lastDay;     // Up to the year 11,000,000 AD\r\n    }\r\n    DailyLimitVars private vars;\r\n    uint constant MAX_ALLOWED = 2**112 - 1;\r\n\r\n    constructor(uint _limit) public {\r\n        _setDailyLimit(_limit);\r\n    }\r\n\r\n    // Sets the daily limit.\r\n    function _setDailyLimit(uint _limit) internal {\r\n        require(_limit <= MAX_ALLOWED);\r\n        vars.dailyLimit = uint112(_limit);\r\n    }\r\n\r\n    // Uses the requested amount if its within limit. Or throws.\r\n    // You should use getDailyLimitRemaining() before calling this.\r\n    function _useFromDailyLimit(uint _amount) internal {\r\n        uint _remaining = updateAndGetRemaining();\r\n        require(_amount <= _remaining);\r\n        vars.usedToday += uint112(_amount);\r\n    }\r\n\r\n    // If necessary, resets the day's usage.\r\n    // Then returns the amount remaining for today.\r\n    function updateAndGetRemaining() private returns (uint _amtRemaining) {\r\n        if (today() > vars.lastDay) {\r\n            vars.usedToday = 0;\r\n            vars.lastDay = today();\r\n        }\r\n        uint112 _usedToday = vars.usedToday;\r\n        uint112 _dailyLimit = vars.dailyLimit;\r\n        // This could be negative if _dailyLimit was reduced.\r\n        return uint(_usedToday >= _dailyLimit ? 0 : _dailyLimit - _usedToday);\r\n    }\r\n\r\n    // Returns the current day.\r\n    function today() private view returns (uint32) {\r\n        return uint32(block.timestamp / 1 days);\r\n    }\r\n\r\n\r\n    /////////////////////////////////////////////////////////////////\r\n    ////////////// PUBLIC VIEWS /////////////////////////////////////\r\n    /////////////////////////////////////////////////////////////////\r\n\r\n    function getDailyLimit() public view returns (uint) {\r\n        return uint(vars.dailyLimit);\r\n    }\r\n    function getDailyLimitUsed() public view returns (uint) {\r\n        return uint(today() > vars.lastDay ? 0 : vars.usedToday);\r\n    }\r\n    function getDailyLimitRemaining() public view returns (uint) {\r\n        uint _used = getDailyLimitUsed();\r\n        return uint(_used >= vars.dailyLimit ? 0 : vars.dailyLimit - _used);\r\n    }\r\n}\r\n\r\n/**\r\n    This is a simple class that maintains a doubly linked list of\r\n    address => uint amounts. Address balances can be added to \r\n    or removed from via add() and subtract(). All balances can\r\n    be obtain by calling balances(). If an address has a 0 amount,\r\n    it is removed from the Ledger.\r\n\r\n    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it's safe to\r\n          use to track Ether balances.\r\n\r\n    Public methods:\r\n      - [fromOwner] add()\r\n      - [fromOwner] subtract()\r\n    Public views:\r\n      - total()\r\n      - size()\r\n      - balanceOf()\r\n      - balances()\r\n      - entries() [to manually iterate]\r\n*/\r\ncontract Ledger {\r\n    uint public total;      // Total amount in Ledger\r\n\r\n    struct Entry {          // Doubly linked list tracks amount per address\r\n        uint balance;\r\n        address next;\r\n        address prev;\r\n    }\r\n    mapping (address => Entry) public entries;\r\n\r\n    address public owner;\r\n    modifier fromOwner() { require(msg.sender==owner); _; }\r\n\r\n    // Constructor sets the owner\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** OWNER METHODS ************************/\r\n    /******************************************************/\r\n\r\n    function add(address _address, uint _amt)\r\n        fromOwner\r\n        public\r\n    {\r\n        if (_address == address(0) || _amt == 0) return;\r\n        Entry storage entry = entries[_address];\r\n\r\n        // If new entry, replace first entry with this one.\r\n        if (entry.balance == 0) {\r\n            entry.next = entries[0x0].next;\r\n            entries[entries[0x0].next].prev = _address;\r\n            entries[0x0].next = _address;\r\n        }\r\n        // Update stats.\r\n        total += _amt;\r\n        entry.balance += _amt;\r\n    }\r\n\r\n    function subtract(address _address, uint _amt)\r\n        fromOwner\r\n        public\r\n        returns (uint _amtRemoved)\r\n    {\r\n        if (_address == address(0) || _amt == 0) return;\r\n        Entry storage entry = entries[_address];\r\n\r\n        uint _maxAmt = entry.balance;\r\n        if (_maxAmt == 0) return;\r\n        \r\n        if (_amt >= _maxAmt) {\r\n            // Subtract the max amount, and delete entry.\r\n            total -= _maxAmt;\r\n            entries[entry.prev].next = entry.next;\r\n            entries[entry.next].prev = entry.prev;\r\n            delete entries[_address];\r\n            return _maxAmt;\r\n        } else {\r\n            // Subtract the amount from entry.\r\n            total -= _amt;\r\n            entry.balance -= _amt;\r\n            return _amt;\r\n        }\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** PUBLIC VIEWS *************************/\r\n    /******************************************************/\r\n\r\n    function size()\r\n        public\r\n        view\r\n        returns (uint _size)\r\n    {\r\n        // Loop once to get the total count.\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _curEntry = entries[_curEntry.next];\r\n            _size++;\r\n        }\r\n        return _size;\r\n    }\r\n\r\n    function balanceOf(address _address)\r\n        public\r\n        view\r\n        returns (uint _balance)\r\n    {\r\n        return entries[_address].balance;\r\n    }\r\n\r\n    function balances()\r\n        public\r\n        view\r\n        returns (address[] _addresses, uint[] _balances)\r\n    {\r\n        // Populate names and addresses\r\n        uint _size = size();\r\n        _addresses = new address[](_size);\r\n        _balances = new uint[](_size);\r\n        uint _i = 0;\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _addresses[_i] = _curEntry.next;\r\n            _balances[_i] = entries[_curEntry.next].balance;\r\n            _curEntry = entries[_curEntry.next];\r\n            _i++;\r\n        }\r\n        return (_addresses, _balances);\r\n    }\r\n}\r\n\r\n/**\r\n    This is a simple class that maintains a doubly linked list of\r\n    addresses it has seen. Addresses can be added and removed\r\n    from the set, and a full list of addresses can be obtained.\r\n\r\n    Methods:\r\n     - [fromOwner] .add()\r\n     - [fromOwner] .remove()\r\n    Views:\r\n     - .size()\r\n     - .has()\r\n     - .addresses()\r\n*/\r\ncontract AddressSet {\r\n    \r\n    struct Entry {  // Doubly linked list\r\n        bool exists;\r\n        address next;\r\n        address prev;\r\n    }\r\n    mapping (address => Entry) public entries;\r\n\r\n    address public owner;\r\n    modifier fromOwner() { require(msg.sender==owner); _; }\r\n\r\n    // Constructor sets the owner.\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** OWNER METHODS ************************/\r\n    /******************************************************/\r\n\r\n    function add(address _address)\r\n        fromOwner\r\n        public\r\n        returns (bool _didCreate)\r\n    {\r\n        // Do not allow the adding of HEAD.\r\n        if (_address == address(0)) return;\r\n        Entry storage entry = entries[_address];\r\n        // If already exists, do nothing. Otherwise set it.\r\n        if (entry.exists) return;\r\n        else entry.exists = true;\r\n\r\n        // Replace first entry with this one.\r\n        // Before: HEAD <-> X <-> Y\r\n        // After: HEAD <-> THIS <-> X <-> Y\r\n        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\r\n        Entry storage HEAD = entries[0x0];\r\n        entry.next = HEAD.next;\r\n        entries[HEAD.next].prev = _address;\r\n        HEAD.next = _address;\r\n        return true;\r\n    }\r\n\r\n    function remove(address _address)\r\n        fromOwner\r\n        public\r\n        returns (bool _didExist)\r\n    {\r\n        // Do not allow the removal of HEAD.\r\n        if (_address == address(0)) return;\r\n        Entry storage entry = entries[_address];\r\n        // If it doesn't exist already, there is nothing to do.\r\n        if (!entry.exists) return;\r\n\r\n        // Stitch together next and prev, delete entry.\r\n        // Before: X <-> THIS <-> Y\r\n        // After: X <-> Y\r\n        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\r\n        entries[entry.prev].next = entry.next;\r\n        entries[entry.next].prev = entry.prev;\r\n        delete entries[_address];\r\n        return true;\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** PUBLIC VIEWS *************************/\r\n    /******************************************************/\r\n\r\n    function size()\r\n        public\r\n        view\r\n        returns (uint _size)\r\n    {\r\n        // Loop once to get the total count.\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _curEntry = entries[_curEntry.next];\r\n            _size++;\r\n        }\r\n        return _size;\r\n    }\r\n\r\n    function has(address _address)\r\n        public\r\n        view\r\n        returns (bool _exists)\r\n    {\r\n        return entries[_address].exists;\r\n    }\r\n\r\n    function addresses()\r\n        public\r\n        view\r\n        returns (address[] _addresses)\r\n    {\r\n        // Populate names and addresses\r\n        uint _size = size();\r\n        _addresses = new address[](_size);\r\n        // Iterate forward through all entries until the end.\r\n        uint _i = 0;\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _addresses[_i] = _curEntry.next;\r\n            _curEntry = entries[_curEntry.next];\r\n            _i++;\r\n        }\r\n        return _addresses;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n  A simple class that manages bankroll, and maintains collateral.\r\n  This class only ever sends profits the Treasury. No exceptions.\r\n\r\n  - Anybody can add funding (according to whitelist)\r\n  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\r\n  - Anyone can remove their funding, so long as balance >= collateral.\r\n  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\r\n\r\n  Exposes the following:\r\n    Public Methods\r\n     - addBankroll\r\n     - removeBankroll\r\n     - sendProfits\r\n    Public Views\r\n     - getCollateral\r\n     - profits\r\n     - profitsSent\r\n     - profitsTotal\r\n     - bankroll\r\n     - bankrollAvailable\r\n     - bankrolledBy\r\n     - bankrollerTable\r\n*/\r\ncontract Bankrollable is\r\n    UsingTreasury\r\n{   \r\n    // How much profits have been sent. \r\n    uint public profitsSent;\r\n    // Ledger keeps track of who has bankrolled us, and for how much\r\n    Ledger public ledger;\r\n    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\r\n    uint public bankroll;\r\n    // This is the whitelist of who can call .addBankroll()\r\n    AddressSet public whitelist;\r\n\r\n    modifier fromWhitelistOwner(){\r\n        require(msg.sender == getWhitelistOwner());\r\n        _;\r\n    }\r\n\r\n    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\r\n    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\r\n    event ProfitsSent(uint time, address indexed treasury, uint amount);\r\n    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\r\n    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\r\n\r\n    // Constructor creates the ledger and whitelist, with self as owner.\r\n    constructor(address _registry)\r\n        UsingTreasury(_registry)\r\n        public\r\n    {\r\n        ledger = new Ledger(this);\r\n        whitelist = new AddressSet(this);\r\n    }\r\n\r\n\r\n    /*****************************************************/\r\n    /************** WHITELIST MGMT ***********************/\r\n    /*****************************************************/    \r\n\r\n    function addToWhitelist(address _addr)\r\n        fromWhitelistOwner\r\n        public\r\n    {\r\n        bool _didAdd = whitelist.add(_addr);\r\n        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\r\n    }\r\n\r\n    function removeFromWhitelist(address _addr)\r\n        fromWhitelistOwner\r\n        public\r\n    {\r\n        bool _didRemove = whitelist.remove(_addr);\r\n        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\r\n    }\r\n\r\n    /*****************************************************/\r\n    /************** PUBLIC FUNCTIONS *********************/\r\n    /*****************************************************/\r\n\r\n    // Bankrollable contracts should be payable (to receive revenue)\r\n    function () public payable {}\r\n\r\n    // Increase funding by whatever value is sent\r\n    function addBankroll()\r\n        public\r\n        payable \r\n    {\r\n        require(whitelist.size()==0 || whitelist.has(msg.sender));\r\n        ledger.add(msg.sender, msg.value);\r\n        bankroll = ledger.total();\r\n        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\r\n    }\r\n\r\n    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\r\n    function removeBankroll(uint _amount, string _callbackFn)\r\n        public\r\n        returns (uint _recalled)\r\n    {\r\n        // cap amount at the balance minus collateral, or nothing at all.\r\n        address _bankroller = msg.sender;\r\n        uint _collateral = getCollateral();\r\n        uint _balance = address(this).balance;\r\n        uint _available = _balance > _collateral ? _balance - _collateral : 0;\r\n        if (_amount > _available) _amount = _available;\r\n\r\n        // Try to remove _amount from ledger, get actual _amount removed.\r\n        _amount = ledger.subtract(_bankroller, _amount);\r\n        bankroll = ledger.total();\r\n        if (_amount == 0) return;\r\n\r\n        bytes4 _sig = bytes4(keccak256(_callbackFn));\r\n        require(_bankroller.call.value(_amount)(_sig));\r\n        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\r\n        return _amount;\r\n    }\r\n\r\n    // Send any excess profits to treasury.\r\n    function sendProfits()\r\n        public\r\n        returns (uint _profits)\r\n    {\r\n        int _p = profits();\r\n        if (_p <= 0) return;\r\n        _profits = uint(_p);\r\n        profitsSent += _profits;\r\n        // Send profits to Treasury\r\n        address _tr = getTreasury();\r\n        require(_tr.call.value(_profits)());\r\n        emit ProfitsSent(now, _tr, _profits);\r\n    }\r\n\r\n\r\n    /*****************************************************/\r\n    /************** PUBLIC VIEWS *************************/\r\n    /*****************************************************/\r\n\r\n    // Function must be overridden by inheritors to ensure collateral is kept.\r\n    function getCollateral()\r\n        public\r\n        view\r\n        returns (uint _amount);\r\n\r\n    // Function must be overridden by inheritors to enable whitelist control.\r\n    function getWhitelistOwner()\r\n        public\r\n        view\r\n        returns (address _addr);\r\n\r\n    // Profits are the difference between balance and threshold\r\n    function profits()\r\n        public\r\n        view\r\n        returns (int _profits)\r\n    {\r\n        int _balance = int(address(this).balance);\r\n        int _threshold = int(bankroll + getCollateral());\r\n        return _balance - _threshold;\r\n    }\r\n\r\n    // How profitable this contract is, overall\r\n    function profitsTotal()\r\n        public\r\n        view\r\n        returns (int _profits)\r\n    {\r\n        return int(profitsSent) + profits();\r\n    }\r\n\r\n    // Returns the amount that can currently be bankrolled.\r\n    //   - 0 if balance < collateral\r\n    //   - If profits: full bankroll\r\n    //   - If no profits: remaning bankroll: balance - collateral\r\n    function bankrollAvailable()\r\n        public\r\n        view\r\n        returns (uint _amount)\r\n    {\r\n        uint _balance = address(this).balance;\r\n        uint _bankroll = bankroll;\r\n        uint _collat = getCollateral();\r\n        // Balance is below collateral!\r\n        if (_balance <= _collat) return 0;\r\n        // No profits, but we have a balance over collateral.\r\n        else if (_balance < _collat + _bankroll) return _balance - _collat;\r\n        // Profits. Return only _bankroll\r\n        else return _bankroll;\r\n    }\r\n\r\n    function bankrolledBy(address _addr)\r\n        public\r\n        view\r\n        returns (uint _amount)\r\n    {\r\n        return ledger.balanceOf(_addr);\r\n    }\r\n\r\n    function bankrollerTable()\r\n        public\r\n        view\r\n        returns (address[], uint[])\r\n    {\r\n        return ledger.balances();\r\n    }\r\n}\r\n\r\n// An interface to MonarchyGame instances.\r\ninterface IMonarchyGame {\r\n    function sendPrize(uint _gasLimit) external returns (bool _success, uint _prizeSent);\r\n    function sendFees() external returns (uint _feesSent);\r\n    function prize() external view returns(uint);\r\n    function numOverthrows() external view returns(uint);\r\n    function fees() external view returns (uint _fees);\r\n    function monarch() external view returns (address _addr);\r\n    function isEnded() external view returns (bool _bool);\r\n    function isPaid() external view returns (bool _bool);\r\n}\r\n\r\n/*\r\n\r\n  MonarchyController manages a list of PredefinedGames.\r\n  PredefinedGames' parameters are definable by the Admin.\r\n  These gamess can be started, ended, or refreshed by anyone.\r\n\r\n  Starting games uses the funds in this contract, unless called via\r\n  .startDefinedGameManually(), in which case it uses the funds sent.\r\n\r\n  All revenues of any started games will come back to this contract.\r\n\r\n  Since this contract inherits Bankrollable, it is able to be funded\r\n  via the Registry (or by anyone whitelisted). Profits will go to the\r\n  Treasury, and can be triggered by anyone.\r\n\r\n*/\r\ncontract MonarchyController is\r\n    HasDailyLimit,\r\n    Bankrollable,\r\n    UsingAdmin,\r\n    UsingMonarchyFactory\r\n{\r\n    uint constant public version = 1;\r\n\r\n    // just some accounting/stats stuff to keep track of\r\n    uint public totalFees;\r\n    uint public totalPrizes;\r\n    uint public totalOverthrows;\r\n    IMonarchyGame[] public endedGames;\r\n\r\n    // An admin-controlled index of available games.\r\n    // Note: Index starts at 1, and is limited to 20.\r\n    uint public numDefinedGames;\r\n    mapping (uint => DefinedGame) public definedGames;\r\n    struct DefinedGame {\r\n        IMonarchyGame game;     // address of ongoing game (or 0)\r\n        bool isEnabled;         // if true, can be started\r\n        string summary;         // definable via editDefinedGame\r\n        uint initialPrize;      // definable via editDefinedGame\r\n        uint fee;               // definable via editDefinedGame\r\n        int prizeIncr;          // definable via editDefinedGame\r\n        uint reignBlocks;       // definable via editDefinedGame\r\n        uint initialBlocks;     // definable via editDefinedGame\r\n    }\r\n\r\n    event Created(uint time);\r\n    event DailyLimitChanged(uint time, address indexed owner, uint newValue);\r\n    event Error(uint time, string msg);\r\n    event DefinedGameEdited(uint time, uint index);\r\n    event DefinedGameEnabled(uint time, uint index, bool isEnabled);\r\n    event DefinedGameFailedCreation(uint time, uint index);\r\n    event GameStarted(uint time, uint indexed index, address indexed addr, uint initialPrize);\r\n    event GameEnded(uint time, uint indexed index, address indexed addr, address indexed winner);\r\n    event FeesCollected(uint time, uint amount);\r\n\r\n\r\n    constructor(address _registry) \r\n        HasDailyLimit(10 ether)\r\n        Bankrollable(_registry)\r\n        UsingAdmin(_registry)\r\n        UsingMonarchyFactory(_registry)\r\n        public\r\n    {\r\n        emit Created(now);\r\n    }\r\n\r\n    /*************************************************************/\r\n    /******** OWNER FUNCTIONS ************************************/\r\n    /*************************************************************/\r\n\r\n    function setDailyLimit(uint _amount)\r\n        public\r\n        fromOwner\r\n    {\r\n        _setDailyLimit(_amount);\r\n        emit DailyLimitChanged(now, msg.sender, _amount);\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /******** ADMIN FUNCTIONS ************************************/\r\n    /*************************************************************/\r\n\r\n    // allows admin to edit or add an available game\r\n    function editDefinedGame(\r\n        uint _index,\r\n        string _summary,\r\n        uint _initialPrize,\r\n        uint _fee,\r\n        int _prizeIncr,\r\n        uint _reignBlocks,\r\n        uint _initialBlocks\r\n    )\r\n        public\r\n        fromAdmin\r\n        returns (bool _success)\r\n    {\r\n        if (_index-1 > numDefinedGames || _index > 20) {\r\n            emit Error(now, \"Index out of bounds.\");\r\n            return;\r\n        }\r\n\r\n        if (_index-1 == numDefinedGames) numDefinedGames++;\r\n        definedGames[_index].summary = _summary;\r\n        definedGames[_index].initialPrize = _initialPrize;\r\n        definedGames[_index].fee = _fee;\r\n        definedGames[_index].prizeIncr = _prizeIncr;\r\n        definedGames[_index].reignBlocks = _reignBlocks;\r\n        definedGames[_index].initialBlocks = _initialBlocks;\r\n        emit DefinedGameEdited(now, _index);\r\n        return true;\r\n    }\r\n\r\n    function enableDefinedGame(uint _index, bool _bool)\r\n        public\r\n        fromAdmin\r\n        returns (bool _success)\r\n    {\r\n        if (_index-1 >= numDefinedGames) {\r\n            emit Error(now, \"Index out of bounds.\");\r\n            return;\r\n        }\r\n        definedGames[_index].isEnabled = _bool;\r\n        emit DefinedGameEnabled(now, _index, _bool);\r\n        return true;\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /******* PUBLIC FUNCTIONS ************************************/\r\n    /*************************************************************/\r\n\r\n    function () public payable {\r\n         totalFees += msg.value;\r\n    }\r\n\r\n    // This is called by anyone when a new MonarchyGame should be started.\r\n    // In reality will only be called by TaskManager.\r\n    //\r\n    // Errors if:\r\n    //      - isEnabled is false (or doesnt exist)\r\n    //      - game is already started\r\n    //      - not enough funds\r\n    //      - PAF.getCollector() points to another address\r\n    //      - unable to create game\r\n    function startDefinedGame(uint _index)\r\n        public\r\n        returns (address _game)\r\n    {\r\n        DefinedGame memory dGame = definedGames[_index];\r\n        if (_index-1 >= numDefinedGames) {\r\n            _error(\"Index out of bounds.\");\r\n            return;\r\n        }\r\n        if (dGame.isEnabled == false) {\r\n            _error(\"DefinedGame is not enabled.\");\r\n            return;\r\n        }\r\n        if (dGame.game != IMonarchyGame(0)) {\r\n            _error(\"Game is already started.\");\r\n            return;\r\n        }\r\n        if (address(this).balance < dGame.initialPrize) {\r\n            _error(\"Not enough funds to start this game.\");\r\n            return;\r\n        }\r\n        if (getDailyLimitRemaining() < dGame.initialPrize) {\r\n            _error(\"Starting game would exceed daily limit.\");\r\n            return;\r\n        }\r\n\r\n        // Ensure that if this game is started, revenue comes back to this contract.\r\n        IMonarchyFactory _mf = getMonarchyFactory();\r\n        if (_mf.getCollector() != address(this)){\r\n            _error(\"MonarchyFactory.getCollector() points to a different contract.\");\r\n            return;\r\n        }\r\n\r\n        // Try to create game via factory.\r\n        bool _success = address(_mf).call.value(dGame.initialPrize)(\r\n            bytes4(keccak256(\"createGame(uint256,uint256,int256,uint256,uint256)\")),\r\n            dGame.initialPrize,\r\n            dGame.fee,\r\n            dGame.prizeIncr,\r\n            dGame.reignBlocks,\r\n            dGame.initialBlocks\r\n        );\r\n        if (!_success) {\r\n            emit DefinedGameFailedCreation(now, _index);\r\n            _error(\"MonarchyFactory could not create game (invalid params?)\");\r\n            return;\r\n        }\r\n\r\n        // Get the game, add it to definedGames, and return.\r\n        _useFromDailyLimit(dGame.initialPrize);\r\n        _game = _mf.lastCreatedGame();\r\n        definedGames[_index].game = IMonarchyGame(_game);\r\n        emit GameStarted(now, _index, _game, dGame.initialPrize);\r\n        return _game;\r\n    }\r\n        // Emits an error with a given message\r\n        function _error(string _msg)\r\n            private\r\n        {\r\n            emit Error(now, _msg);\r\n        }\r\n\r\n    function startDefinedGameManually(uint _index)\r\n        public\r\n        payable\r\n        returns (address _game)\r\n    {\r\n        // refund if invalid value sent.\r\n        DefinedGame memory dGame = definedGames[_index];\r\n        if (msg.value != dGame.initialPrize) {\r\n            _error(\"Value sent does not match initialPrize.\");\r\n            require(msg.sender.call.value(msg.value)());\r\n            return;\r\n        }\r\n\r\n        // refund if .startDefinedGame fails\r\n        _game = startDefinedGame(_index);\r\n        if (_game == address(0)) {\r\n            require(msg.sender.call.value(msg.value)());\r\n        }\r\n    }\r\n\r\n    // Looks at all active defined games and:\r\n    //  - tells each game to send fees to collector (us)\r\n    //  - if ended: tries to pay winner, moves to endedGames\r\n    function refreshGames()\r\n        public\r\n        returns (uint _numGamesEnded, uint _feesCollected)\r\n    {\r\n        for (uint _i = 1; _i <= numDefinedGames; _i++) {\r\n            IMonarchyGame _game = definedGames[_i].game;\r\n            if (_game == IMonarchyGame(0)) continue;\r\n\r\n            // redeem the fees\r\n            uint _fees = _game.sendFees();\r\n            _feesCollected += _fees;\r\n\r\n            // attempt to pay winner, update stats, and set game to empty.\r\n            if (_game.isEnded()) {\r\n                // paying the winner can error if the winner uses too much gas\r\n                // in that case, they can call .sendPrize() themselves later.\r\n                if (!_game.isPaid()) _game.sendPrize(2300);\r\n                \r\n                // update stats\r\n                totalPrizes += _game.prize();\r\n                totalOverthrows += _game.numOverthrows();\r\n\r\n                // clear game, move to endedGames, update return\r\n                definedGames[_i].game = IMonarchyGame(0);\r\n                endedGames.push(_game);\r\n                _numGamesEnded++;\r\n\r\n                emit GameEnded(now, _i, address(_game), _game.monarch());\r\n            }\r\n        }\r\n        if (_feesCollected > 0) emit FeesCollected(now, _feesCollected);\r\n        return (_numGamesEnded, _feesCollected);\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /*********** PUBLIC VIEWS ************************************/\r\n    /*************************************************************/\r\n    // IMPLEMENTS: Bankrollable.getCollateral()\r\n    function getCollateral() public view returns (uint) { return 0; }\r\n    function getWhitelistOwner() public view returns (address){ return getAdmin(); }\r\n\r\n    function numEndedGames()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return endedGames.length;\r\n    }\r\n\r\n    function numActiveGames()\r\n        public\r\n        view\r\n        returns (uint _count)\r\n    {\r\n        for (uint _i = 1; _i <= numDefinedGames; _i++) {\r\n            if (definedGames[_i].game != IMonarchyGame(0)) _count++;\r\n        }\r\n    }\r\n\r\n    function getNumEndableGames()\r\n        public\r\n        view\r\n        returns (uint _count)\r\n    {\r\n        for (uint _i = 1; _i <= numDefinedGames; _i++) {\r\n            IMonarchyGame _game = definedGames[_i].game;\r\n            if (_game == IMonarchyGame(0)) continue;\r\n            if (_game.isEnded()) _count++;\r\n        }\r\n        return _count;\r\n    }\r\n\r\n    function getFirstStartableIndex()\r\n        public\r\n        view\r\n        returns (uint _index)\r\n    {\r\n        for (uint _i = 1; _i <= numDefinedGames; _i++) {\r\n            if (getIsStartable(_i)) return _i;\r\n        }\r\n    }\r\n\r\n    // Gets total amount of fees that are redeemable if refreshGames() is called.\r\n    function getAvailableFees()\r\n        public\r\n        view\r\n        returns (uint _feesAvailable)\r\n    {\r\n        for (uint _i = 1; _i <= numDefinedGames; _i++) {\r\n            if (definedGames[_i].game == IMonarchyGame(0)) continue;\r\n            _feesAvailable += definedGames[_i].game.fees();\r\n        }\r\n        return _feesAvailable;\r\n    }\r\n\r\n    function recentlyEndedGames(uint _num)\r\n        public\r\n        view\r\n        returns (address[] _addresses)\r\n    {\r\n        // set _num to Min(_num, _len), initialize the array\r\n        uint _len = endedGames.length;\r\n        if (_num > _len) _num = _len;\r\n        _addresses = new address[](_num);\r\n\r\n        // Loop _num times, adding from end of endedGames.\r\n        uint _i = 1;\r\n        while (_i <= _num) {\r\n            _addresses[_i - 1] = endedGames[_len - _i];\r\n            _i++;\r\n        }\r\n    }\r\n\r\n    /******** Shorthand access to definedGames **************************/\r\n    function getGame(uint _index)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(definedGames[_index].game);\r\n    }\r\n\r\n    function getIsEnabled(uint _index)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return definedGames[_index].isEnabled;\r\n    }\r\n\r\n    function getInitialPrize(uint _index)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return definedGames[_index].initialPrize;\r\n    }\r\n\r\n    function getIsStartable(uint _index)\r\n        public\r\n        view\r\n        returns (bool _isStartable)\r\n    {\r\n        DefinedGame memory dGame = definedGames[_index];\r\n        if (_index >= numDefinedGames) return;\r\n        if (dGame.isEnabled == false) return;\r\n        if (dGame.game != IMonarchyGame(0)) return;\r\n        if (dGame.initialPrize > address(this).balance) return;\r\n        if (dGame.initialPrize > getDailyLimitRemaining()) return;\r\n        return true;\r\n    }\r\n    /******** Shorthand access to definedGames **************************/\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bankrollAvailable\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addBankroll\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumEndableGames\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPrizes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refreshGames\",\"outputs\":[{\"name\":\"_numGamesEnded\",\"type\":\"uint256\"},{\"name\":\"_feesCollected\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profits\",\"outputs\":[{\"name\":\"_profits\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDailyLimitRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getIsEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numEndedGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstStartableIndex\",\"outputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableFees\",\"outputs\":[{\"name\":\"_feesAvailable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDailyLimitUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankrollerTable\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"bankrolledBy\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numDefinedGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ledger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendProfits\",\"outputs\":[{\"name\":\"_profits\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"startDefinedGame\",\"outputs\":[{\"name\":\"_game\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"enableDefinedGame\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_callbackFn\",\"type\":\"string\"}],\"name\":\"removeBankroll\",\"outputs\":[{\"name\":\"_recalled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getInitialPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"startDefinedGameManually\",\"outputs\":[{\"name\":\"_game\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitsTotal\",\"outputs\":[{\"name\":\"_profits\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getIsStartable\",\"outputs\":[{\"name\":\"_isStartable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getGame\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setDailyLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_summary\",\"type\":\"string\"},{\"name\":\"_initialPrize\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_prizeIncr\",\"type\":\"int256\"},{\"name\":\"_reignBlocks\",\"type\":\"uint256\"},{\"name\":\"_initialBlocks\",\"type\":\"uint256\"}],\"name\":\"editDefinedGame\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWhitelistOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"endedGames\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMonarchyFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numActiveGames\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOverthrows\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitsSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"definedGames\",\"outputs\":[{\"name\":\"game\",\"type\":\"address\"},{\"name\":\"isEnabled\",\"type\":\"bool\"},{\"name\":\"summary\",\"type\":\"string\"},{\"name\":\"initialPrize\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"prizeIncr\",\"type\":\"int256\"},{\"name\":\"reignBlocks\",\"type\":\"uint256\"},{\"name\":\"initialBlocks\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"recentlyEndedGames\",\"outputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"DailyLimitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DefinedGameEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"DefinedGameEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DefinedGameFailedCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"initialPrize\",\"type\":\"uint256\"}],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"GameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bankroller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bankroll\",\"type\":\"uint256\"}],\"name\":\"BankrollAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bankroller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bankroll\",\"type\":\"uint256\"}],\"name\":\"BankrollRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"treasury\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitsSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"wlOwner\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"wlOwner\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"}]","ContractName":"MonarchyController","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009c6386aba3907ad0e2177e74684f3ac986070981","Library":"","SwarmSource":"bzzr://d361b00680d188dcc0850e1c5d1a66cd44807fdcd0f9bc82fd23ee8cca4dfca0"}]}