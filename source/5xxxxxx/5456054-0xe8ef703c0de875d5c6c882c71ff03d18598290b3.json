{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\n\r\ncontract ReentrancyHandlingContract{\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract KycContractInterface {\r\n    function isAddressVerified(address _address) public view returns (bool);\r\n}\r\n\r\ncontract MintingContractInterface {\r\n\r\n    address public crowdsaleContractAddress;\r\n    address public tokenContractAddress;\r\n    uint public tokenTotalSupply;\r\n\r\n    event MintMade(address _to, uint _ethAmount, uint _tokensMinted, string _message);\r\n\r\n    function doPresaleMinting(address _destination, uint _tokensAmount) public;\r\n    function doCrowdsaleMinting(address _destination, uint _tokensAmount) public;\r\n    function doTeamMinting(address _destination) public;\r\n    function setTokenContractAddress(address _newAddress) public;\r\n    function setCrowdsaleContractAddress(address _newAddress) public;\r\n    function killContract() public;\r\n}\r\n\r\ncontract ERC20TokenInterface {\r\n    function totalSupply() public constant returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Crowdsale is ReentrancyHandlingContract, Owned {\r\n    \r\n    enum state { pendingStart, crowdsale, crowdsaleEnded }\r\n    struct ContributorData {\r\n        uint contributionAmount;\r\n        uint tokensIssued;\r\n    }\r\n\r\n    state public crowdsaleState = state.pendingStart;\r\n    \r\n    address public multisigAddress = 0x0;\r\n    address public kycAddress = 0x0;\r\n    address public mintingContractAddress = 0x0;\r\n\r\n    uint public startPhaseLength = 720;\r\n    uint public startPhaseMaximumcontribution = 10 * 10**18;\r\n\r\n    uint public crowdsaleStartBlock;\r\n    uint public crowdsaleEndedBlock;\r\n\r\n    mapping(address => ContributorData) public contributorList;\r\n    uint nextContributorIndex;\r\n    mapping(uint => address) contributorIndexes;\r\n\r\n    uint public minCap;\r\n    uint public maxCap;\r\n    uint public ethRaised;\r\n    uint public tokensIssued = 0;\r\n\r\n    event CrowdsaleStarted(uint blockNumber);\r\n    event CrowdsaleEnded(uint blockNumber);\r\n    event ErrorSendingETH(address to, uint amount);\r\n    event MinCapReached(uint blockNumber);\r\n    event MaxCapReached(uint blockNumber);\r\n\r\n    uint nextContributorToClaim;\r\n    mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n    function() noReentrancy payable public {\r\n        require(msg.value >= 100000000000000000);\r\n        require(crowdsaleState != state.crowdsaleEnded);\r\n        require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));\r\n\r\n        bool stateChanged = checkCrowdsaleState();\r\n\r\n        if (crowdsaleState == state.crowdsale) {\r\n            processTransaction(msg.sender, msg.value);\r\n        } else {\r\n            refundTransaction(stateChanged);\r\n        }\r\n    }\r\n\r\n    function checkCrowdsaleState() internal returns (bool) {\r\n        if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {\r\n            crowdsaleState = state.crowdsaleEnded;\r\n            emit CrowdsaleEnded(block.number);\r\n            return true;\r\n        }\r\n\r\n        if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {\r\n            if (crowdsaleState != state.crowdsale) {\r\n                crowdsaleState = state.crowdsale;\r\n                emit CrowdsaleStarted(block.number);\r\n                return true;\r\n            }\r\n        } else {\r\n            if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {\r\n                crowdsaleState = state.crowdsaleEnded;\r\n                emit CrowdsaleEnded(block.number);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function refundTransaction(bool _stateChanged) internal {\r\n        if (_stateChanged) {\r\n            msg.sender.transfer(msg.value);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\r\n        if (tokensIssued <= 20000000 * 10**18) {\r\n            return _eth * 8640;\r\n        } else if(tokensIssued <= 40000000 * 10**18) {\r\n            return _eth * 8480;\r\n        } else if(tokensIssued <= 60000000 * 10**18) {\r\n            return _eth * 8320;\r\n        } else if(tokensIssued <= 80000000 * 10**18) {\r\n            return _eth * 8160;\r\n        } else {\r\n            return _eth * 8000;\r\n        }\r\n    }\r\n\r\n    function calculateTokenToEth(uint _token, uint _blockNumber) constant public returns(uint) {\r\n        uint tempTokenAmount;\r\n        if (tokensIssued <= 20000000 * 10**18) {\r\n            tempTokenAmount = (_token * 1000) / 1008640;\r\n        } else if(tokensIssued <= 40000000 * 10**18) {\r\n            tempTokenAmount = (_token * 1000) / 8480;\r\n        } else if(tokensIssued <= 60000000 * 10**18) {\r\n            tempTokenAmount = (_token * 1000) / 8320;\r\n        } else if(tokensIssued <= 80000000 * 10**18) {\r\n            tempTokenAmount = (_token * 1000) / 8160;\r\n        } else {\r\n            tempTokenAmount = (_token * 1000) / 8000;\r\n        }\r\n        return tempTokenAmount / 1000;\r\n    }\r\n\r\n    function processTransaction(address _contributor, uint _amount) internal {\r\n        uint contributionAmount = 0;\r\n        uint returnAmount = 0;\r\n        uint tokensToGive = 0;\r\n\r\n        if (block.number < crowdsaleStartBlock + startPhaseLength) {\r\n            if((_amount + contributorList[_contributor].contributionAmount) > startPhaseMaximumcontribution) {\r\n                if (contributorList[_contributor].contributionAmount < startPhaseMaximumcontribution) {\r\n                    contributionAmount = startPhaseMaximumcontribution - contributorList[_contributor].contributionAmount;\r\n                    returnAmount = _amount - contributionAmount;\r\n                } else {\r\n                    revert();\r\n                }\r\n            } else {\r\n                contributionAmount = _amount;\r\n            }\r\n        } else {\r\n            contributionAmount = _amount;\r\n        }\r\n        \r\n        tokensToGive = calculateEthToToken(contributionAmount, block.number);\r\n\r\n        if (tokensToGive > (maxCap - tokensIssued)) {\r\n            contributionAmount = calculateTokenToEth(maxCap - tokensIssued, block.number);\r\n            returnAmount = _amount - contributionAmount;\r\n            tokensToGive = maxCap - tokensIssued;\r\n            emit MaxCapReached(block.number);\r\n        }\r\n\r\n        if (contributorList[_contributor].contributionAmount == 0) {\r\n            contributorIndexes[nextContributorIndex] = _contributor;\r\n            nextContributorIndex += 1;\r\n        }\r\n\r\n        contributorList[_contributor].contributionAmount += contributionAmount;\r\n        ethRaised += contributionAmount;\r\n\r\n        if (tokensToGive > 0) {\r\n            MintingContractInterface(mintingContractAddress).doCrowdsaleMinting(_contributor, tokensToGive);\r\n            contributorList[_contributor].tokensIssued += tokensToGive;\r\n            tokensIssued += tokensToGive;\r\n        }\r\n        if (returnAmount != 0) {\r\n            _contributor.transfer(returnAmount);\r\n        } \r\n    }\r\n\r\n    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n\r\n    function withdrawEth() onlyOwner public {\r\n        require(address(this).balance != 0);\r\n        require(tokensIssued >= minCap);\r\n\r\n        multisigAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function claimEthIfFailed() public {\r\n        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\r\n        require(contributorList[msg.sender].contributionAmount > 0);\r\n        require(!hasClaimedEthWhenFail[msg.sender]);\r\n\r\n        uint ethContributed = contributorList[msg.sender].contributionAmount;\r\n        hasClaimedEthWhenFail[msg.sender] = true;\r\n        if (!msg.sender.send(ethContributed)) {\r\n            emit ErrorSendingETH(msg.sender, ethContributed);\r\n        }\r\n    }\r\n\r\n    function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\r\n        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\r\n        address currentParticipantAddress;\r\n        uint contribution;\r\n        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n            currentParticipantAddress = contributorIndexes[nextContributorToClaim];\r\n            if (currentParticipantAddress == 0x0) {\r\n                return;\r\n            }\r\n            if (!hasClaimedEthWhenFail[currentParticipantAddress]) {\r\n                contribution = contributorList[currentParticipantAddress].contributionAmount;\r\n                hasClaimedEthWhenFail[currentParticipantAddress] = true;\r\n                if (!currentParticipantAddress.send(contribution)) {\r\n                    emit ErrorSendingETH(currentParticipantAddress, contribution);\r\n                }\r\n            }\r\n            nextContributorToClaim += 1;\r\n        }\r\n    }\r\n\r\n    function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\r\n        require(address(this).balance != 0);\r\n        require(block.number > crowdsaleEndedBlock);\r\n        require(contributorIndexes[nextContributorToClaim] == 0x0);\r\n        multisigAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function setMultisigAddress(address _newAddress) onlyOwner public {\r\n        multisigAddress = _newAddress;\r\n    }\r\n\r\n    function setMintingContractAddress(address _newAddress) onlyOwner public {\r\n        mintingContractAddress = _newAddress;\r\n    }\r\n\r\n    function setKycAddress(address _newAddress) onlyOwner public {\r\n        kycAddress = _newAddress;\r\n    }\r\n\r\n    function investorCount() constant public returns(uint) {\r\n        return nextContributorIndex;\r\n    }\r\n\r\n    function setCrowdsaleStartBlock(uint _block) onlyOwner public {\r\n        crowdsaleStartBlock = _block;\r\n    }\r\n}\r\n\r\ncontract EligmaCrowdsaleContract is Crowdsale {\r\n  \r\n    function EligmaCrowdsaleContract() public {\r\n\r\n        crowdsaleStartBlock = 5456462;\r\n        crowdsaleEndedBlock = 5584081; \r\n\r\n        minCap = 0 * 10**18;\r\n        maxCap = 161054117 * 10**18;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMultisigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndedBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainingBalanceForManualRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kycAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"calculateEthToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMintingContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setKycAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"uint256\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"calculateTokenToEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorList\",\"outputs\":[{\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"name\":\"tokensIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPhaseLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"setCrowdsaleStartBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPhaseMaximumcontribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ErrorSendingETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MinCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MaxCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"EligmaCrowdsaleContract","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://df6e1e9e6260dee68ae200c11d66d2c2106d71e55c9ef01d082f82a80c3e999f"}]}