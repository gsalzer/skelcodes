{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n// NOTE: BasicToken only has partial ERC20 support\r\ncontract Ico is BasicToken {\r\n  address owner;\r\n  uint256 public teamNum;\r\n  mapping(address => bool) team;\r\n\r\n  // expose these for ERC20 tools\r\n  string public constant name = \"LUNA\";\r\n  string public constant symbol = \"LUNA\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  // Significant digits tokenPrecision\r\n  uint256 private constant tokenPrecision = 10e17;\r\n\r\n  // Tokens frozen supply\r\n  uint256 public tokensFrozen = 0;\r\n\r\n  uint256 public tokenValue = 1 * tokenPrecision;\r\n\r\n  // struct representing a dividends snapshot\r\n  struct DividendSnapshot {\r\n    uint256 totalSupply;\r\n    uint256 dividendsIssued;\r\n    uint256 managementDividends;\r\n  }\r\n  // An array of all the DividendSnapshot so far\r\n  DividendSnapshot[] dividendSnapshots;\r\n\r\n  // Mapping of user to the index of the last dividend that was awarded to zhie\r\n  mapping(address => uint256) lastDividend;\r\n\r\n  // Management fees share express as 100/%: eg. 20% => 100/20 = 5\r\n  uint256 public constant managementFees = 10;\r\n\r\n  // Assets under management in USD\r\n  uint256 public aum = 0;\r\n\r\n  // Amount of tokens in circulation\r\n  uint256 public totalSupply = 0;\r\n\r\n  // drip percent in 100 / percentage\r\n  uint256 public dripRate = 50;\r\n\r\n  // current registred change address\r\n  address public currentSaleAddress;\r\n\r\n  // custom events\r\n  event Freeze(address indexed from, uint256 value);\r\n  event Reconcile(address indexed from, uint256 period, uint256 value);\r\n\r\n  /**\r\n   * Luna constructor\r\n   * Define Luna details and contribution period\r\n   */\r\n  constructor(address[] _team, address[] shareholders, uint256[] shares, uint256 _aum, uint256 _tokensFrozen) public {\r\n    owner = msg.sender;\r\n\r\n    // reset from old contract\r\n    aum = _aum;\r\n    tokensFrozen = _tokensFrozen;\r\n\r\n    uint256 shareholderNum = shareholders.length;\r\n    for (uint256 i = 0; i < shareholderNum; i++) {\r\n      balances[shareholders[i]] = shares[i];\r\n      totalSupply = totalSupply.add(shares[i]);\r\n      emit Transfer(0x0, shareholders[i], shares[i]);\r\n    }\r\n\r\n    // initialize the team mapping with true when part of the team\r\n    teamNum = _team.length;\r\n    for (i = 0; i < teamNum; i++) {\r\n      team[_team[i]] = true;\r\n    }\r\n\r\n    // as a safety measure tempory set the sale address to something else than 0x0\r\n    currentSaleAddress = owner;\r\n  }\r\n\r\n  /**\r\n   * Modifiers\r\n   */\r\n  modifier onlyOwner() {\r\n    require (msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyTeam() {\r\n    require (team[msg.sender] == true);\r\n    _;\r\n  }\r\n\r\n  modifier onlySaleAddress() {\r\n    require (msg.sender == currentSaleAddress);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Internal burn function, only callable by team\r\n   *\r\n   * @param _amount is the amount of tokens to burn.\r\n   */\r\n  function freeze(uint256 _amount) public onlySaleAddress returns (bool) {\r\n    reconcileDividend(msg.sender);\r\n    require(_amount <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n    totalSupply = totalSupply.sub(_amount);\r\n    tokensFrozen = tokensFrozen.add(_amount);\r\n\r\n    aum = aum.sub(tokenValue.mul(_amount).div(tokenPrecision));\r\n\r\n    emit Freeze(msg.sender, _amount);\r\n    emit Transfer(msg.sender, 0x0, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Calculate the divends for the current period given the AUM profit\r\n   *\r\n   * @param totalProfit is the amount of total profit in USD.\r\n   */\r\n  function reportProfit(int256 totalProfit, bool shouldDrip, address saleAddress) public onlyTeam returns (bool) {\r\n    // first we new dividends if this period was profitable\r\n    if (totalProfit > 0) {\r\n      // We only care about 50% of this, as the rest is reinvested right away\r\n      uint256 profit = uint256(totalProfit).mul(tokenPrecision).div(2);\r\n\r\n      // this will throw if there are not enough tokens\r\n      addNewDividends(profit);\r\n    }\r\n\r\n    if (shouldDrip) {\r\n      // then we drip\r\n      drip(saleAddress);\r\n    }\r\n\r\n    // adjust AUM\r\n    if (totalProfit > 0) {\r\n      aum = aum.add(uint256(totalProfit).mul(tokenPrecision));\r\n    } else if (totalProfit < 0) {\r\n      aum = aum.sub(uint256(-totalProfit).mul(tokenPrecision));\r\n    }\r\n\r\n    // register the sale address\r\n    currentSaleAddress = saleAddress;\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  function drip(address saleAddress) internal {\r\n    uint256 dripTokens = tokensFrozen.div(dripRate);\r\n\r\n    tokensFrozen = tokensFrozen.sub(dripTokens);\r\n    totalSupply = totalSupply.add(dripTokens);\r\n    aum = aum.add(tokenValue.mul(dripTokens).div(tokenPrecision));\r\n\r\n    reconcileDividend(saleAddress);\r\n    balances[saleAddress] = balances[saleAddress].add(dripTokens);\r\n    emit Transfer(0x0, saleAddress, dripTokens);\r\n  }\r\n\r\n  /**\r\n   * Calculate the divends for the current period given the dividend\r\n   * amounts (USD * tokenPrecision).\r\n   */\r\n  function addNewDividends(uint256 profit) internal {\r\n    uint256 newAum = aum.add(profit); // 18 sig digits\r\n    tokenValue = newAum.mul(tokenPrecision).div(totalSupply); // 18 sig digits\r\n    uint256 totalDividends = profit.mul(tokenPrecision).div(tokenValue); // 18 sig digits\r\n    uint256 managementDividends = totalDividends.div(managementFees); // 17 sig digits\r\n    uint256 dividendsIssued = totalDividends.sub(managementDividends); // 18 sig digits\r\n\r\n    // make sure we have enough in the frozen fund\r\n    require(tokensFrozen >= totalDividends);\r\n\r\n    dividendSnapshots.push(DividendSnapshot(totalSupply, dividendsIssued, managementDividends));\r\n\r\n    // add the previous amount of given dividends to the totalSupply\r\n    totalSupply = totalSupply.add(totalDividends);\r\n    tokensFrozen = tokensFrozen.sub(totalDividends);\r\n  }\r\n\r\n  /**\r\n   * Withdraw all funds and kill fund smart contract\r\n   */\r\n  function liquidate() public onlyTeam returns (bool) {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /**\r\n   * Manually update AUM, need (for example) when the drip was sold\r\n   * for anything other than NAV.\r\n   */\r\n  function setAUM(uint256 _aum) public onlyTeam returns (bool) {\r\n    aum = _aum;\r\n    return true;\r\n  }\r\n\r\n\r\n  // getter to retrieve divident owed\r\n  function getOwedDividend(address _owner) public view returns (uint256 total, uint256[]) {\r\n    uint256[] memory noDividends = new uint256[](0);\r\n    // And the address' current balance\r\n    uint256 balance = BasicToken.balanceOf(_owner);\r\n    // retrieve index of last dividend this address received\r\n    // NOTE: the default return value of a mapping is 0 in this case\r\n    uint idx = lastDividend[_owner];\r\n    if (idx == dividendSnapshots.length) return (total, noDividends);\r\n    if (balance == 0 && team[_owner] != true) return (total, noDividends);\r\n\r\n    uint256[] memory dividends = new uint256[](dividendSnapshots.length - idx - i);\r\n    uint256 currBalance = balance;\r\n    for (uint i = idx; i < dividendSnapshots.length; i++) {\r\n      // We should be able to remove the .mul(tokenPrecision) and .div(tokenPrecision) and apply them once\r\n      // at the beginning and once at the end, but we need to math it out\r\n      uint256 dividend = currBalance.mul(tokenPrecision).div(dividendSnapshots[i].totalSupply).mul(dividendSnapshots[i].dividendsIssued).div(tokenPrecision);\r\n\r\n      // Add the management dividends in equal parts if the current address is part of the team\r\n      if (team[_owner] == true) {\r\n        dividend = dividend.add(dividendSnapshots[i].managementDividends.div(teamNum));\r\n      }\r\n\r\n      total = total.add(dividend);\r\n\r\n      dividends[i - idx] = dividend;\r\n\r\n      currBalance = currBalance.add(dividend);\r\n    }\r\n\r\n    return (total, dividends);\r\n  }\r\n\r\n  // monkey patches\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    uint256 owedDividend;\r\n    (owedDividend,) = getOwedDividend(_owner);\r\n    return BasicToken.balanceOf(_owner).add(owedDividend);\r\n  }\r\n\r\n\r\n  // Reconcile all outstanding dividends for an address\r\n  // into its balance.\r\n  function reconcileDividend(address _owner) internal {\r\n    uint256 owedDividend;\r\n    uint256[] memory dividends;\r\n    (owedDividend, dividends) = getOwedDividend(_owner);\r\n\r\n    for (uint i = 0; i < dividends.length; i++) {\r\n      if (dividends[i] > 0) {\r\n        emit Reconcile(_owner, lastDividend[_owner] + i, dividends[i]);\r\n        emit Transfer(0x0, _owner, dividends[i]);\r\n      }\r\n    }\r\n\r\n    if(owedDividend > 0) {\r\n      balances[_owner] = balances[_owner].add(owedDividend);\r\n    }\r\n\r\n    // register this user as being owed no further dividends\r\n    lastDividend[_owner] = dividendSnapshots.length;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _amount) public returns (bool) {\r\n    reconcileDividend(msg.sender);\r\n    reconcileDividend(_to);\r\n    return BasicToken.transfer(_to, _amount);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"totalProfit\",\"type\":\"int256\"},{\"name\":\"shouldDrip\",\"type\":\"bool\"},{\"name\":\"saleAddress\",\"type\":\"address\"}],\"name\":\"reportProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"liquidate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managementFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_aum\",\"type\":\"uint256\"}],\"name\":\"setAUM\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dripRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwedDividend\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_team\",\"type\":\"address[]\"},{\"name\":\"shareholders\",\"type\":\"address[]\"},{\"name\":\"shares\",\"type\":\"uint256[]\"},{\"name\":\"_aum\",\"type\":\"uint256\"},{\"name\":\"_tokensFrozen\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Reconcile\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Ico","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000054000000000000000000000000000000000000000000000000000000000000055d4000000000000000000000000000000000000000000000ad9e35598e1fdba9fdd0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000fe01b3b2e5693eda712104555620742c87d6ca90000000000000000000000000f80f44febc9ee496ad5c8266f1b567148cd00f19000000000000000000000000be2c2fa2347340298783ea69ad03eb4e70c1e970000000000000000000000000ff56d7fdecd8baf89518cb83492ff8257b0f50b2000000000000000000000000000000000000000000000000000000000000001f00000000000000000000000076da2c4829eb93c07258b807fecfd9b80ca959ae0000000000000000000000006ac95e70ef4b283aa9628c140bcbcd7f0758cd32000000000000000000000000cd7f4bc16ef2490a9b112edb6075703ced11ab3100000000000000000000000031402ccccb57e32ea60599d80d7efff74f8f8a110000000000000000000000007f22cdd93fcf7a32d430bd893fa38b4eef33fe01000000000000000000000000cb2e77703e907d0f95cca6dc3f9ee8f71583c8c8000000000000000000000000e8177833972a3d4767719e16837a82c2739d6a6e000000000000000000000000a381aea77319ad1f3571457a7f152684ddeb0982000000000000000000000000dcb1384ded04322e9c55ef308b9ccb7968c28ebc000000000000000000000000db97db3fd4b84a44c37679d9e21b022c6d46d1c1000000000000000000000000f1990d3a49fea005112c6ce15b8d261a36cc19bb0000000000000000000000002064d1d7275aa8dae69ef47e6c81bed65713edae0000000000000000000000004263f290ec423e9b7da2d58156f1330d4e60249f000000000000000000000000660f57acad59e678ac4c93582146b970dce18c5b000000000000000000000000f3182d981608e7200bd4dfe63c5f22ecc2f13d7b00000000000000000000000003d762130fe9f42e6eb9819abfd8464bbe5b7664000000000000000000000000b59a3a1d259ebc10643ce368d72e9655283ce3680000000000000000000000002e2c40d6def343cb7205a754048b5db80e300c00000000000000000000000000efaa49e4d24edf372f182c7362f98012c0c174c900000000000000000000000096c767f762d6ed950103d2309d7666f49b321ac90000000000000000000000004b4df070ba3ed7b01f3b785b103ad597d0609eb60000000000000000000000006cb5182e9a81df5ce4ab453c772c75ff2367f62f0000000000000000000000006f440b00d1eaa01914d24ff5e95905918b328f7e000000000000000000000000fef1dabb746b217c22144fbc129108655158e3bf000000000000000000000000f0cfd00be6d595ddc6dafb9de10e5024ff11ec9b0000000000000000000000002d8ebcf7957dbc4dcb4e7377291a1aacfb9db06d00000000000000000000000081b18f1d40120b6c898b15de1b57dd5386861e88000000000000000000000000fe01b3b2e5693eda712104555620742c87d6ca90000000000000000000000000f80f44febc9ee496ad5c8266f1b567148cd00f19000000000000000000000000be2c2fa2347340298783ea69ad03eb4e70c1e970000000000000000000000000ff56d7fdecd8baf89518cb83492ff8257b0f50b2000000000000000000000000000000000000000000000000000000000000001f000000000000000000000000000000000000000000000160eb8a48e5415fd930000000000000000000000000000000000000000000000121475c5d52ff072f580000000000000000000000000000000000000000000000c081eb4d3aa7c7b649000000000000000000000000000000000000000000000095999f28ea0875e21c000000000000000000000000000000000000000000000089ab454560e776c6a100000000000000000000000000000000000000000000008999dc0664e53993f300000000000000000000000000000000000000000000008999dc0664e53993f300000000000000000000000000000000000000000000008285f43d122b9354160000000000000000000000000000000000000000000000482f76746a7953da5c00000000000000000000000000000000000000000000002aaa15f34ef95c3122000000000000000000000000000000000000000000000018053ec18ca7b28dd200000000000000000000000000000000000000000000000ec2d18ec7893a52ea000000000000000000000000000000000000000000000008bbffa22b23ea3800000000000000000000000000000000000000000000000008bbffa22b23ea3800000000000000000000000000000000000000000000000008bbffa22b23ea3800000000000000000000000000000000000000000000000008bbffa22b23ea3800000000000000000000000000000000000000000000000008414796ae1a6cd000000000000000000000000000000000000000000000000004bf296f28881484000000000000000000000000000000000000000000000000029a7f8d20bf39241a0000000000000000000000000000000000000000000000009b5caa701b81fcb10000000000000000000000000000000000000000000000009b5caa701b81fcb10000000000000000000000000000000000000000000000009a483142d6ee69170000000000000000000000000000000000000000000000009a483142d6ee69170000000000000000000000000000000000000000000000009a483142d6ee69170000000000000000000000000000000000000000000000009a483142d6ee69170000000000000000000000000000000000000000000000009a483142d6ee69170000000000000000000000000000000000000000000000007b6cf43578beb32c000000000000000000000000000000000000000000000004b07802fb93d44125000000000000000000000000000000000000000000000004b07802fb93d44125000000000000000000000000000000000000000000000004b07802fb93d44125000000000000000000000000000000000000000000000004b07802fb93d44125","Library":"","SwarmSource":"bzzr://965b4c0f59ee1e26209898fc5295201b25f5bd33e97c837c70992f58465d0282"}]}