{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\t////////////////////////////////////\r\n\t////// CRYPTO SURPRISE\r\n\t////// https://cryptosurprise.me\r\n\t////////////////////////////////////\r\n\t\r\ncontract CryptoSurprise\r\n{\r\n    using SetLibrary for SetLibrary.Set;\r\n    \r\n    ////////////////////////////////////\r\n    ////// CONSTANTS\r\n    \r\n    uint256 constant public BAG_TRANSFER_FEE = 0.05 ether;\r\n    uint256 constant public BAG_TRANSFER_MINIMUM_AMOUNT_OF_BUYS = 4;\r\n    \r\n    \r\n    ////////////////////////////////////\r\n    ////// STATE VARIABLES\r\n    \r\n    struct BagType\r\n    {\r\n        // Constants\r\n        string name;\r\n        \r\n        uint256 startPrice;\r\n        uint256 priceMultiplierPerBuy; // For example, 2 000 000 means 100% increase. (100% = doubling every buy)\r\n        \r\n        uint256 startCommission; // 0 to 1 000 000, for example 100 000 means 10%\r\n        uint256 commissionIncrementPerBuy;\r\n        uint256 maximumCommission;\r\n        \r\n        uint256 supplyHardCap;\r\n        \r\n        // Variables\r\n        uint256 currentSupply;\r\n    }\r\n    \r\n    struct Bag\r\n    {\r\n        // Constants\r\n        uint256 bagTypeIndex;\r\n        \r\n        // Variables\r\n        uint256 amountOfBuys;\r\n        address owner;\r\n        uint256 commission; // 0 to 1 000 000, for example 100 000 means 10%\r\n        uint256 price;\r\n        \r\n        uint256 availableTimestamp;\r\n    }\r\n    \r\n    // Variable that remembers the current owner\r\n    address public owner;\r\n    BagType[] public bagTypes;\r\n    Bag[] public bags;\r\n    \r\n    mapping(address => uint256) public addressToTotalEtherSpent;\r\n    mapping(address => uint256) public addressToTotalPurchasesMade;\r\n    mapping(address => SetLibrary.Set) private ownerToBagIndices;\r\n    address[] public allParticipants;\r\n    \r\n    \r\n    ////////////////////////////////////\r\n    ////// PLAYER FUNCTIONS\r\n    \r\n    function buyBag(uint256 _bagIndex) external payable\r\n    {\r\n        // Make sure that the bag exists\r\n        require(_bagIndex < bags.length);\r\n        \r\n        // Reference the bag data and bag type data\r\n        Bag storage bag = bags[_bagIndex];\r\n        BagType storage bagType = bagTypes[bag.bagTypeIndex];\r\n        \r\n        // Make sure the bag is already available\r\n        require(now >= bag.availableTimestamp);\r\n        \r\n        // Make sure the caller payed at least the current price\r\n        require(msg.value >= bag.price);\r\n        uint256 refund = msg.value - bag.price;\r\n        \r\n        // Remember who the previous owner was\r\n        address previousOwner = bag.owner;\r\n        \r\n        // Set the buyer as the new owner\r\n        bag.owner = msg.sender;\r\n        \r\n        // Calculate the previous and next price\r\n        uint256 previousPrice = bag.price * 1000000 / bagType.priceMultiplierPerBuy;\r\n        uint256 nextPrice = bag.price * bagType.priceMultiplierPerBuy / 1000000;\r\n        \r\n        // Calculate how much the previous owner should get:\r\n        uint256 previousOwnerReward;\r\n        \r\n        // If this is the first buy: the full current price\r\n        if (bag.amountOfBuys == 0)\r\n        {\r\n            previousOwnerReward = bag.price;\r\n        }\r\n        \r\n        // otherwise: previous price + the commission\r\n        else\r\n        {\r\n            previousOwnerReward = bag.price * bag.commission / 1000000;\r\n            //previousOwnerReward = previousPrice + previousPrice * bag.commission / 1000000;\r\n        }\r\n        \r\n        // Set the new price of the bag\r\n        bag.price = nextPrice;\r\n        \r\n        // Increment the amountOfBuys counter\r\n        bag.amountOfBuys++;\r\n        \r\n        // If this is NOT the first buy of this bag:\r\n        if (bag.amountOfBuys > 1)\r\n        {\r\n            // Increase the commission up to the maximum\r\n            if (bag.commission < bagType.maximumCommission)\r\n            {\r\n                uint256 newCommission = bag.commission + bagType.commissionIncrementPerBuy;\r\n                \r\n                if (newCommission >= bagType.maximumCommission)\r\n                {\r\n                    bag.commission = bagType.maximumCommission;\r\n                }\r\n                else \r\n                {\r\n                    bag.commission = newCommission;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Record statistics\r\n        if (addressToTotalPurchasesMade[msg.sender] == 0)\r\n        {\r\n            allParticipants.push(msg.sender);\r\n        }\r\n        addressToTotalEtherSpent[msg.sender] += msg.value;\r\n        addressToTotalPurchasesMade[msg.sender]++;\r\n        \r\n        // Transfer the reward to the previous owner. If the previous owner is\r\n        // the CryptoSurprise smart contract itself, we don't need to perform any\r\n        // transfer because the contract already has it.\r\n        if (previousOwner != address(this))\r\n        {\r\n            previousOwner.transfer(previousOwnerReward);\r\n        }\r\n        \r\n        if (refund > 0)\r\n        {\r\n            msg.sender.transfer(refund);\r\n        }\r\n    }\r\n    \r\n    function transferBag(address _newOwner, uint256 _bagIndex) public payable\r\n    {\r\n        // Require payment\r\n        require(msg.value == BAG_TRANSFER_FEE);\r\n        \r\n        // Perform the transfer\r\n        _transferBag(msg.sender, _newOwner, _bagIndex);\r\n    }\r\n    \r\n    \r\n    ////////////////////////////////////\r\n    ////// OWNER FUNCTIONS\r\n    \r\n    // Constructor function\r\n    function CryptoSurprise() public\r\n    {\r\n        owner = msg.sender;\r\n        \r\n        bagTypes.push(BagType({\r\n            name: \"Blue\",\r\n            \r\n            startPrice: 0.04 ether,\r\n            priceMultiplierPerBuy: 1300000, // 130%\r\n            \r\n            startCommission: 850000, // 85%\r\n            commissionIncrementPerBuy: 5000, // 0.5 %-point\r\n            maximumCommission: 900000, // 90%\r\n            \r\n            supplyHardCap: 600,\r\n            \r\n            currentSupply: 0\r\n        }));\r\n\t\tbagTypes.push(BagType({\r\n            name: \"Red\",\r\n            \r\n            startPrice: 0.03 ether,\r\n            priceMultiplierPerBuy: 1330000, // 133%\r\n            \r\n            startCommission: 870000, // 87%\r\n            commissionIncrementPerBuy: 5000, // 0.5 %-point\r\n            maximumCommission: 920000, // 92%\r\n            \r\n            supplyHardCap: 300,\r\n            \r\n            currentSupply: 0\r\n        }));\r\n\t\tbagTypes.push(BagType({\r\n            name: \"Green\",\r\n            \r\n            startPrice: 0.02 ether,\r\n            priceMultiplierPerBuy: 1360000, // 136%\r\n            \r\n            startCommission: 890000, // 89%\r\n            commissionIncrementPerBuy: 5000, // 0.5 %-point\r\n            maximumCommission: 940000, // 94%\r\n            \r\n            supplyHardCap: 150,\r\n            \r\n            currentSupply: 0\r\n        }));\r\n\t\tbagTypes.push(BagType({\r\n            name: \"Black\",\r\n            \r\n            startPrice: 0.1 ether,\r\n            priceMultiplierPerBuy: 1450000, // 145%\r\n            \r\n            startCommission: 920000, // 92%\r\n            commissionIncrementPerBuy: 10000, // 1 %-point\r\n            maximumCommission: 960000, // 96%\r\n            \r\n            supplyHardCap: 50,\r\n            \r\n            currentSupply: 0\r\n        }));\r\n\t\tbagTypes.push(BagType({\r\n            name: \"Pink\",\r\n            \r\n            startPrice: 1 ether,\r\n            priceMultiplierPerBuy: 1500000, // 150%\r\n            \r\n            startCommission: 940000, // 94%\r\n            commissionIncrementPerBuy: 10000, // 1 %-point\r\n            maximumCommission: 980000, // 98%\r\n            \r\n            supplyHardCap: 10,\r\n            \r\n            currentSupply: 0\r\n        }));\r\n\t\tbagTypes.push(BagType({\r\n            name: \"White\",\r\n            \r\n            startPrice: 10 ether,\r\n            priceMultiplierPerBuy: 1500000, // 150%\r\n            \r\n            startCommission: 970000, // 97%\r\n            commissionIncrementPerBuy: 10000, // 1 %-point\r\n            maximumCommission: 990000, // 99%\r\n            \r\n            supplyHardCap: 1,\r\n            \r\n            currentSupply: 0\r\n        }));\r\n    }\r\n    \r\n    // Function that allows the current owner to transfer ownership\r\n    function transferOwnership(address _newOwner) external\r\n    {\r\n        require(msg.sender == owner);\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    // Only the owner can deposit ETH by sending it directly to the contract\r\n    function () payable external\r\n    {\r\n        require(msg.sender == owner);\r\n    }\r\n    \r\n    // Function that allows the current owner to withdraw any amount\r\n    // of ETH from the contract\r\n    function withdrawEther(uint256 amount) external\r\n    {\r\n        require(msg.sender == owner);\r\n        owner.transfer(amount);\r\n    }\r\n    \r\n    function addBag(uint256 _bagTypeIndex) external\r\n    {\r\n        addBagAndGift(_bagTypeIndex, address(this));\r\n    }\r\n    function addBagDelayed(uint256 _bagTypeIndex, uint256 _delaySeconds) external\r\n    {\r\n        addBagAndGiftAtTime(_bagTypeIndex, address(this), now + _delaySeconds);\r\n    }\r\n    \r\n    function addBagAndGift(uint256 _bagTypeIndex, address _firstOwner) public\r\n    {\r\n        addBagAndGiftAtTime(_bagTypeIndex, _firstOwner, now);\r\n    }\r\n    function addBagAndGiftAtTime(uint256 _bagTypeIndex, address _firstOwner, uint256 _timestamp) public\r\n    {\r\n        require(msg.sender == owner);\r\n        \r\n        require(_bagTypeIndex < bagTypes.length);\r\n        \r\n        BagType storage bagType = bagTypes[_bagTypeIndex];\r\n        \r\n        require(bagType.currentSupply < bagType.supplyHardCap);\r\n        \r\n        bags.push(Bag({\r\n            bagTypeIndex: _bagTypeIndex,\r\n            \r\n            amountOfBuys: 0,\r\n            owner: _firstOwner,\r\n            commission: bagType.startCommission,\r\n            price: bagType.startPrice,\r\n            \r\n            availableTimestamp: _timestamp\r\n        }));\r\n        \r\n        bagType.currentSupply++;\r\n    }\r\n    \r\n\r\n    \r\n    ////////////////////////////////////\r\n    ////// INTERNAL FUNCTIONS\r\n    \r\n    function _transferBag(address _from, address _to, uint256 _bagIndex) internal\r\n    {\r\n        // Make sure that the bag exists\r\n        require(_bagIndex < bags.length);\r\n        \r\n        // Bag may not be transferred before it has been bought x times\r\n        require(bags[_bagIndex].amountOfBuys >= BAG_TRANSFER_MINIMUM_AMOUNT_OF_BUYS);\r\n        \r\n        // Make sure that the sender is the current owner of the bag\r\n        require(bags[_bagIndex].owner == _from);\r\n        \r\n        // Set the new owner\r\n        bags[_bagIndex].owner = _to;\r\n        ownerToBagIndices[_from].remove(_bagIndex);\r\n        ownerToBagIndices[_to].add(_bagIndex);\r\n        \r\n        // Trigger blockchain event\r\n        Transfer(_from, _to, _bagIndex);\r\n    }\r\n    \r\n    \r\n    ////////////////////////////////////\r\n    ////// VIEW FUNCTIONS FOR USER INTERFACE\r\n    \r\n    function amountOfBags() external view returns (uint256)\r\n    {\r\n        return bags.length;\r\n    }\r\n    function amountOfBagTypes() external view returns (uint256)\r\n    {\r\n        return bagTypes.length;\r\n    }\r\n    function amountOfParticipants() external view returns (uint256)\r\n    {\r\n        return allParticipants.length;\r\n    }\r\n    \r\n    \r\n    ////////////////////////////////////\r\n    ////// ERC721 NON FUNGIBLE TOKEN INTERFACE\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    \r\n    function name() external pure returns (string)\r\n    {\r\n        return \"Bags\";\r\n    }\r\n    \r\n    function symbol() external pure returns (string)\r\n    {\r\n        return \"BAG\";\r\n    }\r\n    \r\n    function totalSupply() external view returns (uint256)\r\n    {\r\n        return bags.length;\r\n    }\r\n    \r\n    function balanceOf(address _owner) external view returns (uint256)\r\n    {\r\n        return ownerToBagIndices[_owner].size();\r\n    }\r\n    \r\n    function ownerOf(uint256 _bagIndex) external view returns (address)\r\n    {\r\n        require(_bagIndex < bags.length);\r\n        \r\n        return bags[_bagIndex].owner;\r\n    }\r\n    mapping(address => mapping(address => mapping(uint256 => bool))) private ownerToAddressToBagIndexAllowed;\r\n    function approve(address _to, uint256 _bagIndex) external\r\n    {\r\n        require(_bagIndex < bags.length);\r\n        \r\n        require(msg.sender == bags[_bagIndex].owner);\r\n        \r\n        ownerToAddressToBagIndexAllowed[msg.sender][_to][_bagIndex] = true;\r\n    }\r\n    \r\n    function takeOwnership(uint256 _bagIndex) external\r\n    {\r\n        require(_bagIndex < bags.length);\r\n        \r\n        address previousOwner = bags[_bagIndex].owner;\r\n        \r\n        require(ownerToAddressToBagIndexAllowed[previousOwner][msg.sender][_bagIndex] == true);\r\n        \r\n        ownerToAddressToBagIndexAllowed[previousOwner][msg.sender][_bagIndex] = false;\r\n        \r\n        _transferBag(previousOwner, msg.sender, _bagIndex);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _bagIndex) external\r\n    {\r\n        transferBag(_to, _bagIndex);\r\n    }\r\n    \r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256)\r\n    {\r\n        require(_index < ownerToBagIndices[_owner].size());\r\n        \r\n        return ownerToBagIndices[_owner].values[_index];\r\n    }\r\n}\r\n \r\nlibrary SetLibrary\r\n{\r\n    struct ArrayIndexAndExistsFlag\r\n    {\r\n        uint256 index;\r\n        bool exists;\r\n    }\r\n    struct Set\r\n    {\r\n        mapping(uint256 => ArrayIndexAndExistsFlag) valuesMapping;\r\n        uint256[] values;\r\n    }\r\n    function add(Set storage self, uint256 value) public returns (bool added)\r\n    {\r\n        // If the value is already in the set, we don't need to do anything\r\n        if (self.valuesMapping[value].exists == true) return false;\r\n        \r\n        // Remember that the value is in the set, and remember the value's array index\r\n        self.valuesMapping[value] = ArrayIndexAndExistsFlag({index: self.values.length, exists: true});\r\n        \r\n        // Add the value to the array of unique values\r\n        self.values.push(value);\r\n        \r\n        return true;\r\n    }\r\n    function contains(Set storage self, uint256 value) public view returns (bool contained)\r\n    {\r\n        return self.valuesMapping[value].exists;\r\n    }\r\n    function remove(Set storage self, uint256 value) public returns (bool removed)\r\n    {\r\n        // If the value is not in the set, we don't need to do anything\r\n        if (self.valuesMapping[value].exists == false) return false;\r\n        \r\n        // Remember that the value is not in the set\r\n        self.valuesMapping[value].exists = false;\r\n        \r\n        // Now we need to remove the value from the array. To prevent leaking\r\n        // storage space, we move the last value in the array into the spot that\r\n        // contains the element we're removing.\r\n        if (self.valuesMapping[value].index < self.values.length-1)\r\n        {\r\n            uint256 valueToMove = self.values[self.values.length-1];\r\n            uint256 indexToMoveItTo = self.valuesMapping[value].index;\r\n            self.values[indexToMoveItTo] = valueToMove;\r\n            self.valuesMapping[valueToMove].index = indexToMoveItTo;\r\n        }\r\n        \r\n        // Now we remove the last element from the array, because we just duplicated it.\r\n        // We don't free the storage allocation of the removed last element,\r\n        // because it will most likely be used again by a call to add().\r\n        // De-allocating and re-allocating storage space costs more gas than\r\n        // just keeping it allocated and unused.\r\n        \r\n        // Uncomment this line to save gas if your use case does not call add() after remove():\r\n        // delete self.values[self.values.length-1];\r\n        self.values.length--;\r\n        \r\n        // We do free the storage allocation in the mapping, because it is\r\n        // less likely that the exact same value will added again.\r\n        delete self.valuesMapping[value];\r\n        \r\n        return true;\r\n    }\r\n    function size(Set storage self) public view returns (uint256 amountOfValues)\r\n    {\r\n        return self.values.length;\r\n    }\r\n    \r\n    // Also accept address and bytes32 types, so the user doesn't have to cast.\r\n    function add(Set storage self, address value) public returns (bool added) { return add(self, uint256(value)); }\r\n    function add(Set storage self, bytes32 value) public returns (bool added) { return add(self, uint256(value)); }\r\n    function contains(Set storage self, address value) public view returns (bool contained) { return contains(self, uint256(value)); }\r\n    function contains(Set storage self, bytes32 value) public view returns (bool contained) { return contains(self, uint256(value)); }\r\n    function remove(Set storage self, address value) public returns (bool removed) { return remove(self, uint256(value)); }\r\n    function remove(Set storage self, bytes32 value) public returns (bool removed) { return remove(self, uint256(value)); }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_bagIndex\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bagTypeIndex\",\"type\":\"uint256\"},{\"name\":\"_firstOwner\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"addBagAndGiftAtTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bagIndex\",\"type\":\"uint256\"}],\"name\":\"buyBag\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bagTypeIndex\",\"type\":\"uint256\"}],\"name\":\"addBag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfBagTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bagIndex\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToTotalPurchasesMade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToTotalEtherSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"},{\"name\":\"_bagIndex\",\"type\":\"uint256\"}],\"name\":\"transferBag\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_bagIndex\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bagIndex\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfBags\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bags\",\"outputs\":[{\"name\":\"bagTypeIndex\",\"type\":\"uint256\"},{\"name\":\"amountOfBuys\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"commission\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"availableTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bagTypes\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"startPrice\",\"type\":\"uint256\"},{\"name\":\"priceMultiplierPerBuy\",\"type\":\"uint256\"},{\"name\":\"startCommission\",\"type\":\"uint256\"},{\"name\":\"commissionIncrementPerBuy\",\"type\":\"uint256\"},{\"name\":\"maximumCommission\",\"type\":\"uint256\"},{\"name\":\"supplyHardCap\",\"type\":\"uint256\"},{\"name\":\"currentSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountOfParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bagTypeIndex\",\"type\":\"uint256\"},{\"name\":\"_firstOwner\",\"type\":\"address\"}],\"name\":\"addBagAndGift\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BAG_TRANSFER_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bagTypeIndex\",\"type\":\"uint256\"},{\"name\":\"_delaySeconds\",\"type\":\"uint256\"}],\"name\":\"addBagDelayed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BAG_TRANSFER_MINIMUM_AMOUNT_OF_BUYS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CryptoSurprise","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"SetLibrary:55F44E8b16651a7C5EA1FFCC54749336ffC17E3a","SwarmSource":"bzzr://344941c93384be2385ef37755c9aaa5684448e3fd92bb21795385eee1d2b7c23"}]}