{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n/**\r\n * Crowdsale has a life span during which investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to beneficiary\r\n * as they arrive.\r\n *\r\n * A crowdsale is defined by:\r\n *\toffset (required) - crowdsale start, unix timestamp\r\n *\tlength (required) - crowdsale length in seconds\r\n *  price (required) - token price in wei\r\n *\tsoft cap (optional) - minimum amount of funds required for crowdsale success, can be zero (if not used)\r\n *\thard cap (optional) - maximum amount of funds crowdsale can accept, can be zero (unlimited)\r\n *  quantum (optional) - enables value accumulation effect to reduce value transfer costs, usually is not used (set to zero)\r\n *    if non-zero value passed specifies minimum amount of wei to transfer to beneficiary\r\n *\r\n * This crowdsale doesn't own tokens and doesn't perform any token emission.\r\n * It expects enough tokens to be available on its address:\r\n * these tokens are used for issuing them to investors.\r\n * Token redemption is done in opposite way: tokens accumulate back on contract's address\r\n * Beneficiary is specified by its address.\r\n * This implementation can be used to make several crowdsales with the same token being sold.\r\n */\r\ncontract Crowdsale {\r\n\t/**\r\n\t* Descriptive name of this Crowdsale. There could be multiple crowdsales for same Token.\r\n\t*/\r\n\tstring public name;\r\n\r\n\t// contract creator, owner of the contract\r\n\t// creator is also supplier of tokens\r\n\taddress private creator;\r\n\r\n\t// crowdsale start (unix timestamp)\r\n\tuint public offset;\r\n\r\n\t// crowdsale length in seconds\r\n\tuint public length;\r\n\r\n\t// one token price in wei\r\n\tuint public price;\r\n\r\n\t// crowdsale minimum goal in wei\r\n\tuint public softCap;\r\n\r\n\t// crowdsale maximum goal in wei\r\n\tuint public hardCap;\r\n\r\n\t// minimum amount of value to transfer to beneficiary in automatic mode\r\n\tuint private quantum;\r\n\r\n\t// how much value collected (funds raised)\r\n\tuint public collected;\r\n\r\n\t// how many different addresses made an investment\r\n\tuint public investorsCount;\r\n\r\n\t// how much value refunded (if crowdsale failed)\r\n\tuint public refunded;\r\n\r\n\t// how much tokens issued to investors\r\n\tuint public tokensIssued;\r\n\r\n\t// how much tokens redeemed and refunded (if crowdsale failed)\r\n\tuint public tokensRedeemed;\r\n\r\n\t// how many successful transactions (with tokens being send back) do we have\r\n\tuint public transactions;\r\n\r\n\t// how many refund transactions (in exchange for tokens) made (if crowdsale failed)\r\n\tuint public refunds;\r\n\r\n\t// The token being sold\r\n\tDetailedERC20 private token;\r\n\r\n\t// decimal coefficient (k) enables support for tokens with non-zero decimals\r\n\tuint k;\r\n\r\n\t// address where funds are collected\r\n\taddress public beneficiary;\r\n\r\n\t// investor's mapping, required for token redemption in a failed crowdsale\r\n\t// making this field public allows to extend investor-related functionality in the future\r\n\tmapping(address => uint) public balances;\r\n\r\n\t// events to log\r\n\tevent InvestmentAccepted(address indexed holder, uint tokens, uint value);\r\n\tevent RefundIssued(address indexed holder, uint tokens, uint value);\r\n\r\n\t// a crowdsale is defined by a set of parameters passed here\r\n\t// make sure _end timestamp is in the future in order for crowdsale to be operational\r\n\t// _price must be positive, this is a price of one token in wei\r\n\t// _hardCap must be greater then _softCap or zero, zero _hardCap means unlimited crowdsale\r\n\t// _quantum may be zero, in this case there will be no value accumulation on the contract\r\n\tfunction Crowdsale(\r\n\t\tstring _name,\r\n\t\tuint _offset,\r\n\t\tuint _length,\r\n\t\tuint _price,\r\n\t\tuint _softCap,\r\n\t\tuint _hardCap,\r\n\t\tuint _quantum,\r\n\t\taddress _beneficiary,\r\n\t\taddress _token\r\n\t) public {\r\n\r\n\t\t// validate crowdsale settings (inputs)\r\n\t\t// require(_offset > 0); // we don't really care\r\n\t\trequire(_length > 0);\r\n\t\trequire(now < _offset + _length); // crowdsale must not be already finished\r\n\t\t// softCap can be anything, zero means crowdsale doesn't fail\r\n\t\trequire(_hardCap > _softCap || _hardCap == 0);\r\n\t\t// hardCap must be greater then softCap\r\n\t\t// quantum can be anything, zero means no accumulation\r\n\t\trequire(_price > 0);\r\n\t\trequire(_beneficiary != address(0));\r\n\t\trequire(_token != address(0));\r\n\r\n\t\tname = _name;\r\n\r\n\t\t// setup crowdsale settings\r\n\t\toffset = _offset;\r\n\t\tlength = _length;\r\n\t\tsoftCap = _softCap;\r\n\t\thardCap = _hardCap;\r\n\t\tquantum = _quantum;\r\n\t\tprice = _price;\r\n\t\tcreator = msg.sender;\r\n\r\n\t\t// define beneficiary\r\n\t\tbeneficiary = _beneficiary;\r\n\r\n\t\t// allocate tokens: link and init coefficient\r\n\t\t__allocateTokens(_token);\r\n\t}\r\n\r\n\t// accepts crowdsale investment, requires\r\n\t// crowdsale to be running and not reached its goal\r\n\tfunction invest() public payable {\r\n\t\t// perform validations\r\n\t\tassert(now >= offset && now < offset + length); // crowdsale is active\r\n\t\tassert(collected + price <= hardCap || hardCap == 0); // its still possible to buy at least 1 token\r\n\t\trequire(msg.value >= price); // value sent is enough to buy at least one token\r\n\r\n\t\t// call 'sender' nicely - investor\r\n\t\taddress investor = msg.sender;\r\n\r\n\t\t// how much tokens we must send to investor\r\n\t\tuint tokens = msg.value / price;\r\n\r\n\t\t// how much value we must send to beneficiary\r\n\t\tuint value = tokens * price;\r\n\r\n\t\t// ensure we are not crossing the hardCap\r\n\t\tif (value + collected > hardCap || hardCap == 0) {\r\n\t\t\tvalue = hardCap - collected;\r\n\t\t\ttokens = value / price;\r\n\t\t\tvalue = tokens * price;\r\n\t\t}\r\n\r\n\t\t// update crowdsale status\r\n\t\tcollected += value;\r\n\t\ttokensIssued += tokens;\r\n\r\n\t\t// transfer tokens to investor\r\n\t\t__issueTokens(investor, tokens);\r\n\r\n\t\t// transfer the change to investor\r\n\t\tinvestor.transfer(msg.value - value);\r\n\r\n\t\t// accumulate the value or transfer it to beneficiary\r\n\t\tif (collected >= softCap && this.balance >= quantum) {\r\n\t\t\t// transfer all the value to beneficiary\r\n\t\t\t__beneficiaryTransfer(this.balance);\r\n\t\t}\r\n\r\n\t\t// log an event\r\n\t\tInvestmentAccepted(investor, tokens, value);\r\n\t}\r\n\r\n\t// refunds an investor of failed crowdsale,\r\n\t// requires investor to allow token transfer back\r\n\tfunction refund() public payable {\r\n\t\t// perform validations\r\n\t\tassert(now >= offset + length); // crowdsale ended\r\n\t\tassert(collected < softCap); // crowdsale failed\r\n\r\n\t\t// call 'sender' nicely - investor\r\n\t\taddress investor = msg.sender;\r\n\r\n\t\t// find out how much tokens should be refunded\r\n\t\tuint tokens = __redeemAmount(investor);\r\n\r\n\t\t// calculate refund amount\r\n\t\tuint refundValue = tokens * price;\r\n\r\n\t\t// additional validations\r\n\t\trequire(tokens > 0);\r\n\r\n\t\t// update crowdsale status\r\n\t\trefunded += refundValue;\r\n\t\ttokensRedeemed += tokens;\r\n\t\trefunds++;\r\n\r\n\t\t// transfer the tokens back\r\n\t\t__redeemTokens(investor, tokens);\r\n\r\n\t\t// make a refund\r\n\t\tinvestor.transfer(refundValue + msg.value);\r\n\r\n\t\t// log an event\r\n\t\tRefundIssued(investor, tokens, refundValue);\r\n\t}\r\n\r\n\t// sends all the value to the beneficiary\r\n\tfunction withdraw() public {\r\n\t\t// perform validations\r\n\t\tassert(creator == msg.sender || beneficiary == msg.sender); // only creator or beneficiary can initiate this call\r\n\t\tassert(collected >= softCap); // crowdsale must be successful\r\n\t\tassert(this.balance > 0); // there should be something to transfer\r\n\r\n\t\t// how much to withdraw (entire balance obviously)\r\n\t\tuint value = this.balance;\r\n\r\n\t\t// perform the transfer\r\n\t\t__beneficiaryTransfer(value);\r\n\t}\r\n\r\n\t// performs an investment, refund or withdrawal,\r\n\t// depending on the crowdsale status\r\n\tfunction() public payable {\r\n\t\t// started or finished\r\n\t\trequire(now >= offset);\r\n\r\n\t\tif(now < offset + length) {\r\n\t\t\t// crowdsale is running, invest\r\n\t\t\tinvest();\r\n\t\t}\r\n\t\telse if(collected < softCap) {\r\n\t\t\t// crowdsale failed, try to refund\r\n\t\t\trefund();\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// crowdsale is successful, investments are not accepted anymore\r\n\t\t\t// but maybe poor beneficiary is begging for change...\r\n\t\t\twithdraw();\r\n\t\t}\r\n\t}\r\n\r\n\t// ----------------------- internal section -----------------------\r\n\r\n\t// allocates token source (basically links token)\r\n\tfunction __allocateTokens(address _token) internal {\r\n\t\t// link tokens, tokens are not owned by a crowdsale\r\n\t\t// should be transferred to crowdsale after the deployment\r\n\t\ttoken = DetailedERC20(_token);\r\n\r\n\t\t// obtain decimals and calculate coefficient k\r\n\t\tk = 10 ** uint(token.decimals());\r\n\t}\r\n\r\n\t// transfers tokens to investor, validations are not required\r\n\tfunction __issueTokens(address investor, uint tokens) internal {\r\n\t\t// if this is a new investor update investor count\r\n\t\tif (balances[investor] == 0) {\r\n\t\t\tinvestorsCount++;\r\n\t\t}\r\n\r\n\t\t// for open crowdsales we track investors balances\r\n\t\tbalances[investor] += tokens;\r\n\r\n\t\t// issue tokens, taking into account decimals\r\n\t\ttoken.transferFrom(creator, investor, tokens * k);\r\n\t}\r\n\r\n\t// calculates amount of tokens available to redeem from investor, validations are not required\r\n\tfunction __redeemAmount(address investor) internal view returns (uint amount) {\r\n\t\t// round down allowance taking into account token decimals\r\n\t\tuint allowance = token.allowance(investor, this) / k;\r\n\r\n\t\t// for open crowdsales we check previously tracked investor balance\r\n\t\tuint balance = balances[investor];\r\n\r\n\t\t// return allowance safely by checking also the balance\r\n\t\treturn balance < allowance ? balance : allowance;\r\n\t}\r\n\r\n\t// transfers tokens from investor, validations are not required\r\n\tfunction __redeemTokens(address investor, uint tokens) internal {\r\n\t\t// for open crowdsales we track investors balances\r\n\t\tbalances[investor] -= tokens;\r\n\r\n\t\t// redeem tokens, taking into account decimals coefficient\r\n\t\ttoken.transferFrom(investor, creator, tokens * k);\r\n\t}\r\n\r\n\t// transfers a value to beneficiary, validations are not required\r\n\tfunction __beneficiaryTransfer(uint value) internal {\r\n\t\tbeneficiary.transfer(value);\r\n\t}\r\n\r\n\t// !---------------------- internal section ----------------------!\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRedeemed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"offset\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_offset\",\"type\":\"uint256\"},{\"name\":\"_length\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"name\":\"_quantum\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvestmentAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RefundIssued\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000005b0c2b04000000000000000000000000000000000000000000000000000000000024ea00000000000000000000000000000000000000000000000000000d529ae9e86000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054b40b74c90b4c9c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ad257d9744b3aa5b3270d0e6a9b9ed81855b8270000000000000000000000000cbc7556d2b75e2171e0c4236bf5c6afacdded6db00000000000000000000000000000000000000000000000000000000000000174e616772692043726f776473616c652050686173652031000000000000000000","Library":"","SwarmSource":"bzzr://56f5cb5301da759eb7509de15ba0228ad4004853fa28a5e769493d066a5d6140"}]}