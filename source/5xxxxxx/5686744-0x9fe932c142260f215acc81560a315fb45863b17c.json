{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary DS {\r\n  struct Proof {\r\n    uint level;         // Audit level\r\n    uint insertedBlock; // Audit's block\r\n    bytes32 ipfsHash;   // IPFS dag-cbor proof\r\n    address auditedBy;  // Audited by address\r\n  }\r\n}\r\n\r\ncontract Audit {\r\n  event AttachedEvidence(address indexed auditorAddr, bytes32 indexed codeHash, bytes32 ipfsHash);\r\n  event NewAudit(address indexed auditorAddr, bytes32 indexed codeHash);\r\n\r\n  // Maps auditor address and code's keccak256 to Audit\r\n  mapping (address => mapping (bytes32 => DS.Proof)) public auditedContracts;\r\n  // Maps auditor address to a list of audit code hashes\r\n  mapping (address => bytes32[]) public auditorContracts;\r\n  \r\n  // Returns code audit level, 0 if not present\r\n  function isVerifiedAddress(address _auditorAddr, address _contractAddr) public view returns(uint) {\r\n    bytes32 codeHash = keccak256(codeAt(_contractAddr));\r\n    return auditedContracts[_auditorAddr][codeHash].level;\r\n  }\r\n\r\n  function isVerifiedCode(address _auditorAddr, bytes32 _codeHash) public view returns(uint) {\r\n    return auditedContracts[_auditorAddr][_codeHash].level;\r\n  }\r\n  \r\n  // Add audit information\r\n  function addAudit(bytes32 _codeHash, uint _level, bytes32 _ipfsHash) public {\r\n    address auditor = msg.sender;\r\n    require(auditedContracts[auditor][_codeHash].insertedBlock == 0);\r\n    auditedContracts[auditor][_codeHash] = DS.Proof({ \r\n        level: _level,\r\n        auditedBy: auditor,\r\n        insertedBlock: block.number,\r\n        ipfsHash: _ipfsHash\r\n    });\r\n    auditorContracts[auditor].push(_codeHash);\r\n    emit NewAudit(auditor, _codeHash);\r\n  }\r\n  \r\n  // Add evidence to audited code, only author, if _newLevel is different from original\r\n  // updates the contract's level\r\n  function addEvidence(bytes32 _codeHash, uint _newLevel, bytes32 _ipfsHash) public {\r\n    address auditor = msg.sender;\r\n    require(auditedContracts[auditor][_codeHash].insertedBlock != 0);\r\n    if (auditedContracts[auditor][_codeHash].level != _newLevel)\r\n      auditedContracts[auditor][_codeHash].level = _newLevel;\r\n    emit AttachedEvidence(auditor, _codeHash, _ipfsHash);\r\n  }\r\n\r\n  function codeAt(address _addr) public view returns (bytes code) {\r\n    assembly {\r\n      // retrieve the size of the code, this needs assembly\r\n      let size := extcodesize(_addr)\r\n      // allocate output byte array - this could also be done without assembly\r\n      // by using o_code = new bytes(size)\r\n      code := mload(0x40)\r\n      // new \"memory end\" including padding\r\n      mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n      // store length in memory\r\n      mstore(code, size)\r\n      // actually retrieve the code, this needs assembly\r\n      extcodecopy(_addr, add(code, 0x20), 0, size)\r\n    }\r\n  }\r\n}\r\n\r\ncontract MonteLabsMS {\r\n  // MonteLabs owners\r\n  mapping (address => bool) public owners;\r\n  uint8 constant quorum = 2;\r\n  Audit public auditContract;\r\n\r\n  constructor(address[] _owners, Audit _auditContract) public {\r\n    auditContract = _auditContract;\r\n    require(_owners.length == 3);\r\n    for (uint i = 0; i < _owners.length; ++i) {\r\n      owners[_owners[i]] = true;\r\n    }\r\n  }\r\n\r\n  function addAuditOrEvidence(bool audit, bytes32 _codeHash, uint _level,\r\n                              bytes32 _ipfsHash, uint8 _v, bytes32 _r, \r\n                              bytes32 _s) internal {\r\n    address sender = msg.sender;\r\n    require(owners[sender]);\r\n\r\n    bytes32 prefixedHash = keccak256(\"\\x19Ethereum Signed Message:\\n32\",\r\n                           keccak256(audit, _codeHash, _level, _ipfsHash));\r\n\r\n    address other = ecrecover(prefixedHash, _v, _r, _s);\r\n    // At least 2 different owners\r\n    assert(other != sender);\r\n    if (audit)\r\n      auditContract.addAudit(_codeHash, _level, _ipfsHash);\r\n    else\r\n      auditContract.addEvidence(_codeHash, _level, _ipfsHash);\r\n  }\r\n\r\n  function addAudit(bytes32 _codeHash, uint _level, bytes32 _ipfsHash,\r\n                    uint8 _v, bytes32 _r, bytes32 _s) public {\r\n    addAuditOrEvidence(true, _codeHash, _level, _ipfsHash, _v, _r, _s);\r\n  }\r\n\r\n  function addEvidence(bytes32 _codeHash, uint _version, bytes32 _ipfsHash,\r\n                    uint8 _v, bytes32 _r, bytes32 _s) public {\r\n    addAuditOrEvidence(false, _codeHash, _version, _ipfsHash, _v, _r, _s);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_codeHash\",\"type\":\"bytes32\"},{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"addAudit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_codeHash\",\"type\":\"bytes32\"},{\"name\":\"_version\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"addEvidence\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auditContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_auditContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MonteLabsMS","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000b5124ab26c97be4975b242bfc26de88e22e6d644000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000e190d3746cfd2b3ce1e24c8c9962bbc8ddc7c0000000000000000000000000992ae565869aaa12a53960fb1b1398f0d493e05b0000000000000000000000002303c5092e19a31f409c82589cc738c515a0b509","Library":"","SwarmSource":"bzzr://5a7c86787af494d79c701afb2bbe037a699108329f7f6b90f6bee091f3e10ddf"}]}