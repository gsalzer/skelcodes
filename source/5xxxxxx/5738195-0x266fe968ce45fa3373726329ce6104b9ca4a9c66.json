{"status":"1","message":"OK","result":[{"SourceCode":"contract IERC20Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}   \r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\ncontract SafeMath {\r\n    \r\n    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        require(x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        require(x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) pure internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        require(x <= (MAX_UINT256 / y));\r\n        return x * y;\r\n    }\r\n}\r\n\r\n\r\ncontract LinkedList {\r\n\r\n    struct Element {\r\n        uint previous;\r\n        uint next;\r\n\r\n        address data;\r\n    }\r\n\r\n    uint public size;\r\n    uint public tail;\r\n    uint public head;\r\n    mapping(uint => Element) elements;\r\n    mapping(address => uint) elementLocation;\r\n\r\n    function addItem(address _newItem) public returns (bool) {\r\n        Element memory elem = Element(0, 0, _newItem);\r\n\r\n        if (size == 0) {\r\n            head = 1;\r\n        } else {\r\n            elements[tail].next = tail + 1;\r\n            elem.previous = tail;\r\n        }\r\n\r\n        elementLocation[_newItem] = tail + 1;\r\n        elements[tail + 1] = elem;\r\n        size++;\r\n        tail++;\r\n        return true;\r\n    }\r\n\r\n    function removeItem(address _item) public returns (bool) {\r\n        uint key;\r\n        if (elementLocation[_item] == 0) {\r\n            return false;\r\n        }else {\r\n            key = elementLocation[_item];\r\n        }\r\n\r\n        if (size == 1) {\r\n            tail = 0;\r\n            head = 0;\r\n        }else if (key == head) {\r\n            head = elements[head].next;\r\n        }else if (key == tail) {\r\n            tail = elements[tail].previous;\r\n            elements[tail].next = 0;\r\n        }else {\r\n            elements[key - 1].next = elements[key].next;\r\n            elements[key + 1].previous = elements[key].previous;\r\n        }\r\n\r\n        size--;\r\n        delete elements[key];\r\n        elementLocation[_item] = 0;\r\n        return true;\r\n    }\r\n\r\n    function getAllElements() constant public returns(address[]) {\r\n        address[] memory tempElementArray = new address[](size);\r\n        uint cnt = 0;\r\n        uint currentElemId = head;\r\n        while (cnt < size) {\r\n            tempElementArray[cnt] = elements[currentElemId].data;\r\n            currentElemId = elements[currentElemId].next;\r\n            cnt += 1;\r\n        }\r\n        return tempElementArray;\r\n    }\r\n\r\n    function getElementAt(uint _index) constant public returns (address) {\r\n        return elements[_index].data;\r\n    }\r\n\r\n    function getElementLocation(address _element) constant public returns (uint) {\r\n        return elementLocation[_element];\r\n    }\r\n\r\n    function getNextElement(uint _currElementId) constant public returns (uint) {\r\n        return elements[_currElementId].next;\r\n    }\r\n}\r\n\r\ncontract ICreditBIT{\r\n    function claimGameReward(address _champion, uint _lockedTokenAmount, uint _lockTime) returns (uint error);\r\n}\r\n\r\ncontract CreditGAME is Owned, SafeMath, LinkedList{\r\n    \r\n    mapping(address => bool) approvedGames;\r\n    mapping(address => GameLock) gameLocks;\r\n    mapping(address => bool) public isGameLocked;\r\n    mapping(uint => address) public concludedGames;\r\n    \r\n    uint public amountLocked = 0;\r\n    uint public concludedGameIndex = 0;\r\n    \r\n    struct GameLock{\r\n        uint amount;\r\n        uint lockDuration;\r\n    }\r\n    \r\n    event LockParameters(address gameAddress, uint totalParticipationAmount, uint tokenLockDuration);\r\n    event UnlockParameters(address gameAddress, uint totalParticipationAmount);\r\n    event GameConcluded(address gameAddress);\r\n\r\n    //SET TOKEN ADDRESS BEFORE DEPLOY\r\n    address public tokenAddress = 0xAef38fBFBF932D1AeF3B808Bc8fBd8Cd8E1f8BC5;\r\n    \r\n    /**\r\n     * Set CRB token address here\r\n     * \r\n     **/\r\n    function setTokenAddress(address _tokenAddress) onlyOwner public {\r\n        tokenAddress = _tokenAddress;\r\n    }\r\n\r\n    /**\r\n     * When new game is created it needs to be approved here before it starts.\r\n     * \r\n     **/\r\n    function addApprovedGame(address _gameAddress) onlyOwner public{\r\n        approvedGames[_gameAddress] = true;\r\n        addItem(_gameAddress);\r\n    }\r\n    \r\n    /**\r\n     * Manually remove approved game.\r\n     * \r\n     **/\r\n    function removeApprovedGame(address _gameAddress) onlyOwner public{\r\n        approvedGames[_gameAddress] = false;\r\n        removeItem(_gameAddress);\r\n    }\r\n\r\n    /**\r\n     * Remove failed game.\r\n     * \r\n     **/\r\n    function removeFailedGame() public{\r\n      require(approvedGames[msg.sender] == true);\r\n      removeItem(msg.sender);\r\n      approvedGames[msg.sender] = false;\r\n      concludedGames[concludedGameIndex] = msg.sender; \r\n      concludedGameIndex++;\r\n      emit GameConcluded(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Verify if game is approved\r\n     * \r\n     **/\r\n    function isGameApproved(address _gameAddress) view public returns(bool){\r\n        if(approvedGames[_gameAddress] == true){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Funds must be transfered by calling contract before calling this contract. \r\n     * msg.sender is address of calling contract that must be approved.\r\n     * \r\n     **/\r\n    function createLock(address _winner, uint _totalParticipationAmount, uint _tokenLockDuration) public {\r\n        require(approvedGames[msg.sender] == true);\r\n        require(isGameLocked[msg.sender] == false);\r\n        \r\n        //Create gameLock\r\n        GameLock memory gameLock = GameLock(_totalParticipationAmount, block.number + _tokenLockDuration);\r\n        gameLocks[msg.sender] = gameLock;\r\n        isGameLocked[msg.sender] = true;\r\n        amountLocked = safeAdd(amountLocked, _totalParticipationAmount);\r\n        \r\n        //Transfer game credits to winner\r\n        generateChampionTokens(_winner, _totalParticipationAmount, _tokenLockDuration);\r\n        emit LockParameters(msg.sender, _totalParticipationAmount, block.number + _tokenLockDuration);\r\n    }\r\n    \r\n    /**\r\n     * Call CRB token to mint champion tokens\r\n     * \r\n     **/\r\n    function generateChampionTokens(address _winner, uint _totalParticipationAmount, uint _tokenLockDuration) internal{\r\n        ICreditBIT(tokenAddress).claimGameReward(_winner, _totalParticipationAmount, _tokenLockDuration);\r\n    }\r\n    \r\n    /**\r\n     * Check the CRB balance of this.\r\n     * \r\n     **/\r\n    function checkInternalBalance() public view returns(uint256 tokenBalance) {\r\n        return IERC20Token(tokenAddress).balanceOf(address(this));\r\n    }\r\n    \r\n    /**\r\n     * Method called by game contract\r\n     * msg.sender is address of calling contract that must be approved.\r\n     **/\r\n    function removeLock() public{\r\n        require(approvedGames[msg.sender] == true);\r\n        require(isGameLocked[msg.sender] == true);\r\n        require(checkIfLockCanBeRemoved(msg.sender) == true);\r\n        GameLock memory gameLock = gameLocks[msg.sender];\r\n        \r\n        //transfer tokens to game contract\r\n        IERC20Token(tokenAddress).transfer(msg.sender, gameLock.amount);\r\n        \r\n        delete(gameLocks[msg.sender]);\r\n        \r\n        //clean up\r\n        amountLocked = safeSub(amountLocked, gameLock.amount);\r\n        \r\n        isGameLocked[msg.sender] = false;\r\n        emit UnlockParameters(msg.sender, gameLock.amount);\r\n    }\r\n    \r\n    /**\r\n     * Method called by game contract when last participant has withdrawn\r\n     * msg.sender is address of calling contract that must be approved.\r\n     **/\r\n    function cleanUp() public{\r\n        require(approvedGames[msg.sender] == true);\r\n        require(isGameLocked[msg.sender] == false);\r\n        removeItem(msg.sender);\r\n        \r\n        approvedGames[msg.sender] = false;\r\n        concludedGames[concludedGameIndex] = msg.sender; \r\n        concludedGameIndex++;\r\n        emit GameConcluded(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Failsafe if game needs to be removed. Tokens are transfered to _tokenHolder address\r\n     * \r\n     **/\r\n    function removeGameManually(address _gameAddress, address _tokenHolder) onlyOwner public{\r\n      GameLock memory gameLock = gameLocks[_gameAddress];\r\n      //transfer tokens to game contract\r\n      IERC20Token(tokenAddress).transfer(_tokenHolder, gameLock.amount);\r\n      //clean up\r\n      amountLocked = safeSub(amountLocked, gameLock.amount);\r\n      delete(gameLocks[_gameAddress]);\r\n      isGameLocked[_gameAddress] = false;\r\n      removeItem(_gameAddress);\r\n      approvedGames[_gameAddress] = false;\r\n    }\r\n    \r\n    /**\r\n     * Get gamelock parameters: CRB amount locked, CRB lock duration\r\n     * \r\n     **/\r\n    function getGameLock(address _gameAddress) public view returns(uint, uint){\r\n        require(isGameLocked[_gameAddress] == true);\r\n        GameLock memory gameLock = gameLocks[_gameAddress];\r\n        return(gameLock.amount, gameLock.lockDuration);\r\n    }\r\n\r\n    /**\r\n     * Verify if game is locked\r\n     * \r\n     **/\r\n    function isGameLocked(address _gameAddress) public view returns(bool){\r\n      if(isGameLocked[_gameAddress] == true){\r\n        return true;\r\n      }else{\r\n        return false;\r\n      }\r\n    }\r\n    \r\n    /**\r\n     * Check if game lock can be removed\r\n     * \r\n     **/\r\n    function checkIfLockCanBeRemoved(address _gameAddress) public view returns(bool){\r\n        require(approvedGames[_gameAddress] == true);\r\n        require(isGameLocked[_gameAddress] == true);\r\n        GameLock memory gameLock = gameLocks[_gameAddress];\r\n        if(gameLock.lockDuration < block.number){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Kill contract if needed\r\n     * \r\n     **/\r\n    function killContract() onlyOwner public {\r\n      selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"concludedGames\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeFailedGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tail\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"concludedGameIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_currElementId\",\"type\":\"uint256\"}],\"name\":\"getNextElement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"}],\"name\":\"addApprovedGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllElements\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_item\",\"type\":\"address\"}],\"name\":\"removeItem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkInternalBalance\",\"outputs\":[{\"name\":\"tokenBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_winner\",\"type\":\"address\"},{\"name\":\"_totalParticipationAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenLockDuration\",\"type\":\"uint256\"}],\"name\":\"createLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"}],\"name\":\"getGameLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newItem\",\"type\":\"address\"}],\"name\":\"addItem\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"head\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_element\",\"type\":\"address\"}],\"name\":\"getElementLocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"}],\"name\":\"checkIfLockCanBeRemoved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getElementAt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"},{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"removeGameManually\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"}],\"name\":\"isGameLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"}],\"name\":\"isGameApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cleanUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalParticipationAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenLockDuration\",\"type\":\"uint256\"}],\"name\":\"LockParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalParticipationAmount\",\"type\":\"uint256\"}],\"name\":\"UnlockParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"GameConcluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"CreditGAME","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://73b0e4a69a4ce2d213e4a421d318305b5289dd4aafc570f8336d4cfeafa948b5"}]}