{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/IEscrow.sol\r\n\r\n/**\r\n * @title Escrow interface\r\n *\r\n * @dev https://send.sd/token\r\n */\r\ninterface IEscrow {\r\n\r\n  event Created(\r\n    address indexed sender,\r\n    address indexed recipient,\r\n    address indexed arbitrator,\r\n    uint256 transactionId\r\n  );\r\n  event Released(address indexed arbitrator, address indexed sentTo, uint256 transactionId);\r\n  event Dispute(address indexed arbitrator, uint256 transactionId);\r\n  event Paid(address indexed arbitrator, uint256 transactionId);\r\n\r\n  function create(\r\n      address _sender,\r\n      address _recipient,\r\n      address _arbitrator,\r\n      uint256 _transactionId,\r\n      uint256 _tokens,\r\n      uint256 _fee,\r\n      uint256 _expiration\r\n  ) public;\r\n\r\n  function fund(\r\n      address _sender,\r\n      address _arbitrator,\r\n      uint256 _transactionId,\r\n      uint256 _tokens,\r\n      uint256 _fee\r\n  ) public;\r\n\r\n}\r\n\r\n// File: contracts/ISendToken.sol\r\n\r\n/**\r\n * @title ISendToken - Send Consensus Network Token interface\r\n * @dev token interface built on top of ERC20 standard interface\r\n * @dev see https://send.sd/token\r\n */\r\ninterface ISendToken {\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n\r\n  function isVerified(address _address) public constant returns(bool);\r\n\r\n  function verify(address _address) public;\r\n\r\n  function unverify(address _address) public;\r\n\r\n  function verifiedTransferFrom(\r\n      address from,\r\n      address to,\r\n      uint256 value,\r\n      uint256 referenceId,\r\n      uint256 exchangeRate,\r\n      uint256 fee\r\n  ) public;\r\n\r\n  function issueExchangeRate(\r\n      address _from,\r\n      address _to,\r\n      address _verifiedAddress,\r\n      uint256 _value,\r\n      uint256 _referenceId,\r\n      uint256 _exchangeRate\r\n  ) public;\r\n\r\n  event VerifiedTransfer(\r\n      address indexed from,\r\n      address indexed to,\r\n      address indexed verifiedAddress,\r\n      uint256 value,\r\n      uint256 referenceId,\r\n      uint256 exchangeRate\r\n  );\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Escrow.sol\r\n\r\n/**\r\n * @title Vesting contract for SDT\r\n * @dev see https://send.sd/token\r\n */\r\ncontract Escrow is IEscrow, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  ISendToken public token;\r\n\r\n  struct Lock {\r\n    address sender;\r\n    address recipient;\r\n    uint256 value;\r\n    uint256 fee;\r\n    uint256 expiration;\r\n    bool paid;\r\n  }\r\n\r\n  mapping(address => mapping(uint256 => Lock)) internal escrows;\r\n\r\n  function Escrow(address _token) public {\r\n    token = ISendToken(_token);\r\n  }\r\n\r\n  modifier tokenRestricted() {\r\n    require(msg.sender == address(token));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Create a record for held tokens\r\n   * @param _arbitrator Address to be authorized to spend locked funds\r\n   * @param _transactionId Intenral ID for applications implementing this\r\n   * @param _tokens Amount of tokens to lock\r\n   * @param _fee A fee to be paid to arbitrator (may be 0)\r\n   * @param _expiration After this timestamp, user can claim tokens back.\r\n   */\r\n  function create(\r\n      address _sender,\r\n      address _recipient,\r\n      address _arbitrator,\r\n      uint256 _transactionId,\r\n      uint256 _tokens,\r\n      uint256 _fee,\r\n      uint256 _expiration\r\n  ) public tokenRestricted {\r\n\r\n    require(_tokens > 0);\r\n    require(_fee >= 0);\r\n    require(escrows[_arbitrator][_transactionId].value == 0);\r\n\r\n    escrows[_arbitrator][_transactionId].sender = _sender;\r\n    escrows[_arbitrator][_transactionId].recipient = _recipient;\r\n    escrows[_arbitrator][_transactionId].value = _tokens;\r\n    escrows[_arbitrator][_transactionId].fee = _fee;\r\n    escrows[_arbitrator][_transactionId].expiration = _expiration;\r\n\r\n    Created(_sender, _recipient, _arbitrator, _transactionId);\r\n  }\r\n\r\n  /**\r\n   * @dev Fund escrow record\r\n   * @param _arbitrator Address to be authorized to spend locked funds\r\n   * @param _transactionId Intenral ID for applications implementing this\r\n   * @param _tokens Amount of tokens to lock\r\n   * @param _fee A fee to be paid to arbitrator (may be 0)\r\n   */\r\n  function fund(\r\n      address _sender,\r\n      address _arbitrator,\r\n      uint256 _transactionId,\r\n      uint256 _tokens,\r\n      uint256 _fee\r\n  ) public tokenRestricted {\r\n\r\n    require(escrows[_arbitrator][_transactionId].sender == _sender);\r\n    require(escrows[_arbitrator][_transactionId].value == _tokens);\r\n    require(escrows[_arbitrator][_transactionId].fee == _fee);\r\n    require(escrows[_arbitrator][_transactionId].paid == false);\r\n\r\n    escrows[_arbitrator][_transactionId].paid = true;\r\n\r\n    Paid(_arbitrator, _transactionId);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer a locked amount\r\n   * @notice Only authorized address\r\n   * @notice Exchange rate has 18 decimal places\r\n   * @param _sender Address with locked amount\r\n   * @param _recipient Address to send funds to\r\n   * @param _transactionId App/user internal associated ID\r\n   * @param _exchangeRate Rate to be reported to the blockchain\r\n   */\r\n  function release(\r\n      address _sender,\r\n      address _recipient,\r\n      uint256 _transactionId,\r\n      uint256 _exchangeRate\r\n  ) public {\r\n\r\n    Lock memory lock = escrows[msg.sender][_transactionId];\r\n\r\n    require(lock.expiration != 1);\r\n    require(lock.sender == _sender);\r\n    require(lock.recipient == _recipient || lock.sender == _recipient);\r\n    require(lock.paid);\r\n\r\n    if (lock.fee > 0 && lock.recipient == _recipient) {\r\n      token.transfer(_recipient, lock.value);\r\n      token.transfer(msg.sender, lock.fee);\r\n    } else {\r\n      token.transfer(_recipient, lock.value.add(lock.fee));\r\n    }\r\n\r\n    delete escrows[msg.sender][_transactionId];\r\n\r\n    token.issueExchangeRate(\r\n      _sender,\r\n      _recipient,\r\n      msg.sender,\r\n      lock.value,\r\n      _transactionId,\r\n      _exchangeRate\r\n    );\r\n    Released(msg.sender, _recipient, _transactionId);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer a locked amount for timeless escrow\r\n   * @notice Only authorized address\r\n   * @notice Exchange rate has 18 decimal places\r\n   * @param _sender Address with locked amount\r\n   * @param _recipient Address to send funds to\r\n   * @param _transactionId App/user internal associated ID\r\n   * @param _exchangeRate Rate to be reported to the blockchain\r\n   */\r\n  function releaseUnlocked(\r\n      address _sender,\r\n      address _recipient,\r\n      uint256 _transactionId,\r\n      uint256 _exchangeRate\r\n  ) public {\r\n\r\n    Lock memory lock = escrows[msg.sender][_transactionId];\r\n\r\n    require(lock.expiration == 1);\r\n    require(lock.sender == _sender);\r\n    require(lock.paid);\r\n\r\n    if (lock.fee > 0 && lock.sender != _recipient) {\r\n      token.transfer(_recipient, lock.value);\r\n      token.transfer(msg.sender, lock.fee);\r\n    } else {\r\n      token.transfer(_recipient, lock.value.add(lock.fee));\r\n    }\r\n\r\n    delete escrows[msg.sender][_transactionId];\r\n\r\n    token.issueExchangeRate(\r\n      _sender,\r\n      _recipient,\r\n      msg.sender,\r\n      lock.value,\r\n      _transactionId,\r\n      _exchangeRate\r\n    );\r\n    Released(msg.sender, _recipient, _transactionId);\r\n  }\r\n\r\n  /**\r\n   * @dev Claim back locked amount after expiration time\r\n   * @dev Cannot be claimed if expiration == 0 or expiration == 1\r\n   * @notice Only works after lock expired\r\n   * @param _arbitrator Authorized lock address\r\n   * @param _transactionId transactionId ID from App/user\r\n   */\r\n  function claim(\r\n      address _arbitrator,\r\n      uint256 _transactionId\r\n  ) public {\r\n    Lock memory lock = escrows[_arbitrator][_transactionId];\r\n\r\n    require(lock.sender == msg.sender);\r\n    require(lock.paid);\r\n    require(lock.expiration < block.timestamp);\r\n    require(lock.expiration != 0);\r\n    require(lock.expiration != 1);\r\n\r\n    delete escrows[_arbitrator][_transactionId];\r\n\r\n    token.transfer(msg.sender, lock.value.add(lock.fee));\r\n\r\n    Released(\r\n      _arbitrator,\r\n      msg.sender,\r\n      _transactionId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Remove expiration time on a lock\r\n   * @notice User wont be able to claim tokens back after this is called by arbitrator address\r\n   * @notice Only authorized address\r\n   * @param _transactionId App/user internal associated ID\r\n   */\r\n  function mediate(\r\n      uint256 _transactionId\r\n  ) public {\r\n    require(escrows[msg.sender][_transactionId].paid);\r\n    require(escrows[msg.sender][_transactionId].expiration != 0);\r\n    require(escrows[msg.sender][_transactionId].expiration != 1);\r\n\r\n    escrows[msg.sender][_transactionId].expiration = 0;\r\n\r\n    Dispute(msg.sender, _transactionId);\r\n  }\r\n\r\n  /**\r\n   This function is a way to get other ETC20 tokens\r\n   back to their rightful owner if sent by mistake\r\n   */\r\n  function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner {\r\n    require(_tokenAddress != address(token));\r\n\r\n    ISendToken erc20Token = ISendToken(_tokenAddress);\r\n    erc20Token.transfer(_transferTo, _value);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_arbitrator\",\"type\":\"address\"},{\"name\":\"_transactionId\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_transactionId\",\"type\":\"uint256\"},{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_arbitrator\",\"type\":\"address\"},{\"name\":\"_transactionId\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_expiration\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_arbitrator\",\"type\":\"address\"},{\"name\":\"_transactionId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transactionId\",\"type\":\"uint256\"}],\"name\":\"mediate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_transactionId\",\"type\":\"uint256\"},{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"releaseUnlocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_transferTo\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sentTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Dispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Paid\",\"type\":\"event\"}]","ContractName":"Escrow","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003452282f3b9d93f1f79cc168631fe98bb9673f77","Library":"","SwarmSource":"bzzr://5417d6d36f45dcae06c42722371889550d3b7929caa31627ba1cd3b6062cc938"}]}