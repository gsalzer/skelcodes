{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/******************************************************************************\\\r\n*..................................SU.SQUARES..................................*\r\n*.......................Blockchain.rentable.advertising........................*\r\n*..............................................................................*\r\n* First, I just want to say we are so excited and humbled to get this far and  *\r\n* that you're even reading this. So thank you!                                 *\r\n*                                                                              *\r\n* This file is organized into multiple contracts that separate functionality   *\r\n* into logical parts. The deployed contract, SuMain, is at the bottom and      *\r\n* includes the rest of the file using inheritance.                             *\r\n*                                                                              *\r\n*  - ERC165, ERC721: These interfaces follow the official EIPs                 *\r\n*  - AccessControl: A reusable CEO/CFO/COO access model                        *\r\n*  - PublishInterfaces: An implementation of ERC165                            *\r\n*  - SuNFT: An implementation of ERC721                                        *\r\n*  - SuOperation: The actual square data and the personalize function          *\r\n*  - SuPromo, SuVending: How we sell or grant squares                          *\r\n*..............................................................................*\r\n*............................Su.&.William.Entriken.............................*\r\n*...................................(c) 2018...................................*\r\n\\******************************************************************************/\r\n\r\n/* AccessControl.sol **********************************************************/\r\n\r\n/// @title Reusable three-role access control inspired by CryptoKitties\r\n/// @author William Entriken (https://phor.net)\r\n/// @dev Keep the CEO wallet stored offline, I warned you\r\ncontract AccessControl {\r\n    /// @notice The account that can only reassign executive accounts\r\n    address public executiveOfficerAddress;\r\n\r\n    /// @notice The account that can collect funds from this contract\r\n    address public financialOfficerAddress;\r\n\r\n    /// @notice The account with administrative control of this contract\r\n    address public operatingOfficerAddress;\r\n\r\n    function AccessControl() internal {\r\n        executiveOfficerAddress = msg.sender;\r\n    }\r\n\r\n    /// @dev Only allowed by executive officer\r\n    modifier onlyExecutiveOfficer() {\r\n        require(msg.sender == executiveOfficerAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only allowed by financial officer\r\n    modifier onlyFinancialOfficer() {\r\n        require(msg.sender == financialOfficerAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only allowed by operating officer\r\n    modifier onlyOperatingOfficer() {\r\n        require(msg.sender == operatingOfficerAddress);\r\n        _;\r\n    }\r\n\r\n    /// @notice Reassign the executive officer role\r\n    /// @param _executiveOfficerAddress new officer address\r\n    function setExecutiveOfficer(address _executiveOfficerAddress)\r\n        external\r\n        onlyExecutiveOfficer\r\n    {\r\n        require(_executiveOfficerAddress != address(0));\r\n        executiveOfficerAddress = _executiveOfficerAddress;\r\n    }\r\n\r\n    /// @notice Reassign the financial officer role\r\n    /// @param _financialOfficerAddress new officer address\r\n    function setFinancialOfficer(address _financialOfficerAddress)\r\n        external\r\n        onlyExecutiveOfficer\r\n    {\r\n        require(_financialOfficerAddress != address(0));\r\n        financialOfficerAddress = _financialOfficerAddress;\r\n    }\r\n\r\n    /// @notice Reassign the operating officer role\r\n    /// @param _operatingOfficerAddress new officer address\r\n    function setOperatingOfficer(address _operatingOfficerAddress)\r\n        external\r\n        onlyExecutiveOfficer\r\n    {\r\n        require(_operatingOfficerAddress != address(0));\r\n        operatingOfficerAddress = _operatingOfficerAddress;\r\n    }\r\n\r\n    /// @notice Collect funds from this contract\r\n    function withdrawBalance() external onlyFinancialOfficer {\r\n        financialOfficerAddress.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\n/* ERC165.sol *****************************************************************/\r\n\r\n/// @title ERC-165 Standard Interface Detection\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/* ERC721.sol *****************************************************************/\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\ncontract ERC721 is ERC165 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\ninterface ERC721TokenReceiver {\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    function name() external pure returns (string _name);\r\n    function symbol() external pure returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/* PublishInterfaces.sol ******************************************************/\r\n\r\n/// @title A reusable contract to comply with ERC-165\r\n/// @author William Entriken (https://phor.net)\r\ncontract PublishInterfaces is ERC165 {\r\n    /// @dev Every interface that we support\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    function PublishInterfaces() internal {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n    }\r\n\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[interfaceID] && (interfaceID != 0xffffffff);\r\n    }\r\n}\r\n\r\n/* SuNFT.sol ******************************************************************/\r\n\r\n/// @title Compliance with ERC-721 for Su Squares\r\n/// @dev This implementation assumes:\r\n///  - A fixed supply of NFTs, cannot mint or burn\r\n///  - ids are numbered sequentially starting at 1.\r\n///  - NFTs are initially assigned to this contract\r\n///  - This contract does not externally call its own functions\r\n/// @author William Entriken (https://phor.net)\r\ncontract SuNFT is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, PublishInterfaces {\r\n    /// @dev The authorized address for each NFT\r\n    mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    /// @dev The authorized operators for each address\r\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n    /// @dev Guarantees msg.sender is the owner of _tokenId\r\n    /// @param _tokenId The token to validate belongs to msg.sender\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // assert(msg.sender != address(this))\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier mustBeOwnedByThisContract(uint256 _tokenId) {\r\n        require(_tokenId >= 1 && _tokenId <= TOTAL_SUPPLY);\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        require(owner == address(0) || owner == address(this));\r\n        _;\r\n    }\r\n    \r\n    modifier canOperate(uint256 _tokenId) {\r\n        // assert(msg.sender != address(this))\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        require(msg.sender == owner || operatorApprovals[owner][msg.sender]);\r\n        _;\r\n    }\r\n    \r\n    modifier canTransfer(uint256 _tokenId) {\r\n        // assert(msg.sender != address(this))\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        require(msg.sender == owner || \r\n          msg.sender == tokenApprovals[_tokenId] || \r\n          operatorApprovals[msg.sender][msg.sender]);\r\n        _;\r\n    }\r\n    \r\n    modifier mustBeValidToken(uint256 _tokenId) {\r\n        require(_tokenId >= 1 && _tokenId <= TOTAL_SUPPLY);\r\n        _;\r\n    }\r\n    \r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return _tokensOfOwnerWithSubstitutions[_owner].length;\r\n    }\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) \r\n        external\r\n        view\r\n        mustBeValidToken(_tokenId)\r\n        returns (address _owner)\r\n    {\r\n        _owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Handle substitutions\r\n        if (_owner == address(0)) {\r\n            _owner = address(this);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable\r\n    {\r\n        _safeTransferFrom(_from, _to, _tokenId, data);\r\n    }\r\n\t\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable\r\n    {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId)\r\n        external\r\n        payable\r\n        mustBeValidToken(_tokenId)\r\n        canTransfer(_tokenId)\r\n    {\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Handle substitutions\r\n        if (owner == address(0)) {\r\n            owner = address(this);\r\n        }\r\n        require(owner == _from);\r\n        require(_to != address(0));\r\n        _transfer(_tokenId, _to);\r\n    }\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId)\r\n        external\r\n        payable\r\n        // assert(mustBeValidToken(_tokenId))\r\n        canOperate(_tokenId)\r\n    {\r\n        address _owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Handle substitutions\r\n        if (_owner == address(0)) {\r\n            _owner = address(this);\r\n        }\r\n        tokenApprovals[_tokenId] = _approved;\r\n        emit Approval(_owner, _approved, _tokenId);\r\n    }\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your asset.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        operatorApprovals[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId)\r\n        external\r\n        view\r\n        mustBeValidToken(_tokenId)\r\n        returns (address)\r\n    {\r\n        return tokenApprovals[_tokenId];        \r\n    }\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n    \r\n    // COMPLIANCE WITH ERC721Metadata //////////////////////////////////////////\r\n\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string) {\r\n        return \"Su Squares\";\r\n    }\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string) {\r\n        return \"SU\";\r\n    }\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) \r\n        external\r\n        view\r\n        mustBeValidToken(_tokenId)\r\n        returns (string _tokenURI)\r\n    {\r\n        _tokenURI = \"https://tenthousandsu.com/erc721/00000.json\";\r\n        bytes memory _tokenURIBytes = bytes(_tokenURI);\r\n        _tokenURIBytes[33] = byte(48+(_tokenId / 10000) % 10);\r\n        _tokenURIBytes[34] = byte(48+(_tokenId / 1000) % 10);\r\n        _tokenURIBytes[35] = byte(48+(_tokenId / 100) % 10);\r\n        _tokenURIBytes[36] = byte(48+(_tokenId / 10) % 10);\r\n        _tokenURIBytes[37] = byte(48+(_tokenId / 1) % 10);\r\n        \r\n    }\r\n\r\n    // COMPLIANCE WITH ERC721Enumerable ////////////////////////////////////////\r\n\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256) {\r\n        return TOTAL_SUPPLY;\r\n    }\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < TOTAL_SUPPLY);\r\n        return _index + 1;\r\n    }\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {\r\n        require(_owner != address(0));\r\n        require(_index < _tokensOfOwnerWithSubstitutions[_owner].length);\r\n        _tokenId = _tokensOfOwnerWithSubstitutions[_owner][_index];\r\n        // Handle substitutions\r\n        if (_owner == address(this)) {\r\n            if (_tokenId == 0) {\r\n                _tokenId = _index + 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    // INTERNAL INTERFACE //////////////////////////////////////////////////////\r\n\r\n    /// @dev Actually do a transfer, does NO precondition checking\r\n    function _transfer(uint256 _tokenId, address _to) internal {\r\n        // Here are the preconditions we are not checking:\r\n        // assert(canTransfer(_tokenId))\r\n        // assert(mustBeValidToken(_tokenId))\r\n        require(_to != address(0));\r\n\r\n        // Find the FROM address\r\n        address fromWithSubstitution = _tokenOwnerWithSubstitutions[_tokenId];\r\n        address from = fromWithSubstitution;\r\n        if (fromWithSubstitution == address(0)) {\r\n            from = address(this);\r\n        }\r\n\r\n        // Take away from the FROM address\r\n        // The Entriken algorithm for deleting from an indexed, unsorted array\r\n        uint256 indexToDeleteWithSubstitution = _ownedTokensIndexWithSubstitutions[_tokenId];\r\n        uint256 indexToDelete;\r\n        if (indexToDeleteWithSubstitution == 0) {\r\n            indexToDelete = _tokenId - 1;\r\n        } else {\r\n            indexToDelete = indexToDeleteWithSubstitution - 1;\r\n        }\r\n        if (indexToDelete != _tokensOfOwnerWithSubstitutions[from].length - 1) {\r\n            uint256 lastNftWithSubstitution = _tokensOfOwnerWithSubstitutions[from][_tokensOfOwnerWithSubstitutions[from].length - 1];\r\n            uint256 lastNft = lastNftWithSubstitution;\r\n            if (lastNftWithSubstitution == 0) {\r\n                // assert(from ==  address(0) || from == address(this));\r\n                lastNft = _tokensOfOwnerWithSubstitutions[from].length;\r\n            }\r\n            _tokensOfOwnerWithSubstitutions[from][indexToDelete] = lastNft;\r\n            _ownedTokensIndexWithSubstitutions[lastNft] = indexToDelete + 1;\r\n        }\r\n        delete _tokensOfOwnerWithSubstitutions[from][_tokensOfOwnerWithSubstitutions[from].length - 1]; // get gas back\r\n        _tokensOfOwnerWithSubstitutions[from].length--;\r\n        // Right now _ownedTokensIndexWithSubstitutions[_tokenId] is invalid, set it below based on the new owner\r\n\r\n        // Give to the TO address\r\n        _tokensOfOwnerWithSubstitutions[_to].push(_tokenId);\r\n        _ownedTokensIndexWithSubstitutions[_tokenId] = (_tokensOfOwnerWithSubstitutions[_to].length - 1) + 1;\r\n\r\n        // External processing\r\n        _tokenOwnerWithSubstitutions[_tokenId] = _to;\r\n        tokenApprovals[_tokenId] = address(0);\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n    \r\n    // PRIVATE STORAGE AND FUNCTIONS ///////////////////////////////////////////\r\n\r\n    uint256 private constant TOTAL_SUPPLY = 10000; // SOLIDITY ISSUE #3356 make this immutable\r\n\r\n    bytes4 private constant ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"));\r\n    \r\n    /// @dev The owner of each NFT\r\n    ///  If value == address(0), NFT is owned by address(this)\r\n    ///  If value != address(0), NFT is owned by value\r\n    ///  assert(This contract never assigns awnerhip to address(0) or destroys NFTs)\r\n    ///  See commented out code in constructor, saves hella gas\r\n    mapping (uint256 => address) private _tokenOwnerWithSubstitutions;\r\n\r\n    /// @dev The list of NFTs owned by each address\r\n    ///  Nomenclature: this[key][index] = value\r\n    ///  If key != address(this) or value != 0, then value represents an NFT\r\n    ///  If key == address(this) and value == 0, then index + 1 is the NFT\r\n    ///  assert(0 is not a valid NFT)\r\n    ///  See commented out code in constructor, saves hella gas\r\n    mapping (address => uint256[]) private _tokensOfOwnerWithSubstitutions;\r\n    \r\n    /// @dev (Location + 1) of each NFT in its owner's list\r\n    ///  Nomenclature: this[key] = value\r\n    ///  If value != 0, _tokensOfOwnerWithSubstitutions[owner][value - 1] = nftId\r\n    ///  If value == 0, _tokensOfOwnerWithSubstitutions[owner][key - 1] = nftId\r\n    ///  assert(2**256-1 is not a valid NFT)\r\n    ///  See commented out code in constructor, saves hella gas\r\n    mapping (uint256 => uint256) private _ownedTokensIndexWithSubstitutions;\r\n\r\n    // Due to implementation choices (no mint, no burn, contiguous NFT ids), it\r\n    // is not necessary to keep an array of NFT ids nor where each NFT id is\r\n    // located in that array.\r\n    // address[] private nftIds;\r\n    // mapping (uint256 => uint256) private nftIndexOfId;\r\n    \r\n    function SuNFT() internal {\r\n        // Publish interfaces with ERC-165\r\n        supportedInterfaces[0x6466353c] = true; // ERC721\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n        \r\n        // The effect of substitution makes storing address(this), address(this)\r\n        // ..., address(this) for a total of TOTAL_SUPPLY times unnecessary at\r\n        // deployment time\r\n        // for (uint256 i = 1; i <= TOTAL_SUPPLY; i++) {\r\n        //     _tokenOwnerWithSubstitutions[i] = address(this);\r\n        // }\r\n\r\n        // The effect of substitution makes storing 1, 2, ..., TOTAL_SUPPLY\r\n        // unnecessary at deployment time\r\n        _tokensOfOwnerWithSubstitutions[address(this)].length = TOTAL_SUPPLY;\r\n        // for (uint256 i = 0; i < TOTAL_SUPPLY; i++) {\r\n        //     _tokensOfOwnerWithSubstitutions[address(this)][i] = i + 1;\r\n        // }\r\n        // for (uint256 i = 1; i <= TOTAL_SUPPLY; i++) {\r\n        //     _ownedTokensIndexWithSubstitutions[i] = i - 1;\r\n        // }\r\n    }\r\n    \r\n    /// @dev Actually perform the safeTransferFrom\r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)\r\n        private\r\n        mustBeValidToken(_tokenId)\r\n        canTransfer(_tokenId)\r\n    {\r\n        address owner = _tokenOwnerWithSubstitutions[_tokenId];\r\n        // Handle substitutions\r\n        if (owner == address(0)) {\r\n            owner = address(this);\r\n        }\r\n        require(owner == _from);\r\n        require(_to != address(0));\r\n        _transfer(_tokenId, _to);\r\n        \r\n        // Do the callback after everything is done to avoid reentrancy attack\r\n        uint256 codeSize;\r\n        assembly { codeSize := extcodesize(_to) }\r\n        if (codeSize == 0) {\r\n            return;\r\n        }\r\n        bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\r\n        require(retval == ERC721_RECEIVED);\r\n    }    \r\n}\r\n\r\n/* SuOperation.sol ************************************************************/\r\n\r\n/// @title The features that square owners can use\r\n/// @author William Entriken (https://phor.net)\r\n/// @dev See SuMain contract documentation for detail on how contracts interact.\r\ncontract SuOperation is SuNFT {\r\n    /// @dev The personalization of a square has changed\r\n    event Personalized(uint256 _nftId);\r\n    \r\n    /// @dev The main SuSquare struct. The owner may set these properties, subject\r\n    ///  subject to certain rules. The actual 10x10 image is rendered on our\r\n    ///  website using this data.\r\n    struct SuSquare {\r\n        /// @dev This increments on each update\r\n        uint256 version;\r\n        \r\n        /// @dev A 10x10 pixel image, stored 8-bit RGB values from left-to-right\r\n        ///  and top-to-bottom order (normal English reading order). So it is\r\n        ///  exactly 300 bytes. Or it is an empty array.\r\n        ///  So the first byte is the red channel for the top-left pixel, then\r\n        ///  the blue, then the green, and then next is the red channel for the\r\n        ///  pixel to the right of the first pixel.\r\n        bytes rgbData;\r\n\r\n        /// @dev The title of this square, at most 64 bytes,\r\n        string title;\r\n\r\n        /// @dev The URL of this square, at most 100 bytes, or empty string\r\n        string href;\r\n    }\r\n\r\n    /// @notice All the Su Squares that ever exist or will exist. Each Su Square\r\n    ///  represents a square on our webpage in a 100x100 grid. The squares are\r\n    ///  arranged in left-to-right, top-to-bottom order. In other words, normal\r\n    ///  English reading order. So suSquares[1] is the top-left location and\r\n    ///  suSquares[100] is the top-right location. And suSquares[101] is\r\n    ///  directly below suSquares[1]. \r\n    /// @dev There is no suSquares[0] -- that is an unused array index.\r\n    SuSquare[10001] public suSquares;\r\n    \r\n    /// @notice Update the contents of your square, the first 3 personalizations\r\n    ///  for a square are free then cost 100 finney (0.1 ether) each\r\n    /// @param _squareId The top-left is 1, to its right is 2, ..., top-right is\r\n    ///  100 and then 101 is below 1... the last one at bottom-right is 10000\r\n    /// @param _squareId A 10x10 image for your square, in 8-bit RGB words\r\n    ///  ordered like the squares are ordered. See Imagemagick's command\r\n    ///  convert -size 10x10 -depth 8 in.rgb out.png\r\n    /// @param _title A description of your square (max 64 bytes UTF-8)\r\n    /// @param _href A hyperlink for your square (max 96 bytes)\r\n    function personalizeSquare(\r\n        uint256 _squareId,\r\n        bytes _rgbData,\r\n        string _title,\r\n        string _href\r\n    )\r\n        external\r\n        onlyOwnerOf(_squareId)\r\n        payable\r\n    {\r\n        require(bytes(_title).length <= 64);\r\n        require(bytes(_href).length <= 96);\r\n        require(_rgbData.length == 300);\r\n        suSquares[_squareId].version++;\r\n        suSquares[_squareId].rgbData = _rgbData;\r\n        suSquares[_squareId].title = _title;\r\n        suSquares[_squareId].href = _href;\r\n        if (suSquares[_squareId].version > 3) {\r\n            require(msg.value == 100 finney);\r\n        }\r\n        emit Personalized(_squareId);\r\n    }\r\n}\r\n\r\n/* SuPromo.sol ****************************************************************/\r\n\r\n/// @title A limited pre-sale and promotional giveaway.\r\n/// @author William Entriken (https://phor.net)\r\n/// @dev See SuMain contract documentation for detail on how contracts interact.\r\ncontract SuPromo is AccessControl, SuNFT {\r\n    uint256 constant PROMO_CREATION_LIMIT = 5000;\r\n\r\n    /// @notice How many promo squares were granted\r\n    uint256 public promoCreatedCount;\r\n\r\n    /// @notice BEWARE, this does not use a safe transfer mechanism!\r\n    ///  You must manually check the receiver can accept NFTs\r\n    function grantToken(uint256 _tokenId, address _newOwner)\r\n        external\r\n        onlyOperatingOfficer\r\n        mustBeValidToken(_tokenId)\r\n        mustBeOwnedByThisContract(_tokenId)\r\n    {\r\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\r\n        promoCreatedCount++;\r\n        _transfer(_tokenId, _newOwner);\r\n    }\r\n}\r\n\r\n/* SuVending.sol **************************************************************/\r\n\r\n/// @title A token vending machine\r\n/// @author William Entriken (https://phor.net)\r\n/// @dev See SuMain contract documentation for detail on how contracts interact.\r\ncontract SuVending is SuNFT {\r\n    uint256 constant SALE_PRICE = 500 finney; // 0.5 ether\r\n\r\n    /// @notice The price is always 0.5 ether, and you can buy any available square\r\n    ///  Be sure you are calling this from a regular account (not a smart contract)\r\n    ///  or if you are calling from a smart contract, make sure it can use\r\n    ///  ERC-721 non-fungible tokens\r\n    function purchase(uint256 _nftId)\r\n        external\r\n        payable\r\n        mustBeValidToken(_nftId)\r\n        mustBeOwnedByThisContract(_nftId)\r\n    {\r\n        require(msg.value == SALE_PRICE);\r\n        _transfer(_nftId, msg.sender);\r\n    }\r\n}\r\n\r\n/* SuMain.sol *****************************************************************/\r\n\r\n/// @title The features that deed owners can use\r\n/// @author William Entriken (https://phor.net)\r\n/// @dev See SuMain contract documentation for detail on how contracts interact.\r\ncontract SuMain is AccessControl, SuNFT, SuOperation, SuVending, SuPromo {\r\n    function SuMain() public {\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"executiveOfficerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promoCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"grantToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operatingOfficerAddress\",\"type\":\"address\"}],\"name\":\"setOperatingOfficer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operatingOfficerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_squareId\",\"type\":\"uint256\"},{\"name\":\"_rgbData\",\"type\":\"bytes\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_href\",\"type\":\"string\"}],\"name\":\"personalizeSquare\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"financialOfficerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"_tokenURI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_financialOfficerAddress\",\"type\":\"address\"}],\"name\":\"setFinancialOfficer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_executiveOfficerAddress\",\"type\":\"address\"}],\"name\":\"setExecutiveOfficer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"suSquares\",\"outputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"rgbData\",\"type\":\"bytes\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"href\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"Personalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"SuMain","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://80ca894129dcf33cf9170139ad5d36a738c70107f6974d5ee302fb6e369bd1ac"}]}