{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.20;\r\n\r\ncontract IAugur {\r\n    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] _parentPayoutNumerators, bool _parentInvalid) public returns (IUniverse);\r\n    function isKnownUniverse(IUniverse _universe) public view returns (bool);\r\n    function trustedTransfer(ERC20 _token, address _from, address _to, uint256 _amount) public returns (bool);\r\n    function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, bytes32[] _outcomes, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);\r\n    function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);\r\n    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] _payoutNumerators, bool _invalid) public returns (bool);\r\n    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] _payoutNumerators, uint256 _size, bool _invalid) public returns (bool);\r\n    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked) public returns (bool);\r\n    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer) public returns (bool);\r\n    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);\r\n    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);\r\n    function logFeeWindowRedeemed(IUniverse _universe, address _reporter, uint256 _amountRedeemed, uint256 _reportingFeesReceived) public returns (bool);\r\n    function logMarketFinalized(IUniverse _universe) public returns (bool);\r\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\r\n    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\r\n    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\r\n    function logOrderCanceled(IUniverse _universe, address _shareToken, address _sender, bytes32 _orderId, Order.Types _orderType, uint256 _tokenRefund, uint256 _sharesRefund) public returns (bool);\r\n    function logOrderCreated(Order.Types _orderType, uint256 _amount, uint256 _price, address _creator, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _tradeGroupId, bytes32 _orderId, IUniverse _universe, address _shareToken) public returns (bool);\r\n    function logOrderFilled(IUniverse _universe, address _shareToken, address _filler, bytes32 _orderId, uint256 _numCreatorShares, uint256 _numCreatorTokens, uint256 _numFillerShares, uint256 _numFillerTokens, uint256 _marketCreatorFees, uint256 _reporterFees, uint256 _amountFilled, bytes32 _tradeGroupId) public returns (bool);\r\n    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\r\n    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\r\n    function logTradingProceedsClaimed(IUniverse _universe, address _shareToken, address _sender, address _market, uint256 _numShares, uint256 _numPayoutTokens, uint256 _finalTokenBalance) public returns (bool);\r\n    function logUniverseForked() public returns (bool);\r\n    function logFeeWindowTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\r\n    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\r\n    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\r\n    function logShareTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\r\n    function logReputationTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logReputationTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logShareTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logShareTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logFeeWindowBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logFeeWindowMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logFeeWindowCreated(IFeeWindow _feeWindow, uint256 _id) public returns (bool);\r\n    function logFeeTokenTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\r\n    function logFeeTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logFeeTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\r\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\r\n    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\r\n    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\r\n    function logMarketMailboxTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\r\n    function logEscapeHatchChanged(bool _isOn) public returns (bool);\r\n}\r\n\r\ncontract IControlled {\r\n    function getController() public view returns (IController);\r\n    function setController(IController _controller) public returns(bool);\r\n}\r\n\r\ncontract Controlled is IControlled {\r\n    IController internal controller;\r\n\r\n    modifier onlyWhitelistedCallers {\r\n        require(controller.assertIsWhitelisted(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyCaller(bytes32 _key) {\r\n        require(msg.sender == controller.lookup(_key));\r\n        _;\r\n    }\r\n\r\n    modifier onlyControllerCaller {\r\n        require(IController(msg.sender) == controller);\r\n        _;\r\n    }\r\n\r\n    modifier onlyInGoodTimes {\r\n        require(controller.stopInEmergency());\r\n        _;\r\n    }\r\n\r\n    modifier onlyInBadTimes {\r\n        require(controller.onlyInEmergency());\r\n        _;\r\n    }\r\n\r\n    function Controlled() public {\r\n        controller = IController(msg.sender);\r\n    }\r\n\r\n    function getController() public view returns(IController) {\r\n        return controller;\r\n    }\r\n\r\n    function setController(IController _controller) public onlyControllerCaller returns(bool) {\r\n        controller = _controller;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract IController {\r\n    function assertIsWhitelisted(address _target) public view returns(bool);\r\n    function lookup(bytes32 _key) public view returns(address);\r\n    function stopInEmergency() public view returns(bool);\r\n    function onlyInEmergency() public view returns(bool);\r\n    function getAugur() public view returns (IAugur);\r\n    function getTimestamp() public view returns (uint256);\r\n}\r\n\r\ncontract FeeWindowFactory {\r\n    function createFeeWindow(IController _controller, IUniverse _universe, uint256 _feeWindowId) public returns (IFeeWindow) {\r\n        Delegator _delegator = new Delegator(_controller, \"FeeWindow\");\r\n        IFeeWindow _feeWindow = IFeeWindow(_delegator);\r\n        _feeWindow.initialize(_universe, _feeWindowId);\r\n        return _feeWindow;\r\n    }\r\n}\r\n\r\ncontract MarketFactory {\r\n    function createMarket(IController _controller, IUniverse _universe, uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, address _sender, uint256 _numOutcomes, uint256 _numTicks) public payable returns (IMarket _market) {\r\n        Delegator _delegator = new Delegator(_controller, \"Market\");\r\n        _market = IMarket(_delegator);\r\n        IReputationToken _reputationToken = _universe.getReputationToken();\r\n        require(_reputationToken.transfer(_market, _reputationToken.balanceOf(this)));\r\n        _market.initialize.value(msg.value)(_universe, _endTime, _feePerEthInWei, _denominationToken, _designatedReporterAddress, _sender, _numOutcomes, _numTicks);\r\n        return _market;\r\n    }\r\n}\r\n\r\ncontract ReputationTokenFactory {\r\n    function createReputationToken(IController _controller, IUniverse _universe) public returns (IReputationToken) {\r\n        Delegator _delegator = new Delegator(_controller, \"ReputationToken\");\r\n        IReputationToken _reputationToken = IReputationToken(_delegator);\r\n        _reputationToken.initialize(_universe);\r\n        return _reputationToken;\r\n    }\r\n}\r\n\r\ncontract DelegationTarget is Controlled {\r\n    bytes32 public controllerLookupName;\r\n}\r\n\r\ncontract Delegator is DelegationTarget {\r\n    function Delegator(IController _controller, bytes32 _controllerLookupName) public {\r\n        controller = _controller;\r\n        controllerLookupName = _controllerLookupName;\r\n    }\r\n\r\n    function() external payable {\r\n        // Do nothing if we haven't properly set up the delegator to delegate calls\r\n        if (controllerLookupName == 0) {\r\n            return;\r\n        }\r\n\r\n        // Get the delegation target contract\r\n        address _target = controller.lookup(controllerLookupName);\r\n\r\n        assembly {\r\n            //0x40 is the address where the next free memory slot is stored in Solidity\r\n            let _calldataMemoryOffset := mload(0x40)\r\n            // new \"memory end\" including padding. The bitwise operations here ensure we get rounded up to the nearest 32 byte boundary\r\n            let _size := and(add(calldatasize, 0x1f), not(0x1f))\r\n            // Update the pointer at 0x40 to point at new free memory location so any theoretical allocation doesn't stomp our memory in this call\r\n            mstore(0x40, add(_calldataMemoryOffset, _size))\r\n            // Copy method signature and parameters of this call into memory\r\n            calldatacopy(_calldataMemoryOffset, 0x0, calldatasize)\r\n            // Call the actual method via delegation\r\n            let _retval := delegatecall(gas, _target, _calldataMemoryOffset, calldatasize, 0, 0)\r\n            switch _retval\r\n            case 0 {\r\n                // 0 == it threw, so we revert\r\n                revert(0,0)\r\n            } default {\r\n                // If the call succeeded return the return data from the delegate call\r\n                let _returndataMemoryOffset := mload(0x40)\r\n                // Update the pointer at 0x40 again to point at new free memory location so any theoretical allocation doesn't stomp our memory in this call\r\n                mstore(0x40, add(_returndataMemoryOffset, returndatasize))\r\n                returndatacopy(_returndataMemoryOffset, 0x0, returndatasize)\r\n                return(_returndataMemoryOffset, returndatasize)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract IOwnable {\r\n    function getOwner() public view returns (address);\r\n    function transferOwnership(address newOwner) public returns (bool);\r\n}\r\n\r\ncontract ITyped {\r\n    function getTypeName() public view returns (bytes32);\r\n}\r\n\r\ncontract Initializable {\r\n    bool private initialized = false;\r\n\r\n    modifier afterInitialized {\r\n        require(initialized);\r\n        _;\r\n    }\r\n\r\n    modifier beforeInitialized {\r\n        require(!initialized);\r\n        _;\r\n    }\r\n\r\n    function endInitialization() internal beforeInitialized returns (bool) {\r\n        initialized = true;\r\n        return true;\r\n    }\r\n\r\n    function getInitialized() public view returns (bool) {\r\n        return initialized;\r\n    }\r\n}\r\n\r\nlibrary SafeMathUint256 {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a <= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a >= b) {\r\n            return a;\r\n        } else {\r\n            return b;\r\n        }\r\n    }\r\n\r\n    function getUint256Min() internal pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function getUint256Max() internal pure returns (uint256) {\r\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    }\r\n\r\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\r\n        return a % b == 0;\r\n    }\r\n\r\n    // Float [fixed point] Operations\r\n    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\r\n        return div(mul(a, b), base);\r\n    }\r\n\r\n    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\r\n        return div(mul(a, base), b);\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function totalSupply() public view returns (uint256);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function approve(address _spender, uint256 _value) public returns (bool);\r\n}\r\n\r\ncontract IFeeToken is ERC20, Initializable {\r\n    function initialize(IFeeWindow _feeWindow) public returns (bool);\r\n    function getFeeWindow() public view returns (IFeeWindow);\r\n    function feeWindowBurn(address _target, uint256 _amount) public returns (bool);\r\n    function mintForReportingParticipant(address _target, uint256 _amount) public returns (bool);\r\n}\r\n\r\ncontract IFeeWindow is ITyped, ERC20 {\r\n    function initialize(IUniverse _universe, uint256 _feeWindowId) public returns (bool);\r\n    function getUniverse() public view returns (IUniverse);\r\n    function getReputationToken() public view returns (IReputationToken);\r\n    function getStartTime() public view returns (uint256);\r\n    function getEndTime() public view returns (uint256);\r\n    function getNumMarkets() public view returns (uint256);\r\n    function getNumInvalidMarkets() public view returns (uint256);\r\n    function getNumIncorrectDesignatedReportMarkets() public view returns (uint256);\r\n    function getNumDesignatedReportNoShows() public view returns (uint256);\r\n    function getFeeToken() public view returns (IFeeToken);\r\n    function isActive() public view returns (bool);\r\n    function isOver() public view returns (bool);\r\n    function onMarketFinalized() public returns (bool);\r\n    function buy(uint256 _attotokens) public returns (bool);\r\n    function redeem(address _sender) public returns (bool);\r\n    function redeemForReportingParticipant() public returns (bool);\r\n    function mintFeeTokens(uint256 _amount) public returns (bool);\r\n    function trustedUniverseBuy(address _buyer, uint256 _attotokens) public returns (bool);\r\n}\r\n\r\ncontract IMailbox {\r\n    function initialize(address _owner, IMarket _market) public returns (bool);\r\n    function depositEther() public payable returns (bool);\r\n}\r\n\r\ncontract IMarket is ITyped, IOwnable {\r\n    enum MarketType {\r\n        YES_NO,\r\n        CATEGORICAL,\r\n        SCALAR\r\n    }\r\n\r\n    function initialize(IUniverse _universe, uint256 _endTime, uint256 _feePerEthInAttoeth, ICash _cash, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public payable returns (bool _success);\r\n    function derivePayoutDistributionHash(uint256[] _payoutNumerators, bool _invalid) public view returns (bytes32);\r\n    function getUniverse() public view returns (IUniverse);\r\n    function getFeeWindow() public view returns (IFeeWindow);\r\n    function getNumberOfOutcomes() public view returns (uint256);\r\n    function getNumTicks() public view returns (uint256);\r\n    function getDenominationToken() public view returns (ICash);\r\n    function getShareToken(uint256 _outcome)  public view returns (IShareToken);\r\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\r\n    function getForkingMarket() public view returns (IMarket _market);\r\n    function getEndTime() public view returns (uint256);\r\n    function getMarketCreatorMailbox() public view returns (IMailbox);\r\n    function getWinningPayoutDistributionHash() public view returns (bytes32);\r\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\r\n    function getReputationToken() public view returns (IReputationToken);\r\n    function getFinalizationTime() public view returns (uint256);\r\n    function getInitialReporterAddress() public view returns (address);\r\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\r\n    function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);\r\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\r\n    function isInvalid() public view returns (bool);\r\n    function finalize() public returns (bool);\r\n    function designatedReporterWasCorrect() public view returns (bool);\r\n    function designatedReporterShowed() public view returns (bool);\r\n    function isFinalized() public view returns (bool);\r\n    function finalizeFork() public returns (bool);\r\n    function assertBalances() public view returns (bool);\r\n}\r\n\r\ncontract IRepPriceOracle {\r\n    function setRepPriceInAttoEth(uint256 _repPriceInAttoEth) external returns (bool);\r\n    function getRepPriceInAttoEth() external view returns (uint256);\r\n}\r\n\r\ncontract IReportingParticipant {\r\n    function getStake() public view returns (uint256);\r\n    function getPayoutDistributionHash() public view returns (bytes32);\r\n    function liquidateLosing() public returns (bool);\r\n    function redeem(address _redeemer) public returns (bool);\r\n    function isInvalid() public view returns (bool);\r\n    function isDisavowed() public view returns (bool);\r\n    function migrate() public returns (bool);\r\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\r\n    function getMarket() public view returns (IMarket);\r\n    function getSize() public view returns (uint256);\r\n}\r\n\r\ncontract IDisputeCrowdsourcer is IReportingParticipant, ERC20 {\r\n    function initialize(IMarket market, uint256 _size, bytes32 _payoutDistributionHash, uint256[] _payoutNumerators, bool _invalid) public returns (bool);\r\n    function contribute(address _participant, uint256 _amount) public returns (uint256);\r\n}\r\n\r\ncontract IReputationToken is ITyped, ERC20 {\r\n    function initialize(IUniverse _universe) public returns (bool);\r\n    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool);\r\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\r\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\r\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\r\n    function trustedFeeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\r\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\r\n    function getUniverse() public view returns (IUniverse);\r\n    function getTotalMigrated() public view returns (uint256);\r\n    function getTotalTheoreticalSupply() public view returns (uint256);\r\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\r\n}\r\n\r\ncontract IUniverse is ITyped {\r\n    function initialize(IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash) external returns (bool);\r\n    function fork() public returns (bool);\r\n    function getParentUniverse() public view returns (IUniverse);\r\n    function createChildUniverse(uint256[] _parentPayoutNumerators, bool _invalid) public returns (IUniverse);\r\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\r\n    function getReputationToken() public view returns (IReputationToken);\r\n    function getForkingMarket() public view returns (IMarket);\r\n    function getForkEndTime() public view returns (uint256);\r\n    function getForkReputationGoal() public view returns (uint256);\r\n    function getParentPayoutDistributionHash() public view returns (bytes32);\r\n    function getDisputeRoundDurationInSeconds() public view returns (uint256);\r\n    function getOrCreateFeeWindowByTimestamp(uint256 _timestamp) public returns (IFeeWindow);\r\n    function getOrCreateCurrentFeeWindow() public returns (IFeeWindow);\r\n    function getOrCreateNextFeeWindow() public returns (IFeeWindow);\r\n    function getOpenInterestInAttoEth() public view returns (uint256);\r\n    function getRepMarketCapInAttoeth() public view returns (uint256);\r\n    function getTargetRepMarketCapInAttoeth() public view returns (uint256);\r\n    function getOrCacheValidityBond() public returns (uint256);\r\n    function getOrCacheDesignatedReportStake() public returns (uint256);\r\n    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\r\n    function getOrCacheReportingFeeDivisor() public returns (uint256);\r\n    function getDisputeThresholdForFork() public view returns (uint256);\r\n    function getInitialReportMinValue() public view returns (uint256);\r\n    function calculateFloatingValue(uint256 _badMarkets, uint256 _totalMarkets, uint256 _targetDivisor, uint256 _previousValue, uint256 _defaultValue, uint256 _floor) public pure returns (uint256 _newValue);\r\n    function getOrCacheMarketCreationCost() public returns (uint256);\r\n    function getCurrentFeeWindow() public view returns (IFeeWindow);\r\n    function getOrCreateFeeWindowBefore(IFeeWindow _feeWindow) public returns (IFeeWindow);\r\n    function isParentOf(IUniverse _shadyChild) public view returns (bool);\r\n    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\r\n    function isContainerForFeeWindow(IFeeWindow _shadyTarget) public view returns (bool);\r\n    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\r\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\r\n    function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);\r\n    function isContainerForFeeToken(IFeeToken _shadyTarget) public view returns (bool);\r\n    function addMarketTo() public returns (bool);\r\n    function removeMarketFrom() public returns (bool);\r\n    function decrementOpenInterest(uint256 _amount) public returns (bool);\r\n    function decrementOpenInterestFromMarket(uint256 _amount) public returns (bool);\r\n    function incrementOpenInterest(uint256 _amount) public returns (bool);\r\n    function incrementOpenInterestFromMarket(uint256 _amount) public returns (bool);\r\n    function getWinningChildUniverse() public view returns (IUniverse);\r\n    function isForking() public view returns (bool);\r\n}\r\n\r\nlibrary Reporting {\r\n    uint256 private constant DESIGNATED_REPORTING_DURATION_SECONDS = 3 days;\r\n    uint256 private constant DISPUTE_ROUND_DURATION_SECONDS = 7 days;\r\n    uint256 private constant CLAIM_PROCEEDS_WAIT_TIME = 3 days;\r\n    uint256 private constant FORK_DURATION_SECONDS = 60 days;\r\n\r\n    uint256 private constant INITIAL_REP_SUPPLY = 11 * 10 ** 6 * 10 ** 18; // 11 Million REP\r\n\r\n    uint256 private constant DEFAULT_VALIDITY_BOND = 1 ether / 100;\r\n    uint256 private constant VALIDITY_BOND_FLOOR = 1 ether / 100;\r\n    uint256 private constant DEFAULT_REPORTING_FEE_DIVISOR = 100; // 1% fees\r\n    uint256 private constant MAXIMUM_REPORTING_FEE_DIVISOR = 10000; // Minimum .01% fees\r\n    uint256 private constant MINIMUM_REPORTING_FEE_DIVISOR = 3; // Maximum 33.3~% fees. Note than anything less than a value of 2 here will likely result in bugs such as divide by 0 cases.\r\n\r\n    uint256 private constant TARGET_INVALID_MARKETS_DIVISOR = 100; // 1% of markets are expected to be invalid\r\n    uint256 private constant TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR = 100; // 1% of markets are expected to have an incorrect designate report\r\n    uint256 private constant TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR = 100; // 1% of markets are expected to have an incorrect designate report\r\n    uint256 private constant TARGET_REP_MARKET_CAP_MULTIPLIER = 15; // We multiply and divide by constants since we want to multiply by a fractional amount (7.5)\r\n    uint256 private constant TARGET_REP_MARKET_CAP_DIVISOR = 2;\r\n\r\n    uint256 private constant FORK_MIGRATION_PERCENTAGE_BONUS_DIVISOR = 20; // 5% bonus to any REP migrated during a fork\r\n\r\n    function getDesignatedReportingDurationSeconds() internal pure returns (uint256) { return DESIGNATED_REPORTING_DURATION_SECONDS; }\r\n    function getDisputeRoundDurationSeconds() internal pure returns (uint256) { return DISPUTE_ROUND_DURATION_SECONDS; }\r\n    function getClaimTradingProceedsWaitTime() internal pure returns (uint256) { return CLAIM_PROCEEDS_WAIT_TIME; }\r\n    function getForkDurationSeconds() internal pure returns (uint256) { return FORK_DURATION_SECONDS; }\r\n    function getDefaultValidityBond() internal pure returns (uint256) { return DEFAULT_VALIDITY_BOND; }\r\n    function getValidityBondFloor() internal pure returns (uint256) { return VALIDITY_BOND_FLOOR; }\r\n    function getTargetInvalidMarketsDivisor() internal pure returns (uint256) { return TARGET_INVALID_MARKETS_DIVISOR; }\r\n    function getTargetIncorrectDesignatedReportMarketsDivisor() internal pure returns (uint256) { return TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR; }\r\n    function getTargetDesignatedReportNoShowsDivisor() internal pure returns (uint256) { return TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR; }\r\n    function getTargetRepMarketCapMultiplier() internal pure returns (uint256) { return TARGET_REP_MARKET_CAP_MULTIPLIER; }\r\n    function getTargetRepMarketCapDivisor() internal pure returns (uint256) { return TARGET_REP_MARKET_CAP_DIVISOR; }\r\n    function getForkMigrationPercentageBonusDivisor() internal pure returns (uint256) { return FORK_MIGRATION_PERCENTAGE_BONUS_DIVISOR; }\r\n    function getMaximumReportingFeeDivisor() internal pure returns (uint256) { return MAXIMUM_REPORTING_FEE_DIVISOR; }\r\n    function getMinimumReportingFeeDivisor() internal pure returns (uint256) { return MINIMUM_REPORTING_FEE_DIVISOR; }\r\n    function getDefaultReportingFeeDivisor() internal pure returns (uint256) { return DEFAULT_REPORTING_FEE_DIVISOR; }\r\n    function getInitialREPSupply() internal pure returns (uint256) { return INITIAL_REP_SUPPLY; }\r\n}\r\n\r\ncontract Universe is DelegationTarget, ITyped, Initializable, IUniverse {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    IUniverse private parentUniverse;\r\n    bytes32 private parentPayoutDistributionHash;\r\n    IReputationToken private reputationToken;\r\n    IMarket private forkingMarket;\r\n    bytes32 private tentativeWinningChildUniversePayoutDistributionHash;\r\n    uint256 private forkEndTime;\r\n    uint256 private forkReputationGoal;\r\n    uint256 private disputeThresholdForFork;\r\n    uint256 private initialReportMinValue;\r\n    mapping(uint256 => IFeeWindow) private feeWindows;\r\n    mapping(address => bool) private markets;\r\n    mapping(bytes32 => IUniverse) private childUniverses;\r\n    uint256 private openInterestInAttoEth;\r\n\r\n    mapping (address => uint256) private validityBondInAttoeth;\r\n    mapping (address => uint256) private targetReporterGasCosts;\r\n    mapping (address => uint256) private designatedReportStakeInAttoRep;\r\n    mapping (address => uint256) private designatedReportNoShowBondInAttoRep;\r\n    mapping (address => uint256) private shareSettlementFeeDivisor;\r\n\r\n    function initialize(IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash) external onlyInGoodTimes beforeInitialized returns (bool) {\r\n        endInitialization();\r\n        parentUniverse = _parentUniverse;\r\n        parentPayoutDistributionHash = _parentPayoutDistributionHash;\r\n        reputationToken = ReputationTokenFactory(controller.lookup(\"ReputationTokenFactory\")).createReputationToken(controller, this);\r\n        updateForkValues();\r\n        require(reputationToken != address(0));\r\n        return true;\r\n    }\r\n\r\n    function fork() public onlyInGoodTimes afterInitialized returns (bool) {\r\n        require(!isForking());\r\n        require(isContainerForMarket(IMarket(msg.sender)));\r\n        forkingMarket = IMarket(msg.sender);\r\n        forkEndTime = controller.getTimestamp().add(Reporting.getForkDurationSeconds());\r\n        controller.getAugur().logUniverseForked();\r\n        return true;\r\n    }\r\n\r\n    function updateForkValues() public returns (bool) {\r\n        uint256 _totalRepSupply = reputationToken.getTotalTheoreticalSupply();\r\n        forkReputationGoal = _totalRepSupply.div(2); // 50% of REP migrating results in a victory in a fork\r\n        disputeThresholdForFork = _totalRepSupply.div(40); // 2.5% of the total rep supply\r\n        initialReportMinValue = disputeThresholdForFork.div(3).div(2**18).add(1); // This value will result in a maximum 20 round dispute sequence\r\n        return true;\r\n    }\r\n\r\n    function getTypeName() public view returns (bytes32) {\r\n        return \"Universe\";\r\n    }\r\n\r\n    function getParentUniverse() public view returns (IUniverse) {\r\n        return parentUniverse;\r\n    }\r\n\r\n    function getParentPayoutDistributionHash() public view returns (bytes32) {\r\n        return parentPayoutDistributionHash;\r\n    }\r\n\r\n    function getReputationToken() public view returns (IReputationToken) {\r\n        return reputationToken;\r\n    }\r\n\r\n    function getForkingMarket() public view returns (IMarket) {\r\n        return forkingMarket;\r\n    }\r\n\r\n    function getForkEndTime() public view returns (uint256) {\r\n        return forkEndTime;\r\n    }\r\n\r\n    function getForkReputationGoal() public view returns (uint256) {\r\n        return forkReputationGoal;\r\n    }\r\n\r\n    function getDisputeThresholdForFork() public view returns (uint256) {\r\n        return disputeThresholdForFork;\r\n    }\r\n\r\n    function getInitialReportMinValue() public view returns (uint256) {\r\n        return initialReportMinValue;\r\n    }\r\n\r\n    function getFeeWindow(uint256 _feeWindowId) public view returns (IFeeWindow) {\r\n        return feeWindows[_feeWindowId];\r\n    }\r\n\r\n    function isForking() public view returns (bool) {\r\n        return forkingMarket != IMarket(0);\r\n    }\r\n\r\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse) {\r\n        return childUniverses[_parentPayoutDistributionHash];\r\n    }\r\n\r\n    function getFeeWindowId(uint256 _timestamp) public view returns (uint256) {\r\n        return _timestamp.div(getDisputeRoundDurationInSeconds());\r\n    }\r\n\r\n    function getDisputeRoundDurationInSeconds() public view returns (uint256) {\r\n        return Reporting.getDisputeRoundDurationSeconds();\r\n    }\r\n\r\n    function getOrCreateFeeWindowByTimestamp(uint256 _timestamp) public onlyInGoodTimes returns (IFeeWindow) {\r\n        uint256 _windowId = getFeeWindowId(_timestamp);\r\n        if (feeWindows[_windowId] == address(0)) {\r\n            IFeeWindow _feeWindow = FeeWindowFactory(controller.lookup(\"FeeWindowFactory\")).createFeeWindow(controller, this, _windowId);\r\n            feeWindows[_windowId] = _feeWindow;\r\n            controller.getAugur().logFeeWindowCreated(_feeWindow, _windowId);\r\n        }\r\n        return feeWindows[_windowId];\r\n    }\r\n\r\n    function getFeeWindowByTimestamp(uint256 _timestamp) public view onlyInGoodTimes returns (IFeeWindow) {\r\n        uint256 _windowId = getFeeWindowId(_timestamp);\r\n        return feeWindows[_windowId];\r\n    }\r\n\r\n    function getOrCreatePreviousPreviousFeeWindow() public onlyInGoodTimes returns (IFeeWindow) {\r\n        return getOrCreateFeeWindowByTimestamp(controller.getTimestamp().sub(getDisputeRoundDurationInSeconds().mul(2)));\r\n    }\r\n\r\n    function getOrCreatePreviousFeeWindow() public onlyInGoodTimes returns (IFeeWindow) {\r\n        return getOrCreateFeeWindowByTimestamp(controller.getTimestamp().sub(getDisputeRoundDurationInSeconds()));\r\n    }\r\n\r\n    function getPreviousFeeWindow() public view onlyInGoodTimes returns (IFeeWindow) {\r\n        return getFeeWindowByTimestamp(controller.getTimestamp().sub(getDisputeRoundDurationInSeconds()));\r\n    }\r\n\r\n    function getOrCreateCurrentFeeWindow() public onlyInGoodTimes returns (IFeeWindow) {\r\n        return getOrCreateFeeWindowByTimestamp(controller.getTimestamp());\r\n    }\r\n\r\n    function getCurrentFeeWindow() public view onlyInGoodTimes returns (IFeeWindow) {\r\n        return getFeeWindowByTimestamp(controller.getTimestamp());\r\n    }\r\n\r\n    function getOrCreateNextFeeWindow() public onlyInGoodTimes returns (IFeeWindow) {\r\n        return getOrCreateFeeWindowByTimestamp(controller.getTimestamp().add(getDisputeRoundDurationInSeconds()));\r\n    }\r\n\r\n    function getNextFeeWindow() public view onlyInGoodTimes returns (IFeeWindow) {\r\n        return getFeeWindowByTimestamp(controller.getTimestamp().add(getDisputeRoundDurationInSeconds()));\r\n    }\r\n\r\n    function getOrCreateFeeWindowBefore(IFeeWindow _feeWindow) public onlyInGoodTimes returns (IFeeWindow) {\r\n        return getOrCreateFeeWindowByTimestamp(_feeWindow.getStartTime().sub(2));\r\n    }\r\n\r\n    function createChildUniverse(uint256[] _parentPayoutNumerators, bool _parentInvalid) public returns (IUniverse) {\r\n        bytes32 _parentPayoutDistributionHash = forkingMarket.derivePayoutDistributionHash(_parentPayoutNumerators, _parentInvalid);\r\n        IUniverse _childUniverse = getChildUniverse(_parentPayoutDistributionHash);\r\n        IAugur _augur = controller.getAugur();\r\n        if (_childUniverse == IUniverse(0)) {\r\n            _childUniverse = _augur.createChildUniverse(_parentPayoutDistributionHash, _parentPayoutNumerators, _parentInvalid);\r\n            childUniverses[_parentPayoutDistributionHash] = _childUniverse;\r\n        }\r\n        return _childUniverse;\r\n    }\r\n\r\n    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool) {\r\n        IUniverse _tentativeWinningUniverse = getChildUniverse(tentativeWinningChildUniversePayoutDistributionHash);\r\n        IUniverse _updatedUniverse = getChildUniverse(_parentPayoutDistributionHash);\r\n        uint256 _currentTentativeWinningChildUniverseRepMigrated = 0;\r\n        if (_tentativeWinningUniverse != IUniverse(0)) {\r\n            _currentTentativeWinningChildUniverseRepMigrated = _tentativeWinningUniverse.getReputationToken().getTotalMigrated();\r\n        }\r\n        uint256 _updatedUniverseRepMigrated = _updatedUniverse.getReputationToken().getTotalMigrated();\r\n        if (_updatedUniverseRepMigrated > _currentTentativeWinningChildUniverseRepMigrated) {\r\n            tentativeWinningChildUniversePayoutDistributionHash = _parentPayoutDistributionHash;\r\n        }\r\n        if (_updatedUniverseRepMigrated >= forkReputationGoal) {\r\n            forkingMarket.finalizeFork();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getWinningChildUniverse() public view returns (IUniverse) {\r\n        require(isForking());\r\n        require(tentativeWinningChildUniversePayoutDistributionHash != bytes32(0));\r\n        IUniverse _tentativeWinningUniverse = getChildUniverse(tentativeWinningChildUniversePayoutDistributionHash);\r\n        uint256 _winningAmount = _tentativeWinningUniverse.getReputationToken().getTotalMigrated();\r\n        require(_winningAmount >= forkReputationGoal || controller.getTimestamp() > forkEndTime);\r\n        return _tentativeWinningUniverse;\r\n    }\r\n\r\n    function isContainerForFeeWindow(IFeeWindow _shadyFeeWindow) public view returns (bool) {\r\n        uint256 _startTime = _shadyFeeWindow.getStartTime();\r\n        if (_startTime == 0) {\r\n            return false;\r\n        }\r\n        uint256 _feeWindowId = getFeeWindowId(_startTime);\r\n        IFeeWindow _legitFeeWindow = feeWindows[_feeWindowId];\r\n        return _shadyFeeWindow == _legitFeeWindow;\r\n    }\r\n\r\n    function isContainerForFeeToken(IFeeToken _shadyFeeToken) public view returns (bool) {\r\n        IFeeWindow _shadyFeeWindow = _shadyFeeToken.getFeeWindow();\r\n        require(isContainerForFeeWindow(_shadyFeeWindow));\r\n        IFeeWindow _legitFeeWindow = _shadyFeeWindow;\r\n        return _legitFeeWindow.getFeeToken() == _shadyFeeToken;\r\n    }\r\n\r\n    function isContainerForMarket(IMarket _shadyMarket) public view returns (bool) {\r\n        return markets[address(_shadyMarket)];\r\n    }\r\n\r\n    function addMarketTo() public returns (bool) {\r\n        require(parentUniverse.isContainerForMarket(IMarket(msg.sender)));\r\n        markets[msg.sender] = true;\r\n        controller.getAugur().logMarketMigrated(IMarket(msg.sender), parentUniverse);\r\n        return true;\r\n    }\r\n\r\n    function removeMarketFrom() public returns (bool) {\r\n        require(isContainerForMarket(IMarket(msg.sender)));\r\n        markets[msg.sender] = false;\r\n        return true;\r\n    }\r\n\r\n    function isContainerForShareToken(IShareToken _shadyShareToken) public view returns (bool) {\r\n        IMarket _shadyMarket = _shadyShareToken.getMarket();\r\n        if (_shadyMarket == address(0)) {\r\n            return false;\r\n        }\r\n        if (!isContainerForMarket(_shadyMarket)) {\r\n            return false;\r\n        }\r\n        IMarket _legitMarket = _shadyMarket;\r\n        return _legitMarket.isContainerForShareToken(_shadyShareToken);\r\n    }\r\n\r\n    function isContainerForReportingParticipant(IReportingParticipant _shadyReportingParticipant) public view returns (bool) {\r\n        IMarket _shadyMarket = _shadyReportingParticipant.getMarket();\r\n        if (_shadyMarket == address(0)) {\r\n            return false;\r\n        }\r\n        if (!isContainerForMarket(_shadyMarket)) {\r\n            return false;\r\n        }\r\n        IMarket _legitMarket = _shadyMarket;\r\n        return _legitMarket.isContainerForReportingParticipant(_shadyReportingParticipant);\r\n    }\r\n\r\n    function isParentOf(IUniverse _shadyChild) public view returns (bool) {\r\n        bytes32 _parentPayoutDistributionHash = _shadyChild.getParentPayoutDistributionHash();\r\n        return getChildUniverse(_parentPayoutDistributionHash) == _shadyChild;\r\n    }\r\n\r\n    function decrementOpenInterest(uint256 _amount) public onlyInGoodTimes onlyWhitelistedCallers returns (bool) {\r\n        openInterestInAttoEth = openInterestInAttoEth.sub(_amount);\r\n        return true;\r\n    }\r\n\r\n    function decrementOpenInterestFromMarket(uint256 _amount) public returns (bool) {\r\n        require(isContainerForMarket(IMarket(msg.sender)));\r\n        openInterestInAttoEth = openInterestInAttoEth.sub(_amount);\r\n        return true;\r\n    }\r\n\r\n    function incrementOpenInterest(uint256 _amount) public onlyInGoodTimes onlyWhitelistedCallers returns (bool) {\r\n        openInterestInAttoEth = openInterestInAttoEth.add(_amount);\r\n        return true;\r\n    }\r\n\r\n    function incrementOpenInterestFromMarket(uint256 _amount) public onlyInGoodTimes returns (bool) {\r\n        require(isContainerForMarket(IMarket(msg.sender)));\r\n        openInterestInAttoEth = openInterestInAttoEth.add(_amount);\r\n        return true;\r\n    }\r\n\r\n    function getOpenInterestInAttoEth() public view returns (uint256) {\r\n        return openInterestInAttoEth;\r\n    }\r\n\r\n    function getRepMarketCapInAttoeth() public view returns (uint256) {\r\n        uint256 _attorepPerEth = IRepPriceOracle(controller.lookup(\"RepPriceOracle\")).getRepPriceInAttoEth();\r\n        uint256 _repMarketCapInAttoeth = getReputationToken().totalSupply().mul(_attorepPerEth);\r\n        return _repMarketCapInAttoeth;\r\n    }\r\n\r\n    function getTargetRepMarketCapInAttoeth() public view returns (uint256) {\r\n        return getOpenInterestInAttoEth().mul(Reporting.getTargetRepMarketCapMultiplier()).div(Reporting.getTargetRepMarketCapDivisor());\r\n    }\r\n\r\n    function getOrCacheValidityBond() public onlyInGoodTimes returns (uint256) {\r\n        IFeeWindow _feeWindow = getOrCreateCurrentFeeWindow();\r\n        IFeeWindow  _previousFeeWindow = getOrCreatePreviousPreviousFeeWindow();\r\n        uint256 _currentValidityBondInAttoeth = validityBondInAttoeth[_feeWindow];\r\n        if (_currentValidityBondInAttoeth != 0) {\r\n            return _currentValidityBondInAttoeth;\r\n        }\r\n        uint256 _totalMarketsInPreviousWindow = _previousFeeWindow.getNumMarkets();\r\n        uint256 _invalidMarketsInPreviousWindow = _previousFeeWindow.getNumInvalidMarkets();\r\n        uint256 _previousValidityBondInAttoeth = validityBondInAttoeth[_previousFeeWindow];\r\n        _currentValidityBondInAttoeth = calculateFloatingValue(_invalidMarketsInPreviousWindow, _totalMarketsInPreviousWindow, Reporting.getTargetInvalidMarketsDivisor(), _previousValidityBondInAttoeth, Reporting.getDefaultValidityBond(), Reporting.getValidityBondFloor());\r\n        validityBondInAttoeth[_feeWindow] = _currentValidityBondInAttoeth;\r\n        return _currentValidityBondInAttoeth;\r\n    }\r\n\r\n    function getOrCacheDesignatedReportStake() public onlyInGoodTimes returns (uint256) {\r\n        IFeeWindow _feeWindow = getOrCreateCurrentFeeWindow();\r\n        IFeeWindow _previousFeeWindow = getOrCreatePreviousPreviousFeeWindow();\r\n        uint256 _currentDesignatedReportStakeInAttoRep = designatedReportStakeInAttoRep[_feeWindow];\r\n        if (_currentDesignatedReportStakeInAttoRep != 0) {\r\n            return _currentDesignatedReportStakeInAttoRep;\r\n        }\r\n        uint256 _totalMarketsInPreviousWindow = _previousFeeWindow.getNumMarkets();\r\n        uint256 _incorrectDesignatedReportMarketsInPreviousWindow = _previousFeeWindow.getNumIncorrectDesignatedReportMarkets();\r\n        uint256 _previousDesignatedReportStakeInAttoRep = designatedReportStakeInAttoRep[_previousFeeWindow];\r\n\r\n        _currentDesignatedReportStakeInAttoRep = calculateFloatingValue(_incorrectDesignatedReportMarketsInPreviousWindow, _totalMarketsInPreviousWindow, Reporting.getTargetIncorrectDesignatedReportMarketsDivisor(), _previousDesignatedReportStakeInAttoRep, initialReportMinValue, initialReportMinValue);\r\n        designatedReportStakeInAttoRep[_feeWindow] = _currentDesignatedReportStakeInAttoRep;\r\n        return _currentDesignatedReportStakeInAttoRep;\r\n    }\r\n\r\n    function getOrCacheDesignatedReportNoShowBond() public onlyInGoodTimes returns (uint256) {\r\n        IFeeWindow _feeWindow = getOrCreateCurrentFeeWindow();\r\n        IFeeWindow _previousFeeWindow = getOrCreatePreviousPreviousFeeWindow();\r\n        uint256 _currentDesignatedReportNoShowBondInAttoRep = designatedReportNoShowBondInAttoRep[_feeWindow];\r\n        if (_currentDesignatedReportNoShowBondInAttoRep != 0) {\r\n            return _currentDesignatedReportNoShowBondInAttoRep;\r\n        }\r\n        uint256 _totalMarketsInPreviousWindow = _previousFeeWindow.getNumMarkets();\r\n        uint256 _designatedReportNoShowsInPreviousWindow = _previousFeeWindow.getNumDesignatedReportNoShows();\r\n        uint256 _previousDesignatedReportNoShowBondInAttoRep = designatedReportNoShowBondInAttoRep[_previousFeeWindow];\r\n\r\n        _currentDesignatedReportNoShowBondInAttoRep = calculateFloatingValue(_designatedReportNoShowsInPreviousWindow, _totalMarketsInPreviousWindow, Reporting.getTargetDesignatedReportNoShowsDivisor(), _previousDesignatedReportNoShowBondInAttoRep, initialReportMinValue, initialReportMinValue);\r\n        designatedReportNoShowBondInAttoRep[_feeWindow] = _currentDesignatedReportNoShowBondInAttoRep;\r\n        return _currentDesignatedReportNoShowBondInAttoRep;\r\n    }\r\n\r\n    function calculateFloatingValue(uint256 _badMarkets, uint256 _totalMarkets, uint256 _targetDivisor, uint256 _previousValue, uint256 _defaultValue, uint256 _floor) public pure returns (uint256 _newValue) {\r\n        if (_totalMarkets == 0) {\r\n            return _defaultValue;\r\n        }\r\n        if (_previousValue == 0) {\r\n            _previousValue = _defaultValue;\r\n        }\r\n\r\n        // Modify the amount based on the previous amount and the number of markets fitting the failure criteria. We want the amount to be somewhere in the range of 0.5 to 2 times its previous value where ALL markets with the condition results in 2x and 0 results in 0.5x.\r\n        // Safe math div is redundant so we avoid here as we're at the stack limit.\r\n        if (_badMarkets <= _totalMarkets / _targetDivisor) {\r\n            // FXP formula: previous_amount * actual_percent / (2 * target_percent) + 0.5;\r\n            _newValue = _badMarkets\r\n                .mul(_previousValue)\r\n                .mul(_targetDivisor);\r\n            _newValue = _newValue / _totalMarkets;\r\n            _newValue = _newValue / 2;\r\n            _newValue = _newValue.add(_previousValue / 2);\r\n        } else {\r\n            // FXP formula: previous_amount * (1/(1 - target_percent)) * (actual_percent - target_percent) + 1;\r\n            _newValue = _targetDivisor\r\n                .mul(_previousValue\r\n                    .mul(_badMarkets)\r\n                    .div(_totalMarkets)\r\n                .sub(_previousValue / _targetDivisor));\r\n            _newValue = _newValue / (_targetDivisor - 1);\r\n            _newValue = _newValue.add(_previousValue);\r\n        }\r\n        _newValue = _newValue.max(_floor);\r\n\r\n        return _newValue;\r\n    }\r\n\r\n    function getOrCacheReportingFeeDivisor() public onlyInGoodTimes returns (uint256) {\r\n        IFeeWindow _feeWindow = getOrCreateCurrentFeeWindow();\r\n        IFeeWindow _previousFeeWindow = getOrCreatePreviousFeeWindow();\r\n        uint256 _currentFeeDivisor = shareSettlementFeeDivisor[_feeWindow];\r\n        if (_currentFeeDivisor != 0) {\r\n            return _currentFeeDivisor;\r\n        }\r\n        uint256 _repMarketCapInAttoeth = getRepMarketCapInAttoeth();\r\n        uint256 _targetRepMarketCapInAttoeth = getTargetRepMarketCapInAttoeth();\r\n        uint256 _previousFeeDivisor = shareSettlementFeeDivisor[_previousFeeWindow];\r\n        if (_previousFeeDivisor == 0) {\r\n            _currentFeeDivisor = Reporting.getDefaultReportingFeeDivisor();\r\n        } else if (_targetRepMarketCapInAttoeth == 0) {\r\n            _currentFeeDivisor = Reporting.getDefaultReportingFeeDivisor();\r\n        } else {\r\n            _currentFeeDivisor = _previousFeeDivisor.mul(_repMarketCapInAttoeth).div(_targetRepMarketCapInAttoeth);\r\n        }\r\n\r\n        _currentFeeDivisor = _currentFeeDivisor\r\n            .max(Reporting.getMinimumReportingFeeDivisor())\r\n            .min(Reporting.getMaximumReportingFeeDivisor());\r\n\r\n        shareSettlementFeeDivisor[_feeWindow] = _currentFeeDivisor;\r\n        return _currentFeeDivisor;\r\n    }\r\n\r\n    function getOrCacheMarketCreationCost() public onlyInGoodTimes returns (uint256) {\r\n        return getOrCacheValidityBond();\r\n    }\r\n\r\n    function getInitialReportStakeSize() public onlyInGoodTimes returns (uint256) {\r\n        return getOrCacheDesignatedReportNoShowBond().max(getOrCacheDesignatedReportStake());\r\n    }\r\n\r\n    function createYesNoMarket(uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, bytes32 _topic, string _description, string _extraInfo) public onlyInGoodTimes afterInitialized payable returns (IMarket _newMarket) {\r\n        require(bytes(_description).length > 0);\r\n        _newMarket = createMarketInternal(_endTime, _feePerEthInWei, _denominationToken, _designatedReporterAddress, msg.sender, 2, 10000);\r\n        controller.getAugur().logMarketCreated(_topic, _description, _extraInfo, this, _newMarket, msg.sender, 0, 1 ether, IMarket.MarketType.YES_NO);\r\n        return _newMarket;\r\n    }\r\n\r\n    function createCategoricalMarket(uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, bytes32[] _outcomes, bytes32 _topic, string _description, string _extraInfo) public onlyInGoodTimes afterInitialized payable returns (IMarket _newMarket) {\r\n        require(bytes(_description).length > 0);\r\n        _newMarket = createMarketInternal(_endTime, _feePerEthInWei, _denominationToken, _designatedReporterAddress, msg.sender, uint256(_outcomes.length), 10000);\r\n        controller.getAugur().logMarketCreated(_topic, _description, _extraInfo, this, _newMarket, msg.sender, _outcomes, 0, 1 ether, IMarket.MarketType.CATEGORICAL);\r\n        return _newMarket;\r\n    }\r\n\r\n    function createScalarMarket(uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, int256 _minPrice, int256 _maxPrice, uint256 _numTicks, bytes32 _topic, string _description, string _extraInfo) public onlyInGoodTimes afterInitialized payable returns (IMarket _newMarket) {\r\n        require(bytes(_description).length > 0);\r\n        require(_minPrice < _maxPrice);\r\n        require(_numTicks.isMultipleOf(2));\r\n        _newMarket = createMarketInternal(_endTime, _feePerEthInWei, _denominationToken, _designatedReporterAddress, msg.sender, 2, _numTicks);\r\n        controller.getAugur().logMarketCreated(_topic, _description, _extraInfo, this, _newMarket, msg.sender, _minPrice, _maxPrice, IMarket.MarketType.SCALAR);\r\n        return _newMarket;\r\n    }\r\n\r\n    function createMarketInternal(uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, address _sender, uint256 _numOutcomes, uint256 _numTicks) private onlyInGoodTimes afterInitialized returns (IMarket _newMarket) {\r\n        MarketFactory _marketFactory = MarketFactory(controller.lookup(\"MarketFactory\"));\r\n        getReputationToken().trustedUniverseTransfer(_sender, _marketFactory, getOrCacheDesignatedReportNoShowBond());\r\n        _newMarket = _marketFactory.createMarket.value(msg.value)(controller, this, _endTime, _feePerEthInWei, _denominationToken, _designatedReporterAddress, _sender, _numOutcomes, _numTicks);\r\n        markets[address(_newMarket)] = true;\r\n        return _newMarket;\r\n    }\r\n\r\n    function redeemStake(IReportingParticipant[] _reportingParticipants, IFeeWindow[] _feeWindows) public onlyInGoodTimes returns (bool) {\r\n        for (uint256 i=0; i < _reportingParticipants.length; i++) {\r\n            _reportingParticipants[i].redeem(msg.sender);\r\n        }\r\n\r\n        for (uint256 k=0; k < _feeWindows.length; k++) {\r\n            _feeWindows[k].redeem(msg.sender);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function buyParticipationTokens(uint256 _attotokens) public onlyInGoodTimes returns (bool) {\r\n        IFeeWindow _feeWindow = getOrCreateCurrentFeeWindow();\r\n        _feeWindow.trustedUniverseBuy(msg.sender, _attotokens);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ICash is ERC20 {\r\n    function depositEther() external payable returns(bool);\r\n    function depositEtherFor(address _to) external payable returns(bool);\r\n    function withdrawEther(uint256 _amount) external returns(bool);\r\n    function withdrawEtherTo(address _to, uint256 _amount) external returns(bool);\r\n    function withdrawEtherToIfPossible(address _to, uint256 _amount) external returns (bool);\r\n}\r\n\r\ncontract IOrders {\r\n    function saveOrder(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _betterOrderId, bytes32 _worseOrderId, bytes32 _tradeGroupId) public returns (bytes32 _orderId);\r\n    function removeOrder(bytes32 _orderId) public returns (bool);\r\n    function getMarket(bytes32 _orderId) public view returns (IMarket);\r\n    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\r\n    function getOutcome(bytes32 _orderId) public view returns (uint256);\r\n    function getAmount(bytes32 _orderId) public view returns (uint256);\r\n    function getPrice(bytes32 _orderId) public view returns (uint256);\r\n    function getOrderCreator(bytes32 _orderId) public view returns (address);\r\n    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\r\n    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\r\n    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\r\n    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\r\n    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\r\n    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\r\n    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\r\n    function getOrderId(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\r\n    function getTotalEscrowed(IMarket _market) public view returns (uint256);\r\n    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\r\n    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\r\n    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\r\n    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\r\n    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled) public returns (bool);\r\n    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\r\n    function incrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);\r\n    function decrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);\r\n}\r\n\r\ncontract IShareToken is ITyped, ERC20 {\r\n    function initialize(IMarket _market, uint256 _outcome) external returns (bool);\r\n    function createShares(address _owner, uint256 _amount) external returns (bool);\r\n    function destroyShares(address, uint256 balance) external returns (bool);\r\n    function getMarket() external view returns (IMarket);\r\n    function getOutcome() external view returns (uint256);\r\n    function trustedOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\r\n    function trustedFillOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\r\n    function trustedCancelOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\r\n}\r\n\r\nlibrary Order {\r\n    using SafeMathUint256 for uint256;\r\n\r\n    enum Types {\r\n        Bid, Ask\r\n    }\r\n\r\n    enum TradeDirections {\r\n        Long, Short\r\n    }\r\n\r\n    struct Data {\r\n        // Contracts\r\n        IOrders orders;\r\n        IMarket market;\r\n        IAugur augur;\r\n\r\n        // Order\r\n        bytes32 id;\r\n        address creator;\r\n        uint256 outcome;\r\n        Order.Types orderType;\r\n        uint256 amount;\r\n        uint256 price;\r\n        uint256 sharesEscrowed;\r\n        uint256 moneyEscrowed;\r\n        bytes32 betterOrderId;\r\n        bytes32 worseOrderId;\r\n    }\r\n\r\n    //\r\n    // Constructor\r\n    //\r\n\r\n    // No validation is needed here as it is simply a librarty function for organizing data\r\n    function create(IController _controller, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data) {\r\n        require(_outcome < _market.getNumberOfOutcomes());\r\n        require(_price < _market.getNumTicks());\r\n\r\n        IOrders _orders = IOrders(_controller.lookup(\"Orders\"));\r\n        IAugur _augur = _controller.getAugur();\r\n\r\n        return Data({\r\n            orders: _orders,\r\n            market: _market,\r\n            augur: _augur,\r\n            id: 0,\r\n            creator: _creator,\r\n            outcome: _outcome,\r\n            orderType: _type,\r\n            amount: _attoshares,\r\n            price: _price,\r\n            sharesEscrowed: 0,\r\n            moneyEscrowed: 0,\r\n            betterOrderId: _betterOrderId,\r\n            worseOrderId: _worseOrderId\r\n        });\r\n    }\r\n\r\n    //\r\n    // \"public\" functions\r\n    //\r\n\r\n    function getOrderId(Order.Data _orderData) internal view returns (bytes32) {\r\n        if (_orderData.id == bytes32(0)) {\r\n            bytes32 _orderId = _orderData.orders.getOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\r\n            require(_orderData.orders.getAmount(_orderId) == 0);\r\n            _orderData.id = _orderId;\r\n        }\r\n        return _orderData.id;\r\n    }\r\n\r\n    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\r\n        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\r\n    }\r\n\r\n    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\r\n        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\r\n    }\r\n\r\n    function escrowFunds(Order.Data _orderData) internal returns (bool) {\r\n        if (_orderData.orderType == Order.Types.Ask) {\r\n            return escrowFundsForAsk(_orderData);\r\n        } else if (_orderData.orderType == Order.Types.Bid) {\r\n            return escrowFundsForBid(_orderData);\r\n        }\r\n    }\r\n\r\n    function saveOrder(Order.Data _orderData, bytes32 _tradeGroupId) internal returns (bytes32) {\r\n        return _orderData.orders.saveOrder(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed, _orderData.betterOrderId, _orderData.worseOrderId, _tradeGroupId);\r\n    }\r\n\r\n    //\r\n    // Private functions\r\n    //\r\n\r\n    function escrowFundsForBid(Order.Data _orderData) private returns (bool) {\r\n        require(_orderData.moneyEscrowed == 0);\r\n        require(_orderData.sharesEscrowed == 0);\r\n        uint256 _attosharesToCover = _orderData.amount;\r\n        uint256 _numberOfOutcomes = _orderData.market.getNumberOfOutcomes();\r\n\r\n        // Figure out how many almost-complete-sets (just missing `outcome` share) the creator has\r\n        uint256 _attosharesHeld = 2**254;\r\n        for (uint256 _i = 0; _i < _numberOfOutcomes; _i++) {\r\n            if (_i != _orderData.outcome) {\r\n                uint256 _creatorShareTokenBalance = _orderData.market.getShareToken(_i).balanceOf(_orderData.creator);\r\n                _attosharesHeld = SafeMathUint256.min(_creatorShareTokenBalance, _attosharesHeld);\r\n            }\r\n        }\r\n\r\n        // Take shares into escrow if they have any almost-complete-sets\r\n        if (_attosharesHeld > 0) {\r\n            _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);\r\n            _attosharesToCover -= _orderData.sharesEscrowed;\r\n            for (_i = 0; _i < _numberOfOutcomes; _i++) {\r\n                if (_i != _orderData.outcome) {\r\n                    _orderData.market.getShareToken(_i).trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);\r\n                }\r\n            }\r\n        }\r\n        // If not able to cover entire order with shares alone, then cover remaining with tokens\r\n        if (_attosharesToCover > 0) {\r\n            _orderData.moneyEscrowed = _attosharesToCover.mul(_orderData.price);\r\n            require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function escrowFundsForAsk(Order.Data _orderData) private returns (bool) {\r\n        require(_orderData.moneyEscrowed == 0);\r\n        require(_orderData.sharesEscrowed == 0);\r\n        IShareToken _shareToken = _orderData.market.getShareToken(_orderData.outcome);\r\n        uint256 _attosharesToCover = _orderData.amount;\r\n\r\n        // Figure out how many shares of the outcome the creator has\r\n        uint256 _attosharesHeld = _shareToken.balanceOf(_orderData.creator);\r\n\r\n        // Take shares in escrow if user has shares\r\n        if (_attosharesHeld > 0) {\r\n            _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);\r\n            _attosharesToCover -= _orderData.sharesEscrowed;\r\n            _shareToken.trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);\r\n        }\r\n\r\n        // If not able to cover entire order with shares alone, then cover remaining with tokens\r\n        if (_attosharesToCover > 0) {\r\n            _orderData.moneyEscrowed = _orderData.market.getNumTicks().sub(_orderData.price).mul(_attosharesToCover);\r\n            require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));\r\n        }\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"incrementOpenInterestFromMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCreateNextFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decrementOpenInterestFromMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRepMarketCapInAttoeth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCreatePreviousFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shadyFeeToken\",\"type\":\"address\"}],\"name\":\"isContainerForFeeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeRoundDurationInSeconds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_feeWindowId\",\"type\":\"uint256\"}],\"name\":\"getFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fork\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTargetRepMarketCapInAttoeth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCreatePreviousPreviousFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shadyShareToken\",\"type\":\"address\"}],\"name\":\"isContainerForShareToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_attotokens\",\"type\":\"uint256\"}],\"name\":\"buyParticipationTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_badMarkets\",\"type\":\"uint256\"},{\"name\":\"_totalMarkets\",\"type\":\"uint256\"},{\"name\":\"_targetDivisor\",\"type\":\"uint256\"},{\"name\":\"_previousValue\",\"type\":\"uint256\"},{\"name\":\"_defaultValue\",\"type\":\"uint256\"},{\"name\":\"_floor\",\"type\":\"uint256\"}],\"name\":\"calculateFloatingValue\",\"outputs\":[{\"name\":\"_newValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitialReportMinValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCreateCurrentFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpenInterestInAttoEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPreviousFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinningChildUniverse\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_feePerEthInWei\",\"type\":\"uint256\"},{\"name\":\"_denominationToken\",\"type\":\"address\"},{\"name\":\"_designatedReporterAddress\",\"type\":\"address\"},{\"name\":\"_minPrice\",\"type\":\"int256\"},{\"name\":\"_maxPrice\",\"type\":\"int256\"},{\"name\":\"_numTicks\",\"type\":\"uint256\"},{\"name\":\"_topic\",\"type\":\"bytes32\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_extraInfo\",\"type\":\"string\"}],\"name\":\"createScalarMarket\",\"outputs\":[{\"name\":\"_newMarket\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeMarketFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getForkEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getForkReputationGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reportingParticipants\",\"type\":\"address[]\"},{\"name\":\"_feeWindows\",\"type\":\"address[]\"}],\"name\":\"redeemStake\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCacheReportingFeeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shadyChild\",\"type\":\"address\"}],\"name\":\"isParentOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateForkValues\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shadyMarket\",\"type\":\"address\"}],\"name\":\"isContainerForMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParentUniverse\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getFeeWindowByTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCacheValidityBond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getInitialReportStakeSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decrementOpenInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getOrCreateFeeWindowByTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReputationToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentUniverse\",\"type\":\"address\"},{\"name\":\"_parentPayoutDistributionHash\",\"type\":\"bytes32\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isForking\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllerLookupName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParentPayoutDistributionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shadyFeeWindow\",\"type\":\"address\"}],\"name\":\"isContainerForFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_feePerEthInWei\",\"type\":\"uint256\"},{\"name\":\"_denominationToken\",\"type\":\"address\"},{\"name\":\"_designatedReporterAddress\",\"type\":\"address\"},{\"name\":\"_topic\",\"type\":\"bytes32\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_extraInfo\",\"type\":\"string\"}],\"name\":\"createYesNoMarket\",\"outputs\":[{\"name\":\"_newMarket\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getForkingMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"incrementOpenInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_feePerEthInWei\",\"type\":\"uint256\"},{\"name\":\"_denominationToken\",\"type\":\"address\"},{\"name\":\"_designatedReporterAddress\",\"type\":\"address\"},{\"name\":\"_outcomes\",\"type\":\"bytes32[]\"},{\"name\":\"_topic\",\"type\":\"bytes32\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_extraInfo\",\"type\":\"string\"}],\"name\":\"createCategoricalMarket\",\"outputs\":[{\"name\":\"_newMarket\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getFeeWindowId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTypeName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentPayoutNumerators\",\"type\":\"uint256[]\"},{\"name\":\"_parentInvalid\",\"type\":\"bool\"}],\"name\":\"createChildUniverse\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeWindow\",\"type\":\"address\"}],\"name\":\"getOrCreateFeeWindowBefore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCacheDesignatedReportStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCacheMarketCreationCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_parentPayoutDistributionHash\",\"type\":\"bytes32\"}],\"name\":\"getChildUniverse\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextFeeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentPayoutDistributionHash\",\"type\":\"bytes32\"}],\"name\":\"updateTentativeWinningChildUniverse\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shadyReportingParticipant\",\"type\":\"address\"}],\"name\":\"isContainerForReportingParticipant\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDisputeThresholdForFork\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOrCacheDesignatedReportNoShowBond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addMarketTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Universe","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0e2b9ae23c0b9007840d3f6c1bab2efdb81a485ecd92d322ea9877ca86652654"}]}