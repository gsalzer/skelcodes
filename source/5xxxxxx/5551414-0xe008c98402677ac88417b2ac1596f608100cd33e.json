{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath\r\n{\r\n    function mul(uint a, uint b) internal returns (uint)\r\n    {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal returns (uint)\r\n    {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal returns (uint)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64)\r\n    {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256)\r\n    {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function assert(bool assertion) internal\r\n    {\r\n        if (!assertion)\r\n        {\r\n            throw;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Basic\r\n{\r\n    uint public totalSupply;\r\n    function balanceOf(address who) constant returns (uint);\r\n    function transfer(address to, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic\r\n{\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n    function transferFrom(address from, address to, uint value);\r\n    function approve(address spender, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic\r\n{\r\n    using SafeMath for uint;\r\n    mapping(address => uint) balances;\r\n\r\n    /**\r\n     * @dev Fix for the ERC20 short address attack.\r\n     */\r\n    modifier onlyPayloadSize(uint size)\r\n    {\r\n        if(msg.data.length < size + 4)\r\n        {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32)\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint balance)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is BasicToken, ERC20\r\n{\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint the amout of tokens to be transfered\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32)\r\n    {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // if (_value > _allowance) throw;\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint _value)\r\n    {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint specifing the amount of tokens still avaible for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n/**\r\n * @title Sophos ERC20 token\r\n *\r\n * @dev Implementation of the Sophos Token.\r\n */\r\ncontract SophosToken is StandardToken\r\n{\r\n    string public name = \"Sophos\";\r\n    string public symbol = \"SOPH\";\r\n    uint public decimals = 8 ;\r\n\r\n    // Initial supply is 30,000,000.00000000\r\n    // AKA: 3 * (10 ** ( 7 + decimals )) when expressed as uint\r\n    uint public INITIAL_SUPPLY = 3000000000000000;\r\n\r\n    // Allocation Constants\r\n\r\n    // Expiration Unix Timestamp: Friday, November 1, 2019 12:00:00 AM\r\n    // https://www.unixtimestamp.com\r\n    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;\r\n\r\n    address public constant RAVI_ADDRESS = 0xB75066802f677bb5354F0850A1e1d3968E983BE8;\r\n    uint public constant    RAVI_ALLOCATION = 120000000000000; // 4%\r\n\r\n    address public constant JULIAN_ADDRESS = 0xB2A76D747fC4A076D7f4Db3bA91Be97e94beB01C;\r\n    uint public constant    JULIAN_ALLOCATION = 120000000000000; // 4%\r\n\r\n    address  public constant ABDEL_ADDRESS = 0x9894989fd6CaefCcEB183B8eB668B2d5614bEBb6;\r\n    uint public constant     ABDEL_ALLOCATION = 120000000000000; // 4%\r\n\r\n    address public constant ASHLEY_ADDRESS = 0xb37B31f004dD8259F3171Ca5FBD451C03c3bC0Ae;\r\n    uint public constant    ASHLEY_ALLOCATION = 210000000000000; // 7%\r\n\r\n    function SophosToken()\r\n    {\r\n        // Set total supply\r\n        totalSupply = INITIAL_SUPPLY;\r\n\r\n        // Allocate total supply to sender\r\n        balances[msg.sender] = totalSupply;\r\n\r\n        // Subtract team member allocations from total supply\r\n        balances[msg.sender] -= RAVI_ALLOCATION;\r\n        balances[msg.sender] -= JULIAN_ALLOCATION;\r\n        balances[msg.sender] -= ABDEL_ALLOCATION;\r\n        balances[msg.sender] -= ASHLEY_ALLOCATION;\r\n\r\n        // Credit Team Member Allocation Addresses\r\n        balances[RAVI_ADDRESS]   = RAVI_ALLOCATION;\r\n        balances[JULIAN_ADDRESS] = JULIAN_ALLOCATION;\r\n        balances[ABDEL_ADDRESS]  = ABDEL_ALLOCATION;\r\n        balances[ASHLEY_ADDRESS] = ASHLEY_ALLOCATION;\r\n    }\r\n\r\n    // Stop transactions from team member allocations during lock period\r\n    function isAllocationLocked(address _spender) constant returns (bool)\r\n    {\r\n        return inAllocationLockPeriod() && isTeamMember(_spender);\r\n    }\r\n\r\n    // True if the current timestamp is before the allocation lock period\r\n    function inAllocationLockPeriod() constant returns (bool)\r\n    {\r\n        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\r\n    }\r\n\r\n    // Is the spender address one of the Sophos Team?\r\n    function isTeamMember(address _spender) constant returns (bool)\r\n    {\r\n        return _spender == RAVI_ADDRESS  ||\r\n            _spender == JULIAN_ADDRESS ||\r\n            _spender == ABDEL_ADDRESS ||\r\n            _spender == ASHLEY_ADDRESS;\r\n    }\r\n\r\n    // Function wrapper to check for allocation lock\r\n    function approve(address spender, uint tokens)\r\n    {\r\n        if (isAllocationLocked(spender))\r\n        {\r\n            throw;\r\n        }\r\n        else\r\n        {\r\n            super.approve(spender, tokens);\r\n        }\r\n    }\r\n\r\n    // Function wrapper to check for allocation lock\r\n    function transfer(address to, uint tokens) onlyPayloadSize(2 * 32)\r\n    {\r\n        if (isAllocationLocked(to))\r\n        {\r\n            throw;\r\n        }\r\n        else\r\n        {\r\n            super.transfer(to, tokens);\r\n        }\r\n    }\r\n\r\n    // Function wrapper to check for allocation lock\r\n    function transferFrom(address from, address to, uint tokens) onlyPayloadSize(3 * 32)\r\n    {\r\n        if (isAllocationLocked(from) || isAllocationLocked(to))\r\n        {\r\n            throw;\r\n        }\r\n        else\r\n        {\r\n            super.transferFrom(from, to, tokens);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"isAllocationLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RAVI_ALLOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JULIAN_ALLOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ALLOCATION_LOCK_END_TIMESTAMP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ABDEL_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASHLEY_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JULIAN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"isTeamMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ABDEL_ALLOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inAllocationLockPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASHLEY_ALLOCATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RAVI_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"SophosToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c25b433c050fa33d1fc437b619d0ee76c815f2ff6842bd8043d12ae785da8c62"}]}