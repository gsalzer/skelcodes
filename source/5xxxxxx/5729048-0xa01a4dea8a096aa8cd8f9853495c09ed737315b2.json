{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * \r\n * This contract is used to set admin to the contract  which has some additional features such as minting , burning etc\r\n * \r\n */\r\n    contract Owned {\r\n        address public owner;\r\n\r\n        function owned() public {\r\n            owner = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner {\r\n            require(msg.sender == owner);\r\n            _;\r\n        }\r\n        \r\n        /* This function is used to transfer adminship to new owner\r\n         * @param  _newOwner - address of new admin or owner        \r\n         */\r\n\r\n        function transferOwnership(address _newOwner) onlyOwner public {\r\n            owner = _newOwner;\r\n        }          \r\n    }\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n This is interface to transfer Railz tokens , created by Railz token contract\r\n */\r\ninterface RailzToken {\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * This is the main Railz Token Sale contract\r\n */\r\ncontract RailzTokenSale is Owned {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping (address=> uint256) contributors;\r\n\tmapping (address=> uint256) public tokensAllocated;\r\n    \r\n\t// start and end timestamps when contributions are allowed  (both inclusive)\r\n\tuint256 public presalestartTime =1528099200 ;     //4th June 8:00 am UTC\r\n\tuint256 public presaleendTime = 1530489599;       //1st July 23:59 pm UTC\r\n\tuint256 public publicsalestartTime = 1530518400;  //2nd July 8:00 am UTC\r\n\tuint256 public publicsalesendTime = 1532908799;   //29th July 23:59 pm UTC\r\n\r\n\r\n\t//token caps for each round\r\n\tuint256 public presalesCap = 120000000 * (1e18);\r\n\tuint256 public publicsalesCap = 350000000 * (1e18);\r\n\r\n\t//token price for each round\r\n\tuint256 public presalesTokenPriceInWei =  80000000000000 ; // 0.00008 ether;\r\n\tuint256 public publicsalesTokenPriceInWei = 196000000000000 ;// 0.000196 ether;\r\n\r\n\t// address where all funds collected from token sale are stored , this will ideally be address of MutliSig wallet\r\n\taddress wallet;\r\n\r\n\t// amount of raised money in wei\r\n\tuint256 public weiRaised=0;\r\n\r\n\t//amount of tokens sold\r\n\tuint256 public numberOfTokensAllocated=0;\r\n\r\n\t// maximum gas price for contribution transactions - 60 GWEI\r\n\tuint256 public maxGasPrice = 60000000000  wei;  \r\n\r\n\t// The token being sold\r\n\tRailzToken public token;\r\n\r\n\tbool hasPreTokenSalesCapReached = false;\r\n\tbool hasTokenSalesCapReached = false;\r\n\r\n\t// events for funds received and tokens\r\n\tevent ContributionReceived(address indexed contributor, uint256 value, uint256 numberOfTokens);\r\n\tevent TokensTransferred(address indexed contributor, uint256 numberOfTokensTransferred);\r\n\tevent ManualTokensTransferred(address indexed contributor, uint256 numberOfTokensTransferred);\r\n\tevent PreTokenSalesCapReached(address indexed contributor);\r\n\tevent TokenSalesCapReached(address indexed contributor);\r\n\r\n\tfunction RailzTokenSale(RailzToken _addressOfRewardToken, address _wallet) public {        \r\n  \t\trequire(presalestartTime >= now); \r\n  \t\trequire(_wallet != address(0));   \r\n        \r\n  \t\ttoken = RailzToken (_addressOfRewardToken);\r\n  \t\twallet = _wallet;\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t// verifies that the gas price is lower than max gas price\r\n\tmodifier validGasPrice() {\r\n\t\tassert(tx.gasprice <= maxGasPrice);\r\n\t\t_;\r\n\t}\r\n\r\n\t// fallback function  used to buy tokens , this function is called when anyone sends ether to this contract\r\n\tfunction ()  payable public validGasPrice {  \r\n\t\trequire(msg.sender != address(0));                      //contributor's address should not be zero00/80\r\n\t\trequire(msg.value != 0);                                //amount should be greater then zero            \r\n        require(msg.value>=0.1 ether);                          //minimum contribution is 0.1 eth\r\n\t\trequire(isContributionAllowed());                       //Valid time of contribution and cap has not been reached 11\r\n\t\r\n\t\t// Add to mapping of contributor\r\n\t\tcontributors[msg.sender] = contributors[msg.sender].add(msg.value);\r\n\t\tweiRaised = weiRaised.add(msg.value);\r\n\t\tuint256 numberOfTokens = 0;\r\n\r\n\t\t//calculate number of tokens to be given\r\n\t\tif (isPreTokenSaleActive()) {\r\n\t\t\tnumberOfTokens = msg.value/presalesTokenPriceInWei;\r\n            numberOfTokens = numberOfTokens * (1e18);\r\n\t\t\trequire((numberOfTokens + numberOfTokensAllocated) <= presalesCap);\t\t\t//Check whether remaining tokens are greater than tokens to allocate\r\n\r\n\t\t\ttokensAllocated[msg.sender] = tokensAllocated[msg.sender].add(numberOfTokens);\r\n\t\t\tnumberOfTokensAllocated = numberOfTokensAllocated.add(numberOfTokens);\r\n\t\t\t\r\n\t\t\t//forward fund received to Railz multisig Account\r\n\t\t    forwardFunds(); \r\n\r\n\t\t\t//Notify server that an contribution has been received\r\n\t\t\temit ContributionReceived(msg.sender, msg.value, numberOfTokens);\r\n\r\n\t\t} else if (isTokenSaleActive()) {\r\n\t\t\tnumberOfTokens = msg.value/publicsalesTokenPriceInWei;\r\n\t\t\tnumberOfTokens = numberOfTokens * (1e18);\r\n\t\t\trequire((numberOfTokens + numberOfTokensAllocated) <= (presalesCap + publicsalesCap));\t//Check whether remaining tokens are greater than tokens to allocate\r\n\r\n\t\t\ttokensAllocated[msg.sender] = tokensAllocated[msg.sender].add(numberOfTokens);\r\n\t\t\tnumberOfTokensAllocated = numberOfTokensAllocated.add(numberOfTokens);\r\n\r\n            //forward fund received to Railz multisig Account\r\n\t\t    forwardFunds();\r\n\r\n\t\t\t//Notify server that an contribution has been received\r\n\t\t    emit ContributionReceived(msg.sender, msg.value, numberOfTokens);\r\n\t\t}        \r\n\r\n\t\t// check if hard cap has been reached or not , if it has reached close the contract\r\n\t\tcheckifCapHasReached();\r\n\t}\r\n\r\n\t/**\r\n\t* This function is used to check if an contribution is allowed or not\r\n\t*/\r\n\tfunction isContributionAllowed() public view returns (bool) {    \r\n\t\tif (isPreTokenSaleActive())\r\n\t\t\treturn  (!hasPreTokenSalesCapReached);\r\n\t\telse if (isTokenSaleActive())\r\n\t\t\treturn (!hasTokenSalesCapReached);\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\t// send ether to the fund collection wallet  , this ideally would be an multisig wallet\r\n\tfunction forwardFunds() internal {\r\n\t\twallet.transfer(msg.value);\r\n\t}\r\n\r\n\t//Pre Token Sale time\r\n\tfunction isPreTokenSaleActive() internal view returns (bool) {\r\n\t\treturn ((now >= presalestartTime) && (now <= presaleendTime));  \r\n\t}\r\n\r\n\t//Token Sale time\r\n\tfunction isTokenSaleActive() internal view returns (bool) {\r\n\t\treturn (now >= (publicsalestartTime) && (now <= publicsalesendTime));  \r\n\t}\r\n\r\n\t// Called by owner when preico token cap has been reached\r\n\tfunction preTokenSalesCapReached() internal {\r\n\t\thasPreTokenSalesCapReached = true;\r\n\t\temit PreTokenSalesCapReached(msg.sender);\r\n\t}\r\n\r\n\t// Called by owner when ico token cap has been reached\r\n\tfunction tokenSalesCapReached() internal {\r\n\t\thasTokenSalesCapReached = true;\r\n\t\temit TokenSalesCapReached(msg.sender);\r\n\t}\r\n\r\n\t//This function is used to transfer token to contributor after successful audit\r\n\tfunction transferToken(address _contributor) public onlyOwner {\r\n\t\trequire(_contributor != 0);\r\n        uint256 numberOfTokens = tokensAllocated[_contributor];\r\n        tokensAllocated[_contributor] = 0;    \r\n\t\ttoken.transfer(_contributor, numberOfTokens);\r\n\t\temit TokensTransferred(_contributor, numberOfTokens);\r\n\t}\r\n\r\n\r\n\t//This function is used to do bulk transfer token to contributor after successful audit manually\r\n\t function manualBatchTransferToken(uint256[] amount, address[] wallets) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n            token.transfer(wallets[i], amount[i]);\r\n\t\t\temit TokensTransferred(wallets[i], amount[i]);\r\n        }\r\n    }\r\n\r\n\t//This function is used to do bulk transfer token to contributor after successful audit\r\n\t function batchTransferToken(address[] wallets) public onlyOwner {\r\n        for (uint256 i = 0; i < wallets.length; i++) {\r\n\t\t\tuint256 amountOfTokens = tokensAllocated[wallets[i]];\r\n\t\t\trequire(amountOfTokens > 0);\r\n\t\t\ttokensAllocated[wallets[i]]=0;\r\n            token.transfer(wallets[i], amountOfTokens);\r\n\t\t\temit TokensTransferred(wallets[i], amountOfTokens);\r\n        }\r\n    }\r\n\t\r\n\t//This function is used refund contribution of a contributor in case soft cap is not reached or audit of an contributor failed\r\n\tfunction refundContribution(address _contributor, uint256 _weiAmount) public onlyOwner returns (bool) {\r\n\t\trequire(_contributor != 0);                                                                                                                                     \r\n\t\tif (!_contributor.send(_weiAmount)) {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\tcontributors[_contributor] = 0;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t// This function check whether ICO is currently active or not\r\n    function checkifCapHasReached() internal {\r\n    \tif (isPreTokenSaleActive() && (numberOfTokensAllocated > presalesCap))  \r\n        \thasPreTokenSalesCapReached = true;\r\n     \telse if (isTokenSaleActive() && (numberOfTokensAllocated > (presalesCap + publicsalesCap)))     \r\n        \thasTokenSalesCapReached = true;     \t\r\n    }\r\n\r\n  \t//This function allows the owner to update the gas price limit public onlyOwner     \r\n    function setGasPrice(uint256 _gasPrice) public onlyOwner {\r\n    \tmaxGasPrice = _gasPrice;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"presaleendTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"batchTransferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicsalesendTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presalesCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicsalesTokenPriceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"manualBatchTransferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presalesTokenPriceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicsalestartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presalestartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"refundContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicsalesCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"owned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContributionAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addressOfRewardToken\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"ContributionReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberOfTokensTransferred\",\"type\":\"uint256\"}],\"name\":\"TokensTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberOfTokensTransferred\",\"type\":\"uint256\"}],\"name\":\"ManualTokensTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"PreTokenSalesCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"TokenSalesCapReached\",\"type\":\"event\"}]","ContractName":"RailzTokenSale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002ed03c143d3f2062f0bd4a12229f28fb6a3eeae5000000000000000000000000582b68a841232601a4027cbe17c3b30ce059cb57","Library":"","SwarmSource":"bzzr://a309df13593496e2019eaae7635291eaa3bee3d883e80e49df16378ceed87a26"}]}