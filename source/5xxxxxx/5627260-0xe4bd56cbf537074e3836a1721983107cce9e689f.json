{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments. Inherit from this\r\n * contract and use asyncSend instead of send or transfer.\r\n */\r\ncontract PullPayment {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public payments;\r\n  uint256 public totalPayments;\r\n\r\n  /**\r\n  * @dev Withdraw accumulated balance, called by payee.\r\n  */\r\n  function withdrawPayments() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n\r\n    require(payment != 0);\r\n    require(address(this).balance >= payment);\r\n\r\n    totalPayments = totalPayments.sub(payment);\r\n    payments[payee] = 0;\r\n\r\n    payee.transfer(payment);\r\n  }\r\n\r\n  /**\r\n  * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n  * @param dest The destination address of the funds.\r\n  * @param amount The amount to transfer.\r\n  */\r\n  function asyncSend(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n    totalPayments = totalPayments.add(amount);\r\n  }\r\n\r\n  // Called by children of this contract to remove value from an account\r\n  function asyncDebit(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].sub(amount);\r\n    totalPayments = totalPayments.sub(amount);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * Sorted list of sales for use in the marketplace. Sorting is maintained by linked list.\r\n */\r\nlibrary SaleListLib {\r\n  address public constant nullAddress = address(0);\r\n\r\n  struct SaleList {\r\n    address head;\r\n\r\n    mapping(address => address) sellerListMapping;\r\n    mapping(address => uint) sellerToPrice;\r\n  }\r\n\r\n  function getBest(SaleList storage self) public view returns (address, uint) {\r\n    address head = self.head;\r\n    return (head, self.sellerToPrice[head]);\r\n  }\r\n\r\n  function addSale(SaleList storage self, address seller, uint price) public {\r\n    require(price != 0);\r\n    require(seller != nullAddress);\r\n\r\n    if (_contains(self, seller)) {\r\n      removeSale(self, seller);\r\n    }\r\n\r\n    self.sellerToPrice[seller] = price;\r\n    if (self.head == nullAddress || price <= self.sellerToPrice[self.head]) {\r\n      self.sellerListMapping[seller] = self.head;\r\n      self.head = seller;\r\n    } else {\r\n      address prev = self.head;\r\n      address cur = self.sellerListMapping[prev];\r\n\r\n      while (cur != nullAddress) {\r\n        if (price <= self.sellerToPrice[cur]) {\r\n          self.sellerListMapping[prev] = seller;\r\n          self.sellerListMapping[seller] = cur;\r\n\r\n          break;\r\n        }\r\n\r\n        prev = cur;\r\n        cur = self.sellerListMapping[cur];\r\n      }\r\n\r\n      // Insert value greater than all values in list\r\n      if (cur == nullAddress) {\r\n        self.sellerListMapping[prev] = seller;\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeSale(SaleList storage self, address seller) public returns (bool) {\r\n    require(seller != nullAddress);\r\n\r\n    if (!_contains(self, seller)) {\r\n      return false;\r\n    }\r\n\r\n    if (seller == self.head) {\r\n      self.head = self.sellerListMapping[seller];\r\n      _remove(self, seller);\r\n    } else {\r\n      address prev = self.head;\r\n      address cur = self.sellerListMapping[prev];\r\n\r\n      // TODO: Make SURE that initialized mapping with address vals initializes those vals to address(0)\r\n      // NOTE: Redundant check (prev != seller)\r\n      while (cur != nullAddress && prev != seller) {\r\n        if (cur == seller) {\r\n          self.sellerListMapping[prev] = self.sellerListMapping[seller];\r\n          _remove(self, seller);\r\n\r\n          break;\r\n        }\r\n\r\n        prev = cur;\r\n        cur = self.sellerListMapping[cur];\r\n      }\r\n\r\n      // NOTE: Redundant check\r\n      if (cur == nullAddress) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // NOTE: This is a purely internal method that *only* zeros out sellerListMapping and sellerToPrice\r\n  function _remove(SaleList storage self, address seller) internal {\r\n    self.sellerToPrice[seller] = 0;\r\n    self.sellerListMapping[seller] = nullAddress;\r\n  }\r\n\r\n  function _contains(SaleList storage self, address seller) view internal returns (bool) {\r\n    return self.sellerToPrice[seller] != 0;\r\n  }\r\n}\r\n\r\ncontract SaleRegistry is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  /////////\r\n  // Events\r\n  /////////\r\n\r\n  event SalePosted(\r\n    address indexed _seller,\r\n    bytes32 indexed _sig,\r\n    uint256 _price\r\n  );\r\n\r\n  event SaleCancelled(\r\n    address indexed _seller,\r\n    bytes32 indexed _sig\r\n  );\r\n\r\n  ////////\r\n  // State\r\n  ////////\r\n\r\n  mapping(bytes32 => SaleListLib.SaleList) _sigToSortedSales;\r\n\r\n  mapping(address => mapping(bytes32 => uint256)) _addressToSigToSalePrice;\r\n\r\n  // NOTE: Rules are different for contract owner. Can run many sales at a time, all at a single price. This\r\n  // allows multi-sale at genesis time\r\n  mapping(bytes32 => uint256) _ownerSigToNumSales;\r\n\r\n  mapping(bytes32 => uint256) public sigToNumSales;\r\n\r\n  /////////////\r\n  // User views\r\n  /////////////\r\n\r\n  // Returns (seller, price) tuple\r\n  function getBestSale(bytes32 sig) public view returns (address, uint256) {\r\n    return SaleListLib.getBest(_sigToSortedSales[sig]);\r\n  }\r\n\r\n  // Returns price that the sender is selling the current sig for (or 0 if not)\r\n  function getMySalePrice(bytes32 sig) public view returns (uint256) {\r\n    return _addressToSigToSalePrice[msg.sender][sig];\r\n  }\r\n\r\n  ///////////////\r\n  // User actions\r\n  ///////////////\r\n\r\n  // Convenience method used *only* at genesis sale time\r\n  function postGenesisSales(bytes32 sig, uint256 price, uint256 numSales) internal onlyOwner {\r\n    SaleListLib.addSale(_sigToSortedSales[sig], owner, price);\r\n    _addressToSigToSalePrice[owner][sig] = price;\r\n\r\n    _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].add(numSales);\r\n    sigToNumSales[sig] = sigToNumSales[sig].add(numSales);\r\n\r\n    emit SalePosted(owner, sig, price);\r\n  }\r\n\r\n  // Admin method for re-listing all genesis sales\r\n  function relistGenesisSales(bytes32 sig, uint256 newPrice) external onlyOwner {\r\n    SaleListLib.addSale(_sigToSortedSales[sig], owner, newPrice);\r\n    _addressToSigToSalePrice[owner][sig] = newPrice;\r\n\r\n    emit SalePosted(owner, sig, newPrice);\r\n  }\r\n\r\n  // NOTE: Only allows 1 active sale per address per sig, unless owner\r\n  function postSale(address seller, bytes32 sig, uint256 price) internal {\r\n    SaleListLib.addSale(_sigToSortedSales[sig], seller, price);\r\n    _addressToSigToSalePrice[seller][sig] = price;\r\n\r\n    sigToNumSales[sig] = sigToNumSales[sig].add(1);\r\n\r\n    if (seller == owner) {\r\n      _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].add(1);\r\n    }\r\n\r\n    emit SalePosted(seller, sig, price);\r\n  }\r\n\r\n  // NOTE: Special remove logic for contract owner's sale!\r\n  function cancelSale(address seller, bytes32 sig) internal {\r\n    if (seller == owner) {\r\n      _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].sub(1);\r\n\r\n      if (_ownerSigToNumSales[sig] == 0) {\r\n        SaleListLib.removeSale(_sigToSortedSales[sig], seller);\r\n        _addressToSigToSalePrice[seller][sig] = 0;\r\n      }\r\n    } else {\r\n      SaleListLib.removeSale(_sigToSortedSales[sig], seller);\r\n      _addressToSigToSalePrice[seller][sig] = 0;\r\n    }\r\n    sigToNumSales[sig] = sigToNumSales[sig].sub(1);\r\n\r\n    emit SaleCancelled(seller, sig);\r\n  }\r\n}\r\n\r\ncontract OwnerRegistry {\r\n  using SafeMath for uint256;\r\n\r\n  /////////\r\n  // Events\r\n  /////////\r\n\r\n  event CardCreated(\r\n    bytes32 indexed _sig,\r\n    uint256 _numAdded\r\n  );\r\n\r\n  event CardsTransferred(\r\n    bytes32 indexed _sig,\r\n    address indexed _oldOwner,\r\n    address indexed _newOwner,\r\n    uint256 _count\r\n  );\r\n\r\n  ////////\r\n  // State\r\n  ////////\r\n\r\n  bytes32[] _allSigs;\r\n  mapping(address => mapping(bytes32 => uint256)) _ownerToSigToCount;\r\n  mapping(bytes32 => uint256) _sigToCount;\r\n\r\n  ////////////////\r\n  // Admin actions\r\n  ////////////////\r\n\r\n  function addCardToRegistry(address owner, bytes32 sig, uint256 numToAdd) internal {\r\n    // Only allow adding cards that haven't already been added\r\n    require(_sigToCount[sig] == 0);\r\n\r\n    _allSigs.push(sig);\r\n    _ownerToSigToCount[owner][sig] = numToAdd;\r\n    _sigToCount[sig] = numToAdd;\r\n\r\n    emit CardCreated(sig, numToAdd);\r\n  }\r\n\r\n  /////////////\r\n  // User views\r\n  /////////////\r\n\r\n  function getAllSigs() public view returns (bytes32[]) {\r\n    return _allSigs;\r\n  }\r\n\r\n  function getNumSigsOwned(bytes32 sig) public view returns (uint256) {\r\n    return _ownerToSigToCount[msg.sender][sig];\r\n  }\r\n\r\n  function getNumSigs(bytes32 sig) public view returns (uint256) {\r\n    return _sigToCount[sig];\r\n  }\r\n\r\n  ///////////////////\r\n  // Transfer actions\r\n  ///////////////////\r\n\r\n  function registryTransfer(address oldOwner, address newOwner, bytes32 sig, uint256 count) internal {\r\n    // Must be transferring at least one card!\r\n    require(count > 0);\r\n\r\n    // Don't allow a transfer when the old owner doesn't enough of the card\r\n    require(_ownerToSigToCount[oldOwner][sig] >= count);\r\n\r\n    _ownerToSigToCount[oldOwner][sig] = _ownerToSigToCount[oldOwner][sig].sub(count);\r\n    _ownerToSigToCount[newOwner][sig] = _ownerToSigToCount[newOwner][sig].add(count);\r\n\r\n    emit CardsTransferred(sig, oldOwner, newOwner, count);\r\n  }\r\n}\r\n\r\ncontract ArtistRegistry {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(bytes32 => address) _sigToArtist;\r\n\r\n  // fee tuple is of form (txFeePercent, genesisSalePercent)\r\n  mapping(bytes32 => uint256[2]) _sigToFeeTuple;\r\n\r\n  function addArtistToRegistry(bytes32 sig,\r\n                               address artist,\r\n                               uint256 txFeePercent,\r\n                               uint256 genesisSalePercent) internal {\r\n    // Must be a valid artist address!\r\n    require(artist != address(0));\r\n\r\n    // Only allow 1 sig per artist!\r\n    require(_sigToArtist[sig] == address(0));\r\n\r\n    _sigToArtist[sig] = artist;\r\n    _sigToFeeTuple[sig] = [txFeePercent, genesisSalePercent];\r\n  }\r\n\r\n  function computeArtistTxFee(bytes32 sig, uint256 txFee) internal view returns (uint256) {\r\n    uint256 feePercent = _sigToFeeTuple[sig][0];\r\n    return (txFee.mul(feePercent)).div(100);\r\n  }\r\n\r\n  function computeArtistGenesisSaleFee(bytes32 sig, uint256 genesisSaleProfit) internal view returns (uint256) {\r\n    uint256 feePercent = _sigToFeeTuple[sig][1];\r\n    return (genesisSaleProfit.mul(feePercent)).div(100);\r\n  }\r\n\r\n  function getArtist(bytes32 sig) internal view returns (address) {\r\n    return _sigToArtist[sig];\r\n  }\r\n}\r\n\r\ncontract PepeCore is PullPayment, OwnerRegistry, SaleRegistry, ArtistRegistry {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 constant public totalTxFeePercent = 4;\r\n\r\n  ////////////////////\r\n  // Shareholder stuff\r\n  ////////////////////\r\n\r\n  // Only 3 equal shareholders max allowed on this contract representing the three equal-partner founders\r\n  // involved in its inception\r\n  address public shareholder1;\r\n  address public shareholder2;\r\n  address public shareholder3;\r\n\r\n  // 0 -> 3 depending on contract state. I only use uint256 so that I can use SafeMath...\r\n  uint256 public numShareholders = 0;\r\n\r\n  // Used to set initial shareholders\r\n  function addShareholderAddress(address newShareholder) external onlyOwner {\r\n    // Don't let shareholder be address(0)\r\n    require(newShareholder != address(0));\r\n\r\n    // Contract owner can't be a shareholder\r\n    require(newShareholder != owner);\r\n\r\n    // Must be an open shareholder spot!\r\n    require(shareholder1 == address(0) || shareholder2 == address(0) || shareholder3 == address(0));\r\n\r\n    if (shareholder1 == address(0)) {\r\n      shareholder1 = newShareholder;\r\n      numShareholders = numShareholders.add(1);\r\n    } else if (shareholder2 == address(0)) {\r\n      shareholder2 = newShareholder;\r\n      numShareholders = numShareholders.add(1);\r\n    } else if (shareholder3 == address(0)) {\r\n      shareholder3 = newShareholder;\r\n      numShareholders = numShareholders.add(1);\r\n    }\r\n  }\r\n\r\n  // Splits the amount specified among shareholders equally\r\n  function payShareholders(uint256 amount) internal {\r\n    // If no shareholders, shareholder fees will be held in contract to be withdrawable by owner\r\n    if (numShareholders > 0) {\r\n      uint256 perShareholderFee = amount.div(numShareholders);\r\n\r\n      if (shareholder1 != address(0)) {\r\n        asyncSend(shareholder1, perShareholderFee);\r\n      }\r\n\r\n      if (shareholder2 != address(0)) {\r\n        asyncSend(shareholder2, perShareholderFee);\r\n      }\r\n\r\n      if (shareholder3 != address(0)) {\r\n        asyncSend(shareholder3, perShareholderFee);\r\n      }\r\n    }\r\n  }\r\n\r\n  ////////////////\r\n  // Admin actions\r\n  ////////////////\r\n\r\n  function withdrawContractBalance() external onlyOwner {\r\n    uint256 contractBalance = address(this).balance;\r\n    uint256 withdrawableBalance = contractBalance.sub(totalPayments);\r\n\r\n    // No withdrawal necessary if <= 0 balance\r\n    require(withdrawableBalance > 0);\r\n\r\n    msg.sender.transfer(withdrawableBalance);\r\n  }\r\n\r\n  function addCard(bytes32 sig,\r\n                   address artist,\r\n                   uint256 txFeePercent,\r\n                   uint256 genesisSalePercent,\r\n                   uint256 numToAdd,\r\n                   uint256 startingPrice) external onlyOwner {\r\n    addCardToRegistry(owner, sig, numToAdd);\r\n\r\n    addArtistToRegistry(sig, artist, txFeePercent, genesisSalePercent);\r\n\r\n    postGenesisSales(sig, startingPrice, numToAdd);\r\n  }\r\n\r\n  ///////////////\r\n  // User actions\r\n  ///////////////\r\n\r\n  function createSale(bytes32 sig, uint256 price) external {\r\n    // Can't sell a card for 0... May want other limits in the future\r\n    require(price > 0);\r\n\r\n    // Can't sell a card you don't own\r\n    require(getNumSigsOwned(sig) > 0);\r\n\r\n    // Can't post a sale if you have one posted already! Unless you're the contract owner\r\n    require(msg.sender == owner || _addressToSigToSalePrice[msg.sender][sig] == 0);\r\n\r\n    postSale(msg.sender, sig, price);\r\n  }\r\n\r\n  function removeSale(bytes32 sig) public {\r\n    // Can't cancel a sale that doesn't exist\r\n    require(_addressToSigToSalePrice[msg.sender][sig] > 0);\r\n\r\n    cancelSale(msg.sender, sig);\r\n  }\r\n\r\n  function computeTxFee(uint256 price) private pure returns (uint256) {\r\n    return (price * totalTxFeePercent) / 100;\r\n  }\r\n\r\n  // If card is held by contract owner, split among artist + shareholders\r\n  function paySellerFee(bytes32 sig, address seller, uint256 sellerProfit) private {\r\n    if (seller == owner) {\r\n      address artist = getArtist(sig);\r\n      uint256 artistFee = computeArtistGenesisSaleFee(sig, sellerProfit);\r\n      asyncSend(artist, artistFee);\r\n\r\n      payShareholders(sellerProfit.sub(artistFee));\r\n    } else {\r\n      asyncSend(seller, sellerProfit);\r\n    }\r\n  }\r\n\r\n  // Simply pay out tx fees appropriately\r\n  function payTxFees(bytes32 sig, uint256 txFee) private {\r\n    uint256 artistFee = computeArtistTxFee(sig, txFee);\r\n    address artist = getArtist(sig);\r\n    asyncSend(artist, artistFee);\r\n\r\n    payShareholders(txFee.sub(artistFee));\r\n  }\r\n\r\n  // Handle wallet debit if necessary, pay out fees, pay out seller profit, cancel sale, transfer card\r\n  function buy(bytes32 sig) external payable {\r\n    address seller;\r\n    uint256 price;\r\n    (seller, price) = getBestSale(sig);\r\n\r\n    // There must be a valid sale for the card\r\n    require(price > 0 && seller != address(0));\r\n\r\n    // Buyer must have enough Eth via wallet and payment to cover posted price\r\n    uint256 availableEth = msg.value.add(payments[msg.sender]);\r\n    require(availableEth >= price);\r\n\r\n    // Debit wallet if msg doesn't have enough value to cover price\r\n    if (msg.value < price) {\r\n      asyncDebit(msg.sender, price.sub(msg.value));\r\n    }\r\n\r\n    // Split out fees + seller profit\r\n    uint256 txFee = computeTxFee(price);\r\n    uint256 sellerProfit = price.sub(txFee);\r\n\r\n    // Pay out seller (special logic for seller == owner)\r\n    paySellerFee(sig, seller, sellerProfit);\r\n\r\n    // Pay out tx fees\r\n    payTxFees(sig, txFee);\r\n\r\n    // Cancel sale\r\n    cancelSale(seller, sig);\r\n\r\n    // Transfer single sig ownership in registry\r\n    registryTransfer(seller, msg.sender, sig, 1);\r\n  }\r\n\r\n  // Can also be used in airdrops, etc.\r\n  function transferSig(bytes32 sig, uint256 count, address newOwner) external {\r\n    uint256 numOwned = getNumSigsOwned(sig);\r\n\r\n    // Can't transfer cards you don't own\r\n    require(numOwned >= count);\r\n\r\n    // If transferring from contract owner, cancel the proper number of sales if necessary\r\n    if (msg.sender == owner) {\r\n      uint256 remaining = numOwned.sub(count);\r\n\r\n      if (remaining < _ownerSigToNumSales[sig]) {\r\n        uint256 numSalesToCancel = _ownerSigToNumSales[sig].sub(remaining);\r\n\r\n        for (uint256 i = 0; i < numSalesToCancel; i++) {\r\n          removeSale(sig);\r\n        }\r\n      }\r\n    } else {\r\n      // Remove existing sale if transferring all owned cards\r\n      if (numOwned == count && _addressToSigToSalePrice[msg.sender][sig] > 0) {\r\n        removeSale(sig);\r\n      }\r\n    }\r\n\r\n    // Transfer in registry\r\n    registryTransfer(msg.sender, newOwner, sig, count);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newShareholder\",\"type\":\"address\"}],\"name\":\"addShareholderAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTxFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"}],\"name\":\"getNumSigsOwned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareholder1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numShareholders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareholder2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"}],\"name\":\"removeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareholder3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"sigToNumSales\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"},{\"name\":\"artist\",\"type\":\"address\"},{\"name\":\"txFeePercent\",\"type\":\"uint256\"},{\"name\":\"genesisSalePercent\",\"type\":\"uint256\"},{\"name\":\"numToAdd\",\"type\":\"uint256\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"}],\"name\":\"addCard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllSigs\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"createSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"},{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"relistGenesisSales\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"}],\"name\":\"getBestSale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"}],\"name\":\"getNumSigs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferSig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sig\",\"type\":\"bytes32\"}],\"name\":\"getMySalePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"SalePosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_sig\",\"type\":\"bytes32\"}],\"name\":\"SaleCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_numAdded\",\"type\":\"uint256\"}],\"name\":\"CardCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sig\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"CardsTransferred\",\"type\":\"event\"}]","ContractName":"PepeCore","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"SaleListLib:e3f10b91a8fb0e629a178ee4d3d3ac05fd7c5b89","SwarmSource":"bzzr://72ada87abffdcf404de6f3759a226a3fd03354d3b1849d444573cbd4cb86c380"}]}