{"status":"1","message":"OK","result":[{"SourceCode":"/* ==================================================================== */\r\n/* Copyright (c) 2018 The ether.online Project.  All rights reserved.\r\n/* \r\n/* https://ether.online  The first RPG game of blockchain \r\n/*  \r\n/* authors rickhunter.shen@gmail.com   \r\n/*         ssesunding@gmail.com            \r\n/* ==================================================================== */\r\n\r\npragma solidity ^0.4.20;\r\n\r\ncontract AccessAdmin {\r\n    bool public isPaused = false;\r\n    address public addrAdmin;  \r\n\r\n    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);\r\n\r\n    function AccessAdmin() public {\r\n        addrAdmin = msg.sender;\r\n    }  \r\n\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == addrAdmin);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!isPaused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(isPaused);\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address _newAdmin) external onlyAdmin {\r\n        require(_newAdmin != address(0));\r\n        AdminTransferred(addrAdmin, _newAdmin);\r\n        addrAdmin = _newAdmin;\r\n    }\r\n\r\n    function doPause() external onlyAdmin whenNotPaused {\r\n        isPaused = true;\r\n    }\r\n\r\n    function doUnpause() external onlyAdmin whenPaused {\r\n        isPaused = false;\r\n    }\r\n}\r\n\r\n\r\ncontract AccessService is AccessAdmin {\r\n    address public addrService;\r\n    address public addrFinance;\r\n\r\n    modifier onlyService() {\r\n        require(msg.sender == addrService);\r\n        _;\r\n    }\r\n\r\n    modifier onlyFinance() {\r\n        require(msg.sender == addrFinance);\r\n        _;\r\n    }\r\n\r\n    function setService(address _newService) external {\r\n        require(msg.sender == addrService || msg.sender == addrAdmin);\r\n        require(_newService != address(0));\r\n        addrService = _newService;\r\n    }\r\n\r\n    function setFinance(address _newFinance) external {\r\n        require(msg.sender == addrFinance || msg.sender == addrAdmin);\r\n        require(_newFinance != address(0));\r\n        addrFinance = _newFinance;\r\n    }\r\n\r\n    function withdraw(address _target, uint256 _amount) \r\n        external \r\n    {\r\n        require(msg.sender == addrFinance || msg.sender == addrAdmin);\r\n        require(_amount > 0);\r\n        address receiver = _target == address(0) ? addrFinance : _target;\r\n        uint256 balance = this.balance;\r\n        if (_amount < balance) {\r\n            receiver.transfer(_amount);\r\n        } else {\r\n            receiver.transfer(this.balance);\r\n        }      \r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IBitGuildToken {\r\n    function transfer(address _to, uint256 _value) external;\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external; \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool);\r\n    function balanceOf(address _from) external view returns(uint256);\r\n}\r\n\r\ninterface IAgonFight {\r\n    function calcFight(uint64 _mFlag, uint64 _cFlag, uint256 _aSeed, uint256 _fSeed) external pure returns(uint64);\r\n}\r\n\r\ncontract ActionAgonPlat is AccessService {\r\n    using SafeMath for uint256; \r\n\r\n    event CreateAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);\r\n    event CancelAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag);\r\n    event ChallengeAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);\r\n    event ResolveAgonPlat(uint64 indexed agonId, address indexed master, uint64 indexed outFlag, address challenger);\r\n\r\n    struct Agon {\r\n        address master;\r\n        address challenger;\r\n        uint64 agonPrice;\r\n        uint64 outFlag;\r\n        uint64 agonFlag;    \r\n        uint64 result;      // 1-win, 2-lose, 99-cancel\r\n    }\r\n\r\n    Agon[] agonArray;\r\n    IAgonFight fightContract;\r\n    IBitGuildToken public bitGuildContract;\r\n\r\n    mapping (address => uint64[]) public ownerToAgonIdArray;\r\n    uint256 public maxAgonCount = 6;\r\n    uint256 public maxResolvedAgonId = 0; \r\n    uint256[5] public agonValues;\r\n\r\n    function ActionAgonPlat(address _platAddr) public {\r\n        addrAdmin = msg.sender;\r\n        addrService = msg.sender;\r\n        addrFinance = msg.sender;\r\n\r\n        bitGuildContract = IBitGuildToken(_platAddr);\r\n\r\n        Agon memory order = Agon(0, 0, 0, 0, 1, 1);\r\n        agonArray.push(order);\r\n        agonValues[0] = 3000000000000000000000;\r\n        agonValues[1] = 12000000000000000000000;\r\n        agonValues[2] = 30000000000000000000000;\r\n        agonValues[3] = 60000000000000000000000;\r\n        agonValues[4] = 120000000000000000000000;\r\n    }\r\n\r\n    function() external {}\r\n\r\n    function setMaxAgonCount(uint256 _count) external onlyAdmin {\r\n        require(_count > 0 && _count < 20);\r\n        require(_count != maxAgonCount);\r\n        maxAgonCount = _count;\r\n    }\r\n\r\n    function setAgonFight(address _addr) external onlyAdmin {\r\n        fightContract = IAgonFight(_addr);\r\n    }\r\n\r\n    function setMaxResolvedAgonId() external {\r\n        uint256 length = agonArray.length;\r\n        for (uint256 i = maxResolvedAgonId; i < length; ++i) {\r\n            if (agonArray[i].result == 0) {\r\n                maxResolvedAgonId = i - 1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setAgonValues(uint256[5] values) external onlyAdmin {\r\n        require(values[0] >= 100);\r\n        require(values[1] >= values[0]);\r\n        require(values[2] >= values[1]);\r\n        require(values[3] >= values[2]);\r\n        require(values[4] >= values[3]);\r\n        require(values[4] <= 600000); \r\n        require(values[0] % 100 == 0);\r\n        require(values[1] % 100 == 0);\r\n        require(values[2] % 100 == 0);\r\n        require(values[3] % 100 == 0);\r\n        require(values[4] % 100 == 0);\r\n        agonValues[0] = values[0].mul(1000000000000000000);\r\n        agonValues[1] = values[1].mul(1000000000000000000);\r\n        agonValues[2] = values[2].mul(1000000000000000000);\r\n        agonValues[3] = values[3].mul(1000000000000000000);\r\n        agonValues[4] = values[4].mul(1000000000000000000);\r\n    }\r\n\r\n    function _getExtraParam(bytes _extraData) internal pure returns(uint64 p1, uint64 p2, uint64 p3) {\r\n        p1 = uint64(_extraData[0]);\r\n        p2 = uint64(_extraData[1]);\r\n        uint64 index = 2;\r\n        uint256 val = 0;\r\n        uint256 length = _extraData.length;\r\n        while (index < length) {\r\n            val += (uint256(_extraData[index]) * (256 ** (length - index - 1)));\r\n            index += 1;\r\n        }\r\n        p3 = uint64(val);\r\n    }\r\n\r\n    function receiveApproval(address _sender, uint256 _value, address _tokenContract, bytes _extraData) \r\n        external \r\n        whenNotPaused \r\n    {\r\n        require(msg.sender == address(bitGuildContract));\r\n        require(_extraData.length > 2 && _extraData.length <= 10);\r\n        var (p1, p2, p3) = _getExtraParam(_extraData);\r\n        if (p1 == 0) {\r\n            _newAgon(p3, p2, _sender, _value);\r\n        } else if (p1 == 1) {\r\n            _newChallenge(p3, p2, _sender, _value);\r\n        } else {\r\n            require(false);\r\n        }\r\n    }\r\n\r\n    function _newAgon(uint64 _outFlag, uint64 _valId, address _sender, uint256 _value) internal {\r\n        require(ownerToAgonIdArray[_sender].length < maxAgonCount);\r\n        require(_valId >= 0 && _valId <= 4);\r\n        require(_value == agonValues[_valId]);\r\n        \r\n        require(bitGuildContract.transferFrom(_sender, address(this), _value));\r\n\r\n        uint64 newAgonId = uint64(agonArray.length);\r\n        agonArray.length += 1;\r\n        Agon storage agon = agonArray[newAgonId];\r\n        agon.master = _sender;\r\n        agon.agonPrice = uint64(_value.div(1000000000000000000)); \r\n        agon.outFlag = _outFlag;\r\n\r\n        ownerToAgonIdArray[_sender].push(newAgonId);\r\n\r\n        CreateAgonPlat(uint64(newAgonId), _sender, _outFlag);\r\n    } \r\n\r\n    function _removeAgonIdByOwner(address _owner, uint64 _agonId) internal {\r\n        uint64[] storage agonIdArray = ownerToAgonIdArray[_owner];\r\n        uint256 length = agonIdArray.length;\r\n        require(length > 0);\r\n        uint256 findIndex = 99;\r\n        for (uint256 i = 0; i < length; ++i) {\r\n            if (_agonId == agonIdArray[i]) {\r\n                findIndex = i;\r\n            }\r\n        }\r\n        require(findIndex != 99);\r\n        if (findIndex != (length - 1)) {\r\n            agonIdArray[findIndex] = agonIdArray[length - 1];\r\n        } \r\n        agonIdArray.length -= 1;\r\n    }\r\n\r\n    function cancelAgon(uint64 _agonId) external {\r\n        require(_agonId < agonArray.length);\r\n        Agon storage agon = agonArray[_agonId];\r\n        require(agon.result == 0);\r\n        require(agon.challenger == address(0));\r\n        require(agon.master == msg.sender);\r\n\r\n        agon.result = 99;\r\n        _removeAgonIdByOwner(msg.sender, _agonId);\r\n        bitGuildContract.transfer(msg.sender, uint256(agon.agonPrice).mul(1000000000000000000));\r\n\r\n        CancelAgonPlat(_agonId, msg.sender, agon.outFlag);\r\n    }\r\n\r\n    function cancelAgonForce(uint64 _agonId) external onlyService {\r\n        require(_agonId < agonArray.length);\r\n        Agon storage agon = agonArray[_agonId];\r\n        require(agon.result == 0);\r\n        require(agon.challenger == address(0));\r\n\r\n        agon.result = 99;\r\n        _removeAgonIdByOwner(agon.master, _agonId);\r\n        bitGuildContract.transfer(agon.master, uint256(agon.agonPrice).mul(1000000000000000000));\r\n\r\n        CancelAgonPlat(_agonId, agon.master, agon.outFlag);\r\n    }\r\n\r\n    function _newChallenge(uint64 _agonId, uint64 _flag, address _sender, uint256 _value) internal {\r\n        require(_agonId < agonArray.length);\r\n        Agon storage agon = agonArray[_agonId];\r\n        require(agon.result == 0);\r\n        require(agon.master != _sender);\r\n        require(uint256(agon.agonPrice).mul(1000000000000000000) == _value);\r\n        require(agon.challenger == address(0));\r\n\r\n        require(bitGuildContract.transferFrom(_sender, address(this), _value));\r\n\r\n        agon.challenger = _sender;\r\n        agon.agonFlag = _flag;\r\n        ChallengeAgonPlat(_agonId, agon.master, agon.outFlag, _sender);\r\n    }\r\n\r\n    function fightAgon(uint64 _agonId, uint64 _mFlag, uint256 _aSeed, uint256 _fSeed) external onlyService {\r\n        require(_agonId < agonArray.length);\r\n        Agon storage agon = agonArray[_agonId];\r\n        require(agon.result == 0 && agon.challenger != address(0));\r\n        require(fightContract != address(0));\r\n        uint64 fRet = fightContract.calcFight(_mFlag, agon.agonFlag, _aSeed, _fSeed);\r\n        require(fRet == 1 || fRet == 2);\r\n        agon.result = fRet;\r\n        _removeAgonIdByOwner(agon.master, _agonId);\r\n        uint256 devCut = uint256(agon.agonPrice).div(10);\r\n        uint256 winVal = uint256(agon.agonPrice).mul(2).sub(devCut);\r\n        if (fRet == 1) {\r\n            bitGuildContract.transfer(agon.master, winVal.mul(1000000000000000000));\r\n        } else {\r\n            bitGuildContract.transfer(agon.challenger, winVal.mul(1000000000000000000));\r\n        }\r\n\r\n        ResolveAgonPlat(_agonId, agon.master, agon.outFlag, agon.challenger);\r\n    }\r\n\r\n    function getPlatBalance() external view returns(uint256) {\r\n        return bitGuildContract.balanceOf(this);\r\n    }\r\n\r\n    function withdrawPlat() external {\r\n        require(msg.sender == addrFinance || msg.sender == addrAdmin);\r\n        uint256 balance = bitGuildContract.balanceOf(this);\r\n        require(balance > 0);\r\n        bitGuildContract.transfer(addrFinance, balance);\r\n    }\r\n\r\n    function getAgon(uint256 _agonId) external view\r\n        returns(\r\n            address master,\r\n            address challenger,\r\n            uint64 agonPrice,\r\n            uint64 outFlag,\r\n            uint64 agonFlag,\r\n            uint64 result\r\n        )\r\n    {\r\n        require(_agonId < agonArray.length);\r\n        Agon memory agon = agonArray[_agonId];\r\n        master = agon.master;\r\n        challenger = agon.challenger;\r\n        agonPrice = agon.agonPrice;\r\n        outFlag = agon.outFlag;\r\n        agonFlag = agon.agonFlag;\r\n        result = agon.result;\r\n    }\r\n\r\n    function getAgonArray(uint64 _startAgonId, uint64 _count) external view\r\n        returns(\r\n            uint64[] agonIds,\r\n            address[] masters,\r\n            address[] challengers,\r\n            uint64[] agonPrices,           \r\n            uint64[] agonOutFlags,\r\n            uint64[] agonFlags,\r\n            uint64[] results\r\n        ) \r\n    {\r\n        uint64 length = uint64(agonArray.length);\r\n        require(_startAgonId < length);\r\n        require(_startAgonId > 0);\r\n        uint256 maxLen;\r\n        if (_count == 0) {\r\n            maxLen = length - _startAgonId;\r\n        } else {\r\n            maxLen = (length - _startAgonId) >= _count ? _count : (length - _startAgonId);\r\n        }\r\n        agonIds = new uint64[](maxLen);\r\n        masters = new address[](maxLen);\r\n        challengers = new address[](maxLen);\r\n        agonPrices = new uint64[](maxLen);\r\n        agonOutFlags = new uint64[](maxLen);\r\n        agonFlags = new uint64[](maxLen);\r\n        results = new uint64[](maxLen);\r\n        uint256 counter = 0;\r\n        for (uint64 i = _startAgonId; i < length; ++i) {\r\n            Agon storage tmpAgon = agonArray[i];\r\n            agonIds[counter] = i;\r\n            masters[counter] = tmpAgon.master;\r\n            challengers[counter] = tmpAgon.challenger;\r\n            agonPrices[counter] = tmpAgon.agonPrice;\r\n            agonOutFlags[counter] = tmpAgon.outFlag;\r\n            agonFlags[counter] = tmpAgon.agonFlag;\r\n            results[counter] = tmpAgon.result;\r\n            counter += 1;\r\n            if (counter >= maxLen) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getMaxAgonId() external view returns(uint256) {\r\n        return agonArray.length - 1;\r\n    }\r\n\r\n    function getAgonIdArray(address _owner) external view returns(uint64[]) {\r\n        return ownerToAgonIdArray[_owner];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_startAgonId\",\"type\":\"uint64\"},{\"name\":\"_count\",\"type\":\"uint64\"}],\"name\":\"getAgonArray\",\"outputs\":[{\"name\":\"agonIds\",\"type\":\"uint64[]\"},{\"name\":\"masters\",\"type\":\"address[]\"},{\"name\":\"challengers\",\"type\":\"address[]\"},{\"name\":\"agonPrices\",\"type\":\"uint64[]\"},{\"name\":\"agonOutFlags\",\"type\":\"uint64[]\"},{\"name\":\"agonFlags\",\"type\":\"uint64[]\"},{\"name\":\"results\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"values\",\"type\":\"uint256[5]\"}],\"name\":\"setAgonValues\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlatBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setAgonFight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAgonCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doUnpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerToAgonIdArray\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPlat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_agonId\",\"type\":\"uint256\"}],\"name\":\"getAgon\",\"outputs\":[{\"name\":\"master\",\"type\":\"address\"},{\"name\":\"challenger\",\"type\":\"address\"},{\"name\":\"agonPrice\",\"type\":\"uint64\"},{\"name\":\"outFlag\",\"type\":\"uint64\"},{\"name\":\"agonFlag\",\"type\":\"uint64\"},{\"name\":\"result\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agonId\",\"type\":\"uint64\"}],\"name\":\"cancelAgonForce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getAgonIdArray\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"agonValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setMaxResolvedAgonId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setMaxAgonCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addrFinance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxResolvedAgonId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFinance\",\"type\":\"address\"}],\"name\":\"setFinance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bitGuildContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxAgonId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newService\",\"type\":\"address\"}],\"name\":\"setService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addrAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addrService\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agonId\",\"type\":\"uint64\"}],\"name\":\"cancelAgon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agonId\",\"type\":\"uint64\"},{\"name\":\"_mFlag\",\"type\":\"uint64\"},{\"name\":\"_aSeed\",\"type\":\"uint256\"},{\"name\":\"_fSeed\",\"type\":\"uint256\"}],\"name\":\"fightAgon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_platAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agonId\",\"type\":\"uint64\"},{\"indexed\":true,\"name\":\"master\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"outFlag\",\"type\":\"uint64\"}],\"name\":\"CreateAgonPlat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agonId\",\"type\":\"uint64\"},{\"indexed\":true,\"name\":\"master\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"outFlag\",\"type\":\"uint64\"}],\"name\":\"CancelAgonPlat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agonId\",\"type\":\"uint64\"},{\"indexed\":true,\"name\":\"master\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"outFlag\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"ChallengeAgonPlat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agonId\",\"type\":\"uint64\"},{\"indexed\":true,\"name\":\"master\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"outFlag\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"ResolveAgonPlat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"preAdmin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminTransferred\",\"type\":\"event\"}]","ContractName":"ActionAgonPlat","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007e43581b19ab509bcf9397a2efd1ab10233f27de","Library":"","SwarmSource":"bzzr://a9c2d8a2dec3fca122e23cd07c28211524e90d1fad564ba9728db3003e5b6cc3"}]}