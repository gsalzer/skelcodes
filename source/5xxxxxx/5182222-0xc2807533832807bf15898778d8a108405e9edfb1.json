{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/*\r\n * Ponzi Trust Token Smart Contracts \r\n * Code is published on https://github.com/PonziTrust/Token\r\n * Ponzi Trust https://ponzitrust.com/\r\n*/\r\n\r\n\r\n// see: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n// see: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\ncontract ERC20 {\r\n  function name() public view returns (string);\r\n  function symbol() public view returns (string);\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n// see: https://github.com/ethereum/EIPs/issues/677\r\ncontract ERC677Token {\r\n  function transferAndCall(address receiver, uint amount, bytes data) public returns (bool success);\r\n  function contractFallback(address to, uint value, bytes data) internal;\r\n  function isContract(address addr) internal view returns (bool hasCode);\r\n  event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\n\r\n// see: https://github.com/ethereum/EIPs/issues/677\r\ncontract ERC677Recipient {\r\n  function tokenFallback(address from, uint256 amount, bytes data) public returns (bool success);\r\n}  \r\n\r\n\r\n/**\r\n* @dev The token implement ERC20 and ERC677 standarts(see above).\r\n* use Withdrawal, Restricting Access, State Machine patterns.\r\n* see: http://solidity.readthedocs.io/en/develop/common-patterns.html\r\n* use SafeMath library, see above.\r\n* The owner can intervene in the work of the token only before the expiration\r\n* DURATION_TO_ACCESS_FOR_OWNER = 144 days. Contract has thee state of working:\r\n* 1.PreSale - only owner can access to transfer tokens. 2.Sale - contract to sale\r\n* tokens by func byToken() of fallback, contact and owner can access to transfer tokens. \r\n* Token price setting by owner or price setter. 3.PublicUse - anyone can transfer tokens.\r\n*/\r\ncontract PonziToken is ERC20, ERC677Token {\r\n  using SafeMath for uint256;\r\n\r\n  enum State {\r\n    PreSale,   //PRE_SALE_STR\r\n    Sale,      //SALE_STR\r\n    PublicUse  //PUBLIC_USE_STR\r\n  }\r\n  // we need returns string representation of state\r\n  // because enums are not supported by the ABI, they are just supported by Solidity.\r\n  // see: http://solidity.readthedocs.io/en/develop/frequently-asked-questions.html#if-i-return-an-enum-i-only-get-integer-values-in-web3-js-how-to-get-the-named-values\r\n  string private constant PRE_SALE_STR = \"PreSale\";\r\n  string private constant SALE_STR = \"Sale\";\r\n  string private constant PUBLIC_USE_STR = \"PublicUse\";\r\n  State private m_state;\r\n\r\n  uint256 private constant DURATION_TO_ACCESS_FOR_OWNER = 144 days;\r\n  \r\n  uint256 private m_maxTokensPerAddress;\r\n  uint256 private m_firstEntranceToSaleStateUNIX;\r\n  address private m_owner;\r\n  address private m_priceSetter;\r\n  address private m_bank;\r\n  uint256 private m_tokenPriceInWei;\r\n  uint256 private m_totalSupply;\r\n  uint256 private m_myDebtInWei;\r\n  string private m_name;\r\n  string private m_symbol;\r\n  uint8 private m_decimals;\r\n  bool private m_isFixedTokenPrice;\r\n  \r\n  mapping(address => mapping (address => uint256)) private m_allowed;\r\n  mapping(address => uint256) private m_balances;\r\n  mapping(address => uint256) private m_pendingWithdrawals;\r\n\r\n////////////////\r\n// EVENTS\r\n//\r\n  event StateChanged(address indexed who, State newState);\r\n  event PriceChanged(address indexed who, uint newPrice, bool isFixed);\r\n  event TokensSold(uint256 numberOfTokens, address indexed purchasedBy, uint256 indexed priceInWei);\r\n  event Withdrawal(address indexed to, uint sumInWei);\r\n\r\n////////////////\r\n// MODIFIERS - Restricting Access and State Machine patterns\r\n//\r\n  modifier atState(State state) {\r\n    require(m_state == state);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == m_owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwnerOrAtState(State state) {\r\n    require(msg.sender == m_owner || m_state == state); \r\n    _;\r\n  }\r\n  \r\n  modifier checkAccess() {\r\n    require(m_firstEntranceToSaleStateUNIX == 0 // solium-disable-line indentation, operator-whitespace\r\n      || now.sub(m_firstEntranceToSaleStateUNIX) <= DURATION_TO_ACCESS_FOR_OWNER \r\n      || m_state != State.PublicUse\r\n    ); \r\n    _;\r\n    // owner has not access if duration To Access For Owner was passed \r\n    // and (&&) contract in PublicUse state.\r\n  }\r\n  \r\n  modifier validRecipient(address recipient) {\r\n    require(recipient != address(0) && recipient != address(this));\r\n    _;\r\n  }\r\n\r\n///////////////\r\n// CONSTRUCTOR\r\n//  \r\n  /**\r\n  * @dev Constructor PonziToken.\r\n  */\r\n  function PonziToken() public {\r\n    m_owner = msg.sender;\r\n    m_bank = msg.sender;\r\n    m_state = State.PreSale;\r\n    m_decimals = 8;\r\n    m_name = \"Ponzi\";\r\n    m_symbol = \"PT\";\r\n  }\r\n\r\n  /**\r\n  * do not forget about:\r\n  * https://medium.com/codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a\r\n  * \r\n  * @dev Initialize the contract, only owner can call and only once.\r\n  * @return Whether successful or not.\r\n  */\r\n  function initContract() \r\n    public \r\n    onlyOwner() \r\n    returns (bool)\r\n  {\r\n    require(m_maxTokensPerAddress == 0 && m_decimals > 0);\r\n    m_maxTokensPerAddress = uint256(1000).mul(uint256(10)**uint256(m_decimals));\r\n\r\n    m_totalSupply = uint256(100000000).mul(uint256(10)**uint256(m_decimals));\r\n    // 70% for owner\r\n    m_balances[msg.sender] = m_totalSupply.mul(uint256(70)).div(uint256(100));\r\n    // 30% for sale\r\n    m_balances[address(this)] = m_totalSupply.sub(m_balances[msg.sender]);\r\n\r\n    // allow owner to transfer token from this  \r\n    m_allowed[address(this)][m_owner] = m_balances[address(this)];\r\n    return true;\r\n  }\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n// get from https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC20\r\n//\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return m_balances[owner];\r\n  }\r\n  \r\n  /**\r\n  * @dev The name of the token.\r\n  * @return The name of the token.\r\n  */\r\n  function name() public view returns (string) {\r\n    return m_name;\r\n  }\r\n\r\n  /**\r\n  * @dev The symbol of the token.\r\n  * @return The symbol of the token.\r\n  */\r\n  function symbol() public view returns (string) {\r\n    return m_symbol;\r\n  }\r\n\r\n  /**\r\n  * @dev The number of decimals the token.\r\n  * @return The number of decimals the token.\r\n  * @notice Uses - e.g. 8, means to divide the token.\r\n  * amount by 100000000 to get its user representation.\r\n  */\r\n  function decimals() public view returns (uint8) {\r\n    return m_decimals;\r\n  }\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence.\r\n  * @return Total number of tokens in existence.\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return m_totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  * @return Whether successful or not.\r\n  */\r\n  function transfer(address to, uint256 value) \r\n    public \r\n    onlyOwnerOrAtState(State.PublicUse)\r\n    validRecipient(to)\r\n    returns (bool) \r\n  {\r\n    // require(value <= m_balances[msg.sender]);\r\n    // SafeMath.sub will already throw if this condition is not met\r\n    m_balances[msg.sender] = m_balances[msg.sender].sub(value);\r\n    m_balances[to] = m_balances[to].add(value);\r\n    Transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another.\r\n   * @param from Address The address which you want to send tokens from.\r\n   * @param to Address The address which you want to transfer to.\r\n   * @param value Uint256 the amount of tokens to be transferred.\r\n   * @return Whether successful or not.\r\n   */\r\n  function transferFrom(address from, address to, uint256 value) \r\n    public\r\n    onlyOwnerOrAtState(State.PublicUse)\r\n    validRecipient(to)\r\n    returns (bool) \r\n  {\r\n    // require(value <= m_balances[from]);\r\n    // require(value <= m_allowed[from][msg.sender]);\r\n    // SafeMath.sub will already throw if this condition is not met\r\n    m_balances[from] = m_balances[from].sub(value);\r\n    m_balances[to] = m_balances[to].add(value);\r\n    m_allowed[from][msg.sender] = m_allowed[from][msg.sender].sub(value);\r\n    Transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return Whether successful or not.\r\n   */\r\n  function approve(address spender, uint256 value) \r\n    public\r\n    onlyOwnerOrAtState(State.PublicUse)\r\n    validRecipient(spender)\r\n    returns (bool) \r\n  {\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    // allowance to zero by calling `approve(spender,0)` if it is not\r\n    // already 0 to mitigate the race condition described here:\r\n    // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((value == 0) || (m_allowed[msg.sender][spender] == 0));\r\n\r\n    m_allowed[msg.sender][spender] = value;\r\n    Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner Address The address which owns the funds.\r\n   * @param spender Address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address owner, address spender) \r\n    public \r\n    view\r\n    returns (uint256) \r\n  {\r\n    return m_allowed[owner][spender];\r\n  }\r\n  \r\n  /**\r\n   * approve should be called when allowed[spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol.\r\n   *\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   * @return Whether successful or not.\r\n   */\r\n  function increaseApproval(address spender, uint addedValue) \r\n    public \r\n    onlyOwnerOrAtState(State.PublicUse)\r\n    validRecipient(spender)\r\n    returns (bool) \r\n  {\r\n    m_allowed[msg.sender][spender] = m_allowed[msg.sender][spender].add(addedValue);\r\n    Approval(msg.sender, spender, m_allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n   /**\r\n   * Approve should be called when allowed[spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol.\r\n   *\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   * @return Whether successful or not.\r\n   */\r\n  function decreaseApproval(address spender, uint subtractedValue) \r\n    public\r\n    onlyOwnerOrAtState(State.PublicUse)\r\n    validRecipient(spender)\r\n    returns (bool) \r\n  {\r\n    uint oldValue = m_allowed[msg.sender][spender];\r\n    if (subtractedValue > oldValue) {\r\n      m_allowed[msg.sender][spender] = 0;\r\n    } else {\r\n      m_allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n    }\r\n    Approval(msg.sender, spender, m_allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n///////////////////\r\n// ERC677 Methods\r\n//\r\n  /**\r\n  * @dev Transfer token to a contract address with additional data if the recipient is a contact.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  * @param extraData The extra data to be passed to the receiving contract.\r\n  * @return Whether successful or not.\r\n  */\r\n  function transferAndCall(address to, uint256 value, bytes extraData) \r\n    public\r\n    onlyOwnerOrAtState(State.PublicUse)\r\n    validRecipient(to)\r\n    returns (bool)\r\n  {\r\n    // require(value <= m_balances[msg.sender]);\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    m_balances[msg.sender] = m_balances[msg.sender].sub(value);\r\n    m_balances[to] = m_balances[to].add(value);\r\n    Transfer(msg.sender, to, value);\r\n    if (isContract(to)) {\r\n      contractFallback(to, value, extraData);\r\n      Transfer(msg.sender, to, value, extraData);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token all tokens to a contract address with additional data if the recipient is a contact.\r\n  * @param to The address to transfer all to.\r\n  * @param extraData The extra data to be passed to the receiving contract.\r\n  * @return Whether successful or not.\r\n  */\r\n  function transferAllAndCall(address to, bytes extraData) \r\n    external\r\n    onlyOwnerOrAtState(State.PublicUse)\r\n    returns (bool) \r\n  {\r\n    return transferAndCall(to, m_balances[msg.sender], extraData);\r\n  }\r\n  \r\n  /**\r\n  * @dev Call ERC677 tokenFallback for ERC677Recipient contract.\r\n  * @param to The address of ERC677Recipient.\r\n  * @param value Amount of tokens with was sended\r\n  * @param data Sended to ERC677Recipient.\r\n  * @return Whether contract or not.\r\n  */\r\n  function contractFallback(address to, uint value, bytes data)\r\n    internal\r\n  {\r\n    ERC677Recipient recipient = ERC677Recipient(to);\r\n    recipient.tokenFallback(msg.sender, value, data);\r\n  }\r\n\r\n  /**\r\n  * @dev Check addr if is contract.\r\n  * @param addr The address that checking.\r\n  * @return Whether contract or not.\r\n  */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint length;\r\n    assembly { length := extcodesize(addr) }\r\n    return length > 0;\r\n  }\r\n  \r\n  \r\n///////////////////\r\n// payable Methods\r\n// use withdrawal pattern \r\n// see: http://solidity.readthedocs.io/en/develop/common-patterns.html#withdrawal-from-contracts\r\n// see: https://consensys.github.io/smart-contract-best-practices/known_attacks/\r\n//\r\n  /**\r\n  * Recived ETH converted to tokens amount for price. sender has max limit for tokens \r\n  * amount as m_maxTokensPerAddress - balanceOf(sender). if amount <= max limit\r\n  * then transfer amount from this to sender and 95%ETH to bank, 5%ETH to owner.\r\n  * else amount > max limit then we calc cost of max limit of tokens,\r\n  * store this cost in m_pendingWithdrawals[sender] and m_myDebtInWei and \r\n  * transfer max limit of tokens from this to sender and 95% max limit cost to bank\r\n  * 5% max limit cost to owner.\r\n  *\r\n  * @dev Contract receive ETH (payable) from sender and transfer some amount of tokens to him.\r\n  */\r\n  function byTokens() public payable atState(State.Sale) {\r\n    // check if msg.sender can to by tokens \r\n    require(m_balances[msg.sender] < m_maxTokensPerAddress);\r\n\r\n    // get actual token price and set it\r\n    m_tokenPriceInWei = calcTokenPriceInWei();\r\n    \r\n    // check if msg.value has enough for by 1 token\r\n    require(msg.value >= m_tokenPriceInWei);\r\n    \r\n    // calc max available tokens for sender\r\n    uint256 maxAvailableTokens = m_maxTokensPerAddress.sub(m_balances[msg.sender]);\r\n    \r\n    // convert msg.value(wei) to tokens\r\n    uint256 tokensAmount = weiToTokens(msg.value, m_tokenPriceInWei);\r\n    \r\n    if (tokensAmount > maxAvailableTokens) {\r\n      // we CANT transfer all tokens amount, ONLY max available tokens \r\n      // calc cost in wei of max available tokens\r\n      // subtract cost from msg.value and store it as debt for sender\r\n      tokensAmount = maxAvailableTokens;  \r\n      // calc cost\r\n      uint256 tokensAmountCostInWei = tokensToWei(tokensAmount, m_tokenPriceInWei);\r\n      // calc debt\r\n      uint256 debt = msg.value.sub(tokensAmountCostInWei);\r\n      // Withdrawal pattern avoid Re-Entrancy (dont use transfer to unknow address)\r\n      // update pending withdrawals\r\n      m_pendingWithdrawals[msg.sender] = m_pendingWithdrawals[msg.sender].add(debt);\r\n      // update my debt\r\n      m_myDebtInWei = m_myDebtInWei.add(debt);\r\n    }\r\n    // transfer tokensAmount tokens form this to sender\r\n    // SafeMath.sub will already throw if this condition is not met\r\n    m_balances[address(this)] = m_balances[address(this)].sub(tokensAmount);\r\n    m_balances[msg.sender] = m_balances[msg.sender].add(tokensAmount);\r\n\r\n    // we can transfer eth to owner and bank, because we know that they \r\n    // dont use Re-Entrancy and other attacks.\r\n    // transfer 5% of eht-myDebt to owner\r\n    // owner cant be equal address(0) because this function to be accessible\r\n    // only in State.Sale but owner can be equal address(0), only in State.PublicUse\r\n    // State.Sale not equal State.PublicUse!\r\n    m_owner.transfer(this.balance.sub(m_myDebtInWei).mul(uint256(5)).div(uint256(100)));\r\n    // transfer 95% of eht-myDebt to bank\r\n    // bank cant be equal address(0) see setBank() and PonziToken()\r\n    m_bank.transfer(this.balance.sub(m_myDebtInWei));\r\n    checkValidityOfBalance(); // this.balance >= m_myDebtInWei\r\n    Transfer(address(this), msg.sender, tokensAmount);\r\n    TokensSold(tokensAmount, msg.sender, m_tokenPriceInWei); \r\n  }\r\n  \r\n  /**\r\n  * @dev Sender receive his pending withdrawals(if > 0).\r\n  */\r\n  function withdraw() external {\r\n    uint amount = m_pendingWithdrawals[msg.sender];\r\n    require(amount > 0);\r\n    // set zero the pending refund before\r\n    // sending to prevent Re-Entrancy \r\n    m_pendingWithdrawals[msg.sender] = 0;\r\n    m_myDebtInWei = m_myDebtInWei.sub(amount);\r\n    msg.sender.transfer(amount);\r\n    checkValidityOfBalance(); // this.balance >= m_myDebtInWei\r\n    Withdrawal(msg.sender, amount);\r\n  }\r\n\r\n  /**\r\n  * @notice http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\r\n  * we dont need recieve ETH always, only in State.Sale from externally accounts.\r\n  *\r\n  * @dev Fallback func, call byTokens().\r\n  */\r\n  function() public payable atState(State.Sale) {\r\n    byTokens();\r\n  }\r\n    \r\n  \r\n////////////////////////\r\n// external view methods\r\n// everyone outside has access \r\n//\r\n  /**\r\n  * @dev Gets the pending withdrawals of the specified address.\r\n  * @param owner The address to query the pending withdrawals of.\r\n  * @return An uint256 representing the amount withdrawals owned by the passed address.\r\n  */\r\n  function pendingWithdrawals(address owner) external view returns (uint256) {\r\n    return m_pendingWithdrawals[owner];\r\n  }\r\n  \r\n  /**\r\n  * @dev Get contract work state.\r\n  * @return Contract work state via string.\r\n  */\r\n  function state() external view returns (string stateString) {\r\n    if (m_state == State.PreSale) {\r\n      stateString = PRE_SALE_STR;\r\n    } else if (m_state == State.Sale) {\r\n      stateString = SALE_STR;\r\n    } else if (m_state == State.PublicUse) {\r\n      stateString = PUBLIC_USE_STR;\r\n    }\r\n  }\r\n  \r\n  /**\r\n  * @dev Get price of one token in wei.\r\n  * @return Price of one token in wei.\r\n  */\r\n  function tokenPriceInWei() public view returns (uint256) {\r\n    return calcTokenPriceInWei();\r\n  }\r\n  \r\n  /**\r\n  * @dev Get address of the bank.\r\n  * @return Address of the bank. \r\n  */\r\n  function bank() external view returns(address) {\r\n    return m_bank;\r\n  }\r\n  \r\n  /**\r\n  * @dev Get timestamp of first entrance to sale state.\r\n  * @return Timestamp of first entrance to sale state.\r\n  */\r\n  function firstEntranceToSaleStateUNIX() \r\n    external\r\n    view \r\n    returns(uint256) \r\n  {\r\n    return m_firstEntranceToSaleStateUNIX;\r\n  }\r\n  \r\n  /**\r\n  * @dev Get address of the price setter.\r\n  * @return Address of the price setter.\r\n  */\r\n  function priceSetter() external view returns (address) {\r\n    return m_priceSetter;\r\n  }\r\n\r\n////////////////////\r\n// public methods\r\n// only for owner\r\n//\r\n  /**\r\n  * @dev Owner do disown.\r\n  */ \r\n  function disown() external atState(State.PublicUse) onlyOwner() {\r\n    delete m_owner;\r\n  }\r\n  \r\n  /**\r\n  * @dev Set state of contract working.\r\n  * @param newState String representation of new state.\r\n  */ \r\n  function setState(string newState) \r\n    external \r\n    onlyOwner()\r\n    checkAccess()\r\n  {\r\n    if (keccak256(newState) == keccak256(PRE_SALE_STR)) {\r\n      m_state = State.PreSale;\r\n    } else if (keccak256(newState) == keccak256(SALE_STR)) {\r\n      if (m_firstEntranceToSaleStateUNIX == 0) \r\n        m_firstEntranceToSaleStateUNIX = now;\r\n        \r\n      m_state = State.Sale;\r\n    } else if (keccak256(newState) == keccak256(PUBLIC_USE_STR)) {\r\n      m_state = State.PublicUse;\r\n    } else {\r\n      // if newState not valid string\r\n      revert();\r\n    }\r\n    StateChanged(msg.sender, m_state);\r\n  }\r\n\r\n  /**\r\n  * If token price not fix then actual price \r\n  * always will be tokenPriceInWeiForDay(day).\r\n  *\r\n  * @dev Set price of one token in wei and fix it.\r\n  * @param newTokenPriceInWei Price of one token in wei.\r\n  */ \r\n  function setAndFixTokenPriceInWei(uint256 newTokenPriceInWei) \r\n    external\r\n    checkAccess()\r\n  {\r\n    require(msg.sender == m_owner || msg.sender == m_priceSetter);\r\n    m_isFixedTokenPrice = true;\r\n    m_tokenPriceInWei = newTokenPriceInWei;\r\n    PriceChanged(msg.sender, m_tokenPriceInWei, m_isFixedTokenPrice);\r\n  }\r\n  \r\n  /**\r\n  * If token price is unfixed then actual will be tokenPriceInWeiForDay(day).\r\n  * \r\n  * @dev Set unfix token price to true.\r\n  */\r\n  function unfixTokenPriceInWei() \r\n    external\r\n    checkAccess()\r\n  {\r\n    require(msg.sender == m_owner || msg.sender == m_priceSetter);\r\n    m_isFixedTokenPrice = false;\r\n    PriceChanged(msg.sender, m_tokenPriceInWei, m_isFixedTokenPrice);\r\n  }\r\n  \r\n  /**\r\n  * @dev Set the PriceSetter address, which has access to set one token price in wei.\r\n  * @param newPriceSetter The address of new PriceSetter.\r\n  */\r\n  function setPriceSetter(address newPriceSetter) \r\n    external \r\n    onlyOwner() \r\n    checkAccess()\r\n  {\r\n    m_priceSetter = newPriceSetter;\r\n  }\r\n\r\n  /**\r\n  * @dev Set the bank, which receive 95%ETH from tokens sale.\r\n  * @param newBank The address of new bank.\r\n  */\r\n  function setBank(address newBank) \r\n    external\r\n    validRecipient(newBank) \r\n    onlyOwner()\r\n    checkAccess()\r\n  {\r\n    require(newBank != address(0));\r\n    m_bank = newBank;\r\n  }\r\n\r\n////////////////////////\r\n// internal pure methods\r\n//\r\n  /**\r\n  * @dev Convert token to wei.\r\n  * @param tokensAmount Amout of tokens.\r\n  * @param tokenPrice One token price in wei.\r\n  * @return weiAmount Result amount of convertation. \r\n  */\r\n  function tokensToWei(uint256 tokensAmount, uint256 tokenPrice) \r\n    internal\r\n    pure\r\n    returns(uint256 weiAmount)\r\n  {\r\n    weiAmount = tokensAmount.mul(tokenPrice); \r\n  }\r\n  \r\n  /**\r\n  * @dev Conver wei to token.\r\n  * @param weiAmount Wei amout.\r\n  * @param tokenPrice One token price in wei.\r\n  * @return tokensAmount Result amount of convertation.\r\n  */\r\n  function weiToTokens(uint256 weiAmount, uint256 tokenPrice) \r\n    internal \r\n    pure \r\n    returns(uint256 tokensAmount) \r\n  {\r\n    tokensAmount = weiAmount.div(tokenPrice);\r\n  }\r\n \r\n////////////////////////\r\n// private view methods\r\n//\r\n  /**\r\n  * @dev Get actual token price.\r\n  * @return price One token price in wei. \r\n  */\r\n  function calcTokenPriceInWei() \r\n    private \r\n    view \r\n    returns(uint256 price) \r\n  {\r\n    if (m_isFixedTokenPrice) {\r\n      // price is fixed, return current val\r\n      price = m_tokenPriceInWei;\r\n    } else {\r\n      // price not fixed, we must to calc price\r\n      if (m_firstEntranceToSaleStateUNIX == 0) {\r\n        // if contract dont enter to SaleState then price = 0 \r\n        price = 0;\r\n      } else {\r\n        // calculate day after first Entrance To Sale State\r\n        uint256 day = now.sub(m_firstEntranceToSaleStateUNIX).div(1 days);\r\n        // use special formula for calcutation price\r\n        price = tokenPriceInWeiForDay(day);\r\n      }\r\n    } \r\n  }\r\n  \r\n  /**\r\n  * @dev Get token price for specific day after starting sale tokens.\r\n  * @param day Secific day.\r\n  * @return price One token price in wei for specific day. \r\n  */\r\n  function tokenPriceInWeiForDay(uint256 day) \r\n    private \r\n    view \r\n    returns(uint256 price)\r\n  {\r\n    // day 1:   price 1*10^(decimals) TOKEN = 0.001 ETH\r\n    //          price 1 TOKEN = 1 * 10^(-3) ETH / 10^(decimals), in ETH\r\n    //          convert to wei:\r\n    //          price 1 TOKEN = 1 * 10^(-3) * wei * 10^(-decimals)\r\n    //          price 1 TOKEN = 1 * 10^(-3) * 10^(18) * 10^(-decimals)\r\n    //          price 1 TOKEN = 1 * 10^(15) * 10^(-decimals), in WEI\r\n    \r\n    // day 2:   price 1*10^(decimals) TOKEN = 0.002 ETH;\r\n    //          price 1 TOKEN = 2 * 10^(15) * 10^(-decimals), in WEI\r\n    // ...\r\n    // day 12:  price 1*10^(decimals) TOKEN = 0.012 ETH;\r\n    //          price 1 TOKEN = 12 * 10^(15) * 10^(-decimals), in WEI\r\n    \r\n    // day >12: price 1*10^(decimals) TOKEN = 0.012 ETH;\r\n    //          price 1 TOKEN = 12 * 10^(15) * 10^(-decimals), in WEI\r\n\r\n    // from 0 to 11 - sum is 12 days\r\n    if (day <= 11) \r\n      price = day.add(1);// because from >0h to <24h after start day will be 0, \r\n    else                 // but for calc price it must be 1;\r\n      price = 12;\r\n    // convert to WEI\r\n    price = price.mul(uint256(10**15)).div(10**uint256(m_decimals));\r\n  }\r\n  \r\n  /**\r\n  * @notice It is always must be true, for correct withdrawals and receivers ETH.\r\n  *\r\n  * Check if this.balance >= m_myDebtInWei.\r\n  */\r\n  function checkValidityOfBalance() private view {\r\n    // assertion is not a strict equality of the balance because the contract \r\n    // can be forcibly sent ether without going through the byTokens() func.\r\n    // selfdestruct does not trigger a contract's fallback function. \r\n    // see: http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\r\n    assert(this.balance >= m_myDebtInWei);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBank\",\"type\":\"address\"}],\"name\":\"setBank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokenPriceInWei\",\"type\":\"uint256\"}],\"name\":\"setAndFixTokenPriceInWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceSetter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPriceSetter\",\"type\":\"address\"}],\"name\":\"setPriceSetter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newState\",\"type\":\"string\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstEntranceToSaleStateUNIX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"stateString\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"transferAllAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"byTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfixTokenPriceInWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isFixed\",\"type\":\"bool\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"purchasedBy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"TokensSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sumInWei\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"PonziToken","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://03c0523e2b1b3696b8d35ceacaf1567e8044c8e5ac63f79a20068e089cd158d4"}]}