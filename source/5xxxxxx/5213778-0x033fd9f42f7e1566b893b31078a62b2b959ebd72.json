{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20; \r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint256);\r\n    function balanceOf(address owner) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\n\r\ninterface ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token) external;\r\n}\r\n\r\ncontract TRLCoinSale is ApproveAndCallFallBack {\r\n    // Information about a single period\r\n    struct Period {\r\n        uint start;\r\n        uint end;\r\n        uint priceInWei;\r\n        uint tokens;\r\n    }\r\n\r\n    // Information about payment contribution\r\n    struct PaymentContribution {\r\n        uint weiContributed;\r\n        uint timeContribution;\r\n        uint receiveTokens;\r\n    }\r\n\r\n    struct TotalContribution {\r\n        // total value of contribution;\r\n        // for empty address it will be zero\r\n        uint totalReceiveTokens;\r\n        // Only necessary if users want to be able to see contribution history. \r\n        // Otherwise, technically not necessary for the purposes of the sale\r\n        PaymentContribution[] paymentHistory; \r\n    }\r\n\r\n    // Some constant about our expected token distribution\r\n    uint public constant TRLCOIN_DECIMALS = 0;\r\n    uint public constant TOTAL_TOKENS_TO_DISTRIBUTE = 800000000 * (10 ** TRLCOIN_DECIMALS); // 800000000  TRL Token for distribution\r\n    uint public constant TOTAL_TOKENS_AVAILABLE = 1000000000 * (10 ** TRLCOIN_DECIMALS);    // 1000000000 TRL Token totals\r\n\r\n    // ERC20 Contract address.\r\n    ERC20Interface private tokenWallet; // The token wallet contract used for this crowdsale\r\n    \r\n    address private owner;  // The owner of the crowdsale\r\n    \r\n    uint private smallBonus; //The small bonus for presale\r\n    uint private largeBonus; //The large bonus for presale\r\n    uint private largeBonusStopTime; //The stop time for Large bonus\r\n\r\n    uint private tokensRemainingForSale; //Remaining total amout of tokens  \r\n    uint private tokensAwardedForSale;   // total awarded tokens\r\n\r\n    uint private distributionTime; // time after we could start distribution tokens\r\n    \r\n    Period private preSale; // The configured periods for this crowdsale\r\n    Period private sale;    // The configured periods for this crowdsale\r\n    \r\n    \r\n    // pair fo variables one for mapping one for iteration\r\n    mapping(address => TotalContribution) public payments; // Track contributions by each address \r\n    address[] public paymentAddresses;\r\n\r\n    bool private hasStarted; // Has the crowdsale started?\r\n    \r\n    // Fired once the transfer tokens to contract was successfull\r\n    event Transfer(address indexed to, uint amount);\r\n\r\n    // Fired once the sale starts\r\n    event Start(uint timestamp);\r\n\r\n    // Fired whenever a contribution is made\r\n    event Contribute(address indexed from, uint weiContributed, uint tokensReceived);\r\n\r\n    // Fires whenever we send token to contributor\r\n    event Distribute( address indexed to, uint tokensSend );\r\n\r\n    function addContribution(address from, uint weiContributed, uint tokensReceived) private returns(bool) {\r\n        //new contibutor\r\n        require(weiContributed > 0);\r\n        require(tokensReceived > 0);\r\n        require(tokensRemainingForSale >= tokensReceived);\r\n        \r\n        PaymentContribution memory newContribution;\r\n        newContribution.timeContribution = block.timestamp;\r\n        newContribution.weiContributed = weiContributed;\r\n        newContribution.receiveTokens = tokensReceived;\r\n\r\n        // Since we cannot contribute zero tokens, if totalReceiveTokens is zero,\r\n        // then this is the first contribution for this address\r\n        if (payments[from].totalReceiveTokens == 0) {\r\n            // new total contribution           \r\n            payments[from].totalReceiveTokens = tokensReceived;\r\n            payments[from].paymentHistory.push(newContribution);\r\n            \r\n             // push new address to array for iteration by address  during distirbution process\r\n            paymentAddresses.push(from);\r\n        } else {\r\n            payments[from].totalReceiveTokens += tokensReceived;\r\n            payments[from].paymentHistory.push(newContribution);\r\n        }\r\n        tokensRemainingForSale -= tokensReceived;\r\n        tokensAwardedForSale += tokensReceived;\r\n        return true;\r\n    }\r\n\r\n    // public getters for private state variables\r\n    function getOwner() public view returns (address) { return owner; }\r\n    function getHasStartedState() public view  returns(bool) { return hasStarted; }\r\n    function getPresale() public view returns(uint, uint, uint, uint) { \r\n        return (preSale.start, preSale.end, preSale.priceInWei, preSale.tokens);\r\n    }\r\n    function getSale() public view returns(uint, uint, uint, uint) { \r\n        return (sale.start, sale.end, sale.priceInWei, sale.tokens);\r\n    }\r\n    function getDistributionTime() public view returns(uint) { return distributionTime; }\r\n    \r\n    function getSmallBonus() public view returns(uint) { return smallBonus; }\r\n    function getLargeBonus() public view returns(uint) { return largeBonus; }\r\n    function getLargeBonusStopTime() public view returns(uint) { return  largeBonusStopTime; }\r\n    function getTokenRemaining() public view returns(uint) { return tokensRemainingForSale; }\r\n    function getTokenAwarded() public view returns(uint) { return tokensAwardedForSale; }\r\n\r\n    // After create sale contract first function should be approveAndCall on Token contract\r\n    // with this contract as spender and TOTAL_TOKENS_TO_DISTRIBUTE for approval\r\n    // this callback function called form Token contract after approve on Token contract\r\n    // eventually tokensRemainingForSale = TOTAL_TOKENS_TO_DISTRIBUTE\r\n    function receiveApproval(address from, uint256 tokens, address token) external {\r\n        // make sure the sales was not started\r\n        require(hasStarted == false);\r\n        \r\n        // make sure this token address matches our configured tokenWallet address\r\n        require(token == address(tokenWallet)); \r\n        \r\n        tokensRemainingForSale += tokens;\r\n        bool result = tokenWallet.transferFrom(from, this, tokens);\r\n        // Make sure transfer succeeded\r\n        require(result == true);\r\n        \r\n        Transfer(address(this), tokens);\r\n    }\r\n\r\n    // contract constructor\r\n    function TRLCoinSale(address walletAddress) public {\r\n        // Setup the owner and wallet\r\n        owner = msg.sender;\r\n        tokenWallet = ERC20Interface(walletAddress);\r\n\r\n        // Make sure the provided token has the expected number of tokens to distribute\r\n        require(tokenWallet.totalSupply() == TOTAL_TOKENS_AVAILABLE);\r\n\r\n        // Make sure the owner actually controls all the tokens\r\n        require(tokenWallet.balanceOf(owner) >= TOTAL_TOKENS_TO_DISTRIBUTE);\r\n\r\n        // The multiplier necessary to change a coin amount to the token amount\r\n        uint coinToTokenFactor = 10 ** TRLCOIN_DECIMALS;\r\n\r\n        preSale.start = 1520812800; // 00:00:00, March 12, 2018 UTC use next site https://www.epochconverter.com/\r\n        preSale.end = 1523491199; // 23:59:59, July 11, 2018 UTC\r\n        preSale.priceInWei = (1 ether) / (20000 * coinToTokenFactor); // 1 ETH = 20000 TRL\r\n        preSale.tokens = TOTAL_TOKENS_TO_DISTRIBUTE / 2;\r\n       \r\n        smallBonus = 10;\r\n        largeBonus = 20;\r\n        largeBonusStopTime = 1521504000;\r\n    \r\n        sale.start = 1523491200; // 00:00:00, July 12, 2018 UTC use next site https://www.epochconverter.com/\r\n        sale.end = 1531378799; // 23:59:59, July 11, 2018 UTC\r\n        sale.priceInWei = (1 ether) / (10000 * coinToTokenFactor); // 1 ETH = 10000 TRL\r\n        sale.tokens = TOTAL_TOKENS_TO_DISTRIBUTE / 2;\r\n        \r\n        distributionTime = 1531378800; // 00:00:00, June 12, 2018 UTC\r\n\r\n        tokensRemainingForSale = 0;\r\n        tokensAwardedForSale = 0;\r\n    }\r\n\r\n    // change default presale dates \r\n    function setPresaleDates(uint startDate, uint stopDate) public {\r\n        // Only the owner can do this\r\n        require(msg.sender == owner); \r\n        // Cannot change if already started\r\n        require(hasStarted == false);\r\n        //insanity check start < stop and stop resale < start of sale\r\n        require(startDate < stopDate && stopDate < sale.start);\r\n        \r\n        preSale.start = startDate;\r\n        preSale.end = stopDate;\r\n    }\r\n    \r\n    // change default presale dates \r\n    function setlargeBonusStopTime(uint bonusStopTime) public {\r\n        // Only the owner can do this\r\n        require(msg.sender == owner); \r\n        // Cannot change if already started\r\n        require(hasStarted == false);\r\n        //insanity check start < stop and stop resale < start of sale\r\n        require(preSale.start <= bonusStopTime && bonusStopTime <= preSale.end);\r\n        \r\n        largeBonusStopTime = bonusStopTime;\r\n    }\r\n    \r\n    // change default sale dates \r\n    function setSale(uint startDate, uint stopDate) public {\r\n        // Only the owner can do this\r\n        require(msg.sender == owner); \r\n        // Cannot change if already started\r\n        require(hasStarted == false);\r\n        // insanity check start < stop and stop resale < start of sale\r\n        require(startDate < stopDate && startDate > preSale.end);\r\n        // insanity check sale.end < distirbution token time\r\n        require(sale.end < distributionTime);\r\n        \r\n        sale.start = startDate;\r\n        sale.end = stopDate;\r\n    }\r\n\r\n    // change default distibution time\r\n    function setDistributionTime(uint timeOfDistribution) public {\r\n        // Only the owner can do this\r\n        require(msg.sender == owner); \r\n        // Cannot change if already started\r\n        require(hasStarted == false);\r\n        // insanity check sale.end < distirbution token time\r\n        require(sale.end < timeOfDistribution);\r\n        \r\n        distributionTime = timeOfDistribution;\r\n    }\r\n\r\n    // this function added Contributor that already made contribution before presale started \r\n    // should be called only after token was transfered to Sale contract\r\n    function addContributorManually( address who, uint contributionWei, uint tokens) public returns(bool) {\r\n        // only owner\r\n        require(msg.sender == owner);   \r\n        //contract must be not active\r\n        require(hasStarted == false);\r\n        // all entried must be added before presale started\r\n        require(block.timestamp < preSale.start);\r\n        // contract mush have total == TOTAL_TOKENS_TO_DISTRIBUTE\r\n        require((tokensRemainingForSale + tokensAwardedForSale) == TOTAL_TOKENS_TO_DISTRIBUTE);\r\n        \r\n        // decrement presale - token for manual contibution should be taken from presale\r\n        preSale.tokens -= tokens;\r\n\r\n        addContribution(who, contributionWei, tokens);\r\n        Contribute(who, contributionWei, tokens);\r\n        return true;\r\n    }\r\n\r\n    // Start the crowdsale\r\n    function startSale() public {\r\n        // Only the owner can do this\r\n        require(msg.sender == owner); \r\n        // Cannot start if already started\r\n        require(hasStarted == false);\r\n        // Make sure the timestamps all make sense\r\n        require(preSale.end > preSale.start);\r\n        require(sale.end > sale.start);\r\n        require(sale.start > preSale.end);\r\n        require(distributionTime > sale.end);\r\n\r\n        // Make sure the owner actually controls all the tokens for sales\r\n        require(tokenWallet.balanceOf(address(this)) == TOTAL_TOKENS_TO_DISTRIBUTE);\r\n        require((tokensRemainingForSale + tokensAwardedForSale) == TOTAL_TOKENS_TO_DISTRIBUTE);\r\n\r\n        // Make sure we allocated all sale tokens\r\n        require((preSale.tokens + sale.tokens) == tokensRemainingForSale);          \r\n\r\n        // The sale can begin\r\n        hasStarted = true;\r\n\r\n        // Fire event that the sale has begun\r\n        Start(block.timestamp);\r\n    }    \r\n\r\n    // Allow the current owner to change the owner of the crowdsale\r\n    function changeOwner(address newOwner) public {\r\n        // Only the owner can do this\r\n        require(msg.sender == owner);\r\n\r\n        // Change the owner\r\n        owner = newOwner;\r\n    }\r\n\r\n    function preSaleFinishedProcess( uint timeOfRequest) private returns(bool) {\r\n        // if we have Sales event and tokens of presale is not 0 move them to sales\r\n        require(timeOfRequest >= sale.start && timeOfRequest <= sale.end);\r\n        if (preSale.tokens != 0) {\r\n            uint savePreSaleTomens = preSale.tokens;\r\n            preSale.tokens = 0;\r\n            sale.tokens += savePreSaleTomens;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    // Calculate how many tokens can be distributed for the given contribution\r\n    function getTokensForContribution(uint weiContribution) private returns(uint timeOfRequest, uint tokenAmount, uint weiRemainder, uint bonus) { \r\n        // Get curent time\r\n        timeOfRequest = block.timestamp;\r\n        // just for sure that bonus is initialized\r\n        bonus = 0;\r\n                 \r\n        // checking what period are we\r\n        if (timeOfRequest <= preSale.end) {\r\n            // Return the amount of tokens that can be purchased\r\n            // And the amount of wei that would be left over\r\n            tokenAmount = weiContribution / preSale.priceInWei;\r\n            weiRemainder = weiContribution % preSale.priceInWei;\r\n            // if presale - checking bonuses\r\n            if (timeOfRequest < largeBonusStopTime) {\r\n                bonus = ( tokenAmount * largeBonus ) / 100;\r\n            } else {\r\n                bonus = ( tokenAmount * smallBonus ) / 100;\r\n            }             \r\n        } else {\r\n            // if sales period just started - transfer all remaining tokens from presale to sale\r\n            preSaleFinishedProcess(timeOfRequest);\r\n            // Return the amount of tokens that can be purchased\r\n            // And the amount of wei that would be left over\r\n            tokenAmount = weiContribution / sale.priceInWei;\r\n            weiRemainder = weiContribution % sale.priceInWei;\r\n        } \r\n        return(timeOfRequest, tokenAmount, weiRemainder, bonus);\r\n    }\r\n    \r\n    function()public payable {\r\n        // Cannot contribute if the sale hasn't started\r\n        require(hasStarted == true);\r\n        // Cannot contribute if sale is not in this time range\r\n        require((block.timestamp >= preSale.start && block.timestamp <= preSale.end)\r\n            || (block.timestamp >= sale.start && block.timestamp <= sale.end)\r\n        ); \r\n\r\n        // Cannot contribute if amount of money send is les then 0.1 ETH\r\n        require(msg.value >= 100 finney);\r\n        \r\n        uint timeOfRequest;\r\n        uint tokenAmount;\r\n        uint weiRemainder;\r\n        uint bonus;\r\n        // Calculate the tokens to be distributed based on the contribution amount\r\n        (timeOfRequest, tokenAmount, weiRemainder, bonus) = getTokensForContribution(msg.value);\r\n\r\n        // Make sure there are enough tokens left to buy\r\n        require(tokensRemainingForSale >= tokenAmount + bonus);\r\n        \r\n        // Need to contribute enough for at least 1 token\r\n        require(tokenAmount > 0);\r\n        \r\n        // Sanity check: make sure the remainder is less or equal to what was sent to us\r\n        require(weiRemainder <= msg.value);\r\n\r\n        // Check whether in presale or sale\r\n        if (timeOfRequest <= preSale.end) {\r\n            require(tokenAmount <= preSale.tokens);\r\n            require(bonus <= sale.tokens);\r\n            preSale.tokens -= tokenAmount;\r\n            sale.tokens -= bonus;\r\n        } else {\r\n            require(tokenAmount <= sale.tokens);\r\n            // there should be no bonus available after presale\r\n            require(bonus == 0); \r\n            sale.tokens -= tokenAmount;\r\n        }\r\n\r\n        // setup new contribution\r\n        addContribution(msg.sender, msg.value - weiRemainder, tokenAmount + bonus);\r\n\r\n        /// Transfer contribution amount to owner\r\n        owner.transfer(msg.value - weiRemainder);\r\n        // Return the remainder to the sender\r\n        msg.sender.transfer(weiRemainder);\r\n\r\n        // Since we refunded the remainder, the actual contribution is the amount sent\r\n        // minus the remainder\r\n        \r\n        // Record the event\r\n        Contribute(msg.sender, msg.value - weiRemainder, tokenAmount + bonus);\r\n    } \r\n\r\n    \r\n    // Allow the owner to withdraw all the tokens remaining after the\r\n    // crowdsale is over\r\n    function withdrawTokensRemaining() public returns (bool) {\r\n        // Only the owner can do this\r\n        require(msg.sender == owner);\r\n        // The crowsale must be over to perform this operation\r\n        require(block.timestamp > sale.end);\r\n        // Get the remaining tokens owned by the crowdsale\r\n        uint tokenToSend = tokensRemainingForSale;\r\n        // Set available tokens to Zero\r\n        tokensRemainingForSale = 0;\r\n        sale.tokens = 0;\r\n        // Transfer them all to the owner\r\n        bool result = tokenWallet.transfer(owner, tokenToSend);\r\n        // Be sure that transfer was successfull\r\n        require(result == true);\r\n        Distribute(owner, tokenToSend);\r\n        return true;\r\n    }\r\n\r\n    // Allow the owner to withdraw all ether from the contract after the crowdsale is over.\r\n    // We don't need this function( we transfer ether immediately to owner - just in case\r\n    function withdrawEtherRemaining() public returns (bool) {\r\n        // Only the owner can do this\r\n        require(msg.sender == owner);\r\n        // The crowsale must be over to perform this operation\r\n        require(block.timestamp > sale.end);\r\n\r\n        // Transfer them all to the owner\r\n        owner.transfer(this.balance);\r\n        return true;\r\n    }\r\n\r\n    // this function is intentionally internal because we do not check conditions here\r\n    function transferTokensToContributor(uint idx) private returns (bool) {\r\n        if (payments[paymentAddresses[idx]].totalReceiveTokens > 0) {\r\n            // this is for race conditions               \r\n            uint tokenToSend = payments[paymentAddresses[idx]].totalReceiveTokens;\r\n            payments[paymentAddresses[idx]].totalReceiveTokens = 0;\r\n            \r\n            //decrement awarded token\r\n            require(tokensAwardedForSale >= tokenToSend);\r\n            tokensAwardedForSale -= tokenToSend;\r\n            // Transfer them all to the owner\r\n            bool result = tokenWallet.transfer(paymentAddresses[idx], tokenToSend);\r\n            // Be sure that transfer was successfull\r\n            require(result == true);\r\n            Distribute(paymentAddresses[idx], tokenToSend);\r\n        }\r\n        return true;\r\n\r\n    }\r\n    \r\n    // get number of real contributors\r\n    function getNumberOfContributors( ) public view returns (uint) {\r\n        return paymentAddresses.length;\r\n    }\r\n    \r\n    // This function for transfer tokens one by one\r\n    function distributeTokensToContributorByIndex( uint indexVal) public returns (bool) {\r\n        // this is regular check for this function\r\n        require(msg.sender == owner);\r\n        require(block.timestamp >= distributionTime);\r\n        require(indexVal < paymentAddresses.length);\r\n        \r\n        transferTokensToContributor(indexVal);                    \r\n        return true;        \r\n    }\r\n\r\n    function distributeTokensToContributor( uint startIndex, uint numberOfContributors )public returns (bool) {\r\n        // this is regular check for this function\r\n        require(msg.sender == owner);\r\n        require(block.timestamp >= distributionTime);\r\n        require(startIndex < paymentAddresses.length);\r\n        \r\n        uint len = paymentAddresses.length < startIndex + numberOfContributors? paymentAddresses.length : startIndex + numberOfContributors;\r\n        for (uint i = startIndex; i < len; i++) {\r\n            transferTokensToContributor(i);                    \r\n        }\r\n        return true;        \r\n    }\r\n\r\n    function distributeAllTokensToContributor( )public returns (bool) {\r\n        // this is regular check for this function\r\n        require(msg.sender == owner);\r\n        require(block.timestamp >= distributionTime);\r\n        \r\n        for (uint i = 0; i < paymentAddresses.length; i++) {\r\n            transferTokensToContributor(i); \r\n        }\r\n        return true;        \r\n    }\r\n    \r\n    // Owner can transfer out any accidentally sent ERC20 tokens as long as they are not the sale tokens\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool) {\r\n        require(msg.sender == owner);\r\n        require(tokenAddress != address(tokenWallet));\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAwarded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHasStartedState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSmallBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"contributionWei\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"addContributorManually\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokensRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"numberOfContributors\",\"type\":\"uint256\"}],\"name\":\"distributeTokensToContributor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"indexVal\",\"type\":\"uint256\"}],\"name\":\"distributeTokensToContributorByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_TOKENS_TO_DISTRIBUTE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDistributionTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfContributors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEtherRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_TOKENS_AVAILABLE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLargeBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLargeBonusStopTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TRLCOIN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributeAllTokensToContributor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timeOfDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistributionTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"stopDate\",\"type\":\"uint256\"}],\"name\":\"setPresaleDates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"totalReceiveTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bonusStopTime\",\"type\":\"uint256\"}],\"name\":\"setlargeBonusStopTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"stopDate\",\"type\":\"uint256\"}],\"name\":\"setSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiContributed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensReceived\",\"type\":\"uint256\"}],\"name\":\"Contribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensSend\",\"type\":\"uint256\"}],\"name\":\"Distribute\",\"type\":\"event\"}]","ContractName":"TRLCoinSale","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000001dae2898900622f79c5d09e7363693cd1f48be8","Library":"","SwarmSource":"bzzr://ecc1700d8dbcf4c1b6356c104d44d4400e4e22515be70fe20fab5bb74912f641"}]}