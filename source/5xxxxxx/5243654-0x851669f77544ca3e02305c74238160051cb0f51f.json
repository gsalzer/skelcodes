{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.20;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed burner, uint256 value);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// VIOLET ERC20 Standard Token\r\n// ----------------------------------------------------------------------------\r\ncontract VLTToken is ERC20Interface {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner = msg.sender;\r\n\r\n    bytes32 public symbol;\r\n    bytes32 public name;\r\n    uint8 public decimals;\r\n    uint256 public _totalSupply;\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping(address => mapping (address => uint256)) internal allowed;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function VLTToken() public {\r\n        symbol = \"VAI\";\r\n        name = \"VIOLET\";\r\n        decimals = 18;\r\n        _totalSupply = 250000000 * 10**uint256(decimals);\r\n        balances[owner] = _totalSupply;\r\n        Transfer(address(0), owner, _totalSupply);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        // allow sending 0 tokens\r\n        if (_value == 0) {\r\n            Transfer(msg.sender, _to, _value);    // Follow the spec to louch the event when transfer 0\r\n            return;\r\n        }\r\n        \r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        // allow sending 0 tokens\r\n        if (_value == 0) {\r\n            Transfer(_from, _to, _value);    // Follow the spec to louch the event when transfer 0\r\n            return;\r\n        }\r\n\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n        allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Burns a specific amount of tokens.\r\n    * @param _value The amount of token to be burned.\r\n    */\r\n    function burn(uint256 _value) public {\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n        Transfer(burner, address(0), _value);\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool) {\r\n        require(_value <= balances[_from]);               // Check if the targeted balance is enough\r\n        require(_value <= allowed[_from][msg.sender]);    // Check allowed allowance\r\n        balances[_from] = balances[_from].sub(_value);  // Subtract from the targeted balance\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);             // Subtract from the sender's allowance\r\n        _totalSupply = _totalSupply.sub(_value);                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        Transfer(_from, address(0), _value);\r\n        return true;\r\n    } \r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ViolaCrowdsale\r\n * @dev ViolaCrowdsale reserves token from supply when eth is received\r\n * funds will be forwarded after the end of crowdsale. Tokens will be claimable\r\n * within 7 days after crowdsale ends.\r\n */\r\n \r\ncontract ViolaCrowdsale is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  enum State { Deployed, PendingStart, Active, Paused, Ended, Completed }\r\n\r\n  //Status of contract\r\n  State public status = State.Deployed;\r\n\r\n  // The token being sold\r\n  VLTToken public violaToken;\r\n\r\n  //For keeping track of whitelist address. cap >0 = whitelisted\r\n  mapping(address=>uint) public maxBuyCap;\r\n\r\n  //For checking if address passed KYC\r\n  mapping(address => bool)public addressKYC;\r\n\r\n  //Total wei sum an address has invested\r\n  mapping(address=>uint) public investedSum;\r\n\r\n  //Total violaToken an address is allocated\r\n  mapping(address=>uint) public tokensAllocated;\r\n\r\n    //Total violaToken an address purchased externally is allocated\r\n  mapping(address=>uint) public externalTokensAllocated;\r\n\r\n  //Total bonus violaToken an address is entitled after vesting\r\n  mapping(address=>uint) public bonusTokensAllocated;\r\n\r\n  //Total bonus violaToken an address purchased externally is entitled after vesting\r\n  mapping(address=>uint) public externalBonusTokensAllocated;\r\n\r\n  //Store addresses that has registered for crowdsale before (pushed via setWhitelist)\r\n  //Does not mean whitelisted as it can be revoked. Just to track address for loop\r\n  address[] public registeredAddress;\r\n\r\n  //Total amount not approved for withdrawal\r\n  uint256 public totalApprovedAmount = 0;\r\n\r\n  //Start and end timestamps where investments are allowed (both inclusive)\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  uint256 public bonusVestingPeriod = 60 days;\r\n\r\n\r\n  /**\r\n   * Note all values are calculated in wei(uint256) including token amount\r\n   * 1 ether = 1000000000000000000 wei\r\n   * 1 viola = 1000000000000000000 vi lawei\r\n   */\r\n\r\n\r\n  //Address where funds are collected\r\n  address public wallet;\r\n\r\n  //Min amount investor can purchase\r\n  uint256 public minWeiToPurchase;\r\n\r\n  // how many token units *in wei* a buyer gets *per wei*\r\n  uint256 public rate;\r\n\r\n  //Extra bonus token to give *in percentage*\r\n  uint public bonusTokenRateLevelOne = 20;\r\n  uint public bonusTokenRateLevelTwo = 15;\r\n  uint public bonusTokenRateLevelThree = 10;\r\n  uint public bonusTokenRateLevelFour = 0;\r\n\r\n  //Total amount of tokens allocated for crowdsale\r\n  uint256 public totalTokensAllocated;\r\n\r\n  //Total amount of tokens reserved from external sources\r\n  //Sub set of totalTokensAllocated ( totalTokensAllocated - totalReservedTokenAllocated = total tokens allocated for purchases using ether )\r\n  uint256 public totalReservedTokenAllocated;\r\n\r\n  //Numbers of token left above 0 to still be considered sold\r\n  uint256 public leftoverTokensBuffer;\r\n\r\n  /**\r\n   * event for front end logging\r\n   */\r\n\r\n  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount, uint256 bonusAmount);\r\n  event ExternalTokenPurchase(address indexed purchaser, uint256 amount, uint256 bonusAmount);\r\n  event ExternalPurchaseRefunded(address indexed purchaser, uint256 amount, uint256 bonusAmount);\r\n  event TokenDistributed(address indexed tokenReceiver, uint256 tokenAmount);\r\n  event BonusTokenDistributed(address indexed tokenReceiver, uint256 tokenAmount);\r\n  event TopupTokenAllocated(address indexed tokenReceiver, uint256 amount, uint256 bonusAmount);\r\n  event CrowdsalePending();\r\n  event CrowdsaleStarted();\r\n  event CrowdsaleEnded();\r\n  event BonusRateChanged();\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n  //Set inital arguments of the crowdsale\r\n  function initialiseCrowdsale (uint256 _startTime, uint256 _rate, address _tokenAddress, address _wallet) onlyOwner external {\r\n    require(status == State.Deployed);\r\n    require(_startTime >= now);\r\n    require(_rate > 0);\r\n    require(address(_tokenAddress) != address(0));\r\n    require(_wallet != address(0));\r\n\r\n    startTime = _startTime;\r\n    endTime = _startTime + 30 days;\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    violaToken = VLTToken(_tokenAddress);\r\n\r\n    status = State.PendingStart;\r\n\r\n    CrowdsalePending();\r\n\r\n  }\r\n\r\n  /**\r\n   * Crowdsale state functions\r\n   * To track state of current crowdsale\r\n   */\r\n\r\n\r\n  // To be called by Ethereum alarm clock or anyone\r\n  //Can only be called successfully when time is valid\r\n  function startCrowdsale() external {\r\n    require(withinPeriod());\r\n    require(violaToken != address(0));\r\n    require(getTokensLeft() > 0);\r\n    require(status == State.PendingStart);\r\n\r\n    status = State.Active;\r\n\r\n    CrowdsaleStarted();\r\n  }\r\n\r\n  //To be called by owner or contract\r\n  //Ends the crowdsale when tokens are sold out\r\n  function endCrowdsale() public {\r\n    if (!tokensHasSoldOut()) {\r\n      require(msg.sender == owner);\r\n    }\r\n    require(status == State.Active);\r\n\r\n    bonusVestingPeriod = now + 60 days;\r\n\r\n    status = State.Ended;\r\n\r\n    CrowdsaleEnded();\r\n  }\r\n  //Emergency pause\r\n  function pauseCrowdsale() onlyOwner external {\r\n    require(status == State.Active);\r\n\r\n    status = State.Paused;\r\n  }\r\n  //Resume paused crowdsale\r\n  function unpauseCrowdsale() onlyOwner external {\r\n    require(status == State.Paused);\r\n\r\n    status = State.Active;\r\n  }\r\n\r\n  function completeCrowdsale() onlyOwner external {\r\n    require(hasEnded());\r\n    require(violaToken.allowance(owner, this) == 0);\r\n    status = State.Completed;\r\n\r\n    _forwardFunds();\r\n\r\n    assert(this.balance == 0);\r\n  }\r\n\r\n  function burnExtraTokens() onlyOwner external {\r\n    require(hasEnded());\r\n    uint256 extraTokensToBurn = violaToken.allowance(owner, this);\r\n    violaToken.burnFrom(owner, extraTokensToBurn);\r\n    assert(violaToken.allowance(owner, this) == 0);\r\n  }\r\n\r\n  // send ether to the fund collection wallet\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(this.balance);\r\n  }\r\n\r\n  function partialForwardFunds(uint _amountToTransfer) onlyOwner external {\r\n    require(status == State.Ended);\r\n    require(_amountToTransfer < totalApprovedAmount);\r\n    totalApprovedAmount = totalApprovedAmount.sub(_amountToTransfer);\r\n    \r\n    wallet.transfer(_amountToTransfer);\r\n  }\r\n\r\n  /**\r\n   * Setter functions for crowdsale parameters\r\n   * Only owner can set values\r\n   */\r\n\r\n\r\n  function setLeftoverTokensBuffer(uint256 _tokenBuffer) onlyOwner external {\r\n    require(_tokenBuffer > 0);\r\n    require(getTokensLeft() >= _tokenBuffer);\r\n    leftoverTokensBuffer = _tokenBuffer;\r\n  }\r\n\r\n  //Set the ether to token rate\r\n  function setRate(uint _rate) onlyOwner external {\r\n    require(_rate > 0);\r\n    rate = _rate;\r\n  }\r\n\r\n  function setBonusTokenRateLevelOne(uint _rate) onlyOwner external {\r\n    //require(_rate > 0);\r\n    bonusTokenRateLevelOne = _rate;\r\n    BonusRateChanged();\r\n  }\r\n\r\n  function setBonusTokenRateLevelTwo(uint _rate) onlyOwner external {\r\n    //require(_rate > 0);\r\n    bonusTokenRateLevelTwo = _rate;\r\n    BonusRateChanged();\r\n  }\r\n\r\n  function setBonusTokenRateLevelThree(uint _rate) onlyOwner external {\r\n    //require(_rate > 0);\r\n    bonusTokenRateLevelThree = _rate;\r\n    BonusRateChanged();\r\n  }\r\n  function setBonusTokenRateLevelFour(uint _rate) onlyOwner external {\r\n    //require(_rate > 0);\r\n    bonusTokenRateLevelFour = _rate;\r\n    BonusRateChanged();\r\n  }\r\n\r\n  function setMinWeiToPurchase(uint _minWeiToPurchase) onlyOwner external {\r\n    minWeiToPurchase = _minWeiToPurchase;\r\n  }\r\n\r\n\r\n  /**\r\n   * Whitelisting and KYC functions\r\n   * Whitelisted address can buy tokens, KYC successful purchaser can claim token. Refund if fail KYC\r\n   */\r\n\r\n\r\n  //Set the amount of wei an address can purchase up to\r\n  //@dev Value of 0 = not whitelisted\r\n  //@dev cap is in *18 decimals* ( 1 token = 1*10^18)\r\n  \r\n  function setWhitelistAddress( address _investor, uint _cap ) onlyOwner external {\r\n        require(_cap > 0);\r\n        require(_investor != address(0));\r\n        maxBuyCap[_investor] = _cap;\r\n        registeredAddress.push(_investor);\r\n        //add event\r\n    }\r\n\r\n  //Remove the address from whitelist\r\n  function removeWhitelistAddress(address _investor) onlyOwner external {\r\n    require(_investor != address(0));\r\n    \r\n    maxBuyCap[_investor] = 0;\r\n    uint256 weiAmount = investedSum[_investor];\r\n\r\n    if (weiAmount > 0) {\r\n      _refund(_investor);\r\n    }\r\n  }\r\n\r\n  //Flag address as KYC approved. Address is now approved to claim tokens\r\n  function approveKYC(address _kycAddress) onlyOwner external {\r\n    require(_kycAddress != address(0));\r\n    addressKYC[_kycAddress] = true;\r\n\r\n    uint256 weiAmount = investedSum[_kycAddress];\r\n    totalApprovedAmount = totalApprovedAmount.add(weiAmount);\r\n  }\r\n\r\n  //Set KYC status as failed. Refund any eth back to address\r\n  function revokeKYC(address _kycAddress) onlyOwner external {\r\n    require(_kycAddress != address(0));\r\n    addressKYC[_kycAddress] = false;\r\n\r\n    uint256 weiAmount = investedSum[_kycAddress];\r\n    totalApprovedAmount = totalApprovedAmount.sub(weiAmount);\r\n\r\n    if (weiAmount > 0) {\r\n      _refund(_kycAddress);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Getter functions for crowdsale parameters\r\n   * Does not use gas\r\n   */\r\n\r\n  //Checks if token has been sold out\r\n    function tokensHasSoldOut() view internal returns (bool) {\r\n      if (getTokensLeft() <= leftoverTokensBuffer) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n      // @return true if the transaction can buy tokens\r\n  function withinPeriod() public view returns (bool) {\r\n    return now >= startTime && now <= endTime;\r\n  }\r\n\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public view returns (bool) {\r\n    if (status == State.Ended) {\r\n      return true;\r\n    }\r\n    return now > endTime;\r\n  }\r\n\r\n  function getTokensLeft() public view returns (uint) {\r\n    return violaToken.allowance(owner, this).sub(totalTokensAllocated);\r\n  }\r\n\r\n  function transferTokens (address receiver, uint tokenAmount) internal {\r\n     require(violaToken.transferFrom(owner, receiver, tokenAmount));\r\n  }\r\n\r\n  function getTimeBasedBonusRate() public view returns(uint) {\r\n    bool bonusDuration1 = now >= startTime && now <= (startTime + 1 days);  //First 24hr\r\n    bool bonusDuration2 = now > (startTime + 1 days) && now <= (startTime + 3 days);//Next 48 hr\r\n    bool bonusDuration3 = now > (startTime + 3 days) && now <= (startTime + 10 days);//4th to 10th day\r\n    bool bonusDuration4 = now > (startTime + 10 days) && now <= endTime;//11th day onwards\r\n    if (bonusDuration1) {\r\n      return bonusTokenRateLevelOne;\r\n    } else if (bonusDuration2) {\r\n      return bonusTokenRateLevelTwo;\r\n    } else if (bonusDuration3) {\r\n      return bonusTokenRateLevelThree;\r\n    } else if (bonusDuration4) {\r\n      return bonusTokenRateLevelFour;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function getTotalTokensByAddress(address _investor) public view returns(uint) {\r\n    return getTotalNormalTokensByAddress(_investor).add(getTotalBonusTokensByAddress(_investor));\r\n  }\r\n\r\n  function getTotalNormalTokensByAddress(address _investor) public view returns(uint) {\r\n    return tokensAllocated[_investor].add(externalTokensAllocated[_investor]);\r\n  }\r\n\r\n  function getTotalBonusTokensByAddress(address _investor) public view returns(uint) {\r\n    return bonusTokensAllocated[_investor].add(externalBonusTokensAllocated[_investor]);\r\n  }\r\n\r\n  function _clearTotalNormalTokensByAddress(address _investor) internal {\r\n    tokensAllocated[_investor] = 0;\r\n    externalTokensAllocated[_investor] = 0;\r\n  }\r\n\r\n  function _clearTotalBonusTokensByAddress(address _investor) internal {\r\n    bonusTokensAllocated[_investor] = 0;\r\n    externalBonusTokensAllocated[_investor] = 0;\r\n  }\r\n\r\n\r\n  /**\r\n   * Functions to handle buy tokens\r\n   * Fallback function as entry point for eth\r\n   */\r\n\r\n\r\n  // Called when ether is sent to contract\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  //Used to buy tokens\r\n  function buyTokens(address investor) internal {\r\n    require(status == State.Active);\r\n    require(msg.value >= minWeiToPurchase);\r\n\r\n    uint weiAmount = msg.value;\r\n\r\n    checkCapAndRecord(investor,weiAmount);\r\n\r\n    allocateToken(investor,weiAmount);\r\n    \r\n  }\r\n\r\n  //Internal call to check max user cap\r\n  function checkCapAndRecord(address investor, uint weiAmount) internal {\r\n      uint remaindingCap = maxBuyCap[investor];\r\n      require(remaindingCap >= weiAmount);\r\n      maxBuyCap[investor] = remaindingCap.sub(weiAmount);\r\n      investedSum[investor] = investedSum[investor].add(weiAmount);\r\n  }\r\n\r\n  //Internal call to allocated tokens purchased\r\n    function allocateToken(address investor, uint weiAmount) internal {\r\n        // calculate token amount to be created\r\n        uint tokens = weiAmount.mul(rate);\r\n        uint bonusTokens = tokens.mul(getTimeBasedBonusRate()).div(100);\r\n        \r\n        uint tokensToAllocate = tokens.add(bonusTokens);\r\n        \r\n        require(getTokensLeft() >= tokensToAllocate);\r\n        totalTokensAllocated = totalTokensAllocated.add(tokensToAllocate);\r\n\r\n        tokensAllocated[investor] = tokensAllocated[investor].add(tokens);\r\n        bonusTokensAllocated[investor] = bonusTokensAllocated[investor].add(bonusTokens);\r\n\r\n        if (tokensHasSoldOut()) {\r\n          endCrowdsale();\r\n        }\r\n        TokenPurchase(investor, weiAmount, tokens, bonusTokens);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Functions for refunds & claim tokens\r\n   * \r\n   */\r\n\r\n\r\n\r\n  //Refund users in case of unsuccessful crowdsale\r\n  function _refund(address _investor) internal {\r\n    uint256 investedAmt = investedSum[_investor];\r\n    require(investedAmt > 0);\r\n\r\n  \r\n      uint totalInvestorTokens = tokensAllocated[_investor].add(bonusTokensAllocated[_investor]);\r\n\r\n    if (status == State.Active) {\r\n      //Refunded tokens go back to sale pool\r\n      totalTokensAllocated = totalTokensAllocated.sub(totalInvestorTokens);\r\n    }\r\n\r\n    _clearAddressFromCrowdsale(_investor);\r\n\r\n    _investor.transfer(investedAmt);\r\n\r\n    Refunded(_investor, investedAmt);\r\n  }\r\n\r\n    //Partial refund users\r\n  function refundPartial(address _investor, uint _refundAmt, uint _tokenAmt, uint _bonusTokenAmt) onlyOwner external {\r\n\r\n    uint investedAmt = investedSum[_investor];\r\n    require(investedAmt > _refundAmt);\r\n    require(tokensAllocated[_investor] > _tokenAmt);\r\n    require(bonusTokensAllocated[_investor] > _bonusTokenAmt);\r\n\r\n    investedSum[_investor] = investedSum[_investor].sub(_refundAmt);\r\n    tokensAllocated[_investor] = tokensAllocated[_investor].sub(_tokenAmt);\r\n    bonusTokensAllocated[_investor] = bonusTokensAllocated[_investor].sub(_bonusTokenAmt);\r\n\r\n\r\n    uint totalRefundTokens = _tokenAmt.add(_bonusTokenAmt);\r\n\r\n    if (status == State.Active) {\r\n      //Refunded tokens go back to sale pool\r\n      totalTokensAllocated = totalTokensAllocated.sub(totalRefundTokens);\r\n    }\r\n\r\n    _investor.transfer(_refundAmt);\r\n\r\n    Refunded(_investor, _refundAmt);\r\n  }\r\n\r\n  //Used by investor to claim token\r\n    function claimTokens() external {\r\n      require(hasEnded());\r\n      require(addressKYC[msg.sender]);\r\n      address tokenReceiver = msg.sender;\r\n      uint tokensToClaim = getTotalNormalTokensByAddress(tokenReceiver);\r\n\r\n      require(tokensToClaim > 0);\r\n      _clearTotalNormalTokensByAddress(tokenReceiver);\r\n\r\n      violaToken.transferFrom(owner, tokenReceiver, tokensToClaim);\r\n\r\n      TokenDistributed(tokenReceiver, tokensToClaim);\r\n\r\n    }\r\n\r\n    //Used by investor to claim bonus token\r\n    function claimBonusTokens() external {\r\n      require(hasEnded());\r\n      require(now >= bonusVestingPeriod);\r\n      require(addressKYC[msg.sender]);\r\n\r\n      address tokenReceiver = msg.sender;\r\n      uint tokensToClaim = getTotalBonusTokensByAddress(tokenReceiver);\r\n\r\n      require(tokensToClaim > 0);\r\n      _clearTotalBonusTokensByAddress(tokenReceiver);\r\n\r\n      violaToken.transferFrom(owner, tokenReceiver, tokensToClaim);\r\n\r\n      BonusTokenDistributed(tokenReceiver, tokensToClaim);\r\n    }\r\n\r\n    //Used by owner to distribute bonus token\r\n    function distributeBonusTokens(address _tokenReceiver) onlyOwner external {\r\n      require(hasEnded());\r\n      require(now >= bonusVestingPeriod);\r\n\r\n      address tokenReceiver = _tokenReceiver;\r\n      uint tokensToClaim = getTotalBonusTokensByAddress(tokenReceiver);\r\n\r\n      require(tokensToClaim > 0);\r\n      _clearTotalBonusTokensByAddress(tokenReceiver);\r\n\r\n      transferTokens(tokenReceiver, tokensToClaim);\r\n\r\n      BonusTokenDistributed(tokenReceiver,tokensToClaim);\r\n\r\n    }\r\n\r\n    //Used by owner to distribute token\r\n    function distributeICOTokens(address _tokenReceiver) onlyOwner external {\r\n      require(hasEnded());\r\n\r\n      address tokenReceiver = _tokenReceiver;\r\n      uint tokensToClaim = getTotalNormalTokensByAddress(tokenReceiver);\r\n\r\n      require(tokensToClaim > 0);\r\n      _clearTotalNormalTokensByAddress(tokenReceiver);\r\n\r\n      transferTokens(tokenReceiver, tokensToClaim);\r\n\r\n      TokenDistributed(tokenReceiver,tokensToClaim);\r\n\r\n    }\r\n\r\n    //For owner to reserve token for presale\r\n    // function reserveTokens(uint _amount) onlyOwner external {\r\n\r\n    //   require(getTokensLeft() >= _amount);\r\n    //   totalTokensAllocated = totalTokensAllocated.add(_amount);\r\n    //   totalReservedTokenAllocated = totalReservedTokenAllocated.add(_amount);\r\n\r\n    // }\r\n\r\n    // //To distribute tokens not allocated by crowdsale contract\r\n    // function distributePresaleTokens(address _tokenReceiver, uint _amount) onlyOwner external {\r\n    //   require(hasEnded());\r\n    //   require(_tokenReceiver != address(0));\r\n    //   require(_amount > 0);\r\n\r\n    //   violaToken.transferFrom(owner, _tokenReceiver, _amount);\r\n\r\n    //   TokenDistributed(_tokenReceiver,_amount);\r\n\r\n    // }\r\n\r\n    //For external purchases & pre-sale via btc/fiat\r\n    function externalPurchaseTokens(address _investor, uint _amount, uint _bonusAmount) onlyOwner external {\r\n      require(_amount > 0);\r\n      uint256 totalTokensToAllocate = _amount.add(_bonusAmount);\r\n\r\n      require(getTokensLeft() >= totalTokensToAllocate);\r\n      totalTokensAllocated = totalTokensAllocated.add(totalTokensToAllocate);\r\n      totalReservedTokenAllocated = totalReservedTokenAllocated.add(totalTokensToAllocate);\r\n\r\n      externalTokensAllocated[_investor] = externalTokensAllocated[_investor].add(_amount);\r\n      externalBonusTokensAllocated[_investor] = externalBonusTokensAllocated[_investor].add(_bonusAmount);\r\n      \r\n      ExternalTokenPurchase(_investor,  _amount, _bonusAmount);\r\n\r\n    }\r\n\r\n    function refundAllExternalPurchase(address _investor) onlyOwner external {\r\n      require(_investor != address(0));\r\n      require(externalTokensAllocated[_investor] > 0);\r\n\r\n      uint externalTokens = externalTokensAllocated[_investor];\r\n      uint externalBonusTokens = externalBonusTokensAllocated[_investor];\r\n\r\n      externalTokensAllocated[_investor] = 0;\r\n      externalBonusTokensAllocated[_investor] = 0;\r\n\r\n      uint totalInvestorTokens = externalTokens.add(externalBonusTokens);\r\n\r\n      totalReservedTokenAllocated = totalReservedTokenAllocated.sub(totalInvestorTokens);\r\n      totalTokensAllocated = totalTokensAllocated.sub(totalInvestorTokens);\r\n\r\n      ExternalPurchaseRefunded(_investor,externalTokens,externalBonusTokens);\r\n    }\r\n\r\n    function refundExternalPurchase(address _investor, uint _amountToRefund, uint _bonusAmountToRefund) onlyOwner external {\r\n      require(_investor != address(0));\r\n      require(externalTokensAllocated[_investor] >= _amountToRefund);\r\n      require(externalBonusTokensAllocated[_investor] >= _bonusAmountToRefund);\r\n\r\n      uint totalTokensToRefund = _amountToRefund.add(_bonusAmountToRefund);\r\n      externalTokensAllocated[_investor] = externalTokensAllocated[_investor].sub(_amountToRefund);\r\n      externalBonusTokensAllocated[_investor] = externalBonusTokensAllocated[_investor].sub(_bonusAmountToRefund);\r\n\r\n      totalReservedTokenAllocated = totalReservedTokenAllocated.sub(totalTokensToRefund);\r\n      totalTokensAllocated = totalTokensAllocated.sub(totalTokensToRefund);\r\n\r\n      ExternalPurchaseRefunded(_investor,_amountToRefund,_bonusAmountToRefund);\r\n    }\r\n\r\n    function _clearAddressFromCrowdsale(address _investor) internal {\r\n      tokensAllocated[_investor] = 0;\r\n      bonusTokensAllocated[_investor] = 0;\r\n      investedSum[_investor] = 0;\r\n      maxBuyCap[_investor] = 0;\r\n    }\r\n\r\n    function allocateTopupToken(address _investor, uint _amount, uint _bonusAmount) onlyOwner external {\r\n      require(hasEnded());\r\n      require(_amount > 0);\r\n      uint256 tokensToAllocate = _amount.add(_bonusAmount);\r\n\r\n      require(getTokensLeft() >= tokensToAllocate);\r\n      totalTokensAllocated = totalTokensAllocated.add(_amount);\r\n\r\n      tokensAllocated[_investor] = tokensAllocated[_investor].add(_amount);\r\n      bonusTokensAllocated[_investor] = bonusTokensAllocated[_investor].add(_bonusAmount);\r\n\r\n      TopupTokenAllocated(_investor,  _amount, _bonusAmount);\r\n    }\r\n\r\n  //For cases where token are mistakenly sent / airdrops\r\n  function emergencyERC20Drain( ERC20 token, uint amount ) external onlyOwner {\r\n    require(status == State.Completed);\r\n    token.transfer(owner,amount);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"withinPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusTokenRateLevelThree\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusTokenRateLevelTwo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kycAddress\",\"type\":\"address\"}],\"name\":\"approveKYC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressKYC\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountToTransfer\",\"type\":\"uint256\"}],\"name\":\"partialForwardFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setBonusTokenRateLevelOne\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_bonusAmount\",\"type\":\"uint256\"}],\"name\":\"externalPurchaseTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"externalTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kycAddress\",\"type\":\"address\"}],\"name\":\"revokeKYC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getTotalNormalTokensByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"completeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_amountToRefund\",\"type\":\"uint256\"},{\"name\":\"_bonusAmountToRefund\",\"type\":\"uint256\"}],\"name\":\"refundExternalPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_bonusAmount\",\"type\":\"uint256\"}],\"name\":\"allocateTopupToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minWeiToPurchase\",\"type\":\"uint256\"}],\"name\":\"setMinWeiToPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeBasedBonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minWeiToPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenReceiver\",\"type\":\"address\"}],\"name\":\"distributeBonusTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnExtraTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getTotalBonusTokensByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"violaToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenBuffer\",\"type\":\"uint256\"}],\"name\":\"setLeftoverTokensBuffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusTokenRateLevelFour\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setBonusTokenRateLevelFour\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenReceiver\",\"type\":\"address\"}],\"name\":\"distributeICOTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leftoverTokensBuffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setBonusTokenRateLevelThree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"refundAllExternalPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxBuyCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalApprovedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReservedTokenAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"removeWhitelistAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusTokenRateLevelOne\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_refundAmt\",\"type\":\"uint256\"},{\"name\":\"_tokenAmt\",\"type\":\"uint256\"},{\"name\":\"_bonusTokenAmt\",\"type\":\"uint256\"}],\"name\":\"refundPartial\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"initialiseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyERC20Drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"externalBonusTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimBonusTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusVestingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getTotalTokensByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setBonusTokenRateLevelTwo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setWhitelistAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"ExternalTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"ExternalPurchaseRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenReceiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokenDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenReceiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"BonusTokenDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenReceiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"TopupTokenAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CrowdsalePending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BonusRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ViolaCrowdsale","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5db8e40549bfc3fcbc97e2befcb3a7476092927487958256753b0b91951246e9"}]}