{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/HasNoEther.sol\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this ether.\r\n * @notice Ether can still be send to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n*/\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  function HasNoEther() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    assert(owner.send(this.balance));\r\n  }\r\n}\r\n\r\n// File: contracts/AxiePresale.sol\r\n\r\ncontract AxiePresale is HasNoEther, Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  uint8 constant public CLASS_BEAST = 0;\r\n  uint8 constant public CLASS_AQUATIC = 2;\r\n  uint8 constant public CLASS_PLANT = 4;\r\n\r\n  uint256 constant public INITIAL_PRICE_INCREMENT = 1600 szabo; // 0.0016 Ether\r\n  uint256 constant public INITIAL_PRICE = INITIAL_PRICE_INCREMENT;\r\n  uint256 constant public REF_CREDITS_PER_AXIE = 5;\r\n\r\n  mapping (uint8 => uint256) public currentPrices;\r\n  mapping (uint8 => uint256) public priceIncrements;\r\n\r\n  mapping (uint8 => uint256) public totalAxiesAdopted;\r\n  mapping (address => mapping (uint8 => uint256)) public axiesAdopted;\r\n\r\n  mapping (address => uint256) public referralCredits;\r\n  mapping (address => uint256) public axiesRewarded;\r\n  uint256 public totalAxiesRewarded;\r\n\r\n  event AxiesAdopted(\r\n    address indexed adopter,\r\n    uint8 indexed clazz,\r\n    uint256 quantity,\r\n    address indexed referrer\r\n  );\r\n\r\n  event AxiesRewarded(address indexed receiver, uint256 quantity);\r\n\r\n  event AdoptedAxiesRedeemed(address indexed receiver, uint8 indexed clazz, uint256 quantity);\r\n  event RewardedAxiesRedeemed(address indexed receiver, uint256 quantity);\r\n\r\n  function AxiePresale() public {\r\n    priceIncrements[CLASS_BEAST] = priceIncrements[CLASS_AQUATIC] = //\r\n      priceIncrements[CLASS_PLANT] = INITIAL_PRICE_INCREMENT;\r\n\r\n    currentPrices[CLASS_BEAST] = currentPrices[CLASS_AQUATIC] = //\r\n      currentPrices[CLASS_PLANT] = INITIAL_PRICE;\r\n  }\r\n\r\n  function axiesPrice(\r\n    uint256 beastQuantity,\r\n    uint256 aquaticQuantity,\r\n    uint256 plantQuantity\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 totalPrice)\r\n  {\r\n    uint256 price;\r\n\r\n    (price,,) = _axiesPrice(CLASS_BEAST, beastQuantity);\r\n    totalPrice = totalPrice.add(price);\r\n\r\n    (price,,) = _axiesPrice(CLASS_AQUATIC, aquaticQuantity);\r\n    totalPrice = totalPrice.add(price);\r\n\r\n    (price,,) = _axiesPrice(CLASS_PLANT, plantQuantity);\r\n    totalPrice = totalPrice.add(price);\r\n  }\r\n\r\n  function adoptAxies(\r\n    uint256 beastQuantity,\r\n    uint256 aquaticQuantity,\r\n    uint256 plantQuantity,\r\n    address referrer\r\n  )\r\n    public\r\n    payable\r\n    whenNotPaused\r\n  {\r\n    require(beastQuantity <= 3);\r\n    require(aquaticQuantity <= 3);\r\n    require(plantQuantity <= 3);\r\n\r\n    address adopter = msg.sender;\r\n    address actualReferrer = 0x0;\r\n\r\n    // An adopter cannot be his/her own referrer.\r\n    if (referrer != adopter) {\r\n      actualReferrer = referrer;\r\n    }\r\n\r\n    uint256 value = msg.value;\r\n    uint256 price;\r\n\r\n    if (beastQuantity > 0) {\r\n      price = _adoptAxies(\r\n        adopter,\r\n        CLASS_BEAST,\r\n        beastQuantity,\r\n        actualReferrer\r\n      );\r\n\r\n      require(value >= price);\r\n      value -= price;\r\n    }\r\n\r\n    if (aquaticQuantity > 0) {\r\n      price = _adoptAxies(\r\n        adopter,\r\n        CLASS_AQUATIC,\r\n        aquaticQuantity,\r\n        actualReferrer\r\n      );\r\n\r\n      require(value >= price);\r\n      value -= price;\r\n    }\r\n\r\n    if (plantQuantity > 0) {\r\n      price = _adoptAxies(\r\n        adopter,\r\n        CLASS_PLANT,\r\n        plantQuantity,\r\n        actualReferrer\r\n      );\r\n\r\n      require(value >= price);\r\n      value -= price;\r\n    }\r\n\r\n    msg.sender.transfer(value);\r\n\r\n    // The current referral is ignored if the referrer's address is 0x0.\r\n    if (actualReferrer != 0x0) {\r\n      uint256 numCredit = referralCredits[actualReferrer]\r\n        .add(beastQuantity)\r\n        .add(aquaticQuantity)\r\n        .add(plantQuantity);\r\n\r\n      uint256 numReward = numCredit / REF_CREDITS_PER_AXIE;\r\n\r\n      if (numReward > 0) {\r\n        referralCredits[actualReferrer] = numCredit % REF_CREDITS_PER_AXIE;\r\n        axiesRewarded[actualReferrer] = axiesRewarded[actualReferrer].add(numReward);\r\n        totalAxiesRewarded = totalAxiesRewarded.add(numReward);\r\n        AxiesRewarded(actualReferrer, numReward);\r\n      } else {\r\n        referralCredits[actualReferrer] = numCredit;\r\n      }\r\n    }\r\n  }\r\n\r\n  function redeemAdoptedAxies(\r\n    address receiver,\r\n    uint256 beastQuantity,\r\n    uint256 aquaticQuantity,\r\n    uint256 plantQuantity\r\n  )\r\n    public\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (\r\n      uint256 /* remainingBeastQuantity */,\r\n      uint256 /* remainingAquaticQuantity */,\r\n      uint256 /* remainingPlantQuantity */\r\n    )\r\n  {\r\n    return (\r\n      _redeemAdoptedAxies(receiver, CLASS_BEAST, beastQuantity),\r\n      _redeemAdoptedAxies(receiver, CLASS_AQUATIC, aquaticQuantity),\r\n      _redeemAdoptedAxies(receiver, CLASS_PLANT, plantQuantity)\r\n    );\r\n  }\r\n\r\n  function redeemRewardedAxies(\r\n    address receiver,\r\n    uint256 quantity\r\n  )\r\n    public\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (uint256 remainingQuantity)\r\n  {\r\n    remainingQuantity = axiesRewarded[receiver] = axiesRewarded[receiver].sub(quantity);\r\n\r\n    if (quantity > 0) {\r\n      // This requires that rewarded Axies are always included in the total\r\n      // to make sure overflow won't happen.\r\n      totalAxiesRewarded -= quantity;\r\n\r\n      RewardedAxiesRedeemed(receiver, quantity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate price of Axies from the same class.\r\n   * @param clazz The class of Axies.\r\n   * @param quantity Number of Axies to be calculated.\r\n   */\r\n  function _axiesPrice(\r\n    uint8 clazz,\r\n    uint256 quantity\r\n  )\r\n    private\r\n    view\r\n    returns (uint256 totalPrice, uint256 priceIncrement, uint256 currentPrice)\r\n  {\r\n    priceIncrement = priceIncrements[clazz];\r\n    currentPrice = currentPrices[clazz];\r\n\r\n    uint256 nextPrice;\r\n\r\n    for (uint256 i = 0; i < quantity; i++) {\r\n      totalPrice = totalPrice.add(currentPrice);\r\n      nextPrice = currentPrice.add(priceIncrement);\r\n\r\n      if (nextPrice / 100 finney != currentPrice / 100 finney) {\r\n        priceIncrement >>= 1;\r\n      }\r\n\r\n      currentPrice = nextPrice;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Adopt some Axies from the same class.\r\n   * @param adopter Address of the adopter.\r\n   * @param clazz The class of adopted Axies.\r\n   * @param quantity Number of Axies to be adopted, this should be positive.\r\n   * @param referrer Address of the referrer.\r\n   */\r\n  function _adoptAxies(\r\n    address adopter,\r\n    uint8 clazz,\r\n    uint256 quantity,\r\n    address referrer\r\n  )\r\n    private\r\n    returns (uint256 totalPrice)\r\n  {\r\n    (totalPrice, priceIncrements[clazz], currentPrices[clazz]) = _axiesPrice(clazz, quantity);\r\n\r\n    axiesAdopted[adopter][clazz] = axiesAdopted[adopter][clazz].add(quantity);\r\n    totalAxiesAdopted[clazz] = totalAxiesAdopted[clazz].add(quantity);\r\n\r\n    AxiesAdopted(\r\n      adopter,\r\n      clazz,\r\n      quantity,\r\n      referrer\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Redeem adopted Axies from the same class.\r\n   * @param receiver Address of the receiver.\r\n   * @param clazz The class of adopted Axies.\r\n   * @param quantity Number of adopted Axies to be redeemed.\r\n   */\r\n  function _redeemAdoptedAxies(\r\n    address receiver,\r\n    uint8 clazz,\r\n    uint256 quantity\r\n  )\r\n    private\r\n    returns (uint256 remainingQuantity)\r\n  {\r\n    remainingQuantity = axiesAdopted[receiver][clazz] = axiesAdopted[receiver][clazz].sub(quantity);\r\n\r\n    if (quantity > 0) {\r\n      // This requires that adopted Axies are always included in the total\r\n      // to make sure overflow won't happen.\r\n      totalAxiesAdopted[clazz] -= quantity;\r\n\r\n      AdoptedAxiesRedeemed(receiver, clazz, quantity);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"totalAxiesAdopted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beastQuantity\",\"type\":\"uint256\"},{\"name\":\"aquaticQuantity\",\"type\":\"uint256\"},{\"name\":\"plantQuantity\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"adoptAxies\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"axiesAdopted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_PRICE_INCREMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLASS_BEAST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCredits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLASS_PLANT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"beastQuantity\",\"type\":\"uint256\"},{\"name\":\"aquaticQuantity\",\"type\":\"uint256\"},{\"name\":\"plantQuantity\",\"type\":\"uint256\"}],\"name\":\"axiesPrice\",\"outputs\":[{\"name\":\"totalPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"currentPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REF_CREDITS_PER_AXIE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"beastQuantity\",\"type\":\"uint256\"},{\"name\":\"aquaticQuantity\",\"type\":\"uint256\"},{\"name\":\"plantQuantity\",\"type\":\"uint256\"}],\"name\":\"redeemAdoptedAxies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLASS_AQUATIC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"priceIncrements\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"redeemRewardedAxies\",\"outputs\":[{\"name\":\"remainingQuantity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"axiesRewarded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAxiesRewarded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"adopter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"clazz\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"AxiesAdopted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"AxiesRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"clazz\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"AdoptedAxiesRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"RewardedAxiesRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AxiePresale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c0d7266374f67f791833e14d48e76b281e357dea4079c56c195fbbe385b34346"}]}