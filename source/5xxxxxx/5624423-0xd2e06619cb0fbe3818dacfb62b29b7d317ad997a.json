{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/**\r\n * Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n\r\n\tfunction safeMul(uint256 a, uint256 b) public pure returns (uint256) {\r\n\t\tuint256 c = a * b;\r\n\t\tassert(a == 0 || c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction safeDiv(uint256 a, uint256 b) public pure returns (uint256) {\r\n\t\t//assert(a > 0);// Solidity automatically throws when dividing by 0\r\n\t\t//assert(b > 0);// Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn  a / b;\r\n\t}\r\n\r\n\tfunction safeSub(uint256 a, uint256 b) public pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction safeAdd(uint256 a, uint256 b) public pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c>=a && c>=b);\r\n\t\treturn c;\r\n\t}\r\n\r\n}\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n\r\n\tfunction totalSupply() public constant returns (uint256);\r\n\tfunction balanceOf(address _owner) public constant returns (uint256);\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256);\r\n\r\n\t/* ERC20 Events */\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ContractReceiver {\r\n\tfunction tokenFallback(address _from, uint256 _value, bytes _data) public;\r\n}\r\n\r\ncontract ERC223 is ERC20 {\r\n\r\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\r\n\tfunction transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success);\r\n\r\n\t/* ERC223 Events */\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\r\n}\r\n\r\ncontract BankeraToken is ERC223, SafeMath {\r\n\r\n\tstring public constant name = \"Banker Token\";     // Set the name for display purposes\r\n\tstring public constant symbol = \"BNK\";      // Set the symbol for display purposes\r\n\tuint8 public constant decimals = 8;         // Amount of decimals for display purposes\r\n\tuint256 private issued = 0;   \t\t\t\t// tokens count issued to addresses\r\n\tuint256 private totalTokens = 25000000000 * 100000000; //25,000,000,000.0000 0000 BNK\r\n\r\n\taddress private contractOwner;\r\n\taddress private rewardManager;\r\n\taddress private roundManager;\r\n\taddress private issueManager;\r\n\tuint64 public currentRound = 0;\r\n\r\n\tbool public paused = false;\r\n\r\n\tmapping (uint64 => Reward) public reward;\t//key - round, value - reward in round\r\n\tmapping (address => AddressBalanceInfoStructure) public accountBalances;\t//key - address, value - address balance info\r\n\tmapping (uint64 => uint256) public issuedTokensInRound;\t//key - round, value - issued tokens\r\n\tmapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\tuint256 public blocksPerRound; // blocks per round\r\n\tuint256 public lastBlockNumberInRound;\r\n\r\n\tstruct Reward {\r\n\t\tuint64 roundNumber;\r\n\t\tuint256 rewardInWei;\r\n\t\tuint256 rewardRate; //reward rate in wei. 1 sBNK - xxx wei\r\n\t\tbool isConfigured;\r\n\t}\r\n\r\n\tstruct AddressBalanceInfoStructure {\r\n\t\tuint256 addressBalance;\r\n\t\tmapping (uint256 => uint256) roundBalanceMap; //key - round number, value - total token amount in round\r\n\t\tmapping (uint64 => bool) wasModifiedInRoundMap; //key - round number, value - is modified in round\r\n\t\tuint64[] mapKeys;\t//round balance map keys\r\n\t\tuint64 claimedRewardTillRound;\r\n\t\tuint256 totalClaimedReward;\r\n\t}\r\n\r\n\t/* Initializes contract with initial blocks per round number*/\r\n\tfunction BankeraToken(uint256 _blocksPerRound, uint64 _round) public {\r\n\t\tcontractOwner = msg.sender;\r\n\t\tlastBlockNumberInRound = block.number;\r\n\r\n\t\tblocksPerRound = _blocksPerRound;\r\n\t\tcurrentRound = _round;\r\n\t}\r\n\r\n\tfunction() public whenNotPaused payable {\r\n\t}\r\n\r\n\t// Public functions\r\n\t/**\r\n\t * @dev Reject all ERC223 compatible tokens\r\n\t * @param _from address The address that is transferring the tokens\r\n\t * @param _value uint256 the amount of the specified token\r\n\t * @param _data Bytes The data passed from the caller.\r\n\t */\r\n\tfunction tokenFallback(address _from, uint256 _value, bytes _data) public whenNotPaused view {\r\n\t\trevert();\r\n\t}\r\n\r\n\tfunction setReward(uint64 _roundNumber, uint256 _roundRewardInWei) public whenNotPaused onlyRewardManager {\r\n\t\tisNewRound();\r\n\r\n\t\tReward storage rewardInfo = reward[_roundNumber];\r\n\r\n\t\t//validations\r\n\t\tassert(rewardInfo.roundNumber == _roundNumber);\r\n\t\tassert(!rewardInfo.isConfigured); //allow just not configured reward configuration\r\n\r\n\t\trewardInfo.rewardInWei = _roundRewardInWei;\r\n\t\tif(_roundRewardInWei > 0){\r\n\t\t\trewardInfo.rewardRate = safeDiv(_roundRewardInWei, issuedTokensInRound[_roundNumber]);\r\n\t\t}\r\n\t\trewardInfo.isConfigured = true;\r\n\t}\r\n\r\n\t/* Change contract owner */\r\n\tfunction changeContractOwner(address _newContractOwner) public onlyContractOwner {\r\n\t\tisNewRound();\r\n\t\tif (_newContractOwner != contractOwner) {\r\n\t\t\tcontractOwner = _newContractOwner;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\t/* Change reward contract owner */\r\n\tfunction changeRewardManager(address _newRewardManager) public onlyContractOwner {\r\n\t\tisNewRound();\r\n\t\tif (_newRewardManager != rewardManager) {\r\n\t\t\trewardManager = _newRewardManager;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\t/* Change round contract owner */\r\n\tfunction changeRoundManager(address _newRoundManager) public onlyContractOwner {\r\n\t\tisNewRound();\r\n\t\tif (_newRoundManager != roundManager) {\r\n\t\t\troundManager = _newRoundManager;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\t/* Change issue contract owner */\r\n\tfunction changeIssueManager(address _newIssueManager) public onlyContractOwner {\r\n\t\tisNewRound();\r\n\t\tif (_newIssueManager != issueManager) {\r\n\t\t\tissueManager = _newIssueManager;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setBlocksPerRound(uint64 _newBlocksPerRound) public whenNotPaused onlyRoundManager {\r\n\t\tblocksPerRound = _newBlocksPerRound;\r\n\t}\r\n\t/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n\tfunction pause() onlyContractOwner whenNotPaused public {\r\n\t\tpaused = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev called by the owner to resume, returns to normal state\r\n\t */\r\n\tfunction resume() onlyContractOwner whenPaused public {\r\n\t\tpaused = false;\r\n\t}\r\n\t/**\r\n\t *\r\n\t * permission checker\r\n\t */\r\n\tmodifier onlyContractOwner() {\r\n\t\tif(msg.sender != contractOwner){\r\n\t\t\trevert();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\t/**\r\n\t* set reward for round (reward admin)\r\n\t*/\r\n\tmodifier onlyRewardManager() {\r\n\t\tif(msg.sender != rewardManager && msg.sender != contractOwner){\r\n\t\t\trevert();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\t/**\r\n\t* adjust round length (round admin)\r\n\t*/\r\n\tmodifier onlyRoundManager() {\r\n\t\tif(msg.sender != roundManager && msg.sender != contractOwner){\r\n\t\t\trevert();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\t/**\r\n\t* issue tokens to ETH addresses (issue admin)\r\n\t*/\r\n\tmodifier onlyIssueManager() {\r\n\t\tif(msg.sender != issueManager && msg.sender != contractOwner){\r\n\t\t\trevert();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notSelf(address _to) {\r\n\t\tif(msg.sender == _to){\r\n\t\t\trevert();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\t/**\r\n   \t* @dev Modifier to make a function callable only when the contract is not paused.\r\n   \t*/\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!paused);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is paused.\r\n\t */\r\n\tmodifier whenPaused() {\r\n\t\trequire(paused);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction getRoundBalance(address _address, uint256 _round) public view returns (uint256) {\r\n\t\treturn accountBalances[_address].roundBalanceMap[_round];\r\n\t}\r\n\r\n\tfunction isModifiedInRound(address _address, uint64 _round) public view returns (bool) {\r\n\t\treturn accountBalances[_address].wasModifiedInRoundMap[_round];\r\n\t}\r\n\r\n\tfunction getBalanceModificationRounds(address _address) public view returns (uint64[]) {\r\n\t\treturn accountBalances[_address].mapKeys;\r\n\t}\r\n\r\n\t//action for issue tokens\r\n\tfunction issueTokens(address _receiver, uint256 _tokenAmount) public whenNotPaused onlyIssueManager {\r\n\t\tisNewRound();\r\n\t\tissue(_receiver, _tokenAmount);\r\n\t}\r\n\r\n\tfunction withdrawEther() public onlyContractOwner {\r\n\t\tisNewRound();\r\n\t\tif(this.balance > 0) {\r\n\t\t\tcontractOwner.transfer(this.balance);\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\t/* Send coins from owner to other address */\r\n\t/*Override*/\r\n\tfunction transfer(address _to, uint256 _value) public notSelf(_to) whenNotPaused returns (bool success){\r\n\t\trequire(_to != address(0));\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\t\tif(isContract(_to)) {\r\n\t\t\treturn transferToContract(msg.sender, _to, _value, empty);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn transferToAddress(msg.sender, _to, _value, empty);\r\n\t\t}\r\n\t}\r\n\r\n\t/*Override*/\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn accountBalances[_owner].addressBalance;\r\n\t}\r\n\r\n\t/*Override*/\r\n\tfunction totalSupply() public constant returns (uint256){\r\n\t\treturn totalTokens;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer tokens from one address to another\r\n\t * @param _from address The address which you want to send tokens from\r\n\t * @param _to address The address which you want to transfer to\r\n\t * @param _value uint256 the amount of tokens to be transferred\r\n\t */\r\n\t/*Override*/\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= allowed[_from][msg.sender]);\r\n\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\t\tif(isContract(_to)) {\r\n\t\t\trequire(transferToContract(_from, _to, _value, empty));\r\n\t\t}\r\n\t\telse {\r\n\t\t\trequire(transferToAddress(_from, _to, _value, empty));\r\n\t\t}\r\n\t\tallowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\t *\r\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _value The amount of tokens to be spent.\r\n\t */\r\n\t/*Override*/\r\n\tfunction approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t  * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t  * @param _owner address The address which owns the funds.\r\n\t  * @param _spender address The address which will spend the funds.\r\n\t  * @return A uint256 specifying the amount of tokens still available for the spender.\r\n\t  */\r\n\t/*Override*/\r\n\tfunction allowance(address _owner, address _spender) public view whenNotPaused returns (uint256) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To increment\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _addedValue The amount of tokens to increase the allowance by.\r\n\t */\r\n\r\n\tfunction increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\r\n\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To decrement\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n\t */\r\n\tfunction decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\r\n\t\t}\r\n\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Function that is called when a user or another contract wants to transfer funds .\r\n\t/*Override*/\r\n\tfunction transfer(address _to, uint256 _value, bytes _data) public whenNotPaused notSelf(_to) returns (bool success){\r\n\t\trequire(_to != address(0));\r\n\t\tif(isContract(_to)) {\r\n\t\t\treturn transferToContract(msg.sender, _to, _value, _data);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn transferToAddress(msg.sender, _to, _value, _data);\r\n\t\t}\r\n\t}\r\n\r\n\t// Function that is called when a user or another contract wants to transfer funds.\r\n\t/*Override*/\r\n\tfunction transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){\r\n\t\trequire(_to != address(0));\r\n\t\tif(isContract(_to)) {\r\n\t\t\tif(accountBalances[msg.sender].addressBalance < _value){\t\t// Check if the sender has enough\r\n\t\t\t\trevert();\r\n\t\t\t}\r\n\t\t\tif(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){\t\t// Check for overflows\r\n\t\t\t\trevert();\r\n\t\t\t}\r\n\r\n\t\t\tisNewRound();\r\n\t\t\tsubFromAddressBalancesInfo(msg.sender, _value);\t// Subtract from the sender\r\n\t\t\taddToAddressBalancesInfo(_to, _value);\t// Add the same to the recipient\r\n\r\n\t\t\tassert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\r\n\r\n\t\t\t/* Notify anyone listening that this transfer took place */\r\n\t\t\tTransfer(msg.sender, _to, _value, _data);\r\n\t\t\tTransfer(msg.sender, _to, _value);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn transferToAddress(msg.sender, _to, _value, _data);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction claimReward() public whenNotPaused returns (uint256 rewardAmountInWei) {\r\n\t\tisNewRound();\r\n\t\treturn claimRewardTillRound(currentRound);\r\n\t}\r\n\r\n\tfunction claimRewardTillRound(uint64 _claimTillRound) public whenNotPaused returns (uint256 rewardAmountInWei) {\r\n\t\tisNewRound();\r\n\t\trewardAmountInWei = calculateClaimableRewardTillRound(msg.sender, _claimTillRound);\r\n\t\taccountBalances[msg.sender].claimedRewardTillRound = _claimTillRound;\r\n\r\n\t\tif (rewardAmountInWei > 0){\r\n\t\t\taccountBalances[msg.sender].totalClaimedReward = safeAdd(accountBalances[msg.sender].totalClaimedReward, rewardAmountInWei);\r\n\t\t\tmsg.sender.transfer(rewardAmountInWei);\r\n\t\t}\r\n\r\n\t\treturn rewardAmountInWei;\r\n\t}\r\n\r\n\tfunction calculateClaimableReward(address _address) public constant returns (uint256 rewardAmountInWei) {\r\n\t\treturn calculateClaimableRewardTillRound(_address, currentRound);\r\n\t}\r\n\r\n\tfunction calculateClaimableRewardTillRound(address _address, uint64 _claimTillRound) public constant returns (uint256) {\r\n\t\tuint256 rewardAmountInWei = 0;\r\n\r\n\t\tif (_claimTillRound > currentRound) { revert(); }\r\n\t\tif (currentRound < 1) { revert(); }\r\n\r\n\t\tAddressBalanceInfoStructure storage accountBalanceInfo = accountBalances[_address];\r\n\t\tif(accountBalanceInfo.mapKeys.length == 0){\trevert(); }\r\n\r\n\t\tuint64 userLastClaimedRewardRound = accountBalanceInfo.claimedRewardTillRound;\r\n\t\tif (_claimTillRound < userLastClaimedRewardRound) { revert(); }\r\n\r\n\t\tfor (uint64 workRound = userLastClaimedRewardRound; workRound < _claimTillRound; workRound++) {\r\n\r\n\t\t\tReward storage rewardInfo = reward[workRound];\r\n\t\t\tassert(rewardInfo.isConfigured); //don't allow to withdraw reward if affected reward is not configured\r\n\r\n\t\t\tif(accountBalanceInfo.wasModifiedInRoundMap[workRound]){\r\n\t\t\t\trewardAmountInWei = safeAdd(rewardAmountInWei, safeMul(accountBalanceInfo.roundBalanceMap[workRound], rewardInfo.rewardRate));\r\n\t\t\t} else {\r\n\t\t\t\tuint64 lastBalanceModifiedRound = 0;\r\n\t\t\t\tfor (uint256 i = accountBalanceInfo.mapKeys.length; i > 0; i--) {\r\n\t\t\t\t\tuint64 modificationInRound = accountBalanceInfo.mapKeys[i-1];\r\n\t\t\t\t\tif (modificationInRound <= workRound) {\r\n\t\t\t\t\t\tlastBalanceModifiedRound = modificationInRound;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trewardAmountInWei = safeAdd(rewardAmountInWei, safeMul(accountBalanceInfo.roundBalanceMap[lastBalanceModifiedRound], rewardInfo.rewardRate));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn rewardAmountInWei;\r\n\t}\r\n\r\n\tfunction createRounds(uint256 maxRounds) public {\r\n\t\tuint256 blocksAfterLastRound = safeSub(block.number, lastBlockNumberInRound);\t//current block number - last round block number = blocks after last round\r\n\r\n\t\tif(blocksAfterLastRound >= blocksPerRound){\t// need to increase reward round if blocks after last round is greater or equal blocks per round\r\n\r\n\t\t\tuint256 roundsNeedToCreate = safeDiv(blocksAfterLastRound, blocksPerRound);\t//calculate how many rounds need to create\r\n\t\t\tif(roundsNeedToCreate > maxRounds){\r\n\t\t\t\troundsNeedToCreate = maxRounds;\r\n\t\t\t}\r\n\t\t\tlastBlockNumberInRound = safeAdd(lastBlockNumberInRound, safeMul(roundsNeedToCreate, blocksPerRound));\r\n\t\t\tfor (uint256 i = 0; i < roundsNeedToCreate; i++) {\r\n\t\t\t\tupdateRoundInformation();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Private functions\r\n\t//assemble the given address bytecode. If bytecode exists then the _address is a contract.\r\n\tfunction isContract(address _address) private view returns (bool is_contract) {\r\n\t\tuint256 length;\r\n\t\tassembly {\r\n\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_address)\r\n\t\t}\r\n\t\treturn (length > 0);\r\n\t}\r\n\r\n\tfunction isNewRound() private {\r\n\t\tuint256 blocksAfterLastRound = safeSub(block.number, lastBlockNumberInRound);\t//current block number - last round block number = blocks after last round\r\n\t\tif(blocksAfterLastRound >= blocksPerRound){\t// need to increase reward round if blocks after last round is greater or equal blocks per round\r\n\t\t\tupdateRoundsInformation(blocksAfterLastRound);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction updateRoundsInformation(uint256 _blocksAfterLastRound) private {\r\n\t\tuint256 roundsNeedToCreate = safeDiv(_blocksAfterLastRound, blocksPerRound);\t//calculate how many rounds need to create\r\n\t\tlastBlockNumberInRound = safeAdd(lastBlockNumberInRound, safeMul(roundsNeedToCreate, blocksPerRound));\t//calculate last round creation block number\r\n\t\tfor (uint256 i = 0; i < roundsNeedToCreate; i++) {\r\n\t\t\tupdateRoundInformation();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction updateRoundInformation() private {\r\n\t\tissuedTokensInRound[currentRound] = issued;\r\n\r\n\t\tReward storage rewardInfo = reward[currentRound];\r\n\t\trewardInfo.roundNumber = currentRound;\r\n\r\n\t\tcurrentRound = currentRound + 1;\r\n\t}\r\n\r\n\tfunction issue(address _receiver, uint256 _tokenAmount) private {\r\n\t\tif(_tokenAmount == 0){\r\n\t\t\trevert();\r\n\t\t}\r\n\t\tuint256 newIssuedAmount = safeAdd(_tokenAmount, issued);\r\n\t\tif(newIssuedAmount > totalTokens){\r\n\t\t\trevert();\r\n\t\t}\r\n\t\taddToAddressBalancesInfo(_receiver, _tokenAmount);\r\n\t\tissued = newIssuedAmount;\r\n\t\tbytes memory empty;\r\n\t\tif(isContract(_receiver)) {\r\n\t\t\tContractReceiver receiverContract = ContractReceiver(_receiver);\r\n\t\t\treceiverContract.tokenFallback(msg.sender, _tokenAmount, empty);\r\n\t\t}\r\n\t\t/* Notify anyone listening that this transfer took place */\r\n\t\tTransfer(msg.sender, _receiver, _tokenAmount, empty);\r\n\t\tTransfer(msg.sender, _receiver, _tokenAmount);\r\n\t}\r\n\r\n\tfunction addToAddressBalancesInfo(address _receiver, uint256 _tokenAmount) private {\r\n\t\tAddressBalanceInfoStructure storage accountBalance = accountBalances[_receiver];\r\n\r\n\t\tif(!accountBalance.wasModifiedInRoundMap[currentRound]){\t//allow just push one time per round\r\n\t\t\t// If user first time get update balance set user claimed reward round to round before.\r\n\t\t\tif(accountBalance.mapKeys.length == 0 && currentRound > 0){\r\n\t\t\t\taccountBalance.claimedRewardTillRound = currentRound;\r\n\t\t\t}\r\n\t\t\taccountBalance.mapKeys.push(currentRound);\r\n\t\t\taccountBalance.wasModifiedInRoundMap[currentRound] = true;\r\n\t\t}\r\n\t\taccountBalance.addressBalance = safeAdd(accountBalance.addressBalance, _tokenAmount);\r\n\t\taccountBalance.roundBalanceMap[currentRound] = accountBalance.addressBalance;\r\n\t}\r\n\r\n\tfunction subFromAddressBalancesInfo(address _adr, uint256 _tokenAmount) private {\r\n\t\tAddressBalanceInfoStructure storage accountBalance = accountBalances[_adr];\r\n\t\tif(!accountBalance.wasModifiedInRoundMap[currentRound]){\t//allow just push one time per round\r\n\t\t\taccountBalance.mapKeys.push(currentRound);\r\n\t\t\taccountBalance.wasModifiedInRoundMap[currentRound] = true;\r\n\t\t}\r\n\t\taccountBalance.addressBalance = safeSub(accountBalance.addressBalance, _tokenAmount);\r\n\t\taccountBalance.roundBalanceMap[currentRound] = accountBalance.addressBalance;\r\n\t}\r\n\t//function that is called when transaction target is an address\r\n\tfunction transferToAddress(address _from, address _to, uint256 _value, bytes _data) private returns (bool success) {\r\n\t\tif(accountBalances[_from].addressBalance < _value){\t\t// Check if the sender has enough\r\n\t\t\trevert();\r\n\t\t}\r\n\t\tif(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){\t\t// Check for overflows\r\n\t\t\trevert();\r\n\t\t}\r\n\r\n\t\tisNewRound();\r\n\t\tsubFromAddressBalancesInfo(_from, _value);\t// Subtract from the sender\r\n\t\taddToAddressBalancesInfo(_to, _value);\t// Add the same to the recipient\r\n\r\n\t\t/* Notify anyone listening that this transfer took place */\r\n\t\tTransfer(_from, _to, _value, _data);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//function that is called when transaction target is a contract\r\n\tfunction transferToContract(address _from, address _to, uint256 _value, bytes _data) private returns (bool success) {\r\n\t\tif(accountBalances[_from].addressBalance < _value){\t\t// Check if the sender has enough\r\n\t\t\trevert();\r\n\t\t}\r\n\t\tif(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){\t\t// Check for overflows\r\n\t\t\trevert();\r\n\t\t}\r\n\r\n\t\tisNewRound();\r\n\t\tsubFromAddressBalancesInfo(_from, _value);\t// Subtract from the sender\r\n\t\taddToAddressBalancesInfo(_to, _value);\t// Add the same to the recipient\r\n\r\n\t\tContractReceiver receiver = ContractReceiver(_to);\r\n\t\treceiver.tokenFallback(_from, _value, _data);\r\n\r\n\t\t/* Notify anyone listening that this transfer took place */\r\n\t\tTransfer(_from, _to, _value, _data);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"reward\",\"outputs\":[{\"name\":\"roundNumber\",\"type\":\"uint64\"},{\"name\":\"rewardInWei\",\"type\":\"uint256\"},{\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"name\":\"isConfigured\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundNumber\",\"type\":\"uint64\"},{\"name\":\"_roundRewardInWei\",\"type\":\"uint256\"}],\"name\":\"setReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint64\"}],\"name\":\"isModifiedInRound\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_claimTillRound\",\"type\":\"uint64\"}],\"name\":\"calculateClaimableRewardTillRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBlocksPerRound\",\"type\":\"uint64\"}],\"name\":\"setBlocksPerRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContractOwner\",\"type\":\"address\"}],\"name\":\"changeContractOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"issueTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newIssueManager\",\"type\":\"address\"}],\"name\":\"changeIssueManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksPerRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountBalances\",\"outputs\":[{\"name\":\"addressBalance\",\"type\":\"uint256\"},{\"name\":\"claimedRewardTillRound\",\"type\":\"uint64\"},{\"name\":\"totalClaimedReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxRounds\",\"type\":\"uint256\"}],\"name\":\"createRounds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_claimTillRound\",\"type\":\"uint64\"}],\"name\":\"claimRewardTillRound\",\"outputs\":[{\"name\":\"rewardAmountInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getRoundBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"calculateClaimableReward\",\"outputs\":[{\"name\":\"rewardAmountInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[{\"name\":\"rewardAmountInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRoundManager\",\"type\":\"address\"}],\"name\":\"changeRoundManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBalanceModificationRounds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRewardManager\",\"type\":\"address\"}],\"name\":\"changeRewardManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_custom_fallback\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBlockNumberInRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"issuedTokensInRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_blocksPerRound\",\"type\":\"uint256\"},{\"name\":\"_round\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BankeraToken","CompilerVersion":"v0.4.22+commit.4cb486ee","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000060e00000000000000000000000000000000000000000000000000000000000000026","Library":"","SwarmSource":"bzzr://ae46d5011573b1b14431f71e73bd40b7680387fd5b605d06413e11b0b95c6cda"}]}