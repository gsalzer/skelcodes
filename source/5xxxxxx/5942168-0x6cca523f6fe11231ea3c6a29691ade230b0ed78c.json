{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2018 bZeroX, LLC\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ninterface NonCompliantEIP20 {\r\n    function transfer(address _to, uint _value) external;\r\n    function transferFrom(address _from, address _to, uint _value) external;\r\n    function approve(address _spender, uint _value) external;\r\n}\r\n\r\n/**\r\n * @title EIP20/ERC20 wrapper that will support noncompliant ERC20s\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * @dev see https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ncontract EIP20Wrapper {\r\n\r\n    function eip20Transfer(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transfer(to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Transfer failed\");\r\n    }\r\n\r\n    function eip20TransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transferFrom(from, to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20TransferFrom failed\");\r\n    }\r\n\r\n    function eip20Approve(\r\n        address token,\r\n        address spender,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).approve(spender, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Approve failed\");\r\n    }\r\n}\r\n\r\ncontract BZRXFakeFaucet is EIP20Wrapper, Ownable {\r\n\r\n    uint public faucetThresholdSecs = 14400; // 4 hours\r\n\r\n    mapping (address => mapping (address => uint)) public faucetUsers; // mapping of users to mapping of tokens to last request times\r\n\r\n    function() public payable {}\r\n\r\n    function faucet(\r\n        address getToken,\r\n        address receiver)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(block.timestamp-faucetUsers[receiver][getToken] >= faucetThresholdSecs \r\n            && block.timestamp-faucetUsers[msg.sender][getToken] >= faucetThresholdSecs, \"BZRXFakeFaucet::faucet: token requested too recently\");\r\n\r\n        faucetUsers[receiver][getToken] = block.timestamp;\r\n        faucetUsers[msg.sender][getToken] = block.timestamp;\r\n\r\n        eip20Transfer(\r\n            getToken,\r\n            receiver,\r\n            1 ether);\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdrawEther(\r\n        address to,\r\n        uint value)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        uint amount = value;\r\n        if (amount > address(this).balance) {\r\n            amount = address(this).balance;\r\n        }\r\n\r\n        return (to.send(amount)); // solhint-disable-line check-send-result, multiple-sends\r\n    }\r\n\r\n    function withdrawToken(\r\n        address token,\r\n        address to,\r\n        uint tokenAmount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        if (tokenAmount == 0) {\r\n            return false;\r\n        }\r\n        \r\n        eip20Transfer(\r\n            token,\r\n            to,\r\n            tokenAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function depositToken(\r\n        address token,\r\n        address from,\r\n        uint tokenAmount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        if (tokenAmount == 0) {\r\n            return false;\r\n        }\r\n        \r\n        eip20TransferFrom(\r\n            token,\r\n            from,\r\n            this,\r\n            tokenAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferTokenFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint tokenAmount)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        if (tokenAmount == 0) {\r\n            return false;\r\n        }\r\n        \r\n        eip20TransferFrom(\r\n            token,\r\n            from,\r\n            to,\r\n            tokenAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function setFaucetThresholdSecs(\r\n        uint newValue) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newValue != faucetThresholdSecs);\r\n        faucetThresholdSecs = newValue;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"faucetUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"getToken\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"faucet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"faucetThresholdSecs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setFaucetThresholdSecs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"transferTokenFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BZRXFakeFaucet","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c152878043a47362aa3ea52dbfd60b754018299ebd26dca565d990c667982a1f"}]}