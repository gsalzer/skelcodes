{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title EjectableOwnable\r\n * @dev The EjectableOwnable contract provides the function to remove the ownership of the contract.\r\n */\r\ncontract EjectableOwnable is Ownable {\r\n\r\n    /**\r\n     * @dev Remove the ownership by setting the owner address to null,\r\n     * after calling this function, all onlyOwner function will be be able to be called by anyone anymore,\r\n     * the contract will achieve truly decentralisation.\r\n    */\r\n    function removeOwnership() onlyOwner public {\r\n        owner = 0x0;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title JointOwnable\r\n * @dev Extension for the Ownable contract, where the owner can assign another address\r\n *  to manage some functions of the contract, using the eitherOwner modifier.\r\n *  Note that onlyOwner modifier would still be accessible only for the original owner.\r\n */\r\ncontract JointOwnable is Ownable {\r\n\r\n  event AnotherOwnerAssigned(address indexed anotherOwner);\r\n\r\n  address public anotherOwner;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner or anotherOwner.\r\n   */\r\n  modifier eitherOwner() {\r\n    require(msg.sender == owner || msg.sender == anotherOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to assign another owner.\r\n   * @param _anotherOwner The address to another owner.\r\n   */\r\n  function assignAnotherOwner(address _anotherOwner) onlyOwner public {\r\n    require(_anotherOwner != 0);\r\n    AnotherOwnerAssigned(_anotherOwner);\r\n    anotherOwner = _anotherOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments. Inherit from this\r\n * contract and use asyncSend instead of send.\r\n */\r\ncontract PullPayment {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public payments;\r\n  uint256 public totalPayments;\r\n\r\n  /**\r\n   * @dev withdraw accumulated balance, called by payee.\r\n   */\r\n  function withdrawPayments() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n\r\n    require(payment != 0);\r\n    require(this.balance >= payment);\r\n\r\n    totalPayments = totalPayments.sub(payment);\r\n    payments[payee] = 0;\r\n\r\n    assert(payee.send(payment));\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n   * @param dest The destination address of the funds.\r\n   * @param amount The amount to transfer.\r\n   */\r\n  function asyncSend(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n    totalPayments = totalPayments.add(amount);\r\n  }\r\n\r\n}\r\n\r\ncontract DungeonStructs {\r\n\r\n    /**\r\n     * @dev The main Dungeon struct. Every dungeon in the game is represented by this structure.\r\n     * A dungeon is consists of an unlimited number of floors for your heroes to challenge,\r\n     * the power level of a dungeon is encoded in the floorGenes. Some dungeons are in fact more \"challenging\" than others,\r\n     * the secret formula for that is left for user to find out.\r\n     *\r\n     * Each dungeon also has a \"training area\", heroes can perform trainings and upgrade their stat,\r\n     * and some dungeons are more effective in the training, which is also a secret formula!\r\n     *\r\n     * When player challenge or do training in a dungeon, the fee will be collected as the dungeon rewards,\r\n     * which will be rewarded to the player who successfully challenged the current floor.\r\n     *\r\n     * Each dungeon fits in fits into three 256-bit words.\r\n     */\r\n    struct Dungeon {\r\n\r\n        // The timestamp from the block when this dungeon is created.\r\n        uint32 creationTime;\r\n\r\n        // The status of the dungeon, each dungeon can have 4 status, namely:\r\n        // 0: Active | 1: Challenge Only | 2: Train Only | 3: InActive\r\n        uint16 status;\r\n\r\n        // The dungeon's difficulty, the higher the difficulty,\r\n        // normally, the \"rarer\" the seedGenes, the higher the diffculty,\r\n        // and the higher the contribution fee it is to challenge and train with the dungeon,\r\n        // the formula for the contribution fee is in DungeonChallenge and DungeonTraining contracts.\r\n        // A dungeon's difficulty never change.\r\n        uint16 difficulty;\r\n\r\n        // The current floor number, a dungeon is consists of an umlimited number of floors,\r\n        // when there is heroes successfully challenged a floor, the next floor will be\r\n        // automatically generated. 32-bit unsigned integers can have 4 billion floors.\r\n        uint32 floorNumber;\r\n\r\n        // The timestamp from the block when the current floor is generated.\r\n        uint32 floorCreationTime;\r\n\r\n        // Current accumulated rewards, successful challenger will get a large proportion of it.\r\n        uint128 rewards;\r\n\r\n        // The seed genes of the dungeon, it is used as the base gene for first floor,\r\n        // some dungeons are rarer and some are more common, the exact details are,\r\n        // of course, top secret of the game!\r\n        // A dungeon's seedGenes never change.\r\n        uint seedGenes;\r\n\r\n        // The genes for current floor, it encodes the difficulty level of the current floor.\r\n        // We considered whether to store the entire array of genes for all floors, but\r\n        // in order to save some precious gas we're willing to sacrifice some functionalities with that.\r\n        uint floorGenes;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev The main Hero struct. Every hero in the game is represented by this structure.\r\n     */\r\n    struct Hero {\r\n\r\n        // The timestamp from the block when this dungeon is created.\r\n        uint64 creationTime;\r\n\r\n        // The seed of the hero, the gene encodes the power level of the hero.\r\n        // This is another top secret of the game! Hero's gene can be upgraded via\r\n        // training in a dungeon.\r\n        uint genes;\r\n\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title A simplified interface of ERC-721, but without approval functions\r\n */\r\ncontract ERC721 {\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint tokenId);\r\n\r\n    // ERC20 compatible functions\r\n    // function name() public view returns (string);\r\n    // function symbol() public view returns (string);\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n    // Functions that define ownership\r\n    function ownerOf(uint _tokenId) external view returns (address);\r\n    function transfer(address _to, uint _tokenId) external;\r\n\r\n}\r\n\r\n/**\r\n * @title The ERC-721 compliance token contract for the Dungeon tokens.\r\n * @dev See the DungeonStructs contract to see the details of the Dungeon token data structure.\r\n */\r\ncontract DungeonToken is ERC721, DungeonStructs, Pausable, JointOwnable {\r\n\r\n    /**\r\n     * @notice Limits the number of dungeons the contract owner can ever create.\r\n     */\r\n    uint public constant DUNGEON_CREATION_LIMIT = 1024;\r\n\r\n    /**\r\n     * @dev The Mint event is fired whenever a new dungeon is created.\r\n     */\r\n    event Mint(address indexed owner, uint newTokenId, uint difficulty, uint seedGenes);\r\n\r\n    /**\r\n     * @dev The NewDungeonFloor event is fired whenever a new dungeon floor is added.\r\n     */\r\n    event NewDungeonFloor(uint timestamp, uint indexed dungeonId, uint32 newFloorNumber, uint128 newRewards , uint newFloorGenes);\r\n\r\n    /**\r\n     * @dev Transfer event as defined in current draft of ERC721. Emitted every time a token\r\n     *  ownership (Dungeon Master) is assigned, including token creation.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint tokenId);\r\n\r\n    /**\r\n     * @dev Name of token.\r\n     */\r\n    string public constant name = \"Dungeon\";\r\n\r\n    /**\r\n     * @dev Symbol of token.\r\n     */\r\n    string public constant symbol = \"DUNG\";\r\n\r\n    /**\r\n     * @dev An array containing the Dungeon struct, which contains all the dungeons in existance.\r\n     *  The ID for each dungeon is the index of this array.\r\n     */\r\n    Dungeon[] public dungeons;\r\n\r\n    /**\r\n     * @dev A mapping from token IDs to the address that owns them.\r\n     */\r\n    mapping(uint => address) tokenIndexToOwner;\r\n\r\n    /**\r\n     * @dev A mapping from owner address to count of tokens that address owns.\r\n     */\r\n    mapping(address => uint) ownershipTokenCount;\r\n\r\n    /**\r\n     * Each non-fungible token owner can own more than one token at one time.\r\n     * Because each token is referenced by its unique ID, however,\r\n     * it can get difficult to keep track of the individual tokens that a user may own.\r\n     * To do this, the contract keeps a record of the IDs of each token that each user owns.\r\n     */\r\n    mapping(address => uint[]) public ownerTokens;\r\n\r\n    /**\r\n     * @notice Returns the total number of tokens currently in existence.\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return dungeons.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of tokens owned by a specific address.\r\n     * @param _owner The owner address to check.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a given address is the current owner of a particular token.\r\n     * @param _claimant The address we are validating against.\r\n     * @param _tokenId Token ID\r\n     */\r\n    function _owns(address _claimant, uint _tokenId) internal view returns (bool) {\r\n        return tokenIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address currently assigned ownership of a given token.\r\n     */\r\n    function ownerOf(uint _tokenId) external view returns (address) {\r\n        require(tokenIndexToOwner[_tokenId] != address(0));\r\n\r\n        return tokenIndexToOwner[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns ownership of a specific token to an address.\r\n     */\r\n    function _transfer(address _from, address _to, uint _tokenId) internal {\r\n        // Increment the ownershipTokenCount.\r\n        ownershipTokenCount[_to]++;\r\n\r\n        // Transfer ownership.\r\n        tokenIndexToOwner[_tokenId] = _to;\r\n\r\n        // Add the _tokenId to ownerTokens[_to]\r\n        ownerTokens[_to].push(_tokenId);\r\n\r\n        // When creating new token, _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n\r\n            // Remove the _tokenId from ownerTokens[_from]\r\n            uint[] storage fromTokens = ownerTokens[_from];\r\n            bool iFound = false;\r\n\r\n            for (uint i = 0; i < fromTokens.length - 1; i++) {\r\n                if (iFound) {\r\n                    fromTokens[i] = fromTokens[i + 1];\r\n                } else if (fromTokens[i] == _tokenId) {\r\n                    iFound = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emit the Transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice External function to transfers a token to another address.\r\n     * @param _to The address of the recipient, can be a user or contract.\r\n     * @param _tokenId The ID of the token to transfer.\r\n     */\r\n    function transfer(address _to, uint _tokenId) whenNotPaused external {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n\r\n        // You can only send your own token.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function that creates a new dungeon and stores it, only contract owners\r\n     *  can create new token, and will be restricted by the DUNGEON_CREATION_LIMIT.\r\n     *  Will generate a Mint event, a  NewDungeonFloor event, and a Transfer event.\r\n     * @param _difficulty The difficulty of the new dungeon.\r\n     * @param _seedGenes The seed genes of the new dungeon.\r\n     * @return The dungeon ID of the new dungeon.\r\n     */\r\n    function createDungeon(uint _difficulty, uint _seedGenes, address _owner) eitherOwner external returns (uint) {\r\n        // Ensure the total supply is within the fixed limit.\r\n        require(totalSupply() < DUNGEON_CREATION_LIMIT);\r\n\r\n        // UPDATE STORAGE\r\n        // Create a new dungeon.\r\n        dungeons.push(Dungeon(uint32(now), 0, uint16(_difficulty), 0, 0, 0, _seedGenes, 0));\r\n\r\n        // Token id is the index in the storage array.\r\n        uint newTokenId = dungeons.length - 1;\r\n\r\n        // Emit the token mint event.\r\n        Mint(_owner, newTokenId, _difficulty, _seedGenes);\r\n\r\n        // Initialize the fist floor with using the seedGenes, this will emit the NewDungeonFloor event.\r\n        addDungeonNewFloor(newTokenId, 0, _seedGenes);\r\n\r\n        // This will assign ownership, and also emit the Transfer event.\r\n        _transfer(0, _owner, newTokenId);\r\n\r\n        return newTokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to set dungeon status by its ID,\r\n     *  refer to DungeonStructs for more information about dungeon status.\r\n     *  Only contract owners can alter dungeon state.\r\n     */\r\n    function setDungeonStatus(uint _id, uint _newStatus) eitherOwner external {\r\n        require(_id < totalSupply());\r\n\r\n        dungeons[_id].status = uint16(_newStatus);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to add additional dungeon rewards by its ID,\r\n     *  only contract owners can alter dungeon state.\r\n     */\r\n    function addDungeonRewards(uint _id, uint _additinalRewards) eitherOwner external {\r\n        require(_id < totalSupply());\r\n\r\n        dungeons[_id].rewards += uint64(_additinalRewards);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to add another dungeon floor by its ID,\r\n     *  only contract owners can alter dungeon state.\r\n     *  Will generate both a NewDungeonFloor event.\r\n     */\r\n    function addDungeonNewFloor(uint _id, uint _newRewards, uint _newFloorGenes) eitherOwner public {\r\n        require(_id < totalSupply());\r\n\r\n        Dungeon storage dungeon = dungeons[_id];\r\n\r\n        dungeon.floorNumber++;\r\n        dungeon.floorCreationTime = uint32(now);\r\n        dungeon.rewards = uint128(_newRewards);\r\n        dungeon.floorGenes = _newFloorGenes;\r\n\r\n        // Emit the NewDungeonFloor event.\r\n        NewDungeonFloor(now, _id, dungeon.floorNumber, dungeon.rewards, dungeon.floorGenes);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title The ERC-721 compliance token contract for the Hero tokens.\r\n * @dev See the DungeonStructs contract to see the details of the Hero token data structure.\r\n */\r\ncontract HeroToken is ERC721, DungeonStructs, Pausable, JointOwnable {\r\n\r\n    /**\r\n     * @dev The Mint event is fired whenever a new hero is created.\r\n     */\r\n    event Mint(address indexed owner, uint newTokenId, uint _genes);\r\n\r\n    /**\r\n     * @dev Transfer event as defined in current draft of ERC721. Emitted every time a token\r\n     *  ownership is assigned, including token creation.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint tokenId);\r\n\r\n    /**\r\n     * @dev Name of token.\r\n     */\r\n    string public constant name = \"Hero\";\r\n\r\n    /**\r\n     * @dev Symbol of token.\r\n     */\r\n    string public constant symbol = \"HERO\";\r\n\r\n    /**\r\n     * @dev An array containing the Hero struct, which contains all the heroes in existance.\r\n     *  The ID for each hero is the index of this array.\r\n     */\r\n    Hero[] public heroes;\r\n\r\n    /**\r\n     * @dev A mapping from token IDs to the address that owns them.\r\n     */\r\n    mapping(uint => address) tokenIndexToOwner;\r\n\r\n    /**\r\n     * @dev A mapping from owner address to count of tokens that address owns.\r\n     */\r\n    mapping(address => uint) ownershipTokenCount;\r\n\r\n    /**\r\n     * Each non-fungible token owner can own more than one token at one time.\r\n     * Because each token is referenced by its unique ID, however,\r\n     * it can get difficult to keep track of the individual tokens that a user may own.\r\n     * To do this, the contract keeps a record of the IDs of each token that each user owns.\r\n     */\r\n    mapping(address => uint[]) public ownerTokens;\r\n\r\n    /**\r\n     * @notice Returns the total number of tokens currently in existence.\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return heroes.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of tokens owned by a specific address.\r\n     * @param _owner The owner address to check.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a given address is the current owner of a particular token.\r\n     * @param _claimant The address we are validating against.\r\n     * @param _tokenId Token ID\r\n     */\r\n    function _owns(address _claimant, uint _tokenId) internal view returns (bool) {\r\n        return tokenIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address currently assigned ownership of a given token.\r\n     */\r\n    function ownerOf(uint _tokenId) external view returns (address) {\r\n        require(tokenIndexToOwner[_tokenId] != address(0));\r\n\r\n        return tokenIndexToOwner[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns ownership of a specific token to an address.\r\n     */\r\n    function _transfer(address _from, address _to, uint _tokenId) internal {\r\n        // Increment the ownershipTokenCount.\r\n        ownershipTokenCount[_to]++;\r\n\r\n        // Transfer ownership.\r\n        tokenIndexToOwner[_tokenId] = _to;\r\n\r\n        // Add the _tokenId to ownerTokens[_to]\r\n        ownerTokens[_to].push(_tokenId);\r\n\r\n        // When creating new token, _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n\r\n            // Remove the _tokenId from ownerTokens[_from]\r\n            uint[] storage fromTokens = ownerTokens[_from];\r\n            bool iFound = false;\r\n\r\n            for (uint i = 0; i < fromTokens.length - 1; i++) {\r\n                if (iFound) {\r\n                    fromTokens[i] = fromTokens[i + 1];\r\n                } else if (fromTokens[i] == _tokenId) {\r\n                    iFound = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emit the Transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice External function to transfers a token to another address.\r\n     * @param _to The address of the recipient, can be a user or contract.\r\n     * @param _tokenId The ID of the token to transfer.\r\n     */\r\n    function transfer(address _to, uint _tokenId) whenNotPaused external {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n\r\n        // You can only send your own token.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev An external function that creates a new hero and stores it,\r\n     *  only contract owners can create new token.\r\n     *  method doesn't do any checking and should only be called when the\r\n     *  input data is known to be valid.\r\n     * @param _genes The gene of the new hero.\r\n     * @param _owner The inital owner of this hero.\r\n     * @return The hero ID of the new hero.\r\n     */\r\n    function createHero(uint _genes, address _owner) external returns (uint) {\r\n        // UPDATE STORAGE\r\n        // Create a new hero.\r\n        heroes.push(Hero(uint64(now), _genes));\r\n\r\n        // Token id is the index in the storage array.\r\n        uint newTokenId = heroes.length - 1;\r\n\r\n        // Emit the token mint event.\r\n        Mint(_owner, newTokenId, _genes);\r\n\r\n        // This will assign ownership, and also emit the Transfer event.\r\n        _transfer(0, _owner, newTokenId);\r\n\r\n        return newTokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to set the hero genes by its ID,\r\n     *  only contract owners can alter hero state.\r\n     */\r\n    function setHeroGenes(uint _id, uint _newGenes) eitherOwner external {\r\n        require(_id < totalSupply());\r\n\r\n        Hero storage hero = heroes[_id];\r\n\r\n        hero.genes = _newGenes;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * SECRET\r\n */\r\ncontract ChallengeScienceInterface {\r\n\r\n    /**\r\n     * @dev given genes of current floor and dungeon seed, return a genetic combination - may have a random factor\r\n     * @param _floorGenes genes of floor\r\n     * @param _seedGenes seed genes of dungeon\r\n     * @return the resulting genes\r\n     */\r\n    function mixGenes(uint _floorGenes, uint _seedGenes) external pure returns (uint);\r\n\r\n}\r\n\r\n/**\r\n * SECRET\r\n */\r\ncontract TrainingScienceInterface {\r\n\r\n    /**\r\n     * @dev given genes of hero and current floor, return a genetic combination - may have a random factor\r\n     * @param _heroGenes genes of hero\r\n     * @param _floorGenes genes of current floor\r\n     * @return the resulting genes\r\n     */\r\n    function mixGenes(uint _heroGenes, uint _floorGenes) external pure returns (uint);\r\n\r\n}\r\n\r\n/**\r\n * @title DungeonBase\r\n * @dev Base contract for Ether Dungeon. It implements all necessary sub-classes,\r\n * holds all the base storage variables, and some commonly used functions.\r\n */\r\ncontract DungeonBase is EjectableOwnable, Pausable, PullPayment, DungeonStructs {\r\n\r\n    /* ======== TOKEN CONTRACTS ======== */\r\n\r\n    /**\r\n     * @dev The address of the ERC721 token contract managing all Dungeon tokens.\r\n     */\r\n    DungeonToken public dungeonTokenContract;\r\n\r\n    /**\r\n     * @dev The address of the ERC721 token contract managing all Hero tokens.\r\n     */\r\n    HeroToken public heroTokenContract;\r\n\r\n\r\n    /* ======== CLOSED SOURCE CONTRACTS ======== */\r\n\r\n    /**\r\n     * @dev The address of the ChallengeScience contract that handles the floor generation mechanics after challenge success.\r\n     */\r\n    ChallengeScienceInterface challengeScienceContract;\r\n\r\n    /**\r\n     * @dev The address of the TrainingScience contract that handles the hero training mechanics.\r\n     */\r\n    TrainingScienceInterface trainingScienceContract;\r\n\r\n\r\n    /* ======== SETTER FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Set the address of the dungeon token contract.\r\n     * @param _newDungeonTokenContract An address of a DungeonToken contract.\r\n     */\r\n    function setDungeonTokenContract(address _newDungeonTokenContract) onlyOwner external {\r\n        dungeonTokenContract = DungeonToken(_newDungeonTokenContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the hero token contract.\r\n     * @param _newHeroTokenContract An address of a HeroToken contract.\r\n     */\r\n    function setHeroTokenContract(address _newHeroTokenContract) onlyOwner external {\r\n        heroTokenContract = HeroToken(_newHeroTokenContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the secret dungeon challenge formula contract.\r\n     * @param _newChallengeScienceAddress An address of a ChallengeScience contract.\r\n     */\r\n    function setChallengeScienceContract(address _newChallengeScienceAddress) onlyOwner external {\r\n        challengeScienceContract = ChallengeScienceInterface(_newChallengeScienceAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the secret hero training formula contract.\r\n     * @param _newTrainingScienceAddress An address of a TrainingScience contract.\r\n     */\r\n    function setTrainingScienceContract(address _newTrainingScienceAddress) onlyOwner external {\r\n        trainingScienceContract = TrainingScienceInterface(_newTrainingScienceAddress);\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n    /**\r\n     * @dev Throws if _dungeonId is not created yet.\r\n     */\r\n    modifier dungeonExists(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if dungeon status do not allow challenge, also check for dungeon existence.\r\n     */\r\n    modifier canChallenge(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        uint status;\r\n        (,status,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\r\n        require(status == 0 || status == 1);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if dungeon status do not allow training, also check for dungeon existence.\r\n     */\r\n    modifier canTrain(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        uint status;\r\n        (,status,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\r\n        require(status == 0 || status == 2);\r\n        _;\r\n    }\r\n\r\n\r\n    /* ======== HELPER FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev An internal function to calculate the power of player, or difficulty of a dungeon floor,\r\n     *  if the total heroes power is larger than the current dungeon floor difficulty, the heroes win the challenge.\r\n     */\r\n    function _getGenesPower(uint _genes) internal pure returns (uint) {\r\n        // Calculate total stats power.\r\n        uint statsPower;\r\n\r\n        for (uint i = 0; i < 4; i++) {\r\n            statsPower += _genes % 32;\r\n            _genes /= 32 ** 4;\r\n        }\r\n\r\n        // Calculate total stats power.\r\n        uint equipmentPower;\r\n        bool isSuper = true;\r\n\r\n        for (uint j = 4; j < 12; j++) {\r\n            uint curGene = _genes % 32;\r\n            equipmentPower += curGene;\r\n            _genes /= 32 ** 4;\r\n\r\n            if (equipmentPower != curGene * (j - 3)) {\r\n                isSuper = false;\r\n            }\r\n        }\r\n\r\n        // Calculate super power.\r\n        if (isSuper) {\r\n            equipmentPower *= 2;\r\n        }\r\n\r\n        return statsPower + equipmentPower + 12;\r\n    }\r\n\r\n}\r\n\r\ncontract DungeonChallenge is DungeonBase {\r\n\r\n    /**\r\n     * @dev The DungeonChallenged event is fired when user finished a dungeon challenge.\r\n     */\r\n    event DungeonChallenged(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newFloorGenes, uint successRewards, uint masterRewards);\r\n\r\n    /**\r\n     * @notice The actual fee contribution required to call challenge() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty. The payment is accumulated to the dungeon rewards,\r\n     *  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n     *  1 finney = 0.001 ether\r\n     */\r\n    uint256 public challengeFeeMultiplier = 1 finney;\r\n\r\n    /**\r\n     * @dev The percentage for which successful challenger be rewarded of the dungeons' accumulated rewards.\r\n     *  The remaining rewards subtracted by developer fee will be used as the base rewards for new floor.\r\n     */\r\n    uint public challengeRewardsPercent = 64;\r\n\r\n    /**\r\n     * @dev The developer fee for owner\r\n     *  Note that when Ether Dungeon becomes truly decentralised, contract ownership will be ejected,\r\n     *  and the master rewards will be rewarded to the dungeon owner (Dungeon Masters).\r\n     */\r\n    uint public masterRewardsPercent = 8;\r\n\r\n    /**\r\n     * @dev The main public function to call when a player challenge a dungeon,\r\n     *  it determines whether if the player successfully challenged the current floor.\r\n     *  Will generate a DungeonChallenged event.\r\n     */\r\n    function challenge(uint _dungeonId) external payable whenNotPaused canChallenge(_dungeonId) {\r\n        // Get the dungeon details from the token contract.\r\n        uint difficulty;\r\n        uint seedGenes;\r\n        (,,difficulty,,,,seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        uint requiredFee = difficulty * challengeFeeMultiplier;\r\n        require(msg.value >= requiredFee);\r\n\r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon.\r\n        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - requiredFee);\r\n\r\n        // Split the challenge function into multiple parts because of stack too deep error.\r\n        _challengePart2(_dungeonId);\r\n    }\r\n\r\n    /**\r\n     * Split the challenge function into multiple parts because of stack too deep error.\r\n     */\r\n    function _challengePart2(uint _dungeonId) private {\r\n        uint floorNumber;\r\n        uint rewards;\r\n        uint floorGenes;\r\n        (,,,floorNumber,,rewards,,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Get the first hero gene, or initialize first hero with current dungeon's seed genes.\r\n        // TODO: implement multiple heroes in next phase\r\n        uint heroGenes = _getFirstHeroGenesAndInitialize(_dungeonId);\r\n\r\n        bool success = _getChallengeSuccess(heroGenes, floorGenes);\r\n\r\n        uint newFloorGenes;\r\n        uint successRewards;\r\n        uint masterRewards;\r\n\r\n        // Whether a challenge is success or not is determined by a simple comparison between hero power and floor power.\r\n        if (success) {\r\n            newFloorGenes = _getNewFloorGene(_dungeonId);\r\n            successRewards = rewards * challengeRewardsPercent / 100;\r\n            masterRewards = rewards * masterRewardsPercent / 100;\r\n\r\n            // The dungeon rewards for new floor as total rewards - challenge rewards - devleoper fee.\r\n            uint newRewards = rewards * (100 - challengeRewardsPercent - masterRewardsPercent) / 100;\r\n\r\n            // ** STORAGE UPDATE **\r\n            // Add new floor with the new floor genes and new rewards.\r\n            dungeonTokenContract.addDungeonNewFloor(_dungeonId, newRewards, newFloorGenes);\r\n\r\n            // Mark the challenge rewards available to be withdrawed by the player.\r\n            asyncSend(msg.sender, successRewards);\r\n\r\n            // Mark the master rewards available to be withdrawed by the dungeon master.\r\n            asyncSend(dungeonTokenContract.ownerOf(_dungeonId), masterRewards);\r\n        }\r\n\r\n        // Emit the DungeonChallenged event.\r\n        DungeonChallenged(now, msg.sender, _dungeonId, heroGenes, floorNumber, floorGenes, success, newFloorGenes, successRewards, masterRewards);\r\n    }\r\n\r\n    /**\r\n     * Split the challenge function into multiple parts because of stack too deep error.\r\n     */\r\n    function _getFirstHeroGenesAndInitialize(uint _dungeonId) private returns (uint heroGenes) {\r\n        uint seedGenes;\r\n        (,,,,,,seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Get the first hero of the player.\r\n        uint heroId;\r\n\r\n        if (heroTokenContract.balanceOf(msg.sender) == 0) {\r\n            // Assign the first hero using the seed genes of the dungeon for new player.\r\n            heroId = heroTokenContract.createHero(seedGenes, msg.sender);\r\n        } else {\r\n            heroId = heroTokenContract.ownerTokens(msg.sender, 0);\r\n        }\r\n\r\n        // Get the hero genes from token storage.\r\n        (,heroGenes) = heroTokenContract.heroes(heroId);\r\n    }\r\n\r\n    /**\r\n     * Split the challenge function into multiple parts because of stack too deep error.\r\n     */\r\n    function _getChallengeSuccess(uint heroGenes, uint floorGenes) private pure returns (bool) {\r\n        // Determine if the player challenge successfuly the dungeon or not, and the new floor genes.\r\n        uint heroPower = _getGenesPower(heroGenes);\r\n        uint floorPower = _getGenesPower(floorGenes);\r\n\r\n        return heroPower > floorPower;\r\n    }\r\n\r\n    /**\r\n     * Split the challenge function into multiple parts because of stack too deep error.\r\n     */\r\n    function _getNewFloorGene(uint _dungeonId) private view returns (uint) {\r\n        uint seedGenes;\r\n        uint floorGenes;\r\n        (,,,,,seedGenes,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Calculate the new floor gene.\r\n        uint floorPower = _getGenesPower(floorGenes);\r\n        uint newFloorGenes = challengeScienceContract.mixGenes(floorGenes, seedGenes);\r\n        uint newFloorPower = _getGenesPower(newFloorGenes);\r\n\r\n        // If the power decreased, rollback to the current floor genes.\r\n        if (newFloorPower < floorPower) {\r\n            newFloorGenes = floorGenes;\r\n        }\r\n\r\n        return newFloorGenes;\r\n    }\r\n\r\n\r\n    /* ======== SETTER FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Updates the fee contribution multiplier required for calling challenge().\r\n     */\r\n    function setChallengeFeeMultiplier(uint _newChallengeFeeMultiplier) external onlyOwner {\r\n        challengeFeeMultiplier = _newChallengeFeeMultiplier;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the challenge rewards pecentage.\r\n     */\r\n    function setChallengeRewardsPercent(uint _newChallengeRewardsPercent) onlyOwner external {\r\n        challengeRewardsPercent = _newChallengeRewardsPercent;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the master rewards percentage.\r\n     */\r\n    function setMasterRewardsPercent(uint _newMasterRewardsPercent) onlyOwner external {\r\n        masterRewardsPercent = _newMasterRewardsPercent;\r\n    }\r\n\r\n}\r\n\r\ncontract DungeonTraining is DungeonChallenge {\r\n\r\n    /// @dev The HeroTrained event is fired when user finished a training.\r\n    event HeroTrained(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newHeroGenes);\r\n\r\n    /// @notice The actual fee contribution required to call trainX() is calculated by this feeMultiplier,\r\n    ///  times the dungeon difficulty, times X. The payment is accumulated to the dungeon rewards,\r\n    ///  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n    ///  1 finney = 0.001 ether\r\n    uint256 public trainingFeeMultiplier = 2 finney;\r\n\r\n    /// @dev Updates the fee contribution multiplier required for calling trainX().\r\n    function setTrainingFeeMultiplier(uint _newTrainingFeeMultiplier) external onlyOwner {\r\n        trainingFeeMultiplier = _newTrainingFeeMultiplier;\r\n    }\r\n\r\n    /// @dev The public function to call when a hero train with a dungeon,\r\n    ///  it determines whether whether a training is successfully, and the resulting genes.\r\n    ///  Will generate a DungeonChallenged event.\r\n    function train1(uint _dungeonId) external payable whenNotPaused canTrain(_dungeonId) {\r\n        _train(_dungeonId, 1);\r\n    }\r\n\r\n    function train2(uint _dungeonId) external payable whenNotPaused canTrain(_dungeonId) {\r\n        _train(_dungeonId, 2);\r\n    }\r\n\r\n    function train3(uint _dungeonId) external payable whenNotPaused canTrain(_dungeonId) {\r\n        _train(_dungeonId, 3);\r\n    }\r\n\r\n    /// @dev An internal function of a hero train with dungeon,\r\n    ///  it determines whether whether a training is successfully, and the resulting genes.\r\n    ///  Will generate a DungeonChallenged event.\r\n    function _train(uint _dungeonId, uint _trainingTimes) private {\r\n        // Get the dungeon details from the token contract.\r\n        uint difficulty;\r\n        uint floorNumber;\r\n        uint rewards;\r\n        uint seedGenes;\r\n        uint floorGenes;\r\n        (,,difficulty,floorNumber,,rewards,seedGenes,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Check for _trainingTimes abnormality, we probably won't have any feature that train a hero 10 times with a single call.\r\n        require(_trainingTimes < 10);\r\n\r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        uint requiredFee = difficulty * trainingFeeMultiplier * _trainingTimes;\r\n        require(msg.value >= requiredFee);\r\n\r\n        // Get the first hero of the player.\r\n        // TODO: implement multiple heroes in next phase\r\n        uint heroId;\r\n\r\n        if (heroTokenContract.balanceOf(msg.sender) == 0) {\r\n            // Assign the first hero using the seed genes of the dungeon for new player.\r\n            heroId = heroTokenContract.createHero(seedGenes, msg.sender);\r\n        } else {\r\n            heroId = heroTokenContract.ownerTokens(msg.sender, 0);\r\n        }\r\n\r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon.\r\n        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - requiredFee);\r\n\r\n        // Split the _train function into multiple parts because of stack too deep error.\r\n        _trainPart2(_dungeonId, _trainingTimes, heroId);\r\n    }\r\n\r\n    /**\r\n     * Split the _train function into multiple parts because of stack too deep error.\r\n     */\r\n    function _trainPart2(uint _dungeonId, uint _trainingTimes, uint _heroId) private {\r\n        // Get the dungeon details from the token contract.\r\n        uint floorNumber;\r\n        uint floorGenes;\r\n        (,,,floorNumber,,,,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        uint heroGenes;\r\n        (,heroGenes) = heroTokenContract.heroes(_heroId);\r\n\r\n        // Determine if the hero training is successful or not, and the resulting genes.\r\n        uint heroPower = _getGenesPower(heroGenes);\r\n\r\n        uint newHeroGenes = heroGenes;\r\n        uint newHeroPower = heroPower;\r\n\r\n        // Train the hero multiple times according to _trainingTimes,\r\n        // each time if the resulting power is larger, update new hero power.\r\n        for (uint i = 0; i < _trainingTimes; i++) {\r\n            uint tmpHeroGenes = trainingScienceContract.mixGenes(newHeroGenes, floorGenes);\r\n            uint tmpHeroPower = _getGenesPower(tmpHeroGenes);\r\n\r\n            if (tmpHeroPower > newHeroPower) {\r\n                newHeroGenes = tmpHeroGenes;\r\n                newHeroPower = tmpHeroPower;\r\n            }\r\n        }\r\n\r\n        // Prevent reduced power.\r\n        bool success = newHeroPower > heroPower;\r\n\r\n        if (success) {\r\n            // ** STORAGE UPDATE **\r\n            // Set the upgraded hero genes.\r\n            heroTokenContract.setHeroGenes(_heroId, newHeroGenes);\r\n        }\r\n\r\n        // Emit the HeroTrained event.\r\n        HeroTrained(now, msg.sender, _dungeonId, heroGenes, floorNumber, floorGenes, success, newHeroGenes);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title DungeonCoreAlpha2 (fixed challenge rewards calculation bug)\r\n * @dev Core Contract of Ether Dungeon.\r\n *  When Beta launches, DungeonCoreBeta contract will be deployed and DungeonCoreAlpha will be destroyed.\r\n *  Since all dungeons and heroes are stored as tokens in external contracts, they remains immutable.\r\n */\r\ncontract DungeonCoreAlpha2 is Destructible, DungeonTraining {\r\n\r\n    /**\r\n     * Initialize the DungeonCore(Alpha) contract with all the required contract addresses.\r\n     * TODO: really require payable here? why?\r\n     */\r\n    function DungeonCoreAlpha2(\r\n        address _dungeonTokenAddress,\r\n        address _heroTokenAddress,\r\n        address _challengeScienceAddress,\r\n        address _trainingScienceAddress\r\n    ) public {\r\n        dungeonTokenContract = DungeonToken(_dungeonTokenAddress);\r\n        heroTokenContract = HeroToken(_heroTokenAddress);\r\n        challengeScienceContract = ChallengeScienceInterface(_challengeScienceAddress);\r\n        trainingScienceContract = TrainingScienceInterface(_trainingScienceAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific dungeon by its ID.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonDetails(uint _id) external view returns (uint creationTime, uint status, uint difficulty, uint floorNumber, uint floorCreationTime, uint rewards, uint seedGenes, uint floorGenes) {\r\n        require(_id < dungeonTokenContract.totalSupply());\r\n\r\n        (creationTime, status, difficulty, floorNumber, floorCreationTime, rewards, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_id);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific hero by its ID.\r\n     * @param _id The ID of the hero.\r\n     */\r\n    function getHeroDetails(uint _id) external view returns (uint creationTime, uint genes) {\r\n        require(_id < heroTokenContract.totalSupply());\r\n\r\n        (creationTime, genes) = heroTokenContract.heroes(_id);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dungeonTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"}],\"name\":\"train1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDungeonDetails\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint256\"},{\"name\":\"difficulty\",\"type\":\"uint256\"},{\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"name\":\"floorCreationTime\",\"type\":\"uint256\"},{\"name\":\"rewards\",\"type\":\"uint256\"},{\"name\":\"seedGenes\",\"type\":\"uint256\"},{\"name\":\"floorGenes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTrainingFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setTrainingFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heroTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newHeroTokenContract\",\"type\":\"address\"}],\"name\":\"setHeroTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDungeonTokenContract\",\"type\":\"address\"}],\"name\":\"setDungeonTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getHeroDetails\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"genes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"}],\"name\":\"train2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"}],\"name\":\"train3\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMasterRewardsPercent\",\"type\":\"uint256\"}],\"name\":\"setMasterRewardsPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setChallengeFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTrainingScienceAddress\",\"type\":\"address\"}],\"name\":\"setTrainingScienceContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"}],\"name\":\"challenge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trainingFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeRewardsPercent\",\"type\":\"uint256\"}],\"name\":\"setChallengeRewardsPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeScienceAddress\",\"type\":\"address\"}],\"name\":\"setChallengeScienceContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dungeonTokenAddress\",\"type\":\"address\"},{\"name\":\"_heroTokenAddress\",\"type\":\"address\"},{\"name\":\"_challengeScienceAddress\",\"type\":\"address\"},{\"name\":\"_trainingScienceAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"heroGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"newHeroGenes\",\"type\":\"uint256\"}],\"name\":\"HeroTrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"heroGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"newFloorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"successRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"masterRewards\",\"type\":\"uint256\"}],\"name\":\"DungeonChallenged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DungeonCoreAlpha2","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c414e4a3df732e69b74f8fece1d778fe0248a5a00000000000000000000000002375431de246544b5c9d80a7375f5cf02b96502b000000000000000000000000150a2589a45d52d672d70d01eef9ce1a51b0f00100000000000000000000000061aa25869b738cf7fdd80062e25e054c7f1d777f","Library":"","SwarmSource":"bzzr://9b2f9a9ea639b193a703d9fd40596fb5ef0eb2e70cc790aa0d3656a5127a8e28"}]}