{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * @notice Checks if the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *      as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    // a variable to load `extcodesize` to\r\n    uint256 size = 0;\r\n\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\r\n    // TODO: Check this again before the Serenity release, because all addresses will be contracts.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      // retrieve the size of the code at address `addr`\r\n      size := extcodesize(addr)\r\n    }\r\n\r\n    // positive size indicates a smart contract address\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Library for working with strings, primarily converting\r\n * between strings and integer types\r\n */\r\nlibrary StringUtils {\r\n  /**\r\n   * @dev Converts a string to unsigned integer using the specified `base`\r\n   * @dev Throws on invalid input\r\n   *      (wrong characters for a given `base`)\r\n   * @dev Throws if given `base` is not supported\r\n   * @param a string to convert\r\n   * @param base number base, one of 2, 8, 10, 16\r\n   * @return a number representing given string\r\n   */\r\n  function atoi(string a, uint8 base) internal pure returns (uint256 i) {\r\n    // check if the base is valid\r\n    require(base == 2 || base == 8 || base == 10 || base == 16);\r\n\r\n    // convert string into bytes for convenient iteration\r\n    bytes memory buf = bytes(a);\r\n\r\n    // iterate over the string (bytes buffer)\r\n    for(uint256 p = 0; p < buf.length; p++) {\r\n      // extract the digit\r\n      uint8 digit = uint8(buf[p]) - 0x30;\r\n\r\n      // if digit is greater then 10 â€“ mind the gap\r\n      // see `itoa` function for more details\r\n      if(digit > 10) {\r\n        // remove the gap\r\n        digit -= 7;\r\n      }\r\n\r\n      // check if digit meets the base\r\n      require(digit < base);\r\n\r\n      // move to the next digit slot\r\n      i *= base;\r\n\r\n      // add digit to the result\r\n      i += digit;\r\n    }\r\n\r\n    // return the result\r\n    return i;\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a integer to a string using the specified `base`\r\n   * @dev Throws if given `base` is not supported\r\n   * @param i integer to convert\r\n   * @param base number base, one of 2, 8, 10, 16\r\n   * @return a string representing given integer\r\n   */\r\n  function itoa(uint256 i, uint8 base) internal pure returns (string a) {\r\n    // check if the base is valid\r\n    require(base == 2 || base == 8 || base == 10 || base == 16);\r\n\r\n    // for zero input the result is \"0\" string for any base\r\n    if (i == 0) {\r\n      return \"0\";\r\n    }\r\n\r\n    // bytes buffer to put ASCII characters into\r\n    bytes memory buf = new bytes(256);\r\n\r\n    // position within a buffer to be used in cycle\r\n    uint256 p = 0;\r\n\r\n    // extract digits one by one in a cycle\r\n    while (i > 0) {\r\n      // extract current digit\r\n      uint8 digit = uint8(i % base);\r\n\r\n      // convert it to an ASCII code\r\n      // 0x20 is \" \"\r\n      // 0x30-0x39 is \"0\"-\"9\"\r\n      // 0x41-0x5A is \"A\"-\"Z\"\r\n      // 0x61-0x7A is \"a\"-\"z\" (\"A\"-\"Z\" XOR \" \")\r\n      uint8 ascii = digit + 0x30;\r\n\r\n      // if digit is greater then 10,\r\n      // fix the 0x3A-0x40 gap of punctuation marks\r\n      // (7 characters in ASCII table)\r\n      if(digit > 10) {\r\n        // jump through the gap\r\n        ascii += 7;\r\n      }\r\n\r\n      // write character into the buffer\r\n      buf[p++] = byte(ascii);\r\n\r\n      // move to the next digit\r\n      i /= base;\r\n    }\r\n\r\n    // `p` contains real length of the buffer now, save it\r\n    uint256 length = p;\r\n\r\n    // reverse the buffer\r\n    for(p = 0; p < length / 2; p++) {\r\n      // swap elements at position `p` from the beginning and end using XOR:\r\n      // https://en.wikipedia.org/wiki/XOR_swap_algorithm\r\n      buf[p] ^= buf[length - 1 - p];\r\n      buf[length - 1 - p] ^= buf[p];\r\n      buf[p] ^= buf[length - 1 - p];\r\n    }\r\n\r\n    // construct string and return\r\n    return string(buf);\r\n  }\r\n\r\n  /**\r\n   * @dev Concatenates two strings `s1` and `s2`, for example, if\r\n   *      `s1` == `foo` and `s2` == `bar`, the result `s` == `foobar`\r\n   * @param s1 first string\r\n   * @param s2 second string\r\n   * @return concatenation result s1 + s2\r\n   */\r\n  function concat(string s1, string s2) internal pure returns (string s) {\r\n    // convert s1 into buffer 1\r\n    bytes memory buf1 = bytes(s1);\r\n    // convert s2 into buffer 2\r\n    bytes memory buf2 = bytes(s2);\r\n    // create a buffer for concatenation result\r\n    bytes memory buf = new bytes(buf1.length + buf2.length);\r\n\r\n    // copy buffer 1 into buffer\r\n    for(uint256 i = 0; i < buf1.length; i++) {\r\n      buf[i] = buf1[i];\r\n    }\r\n\r\n    // copy buffer 2 into buffer\r\n    for(uint256 j = buf1.length; j < buf2.length; j++) {\r\n      buf[j] = buf2[j - buf1.length];\r\n    }\r\n\r\n    // construct string and return\r\n    return string(buf);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Access control module provides an API to check\r\n *      if specific operation is permitted globally and\r\n *      if particular user's has a permission to execute it\r\n */\r\ncontract AccessControl {\r\n  /// @notice Role manager is responsible for assigning the roles\r\n  /// @dev Role ROLE_ROLE_MANAGER allows executing addOperator/removeOperator\r\n  uint256 private constant ROLE_ROLE_MANAGER = 0x10000000;\r\n\r\n  /// @notice Feature manager is responsible for enabling/disabling\r\n  ///      global features of the smart contract\r\n  /// @dev Role ROLE_FEATURE_MANAGER allows enabling/disabling global features\r\n  uint256 private constant ROLE_FEATURE_MANAGER = 0x20000000;\r\n\r\n  /// @dev Bitmask representing all the possible permissions (super admin role)\r\n  uint256 private constant FULL_PRIVILEGES_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /// @dev A bitmask of globally enabled features\r\n  uint256 public features;\r\n\r\n  /// @notice Privileged addresses with defined roles/permissions\r\n  /// @notice In the context of ERC20/ERC721 tokens these can be permissions to\r\n  ///      allow minting tokens, transferring on behalf and so on\r\n  /// @dev Maps an address to the permissions bitmask (role), where each bit\r\n  ///      represents a permission\r\n  /// @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n  ///      represents all possible permissions\r\n  mapping(address => uint256) public userRoles;\r\n\r\n  /// @dev Fired in updateFeatures()\r\n  event FeaturesUpdated(address indexed _by, uint256 _requested, uint256 _actual);\r\n\r\n  /// @dev Fired in addOperator(), removeOperator(), addRole(), removeRole()\r\n  event RoleUpdated(address indexed _by, address indexed _to, uint256 _role);\r\n\r\n  /**\r\n   * @dev Creates an access controlled instance\r\n   */\r\n  constructor() public {\r\n    // contract creator has full privileges\r\n    userRoles[msg.sender] = FULL_PRIVILEGES_MASK;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates set of the globally enabled features (`f`),\r\n   *      taking into account sender's permissions.\r\n   * @dev Requires sender to have `ROLE_FEATURE_MANAGER` permission.\r\n   * @param mask bitmask representing a set of features to enable/disable\r\n   */\r\n  function updateFeatures(uint256 mask) public {\r\n    // call sender nicely - caller\r\n    address caller = msg.sender;\r\n    // read caller's permissions\r\n    uint256 p = userRoles[caller];\r\n\r\n    // caller should have a permission to update global features\r\n    require(__hasRole(p, ROLE_FEATURE_MANAGER));\r\n\r\n    // taking into account caller's permissions,\r\n    // 1) enable features requested\r\n    features |= p & mask;\r\n    // 2) disable features requested\r\n    features &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ mask));\r\n\r\n    // fire an event\r\n    emit FeaturesUpdated(caller, mask, features);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a new `operator` - an address which has\r\n   *      some extended privileges over the smart contract,\r\n   *      for example token minting, transferring on behalf, etc.\r\n   * @dev Newly added `operator` cannot have any permissions which\r\n   *      transaction sender doesn't have.\r\n   * @dev Requires transaction sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @dev Cannot update existing operator. Throws if `operator` already exists.\r\n   * @param operator address of the operator to add\r\n   * @param role bitmask representing a set of permissions which\r\n   *      newly created operator will have\r\n   */\r\n  function addOperator(address operator, uint256 role) public {\r\n    // call sender gracefully - `manager`\r\n    address manager = msg.sender;\r\n\r\n    // read manager's permissions (role)\r\n    uint256 permissions = userRoles[manager];\r\n\r\n    // check that `operator` doesn't exist\r\n    require(userRoles[operator] == 0);\r\n\r\n    // manager must have a ROLE_ROLE_MANAGER role\r\n    require(__hasRole(permissions, ROLE_ROLE_MANAGER));\r\n\r\n    // recalculate permissions (role) to set:\r\n    // we cannot create an operator more powerful then calling `manager`\r\n    uint256 r = role & permissions;\r\n\r\n    // check if we still have some permissions (role) to set\r\n    require(r != 0);\r\n\r\n    // create an operator by persisting his permissions (roles) to storage\r\n    userRoles[operator] = r;\r\n\r\n    // fire an event\r\n    emit RoleUpdated(manager, operator, userRoles[operator]);\r\n  }\r\n\r\n  /**\r\n   * @dev Deletes an existing `operator`.\r\n   * @dev Requires sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @param operator address of the operator to delete\r\n   */\r\n  function removeOperator(address operator) public {\r\n    // call sender gracefully - `manager`\r\n    address manager = msg.sender;\r\n\r\n    // check if an `operator` exists\r\n    require(userRoles[operator] != 0);\r\n\r\n    // do not allow transaction sender to remove himself\r\n    // protects from an accidental removal of all the operators\r\n    require(operator != manager);\r\n\r\n    // manager must have a ROLE_ROLE_MANAGER role\r\n    // and he must have all the permissions operator has\r\n    require(__hasRole(userRoles[manager], ROLE_ROLE_MANAGER | userRoles[operator]));\r\n\r\n    // perform operator deletion\r\n    delete userRoles[operator];\r\n\r\n    // fire an event\r\n    emit RoleUpdated(manager, operator, 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates an existing `operator`, adding a specified role to it.\r\n   * @dev Note that `operator` cannot receive permission which\r\n   *      transaction sender doesn't have.\r\n   * @dev Requires transaction sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @dev Cannot create a new operator. Throws if `operator` doesn't exist.\r\n   * @dev Existing permissions of the `operator` are preserved\r\n   * @param operator address of the operator to update\r\n   * @param role bitmask representing a set of permissions which\r\n   *      `operator` will have\r\n   */\r\n  function addRole(address operator, uint256 role) public {\r\n    // call sender gracefully - `manager`\r\n    address manager = msg.sender;\r\n\r\n    // read manager's permissions (role)\r\n    uint256 permissions = userRoles[manager];\r\n\r\n    // check that `operator` exists\r\n    require(userRoles[operator] != 0);\r\n\r\n    // manager must have a ROLE_ROLE_MANAGER role\r\n    require(__hasRole(permissions, ROLE_ROLE_MANAGER));\r\n\r\n    // recalculate permissions (role) to add:\r\n    // we cannot make an operator more powerful then calling `manager`\r\n    uint256 r = role & permissions;\r\n\r\n    // check if we still have some permissions (role) to add\r\n    require(r != 0);\r\n\r\n    // update operator's permissions (roles) in the storage\r\n    userRoles[operator] |= r;\r\n\r\n    // fire an event\r\n    emit RoleUpdated(manager, operator, userRoles[operator]);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates an existing `operator`, removing a specified role from it.\r\n   * @dev Note that  permissions which transaction sender doesn't have\r\n   *      cannot be removed.\r\n   * @dev Requires transaction sender to have `ROLE_ROLE_MANAGER` permission.\r\n   * @dev Cannot remove all permissions. Throws on such an attempt.\r\n   * @param operator address of the operator to update\r\n   * @param role bitmask representing a set of permissions which\r\n   *      will be removed from the `operator`\r\n   */\r\n  function removeRole(address operator, uint256 role) public {\r\n    // call sender gracefully - `manager`\r\n    address manager = msg.sender;\r\n\r\n    // read manager's permissions (role)\r\n    uint256 permissions = userRoles[manager];\r\n\r\n    // check that we're not removing all the `operator`s permissions\r\n    // this is not really required and just causes inconveniences is function use\r\n    //require(userRoles[operator] ^ role != 0);\r\n\r\n    // manager must have a ROLE_ROLE_MANAGER role\r\n    require(__hasRole(permissions, ROLE_ROLE_MANAGER));\r\n\r\n    // recalculate permissions (role) to remove:\r\n    // we cannot revoke permissions which calling `manager` doesn't have\r\n    uint256 r = role & permissions;\r\n\r\n    // check if we still have some permissions (role) to revoke\r\n    require(r != 0);\r\n\r\n    // update operator's permissions (roles) in the storage\r\n    userRoles[operator] &= FULL_PRIVILEGES_MASK ^ r;\r\n\r\n    // fire an event\r\n    emit RoleUpdated(manager, operator, userRoles[operator]);\r\n  }\r\n\r\n  /// @dev Checks if requested feature is enabled globally on the contract\r\n  function __isFeatureEnabled(uint256 featureRequired) internal constant returns(bool) {\r\n    // delegate call to `__hasRole`\r\n    return __hasRole(features, featureRequired);\r\n  }\r\n\r\n  /// @dev Checks if transaction sender `msg.sender` has all the required permissions `roleRequired`\r\n  function __isSenderInRole(uint256 roleRequired) internal constant returns(bool) {\r\n    // read sender's permissions (role)\r\n    uint256 userRole = userRoles[msg.sender];\r\n\r\n    // delegate call to `__hasRole`\r\n    return __hasRole(userRole, roleRequired);\r\n  }\r\n\r\n  /// @dev Checks if user role `userRole` contain all the permissions required `roleRequired`\r\n  function __hasRole(uint256 userRole, uint256 roleRequired) internal pure returns(bool) {\r\n    // check the bitmask for the role required and return the result\r\n    return userRole & roleRequired == roleRequired;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safe transfers\r\n *      from ERC721 asset contracts.\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ninterface ERC721Receiver {\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient after a `transfer`.\r\n   *      This function MAY throw to revert and reject the transfer.\r\n   *      Return of other than the magic value MUST result in the transaction being reverted.\r\n   * @notice The contract address is always the message sender.\r\n   *      A wallet/broker/auction application MUST implement the wallet interface\r\n   *      if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function\r\n   * @param _from The address which previously owned the token\r\n   * @param _tokenId The NFT identifier which is being transferred\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing\r\n   */\r\n  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ncontract ERC165 {\r\n  /**\r\n   * 0x01ffc9a7 == bytes4(keccak256('supportsInterface(bytes4)'))\r\n   */\r\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n\r\n  /**\r\n   * @dev a mapping of interface id to whether or not it's supported\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev A contract implementing SupportsInterfaceWithLookup\r\n   * implement ERC165 itself\r\n   */\r\n  constructor() public {\r\n    // register itself in a lookup table\r\n    _registerInterface(InterfaceId_ERC165);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165.\r\n   * @dev This function uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId) public constant returns (bool) {\r\n    // find if interface is supported using a lookup table\r\n    return supportedInterfaces[_interfaceId];\r\n  }\r\n\r\n  /**\r\n   * @dev private method for registering an interface\r\n   */\r\n  function _registerInterface(bytes4 _interfaceId) internal {\r\n    require(_interfaceId != 0xffffffff);\r\n    supportedInterfaces[_interfaceId] = true;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @notice Gem is unique tradable entity. Non-fungible.\r\n * @dev A gem is an ERC721 non-fungible token, which maps Token ID,\r\n *      a 32 bit number to a set of gem properties -\r\n *      attributes (mostly immutable by their nature) and state variables (mutable)\r\n * @dev A gem token supports only minting, it can be only created\r\n */\r\ncontract GemERC721 is AccessControl, ERC165 {\r\n  /// @dev Smart contract version\r\n  /// @dev Should be incremented manually in this source code\r\n  ///      each time smart contact source code is changed\r\n  uint32 public constant TOKEN_VERSION = 0x3;\r\n\r\n  /// @dev ERC20 compliant token symbol\r\n  string public constant symbol = \"GEM\";\r\n  /// @dev ERC20 compliant token name\r\n  string public constant name = \"GEM â€“ CryptoMiner World\";\r\n  /// @dev ERC20 compliant token decimals\r\n  /// @dev this can be only zero, since ERC721 token is non-fungible\r\n  uint8 public constant decimals = 0;\r\n\r\n  /// @dev A gem data structure\r\n  /// @dev Occupies 64 bytes of storage (512 bits)\r\n  struct Gem {\r\n    /// High 256 bits\r\n    /// @dev Where gem was found: land plot ID,\r\n    ///      land block within a plot,\r\n    ///      gem number (id) within a block of land, immutable\r\n    uint64 coordinates;\r\n\r\n    /// @dev Gem color, one of 12 values, immutable\r\n    uint8 color;\r\n\r\n    /// @dev Level modified time\r\n    /// @dev Stored as Ethereum Block Number of the transaction\r\n    ///      when the gem was created\r\n    uint32 levelModified;\r\n\r\n    /// @dev Level value (mutable), one of 1, 2, 3, 4, 5\r\n    uint8 level;\r\n\r\n    /// @dev Grade modified time\r\n    /// @dev Stored as Ethereum Block Number of the transaction\r\n    ///      when the gem was created\r\n    uint32 gradeModified;\r\n\r\n    /// @dev High 8 bits store grade type and low 24 bits grade value\r\n    /// @dev Grade type is one of D (1), C (2), B (3), A (4), AA (5) and AAA (6)\r\n    uint32 grade;\r\n\r\n    /// @dev Store state modified time\r\n    /// @dev Stored as Ethereum Block Number of the transaction\r\n    ///      when the gem was created\r\n    uint32 stateModified;\r\n\r\n    /// @dev State value, mutable\r\n    uint48 state;\r\n\r\n\r\n    /// Low 256 bits\r\n    /// @dev Gem creation time, immutable, cannot be zero\r\n    /// @dev Stored as Ethereum Block Number of the transaction\r\n    ///      when the gem was created\r\n    uint32 creationTime;\r\n\r\n    /// @dev Gem index within an owner's collection of gems, mutable\r\n    uint32 index;\r\n\r\n    /// @dev Initially zero, changes when ownership is transferred\r\n    /// @dev Stored as Ethereum Block Number of the transaction\r\n    ///      when the gem's ownership was changed, mutable\r\n    uint32 ownershipModified;\r\n\r\n    /// @dev Gem's owner, initialized upon gem creation, mutable\r\n    address owner;\r\n  }\r\n\r\n  /// @notice All the emitted gems\r\n  /// @dev Core of the Gem as ERC721 token\r\n  /// @dev Maps Gem ID => Gem Data Structure\r\n  mapping(uint256 => Gem) public gems;\r\n\r\n  /// @dev Mapping from a gem ID to an address approved to\r\n  ///      transfer ownership rights for this gem\r\n  mapping(uint256 => address) public approvals;\r\n\r\n  /// @dev Mapping from owner to operator approvals\r\n  ///      token owner => approved token operator => is approved\r\n  mapping(address => mapping(address => bool)) public approvedOperators;\r\n\r\n  /// @notice Storage for a collections of tokens\r\n  /// @notice A collection of tokens is an ordered list of token IDs,\r\n  ///      owned by a particular address (owner)\r\n  /// @dev A mapping from owner to a collection of his tokens (IDs)\r\n  /// @dev ERC20 compliant structure for balances can be derived\r\n  ///      as a length of each collection in the mapping\r\n  /// @dev ERC20 balances[owner] is equal to collections[owner].length\r\n  mapping(address => uint32[]) public collections;\r\n\r\n  /// @dev Array with all token ids, used for enumeration\r\n  /// @dev ERC20 compliant structure for totalSupply can be derived\r\n  ///      as a length of this collection\r\n  /// @dev ERC20 totalSupply() is equal to allTokens.length\r\n  uint32[] public allTokens;\r\n\r\n  /// @dev The data in token's state may contain lock(s)\r\n  ///      (ex.: is gem currently mining or not)\r\n  /// @dev A locked token cannot be transferred or upgraded\r\n  /// @dev The token is locked if it contains any bits\r\n  ///      from the `lockedBitmask` in its `state` set\r\n  uint64 public lockedBitmask = DEFAULT_MINING_BIT;\r\n\r\n  /// @dev Enables ERC721 transfers of the tokens\r\n  uint32 public constant FEATURE_TRANSFERS = 0x00000001;\r\n\r\n  /// @dev Enables ERC721 transfers on behalf\r\n  uint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x00000002;\r\n\r\n  /// @dev Enables partial support of ERC20 transfers of the tokens,\r\n  ///      allowing to transfer only all owned tokens at once\r\n  //uint32 public constant ERC20_TRANSFERS = 0x00000004;\r\n\r\n  /// @dev Enables partial support of ERC20 transfers on behalf\r\n  ///      allowing to transfer only all owned tokens at once\r\n  //uint32 public constant ERC20_TRANSFERS_ON_BEHALF = 0x00000008;\r\n\r\n  /// @dev Enables full support of ERC20 transfers of the tokens,\r\n  ///      allowing to transfer arbitrary amount of the tokens at once\r\n  //uint32 public constant ERC20_INSECURE_TRANSFERS = 0x00000010;\r\n\r\n  /// @dev Default bitmask indicating that the gem is `mining`\r\n  /// @dev Consists of a single bit at position 1 â€“ binary 1\r\n  /// @dev This bit is cleared by `miningComplete`\r\n  /// @dev The bit meaning in gem's `state` is as follows:\r\n  ///      0: not mining\r\n  ///      1: mining\r\n  uint64 public constant DEFAULT_MINING_BIT = 0x1; // bit number 1\r\n\r\n  /// @notice Exchange is responsible for trading tokens on behalf of token holders\r\n  /// @dev Role ROLE_EXCHANGE allows executing transfer on behalf of token holders\r\n  /// @dev Not used\r\n  //uint32 public constant ROLE_EXCHANGE = 0x00010000;\r\n\r\n  /// @notice Level provider is responsible for enabling the workshop\r\n  /// @dev Role ROLE_LEVEL_PROVIDER allows leveling up the gem\r\n  uint32 public constant ROLE_LEVEL_PROVIDER = 0x00100000;\r\n\r\n  /// @notice Grade provider is responsible for enabling the workshop\r\n  /// @dev Role ROLE_GRADE_PROVIDER allows modifying gem's grade\r\n  uint32 public constant ROLE_GRADE_PROVIDER = 0x00200000;\r\n\r\n  /// @notice Token state provider is responsible for enabling the mining protocol\r\n  /// @dev Role ROLE_STATE_PROVIDER allows modifying token's state\r\n  uint32 public constant ROLE_STATE_PROVIDER = 0x00400000;\r\n\r\n  /// @notice Token state provider is responsible for enabling the mining protocol\r\n  /// @dev Role ROLE_STATE_LOCK_PROVIDER allows modifying token's locked bitmask\r\n  uint32 public constant ROLE_STATE_LOCK_PROVIDER = 0x00800000;\r\n\r\n  /// @notice Token creator is responsible for creating tokens\r\n  /// @dev Role ROLE_TOKEN_CREATOR allows minting tokens\r\n  uint32 public constant ROLE_TOKEN_CREATOR = 0x00040000;\r\n\r\n  /// @notice Token destroyer is responsible for destroying tokens\r\n  /// @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\r\n  //uint32 public constant ROLE_TOKEN_DESTROYER = 0x00080000;\r\n\r\n  /// @dev Magic value to be returned upon successful reception of an NFT\r\n  /// @dev Equal to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n  ///      which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * Supported interfaces section\r\n   */\r\n\r\n  /**\r\n   * ERC721 interface definition in terms of ERC165\r\n   *\r\n   * 0x80ac58cd ==\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\r\n\r\n  /**\r\n   * ERC721 interface extension â€“ exists(uint256)\r\n   *\r\n   * 0x4f558e79 == bytes4(keccak256('exists(uint256)'))\r\n   */\r\n  bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n\r\n  /**\r\n   * ERC721 interface extension - ERC721Enumerable\r\n   *\r\n   * 0x780e9d63 ==\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n\r\n  /**\r\n   * ERC721 interface extension - ERC721Metadata\r\n   *\r\n   * 0x5b5e139f ==\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n\r\n  /// @dev Event names are self-explanatory:\r\n  /// @dev Fired in mint()\r\n  /// @dev Address `_by` allows to track who created a token\r\n  event Minted(address indexed _by, address indexed _to, uint32 indexed _tokenId);\r\n\r\n  /// @dev Fired in burn()\r\n  /// @dev Address `_by` allows to track who destroyed a token\r\n  //event Burnt(address indexed _from, address _by, uint32 indexed _tokenId);\r\n\r\n  /// @dev Fired in transfer(), transferFor(), mint()\r\n  /// @dev When minting a token, address `_from` is zero\r\n  /// @dev ERC20/ERC721 compliant event\r\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId, uint256 _value);\r\n\r\n  /// @dev Fired in approve()\r\n  /// @dev ERC721 compliant event\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n  /// @dev Fired in setApprovalForAll()\r\n  /// @dev ERC721 compliant event\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _value);\r\n\r\n  /// @dev Fired in levelUp()\r\n  event LevelUp(address indexed _by, address indexed _owner, uint256 indexed _tokenId, uint8 _levelReached);\r\n\r\n  /// @dev Fired in upgradeGrade()\r\n  event UpgradeComplete(address indexed _by, address indexed _owner, uint256 indexed _tokenId, uint32 _gradeFrom, uint32 _gradeTo);\r\n\r\n  /// @dev Fired in setState()\r\n  event StateModified(address indexed _by, address indexed _owner, uint256 indexed _tokenId, uint48 _stateFrom, uint48 _stateTo);\r\n\r\n  /// @dev Creates a Gem ERC721 instance,\r\n  /// @dev Registers a ERC721 interface using ERC165\r\n  constructor() public {\r\n    // register the supported interfaces to conform to ERC721 via ERC165\r\n    _registerInterface(InterfaceId_ERC721);\r\n    _registerInterface(InterfaceId_ERC721Exists);\r\n    _registerInterface(InterfaceId_ERC721Enumerable);\r\n    _registerInterface(InterfaceId_ERC721Metadata);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets a gem by ID, representing it as two integers.\r\n   *      The two integers are tightly packed with a gem data:\r\n   *      First integer (high bits) contains (from higher to lower bits order):\r\n   *          coordinates:\r\n   *            plotId,\r\n   *            depth (block ID),\r\n   *            gemNum (gem ID within a block)\r\n   *          color,\r\n   *          levelModified,\r\n   *          level,\r\n   *          gradeModified,\r\n   *          grade,\r\n   *          stateModified,\r\n   *          state,\r\n   *      Second integer (low bits) contains (from higher to lower bits order):\r\n   *          creationTime,\r\n   *          index,\r\n   *          ownershipModified,\r\n   *          owner\r\n   * @dev Throws if gem doesn't exist\r\n   * @param _tokenId ID of the gem to fetch\r\n   */\r\n  function getPacked(uint256 _tokenId) public constant returns(uint256, uint256) {\r\n    // validate gem existence\r\n    require(exists(_tokenId));\r\n\r\n    // load the gem from storage\r\n    Gem memory gem = gems[_tokenId];\r\n\r\n    // pack high 256 bits of the result\r\n    uint256 high = uint256(gem.coordinates) << 192\r\n                 | uint192(gem.color) << 184\r\n                 | uint184(gem.levelModified) << 152\r\n                 | uint152(gem.level) << 144\r\n                 | uint144(gem.gradeModified) << 112\r\n                 | uint112(gem.grade) << 80\r\n                 | uint80(gem.stateModified) << 48\r\n                 | uint48(gem.state);\r\n\r\n    // pack low 256 bits of the result\r\n    uint256 low  = uint256(gem.creationTime) << 224\r\n                 | uint224(gem.index) << 192\r\n                 | uint192(gem.ownershipModified) << 160\r\n                 | uint160(gem.owner);\r\n\r\n    // return the whole 512 bits of result\r\n    return (high, low);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows to fetch collection of tokens, including internal token data\r\n   *       in a single function, useful when connecting to external node like INFURA\r\n   * @param owner an address to query a collection for\r\n   */\r\n  function getPackedCollection(address owner) public constant returns (uint80[]) {\r\n    // get an array of Gem IDs owned by an `owner` address\r\n    uint32[] memory tokenIds = getCollection(owner);\r\n\r\n    // how many gems are there in a collection\r\n    uint32 balance = uint32(tokenIds.length);\r\n\r\n    // data container to store the result\r\n    uint80[] memory result = new uint80[](balance);\r\n\r\n    // fetch token info one by one and pack into structure\r\n    for(uint32 i = 0; i < balance; i++) {\r\n      // token ID to work with\r\n      uint32 tokenId = tokenIds[i];\r\n      // get the token properties and pack them together with tokenId\r\n      uint48 properties = getProperties(tokenId);\r\n\r\n      // pack the data\r\n      result[i] = uint80(tokenId) << 48 | properties;\r\n    }\r\n\r\n    // return the packed data structure\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves a collection of tokens owned by a particular address\r\n   * @notice An order of token IDs is not guaranteed and may change\r\n   *      when a token from the list is transferred\r\n   * @param owner an address to query a collection for\r\n   * @return an ordered list of tokens\r\n   */\r\n  function getCollection(address owner) public constant returns(uint32[]) {\r\n    // read a collection from mapping and return\r\n    return collections[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Allows setting the `lockedBitmask` parameter of the contract,\r\n   *      which is used to determine if a particular token is locked or not\r\n   * @dev A locked token cannot be transferred, upgraded or burnt\r\n   * @dev The token is locked if it contains any bits\r\n   *      from the `lockedBitmask` in its `state` set\r\n   * @dev Requires sender to have `ROLE_STATE_PROVIDER` permission.\r\n   * @param bitmask a value to set `lockedBitmask` to\r\n   */\r\n  function setLockedBitmask(uint64 bitmask) public {\r\n    // check that the call is made by a state lock provider\r\n    require(__isSenderInRole(ROLE_STATE_LOCK_PROVIDER));\r\n\r\n    // update the locked bitmask\r\n    lockedBitmask = bitmask;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the coordinates of a token\r\n   * @param _tokenId ID of the token to get coordinates for\r\n   * @return a token coordinates\r\n   */\r\n  function getCoordinates(uint256 _tokenId) public constant returns(uint64) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's coordinates from storage and return\r\n    return gems[_tokenId].coordinates;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the land plot ID of a gem\r\n   * @param _tokenId ID of the gem to get land plot ID value for\r\n   * @return a token land plot ID\r\n   */\r\n  function getPlotId(uint256 _tokenId) public constant returns(uint32) {\r\n    // extract high 32 bits of the coordinates and return\r\n    return uint32(getCoordinates(_tokenId) >> 32);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the depth (block ID) within plot of land of a gem\r\n   * @param _tokenId ID of the gem to get depth value for\r\n   * @return a token depth\r\n   */\r\n  function getDepth(uint256 _tokenId) public constant returns(uint16) {\r\n    // extract middle 16 bits of the coordinates and return\r\n    return uint16(getCoordinates(_tokenId) >> 16);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the gem's number within land block\r\n   * @param _tokenId ID of the gem to get depth value for\r\n   * @return a gem number within a land block\r\n   */\r\n  function getGemNum(uint256 _tokenId) public constant returns(uint16) {\r\n    // extract low 16 bits of the coordinates and return\r\n    return uint16(getCoordinates(_tokenId));\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the gem's properties â€“ color, level and\r\n   *      grade - as packed uint32 number\r\n   * @param _tokenId ID of the gem to get properties for\r\n   * @return gem's properties - color, level, grade as packed uint32\r\n   */\r\n  function getProperties(uint256 _tokenId) public constant returns(uint48) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // read gem from storage\r\n    Gem memory gem = gems[_tokenId];\r\n\r\n    // pack data structure and return\r\n    return uint48(gem.color) << 40 | uint40(gem.level) << 32 | gem.grade;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the color of a token\r\n   * @param _tokenId ID of the token to get color for\r\n   * @return a token color\r\n   */\r\n  function getColor(uint256 _tokenId) public constant returns(uint8) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's color from storage and return\r\n    return gems[_tokenId].color;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the level modified date of a token\r\n   * @param _tokenId ID of the token to get level modification date for\r\n   * @return a token level modification date\r\n   */\r\n  function getLevelModified(uint256 _tokenId) public constant returns(uint32) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's level modified date from storage and return\r\n    return gems[_tokenId].levelModified;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the level of a token\r\n   * @param _tokenId ID of the token to get level for\r\n   * @return a token level\r\n   */\r\n  function getLevel(uint256 _tokenId) public constant returns(uint8) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's level from storage and return\r\n    return gems[_tokenId].level;\r\n  }\r\n\r\n  /**\r\n   * @dev Levels up a gem\r\n   * @dev Requires sender to have `ROLE_STATE_PROVIDER` permission\r\n   * @param _tokenId ID of the gem to level up\r\n   */\r\n  function levelUp(uint256 _tokenId) public {\r\n    // check that the call is made by a level provider\r\n    require(__isSenderInRole(ROLE_LEVEL_PROVIDER));\r\n\r\n    // check that token to set state for exists\r\n    require(exists(_tokenId));\r\n\r\n    // update the level modified date\r\n    gems[_tokenId].levelModified = uint32(block.number);\r\n\r\n    // increment the level required\r\n    gems[_tokenId].level++;\r\n\r\n    // emit an event\r\n    emit LevelUp(msg.sender, ownerOf(_tokenId), _tokenId, gems[_tokenId].level);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the grade modified date of a gem\r\n   * @param _tokenId ID of the gem to get grade modified date for\r\n   * @return a token grade modified date\r\n   */\r\n  function getGradeModified(uint256 _tokenId) public constant returns(uint32) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's grade modified date from storage and return\r\n    return gems[_tokenId].gradeModified;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the grade of a gem\r\n   * @param _tokenId ID of the gem to get grade for\r\n   * @return a token grade\r\n   */\r\n  function getGrade(uint256 _tokenId) public constant returns(uint32) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's grade from storage and return\r\n    return gems[_tokenId].grade;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the grade type of a gem\r\n   * @param _tokenId ID of the gem to get grade type for\r\n   * @return a token grade type\r\n   */\r\n  function getGradeType(uint256 _tokenId) public constant returns(uint8) {\r\n    // extract high 8 bits of the grade and return\r\n    return uint8(getGrade(_tokenId) >> 24);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the grade value of a gem\r\n   * @param _tokenId ID of the gem to get grade value for\r\n   * @return a token grade value\r\n   */\r\n  function getGradeValue(uint256 _tokenId) public constant returns(uint24) {\r\n    // extract low 24 bits of the grade and return\r\n    return uint24(getGrade(_tokenId));\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the grade of the gem\r\n   * @dev Requires new grade to be higher than an old one\r\n   * @dev Requires sender to have `ROLE_GRADE_PROVIDER` permission\r\n   * @param _tokenId ID of the gem to modify the grade for\r\n   * @param grade new grade to set for the token, should be higher then current state\r\n   */\r\n  function upgradeGrade(uint256 _tokenId, uint32 grade) public {\r\n    // check that the call is made by a grade provider\r\n    require(__isSenderInRole(ROLE_GRADE_PROVIDER));\r\n\r\n    // check that token to set grade for exists\r\n    require(exists(_tokenId));\r\n\r\n    // check if we're not downgrading the gem\r\n    require(gems[_tokenId].grade < grade);\r\n\r\n    // emit an event\r\n    emit UpgradeComplete(msg.sender, ownerOf(_tokenId), _tokenId, gems[_tokenId].grade, grade);\r\n\r\n    // set the grade required\r\n    gems[_tokenId].grade = grade;\r\n\r\n    // update the grade modified date\r\n    gems[_tokenId].gradeModified = uint32(block.number);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the state modified date of a token\r\n   * @param _tokenId ID of the token to get state modified date for\r\n   * @return a token state modification date\r\n   */\r\n  function getStateModified(uint256 _tokenId) public constant returns(uint32) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's state modified date from storage and return\r\n    return gems[_tokenId].stateModified;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the state of a token\r\n   * @param _tokenId ID of the token to get state for\r\n   * @return a token state\r\n   */\r\n  function getState(uint256 _tokenId) public constant returns(uint48) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's state from storage and return\r\n    return gems[_tokenId].state;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the state of a token\r\n   * @dev Requires sender to have `ROLE_STATE_PROVIDER` permission\r\n   * @param _tokenId ID of the token to set state for\r\n   * @param state new state to set for the token\r\n   */\r\n  function setState(uint256 _tokenId, uint48 state) public {\r\n    // check that the call is made by a state provider\r\n    require(__isSenderInRole(ROLE_STATE_PROVIDER));\r\n\r\n    // check that token to set state for exists\r\n    require(exists(_tokenId));\r\n\r\n    // emit an event\r\n    emit StateModified(msg.sender, ownerOf(_tokenId), _tokenId, gems[_tokenId].state, state);\r\n\r\n    // set the state required\r\n    gems[_tokenId].state = state;\r\n\r\n    // update the state modified date\r\n    gems[_tokenId].stateModified = uint32(block.number);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the creation time of a token\r\n   * @param _tokenId ID of the token to get creation time for\r\n   * @return a token creation time\r\n   */\r\n  function getCreationTime(uint256 _tokenId) public constant returns(uint32) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's creation time from storage and return\r\n    return gems[_tokenId].creationTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the ownership modified time of a token\r\n   * @param _tokenId ID of the token to get ownership modified time for\r\n   * @return a token ownership modified time\r\n   */\r\n  function getOwnershipModified(uint256 _tokenId) public constant returns(uint32) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // obtain token's ownership modified time from storage and return\r\n    return gems[_tokenId].ownershipModified;\r\n  }\r\n\r\n  /**\r\n   * @notice Total number of existing tokens (tracked by this contract)\r\n   * @return A count of valid tokens tracked by this contract,\r\n   *    where each one of them has an assigned and\r\n   *    queryable owner not equal to the zero address\r\n   */\r\n  function totalSupply() public constant returns (uint256) {\r\n    // read the length of the `allTokens` collection\r\n    return allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @notice Enumerate valid tokens\r\n   * @dev Throws if `_index` >= `totalSupply()`.\r\n   * @param _index a counter less than `totalSupply()`\r\n   * @return The token ID for the `_index`th token, unsorted\r\n   */\r\n  function tokenByIndex(uint256 _index) public constant returns (uint256) {\r\n    // out of bounds check\r\n    require(_index < allTokens.length);\r\n\r\n    // get the token ID and return\r\n    return allTokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @notice Enumerate tokens assigned to an owner\r\n   * @dev Throws if `_index` >= `balanceOf(_owner)`.\r\n   * @param _owner an address of the owner to query token from\r\n   * @param _index a counter less than `balanceOf(_owner)`\r\n   * @return the token ID for the `_index`th token assigned to `_owner`, unsorted\r\n   */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public constant returns (uint256) {\r\n    // out of bounds check\r\n    require(_index < collections[_owner].length);\r\n\r\n    // get the token ID from owner collection and return\r\n    return collections[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @notice Gets an amount of token owned by the given address\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner address to query the balance for\r\n   * @return an amount owned by the address passed as an input parameter\r\n   */\r\n  function balanceOf(address _owner) public constant returns (uint256) {\r\n    // read the length of the `who`s collection of tokens\r\n    return collections[_owner].length;\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if specified token exists\r\n   * @dev Returns whether the specified token ID exists\r\n   * @param _tokenId ID of the token to query the existence for\r\n   * @return whether the token exists (true - exists)\r\n   */\r\n  function exists(uint256 _tokenId) public constant returns (bool) {\r\n    // check if this token exists (owner is not zero)\r\n    return gems[_tokenId].owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @notice Finds an owner address for a token specified\r\n   * @dev Gets the owner of the specified token from the `gems` mapping\r\n   * @dev Throws if a token with the ID specified doesn't exist\r\n   * @param _tokenId ID of the token to query the owner for\r\n   * @return owner address currently marked as the owner of the given token\r\n   */\r\n  function ownerOf(uint256 _tokenId) public constant returns (address) {\r\n    // check if this token exists\r\n    require(exists(_tokenId));\r\n\r\n    // return owner's address\r\n    return gems[_tokenId].owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates new token with `tokenId` ID specified and\r\n   *      assigns an ownership `to` for that token\r\n   * @dev Allows setting initial token's properties\r\n   * @param to an address to assign created token ownership to\r\n   * @param tokenId ID of the token to create\r\n   */\r\n  function mint(\r\n    address to,\r\n    uint32 tokenId,\r\n    uint32 plotId,\r\n    uint16 depth,\r\n    uint16 gemNum,\r\n    uint8 color,\r\n    uint8 level,\r\n    uint8 gradeType,\r\n    uint24 gradeValue\r\n  ) public {\r\n    // validate destination address\r\n    require(to != address(0));\r\n    require(to != address(this));\r\n\r\n    // check if caller has sufficient permissions to mint a token\r\n    // and if feature is enabled globally\r\n    require(__isSenderInRole(ROLE_TOKEN_CREATOR));\r\n\r\n    // delegate call to `__mint`\r\n    __mint(to, tokenId, plotId, depth, gemNum, color, level, gradeType, gradeValue);\r\n\r\n    // fire ERC20 transfer event\r\n    emit Transfer(address(0), to, tokenId, 1);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers ownership rights of a token defined\r\n   *      by the `tokenId` to a new owner specified by address `to`\r\n   * @dev Requires the sender of the transaction to be an owner\r\n   *      of the token specified (`tokenId`)\r\n   * @param to new owner address\r\n   * @param _tokenId ID of the token to transfer ownership rights for\r\n   */\r\n  function transfer(address to, uint256 _tokenId) public {\r\n    // check if token transfers feature is enabled\r\n    require(__isFeatureEnabled(FEATURE_TRANSFERS));\r\n\r\n    // call sender gracefully - `from`\r\n    address from = msg.sender;\r\n\r\n    // delegate call to unsafe `__transfer`\r\n    __transfer(from, to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice A.k.a \"transfer a token on behalf\"\r\n   * @notice Transfers ownership rights of a token defined\r\n   *      by the `tokenId` to a new owner specified by address `to`\r\n   * @notice Allows transferring ownership rights by a trading operator\r\n   *      on behalf of token owner. Allows building an exchange of tokens.\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * @dev Requires the transaction sender to be one of:\r\n   *      owner of a gem - then its just a usual `transfer`\r\n   *      approved â€“ an address explicitly approved earlier by\r\n   *        the owner of a token to transfer this particular token `tokenId`\r\n   *      operator - an address explicitly approved earlier by\r\n   *        the owner to transfer all his tokens on behalf\r\n   * @param from current owner of the token\r\n   * @param to address to receive the ownership of the token\r\n   * @param _tokenId ID of the token to be transferred\r\n   */\r\n  function transferFrom(address from, address to, uint256 _tokenId) public {\r\n    // check if transfers on behalf feature is enabled\r\n    require(__isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF));\r\n\r\n    // call sender gracefully - `operator`\r\n    address operator = msg.sender;\r\n\r\n    // find if an approved address exists for this token\r\n    address approved = approvals[_tokenId];\r\n\r\n    // we assume `from` is an owner of the token,\r\n    // this will be explicitly checked in `__transfer`\r\n\r\n    // fetch how much approvals left for an operator\r\n    bool approvedOperator = approvedOperators[from][operator];\r\n\r\n    // operator must have an approval to transfer this particular token\r\n    // or operator must be approved to transfer all the tokens\r\n    // or, if nothing satisfies, this is equal to regular transfer,\r\n    // where `from` is basically a transaction sender and owner of the token\r\n    if(operator != approved && !approvedOperator) {\r\n      // transaction sender doesn't have any special permissions\r\n      // we will treat him as a token owner and sender and try to perform\r\n      // a regular transfer:\r\n      // check `from` to be `operator` (transaction sender):\r\n      require(from == operator);\r\n\r\n      // additionally check if token transfers feature is enabled\r\n      require(__isFeatureEnabled(FEATURE_TRANSFERS));\r\n    }\r\n\r\n    // delegate call to unsafe `__transfer`\r\n    __transfer(from, to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice A.k.a \"safe transfer a token on behalf\"\r\n   * @notice Transfers ownership rights of a token defined\r\n   *      by the `tokenId` to a new owner specified by address `to`\r\n   * @notice Allows transferring ownership rights by a trading operator\r\n   *      on behalf of token owner. Allows building an exchange of tokens.\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev Requires the transaction sender to be the owner, approved, or operator\r\n   * @dev When transfer is complete, this function\r\n   *      checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n   *      `onERC721Received` on `_to` and throws if the return value is not\r\n   *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the token\r\n   * @param _tokenId ID of the token to be transferred\r\n   * @param _data Additional data with no specified format, sent in call to `_to`\r\n   */\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public {\r\n    // delegate call to usual (unsafe) `transferFrom`\r\n    transferFrom(_from, _to, _tokenId);\r\n\r\n    // check if receiver `_to` supports ERC721 interface\r\n    if (AddressUtils.isContract(_to)) {\r\n      // if `_to` is a contract â€“ execute onERC721Received\r\n      bytes4 response = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n\r\n      // expected response is ERC721_RECEIVED\r\n      require(response == ERC721_RECEIVED);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice A.k.a \"safe transfer a token on behalf\"\r\n   * @notice Transfers ownership rights of a token defined\r\n   *      by the `tokenId` to a new owner specified by address `to`\r\n   * @notice Allows transferring ownership rights by a trading operator\r\n   *      on behalf of token owner. Allows building an exchange of tokens.\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev Requires the transaction sender to be the owner, approved, or operator\r\n   * @dev Requires from to be an owner of the token\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *      which is called upon a safe transfer, and return the magic value\r\n   *      `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`;\r\n   *      otherwise the transfer is reverted.\r\n   * @dev This works identically to the other function with an extra data parameter,\r\n   *      except this function just sets data to \"\".\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the token\r\n   * @param _tokenId ID of the token to be transferred\r\n   */\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\r\n    // delegate call to overloaded `safeTransferFrom`, set data to \"\"\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @notice Approves an address to transfer the given token on behalf of its owner\r\n   *      Can also be used to revoke an approval by setting `to` address to zero\r\n   * @dev The zero `to` address revokes an approval for a given token\r\n   * @dev There can only be one approved address per token at a given time\r\n   * @dev This function can only be called by the token owner\r\n   * @param _approved address to be approved to transfer the token on behalf of its owner\r\n   * @param _tokenId ID of the token to be approved for transfer on behalf\r\n   */\r\n  function approve(address _approved, uint256 _tokenId) public {\r\n    // call sender nicely - `from`\r\n    address from = msg.sender;\r\n\r\n    // get token owner address (also ensures that token exists)\r\n    address owner = ownerOf(_tokenId);\r\n\r\n    // caller must own this token\r\n    require(from == owner);\r\n    // approval for owner himself is pointless, do not allow\r\n    require(_approved != owner);\r\n    // either we're removing approval, or setting it\r\n    require(approvals[_tokenId] != address(0) || _approved != address(0));\r\n\r\n    // set an approval (deletes an approval if to == 0)\r\n    approvals[_tokenId] = _approved;\r\n\r\n    // emit an ERC721 event\r\n    emit Approval(from, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice Removes an approved address, which was previously added by `approve`\r\n   *      for the given token. Equivalent to calling approve(0, tokenId)\r\n   * @dev Same as calling approve(0, tokenId)\r\n   * @param _tokenId ID of the token to remove approved address for\r\n   */\r\n  function revokeApproval(uint256 _tokenId) public {\r\n    // delegate call to `approve`\r\n    approve(address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * @dev An operator is allowed to transfer *all* tokens of the sender on their behalf\r\n   * @param to operator address to set the approval for\r\n   * @param approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address to, bool approved) public {\r\n    // call sender nicely - `from`\r\n    address from = msg.sender;\r\n\r\n    // validate destination address\r\n    require(to != address(0));\r\n\r\n    // approval for owner himself is pointless, do not allow\r\n    require(to != from);\r\n\r\n    // set an approval\r\n    approvedOperators[from][to] = approved;\r\n\r\n    // emit an ERC721 compliant event\r\n    emit ApprovalForAll(from, to, approved);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the approved address for a single token\r\n   * @dev Throws if `_tokenId` is not a valid token ID.\r\n   * @param _tokenId ID of the token to find the approved address for\r\n   * @return the approved address for this token, or the zero address if there is none\r\n   */\r\n  function getApproved(uint256 _tokenId) public constant returns (address) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // find approved address and return\r\n    return approvals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @notice Query if an address is an authorized operator for another address\r\n   * @param _owner the address that owns at least one token\r\n   * @param _operator the address that acts on behalf of the owner\r\n   * @return true if `_operator` is an approved operator for `_owner`, false otherwise\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public constant returns (bool) {\r\n    // is there a positive amount of approvals left\r\n    return approvedOperators[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n   * @dev Throws if `_tokenId` is not a valid token ID.\r\n   *      URIs are defined in RFC 3986.\r\n   * @param _tokenId uint256 ID of the token to query\r\n   * @return token URI\r\n   */\r\n  function tokenURI(uint256 _tokenId) public constant returns (string) {\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // token URL consists of base URL part (domain) and token ID\r\n    return StringUtils.concat(\"http://cryptominerworld.com/gem/\", StringUtils.itoa(_tokenId, 16));\r\n  }\r\n\r\n  /// @dev Creates new token with `tokenId` ID specified and\r\n  ///      assigns an ownership `to` for this token\r\n  /// @dev Unsafe: doesn't check if caller has enough permissions to execute the call\r\n  ///      checks only that the token doesn't exist yet\r\n  /// @dev Must be kept private at all times\r\n  function __mint(\r\n    address to,\r\n    uint32 tokenId,\r\n    uint32 plotId,\r\n    uint16 depth,\r\n    uint16 gemNum,\r\n    uint8 color,\r\n    uint8 level,\r\n    uint8 gradeType,\r\n    uint24 gradeValue\r\n  ) private {\r\n    // check that `tokenId` is inside valid bounds\r\n    require(tokenId > 0);\r\n\r\n    // ensure that token with such ID doesn't exist\r\n    require(!exists(tokenId));\r\n\r\n    // create new gem in memory\r\n    Gem memory gem = Gem({\r\n      coordinates: uint64(plotId) << 32 | uint32(depth) << 16 | gemNum,\r\n      color: color,\r\n      levelModified: 0,\r\n      level: level,\r\n      gradeModified: 0,\r\n      grade: uint32(gradeType) << 24 | gradeValue,\r\n      stateModified: 0,\r\n      state: 0,\r\n\r\n      creationTime: uint32(block.number),\r\n      // token index within the owner's collection of token\r\n      // points to the place where the token will be placed to\r\n      index: uint32(collections[to].length),\r\n      ownershipModified: 0,\r\n      owner: to\r\n    });\r\n\r\n    // push newly created `tokenId` to the owner's collection of tokens\r\n    collections[to].push(tokenId);\r\n\r\n    // persist gem to the storage\r\n    gems[tokenId] = gem;\r\n\r\n    // add token ID to the `allTokens` collection,\r\n    // automatically updates total supply\r\n    allTokens.push(tokenId);\r\n\r\n    // fire Minted event\r\n    emit Minted(msg.sender, to, tokenId);\r\n    // fire ERC20/ERC721 transfer event\r\n    emit Transfer(address(0), to, tokenId, 1);\r\n  }\r\n\r\n  /// @dev Performs a transfer of a token `tokenId` from address `from` to address `to`\r\n  /// @dev Unsafe: doesn't check if caller has enough permissions to execute the call;\r\n  ///      checks only for token existence and that ownership belongs to `from`\r\n  /// @dev Is save to call from `transfer(to, tokenId)` since it doesn't need any additional checks\r\n  /// @dev Must be kept private at all times\r\n  function __transfer(address from, address to, uint256 _tokenId) private {\r\n    // validate source and destination address\r\n    require(to != address(0));\r\n    require(to != from);\r\n    // impossible by design of transfer(), transferFrom(),\r\n    // approveToken() and approve()\r\n    assert(from != address(0));\r\n\r\n    // validate token existence\r\n    require(exists(_tokenId));\r\n\r\n    // validate token ownership\r\n    require(ownerOf(_tokenId) == from);\r\n\r\n    // transfer is not allowed for a locked gem\r\n    // (ex.: if ge is currently mining)\r\n    require(getState(_tokenId) & lockedBitmask == 0);\r\n\r\n    // clear approved address for this particular token + emit event\r\n    __clearApprovalFor(_tokenId);\r\n\r\n    // move gem ownership,\r\n    // update old and new owner's gem collections accordingly\r\n    __move(from, to, _tokenId);\r\n\r\n    // fire ERC20/ERC721 transfer event\r\n    emit Transfer(from, to, _tokenId, 1);\r\n  }\r\n\r\n  /// @dev Clears approved address for a particular token\r\n  function __clearApprovalFor(uint256 _tokenId) private {\r\n    // check if approval exists - we don't want to fire an event in vain\r\n    if(approvals[_tokenId] != address(0)) {\r\n      // clear approval\r\n      delete approvals[_tokenId];\r\n\r\n      // emit an ERC721 event\r\n      emit Approval(msg.sender, address(0), _tokenId);\r\n    }\r\n  }\r\n\r\n  /// @dev Move a `gem` from owner `from` to a new owner `to`\r\n  /// @dev Unsafe, doesn't check for consistence\r\n  /// @dev Must be kept private at all times\r\n  function __move(address from, address to, uint256 _tokenId) private {\r\n    // cast token ID to uint32 space\r\n    uint32 tokenId = uint32(_tokenId);\r\n\r\n    // overflow check, failure impossible by design of mint()\r\n    assert(tokenId == _tokenId);\r\n\r\n    // get the gem pointer to the storage\r\n    Gem storage gem = gems[_tokenId];\r\n\r\n    // get a reference to the collection where gem is now\r\n    uint32[] storage source = collections[from];\r\n\r\n    // get a reference to the collection where gem goes to\r\n    uint32[] storage destination = collections[to];\r\n\r\n    // collection `source` cannot be empty, if it is - it's a bug\r\n    assert(source.length != 0);\r\n\r\n    // index of the gem within collection `source`\r\n    uint32 i = gem.index;\r\n\r\n    // we put the last gem in the collection `source` to the position released\r\n    // get an ID of the last gem in `source`\r\n    uint32 sourceId = source[source.length - 1];\r\n\r\n    // update gem index to point to proper place in the collection `source`\r\n    gems[sourceId].index = i;\r\n\r\n    // put it into the position i within `source`\r\n    source[i] = sourceId;\r\n\r\n    // trim the collection `source` by removing last element\r\n    source.length--;\r\n\r\n    // update gem index according to position in new collection `destination`\r\n    gem.index = uint32(destination.length);\r\n\r\n    // update gem owner\r\n    gem.owner = to;\r\n\r\n    // update ownership transfer date\r\n    gem.ownershipModified = uint32(block.number);\r\n\r\n    // push gem into collection\r\n    destination.push(tokenId);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_GRADE_PROVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getStateModified\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCoordinates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"levelUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getGradeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_STATE_LOCK_PROVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getProperties\",\"outputs\":[{\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLevelModified\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedBitmask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"grade\",\"type\":\"uint32\"}],\"name\":\"upgradeGrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getGradeModified\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getOwnershipModified\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPlotId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getPackedCollection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint80[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collections\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getGemNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRoles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getDepth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_MINING_BIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"removeRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"addRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_STATE_PROVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_LEVEL_PROVIDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_TOKEN_CREATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint48\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEATURE_TRANSFERS_ON_BEHALF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gems\",\"outputs\":[{\"name\":\"coordinates\",\"type\":\"uint64\"},{\"name\":\"color\",\"type\":\"uint8\"},{\"name\":\"levelModified\",\"type\":\"uint32\"},{\"name\":\"level\",\"type\":\"uint8\"},{\"name\":\"gradeModified\",\"type\":\"uint32\"},{\"name\":\"grade\",\"type\":\"uint32\"},{\"name\":\"stateModified\",\"type\":\"uint32\"},{\"name\":\"state\",\"type\":\"uint48\"},{\"name\":\"creationTime\",\"type\":\"uint32\"},{\"name\":\"index\",\"type\":\"uint32\"},{\"name\":\"ownershipModified\",\"type\":\"uint32\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getGradeType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"revokeApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPacked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEATURE_TRANSFERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint32\"},{\"name\":\"plotId\",\"type\":\"uint32\"},{\"name\":\"depth\",\"type\":\"uint16\"},{\"name\":\"gemNum\",\"type\":\"uint16\"},{\"name\":\"color\",\"type\":\"uint8\"},{\"name\":\"level\",\"type\":\"uint8\"},{\"name\":\"gradeType\",\"type\":\"uint8\"},{\"name\":\"gradeValue\",\"type\":\"uint24\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getGrade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getCollection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bitmask\",\"type\":\"uint64\"}],\"name\":\"setLockedBitmask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint32\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_levelReached\",\"type\":\"uint8\"}],\"name\":\"LevelUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gradeFrom\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_gradeTo\",\"type\":\"uint32\"}],\"name\":\"UpgradeComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stateFrom\",\"type\":\"uint48\"},{\"indexed\":false,\"name\":\"_stateTo\",\"type\":\"uint48\"}],\"name\":\"StateModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"FeaturesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_role\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"}]","ContractName":"GemERC721","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5d62b1d01e04083949e46b340060931da594c1dbe8a7b65e700b8a7c12088d06"}]}