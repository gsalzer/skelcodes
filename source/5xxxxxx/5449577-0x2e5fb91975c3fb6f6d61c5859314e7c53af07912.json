{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC820Registry {\r\n    function getManager(address addr) public view returns(address);\r\n    function setManager(address addr, address newManager) public;\r\n    function getInterfaceImplementer(address addr, bytes32 iHash) public constant returns (address);\r\n    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\r\n}\r\n\r\ncontract ERC820Implementer {\r\n    ERC820Registry erc820Registry = ERC820Registry(0x991a1bcb077599290d7305493c9A630c20f8b798);\r\n\r\n    function setInterfaceImplementation(string ifaceLabel, address impl) internal {\r\n        bytes32 ifaceHash = keccak256(ifaceLabel);\r\n        erc820Registry.setInterfaceImplementer(this, ifaceHash, impl);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string ifaceLabel) internal constant returns(address) {\r\n        bytes32 ifaceHash = keccak256(ifaceLabel);\r\n        return erc820Registry.getInterfaceImplementer(addr, ifaceHash);\r\n    }\r\n\r\n    function delegateManagement(address newManager) internal {\r\n        erc820Registry.setManager(this, newManager);\r\n    }\r\n}\r\ninterface ERC777TokensSender {\r\n    function tokensToSend(address operator, address from, address to, uint amount, bytes userData,bytes operatorData) external;\r\n}\r\n\r\n\r\ninterface ERC777TokensRecipient {\r\n    function tokensReceived(address operator, address from, address to, uint amount, bytes userData, bytes operatorData) external;\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev The constructor sets the original owner of the contract to the sender account.\r\n   */\r\n  function Ownable() public {\r\n    setOwner(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets a new owner address\r\n   */\r\n  function setOwner(address newOwner) internal {\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    setOwner(newOwner);\r\n  }\r\n}\r\n\r\ncontract JaroCoinToken is Ownable, ERC820Implementer {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"JaroCoin\";\r\n    string public constant symbol = \"JARO\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant granularity = 1e10;   // Token has 8 digits after comma\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => bool)) public isOperatorFor;\r\n    mapping (address => mapping (uint256 => bool)) private usedNonces;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes userData, bytes operatorData);\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes userData, bytes operatorData);\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    uint256 public totalSupply = 0;\r\n    uint256 public constant maxSupply = 21000000e18;\r\n\r\n\r\n    // ------- ERC777/ERC965 Implementation ----------\r\n\r\n    /**\r\n    * @notice Send `_amount` of tokens to address `_to` passing `_userData` to the recipient\r\n    * @param _to The address of the recipient\r\n    * @param _amount The number of tokens to be sent\r\n    * @param _userData Data generated by the user to be sent to the recipient\r\n    */\r\n    function send(address _to, uint256 _amount, bytes _userData) public {\r\n        doSend(msg.sender, _to, _amount, _userData, msg.sender, \"\", true);\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address via cheque\r\n    * @param _to The address to transfer to\r\n    * @param _amount The amount to be transferred\r\n    * @param _userData The data to be executed\r\n    * @param _nonce Unique nonce to avoid double spendings\r\n    */\r\n    function sendByCheque(address _to, uint256 _amount, bytes _userData, uint256 _nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n        require(_to != address(this));\r\n\r\n        // Check if signature is valid, get signer's address and mark this cheque as used.\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 hash = keccak256(prefix, keccak256(_to, _amount, _userData, _nonce));\r\n        // bytes32 hash = keccak256(_to, _amount, _userData, _nonce);\r\n\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require (signer != 0);\r\n        require (!usedNonces[signer][_nonce]);\r\n        usedNonces[signer][_nonce] = true;\r\n\r\n        // Transfer tokens\r\n        doSend(signer, _to, _amount, _userData, signer, \"\", true);\r\n    }\r\n\r\n    /**\r\n    * @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.\r\n    * @param _operator The operator that wants to be Authorized\r\n    */\r\n    function authorizeOperator(address _operator) public {\r\n        require(_operator != msg.sender);\r\n        isOperatorFor[_operator][msg.sender] = true;\r\n        emit AuthorizedOperator(_operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.\r\n    * @param _operator The operator that wants to be Revoked\r\n    */\r\n    function revokeOperator(address _operator) public {\r\n        require(_operator != msg.sender);\r\n        isOperatorFor[_operator][msg.sender] = false;\r\n        emit RevokedOperator(_operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\r\n    * @param _from The address holding the tokens being sent\r\n    * @param _to The address of the recipient\r\n    * @param _amount The number of tokens to be sent\r\n    * @param _userData Data generated by the user to be sent to the recipient\r\n    * @param _operatorData Data generated by the operator to be sent to the recipient\r\n    */\r\n    function operatorSend(address _from, address _to, uint256 _amount, bytes _userData, bytes _operatorData) public {\r\n        require(isOperatorFor[msg.sender][_from]);\r\n        doSend(_from, _to, _amount, _userData, msg.sender, _operatorData, true);\r\n    }\r\n\r\n    /* -- Helper Functions -- */\r\n    /**\r\n    * @notice Internal function that ensures `_amount` is multiple of the granularity\r\n    * @param _amount The quantity that want's to be checked\r\n    */\r\n    function requireMultiple(uint256 _amount) internal pure {\r\n        require(_amount.div(granularity).mul(granularity) == _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Check whether an address is a regular address or not.\r\n    * @param _addr Address of the contract that has to be checked\r\n    * @return `true` if `_addr` is a regular address (not a contract)\r\n    */\r\n    function isRegularAddress(address _addr) internal constant returns(bool) {\r\n        if (_addr == 0) { return false; }\r\n        uint size;\r\n        assembly { size := extcodesize(_addr) } // solhint-disable-line no-inline-assembly\r\n        return size == 0;\r\n    }\r\n\r\n    /**\r\n    * @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\r\n    *  May throw according to `_preventLocking`\r\n    * @param _from The address holding the tokens being sent\r\n    * @param _to The address of the recipient\r\n    * @param _amount The amount of tokens to be sent\r\n    * @param _userData Data generated by the user to be passed to the recipient\r\n    * @param _operatorData Data generated by the operator to be passed to the recipient\r\n    *  implementing `ERC777TokensSender`.\r\n    *  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    *  functions SHOULD set this parameter to `false`.\r\n    */\r\n    function callSender(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _userData,\r\n        bytes _operatorData\r\n    ) private {\r\n        address senderImplementation = interfaceAddr(_from, \"ERC777TokensSender\");\r\n        if (senderImplementation != 0) {\r\n            ERC777TokensSender(senderImplementation).tokensToSend(\r\n                _operator, _from, _to, _amount, _userData, _operatorData);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\r\n    *  May throw according to `_preventLocking`\r\n    * @param _from The address holding the tokens being sent\r\n    * @param _to The address of the recipient\r\n    * @param _amount The number of tokens to be sent\r\n    * @param _userData Data generated by the user to be passed to the recipient\r\n    * @param _operatorData Data generated by the operator to be passed to the recipient\r\n    * @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n    *  implementing `ERC777TokensRecipient`.\r\n    *  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    *  functions SHOULD set this parameter to `false`.\r\n    */\r\n    function callRecipient(\r\n        address _operator,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _userData,\r\n        bytes _operatorData,\r\n        bool _preventLocking\r\n    ) private {\r\n        address recipientImplementation = interfaceAddr(_to, \"ERC777TokensRecipient\");\r\n        if (recipientImplementation != 0) {\r\n            ERC777TokensRecipient(recipientImplementation).tokensReceived(\r\n                _operator, _from, _to, _amount, _userData, _operatorData);\r\n        } else if (_preventLocking) {\r\n            require(isRegularAddress(_to));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Helper function actually performing the sending of tokens.\r\n    * @param _from The address holding the tokens being sent\r\n    * @param _to The address of the recipient\r\n    * @param _amount The number of tokens to be sent\r\n    * @param _userData Data generated by the user to be passed to the recipient\r\n    * @param _operatorData Data generated by the operator to be passed to the recipient\r\n    * @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\r\n    *  implementing `erc777_tokenHolder`.\r\n    *  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\r\n    *  functions SHOULD set this parameter to `false`.\r\n    */\r\n    function doSend(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _userData,\r\n        address _operator,\r\n        bytes _operatorData,\r\n        bool _preventLocking\r\n    )\r\n        private\r\n    {\r\n        requireMultiple(_amount);\r\n\r\n        callSender(_operator, _from, _to, _amount, _userData, _operatorData);\r\n\r\n        require(_to != 0x0);                  // forbid sending to 0x0 (=burning)\r\n        require(balanceOf[_from] >= _amount); // ensure enough funds\r\n\r\n        balanceOf[_from] = balanceOf[_from].sub(_amount);\r\n        balanceOf[_to] = balanceOf[_to].add(_amount);\r\n\r\n        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking);\r\n\r\n        emit Sent(_operator, _from, _to, _amount, _userData, _operatorData);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    // ------- ERC20 Implementation ----------\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        doSend(msg.sender, _to, _value, \"\", msg.sender, \"\", false);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another. Technically this is not ERC20 transferFrom but more ERC777 operatorSend.\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(isOperatorFor[msg.sender][_from]);\r\n        doSend(_from, _to, _value, \"\", msg.sender, \"\", true);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n\r\n     * @dev Originally in ERC20 this function to check the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * Function was added purly for backward compatibility with ERC20. Use operator logic from ERC777 instead.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A returning uint256 balanceOf _spender if it's active operator and 0 if not.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256 _amount) {\r\n        if (isOperatorFor[_spender][_owner]) {\r\n            _amount = balanceOf[_owner];\r\n        } else {\r\n            _amount = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend tokens on behalf of msg.sender.\r\n     *\r\n     * This function is more authorizeOperator and revokeOperator from ERC777 that Approve from ERC20.\r\n     * Approve concept has several issues (e.g. https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729),\r\n     * so I prefer to use operator concept. If you want to revoke approval, just put 0 into _value.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value Fake value to be compatible with ERC20 requirements.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_spender != msg.sender);\r\n\r\n        if (_value > 0) {\r\n            // Authorizing operator\r\n            isOperatorFor[_spender][msg.sender] = true;\r\n            emit AuthorizedOperator(_spender, msg.sender);\r\n        } else {\r\n            // Revoking operator\r\n            isOperatorFor[_spender][msg.sender] = false;\r\n            emit RevokedOperator(_spender, msg.sender);\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // ------- Minting and burning ----------\r\n\r\n    /**\r\n    * @dev Function to mint tokens\r\n    * @param _to The address that will receive the minted tokens.\r\n    * @param _amount The amount of tokens to mint.\r\n    * @param _operatorData Data that will be passed to the recipient as a first transfer.\r\n    */\r\n    function mint(address _to, uint256 _amount, bytes _operatorData) public onlyOwner {\r\n        require (totalSupply.add(_amount) <= maxSupply);\r\n        requireMultiple(_amount);\r\n\r\n        totalSupply = totalSupply.add(_amount);\r\n        balanceOf[_to] = balanceOf[_to].add(_amount);\r\n\r\n        callRecipient(msg.sender, 0x0, _to, _amount, \"\", _operatorData, true);\r\n\r\n        emit Minted(msg.sender, _to, _amount, _operatorData);\r\n        emit Transfer(0x0, _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to burn sender's tokens\r\n    * @param _amount The amount of tokens to burn.\r\n    * @return A boolean that indicates if the operation was successful.\r\n    */\r\n    function burn(uint256 _amount, bytes _userData) public {\r\n        require (_amount > 0);\r\n        require (balanceOf[msg.sender] >= _amount);\r\n        requireMultiple(_amount);\r\n\r\n        callSender(msg.sender, msg.sender, 0x0, _amount, _userData, \"\");\r\n\r\n        totalSupply = totalSupply.sub(_amount);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_amount);\r\n\r\n        emit Burned(msg.sender, msg.sender, _amount, _userData, \"\");\r\n        emit Transfer(msg.sender, 0x0, _amount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"sendByCheque\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_operatorData\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_userData\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userData\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userData\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"JaroCoinToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b5edfdf5c0ea5bf276c2e0f1461d7cc8b4e359266b9b798cd150f88bb0c24c27"}]}