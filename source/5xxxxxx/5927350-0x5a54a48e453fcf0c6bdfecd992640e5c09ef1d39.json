{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract ERC20Extended is ERC20 {\r\n    uint256 public decimals;\r\n    string public name;\r\n    string public symbol;\r\n\r\n}\r\n\r\ncontract ComponentInterface {\r\n    string public name;\r\n    string public description;\r\n    string public category;\r\n    string public version;\r\n}\r\n\r\ncontract ExchangeInterface is ComponentInterface {\r\n    /*\r\n     * @dev Checks if a trading pair is available\r\n     * For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\r\n     * @param address _sourceAddress The token to sell for the destAddress.\r\n     * @param address _destAddress The token to buy with the source token.\r\n     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\r\n     * @return boolean whether or not the trading pair is supported by this exchange provider\r\n     */\r\n    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId)\r\n        external view returns(bool supported);\r\n\r\n    /*\r\n     * @dev Buy a single token with ETH.\r\n     * @param ERC20Extended _token The token to buy, should be an ERC20Extended address.\r\n     * @param uint _amount Amount of ETH used to buy this token. Make sure the value sent to this function is the same as the _amount.\r\n     * @param uint _minimumRate The minimum amount of tokens to receive for 1 ETH.\r\n     * @param address _depositAddress The address to send the bought tokens to.\r\n     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\r\n     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here.\r\n     * @return boolean whether or not the trade succeeded.\r\n     */\r\n    function buyToken\r\n        (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress, bytes32 _exchangeId, address _partnerId\r\n        ) external payable returns(bool success);\r\n\r\n    /*\r\n     * @dev Sell a single token for ETH. Make sure the token is approved beforehand.\r\n     * @param ERC20Extended _token The token to sell, should be an ERC20Extended address.\r\n     * @param uint _amount Amount of tokens to sell.\r\n     * @param uint _minimumRate The minimum amount of ETH to receive for 1 ERC20Extended token.\r\n     * @param address _depositAddress The address to send the bought tokens to.\r\n     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\r\n     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\r\n     * @return boolean boolean whether or not the trade succeeded.\r\n     */\r\n    function sellToken\r\n        (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress, bytes32 _exchangeId, address _partnerId\r\n        ) external returns(bool success);\r\n}\r\n\r\ncontract KyberNetworkInterface {\r\n\r\n    function getExpectedRate(ERC20Extended src, ERC20Extended dest, uint srcQty)\r\n        external view returns (uint expectedRate, uint slippageRate);\r\n\r\n    function trade(\r\n        ERC20Extended source,\r\n        uint srcAmount,\r\n        ERC20Extended dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId)\r\n        external payable returns(uint);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract OlympusExchangeAdapterInterface is Ownable {\r\n\r\n    function supportsTradingPair(address _srcAddress, address _destAddress)\r\n        external view returns(bool supported);\r\n\r\n    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount)\r\n        external view returns(uint expectedRate, uint slippageRate);\r\n\r\n    function sellToken\r\n        (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress\r\n        ) external returns(bool success);\r\n\r\n    function buyToken\r\n        (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress\r\n        ) external payable returns(bool success);\r\n\r\n    function enable() external returns(bool);\r\n    function disable() external returns(bool);\r\n    function isEnabled() external view returns (bool success);\r\n\r\n    function setExchangeDetails(bytes32 _id, bytes32 _name) external returns(bool success);\r\n    function getExchangeDetails() external view returns(bytes32 _name, bool _enabled);\r\n\r\n}\r\n\r\ncontract OlympusExchangeAdapterManagerInterface is Ownable {\r\n    function pickExchange(ERC20Extended _token, uint _amount, uint _rate, bool _isBuying) public view returns (bytes32 exchangeId);\r\n    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId) external view returns(bool supported);\r\n    function getExchangeAdapter(bytes32 _exchangeId) external view returns(address);\r\n    function isValidAdapter(address _adapter) external view returns(bool);\r\n    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount, bytes32 _exchangeId)\r\n        external view returns(uint expectedRate, uint slippageRate);\r\n}\r\n\r\ncontract ExchangeAdapterManager is OlympusExchangeAdapterManagerInterface {\r\n\r\n    mapping(bytes32 => OlympusExchangeAdapterInterface) public exchangeAdapters;\r\n    bytes32[] public exchanges;\r\n    uint private genExchangeId = 1000;\r\n    mapping(address=>uint) private adapters;\r\n    ERC20Extended private constant ETH_TOKEN_ADDRESS = ERC20Extended(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n\r\n    event AddedExchange(bytes32 id);\r\n\r\n    function addExchange(bytes32 _name, address _adapter)\r\n    external onlyOwner returns(bool) {\r\n        require(_adapter != 0x0);\r\n        bytes32 id = keccak256(abi.encodePacked(_adapter, genExchangeId++));\r\n        require(OlympusExchangeAdapterInterface(_adapter).setExchangeDetails(id, _name));\r\n        exchanges.push(id);\r\n        exchangeAdapters[id] = OlympusExchangeAdapterInterface(_adapter);\r\n        adapters[_adapter]++;\r\n\r\n        emit AddedExchange(id);\r\n        return true;\r\n    }\r\n\r\n    function getExchanges() external view returns(bytes32[]) {\r\n        return exchanges;\r\n    }\r\n\r\n    function getExchangeInfo(bytes32 _id)\r\n    external view returns(bytes32 name, bool status) {\r\n        OlympusExchangeAdapterInterface adapter = exchangeAdapters[_id];\r\n        require(address(adapter) != 0x0);\r\n\r\n        return adapter.getExchangeDetails();\r\n    }\r\n\r\n    function getExchangeAdapter(bytes32 _id)\r\n    external view returns(address)\r\n    {\r\n        return address(exchangeAdapters[_id]);\r\n    }\r\n\r\n    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount, bytes32 _exchangeId)\r\n        external view returns(uint expectedRate, uint slippageRate) {\r\n\r\n        if(_exchangeId != 0x0) {\r\n            return exchangeAdapters[_exchangeId].getPrice(_sourceAddress, _destAddress, _amount);\r\n        }\r\n        bytes32 exchangeId = _sourceAddress == ETH_TOKEN_ADDRESS ?\r\n        pickExchange(_destAddress, _amount, 0, true) :\r\n        pickExchange(_sourceAddress, _amount, 0, false);\r\n        if(exchangeId != 0x0) {\r\n            OlympusExchangeAdapterInterface adapter = exchangeAdapters[exchangeId];\r\n            return adapter.getPrice(_sourceAddress, _destAddress, _amount);\r\n        }\r\n        return(0, 0);\r\n    }\r\n\r\n    /// >0  : found exchangeId\r\n    /// ==0 : not found\r\n    function pickExchange(ERC20Extended _token, uint _amount, uint _rate, bool _isBuying) public view returns (bytes32 exchangeId) {\r\n\r\n        int maxRate = -1;\r\n        for (uint i = 0; i < exchanges.length; i++) {\r\n\r\n            bytes32 id = exchanges[i];\r\n            OlympusExchangeAdapterInterface adapter = exchangeAdapters[id];\r\n            if (!adapter.isEnabled()) {\r\n                continue;\r\n            }\r\n            uint adapterResultRate;\r\n            uint adapterResultSlippage;\r\n            if (_isBuying){\r\n                (adapterResultRate,adapterResultSlippage) = adapter.getPrice(ETH_TOKEN_ADDRESS, _token, _amount);\r\n            } else {\r\n                (adapterResultRate,adapterResultSlippage) = adapter.getPrice(_token, ETH_TOKEN_ADDRESS, _amount);\r\n            }\r\n            int resultRate = int(adapterResultSlippage);\r\n\r\n\r\n            if (adapterResultRate == 0) { // not support\r\n                continue;\r\n            }\r\n\r\n            if (resultRate < int(_rate)) {\r\n                continue;\r\n            }\r\n\r\n            if (resultRate >= maxRate) {\r\n                maxRate = resultRate;\r\n                return id;\r\n            }\r\n        }\r\n        return 0x0;\r\n    }\r\n\r\n    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId) external view returns (bool) {\r\n        OlympusExchangeAdapterInterface adapter;\r\n        if(_exchangeId != \"\"){\r\n            adapter = exchangeAdapters[id];\r\n            if(!adapter.isEnabled()){\r\n                return false;\r\n            }\r\n            if (adapter.supportsTradingPair(_srcAddress, _destAddress)) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        for (uint i = 0; i < exchanges.length; i++) {\r\n            bytes32 id = exchanges[i];\r\n            adapter = exchangeAdapters[id];\r\n            if (!adapter.isEnabled()) {\r\n                continue;\r\n            }\r\n            if (adapter.supportsTradingPair(_srcAddress, _destAddress)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isValidAdapter(address _adapter) external view returns (bool) {\r\n        return adapters[_adapter] > 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getExchangeAdapter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_srcAddress\",\"type\":\"address\"},{\"name\":\"_destAddress\",\"type\":\"address\"},{\"name\":\"_exchangeId\",\"type\":\"bytes32\"}],\"name\":\"supportsTradingPair\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchanges\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exchanges\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sourceAddress\",\"type\":\"address\"},{\"name\":\"_destAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_exchangeId\",\"type\":\"bytes32\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"expectedRate\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_isBuying\",\"type\":\"bool\"}],\"name\":\"pickExchange\",\"outputs\":[{\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"addExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"exchangeAdapters\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"isValidAdapter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getExchangeInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"AddedExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ExchangeAdapterManager","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://993455db8329a94f9e03105435f53e366a398fe7294177d98b7e78e521916dd7"}]}