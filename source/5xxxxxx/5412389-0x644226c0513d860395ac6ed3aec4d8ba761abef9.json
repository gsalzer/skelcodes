{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\ninterface SvEns {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\n\r\ninterface ENS {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\n\r\ncontract SvEnsRegistry is SvEns {\r\n    struct Record {\r\n        address owner;\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    mapping (bytes32 => Record) records;\r\n\r\n    // Permits modifications only by the owner of the specified node.\r\n    modifier only_owner(bytes32 node) {\r\n        require(records[node].owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructs a new ENS registrar.\r\n     */\r\n    function SvEnsRegistry() public {\r\n        records[0x0].owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\r\n     * @param node The node to transfer ownership of.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setOwner(bytes32 node, address owner) external only_owner(node) {\r\n        emit Transfer(node, owner);\r\n        records[node].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external only_owner(node) returns (bytes32) {\r\n        bytes32 subnode = keccak256(node, label);\r\n        emit NewOwner(node, label, owner);\r\n        records[subnode].owner = owner;\r\n        return subnode;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the resolver address for the specified node.\r\n     * @param node The node to update.\r\n     * @param resolver The address of the resolver.\r\n     */\r\n    function setResolver(bytes32 node, address resolver) external only_owner(node) {\r\n        emit NewResolver(node, resolver);\r\n        records[node].resolver = resolver;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the TTL for the specified node.\r\n     * @param node The node to update.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setTTL(bytes32 node, uint64 ttl) external only_owner(node) {\r\n        emit NewTTL(node, ttl);\r\n        records[node].ttl = ttl;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that owns the specified node.\r\n     * @param node The specified node.\r\n     * @return address of the owner.\r\n     */\r\n    function owner(bytes32 node) external view returns (address) {\r\n        return records[node].owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the resolver for the specified node.\r\n     * @param node The specified node.\r\n     * @return address of the resolver.\r\n     */\r\n    function resolver(bytes32 node) external view returns (address) {\r\n        return records[node].resolver;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the TTL of a node, and any records associated with it.\r\n     * @param node The specified node.\r\n     * @return ttl of the node.\r\n     */\r\n    function ttl(bytes32 node) external view returns (uint64) {\r\n        return records[node].ttl;\r\n    }\r\n\r\n}\r\n\r\ncontract PublicResolver {\r\n\r\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\r\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\r\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\r\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\r\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    struct Record {\r\n        address addr;\r\n        bytes32 content;\r\n        string name;\r\n        PublicKey pubkey;\r\n        mapping(string=>string) text;\r\n        mapping(uint256=>bytes) abis;\r\n    }\r\n\r\n    ENS ens;\r\n\r\n    mapping (bytes32 => Record) records;\r\n\r\n    modifier only_owner(bytes32 node) {\r\n        require(ens.owner(node) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The ENS registrar contract.\r\n     */\r\n    function PublicResolver(ENS ensAddr) public {\r\n        ens = ensAddr;\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) public only_owner(node) {\r\n        records[node].addr = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Sets the content hash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The node to update.\r\n     * @param hash The content hash to set\r\n     */\r\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\r\n        records[node].content = hash;\r\n        emit ContentChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string name) public only_owner(node) {\r\n        records[node].name = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n\r\n        records[node].abis[contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\r\n        records[node].pubkey = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string key, string value) public only_owner(node) {\r\n        records[node].text[key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string key) public view returns (string) {\r\n        return records[node].text[key];\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\r\n        return (records[node].pubkey.x, records[node].pubkey.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\r\n        Record storage record = records[node];\r\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\r\n                data = record.abis[contentType];\r\n                return;\r\n            }\r\n        }\r\n        contentType = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) public view returns (string) {\r\n        return records[node].name;\r\n    }\r\n\r\n    /**\r\n     * Returns the content hash associated with an ENS node.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The ENS node to query.\r\n     * @return The associated content hash.\r\n     */\r\n    function content(bytes32 node) public view returns (bytes32) {\r\n        return records[node].content;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return records[node].addr;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID ||\r\n        interfaceID == CONTENT_INTERFACE_ID ||\r\n        interfaceID == NAME_INTERFACE_ID ||\r\n        interfaceID == ABI_INTERFACE_ID ||\r\n        interfaceID == PUBKEY_INTERFACE_ID ||\r\n        interfaceID == TEXT_INTERFACE_ID ||\r\n        interfaceID == INTERFACE_META_ID;\r\n    }\r\n}\r\n\r\ncontract SvEnsRegistrar {\r\n    SvEns public ens;\r\n    bytes32 public rootNode;\r\n    mapping (bytes32 => bool) knownNodes;\r\n    mapping (address => bool) admins;\r\n    address public owner;\r\n\r\n\r\n    modifier req(bool c) {\r\n        require(c);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The address of the ENS registry.\r\n     * @param node The node that this registrar administers.\r\n     */\r\n    function SvEnsRegistrar(SvEns ensAddr, bytes32 node) public {\r\n        ens = ensAddr;\r\n        rootNode = node;\r\n        admins[msg.sender] = true;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function addAdmin(address newAdmin) req(admins[msg.sender]) external {\r\n        admins[newAdmin] = true;\r\n    }\r\n\r\n    function remAdmin(address oldAdmin) req(admins[msg.sender]) external {\r\n        require(oldAdmin != msg.sender && oldAdmin != owner);\r\n        admins[oldAdmin] = false;\r\n    }\r\n\r\n    function chOwner(address newOwner, bool remPrevOwnerAsAdmin) req(msg.sender == owner) external {\r\n        if (remPrevOwnerAsAdmin) {\r\n            admins[owner] = false;\r\n        }\r\n        owner = newOwner;\r\n        admins[newOwner] = true;\r\n    }\r\n\r\n    /**\r\n     * Register a name that's not currently registered\r\n     * @param subnode The hash of the label to register.\r\n     * @param _owner The address of the new owner.\r\n     */\r\n    function register(bytes32 subnode, address _owner) req(admins[msg.sender]) external {\r\n        _setSubnodeOwner(subnode, _owner);\r\n    }\r\n\r\n    /**\r\n     * Register a name that's not currently registered\r\n     * @param subnodeStr The label to register.\r\n     * @param _owner The address of the new owner.\r\n     */\r\n    function registerName(string subnodeStr, address _owner) req(admins[msg.sender]) external {\r\n        // labelhash\r\n        bytes32 subnode = keccak256(subnodeStr);\r\n        _setSubnodeOwner(subnode, _owner);\r\n    }\r\n\r\n    /**\r\n     * INTERNAL - Register a name that's not currently registered\r\n     * @param subnode The hash of the label to register.\r\n     * @param _owner The address of the new owner.\r\n     */\r\n    function _setSubnodeOwner(bytes32 subnode, address _owner) internal {\r\n        require(!knownNodes[subnode]);\r\n        knownNodes[subnode] = true;\r\n        ens.setSubnodeOwner(rootNode, subnode, _owner);\r\n    }\r\n}\r\n\r\ncontract SvEnsEverythingPx {\r\n    address public owner;\r\n    mapping (address => bool) public admins;\r\n    address[] public adminLog;\r\n\r\n    SvEnsRegistrar public registrar;\r\n    SvEnsRegistry public registry;\r\n    PublicResolver public resolver;\r\n    bytes32 public rootNode;\r\n\r\n    modifier only_admin() {\r\n        require(admins[msg.sender]);\r\n        _;\r\n    }\r\n\r\n\r\n    function SvEnsEverythingPx(SvEnsRegistrar _registrar, SvEnsRegistry _registry, PublicResolver _resolver, bytes32 _rootNode) public {\r\n        registrar = _registrar;\r\n        registry = _registry;\r\n        resolver = _resolver;\r\n        rootNode = _rootNode;\r\n        owner = msg.sender;\r\n        _addAdmin(msg.sender);\r\n    }\r\n\r\n    function _addAdmin(address a) internal {\r\n        admins[a] = true;\r\n        adminLog.push(a);\r\n    }\r\n\r\n    function addAdmin(address a) only_admin() external {\r\n        _addAdmin(a);\r\n    }\r\n\r\n    function remAdmin(address a) only_admin() external {\r\n        require(a != owner && a != msg.sender);\r\n        admins[a] = false;\r\n    }\r\n\r\n    function regName(string name, address resolveTo) only_admin() external returns (bytes32 node) {\r\n        bytes32 labelhash = keccak256(name);\r\n        registrar.register(labelhash, this);\r\n        node = keccak256(rootNode, labelhash);\r\n        registry.setResolver(node, resolver);\r\n        resolver.setAddr(node, resolveTo);\r\n        registry.setOwner(node, msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"remAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adminLog\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"resolveTo\",\"type\":\"address\"}],\"name\":\"regName\",\"outputs\":[{\"name\":\"node\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registrar\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_resolver\",\"type\":\"address\"},{\"name\":\"_rootNode\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"SvEnsEverythingPx","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000047f4a6b393a352f5e8de2bde89fa121e00a4835e00000000000000000000000030ff37d85c14000b6ba4192137fff59a3c22211f000000000000000000000000d784b7429ed0b2d0ae9624bcff1de8d086f13aa9062545aade1505873c0f98042106fdd837fbc3fc0d45f63996ece434e6ef557f","Library":"","SwarmSource":"bzzr://63422d7fa20bfa3017c3763defcbae1c412ebe0f8987b361fc013889ede34e55"}]}