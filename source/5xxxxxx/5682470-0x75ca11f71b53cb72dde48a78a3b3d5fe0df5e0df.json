{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.21;\r\n\r\n/**\r\n *   @title SafeMath\r\n *   @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *   @title ERC20\r\n *   @dev Standart ERC20 token interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address _owner) public constant returns(uint256);\r\n    function transfer(address _to, uint256 _value) public returns(bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\r\n    function approve(address _spender, uint256 _value) public returns(bool);\r\n    function allowance(address _owner, address _spender) public constant returns(uint256);\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/**\r\n *   @dev LTO token contract\r\n */\r\ncontract TESTTESTToken is ERC20 {\r\n    using SafeMath for uint256;\r\n    string public name = \"TESTTEST TOKEN\";\r\n    string public symbol = \"TTT\";\r\n    uint256 public decimals = 18;\r\n    uint256 public totalSupply = 0;\r\n    uint256 public constant MAX_TOKENS = 166000000 * 1e18;\r\n    \r\n    \r\n\r\n    // Ico contract address\r\n    address public owner;\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    // Disables token transfers\r\n    bool public tokensAreFrozen = true;\r\n\r\n    // Allows execution by the owner only\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    \r\n    \r\n    function TESTTESTToken(address _owner) public {\r\n        owner = _owner;\r\n    }\r\n    \r\n\r\n   /**\r\n    *   @dev Mint tokens\r\n    *   @param _investor     address the tokens will be issued to\r\n    *   @param _value        number of tokens\r\n    */\r\n    function mintTokens(address _investor, uint256 _value) external onlyOwner {\r\n        require(_value > 0);\r\n        require(totalSupply.add(_value) <= MAX_TOKENS);\r\n        balances[_investor] = balances[_investor].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        emit Transfer(0x0, _investor, _value);\r\n    }\r\n\r\n   /**\r\n    *   @dev Enables token transfers\r\n    */\r\n    function defrostTokens() external onlyOwner {\r\n      tokensAreFrozen = false;\r\n    }\r\n\r\n   /**\r\n    *   @dev Disables token transfers\r\n    */\r\n    function frostTokens() external onlyOwner {\r\n      tokensAreFrozen = true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Burn Tokens\r\n    *   @param _investor     token holder address which the tokens will be burnt\r\n    *   @param _value        number of tokens to burn\r\n    */\r\n    function burnTokens(address _investor, uint256 _value) external onlyOwner {\r\n        require(balances[_investor] > 0);\r\n        totalSupply = totalSupply.sub(_value);\r\n        balances[_investor] = balances[_investor].sub(_value);\r\n        emit Burn(_investor, _value);\r\n    }\r\n\r\n   /**\r\n    *   @dev Get balance of investor\r\n    *   @param _owner        investor's address\r\n    *   @return              balance of investor\r\n    */\r\n    function balanceOf(address _owner) public constant returns(uint256) {\r\n      return balances[_owner];\r\n    }\r\n\r\n   /**\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transfer(address _to, uint256 _amount) public returns(bool) {\r\n        require(!tokensAreFrozen);\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {\r\n        require(!tokensAreFrozen);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows another account/contract to spend some tokens on its behalf\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   also, to minimize the risk of the approve/transferFrom attack vector\r\n    *   approve has to be called twice in 2 separate transactions - once to\r\n    *   change the allowance to 0 and secondly to change it to the new allowance\r\n    *   value\r\n    *\r\n    *   @param _spender      approved address\r\n    *   @param _amount       allowance amount\r\n    *\r\n    *   @return true if the approval was successful\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns(bool) {\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    *   @param _owner        the address which owns the funds\r\n    *   @param _spender      the address which will spend the funds\r\n    *\r\n    *   @return              the amount of tokens still avaible for the spender\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns(uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\ncontract TESTTESTICO {\r\n    TESTTESTToken public LTO = new TESTTESTToken(this);\r\n    using SafeMath for uint256;\r\n\r\n    // Token price parameters\r\n    uint256 public Rate_Eth = 700; // Rate USD per ETH\r\n    uint256 public Tokens_Per_Dollar = 50; // Lto token per dollar\r\n    uint256 public Token_Price = Tokens_Per_Dollar.mul(Rate_Eth); // Lto token per ETH\r\n\r\n    uint256 constant bountyPart = 20; // 2% of TotalSupply for BountyFund\r\n    uint256 constant teamPart = 30; //3% of TotalSupply for TeamFund\r\n    uint256 constant companyPart = 120; //12% of TotalSupply for company\r\n    uint256 constant MAX_PREICO_TOKENS = 27556000 * 1e18;\r\n    uint256 constant TOKENS_FOR_SALE = 137780000 * 1e18;  // 83% of maximum 166M tokens fo sale\r\n    uint256 constant SOFT_CAP = 36300000 * 1e18; // 726 000$ in ICO\r\n    uint256 constant HARD_CAP = 93690400 * 1e18; // ~1 900 000$ in ICO   (1 873 808)\r\n    uint256 public soldTotal;  // total sold without bonus\r\n    bool public isItIco = false;\r\n    bool public canIBuy = false;\r\n    bool public canIWithdraw = false;\r\n\r\n\r\n    address public BountyFund;\r\n    address public TeamFund;\r\n    address public Company;\r\n    address public Manager; // Manager controls contract\r\n    StatusICO statusICO;\r\n\r\n\r\n    // Possible ICO statuses\r\n    enum StatusICO {\r\n        Created,\r\n        PreIcoStage1,\r\n        PreIcoStage2,\r\n        PreIcoStage3,\r\n        PreIcoFinished,\r\n        IcoStage1,\r\n        IcoStage2,\r\n        IcoStage3,\r\n        IcoStage4,\r\n        IcoStage5,\r\n        IcoFinished\r\n    }\r\n    \r\n    \r\n\r\n\r\n\r\n\r\n    // Mapping\r\n    mapping(address => uint256) public preInvestments; // Mapping for remembering investors eth in preICO\r\n    mapping(address => uint256) public icoInvestments; // Mapping for remembering investors eth in ICO\r\n    mapping(address => bool) public returnStatusPre; // Users can return their funds one time in PreICO and ICO\r\n    mapping(address => bool) public returnStatusIco; // Users can return their funds one time in PreICO and ICO\r\n    mapping(address => uint256) public tokensPreIco; // Mapping for remembering tokens of investors who paid at preICO in ether\r\n    mapping(address => uint256) public tokensIco; // Mapping for remembering tokens of investors who paid at ICO in ether\r\n    mapping(address => uint256) public tokensPreIcoInOtherCrypto; // Mapping for remembering tokens of investors who paid at preICO in other crypto\r\n    mapping(address => uint256) public tokensIcoInOtherCrypto; // Mapping for remembering tokens of investors who paid at ICO in other crypto\r\n    mapping(address => uint256) public tokensNoBonusSold;\r\n\r\n    // Events Log\r\n    event LogStartPreIcoStage(uint stageNum);\r\n    event LogFinishPreICO();\r\n    event LogStartIcoStage(uint stageNum);\r\n    event LogFinishICO(address bountyFund, address Company, address teamFund);\r\n    event LogBuyForInvestor(address investor, uint256 value);\r\n    event LogReturnEth(address investor, uint256 eth);\r\n    event LogReturnOtherCrypto(address investor);\r\n\r\n    // Modifier\r\n    // Allows execution by the contract manager only\r\n    modifier managerOnly {\r\n        require(msg.sender == Manager);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n   /**\r\n    *   @dev Contract constructor function\r\n    */\r\n    function TESTTESTICO(\r\n        address _BountyFund,\r\n        address _TeamFund,\r\n        address _Company,\r\n        address _Manager\r\n    )\r\n        public {\r\n        BountyFund = _BountyFund;\r\n        TeamFund = _TeamFund;\r\n        Company = _Company;\r\n        Manager = _Manager;\r\n        statusICO = StatusICO.Created;\r\n        \r\n    }\r\n    \r\n    function currentStage() public view returns (string) {\r\n        if(statusICO == StatusICO.Created){return \"Created\";}\r\n        else if(statusICO == StatusICO.PreIcoStage1){return  \"PreIcoStage1\";}\r\n        else if(statusICO == StatusICO.PreIcoStage2){return \"PreIcoStage2\";}\r\n        else if(statusICO == StatusICO.PreIcoStage3){return \"PreIcoStage3\";}\r\n        else if(statusICO == StatusICO.PreIcoFinished){return \"PreIcoFinished\";}\r\n        else if(statusICO == StatusICO.IcoStage1){return \"IcoStage1\";}\r\n        else if(statusICO == StatusICO.IcoStage2){return \"IcoStage2\";}\r\n        else if(statusICO == StatusICO.IcoStage1){return \"IcoStage3\";}\r\n        else if(statusICO == StatusICO.IcoStage1){return \"IcoStage4\";}\r\n        else if(statusICO == StatusICO.IcoStage1){return \"IcoStage5\";}\r\n        else if(statusICO == StatusICO.IcoStage1){return \"IcoFinished\";}\r\n    }\r\n\r\n   /**\r\n    *   @dev Set rate of ETH and update token price\r\n    *   @param _RateEth       current ETH rate\r\n    */\r\n    function setRate(uint256 _RateEth) external managerOnly {\r\n        Rate_Eth = _RateEth;\r\n        Token_Price = Tokens_Per_Dollar.mul(Rate_Eth);\r\n    }\r\n\r\n   /**\r\n    *   \r\n    *   Set PreICO status\r\n    */\r\n    function setPreIcoStatus(uint _numb) external managerOnly {\r\n        require(statusICO == StatusICO.Created \r\n        || statusICO == StatusICO.PreIcoStage1 \r\n        || statusICO == StatusICO.PreIcoStage2); \r\n        require(_numb == 1 ||  _numb == 2 || _numb == 3);\r\n        StatusICO stat = StatusICO.PreIcoStage1;\r\n        if(_numb == 2){stat = StatusICO.PreIcoStage2;}\r\n        else if(_numb == 3){stat = StatusICO.PreIcoStage3;}\r\n        \r\n        statusICO = stat;\r\n        canIBuy = true;\r\n        canIWithdraw = true;\r\n        emit LogStartPreIcoStage(_numb);\r\n    }\r\n    \r\n    /**\r\n    *   @dev Finish PreIco\r\n    *   Set Ico status to PreIcoFinished\r\n    */\r\n    function finishPreIco() external managerOnly {\r\n        require(statusICO == StatusICO.PreIcoStage3);\r\n        statusICO = StatusICO.PreIcoFinished;\r\n        isItIco = true;\r\n        canIBuy = false;\r\n        canIWithdraw = false;\r\n        emit LogFinishPreICO();\r\n    }\r\n\r\n \r\n \r\n\r\n   /**\r\n    *   @dev Start ICO\r\n    *   Set ICO status\r\n    */\r\n    \r\n    function setIcoStatus(uint _numb) external managerOnly {\r\n        require(statusICO == StatusICO.PreIcoFinished \r\n        || statusICO == StatusICO.IcoStage1 \r\n        || statusICO == StatusICO.IcoStage2 \r\n        || statusICO == StatusICO.IcoStage3 \r\n        || statusICO == StatusICO.IcoStage4);\r\n        require(_numb == 1 ||  _numb == 2 || _numb == 3 || _numb == 4 || _numb == 5);\r\n        StatusICO stat = StatusICO.IcoStage1;\r\n        if(_numb == 2){stat = StatusICO.IcoStage2;}\r\n        else if(_numb == 3){stat = StatusICO.IcoStage3;}\r\n        else if(_numb == 4){stat = StatusICO.IcoStage4;}\r\n        else if(_numb == 5){stat = StatusICO.IcoStage5;}\r\n        \r\n        statusICO = stat;\r\n        canIBuy = true;\r\n        canIWithdraw = true;\r\n        emit LogStartIcoStage(_numb);\r\n    }\r\n\r\n\r\n\r\n\r\n   /**\r\n    *   @dev Finish ICO and emit tokens for bounty company and team\r\n    */\r\n    function finishIco() external managerOnly {\r\n        require(statusICO == StatusICO.IcoStage5);\r\n        uint256 totalAmount = LTO.totalSupply();\r\n        LTO.mintTokens(BountyFund, bountyPart.mul(totalAmount).div(1000));\r\n        LTO.mintTokens(TeamFund, teamPart.mul(totalAmount).div(1000));\r\n        LTO.mintTokens(Company, companyPart.mul(totalAmount).div(1000));\r\n        statusICO = StatusICO.IcoFinished;\r\n        canIBuy = false;\r\n        if(soldTotal >= SOFT_CAP){canIWithdraw = false;}\r\n        emit LogFinishICO(BountyFund, Company, TeamFund);\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Unfreeze tokens(enable token transfers)\r\n    */\r\n    function enableTokensTransfer() external managerOnly {\r\n        LTO.defrostTokens();\r\n    }\r\n\r\n    /**\r\n    *   @dev Freeze tokens(disable token transfers)\r\n    */\r\n    function disableTokensTransfer() external managerOnly {\r\n        require(statusICO != StatusICO.IcoFinished);\r\n        LTO.frostTokens();\r\n    }\r\n\r\n   /**\r\n    *   @dev Fallback function calls function to create tokens\r\n    *        when investor sends ETH to address of ICO contract\r\n    */\r\n    function() external payable {\r\n        require(canIBuy);\r\n        require(msg.value > 0);\r\n        createTokens(msg.sender, msg.value.mul(Token_Price), msg.value);\r\n    }\r\n    \r\n    \r\n    function buyToken() external payable {\r\n        require(canIBuy);\r\n        require(msg.value > 0);\r\n        createTokens(msg.sender, msg.value.mul(Token_Price), msg.value);\r\n    }\r\n\r\n\r\n\r\n\r\n    function buyForInvestor(address _investor, uint256 _value) external managerOnly {\r\n        require(_value > 0);\r\n        require(canIBuy);\r\n        uint256 decvalue = _value.mul(1 ether);\r\n        uint256 bonus = getBonus(decvalue);\r\n        uint256 total = decvalue.add(bonus);\r\n        if(!isItIco){\r\n            require(LTO.totalSupply().add(total) <= MAX_PREICO_TOKENS);\r\n            tokensPreIcoInOtherCrypto[_investor] = tokensPreIcoInOtherCrypto[_investor].add(total);}\r\n        else {\r\n            require(LTO.totalSupply().add(total) <= TOKENS_FOR_SALE);\r\n            require(soldTotal.add(decvalue) <= HARD_CAP);\r\n            tokensIcoInOtherCrypto[_investor] = tokensIcoInOtherCrypto[_investor].add(total);\r\n            soldTotal = soldTotal.add(decvalue);}\r\n        LTO.mintTokens(_investor, total);\r\n        tokensNoBonusSold[_investor] = tokensNoBonusSold[_investor].add(decvalue);\r\n\r\n        emit LogBuyForInvestor(_investor, _value);\r\n    }\r\n    \r\n\r\n\r\n    function createTokens(address _investor, uint256 _value, uint256 _ethValue) internal {\r\n        require(_value > 0);\r\n        uint256 bonus = getBonus(_value);\r\n        uint256 total = _value.add(bonus);\r\n        if(!isItIco){\r\n            require(LTO.totalSupply().add(total) <= MAX_PREICO_TOKENS);\r\n            tokensPreIco[_investor] = tokensPreIco[_investor].add(total);\r\n            preInvestments[_investor] = preInvestments[_investor].add(_ethValue);}\r\n        else {\r\n            require(LTO.totalSupply().add(total) <= TOKENS_FOR_SALE);\r\n            require(soldTotal.add(_value) <= HARD_CAP);\r\n            tokensIco[_investor] = tokensIco[_investor].add(total);\r\n            icoInvestments[_investor] = icoInvestments[_investor].add(_ethValue);\r\n            soldTotal = soldTotal.add(_value);}\r\n        LTO.mintTokens(_investor, total);\r\n        tokensNoBonusSold[_investor] = tokensNoBonusSold[_investor].add(_value);\r\n    }\r\n \r\n\r\n\r\n   /**\r\n    *   @dev Calculates bonus \r\n    *   @param _value        amount of tokens\r\n    *   @return              bonus value\r\n    */\r\n    function getBonus(uint256 _value) public view returns(uint256) {\r\n        uint256 bonus = 0;\r\n        if (statusICO == StatusICO.PreIcoStage1) {\r\n            bonus = _value.mul(300).div(1000);                    \r\n        } else if (statusICO == StatusICO.PreIcoStage2) {\r\n            bonus = _value.mul(250).div(1000);\r\n        } else if (statusICO == StatusICO.PreIcoStage3) {\r\n            bonus = _value.mul(200).div(1000);\r\n        } else if (statusICO == StatusICO.IcoStage1) {\r\n            bonus = _value.mul(150).div(1000);\r\n        } else if (statusICO == StatusICO.IcoStage2) {\r\n            bonus = _value.mul(100).div(1000);\r\n        } else if (statusICO == StatusICO.IcoStage3) {\r\n            bonus = _value.mul(60).div(1000);\r\n        } else if (statusICO == StatusICO.IcoStage4) {\r\n            bonus = _value.mul(30).div(1000);\r\n        } \r\n        return bonus;\r\n    }\r\n\r\n\r\n\r\n   /**\r\n    *   @dev Allows investors to return their investments\r\n    */\r\n    function returnEther() public {\r\n        uint256 eth = 0;\r\n        uint256 tokens = 0;\r\n        require(canIWithdraw);\r\n        if (!isItIco) {\r\n            require(!returnStatusPre[msg.sender]);\r\n            require(preInvestments[msg.sender] > 0);\r\n            eth = preInvestments[msg.sender];\r\n            tokens = tokensPreIco[msg.sender];\r\n            preInvestments[msg.sender] = 0;\r\n            tokensPreIco[msg.sender] = 0;\r\n            returnStatusPre[msg.sender] = true;\r\n        }\r\n        else {\r\n            require(!returnStatusIco[msg.sender]);\r\n            require(icoInvestments[msg.sender] > 0);\r\n            eth = icoInvestments[msg.sender];\r\n            tokens = tokensIco[msg.sender];\r\n            icoInvestments[msg.sender] = 0;\r\n            tokensIco[msg.sender] = 0;\r\n            returnStatusIco[msg.sender] = true;\r\n            soldTotal = soldTotal.sub(tokensNoBonusSold[msg.sender]);}\r\n        LTO.burnTokens(msg.sender, tokens);\r\n        msg.sender.transfer(eth);\r\n        emit LogReturnEth(msg.sender, eth);\r\n    }\r\n\r\n   /**\r\n    *   @dev Burn tokens who paid in other cryptocurrencies\r\n    */\r\n    function returnOtherCrypto(address _investor)external managerOnly {\r\n        uint256 tokens = 0;\r\n        require(canIWithdraw);\r\n        if (!isItIco) {\r\n            require(!returnStatusPre[_investor]);\r\n            tokens = tokensPreIcoInOtherCrypto[_investor];\r\n            tokensPreIcoInOtherCrypto[_investor] = 0;}\r\n        else {\r\n            require(!returnStatusIco[_investor]);\r\n            tokens = tokensIcoInOtherCrypto[_investor];\r\n            tokensIcoInOtherCrypto[_investor] = 0;\r\n            soldTotal = soldTotal.sub(tokensNoBonusSold[_investor]);}\r\n        LTO.burnTokens(_investor, tokens);\r\n        emit LogReturnOtherCrypto(_investor);\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows Company withdraw investments\r\n    */\r\n    function takeInvestments() external managerOnly {\r\n        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoFinished);\r\n        if(statusICO == StatusICO.PreIcoFinished){\r\n            uint256 totalb = address(this).balance;\r\n            uint256 fivePercent = (totalb.mul(50)).div(1000);\r\n            TeamFund.transfer(fivePercent);\r\n            Company.transfer(totalb.sub(fivePercent));\r\n        } else {\r\n            Company.transfer(address(this).balance);\r\n            LTO.defrostTokens();\r\n        }\r\n        \r\n    }\r\n\r\n}\r\n\r\n// woopchain.com","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"frostTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"defrostTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAreFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"TESTTESTToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000007c0ef8c8961cb7fc0dadd0a40c57b7b7dfed230","Library":"","SwarmSource":"bzzr://92417444c619e9b706a3be2cb98120551ba6a92073d295824d50f7aae1e9706e"}]}