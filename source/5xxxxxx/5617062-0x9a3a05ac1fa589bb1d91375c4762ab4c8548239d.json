{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.20;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        assert(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        assert(b > 0);\r\n        c = a / b;\r\n        assert(a == b * c + a % b);\r\n    }\r\n}\r\n\r\ncontract AcreConfig {\r\n    using SafeMath for uint;\r\n    \r\n    uint internal constant TIME_FACTOR = 1 days;\r\n\r\n    // Ownable\r\n    uint internal constant OWNERSHIP_DURATION_TIME = 7; // 7 days\r\n    \r\n    // MultiOwnable\r\n    uint8 internal constant MULTI_OWNER_COUNT = 5; // 5 accounts, exclude master\r\n    \r\n    // Lockable\r\n    uint internal constant LOCKUP_DURATION_TIME = 365; // 365 days\r\n    \r\n    // AcreToken\r\n    string internal constant TOKEN_NAME            = \"Acre\";\r\n    string internal constant TOKEN_SYMBOL          = \"ACRE\";\r\n    uint8  internal constant TOKEN_DECIMALS        = 18;\r\n    \r\n    uint   internal constant INITIAL_SUPPLY        =   1*1e8 * 10 ** uint(TOKEN_DECIMALS); // supply\r\n    uint   internal constant CAPITAL_SUPPLY        =  31*1e6 * 10 ** uint(TOKEN_DECIMALS); // supply\r\n    uint   internal constant PRE_PAYMENT_SUPPLY    =  19*1e6 * 10 ** uint(TOKEN_DECIMALS); // supply\r\n    uint   internal constant MAX_MINING_SUPPLY     =   4*1e8 * 10 ** uint(TOKEN_DECIMALS); // supply\r\n    \r\n    // Sale\r\n    uint internal constant MIN_ETHER               = 1*1e17; // 0.1 ether\r\n    uint internal constant EXCHANGE_RATE           = 1000;   // 1 eth = 1000 acre\r\n    uint internal constant PRESALE_DURATION_TIME   = 15;     // 15 days \r\n    uint internal constant CROWDSALE_DURATION_TIME = 23;     // 23 days\r\n    \r\n    // helper\r\n    function getDays(uint _time) internal pure returns(uint) {\r\n        return SafeMath.div(_time, 1 days);\r\n    }\r\n    \r\n    function getHours(uint _time) internal pure returns(uint) {\r\n        return SafeMath.div(_time, 1 hours);\r\n    }\r\n    \r\n    function getMinutes(uint _time) internal pure returns(uint) {\r\n        return SafeMath.div(_time, 1 minutes);\r\n    }\r\n}\r\n\r\ncontract Ownable is AcreConfig {\r\n    address public owner;\r\n    address public reservedOwner;\r\n    uint public ownershipDeadline;\r\n    \r\n    event ReserveOwnership(address indexed oldOwner, address indexed newOwner);\r\n    event ConfirmOwnership(address indexed oldOwner, address indexed newOwner);\r\n    event CancelOwnership(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function reserveOwnership(address newOwner) onlyOwner public returns (bool success) {\r\n        require(newOwner != address(0));\r\n        ReserveOwnership(owner, newOwner);\r\n        reservedOwner = newOwner;\r\n\t\townershipDeadline = SafeMath.add(now, SafeMath.mul(OWNERSHIP_DURATION_TIME, TIME_FACTOR));\r\n        return true;\r\n    }\r\n    \r\n    function confirmOwnership() onlyOwner public returns (bool success) {\r\n        require(reservedOwner != address(0));\r\n        require(now > ownershipDeadline);\r\n        ConfirmOwnership(owner, reservedOwner);\r\n        owner = reservedOwner;\r\n        reservedOwner = address(0);\r\n        return true;\r\n    }\r\n    \r\n    function cancelOwnership() onlyOwner public returns (bool success) {\r\n        require(reservedOwner != address(0));\r\n        CancelOwnership(owner, reservedOwner);\r\n        reservedOwner = address(0);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract MultiOwnable is Ownable {\r\n    address[] public owners;\r\n    \r\n    event GrantOwners(address indexed owner);\r\n    event RevokeOwners(address indexed owner);\r\n    \r\n    modifier onlyMutiOwners {\r\n        require(isExistedOwner(msg.sender));\r\n        _;\r\n    }\r\n    \r\n    modifier onlyManagers {\r\n        require(isManageable(msg.sender));\r\n        _;\r\n    }\r\n    \r\n    function MultiOwnable() public {\r\n        owners.length = MULTI_OWNER_COUNT;\r\n    }\r\n    \r\n    function grantOwners(address _owner) onlyOwner public returns (bool success) {\r\n        require(!isExistedOwner(_owner));\r\n        require(isEmptyOwner());\r\n        owners[getEmptyIndex()] = _owner;\r\n        GrantOwners(_owner);\r\n        return true;\r\n    }\r\n\r\n    function revokeOwners(address _owner) onlyOwner public returns (bool success) {\r\n        require(isExistedOwner(_owner));\r\n        owners[getOwnerIndex(_owner)] = address(0);\r\n        RevokeOwners(_owner);\r\n        return true;\r\n    }\r\n    \r\n    // helper\r\n    function isManageable(address _owner) internal constant returns (bool) {\r\n        return isExistedOwner(_owner) || owner == _owner;\r\n    }\r\n    \r\n    function isExistedOwner(address _owner) internal constant returns (bool) {\r\n        for(uint8 i = 0; i < MULTI_OWNER_COUNT; ++i) {\r\n            if(owners[i] == _owner) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getOwnerIndex(address _owner) internal constant returns (uint) {\r\n        for(uint8 i = 0; i < MULTI_OWNER_COUNT; ++i) {\r\n            if(owners[i] == _owner) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function isEmptyOwner() internal constant returns (bool) {\r\n        for(uint8 i = 0; i < MULTI_OWNER_COUNT; ++i) {\r\n            if(owners[i] == address(0)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getEmptyIndex() internal constant returns (uint) {\r\n        for(uint8 i = 0; i < MULTI_OWNER_COUNT; ++i) {\r\n            if(owners[i] == address(0)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Pausable is MultiOwnable {\r\n    bool public paused = false;\r\n    \r\n    event Pause();\r\n    event Unpause();\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n    \r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n    \r\n    modifier whenConditionalPassing() {\r\n        if(!isManageable(msg.sender)) {\r\n            require(!paused);\r\n        }\r\n        _;\r\n    }\r\n    \r\n    function pause() onlyManagers whenNotPaused public returns (bool success) {\r\n        paused = true;\r\n        Pause();\r\n        return true;\r\n    }\r\n  \r\n    function unpause() onlyManagers whenPaused public returns (bool success) {\r\n        paused = false;\r\n        Unpause();\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Lockable is Pausable {\r\n    mapping (address => uint) public locked;\r\n    \r\n    event Lockup(address indexed target, uint startTime, uint deadline);\r\n    \r\n    function lockup(address _target) onlyOwner public returns (bool success) {\r\n\t    require(!isManageable(_target));\r\n        locked[_target] = SafeMath.add(now, SafeMath.mul(LOCKUP_DURATION_TIME, TIME_FACTOR));\r\n        Lockup(_target, now, locked[_target]);\r\n        return true;\r\n    }\r\n    \r\n    // helper\r\n    function isLockup(address _target) internal constant returns (bool) {\r\n        if(now <= locked[_target])\r\n            return true;\r\n    }\r\n}\r\n\r\ninterface tokenRecipient { \r\n    function receiveApproval(address _from, uint _value, address _token, bytes _extraData) external; \r\n}\r\n\r\ncontract TokenERC20 {\r\n    using SafeMath for uint;\r\n    \r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    \r\n    uint public totalSupply;\r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n\r\n    event ERC20Token(address indexed owner, string name, string symbol, uint8 decimals, uint supply);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event TransferFrom(address indexed from, address indexed to, address indexed spender, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    \r\n    function TokenERC20(\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals,\r\n        uint _initialSupply\r\n    ) public {\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _tokenDecimals;\r\n        \r\n        totalSupply = _initialSupply;\r\n        balanceOf[msg.sender] = totalSupply;\r\n        \r\n        ERC20Token(msg.sender, name, symbol, decimals, totalSupply);\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal returns (bool success) {\r\n        require(_to != address(0));\r\n        require(balanceOf[_from] >= _value);\r\n        require(SafeMath.add(balanceOf[_to], _value) > balanceOf[_to]);\r\n        uint previousBalances = SafeMath.add(balanceOf[_from], balanceOf[_to]);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        Transfer(_from, _to, _value);\r\n        assert(SafeMath.add(balanceOf[_from], balanceOf[_to]) == previousBalances);\r\n        return true;\r\n    }\r\n    \r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     \r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        _transfer(_from, _to, _value);\r\n        TransferFrom(_from, _to, msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint _value, bytes _extraData) public returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract AcreToken is Lockable, TokenERC20 {\r\n    string public version = '1.0';\r\n    \r\n    address public companyCapital;\r\n    address public prePayment;\r\n    \r\n    uint public totalMineSupply;\r\n    mapping (address => bool) public frozenAccount;\r\n\r\n    event FrozenAccount(address indexed target, bool frozen);\r\n    event Burn(address indexed owner, uint value);\r\n    event Mining(address indexed recipient, uint value);\r\n    event WithdrawContractToken(address indexed owner, uint value);\r\n    \r\n    function AcreToken(address _companyCapital, address _prePayment) TokenERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS, INITIAL_SUPPLY) public {\r\n        require(_companyCapital != address(0));\r\n        require(_prePayment != address(0));\r\n        companyCapital = _companyCapital;\r\n        prePayment = _prePayment;\r\n        transfer(companyCapital, CAPITAL_SUPPLY);\r\n        transfer(prePayment, PRE_PAYMENT_SUPPLY);\r\n        lockup(prePayment);\r\n        pause(); \r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) whenConditionalPassing internal returns (bool success) {\r\n        require(!frozenAccount[_from]); // freeze                     \r\n        require(!frozenAccount[_to]);\r\n        require(!isLockup(_from));      // lockup\r\n        require(!isLockup(_to));\r\n        return super._transfer(_from, _to, _value);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(!frozenAccount[msg.sender]); // freeze\r\n        require(!isLockup(msg.sender));      // lockup\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n    \r\n    function freezeAccount(address _target) onlyManagers public returns (bool success) {\r\n        require(!isManageable(_target));\r\n        require(!frozenAccount[_target]);\r\n        frozenAccount[_target] = true;\r\n        FrozenAccount(_target, true);\r\n        return true;\r\n    }\r\n    \r\n    function unfreezeAccount(address _target) onlyManagers public returns (bool success) {\r\n        require(frozenAccount[_target]);\r\n        frozenAccount[_target] = false;\r\n        FrozenAccount(_target, false);\r\n        return true;\r\n    }\r\n    \r\n    function burn(uint _value) onlyManagers public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   \r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            \r\n        totalSupply = totalSupply.sub(_value);                      \r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function mining(address _recipient, uint _value) onlyManagers public returns (bool success) {\r\n        require(_recipient != address(0));\r\n        require(!frozenAccount[_recipient]); // freeze\r\n        require(!isLockup(_recipient));      // lockup\r\n        require(SafeMath.add(totalMineSupply, _value) <= MAX_MINING_SUPPLY);\r\n        balanceOf[_recipient] = balanceOf[_recipient].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        totalMineSupply = totalMineSupply.add(_value);\r\n        Mining(_recipient, _value);\r\n        return true;\r\n    }\r\n    \r\n    function withdrawContractToken(uint _value) onlyManagers public returns (bool success) {\r\n        _transfer(this, msg.sender, _value);\r\n        WithdrawContractToken(msg.sender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function getContractBalanceOf() public constant returns(uint blance) {\r\n        blance = balanceOf[this];\r\n    }\r\n    \r\n    function getRemainingMineSupply() public constant returns(uint supply) {\r\n        supply = MAX_MINING_SUPPLY - totalMineSupply;\r\n    }\r\n    \r\n    function () public { revert(); }\r\n}\r\n\r\ncontract AcreSale is MultiOwnable {\r\n    uint public saleDeadline;\r\n    uint public startSaleTime;\r\n    uint public softCapToken;\r\n    uint public hardCapToken;\r\n    uint public soldToken;\r\n    uint public receivedEther;\r\n    address public sendEther;\r\n    AcreToken public tokenReward;\r\n    bool public fundingGoalReached = false;\r\n    bool public saleOpened = false;\r\n    \r\n    Payment public kyc;\r\n    Payment public refund;\r\n    Payment public withdrawal;\r\n\r\n    mapping(uint=>address) public indexedFunders;\r\n    mapping(address => Order) public orders;\r\n    uint public funderCount;\r\n    \r\n    event StartSale(uint softCapToken, uint hardCapToken, uint minEther, uint exchangeRate, uint startTime, uint deadline);\r\n    event ReservedToken(address indexed funder, uint amount, uint token, uint bonusRate);\r\n    event WithdrawFunder(address indexed funder, uint value);\r\n    event WithdrawContractToken(address indexed owner, uint value);\r\n    event CheckGoalReached(uint raisedAmount, uint raisedToken, bool reached);\r\n    event CheckOrderstate(address indexed funder, eOrderstate oldState, eOrderstate newState);\r\n    \r\n    enum eOrderstate { NONE, KYC, REFUND }\r\n    \r\n    struct Order {\r\n        eOrderstate state;\r\n        uint paymentEther;\r\n        uint reservedToken;\r\n        bool withdrawn;\r\n    }\r\n    \r\n    struct Payment {\r\n        uint token;\r\n        uint eth;\r\n        uint count;\r\n    }\r\n\r\n    modifier afterSaleDeadline { \r\n        require(now > saleDeadline); \r\n        _; \r\n    }\r\n    \r\n    function AcreSale(\r\n        address _sendEther,\r\n        uint _softCapToken,\r\n        uint _hardCapToken,\r\n        AcreToken _addressOfTokenUsedAsReward\r\n    ) public {\r\n        require(_sendEther != address(0));\r\n        require(_addressOfTokenUsedAsReward != address(0));\r\n        require(_softCapToken > 0 && _softCapToken <= _hardCapToken);\r\n        sendEther = _sendEther;\r\n        softCapToken = _softCapToken * 10 ** uint(TOKEN_DECIMALS);\r\n        hardCapToken = _hardCapToken * 10 ** uint(TOKEN_DECIMALS);\r\n        tokenReward = AcreToken(_addressOfTokenUsedAsReward);\r\n    }\r\n    \r\n    function startSale(uint _durationTime) onlyManagers internal {\r\n        require(softCapToken > 0 && softCapToken <= hardCapToken);\r\n        require(hardCapToken > 0 && hardCapToken <= tokenReward.balanceOf(this));\r\n        require(_durationTime > 0);\r\n        require(startSaleTime == 0);\r\n\r\n        startSaleTime = now;\r\n        saleDeadline = SafeMath.add(startSaleTime, SafeMath.mul(_durationTime, TIME_FACTOR));\r\n        saleOpened = true;\r\n        \r\n        StartSale(softCapToken, hardCapToken, MIN_ETHER, EXCHANGE_RATE, startSaleTime, saleDeadline);\r\n    }\r\n    \r\n    // get\r\n    function getRemainingSellingTime() public constant returns(uint remainingTime) {\r\n        if(now <= saleDeadline) {\r\n            remainingTime = getMinutes(SafeMath.sub(saleDeadline, now));\r\n        }\r\n    }\r\n    \r\n    function getRemainingSellingToken() public constant returns(uint remainingToken) {\r\n        remainingToken = SafeMath.sub(hardCapToken, soldToken);\r\n    }\r\n    \r\n    function getSoftcapReached() public constant returns(bool reachedSoftcap) {\r\n        reachedSoftcap = soldToken >= softCapToken;\r\n    }\r\n    \r\n    function getContractBalanceOf() public constant returns(uint blance) {\r\n        blance = tokenReward.balanceOf(this);\r\n    }\r\n    \r\n    function getCurrentBonusRate() public constant returns(uint8 bonusRate);\r\n    \r\n    // check\r\n    function checkGoalReached() onlyManagers afterSaleDeadline public {\r\n        if(saleOpened) {\r\n            if(getSoftcapReached()) {\r\n                fundingGoalReached = true;\r\n            }\r\n            saleOpened = false;\r\n            CheckGoalReached(receivedEther, soldToken, fundingGoalReached);\r\n        }\r\n    }\r\n    \r\n    function checkKYC(address _funder) onlyManagers afterSaleDeadline public {\r\n        require(!saleOpened);\r\n        require(orders[_funder].reservedToken > 0);\r\n        require(orders[_funder].state != eOrderstate.KYC);\r\n        require(!orders[_funder].withdrawn);\r\n        \r\n        eOrderstate oldState = orders[_funder].state;\r\n        \r\n        // old, decrease\r\n        if(oldState == eOrderstate.REFUND) {\r\n            refund.token = refund.token.sub(orders[_funder].reservedToken);\r\n            refund.eth   = refund.eth.sub(orders[_funder].paymentEther);\r\n            refund.count = refund.count.sub(1);\r\n        }\r\n        \r\n        // state\r\n        orders[_funder].state = eOrderstate.KYC;\r\n        kyc.token = kyc.token.add(orders[_funder].reservedToken);\r\n        kyc.eth   = kyc.eth.add(orders[_funder].paymentEther);\r\n        kyc.count = kyc.count.add(1);\r\n        CheckOrderstate(_funder, oldState, eOrderstate.KYC);\r\n    }\r\n    \r\n    function checkRefund(address _funder) onlyManagers afterSaleDeadline public {\r\n        require(!saleOpened);\r\n        require(orders[_funder].reservedToken > 0);\r\n        require(orders[_funder].state != eOrderstate.REFUND);\r\n        require(!orders[_funder].withdrawn);\r\n        \r\n        eOrderstate oldState = orders[_funder].state;\r\n        \r\n        // old, decrease\r\n        if(oldState == eOrderstate.KYC) {\r\n            kyc.token = kyc.token.sub(orders[_funder].reservedToken);\r\n            kyc.eth   = kyc.eth.sub(orders[_funder].paymentEther);\r\n            kyc.count = kyc.count.sub(1);\r\n        }\r\n        \r\n        // state\r\n        orders[_funder].state = eOrderstate.REFUND;\r\n        refund.token = refund.token.add(orders[_funder].reservedToken);\r\n        refund.eth   = refund.eth.add(orders[_funder].paymentEther);\r\n        refund.count = refund.count.add(1);\r\n        CheckOrderstate(_funder, oldState, eOrderstate.REFUND);\r\n    }\r\n    \r\n    // withdraw\r\n    function withdrawFunder(address _funder) onlyManagers afterSaleDeadline public {\r\n        require(!saleOpened);\r\n        require(fundingGoalReached);\r\n        require(orders[_funder].reservedToken > 0);\r\n        require(orders[_funder].state == eOrderstate.KYC);\r\n        require(!orders[_funder].withdrawn);\r\n        \r\n        // token\r\n        tokenReward.transfer(_funder, orders[_funder].reservedToken);\r\n        withdrawal.token = withdrawal.token.add(orders[_funder].reservedToken);\r\n        withdrawal.eth   = withdrawal.eth.add(orders[_funder].paymentEther);\r\n        withdrawal.count = withdrawal.count.add(1);\r\n        orders[_funder].withdrawn = true;\r\n        WithdrawFunder(_funder, orders[_funder].reservedToken);\r\n    }\r\n    \r\n    function withdrawContractToken(uint _value) onlyManagers public {\r\n        tokenReward.transfer(msg.sender, _value);\r\n        WithdrawContractToken(msg.sender, _value);\r\n    }\r\n    \r\n    // payable\r\n    function () payable public {\r\n        require(saleOpened);\r\n        require(now <= saleDeadline);\r\n        require(MIN_ETHER <= msg.value);\r\n        \r\n        uint amount = msg.value;\r\n        uint curBonusRate = getCurrentBonusRate();\r\n        uint token = (amount.mul(curBonusRate.add(100)).div(100)).mul(EXCHANGE_RATE);\r\n        \r\n        require(token > 0);\r\n        require(SafeMath.add(soldToken, token) <= hardCapToken);\r\n        \r\n        sendEther.transfer(amount);\r\n        \r\n        // funder info\r\n        if(orders[msg.sender].paymentEther == 0) {\r\n            indexedFunders[funderCount] = msg.sender;\r\n            funderCount = funderCount.add(1);\r\n            orders[msg.sender].state = eOrderstate.NONE;\r\n        }\r\n        \r\n        orders[msg.sender].paymentEther = orders[msg.sender].paymentEther.add(amount);\r\n        orders[msg.sender].reservedToken = orders[msg.sender].reservedToken.add(token);\r\n        receivedEther = receivedEther.add(amount);\r\n        soldToken = soldToken.add(token);\r\n        \r\n        ReservedToken(msg.sender, amount, token, curBonusRate);\r\n    }\r\n}\r\n\r\ncontract AcrePresale is AcreSale {\r\n    function AcrePresale(\r\n        address _sendEther,\r\n        uint _softCapToken,\r\n        uint _hardCapToken,\r\n        AcreToken _addressOfTokenUsedAsReward\r\n    ) AcreSale(\r\n        _sendEther,\r\n        _softCapToken, \r\n        _hardCapToken, \r\n        _addressOfTokenUsedAsReward) public {\r\n    }\r\n    \r\n    function startPresale() onlyManagers public {\r\n        startSale(PRESALE_DURATION_TIME);\r\n    }\r\n    \r\n    function getCurrentBonusRate() public constant returns(uint8 bonusRate) {\r\n        if      (now <= SafeMath.add(startSaleTime, SafeMath.mul( 7, TIME_FACTOR))) { bonusRate = 30; } // 7days  \r\n        else if (now <= SafeMath.add(startSaleTime, SafeMath.mul(15, TIME_FACTOR))) { bonusRate = 25; } // 8days\r\n        else                                                                        { bonusRate = 0; }  // \r\n    } \r\n}\r\n\r\ncontract AcreCrowdsale is AcreSale {\r\n    function AcreCrowdsale(\r\n        address _sendEther,\r\n        uint _softCapToken,\r\n        uint _hardCapToken,\r\n        AcreToken _addressOfTokenUsedAsReward\r\n    ) AcreSale(\r\n        _sendEther,\r\n        _softCapToken, \r\n        _hardCapToken, \r\n        _addressOfTokenUsedAsReward) public {\r\n    }\r\n    \r\n    function startCrowdsale() onlyManagers public {\r\n        startSale(CROWDSALE_DURATION_TIME);\r\n    }\r\n    \r\n    function getCurrentBonusRate() public constant returns(uint8 bonusRate) {\r\n        if      (now <= SafeMath.add(startSaleTime, SafeMath.mul( 7, TIME_FACTOR))) { bonusRate = 20; } // 7days\r\n        else if (now <= SafeMath.add(startSaleTime, SafeMath.mul(15, TIME_FACTOR))) { bonusRate = 15; } // 8days\r\n        else if (now <= SafeMath.add(startSaleTime, SafeMath.mul(23, TIME_FACTOR))) { bonusRate = 10; } // 8days\r\n        else                                                                        { bonusRate = 0; }  // \r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"checkGoalReached\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"funderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sendEther\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"grantOwners\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelOwnership\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refund\",\"outputs\":[{\"name\":\"token\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSoftcapReached\",\"outputs\":[{\"name\":\"reachedSoftcap\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleOpened\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_funder\",\"type\":\"address\"}],\"name\":\"checkRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_funder\",\"type\":\"address\"}],\"name\":\"checkKYC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"reserveOwnership\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingSellingToken\",\"outputs\":[{\"name\":\"remainingToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyc\",\"outputs\":[{\"name\":\"token\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexedFunders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownershipDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawContractToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startSaleTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingSellingTime\",\"outputs\":[{\"name\":\"remainingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalanceOf\",\"outputs\":[{\"name\":\"blance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"revokeOwners\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBonusRate\",\"outputs\":[{\"name\":\"bonusRate\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receivedEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawal\",\"outputs\":[{\"name\":\"token\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_funder\",\"type\":\"address\"}],\"name\":\"withdrawFunder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"paymentEther\",\"type\":\"uint256\"},{\"name\":\"reservedToken\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_sendEther\",\"type\":\"address\"},{\"name\":\"_softCapToken\",\"type\":\"uint256\"},{\"name\":\"_hardCapToken\",\"type\":\"uint256\"},{\"name\":\"_addressOfTokenUsedAsReward\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"softCapToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"StartSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusRate\",\"type\":\"uint256\"}],\"name\":\"ReservedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawFunder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawContractToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"raisedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"raisedToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reached\",\"type\":\"bool\"}],\"name\":\"CheckGoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"CheckOrderstate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"GrantOwners\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RevokeOwners\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ReserveOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ConfirmOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"CancelOwnership\",\"type\":\"event\"}]","ContractName":"AcrePresale","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000234e2e6e293a86aeb970014bd1d511ab78485a4f00000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000005f5e1000000000000000000000000000dd644300b9cc67917d09ae4bee413e600304266","Library":"","SwarmSource":"bzzr://aa52846e52694f2580aae3718aba898478164813a88dc76eaa5cf920d8ff07c5"}]}