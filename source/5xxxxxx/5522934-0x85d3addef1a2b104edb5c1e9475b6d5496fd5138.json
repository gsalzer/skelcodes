{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract DSSafeAddSub {\r\n    function safeToAdd(uint a, uint b) internal returns (bool) {\r\n        return (a + b >= a);\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        if (!safeToAdd(a, b)) throw;\r\n        return a + b;\r\n    }\r\n\r\n    function safeToSubtract(uint a, uint b) internal returns (bool) {\r\n        return (b <= a);\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        if (!safeToSubtract(a, b)) throw;\r\n        return a - b;\r\n    }\r\n}\r\n\r\n\r\ncontract LuckyDice is DSSafeAddSub {\r\n\r\n    /*\r\n     * bet size >= minBet, minNumber < minRollLimit < maxRollLimit - 1 < maxNumber\r\n    */\r\n    modifier betIsValid(uint _betSize, uint minRollLimit, uint maxRollLimit) {\r\n        if (_betSize < minBet || maxRollLimit < minNumber || minRollLimit > maxNumber || maxRollLimit - 1 <= minRollLimit) throw;\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * checks game is currently active\r\n    */\r\n    modifier gameIsActive {\r\n        if (gamePaused == true) throw;\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * checks payouts are currently active\r\n    */\r\n    modifier payoutsAreActive {\r\n        if (payoutsPaused == true) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    /*\r\n     * checks only owner address is calling\r\n    */\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * checks only treasury address is calling\r\n    */\r\n    modifier onlyCasino {\r\n        if (msg.sender != casino) throw;\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * probabilities\r\n    */\r\n    uint[] rollSumProbability = [0, 0, 0, 0, 0, 128600, 643004, 1929012, 4501028, 9002057, 16203703, 26363168, 39223251, 54012345, 69444444, 83719135, 94521604, 100308641, 100308641, 94521604, 83719135, 69444444, 54012345, 39223251, 26363168, 16203703, 9002057, 4501028, 1929012, 643004, 128600];\r\n    uint probabilityDivisor = 10000000;\r\n\r\n    /*\r\n     * game vars\r\n    */\r\n    uint constant public houseEdgeDivisor = 1000;\r\n    uint constant public maxNumber = 30;\r\n    uint constant public minNumber = 5;\r\n    bool public gamePaused;\r\n    address public owner;\r\n    bool public payoutsPaused;\r\n    address public casino;\r\n    uint public contractBalance;\r\n    uint public houseEdge;\r\n    uint public maxProfit;\r\n    uint public minBet;\r\n    int public totalBets;\r\n    uint public maxPendingPayouts;\r\n    uint public totalWeiWon = 0;\r\n    uint public totalWeiWagered = 0;\r\n\r\n    // JP\r\n    uint public jackpot = 0;\r\n    uint public jpPercentage = 40; // = 4%\r\n    uint public jpPercentageDivisor = 1000;\r\n    uint public jpMinBet = 10000000000000000; // = 0.01 Eth\r\n\r\n    // TEMP\r\n    uint tempDiceSum;\r\n    bool tempJp;\r\n    uint tempDiceValue;\r\n    bytes tempRollResult;\r\n    uint tempFullprofit;\r\n    bytes32 tempBetHash;\r\n\r\n    /*\r\n     * player vars\r\n    */\r\n    mapping(bytes32 => address) public playerAddress;\r\n    mapping(bytes32 => address) playerTempAddress;\r\n    mapping(bytes32 => bytes32) playerBetDiceRollHash;\r\n    mapping(bytes32 => uint) playerBetValue;\r\n    mapping(bytes32 => uint) playerTempBetValue;\r\n    mapping(bytes32 => uint) playerRollResult;\r\n    mapping(bytes32 => uint) playerMaxRollLimit;\r\n    mapping(bytes32 => uint) playerMinRollLimit;\r\n    mapping(address => uint) playerPendingWithdrawals;\r\n    mapping(bytes32 => uint) playerProfit;\r\n    mapping(bytes32 => uint) playerToJackpot;\r\n    mapping(bytes32 => uint) playerTempReward;\r\n\r\n    /*\r\n     * events\r\n    */\r\n    /* log bets + output to web3 for precise 'payout on win' field in UI */\r\n    event LogBet(bytes32 indexed DiceRollHash, address indexed PlayerAddress, uint ProfitValue, uint ToJpValue,\r\n        uint BetValue, uint minRollLimit, uint maxRollLimit);\r\n\r\n    /* output to web3 UI on bet result*/\r\n    /* Status: 0=lose, 1=win, 2=win + failed send, 3=refund, 4=refund + failed send*/\r\n    event LogResult(bytes32 indexed DiceRollHash, address indexed PlayerAddress, uint minRollLimit, uint maxRollLimit,\r\n        uint DiceResult, uint Value, string Salt, int Status);\r\n\r\n    /* log manual refunds */\r\n    event LogRefund(bytes32 indexed DiceRollHash, address indexed PlayerAddress, uint indexed RefundValue);\r\n\r\n    /* log owner transfers */\r\n    event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\r\n\r\n    // jp logging\r\n    // Status: 0=win JP, 1=failed send\r\n    event LogJpPayment(bytes32 indexed DiceRollHash, address indexed PlayerAddress, uint DiceResult, uint JackpotValue,\r\n        int Status);\r\n\r\n\r\n    /*\r\n     * init\r\n    */\r\n    function LuckyDice() {\r\n\r\n        owner = msg.sender;\r\n        casino = msg.sender;\r\n\r\n        /* init 960 = 96% (4% houseEdge)*/\r\n        ownerSetHouseEdge(960);\r\n\r\n        /* 0.5 ether  */\r\n        ownerSetMaxProfit(500000000000000000);\r\n\r\n        /* init min bet (0.1 ether) */\r\n        ownerSetMinBet(100000000000000000);\r\n    }\r\n\r\n    /*\r\n     * public function\r\n     * player submit bet\r\n     * only if game is active & bet is valid\r\n    */\r\n    function playerMakeBet(uint minRollLimit, uint maxRollLimit, bytes32 diceRollHash, uint8 v, bytes32 r, bytes32 s) public\r\n    payable\r\n    gameIsActive\r\n    betIsValid(msg.value, minRollLimit, maxRollLimit)\r\n    {\r\n        /* checks if bet was already made */\r\n        if (playerBetDiceRollHash[diceRollHash] != 0x0 || diceRollHash == 0x0) throw;\r\n\r\n        /* checks bet sign */\r\n        tempBetHash = sha256(diceRollHash, byte(minRollLimit), byte(maxRollLimit), msg.sender);\r\n        if (casino != ecrecover(tempBetHash, v, r, s)) throw;\r\n\r\n        tempFullprofit = getFullProfit(msg.value, minRollLimit, maxRollLimit);\r\n        playerProfit[diceRollHash] = getProfit(msg.value, tempFullprofit);\r\n        playerToJackpot[diceRollHash] = getToJackpot(msg.value, tempFullprofit);\r\n        if (playerProfit[diceRollHash] - playerToJackpot[diceRollHash] > maxProfit)\r\n            throw;\r\n\r\n        /* map bet id to serverSeedHash */\r\n        playerBetDiceRollHash[diceRollHash] = diceRollHash;\r\n        /* map player limit to serverSeedHash */\r\n        playerMinRollLimit[diceRollHash] = minRollLimit;\r\n        playerMaxRollLimit[diceRollHash] = maxRollLimit;\r\n        /* map value of wager to serverSeedHash */\r\n        playerBetValue[diceRollHash] = msg.value;\r\n        /* map player address to serverSeedHash */\r\n        playerAddress[diceRollHash] = msg.sender;\r\n        /* safely increase maxPendingPayouts liability - calc all pending payouts under assumption they win */\r\n        maxPendingPayouts = safeAdd(maxPendingPayouts, playerProfit[diceRollHash]);\r\n\r\n\r\n        /* check contract can payout on win */\r\n        if (maxPendingPayouts >= contractBalance)\r\n            throw;\r\n\r\n        /* provides accurate numbers for web3 and allows for manual refunds in case of any error */\r\n        LogBet(diceRollHash, playerAddress[diceRollHash], playerProfit[diceRollHash], playerToJackpot[diceRollHash],\r\n            playerBetValue[diceRollHash], playerMinRollLimit[diceRollHash], playerMaxRollLimit[diceRollHash]);\r\n    }\r\n\r\n    function getFullProfit(uint _betSize, uint minRollLimit, uint maxRollLimit) internal returns (uint){\r\n        uint probabilitySum = 0;\r\n        for (uint i = minRollLimit + 1; i < maxRollLimit; i++)\r\n        {\r\n            probabilitySum += rollSumProbability[i];\r\n        }\r\n\r\n        return _betSize * safeSub(probabilityDivisor * 100, probabilitySum) / probabilitySum;\r\n    }\r\n\r\n    function getProfit(uint _betSize, uint fullProfit) internal returns (uint){\r\n        return (fullProfit + _betSize) * houseEdge / houseEdgeDivisor - _betSize;\r\n    }\r\n\r\n    function getToJackpot(uint _betSize, uint fullProfit) internal returns (uint){\r\n        return (fullProfit + _betSize) * jpPercentage / jpPercentageDivisor;\r\n    }\r\n\r\n    function withdraw(bytes32 diceRollHash, string rollResult, string salt) public\r\n    payoutsAreActive\r\n    {\r\n        /* player address mapped to query id does not exist */\r\n        if (playerAddress[diceRollHash] == 0x0) throw;\r\n\r\n        /* checks hash */\r\n        bytes32 hash = sha256(rollResult, salt);\r\n        if (diceRollHash != hash) throw;\r\n\r\n        /* get the playerAddress for this query id */\r\n        playerTempAddress[diceRollHash] = playerAddress[diceRollHash];\r\n        /* delete playerAddress for this query id */\r\n        delete playerAddress[diceRollHash];\r\n\r\n        /* map the playerProfit for this query id */\r\n        playerTempReward[diceRollHash] = playerProfit[diceRollHash];\r\n        /* set  playerProfit for this query id to 0 */\r\n        playerProfit[diceRollHash] = 0;\r\n\r\n        /* safely reduce maxPendingPayouts liability */\r\n        maxPendingPayouts = safeSub(maxPendingPayouts, playerTempReward[diceRollHash]);\r\n\r\n        /* map the playerBetValue for this query id */\r\n        playerTempBetValue[diceRollHash] = playerBetValue[diceRollHash];\r\n        /* set  playerBetValue for this query id to 0 */\r\n        playerBetValue[diceRollHash] = 0;\r\n\r\n        /* total number of bets */\r\n        totalBets += 1;\r\n\r\n        /* total wagered */\r\n        totalWeiWagered += playerTempBetValue[diceRollHash];\r\n\r\n        tempDiceSum = 0;\r\n        tempJp = true;\r\n        tempRollResult = bytes(rollResult);\r\n        for (uint i = 0; i < 5; i++) {\r\n            tempDiceValue = uint(tempRollResult[i]) - 48;\r\n            tempDiceSum += tempDiceValue;\r\n            playerRollResult[diceRollHash] = playerRollResult[diceRollHash] * 10 + tempDiceValue;\r\n\r\n            if (tempRollResult[i] != tempRollResult[1]) {\r\n                tempJp = false;\r\n            }\r\n        }\r\n\r\n        /*\r\n        * CONGRATULATIONS!!! SOMEBODY WON JP!\r\n        */\r\n        if (playerTempBetValue[diceRollHash] >= jpMinBet && tempJp) {\r\n            LogJpPayment(playerBetDiceRollHash[diceRollHash], playerTempAddress[diceRollHash],\r\n                playerRollResult[diceRollHash], jackpot, 0);\r\n\r\n            uint jackpotTmp = jackpot;\r\n            jackpot = 0;\r\n\r\n            if (!playerTempAddress[diceRollHash].send(jackpotTmp)) {\r\n                LogJpPayment(playerBetDiceRollHash[diceRollHash], playerTempAddress[diceRollHash],\r\n                    playerRollResult[diceRollHash], jackpotTmp, 1);\r\n\r\n                /* if send failed let player withdraw via playerWithdrawPendingTransactions */\r\n                playerPendingWithdrawals[playerTempAddress[diceRollHash]] =\r\n                safeAdd(playerPendingWithdrawals[playerTempAddress[diceRollHash]], jackpotTmp);\r\n            }\r\n        }\r\n\r\n        /*\r\n        * pay winner\r\n        * update contract balance to calculate new max bet\r\n        * send reward\r\n        * if send of reward fails save value to playerPendingWithdrawals\r\n        */\r\n        if (playerMinRollLimit[diceRollHash] < tempDiceSum && tempDiceSum < playerMaxRollLimit[diceRollHash]) {\r\n            /* safely reduce contract balance by player profit */\r\n            contractBalance = safeSub(contractBalance, playerTempReward[diceRollHash]);\r\n\r\n            /* update total wei won */\r\n            totalWeiWon = safeAdd(totalWeiWon, playerTempReward[diceRollHash]);\r\n\r\n            // adding JP percentage\r\n            playerTempReward[diceRollHash] = safeSub(playerTempReward[diceRollHash], playerToJackpot[diceRollHash]);\r\n            jackpot = safeAdd(jackpot, playerToJackpot[diceRollHash]);\r\n\r\n            /* safely calculate payout via profit plus original wager */\r\n            playerTempReward[diceRollHash] = safeAdd(playerTempReward[diceRollHash], playerTempBetValue[diceRollHash]);\r\n\r\n            LogResult(playerBetDiceRollHash[diceRollHash], playerTempAddress[diceRollHash],\r\n                playerMinRollLimit[diceRollHash], playerMaxRollLimit[diceRollHash], playerRollResult[diceRollHash],\r\n                playerTempReward[diceRollHash], salt, 1);\r\n\r\n            /*\r\n            * send win - external call to an untrusted contract\r\n            * if send fails map reward value to playerPendingWithdrawals[address]\r\n            * for withdrawal later via playerWithdrawPendingTransactions\r\n            */\r\n            if (!playerTempAddress[diceRollHash].send(playerTempReward[diceRollHash])) {\r\n                LogResult(playerBetDiceRollHash[diceRollHash], playerTempAddress[diceRollHash],\r\n                    playerMinRollLimit[diceRollHash], playerMaxRollLimit[diceRollHash], playerRollResult[diceRollHash],\r\n                    playerTempReward[diceRollHash], salt, 2);\r\n\r\n                /* if send failed let player withdraw via playerWithdrawPendingTransactions */\r\n                playerPendingWithdrawals[playerTempAddress[diceRollHash]] =\r\n                safeAdd(playerPendingWithdrawals[playerTempAddress[diceRollHash]], playerTempReward[diceRollHash]);\r\n            }\r\n\r\n            return;\r\n\r\n        } else {\r\n            /*\r\n            * no win\r\n            * update contract balance to calculate new max bet\r\n            */\r\n\r\n            LogResult(playerBetDiceRollHash[diceRollHash], playerTempAddress[diceRollHash],\r\n                playerMinRollLimit[diceRollHash], playerMaxRollLimit[diceRollHash], playerRollResult[diceRollHash],\r\n                playerTempBetValue[diceRollHash], salt, 0);\r\n\r\n            /*\r\n            *  safe adjust contractBalance\r\n            */\r\n            contractBalance = safeAdd(contractBalance, (playerTempBetValue[diceRollHash]));\r\n\r\n            return;\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n    * public function\r\n    * in case of a failed refund or win send\r\n    */\r\n    function playerWithdrawPendingTransactions() public\r\n    payoutsAreActive\r\n    returns (bool)\r\n    {\r\n        uint withdrawAmount = playerPendingWithdrawals[msg.sender];\r\n        playerPendingWithdrawals[msg.sender] = 0;\r\n        /* external call to untrusted contract */\r\n        if (msg.sender.call.value(withdrawAmount)()) {\r\n            return true;\r\n        } else {\r\n            /* if send failed revert playerPendingWithdrawals[msg.sender] = 0; */\r\n            /* player can try to withdraw again later */\r\n            playerPendingWithdrawals[msg.sender] = withdrawAmount;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* check for pending withdrawals  */\r\n    function playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) {\r\n        return playerPendingWithdrawals[addressToCheck];\r\n    }\r\n\r\n    /*\r\n    * owner address only functions\r\n    */\r\n    function()\r\n    payable\r\n    onlyOwner\r\n    {\r\n        /* safely update contract balance */\r\n        contractBalance = safeAdd(contractBalance, msg.value);\r\n    }\r\n\r\n\r\n    /* only owner adjust contract balance variable (only used for max profit calc) */\r\n    function ownerUpdateContractBalance(uint newContractBalanceInWei) public\r\n    onlyOwner\r\n    {\r\n        contractBalance = newContractBalanceInWei;\r\n    }\r\n\r\n    /* only owner address can set houseEdge */\r\n    function ownerSetHouseEdge(uint newHouseEdge) public\r\n    onlyOwner\r\n    {\r\n        houseEdge = newHouseEdge;\r\n    }\r\n\r\n    /* only owner address can set maxProfit*/\r\n    function ownerSetMaxProfit(uint newMaxProfit) public\r\n    onlyOwner\r\n    {\r\n        maxProfit = newMaxProfit;\r\n    }\r\n\r\n    /* only owner address can set minBet */\r\n    function ownerSetMinBet(uint newMinimumBet) public\r\n    onlyOwner\r\n    {\r\n        minBet = newMinimumBet;\r\n    }\r\n\r\n    /* only owner address can set jpMinBet */\r\n    function ownerSetJpMinBet(uint newJpMinBet) public\r\n    onlyOwner\r\n    {\r\n        jpMinBet = newJpMinBet;\r\n    }\r\n\r\n    /* only owner address can transfer ether */\r\n    function ownerTransferEther(address sendTo, uint amount) public\r\n    onlyOwner\r\n    {\r\n        /* safely update contract balance when sending out funds*/\r\n        contractBalance = safeSub(contractBalance, amount);\r\n        if (!sendTo.send(amount)) throw;\r\n        LogOwnerTransfer(sendTo, amount);\r\n    }\r\n\r\n    /* only owner address can do manual refund\r\n    * used only if bet placed + server error had a place\r\n    * filter LogBet by address and/or diceRollHash\r\n    * check the following logs do not exist for diceRollHash and/or playerAddress[diceRollHash] before refunding:\r\n    * LogResult or LogRefund\r\n    * if LogResult exists player should use the withdraw pattern playerWithdrawPendingTransactions\r\n    */\r\n    function ownerRefundPlayer(bytes32 diceRollHash, address sendTo, uint originalPlayerProfit, uint originalPlayerBetValue) public\r\n    onlyOwner\r\n    {\r\n        /* safely reduce pendingPayouts by playerProfit[rngId] */\r\n        maxPendingPayouts = safeSub(maxPendingPayouts, originalPlayerProfit);\r\n        /* send refund */\r\n        if (!sendTo.send(originalPlayerBetValue)) throw;\r\n        /* log refunds */\r\n        LogRefund(diceRollHash, sendTo, originalPlayerBetValue);\r\n    }\r\n\r\n    /* only owner address can set emergency pause #1 */\r\n    function ownerPauseGame(bool newStatus) public\r\n    onlyOwner\r\n    {\r\n        gamePaused = newStatus;\r\n    }\r\n\r\n    /* only owner address can set emergency pause #2 */\r\n    function ownerPausePayouts(bool newPayoutStatus) public\r\n    onlyOwner\r\n    {\r\n        payoutsPaused = newPayoutStatus;\r\n    }\r\n\r\n    /* only owner address can set casino address */\r\n    function ownerSetCasino(address newCasino) public\r\n    onlyOwner\r\n    {\r\n        casino = newCasino;\r\n    }\r\n\r\n    /* only owner address can set owner address */\r\n    function ownerChangeOwner(address newOwner) public\r\n    onlyOwner\r\n    {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /* only owner address can suicide - emergency */\r\n    function ownerkill() public\r\n    onlyOwner\r\n    {\r\n        suicide(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"jpPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCasino\",\"type\":\"address\"}],\"name\":\"ownerSetCasino\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseEdge\",\"type\":\"uint256\"}],\"name\":\"ownerSetHouseEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutsPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addressToCheck\",\"type\":\"address\"}],\"name\":\"playerGetPendingTxByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContractBalanceInWei\",\"type\":\"uint256\"}],\"name\":\"ownerUpdateContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPayoutStatus\",\"type\":\"bool\"}],\"name\":\"ownerPausePayouts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jpMinBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumBet\",\"type\":\"uint256\"}],\"name\":\"ownerSetMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minRollLimit\",\"type\":\"uint256\"},{\"name\":\"maxRollLimit\",\"type\":\"uint256\"},{\"name\":\"diceRollHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"playerMakeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sendTo\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ownerTransferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"casino\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newJpMinBet\",\"type\":\"uint256\"}],\"name\":\"ownerSetJpMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"playerWithdrawPendingTransactions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jpPercentageDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"diceRollHash\",\"type\":\"bytes32\"},{\"name\":\"sendTo\",\"type\":\"address\"},{\"name\":\"originalPlayerProfit\",\"type\":\"uint256\"},{\"name\":\"originalPlayerBetValue\",\"type\":\"uint256\"}],\"name\":\"ownerRefundPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerkill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxProfit\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"playerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdgeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPendingPayouts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"diceRollHash\",\"type\":\"bytes32\"},{\"name\":\"rollResult\",\"type\":\"string\"},{\"name\":\"salt\",\"type\":\"string\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"DiceRollHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"PlayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ProfitValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ToJpValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"BetValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minRollLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxRollLimit\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"DiceRollHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"PlayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minRollLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxRollLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"DiceResult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Salt\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"Status\",\"type\":\"int256\"}],\"name\":\"LogResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"DiceRollHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"PlayerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"RefundValue\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"SentToAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"AmountTransferred\",\"type\":\"uint256\"}],\"name\":\"LogOwnerTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"DiceRollHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"PlayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"DiceResult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"JackpotValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Status\",\"type\":\"int256\"}],\"name\":\"LogJpPayment\",\"type\":\"event\"}]","ContractName":"LuckyDice","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6911476ed3f82e9f0aae701706e586a1743c16ba43b699ebe291e1b938cbef39"}]}