{"status":"1","message":"OK","result":[{"SourceCode":"//File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\lifecycle\\Pausable.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\SafeERC20.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\CanReclaimToken.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic token) external onlyOwner {\r\n    uint256 balance = token.balanceOf(this);\r\n    token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n//File: contracts\\ico\\KYCBase.sol\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n// Abstract base contract\r\ncontract KYCBase {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => bool) public isKycSigner;\r\n    mapping (uint64 => uint256) public alreadyPayed;\r\n\r\n    event KycVerified(address indexed signer, address buyerAddress, uint64 buyerId, uint maxAmount);\r\n\r\n    constructor(address[] kycSigners) internal {\r\n        for (uint i = 0; i < kycSigners.length; i++) {\r\n            isKycSigner[kycSigners[i]] = true;\r\n        }\r\n    }\r\n\r\n    // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed\r\n    function releaseTokensTo(address buyer) internal returns(bool);\r\n\r\n    // This method can be overridden to enable some sender to buy token for a different address\r\n    function senderAllowedFor(address buyer)\r\n    internal view returns(bool)\r\n    {\r\n        return buyer == msg.sender;\r\n    }\r\n\r\n    function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\r\n    public payable returns (bool)\r\n    {\r\n        require(senderAllowedFor(buyerAddress));\r\n        return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s);\r\n    }\r\n\r\n    function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\r\n    public payable returns (bool)\r\n    {\r\n        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\r\n    }\r\n\r\n    function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\r\n    private returns (bool)\r\n    {\r\n        // check the signature\r\n        bytes32 hash = sha256(abi.encodePacked(\"Eidoo icoengine authorization\", this, buyerAddress, buyerId, maxAmount));\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (!isKycSigner[signer]) {\r\n            revert();\r\n        } else {\r\n            uint256 totalPayed = alreadyPayed[buyerId].add(msg.value);\r\n            require(totalPayed <= maxAmount);\r\n            alreadyPayed[buyerId] = totalPayed;\r\n            emit KycVerified(signer, buyerAddress, buyerId, maxAmount);\r\n            return releaseTokensTo(buyerAddress);\r\n        }\r\n    }\r\n\r\n    // No payable fallback function, the tokens must be buyed using the functions buyTokens and buyTokensFor\r\n    function () public {\r\n        revert();\r\n    }\r\n}\r\n//File: contracts\\ico\\ICOEngineInterface.sol\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ICOEngineInterface {\r\n\r\n    // false if the ico is not started, true if the ico is started and running, true if the ico is completed\r\n    function started() public view returns(bool);\r\n\r\n    // false if the ico is not started, false if the ico is started and running, true if the ico is completed\r\n    function ended() public view returns(bool);\r\n\r\n    // time stamp of the starting time of the ico, must return 0 if it depends on the block number\r\n    function startTime() public view returns(uint);\r\n\r\n    // time stamp of the ending time of the ico, must retrun 0 if it depends on the block number\r\n    function endTime() public view returns(uint);\r\n\r\n    // Optional function, can be implemented in place of startTime\r\n    // Returns the starting block number of the ico, must return 0 if it depends on the time stamp\r\n    // function startBlock() public view returns(uint);\r\n\r\n    // Optional function, can be implemented in place of endTime\r\n    // Returns theending block number of the ico, must retrun 0 if it depends on the time stamp\r\n    // function endBlock() public view returns(uint);\r\n\r\n    // returns the total number of the tokens available for the sale, must not change when the ico is started\r\n    function totalTokens() public view returns(uint);\r\n\r\n    // returns the number of the tokens available for the ico. At the moment that the ico starts it must be equal to totalTokens(),\r\n    // then it will decrease. It is used to calculate the percentage of sold tokens as remainingTokens() / totalTokens()\r\n    function remainingTokens() public view returns(uint);\r\n\r\n    // return the price as number of tokens released for each ether\r\n    function price() public view returns(uint);\r\n}\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\MintableToken.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    hasMintPermission\r\n    canMint\r\n    public\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\PausableToken.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}\r\n\r\n//File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BurnableToken.sol\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\n//File: contracts\\ico\\GotToken.sol\r\n/**\r\n * @title ParkinGO token\r\n *\r\n * @version 1.0\r\n * @author ParkinGO\r\n */\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract GotToken is CanReclaimToken, MintableToken, PausableToken, BurnableToken {\r\n    string public constant name = \"GOToken\";\r\n    string public constant symbol = \"GOT\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    /**\r\n     * @dev Constructor of GotToken that instantiates a new Mintable Pausable Token\r\n     */\r\n    constructor() public {\r\n        // token should not be transferable until after all tokens have been issued\r\n        paused = true;\r\n    }\r\n}\r\n\r\n\r\n//File: contracts\\ico\\PGOVault.sol\r\n/**\r\n * @title PGOVault\r\n * @dev A token holder contract that allows the release of tokens to the ParkinGo Wallet.\r\n *\r\n * @version 1.0\r\n * @author ParkinGo\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PGOVault {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for GotToken;\r\n\r\n    uint256[4] public vesting_offsets = [\r\n        360 days,\r\n        540 days,\r\n        720 days,\r\n        900 days\r\n    ];\r\n\r\n    uint256[4] public vesting_amounts = [\r\n        0.875e7 * 1e18,\r\n        0.875e7 * 1e18,\r\n        0.875e7 * 1e18,\r\n        0.875e7 * 1e18\r\n    ];\r\n\r\n    address public pgoWallet;\r\n    GotToken public token;\r\n    uint256 public start;\r\n    uint256 public released;\r\n    uint256 public vestingOffsetsLength = vesting_offsets.length;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _pgoWallet The address that will receive the vested tokens.\r\n     * @param _token The GOT Token, which is being vested.\r\n     * @param _start The start time from which each release time will be calculated.\r\n     */\r\n    constructor(\r\n        address _pgoWallet,\r\n        address _token,\r\n        uint256 _start\r\n    )\r\n        public\r\n    {\r\n        pgoWallet = _pgoWallet;\r\n        token = GotToken(_token);\r\n        start = _start;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers vested tokens to ParkinGo Wallet.\r\n     */\r\n    function release() public {\r\n        uint256 unreleased = releasableAmount();\r\n        require(unreleased > 0);\r\n\r\n        released = released.add(unreleased);\r\n\r\n        token.safeTransfer(pgoWallet, unreleased);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     */\r\n    function releasableAmount() public view returns (uint256) {\r\n        return vestedAmount().sub(released);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     */\r\n    function vestedAmount() public view returns (uint256) {\r\n        uint256 vested = 0;\r\n        for (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) {\r\n            if (block.timestamp > start.add(vesting_offsets[i])) {\r\n                vested = vested.add(vesting_amounts[i]);\r\n            }\r\n        }\r\n        return vested;\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculates the amount that has not yet released.\r\n     */\r\n    function unreleasedAmount() public view returns (uint256) {\r\n        uint256 unreleased = 0;\r\n        for (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) {\r\n            unreleased = unreleased.add(vesting_amounts[i]);\r\n        }\r\n        return unreleased.sub(released);\r\n    }\r\n}\r\n\r\n\r\n//File: contracts\\ico\\PGOMonthlyInternalVault.sol\r\n/**\r\n * @title PGOMonthlyVault\r\n * @dev A token holder contract that allows the release of tokens after a vesting period.\r\n *\r\n * @version 1.0\r\n * @author ParkinGO\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PGOMonthlyInternalVault {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for GotToken;\r\n\r\n    struct Investment {\r\n        address beneficiary;\r\n        uint256 totalBalance;\r\n        uint256 released;\r\n    }\r\n\r\n    /*** CONSTANTS ***/\r\n    uint256 public constant VESTING_DIV_RATE = 21;                  // division rate of monthly vesting\r\n    uint256 public constant VESTING_INTERVAL = 30 days;             // vesting interval\r\n    uint256 public constant VESTING_CLIFF = 90 days;                // duration until cliff is reached\r\n    uint256 public constant VESTING_DURATION = 720 days;            // vesting duration\r\n\r\n    GotToken public token;\r\n    uint256 public start;\r\n    uint256 public end;\r\n    uint256 public cliff;\r\n\r\n    //Investment[] public investments;\r\n\r\n    // key: investor address; value: index in investments array.\r\n    //mapping(address => uint256) public investorLUT;\r\n\r\n    mapping(address => Investment) public investments;\r\n\r\n    /**\r\n     * @dev Function to be fired by the initPGOMonthlyInternalVault function from the GotCrowdSale contract to set the\r\n     * InternalVault's state after deployment.\r\n     * @param beneficiaries Array of the internal investors addresses to whom vested tokens are transferred.\r\n     * @param balances Array of token amount per beneficiary.\r\n     * @param startTime Start time at which the first released will be executed, and from which the cliff for second\r\n     * release is calculated.\r\n     * @param _token The address of the GOT Token.\r\n     */\r\n    function init(address[] beneficiaries, uint256[] balances, uint256 startTime, address _token) public {\r\n        // makes sure this function is only called once\r\n        require(token == address(0));\r\n        require(beneficiaries.length == balances.length);\r\n\r\n        start = startTime;\r\n        cliff = start.add(VESTING_CLIFF);\r\n        end = start.add(VESTING_DURATION);\r\n\r\n        token = GotToken(_token);\r\n\r\n        for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) {\r\n            investments[beneficiaries[i]] = Investment(beneficiaries[i], balances[i], 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allows a sender to transfer vested tokens to the beneficiary's address.\r\n     * @param beneficiary The address that will receive the vested tokens.\r\n     */\r\n    function release(address beneficiary) public {\r\n        uint256 unreleased = releasableAmount(beneficiary);\r\n        require(unreleased > 0);\r\n\r\n        investments[beneficiary].released = investments[beneficiary].released.add(unreleased);\r\n        token.safeTransfer(beneficiary, unreleased);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers vested tokens to the sender's address.\r\n     */\r\n    function release() public {\r\n        release(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to check an investment.\r\n     * @param beneficiary The address of the beneficiary of the investment to check.\r\n     */\r\n    function getInvestment(address beneficiary) public view returns(address, uint256, uint256) {\r\n        return (\r\n            investments[beneficiary].beneficiary,\r\n            investments[beneficiary].totalBalance,\r\n            investments[beneficiary].released\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     * @param beneficiary The address that will receive the vested tokens.\r\n     */\r\n    function releasableAmount(address beneficiary) public view returns (uint256) {\r\n        return vestedAmount(beneficiary).sub(investments[beneficiary].released);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     * @param beneficiary The address that will receive the vested tokens.\r\n     */\r\n    function vestedAmount(address beneficiary) public view returns (uint256) {\r\n        uint256 vested = 0;\r\n        if (block.timestamp >= cliff && block.timestamp < end) {\r\n            // after cliff -> 1/21 of totalBalance every month, must skip first 3 months\r\n            uint256 totalBalance = investments[beneficiary].totalBalance;\r\n            uint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE);\r\n            uint256 time = block.timestamp.sub(cliff);\r\n            uint256 elapsedOffsets = time.div(VESTING_INTERVAL);\r\n            uint256 vestedToSum = elapsedOffsets.mul(monthlyBalance);\r\n            vested = vested.add(vestedToSum);\r\n        }\r\n        if (block.timestamp >= end) {\r\n            // after end -> all vested\r\n            vested = investments[beneficiary].totalBalance;\r\n        }\r\n        return vested;\r\n    }\r\n}\r\n\r\n\r\n//File: contracts\\ico\\PGOMonthlyPresaleVault.sol\r\n/**\r\n * @title PGOMonthlyVault\r\n * @dev A token holder contract that allows the release of tokens after a vesting period.\r\n *\r\n * @version 1.0\r\n * @author ParkinGO\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PGOMonthlyPresaleVault is PGOMonthlyInternalVault {\r\n    /**\r\n     * @dev OVERRIDE vestedAmount from PGOMonthlyInternalVault\r\n     * Calculates the amount that has already vested, release 1/3 of token immediately.\r\n     * @param beneficiary The address that will receive the vested tokens.\r\n     */\r\n    function vestedAmount(address beneficiary) public view returns (uint256) {\r\n        uint256 vested = 0;\r\n\r\n        if (block.timestamp >= start) {\r\n            // after start -> 1/3 released (fixed)\r\n            vested = investments[beneficiary].totalBalance.div(3);\r\n        }\r\n        if (block.timestamp >= cliff && block.timestamp < end) {\r\n            // after cliff -> 1/27 of totalBalance every month, must skip first 9 month \r\n            uint256 unlockedStartBalance = investments[beneficiary].totalBalance.div(3);\r\n            uint256 totalBalance = investments[beneficiary].totalBalance;\r\n            uint256 lockedBalance = totalBalance.sub(unlockedStartBalance);\r\n            uint256 monthlyBalance = lockedBalance.div(VESTING_DIV_RATE);\r\n            uint256 daysToSkip = 90 days;\r\n            uint256 time = block.timestamp.sub(start).sub(daysToSkip);\r\n            uint256 elapsedOffsets = time.div(VESTING_INTERVAL);\r\n            vested = vested.add(elapsedOffsets.mul(monthlyBalance));\r\n        }\r\n        if (block.timestamp >= end) {\r\n            // after end -> all vested\r\n            vested = investments[beneficiary].totalBalance;\r\n        }\r\n        return vested;\r\n    }\r\n}\r\n\r\n\r\n//File: contracts\\ico\\GotCrowdSale.sol\r\n/**\r\n * @title GotCrowdSale\r\n *\r\n * @version 1.0\r\n * @author ParkinGo\r\n */\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract GotCrowdSale is Pausable, CanReclaimToken, ICOEngineInterface, KYCBase {\r\n    /*** CONSTANTS ***/\r\n    uint256 public constant START_TIME = 1529416800;\r\n    //uint256 public constant START_TIME = 1529416800;                     // 19 June 2018 14:00:00 GMT\r\n    uint256 public constant END_TIME = 1530655140;                       // 03 July 2018 21:59:00 GMT\r\n    //uint256 public constant USD_PER_TOKEN = 75;                          // 0.75$\r\n    //uint256 public constant USD_PER_ETHER = 60000;                       // REMEMBER TO CHANGE IT AT ICO START\r\n    uint256 public constant TOKEN_PER_ETHER = 740;                       // REMEMBER TO CHANGE IT AT ICO START\r\n\r\n    //Token allocation\r\n    //Team, founder, partners and advisor cap locked using Monthly Internal Vault\r\n    uint256 public constant MONTHLY_INTERNAL_VAULT_CAP = 2.85e7 * 1e18;\r\n    //Company unlocked liquidity and Airdrop allocation\r\n    uint256 public constant PGO_UNLOCKED_LIQUIDITY_CAP = 1.5e7 * 1e18;\r\n    //Internal reserve fund\r\n    uint256 public constant PGO_INTERNAL_RESERVE_CAP = 3.5e7 * 1e18;\r\n    //Reserved Presale Allocation 33% free and 67% locked using Monthly Presale Vault\r\n    uint256 public constant RESERVED_PRESALE_CAP = 1.5754888e7 * 1e18;\r\n    //ICO TOKEN ALLOCATION\r\n    //Public ICO Cap\r\n    //uint256 public constant CROWDSALE_CAP = 0.15e7 * 1e18;\r\n    //Reservation contract Cap\r\n    uint256 public constant RESERVATION_CAP = 0.4297111e7 * 1e18;\r\n    //TOTAL ICO CAP\r\n    uint256 public constant TOTAL_ICO_CAP = 0.5745112e7 * 1e18;\r\n\r\n    uint256 public start;                                             // ICOEngineInterface\r\n    uint256 public end;                                               // ICOEngineInterface\r\n    uint256 public cap;                                               // ICOEngineInterface\r\n    uint256 public tokenPerEth;\r\n    uint256 public availableTokens;                                   // ICOEngineInterface\r\n    address[] public kycSigners;                                      // KYCBase\r\n    bool public capReached;\r\n    uint256 public weiRaised;\r\n    uint256 public tokensSold;\r\n\r\n    // Vesting contracts.\r\n    //Unlock funds after 9 months monthly\r\n    PGOMonthlyInternalVault public pgoMonthlyInternalVault;\r\n    //Unlock 1/3 funds immediately and remaining after 9 months monthly\r\n    PGOMonthlyPresaleVault public pgoMonthlyPresaleVault;\r\n    //Unlock funds after 12 months 25% every 6 months\r\n    PGOVault public pgoVault;\r\n\r\n    // Vesting wallets.\r\n    address public pgoInternalReserveWallet;\r\n    //Unlocked wallets\r\n    address public pgoUnlockedLiquidityWallet;\r\n    //ether wallet\r\n    address public wallet;\r\n\r\n    GotToken public token;\r\n\r\n    // Lets owner manually end crowdsale.\r\n    bool public didOwnerEndCrowdsale;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _token address contract got tokens.\r\n     * @param _wallet The address where funds should be transferred.\r\n     * @param _pgoInternalReserveWallet The address where token will be send after vesting should be transferred.\r\n     * @param _pgoUnlockedLiquidityWallet The address where token will be send after vesting should be transferred.\r\n     * @param _pgoMonthlyInternalVault The address of internal funds vault contract with monthly unlocking after 9 months.\r\n     * @param _pgoMonthlyPresaleVault The address of presale funds vault contract with 1/3 free funds and monthly unlocking after 9 months.\r\n     * @param _kycSigners Array of the signers addresses required by the KYCBase constructor, provided by Eidoo.\r\n     * See https://github.com/eidoo/icoengine\r\n     */\r\n    constructor(\r\n        address _token,\r\n        address _wallet,\r\n        address _pgoInternalReserveWallet,\r\n        address _pgoUnlockedLiquidityWallet,\r\n        address _pgoMonthlyInternalVault,\r\n        address _pgoMonthlyPresaleVault,\r\n        address[] _kycSigners\r\n    )\r\n        public\r\n        KYCBase(_kycSigners)\r\n    {\r\n        require(END_TIME >= START_TIME);\r\n        require(TOTAL_ICO_CAP > 0);\r\n\r\n        start = START_TIME;\r\n        end = END_TIME;\r\n        cap = TOTAL_ICO_CAP;\r\n        wallet = _wallet;\r\n        tokenPerEth = TOKEN_PER_ETHER;// USD_PER_ETHER.div(USD_PER_TOKEN);\r\n        availableTokens = TOTAL_ICO_CAP;\r\n        kycSigners = _kycSigners;\r\n\r\n        token = GotToken(_token);\r\n        pgoMonthlyInternalVault = PGOMonthlyInternalVault(_pgoMonthlyInternalVault);\r\n        pgoMonthlyPresaleVault = PGOMonthlyPresaleVault(_pgoMonthlyPresaleVault);\r\n        pgoInternalReserveWallet = _pgoInternalReserveWallet;\r\n        pgoUnlockedLiquidityWallet = _pgoUnlockedLiquidityWallet;\r\n        wallet = _wallet;\r\n        // Creates ParkinGo vault contract\r\n        pgoVault = new PGOVault(pgoInternalReserveWallet, address(token), END_TIME);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints unlocked tokens to unlockedLiquidityWallet and\r\n     * assings tokens to be held into the internal reserve vault contracts.\r\n     * To be called by the crowdsale's owner only.\r\n     */\r\n    function mintPreAllocatedTokens() public onlyOwner {\r\n        mintTokens(pgoUnlockedLiquidityWallet, PGO_UNLOCKED_LIQUIDITY_CAP);\r\n        mintTokens(address(pgoVault), PGO_INTERNAL_RESERVE_CAP);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the state of the internal monthly locked vault contract and mints tokens.\r\n     * It will contains all TEAM, FOUNDER, ADVISOR and PARTNERS tokens.\r\n     * All token are locked for the first 9 months and then unlocked monthly.\r\n     * It will check that all internal token are correctly allocated.\r\n     * So far, the internal monthly vault contract has been deployed and this function\r\n     * needs to be called to set its investments and vesting conditions.\r\n     * @param beneficiaries Array of the internal addresses to whom vested tokens are transferred.\r\n     * @param balances Array of token amount per beneficiary.\r\n     */\r\n    function initPGOMonthlyInternalVault(address[] beneficiaries, uint256[] balances)\r\n        public\r\n        onlyOwner\r\n        equalLength(beneficiaries, balances)\r\n    {\r\n        uint256 totalInternalBalance = 0;\r\n        uint256 balancesLength = balances.length;\r\n\r\n        for (uint256 i = 0; i < balancesLength; i++) {\r\n            totalInternalBalance = totalInternalBalance.add(balances[i]);\r\n        }\r\n        //check that all balances matches internal vault allocated Cap\r\n        require(totalInternalBalance == MONTHLY_INTERNAL_VAULT_CAP);\r\n\r\n        pgoMonthlyInternalVault.init(beneficiaries, balances, END_TIME, token);\r\n\r\n        mintTokens(address(pgoMonthlyInternalVault), MONTHLY_INTERNAL_VAULT_CAP);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the state of the reserved presale vault contract and mints reserved presale tokens. \r\n     * It will contains all reserved PRESALE token,\r\n     * 1/3 of tokens are free and the remaining are locked for the first 9 months and then unlocked monthly.\r\n     * It will check that all reserved presale token are correctly allocated.\r\n     * So far, the monthly presale vault contract has been deployed and\r\n     * this function needs to be called to set its investments and vesting conditions.\r\n     * @param beneficiaries Array of the presale investors addresses to whom vested tokens are transferred.\r\n     * @param balances Array of token amount per beneficiary.\r\n     */\r\n    function initPGOMonthlyPresaleVault(address[] beneficiaries, uint256[] balances)\r\n        public\r\n        onlyOwner\r\n        equalLength(beneficiaries, balances)\r\n    {\r\n        uint256 totalPresaleBalance = 0;\r\n        uint256 balancesLength = balances.length;\r\n\r\n        for (uint256 i = 0; i < balancesLength; i++) {\r\n            totalPresaleBalance = totalPresaleBalance.add(balances[i]);\r\n        }\r\n        //check that all balances matches internal vault allocated Cap\r\n        require(totalPresaleBalance == RESERVED_PRESALE_CAP);\r\n\r\n        pgoMonthlyPresaleVault.init(beneficiaries, balances, END_TIME, token);\r\n\r\n        mintTokens(address(pgoMonthlyPresaleVault), totalPresaleBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint all token collected by second private presale (called reservation),\r\n     * all KYC control are made outside contract under responsability of ParkinGO.\r\n     * Also, updates tokensSold and availableTokens in the crowdsale contract,\r\n     * it checks that sold token are less than reservation contract cap.\r\n     * @param beneficiaries Array of the reservation user that bought tokens in private reservation sale.\r\n     * @param balances Array of token amount per beneficiary.\r\n     */\r\n    function mintReservation(address[] beneficiaries, uint256[] balances)\r\n        public\r\n        onlyOwner\r\n        equalLength(beneficiaries, balances)\r\n    {\r\n        //require(tokensSold == 0);\r\n\r\n        uint256 totalReservationBalance = 0;\r\n        uint256 balancesLength = balances.length;\r\n\r\n        for (uint256 i = 0; i < balancesLength; i++) {\r\n            totalReservationBalance = totalReservationBalance.add(balances[i]);\r\n            uint256 amount = balances[i];\r\n            //update token sold of crowdsale contract\r\n            tokensSold = tokensSold.add(amount);\r\n            //update available token of crowdsale contract\r\n            availableTokens = availableTokens.sub(amount);\r\n            mintTokens(beneficiaries[i], amount);\r\n        }\r\n\r\n        require(totalReservationBalance <= RESERVATION_CAP);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to close the crowdsale manually before the end time.\r\n     */\r\n    function closeCrowdsale() public onlyOwner {\r\n        require(block.timestamp >= START_TIME && block.timestamp < END_TIME);\r\n        didOwnerEndCrowdsale = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to unpause tokens, stop minting and transfer ownership of the token contract.\r\n     */\r\n    function finalise() public onlyOwner {\r\n        require(didOwnerEndCrowdsale || block.timestamp > end || capReached);\r\n\r\n        token.finishMinting();\r\n        token.unpause();\r\n\r\n        // Token contract extends CanReclaimToken so the owner can recover\r\n        // any ERC20 token received in this contract by mistake.\r\n        // So far, the owner of the token contract is the crowdsale contract.\r\n        // We transfer the ownership so the owner of the crowdsale is also the owner of the token.\r\n        token.transferOwnership(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the price function from EidooEngineInterface.\r\n     * @notice Calculates the price as tokens/ether based on the corresponding bonus bracket.\r\n     * @return Price as tokens/ether.\r\n     */\r\n    function price() public view returns (uint256 _price) {\r\n        return tokenPerEth;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return False if the ico is not started, true if the ico is started and running, true if the ico is completed.\r\n     */\r\n    function started() public view returns(bool) {\r\n        if (block.timestamp >= start) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return False if the ico is not started, false if the ico is started and running, true if the ico is completed.\r\n     */\r\n    function ended() public view returns(bool) {\r\n        if (block.timestamp >= end) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return Timestamp of the ico start time.\r\n     */\r\n    function startTime() public view returns(uint) {\r\n        return start;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return Timestamp of the ico end time.\r\n     */\r\n    function endTime() public view returns(uint) {\r\n        return end;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return The total number of the tokens available for the sale, must not change when the ico is started.\r\n     */\r\n    function totalTokens() public view returns(uint) {\r\n        return cap;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the ICOEngineInterface.\r\n     * @return The number of the tokens available for the ico.\r\n     * At the moment the ico starts it must be equal to totalTokens(),\r\n     * then it will decrease.\r\n     */\r\n    function remainingTokens() public view returns(uint) {\r\n        return availableTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the KYCBase senderAllowedFor function to enable a sender to buy tokens for a different address.\r\n     * @return true.\r\n     */\r\n    function senderAllowedFor(address buyer) internal view returns(bool) {\r\n        require(buyer != address(0));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Implements the KYCBase releaseTokensTo function to mint tokens for an investor.\r\n     * Called after the KYC process has passed.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function releaseTokensTo(address buyer) internal returns(bool) {\r\n        require(validPurchase());\r\n\r\n        uint256 overflowTokens;\r\n        uint256 refundWeiAmount;\r\n\r\n        uint256 weiAmount = msg.value;\r\n        uint256 tokenAmount = weiAmount.mul(price());\r\n\r\n        if (tokenAmount >= availableTokens) {\r\n            capReached = true;\r\n            overflowTokens = tokenAmount.sub(availableTokens);\r\n            tokenAmount = tokenAmount.sub(overflowTokens);\r\n            refundWeiAmount = overflowTokens.div(price());\r\n            weiAmount = weiAmount.sub(refundWeiAmount);\r\n            buyer.transfer(refundWeiAmount);\r\n        }\r\n\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokensSold = tokensSold.add(tokenAmount);\r\n        availableTokens = availableTokens.sub(tokenAmount);\r\n        mintTokens(buyer, tokenAmount);\r\n        forwardFunds(weiAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Fired by the releaseTokensTo function after minting tokens,\r\n     * to forward the raised wei to the address that collects funds.\r\n     * @param _weiAmount Amount of wei send by the investor.\r\n     */\r\n    function forwardFunds(uint256 _weiAmount) internal {\r\n        wallet.transfer(_weiAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Validates an incoming purchase. Required statements revert state when conditions are not met.\r\n     * @return true If the transaction can buy tokens.\r\n     */\r\n    function validPurchase() internal view returns (bool) {\r\n        require(!paused && !capReached);\r\n        require(block.timestamp >= start && block.timestamp <= end);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Mints tokens being sold during the crowdsale phase as part of the implementation of releaseTokensTo function\r\n     * from the KYCBase contract.\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param amount The amount of tokens to mint.\r\n     */\r\n    function mintTokens(address to, uint256 amount) private {\r\n        token.mint(to, amount);\r\n    }\r\n\r\n    modifier equalLength(address[] beneficiaries, uint256[] balances) {\r\n        require(beneficiaries.length == balances.length);\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKycSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MONTHLY_INTERNAL_VAULT_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintPreAllocatedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kycSigners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"}],\"name\":\"mintReservation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PGO_INTERNAL_RESERVE_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PGO_UNLOCKED_LIQUIDITY_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"}],\"name\":\"initPGOMonthlyInternalVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"}],\"name\":\"initPGOMonthlyPresaleVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PER_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"alreadyPayed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pgoVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVATION_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalise\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pgoInternalReserveWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"buyerId\",\"type\":\"uint64\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTokensFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVED_PRESALE_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_ICO_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"didOwnerEndCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerId\",\"type\":\"uint64\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pgoUnlockedLiquidityWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pgoMonthlyInternalVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pgoMonthlyPresaleVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_pgoInternalReserveWallet\",\"type\":\"address\"},{\"name\":\"_pgoUnlockedLiquidityWallet\",\"type\":\"address\"},{\"name\":\"_pgoMonthlyInternalVault\",\"type\":\"address\"},{\"name\":\"_pgoMonthlyPresaleVault\",\"type\":\"address\"},{\"name\":\"_kycSigners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"KycVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"GotCrowdSale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000613fa2a6e6daa70c659060e86ba1443d2679c9d7000000000000000000000000d0f1ef60389e691676a9b92d788b730477297bd7000000000000000000000000b650238883ca8379c00c557625aa9d1c52ccc032000000000000000000000000125cba615fb3bd79f55b984c7f0b622716aa4480000000000000000000000000326a6c84d1cb72e26018497484125b5ab9ff32100000000000000000000000001c96f2547ef02abbcf6b5af99c9d9b186c9ca98e00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000dd5ecefcaa0cb5d75f7b72dc9d2ce446d6d005200000000000000000000000004e315e5de2abbf7b745d9628ee60e4355c0fab86","Library":"","SwarmSource":"bzzr://863ee16526bd09fc3345006c736e7669ece58d67e4df390e58f7b5a9ede5246a"}]}