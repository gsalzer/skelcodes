{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// zeppelin-solidity: 1.9.0\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Membership is Ownable {\r\n  using SafeMath for uint;\r\n\r\n  mapping(address => bool) public isAdmin;\r\n  mapping(address => uint) public userToMemberIndex;\r\n  mapping(uint => uint[]) public tierToMemberIndexes;\r\n\r\n  struct Member {\r\n    address addr;\r\n    uint tier;\r\n    uint tierIndex;\r\n    uint memberIndex;\r\n  }\r\n\r\n  Member[] private members;\r\n\r\n  event NewMember(address user, uint tier);\r\n  event UpdatedMemberTier(address user, uint oldTier, uint newTier);\r\n  event RemovedMember(address user, uint tier);\r\n\r\n  modifier onlyAdmin() {\r\n    require(isAdmin[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  modifier isValidTier(uint _tier) {\r\n    require(_tier >= 1 && _tier <= 4);\r\n    _;\r\n  }\r\n\r\n  modifier notTryingToChangeFromTier1(address _user, uint _tier) {\r\n    require(members[userToMemberIndex[_user]].tier != _tier);\r\n    _;\r\n  }\r\n\r\n\r\n  modifier isMember(address _user) {\r\n    require(userToMemberIndex[_user] != 0);\r\n    _;\r\n  }\r\n\r\n  modifier isValidAddr(address _trgt) {\r\n    require(_trgt != address(0));\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    Member memory member = Member(address(0), 0, 0, 0);\r\n    members.push(member);\r\n  }\r\n\r\n  function addAdmin(address _user)\r\n    external\r\n    onlyOwner\r\n  {\r\n    isAdmin[_user] = true;\r\n  }\r\n\r\n  function removeMember(address _user)\r\n    external\r\n    onlyAdmin\r\n    isValidAddr(_user)\r\n    isMember(_user)\r\n  {\r\n    uint index = userToMemberIndex[_user];\r\n    require(index != 0);\r\n\r\n    Member memory removingMember = members[index];\r\n\r\n    uint tier = removingMember.tier;\r\n\r\n    uint lastTierIndex = tierToMemberIndexes[removingMember.tier].length - 1;\r\n    uint lastTierMemberIndex = tierToMemberIndexes[removingMember.tier][lastTierIndex];\r\n    Member storage lastTierMember = members[lastTierMemberIndex];\r\n    lastTierMember.tierIndex = removingMember.tierIndex;\r\n    tierToMemberIndexes[removingMember.tier][removingMember.tierIndex] = lastTierMember.memberIndex;\r\n    tierToMemberIndexes[removingMember.tier].length--;\r\n\r\n    Member storage lastMember = members[members.length - 1];\r\n    if (lastMember.addr != removingMember.addr) {\r\n      userToMemberIndex[lastMember.addr] = removingMember.memberIndex;\r\n      tierToMemberIndexes[lastMember.tier][lastMember.tierIndex] = removingMember.memberIndex;\r\n      lastMember.memberIndex = removingMember.memberIndex;\r\n      members[removingMember.memberIndex] = lastMember;\r\n    }\r\n    userToMemberIndex[removingMember.addr] = 0;\r\n    members.length--;\r\n\r\n    emit RemovedMember(_user, tier);\r\n  }\r\n\r\n  function addNewMember(address _user, uint _tier)\r\n    internal\r\n  {\r\n    // it's a new member\r\n    uint memberIndex = members.length; // + 1; // add 1 to keep index 0 unoccupied\r\n    uint tierIndex = tierToMemberIndexes[_tier].length;\r\n\r\n    Member memory newMember = Member(_user, _tier, tierIndex, memberIndex);\r\n\r\n    members.push(newMember);\r\n    userToMemberIndex[_user] = memberIndex;\r\n    tierToMemberIndexes[_tier].push(memberIndex);\r\n\r\n    emit NewMember(_user, _tier);\r\n  }\r\n\r\n  function updateExistingMember(address _user, uint _newTier)\r\n    internal\r\n  {\r\n    // this user is a member in another tier, remove him from that tier,\r\n    // and add him to the new tier\r\n    Member storage existingMember = members[userToMemberIndex[_user]];\r\n\r\n    uint oldTier = existingMember.tier;\r\n    uint tierIndex = existingMember.tierIndex;\r\n    uint lastTierIndex = tierToMemberIndexes[oldTier].length - 1;\r\n\r\n    if (tierToMemberIndexes[oldTier].length > 1 && tierIndex != lastTierIndex) {\r\n      Member storage lastMember = members[tierToMemberIndexes[oldTier][lastTierIndex]];\r\n      tierToMemberIndexes[oldTier][tierIndex] = lastMember.memberIndex;\r\n      lastMember.tierIndex = tierIndex;\r\n    }\r\n\r\n    tierToMemberIndexes[oldTier].length--;\r\n    tierToMemberIndexes[_newTier].push(existingMember.memberIndex);\r\n\r\n    existingMember.tier = _newTier;\r\n    existingMember.tierIndex = tierToMemberIndexes[_newTier].length - 1;\r\n\r\n    emit UpdatedMemberTier(_user, oldTier, _newTier);\r\n  }\r\n\r\n  function setMemberTier(address _user, uint _tier)\r\n    external\r\n    onlyAdmin\r\n    isValidAddr(_user)\r\n    isValidTier(_tier)\r\n  {\r\n    if (userToMemberIndex[_user] == 0) {\r\n      addNewMember(_user, _tier);\r\n    } else {\r\n      uint currentTier = members[userToMemberIndex[_user]].tier;\r\n      if (currentTier != _tier) {\r\n        // user's in tier 1 are lifetime tier 1 users\r\n        require(currentTier != 1);\r\n\r\n        updateExistingMember(_user, _tier);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getTierOfMember(address _user)\r\n    external\r\n    view\r\n    returns (uint)\r\n  {\r\n    return members[userToMemberIndex[_user]].tier;\r\n  }\r\n\r\n  function getMembersOfTier(uint _tier)\r\n    external\r\n    view\r\n    returns (address[])\r\n  {\r\n    address[] memory addressesOfTier = new address[](tierToMemberIndexes[_tier].length);\r\n\r\n    for (uint i = 0; i < tierToMemberIndexes[_tier].length; i++) {\r\n      addressesOfTier[i] = members[tierToMemberIndexes[_tier][i]].addr;\r\n    }\r\n\r\n    return addressesOfTier;\r\n  }\r\n\r\n  function getMembersOfTierCount(uint _tier)\r\n    external\r\n    view\r\n    returns (uint)\r\n  {\r\n    return tierToMemberIndexes[_tier].length;\r\n  }\r\n\r\n  function getMembersCount()\r\n    external\r\n    view\r\n    returns (uint)\r\n  {\r\n    if (members.length == 0) {\r\n      return 0;\r\n    } else {\r\n      // remove sentinel at index zero from count\r\n      return members.length - 1;\r\n    }\r\n  }\r\n\r\n  function getMemberByIdx(uint _idx)\r\n    external\r\n    view\r\n    returns (address, uint)\r\n  {\r\n    Member memory member = members[_idx];\r\n\r\n    return (member.addr, member.tier);\r\n  }\r\n\r\n  function isUserMember(address _user)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return userToMemberIndex[_user] != 0;\r\n  }\r\n\r\n  function getMemberIdxOfUser(address _user)\r\n    external\r\n    view\r\n    returns (uint)\r\n  {\r\n    return userToMemberIndex[_user];\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getMembersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTierOfMember\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToMemberIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"getMembersOfTier\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getMemberByIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isUserMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"getMembersOfTierCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tierToMemberIndexes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMemberIdxOfUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"setMemberTier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tier\",\"type\":\"uint256\"}],\"name\":\"NewMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldTier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newTier\",\"type\":\"uint256\"}],\"name\":\"UpdatedMemberTier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tier\",\"type\":\"uint256\"}],\"name\":\"RemovedMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Membership","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0f51e0f8ed646e504fcd9d560d60b89a1497767dbbe43da752366310f33ac2d4"}]}