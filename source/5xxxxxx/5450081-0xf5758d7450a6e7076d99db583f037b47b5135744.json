{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// File: contracts/IPFSEvents.sol\r\n\r\ncontract IPFSEvents {\r\n    event HashAdded(string hash, uint ttl);\r\n    event HashRemoved(string hash);\r\n\r\n    event MetadataObjectAdded(string hash);\r\n    event MetadataObjectRemoved(string hash);    \r\n}\r\n\r\n// File: contracts/Multimember.sol\r\n\r\ncontract Multimember {\r\n\r\n    // TYPES\r\n\r\n    // struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint membersDone;\r\n        uint index;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    // this contract only has seven types of events: it can accept a confirmation, in which case\r\n    // we record member and operation (hash) alongside it.\r\n    event Confirmation(address member, bytes32 operation);\r\n    event Revoke(address member, bytes32 operation);\r\n    // some others are in the case of an member changing.\r\n    event MemberChanged(address oldMember, address newMember);\r\n    event MemberAdded(address newMember);\r\n    event MemberRemoved(address oldMember);\r\n    // the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n    // MODIFIERS\r\n\r\n    // simple single-sig function modifier.\r\n    modifier onlymember {\r\n        if (isMember(msg.sender))\r\n            _;\r\n    }\r\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    // that later attempts can be realised as the same underlying operation and\r\n    // thus count as confirmations.\r\n    modifier onlymanymembers(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }\r\n\r\n    // METHODS\r\n\r\n    // constructor is given number of sigs required to do protected \"onlymanymembers\" transactions\r\n    // as well as the selection of addresses capable of confirming them.\r\n    function Multimember(address[] _members, uint _required) public {\r\n        m_numMembers = _members.length + 1;\r\n        m_members[1] = uint(msg.sender);\r\n        m_memberIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _members.length; ++i) {\r\n            m_members[2 + i] = uint(_members[i]);\r\n            m_memberIndex[uint(_members[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n    \r\n    // Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint memberIndex = m_memberIndex[uint(msg.sender)];\r\n        // make sure they're an member\r\n        if (memberIndex == 0) \r\n            return;\r\n        uint memberIndexBit = 2**memberIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.membersDone & memberIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.membersDone -= memberIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n    \r\n    // Replaces an member `_from` with another `_to`.\r\n    function changeMember(address _from, address _to) onlymanymembers(keccak256(_from,_to)) external {\r\n        if (isMember(_to)) \r\n            return;\r\n        uint memberIndex = m_memberIndex[uint(_from)];\r\n        if (memberIndex == 0) \r\n            return;\r\n\r\n        clearPending();\r\n        m_members[memberIndex] = uint(_to);\r\n        m_memberIndex[uint(_from)] = 0;\r\n        m_memberIndex[uint(_to)] = memberIndex;\r\n        MemberChanged(_from, _to);\r\n    }\r\n    \r\n    function addMember(address _member) onlymanymembers(keccak256(_member)) public {\r\n        if (isMember(_member)) \r\n            return;\r\n\r\n        clearPending();\r\n        if (m_numMembers >= MAXMEMBERS)\r\n            reorganizeMembers();\r\n        if (m_numMembers >= MAXMEMBERS)\r\n            return;\r\n        m_numMembers++;\r\n        m_members[m_numMembers] = uint(_member);\r\n        m_memberIndex[uint(_member)] = m_numMembers;\r\n        MemberAdded(_member);\r\n    }\r\n    \r\n    function removeMember(address _member) onlymanymembers(keccak256(_member)) public {\r\n        uint memberIndex = m_memberIndex[uint(_member)];\r\n        if (memberIndex == 0) \r\n            return;\r\n        if (m_required > m_numMembers - 1) \r\n            return;\r\n\r\n        m_members[memberIndex] = 0;\r\n        m_memberIndex[uint(_member)] = 0;\r\n        clearPending();\r\n        reorganizeMembers(); //make sure m_numMembers is equal to the number of members and always points to the optimal free slot\r\n        MemberRemoved(_member);\r\n    }\r\n    \r\n    function changeRequirement(uint _newRequired) onlymanymembers(keccak256(_newRequired)) external {\r\n        if (_newRequired > m_numMembers) \r\n            return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n    \r\n    function isMember(address _addr) public constant returns (bool) { \r\n        return m_memberIndex[uint(_addr)] > 0;\r\n    }\r\n    \r\n    function hasConfirmed(bytes32 _operation, address _member) external constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint memberIndex = m_memberIndex[uint(_member)];\r\n\r\n        // make sure they're an member\r\n        if (memberIndex == 0) \r\n            return false;\r\n\r\n        // determine the bit to set for this member.\r\n        uint memberIndexBit = 2**memberIndex;\r\n        return !(pending.membersDone & memberIndexBit == 0);\r\n    }\r\n    \r\n    // INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        // determine what index the present sender is:\r\n        uint memberIndex = m_memberIndex[uint(msg.sender)];\r\n        // make sure they're an member\r\n        if (memberIndex == 0) \r\n            return;\r\n\r\n        var pending = m_pending[_operation];\r\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            // reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            // reset which members have confirmed (none) - set our bitmap to 0.\r\n            pending.membersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        // determine the bit to set for this member.\r\n        uint memberIndexBit = 2**memberIndex;\r\n        // make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.membersDone & memberIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            // ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                // enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            } else {\r\n                // not enough: record that this member in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.membersDone |= memberIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeMembers() private returns (bool) {\r\n        uint free = 1;\r\n        while (free < m_numMembers) {\r\n            while (free < m_numMembers && m_members[free] != 0) {\r\n                free++;\r\n            } \r\n\r\n            while (m_numMembers > 1 && m_members[m_numMembers] == 0) {\r\n                m_numMembers--;\r\n            } \r\n\r\n            if (free < m_numMembers && m_members[m_numMembers] != 0 && m_members[free] == 0) {\r\n                m_members[free] = m_members[m_numMembers];\r\n                m_memberIndex[m_members[free]] = free;\r\n                m_members[m_numMembers] = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i) {\r\n            if (m_pendingIndex[i] != 0) {\r\n                delete m_pending[m_pendingIndex[i]];\r\n            }\r\n        }\r\n        delete m_pendingIndex;\r\n    }\r\n        \r\n    // FIELDS\r\n\r\n    // the number of members that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    // pointer used to find a free slot in m_members\r\n    uint public m_numMembers;\r\n    \r\n    // list of members\r\n    uint[256] m_members;\r\n    uint constant MAXMEMBERS = 250;\r\n    // index on the list of members to allow reverse lookup\r\n    mapping(uint => uint) m_memberIndex;\r\n    // the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n// File: contracts/IPFSProxy.sol\r\n\r\ncontract IPFSProxy is IPFSEvents, Multimember {\r\n    uint public persistLimit;\r\n\r\n    event PersistLimitChanged(uint limit);\t\r\n    event ContractAdded(address pubKey,uint startBlock);\r\n    event ContractRemoved(address pubKey);\r\n\r\n    /**\r\n    * @dev Constructor - adds the owner of the contract to the list of valid members\r\n    */\r\n    function IPFSProxy(address[] _members,uint _required, uint _persistlimit) Multimember (_members, _required) public {\r\n        setTotalPersistLimit(_persistlimit);\r\n        for (uint i = 0; i < _members.length; ++i) {\r\n            MemberAdded(_members[i]);\r\n        }\r\n        addContract(this,block.number);\r\n    }\r\n\r\n    /**\r\n    * @dev Add hash to persistent storage\r\n    * @param _ipfsHash The ipfs hash to propagate.\r\n    * @param _ttl amount of time is seconds to persist this. 0 = infinite\r\n    */\r\n    function addHash(string _ipfsHash, uint _ttl) public onlymember {\r\n        HashAdded(_ipfsHash,_ttl);\r\n    }\r\n\r\n    /**\r\n    * @dev Remove hash from persistent storage\r\n    * @param _ipfsHash The ipfs hash to propagate.\t\r\n    */\r\n    function removeHash(string _ipfsHash) public onlymember {\r\n        HashRemoved(_ipfsHash);\r\n    }\r\n\r\n   /** \r\n    * Add a contract to watch list. Each proxy will then \r\n    * watch it for HashAdded and HashRemoved events \r\n    * and cache these events\r\n    * @param _contractAddress The contract address.\r\n    * @param _startBlock The startblock where to look for events.\r\n    */\r\n    function addContract(address _contractAddress,uint _startBlock) public onlymember {\r\n        ContractAdded(_contractAddress,_startBlock);\r\n    }\r\n\r\n    /**\r\n    * @dev Remove contract from watch list\r\n    */\r\n    function removeContract(address _contractAddress) public onlymember {\r\n        require(_contractAddress != address(this));\r\n        ContractRemoved(_contractAddress);\r\n    }\r\n\r\n   /** \r\n    * Add a metadata of an object. Each proxy will then \r\n    * read the ipfs hash file with the metadata about the object and parse it \r\n    */\r\n    function addMetadataObject(string _metadataHash) public onlymember {\r\n        HashAdded(_metadataHash,0);\r\n        MetadataObjectAdded(_metadataHash);\r\n    }\r\n\r\n    /** \r\n    * removed a metadata of an object.\r\n    */\r\n    function removeMetadataObject(string _metadataHash) public onlymember {\r\n        HashRemoved(_metadataHash);\r\n        MetadataObjectRemoved(_metadataHash);\r\n    }\r\n\r\n    /**\r\n    * @dev set total allowed upload\r\n    *\r\n    **/\r\n    function setTotalPersistLimit (uint _limit) public onlymanymembers(keccak256(_limit)) {\r\n        persistLimit = _limit;\r\n        PersistLimitChanged(_limit);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"persistLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_numMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_metadataHash\",\"type\":\"string\"}],\"name\":\"removeMetadataObject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_metadataHash\",\"type\":\"string\"}],\"name\":\"addMetadataObject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"addContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setTotalPersistLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"removeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ipfsHash\",\"type\":\"string\"},{\"name\":\"_ttl\",\"type\":\"uint256\"}],\"name\":\"addHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ipfsHash\",\"type\":\"string\"}],\"name\":\"removeHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_members\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_persistlimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"PersistLimitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pubKey\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"ContractAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pubKey\",\"type\":\"address\"}],\"name\":\"ContractRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMember\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"MemberChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMember\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMember\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"ttl\",\"type\":\"uint256\"}],\"name\":\"HashAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"string\"}],\"name\":\"HashRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"string\"}],\"name\":\"MetadataObjectAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"string\"}],\"name\":\"MetadataObjectRemoved\",\"type\":\"event\"}]","ContractName":"IPFSProxy","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000002540be4000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://02232080981adbe665cabb126e311027074fe633a376a283e573f1c13ccbcc48"}]}