{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    string public constant name = \"\";\r\n    string public constant symbol = \"\";\r\n    uint8 public constant decimals = 0;\r\n}\r\n\r\n// Ethen Decentralized Exchange Contract\r\n// https://ethen.io/\r\ncontract Ethen is Pausable {\r\n    // Trade & order types\r\n    uint public constant BUY = 1; // order type BID\r\n    uint public constant SELL = 0; // order type ASK\r\n\r\n    // Percent multiplier in makeFee & takeFee\r\n    uint public FEE_MUL = 1000000;\r\n\r\n    // x1000000, 0.5%\r\n    uint public constant MAX_FEE = 5000;\r\n\r\n    // Time after expiration, until order will still be valid to trade.\r\n    //\r\n    // All trades are signed by server so it should not be possible to trade\r\n    // expired orders. Let's say, signing happens at the last second.\r\n    // Some time needed for transaction to be mined. If we going to require\r\n    // here in contract that expiration time should always be less than\r\n    // a block.timestamp than such trades will not be successful.\r\n    // Instead we add some reasonable time, after which order still be valid\r\n    // to trade in contract.\r\n    uint public expireDelay = 300;\r\n\r\n    uint public constant MAX_EXPIRE_DELAY = 600;\r\n\r\n    // Value of keccak256(\r\n    //     \"address Contract\", \"string Order\", \"address Token\", \"uint Nonce\",\r\n    //     \"uint Price\", \"uint Amount\", \"uint Expire\"\r\n    // )\r\n    // See https://github.com/ethereum/EIPs/pull/712\r\n    bytes32 public constant ETH_SIGN_TYPED_DATA_ARGHASH =\r\n        0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74;\r\n\r\n    // All prices are per 1e18 tokens\r\n    uint public constant PRICE_MUL = 1e18;\r\n\r\n    //\r\n    // Public State Vars\r\n    //\r\n\r\n    // That address gets all the fees\r\n    address public feeCollector;\r\n\r\n    // x1000000\r\n    uint public makeFee = 0;\r\n\r\n    // x1000000, 2500 == 0.25%\r\n    uint public takeFee = 2500;\r\n\r\n    // user address to ether balances\r\n    mapping (address => uint) public balances;\r\n\r\n    // user address to token address to token balance\r\n    mapping (address => mapping (address => uint)) public tokens;\r\n\r\n    // user => order nonce => amount filled\r\n    mapping (address => mapping (uint => uint)) public filled;\r\n\r\n    // user => nonce => true\r\n    mapping (address => mapping (uint => bool)) public trades;\r\n\r\n    // Every trade should be signed by that address\r\n    address public signer;\r\n\r\n    // Keep track of custom fee coefficients per user\r\n    // 0 means user will pay no fees, 50 - only 50% of fees\r\n    struct Coeff {\r\n        uint8   coeff; // 0-99\r\n        uint128 expire;\r\n    }\r\n    mapping (address => Coeff) public coeffs;\r\n\r\n    // Users can pay to reduce fees\r\n    // (duration << 8) + coeff => price\r\n    mapping(uint => uint) public packs;\r\n\r\n    //\r\n    // Events\r\n    //\r\n\r\n    event NewMakeFee(uint makeFee);\r\n    event NewTakeFee(uint takeFee);\r\n\r\n    event NewFeeCoeff(address user, uint8 coeff, uint128 expire, uint price);\r\n\r\n    event DepositEther(address user, uint amount, uint total);\r\n    event WithdrawEther(address user, uint amount, uint total);\r\n    event DepositToken(address user, address token, uint amount, uint total);\r\n    event WithdrawToken(address user, address token, uint amount, uint total);\r\n\r\n    event Cancel(\r\n        uint8 order,\r\n        address owner,\r\n        uint nonce,\r\n        address token,\r\n        uint price,\r\n        uint amount\r\n    );\r\n\r\n    event Order(\r\n        address orderOwner,\r\n        uint orderNonce,\r\n        uint orderPrice,\r\n        uint tradeTokens,\r\n        uint orderFilled,\r\n        uint orderOwnerFinalTokens,\r\n        uint orderOwnerFinalEther,\r\n        uint fees\r\n    );\r\n\r\n    event Trade(\r\n        address trader,\r\n        uint nonce,\r\n        uint trade,\r\n        address token,\r\n        uint traderFinalTokens,\r\n        uint traderFinalEther\r\n    );\r\n\r\n    event NotEnoughTokens(\r\n        address owner, address token, uint shouldHaveAmount, uint actualAmount\r\n    );\r\n    event NotEnoughEther(\r\n        address owner, uint shouldHaveAmount, uint actualAmount\r\n    );\r\n\r\n    //\r\n    // Constructor\r\n    //\r\n\r\n    function Ethen(address _signer) public {\r\n        feeCollector = msg.sender;\r\n        signer       = _signer;\r\n    }\r\n\r\n    //\r\n    // Admin Methods\r\n    //\r\n\r\n    function setFeeCollector(address _addr) external onlyOwner {\r\n        feeCollector = _addr;\r\n    }\r\n\r\n    function setSigner(address _addr) external onlyOwner {\r\n        signer = _addr;\r\n    }\r\n\r\n    function setMakeFee(uint _makeFee) external onlyOwner {\r\n        require(_makeFee <= MAX_FEE);\r\n        makeFee = _makeFee;\r\n        NewMakeFee(makeFee);\r\n    }\r\n\r\n    function setTakeFee(uint _takeFee) external onlyOwner {\r\n        require(_takeFee <= MAX_FEE);\r\n        takeFee = _takeFee;\r\n        NewTakeFee(takeFee);\r\n    }\r\n\r\n    function addPack(\r\n        uint8 _coeff, uint128 _duration, uint _price\r\n    ) external onlyOwner {\r\n        require(_coeff < 100);\r\n        require(_duration > 0);\r\n        require(_price > 0);\r\n\r\n        uint key = packKey(_coeff, _duration);\r\n        packs[key] = _price;\r\n    }\r\n\r\n    function delPack(uint8 _coeff, uint128 _duration) external onlyOwner {\r\n        uint key = packKey(_coeff, _duration);\r\n        delete packs[key];\r\n    }\r\n\r\n    function setExpireDelay(uint _expireDelay) external onlyOwner {\r\n        require(_expireDelay <= MAX_EXPIRE_DELAY);\r\n        expireDelay = _expireDelay;\r\n    }\r\n\r\n    //\r\n    // User Custom Fees\r\n    //\r\n\r\n    function getPack(\r\n        uint8 _coeff, uint128 _duration\r\n    ) public view returns (uint) {\r\n        uint key = packKey(_coeff, _duration);\r\n        return packs[key];\r\n    }\r\n\r\n    // Buys new fee coefficient for given duration of time\r\n    function buyPack(\r\n        uint8 _coeff, uint128 _duration\r\n    ) external payable {\r\n        require(now >= coeffs[msg.sender].expire);\r\n\r\n        uint key = packKey(_coeff, _duration);\r\n        uint price = packs[key];\r\n\r\n        require(price > 0);\r\n        require(msg.value == price);\r\n\r\n        updateCoeff(msg.sender, _coeff, uint128(now) + _duration, price);\r\n\r\n        balances[feeCollector] = SafeMath.add(\r\n            balances[feeCollector], msg.value\r\n        );\r\n    }\r\n\r\n    // Sets new fee coefficient for user\r\n    function setCoeff(\r\n        uint8 _coeff, uint128 _expire, uint8 _v, bytes32 _r, bytes32 _s\r\n    ) external {\r\n        bytes32 hash = keccak256(this, msg.sender, _coeff, _expire);\r\n        require(ecrecover(hash, _v, _r, _s) == signer);\r\n\r\n        require(_coeff < 100);\r\n        require(uint(_expire) > now);\r\n        require(uint(_expire) <= now + 35 days);\r\n\r\n        updateCoeff(msg.sender, _coeff, _expire, 0);\r\n    }\r\n\r\n    //\r\n    // User Balance Related Methods\r\n    //\r\n\r\n    function () external payable {\r\n        balances[msg.sender] = SafeMath.add(balances[msg.sender], msg.value);\r\n        DepositEther(msg.sender, msg.value, balances[msg.sender]);\r\n    }\r\n\r\n    function depositEther() external payable {\r\n        balances[msg.sender] = SafeMath.add(balances[msg.sender], msg.value);\r\n        DepositEther(msg.sender, msg.value, balances[msg.sender]);\r\n    }\r\n\r\n    function withdrawEther(uint _amount) external {\r\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _amount);\r\n        msg.sender.transfer(_amount);\r\n        WithdrawEther(msg.sender, _amount, balances[msg.sender]);\r\n    }\r\n\r\n    function depositToken(address _token, uint _amount) external {\r\n        require(ERC20(_token).transferFrom(msg.sender, this, _amount));\r\n        tokens[msg.sender][_token] = SafeMath.add(\r\n            tokens[msg.sender][_token], _amount\r\n        );\r\n        DepositToken(msg.sender, _token, _amount, tokens[msg.sender][_token]);\r\n    }\r\n\r\n    function withdrawToken(address _token, uint _amount) external {\r\n        tokens[msg.sender][_token] = SafeMath.sub(\r\n            tokens[msg.sender][_token], _amount\r\n        );\r\n        require(ERC20(_token).transfer(msg.sender, _amount));\r\n        WithdrawToken(msg.sender, _token, _amount, tokens[msg.sender][_token]);\r\n    }\r\n\r\n    //\r\n    // User Trade Methods\r\n    //\r\n\r\n    // Fills order so it cant be executed later\r\n    function cancel(\r\n        uint8   _order, // BUY for bid orders or SELL for ask orders\r\n        address _token,\r\n        uint    _nonce,\r\n        uint    _price, // Price per 1e18 (PRICE_MUL) tokens\r\n        uint    _amount,\r\n        uint    _expire,\r\n        uint    _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external {\r\n        require(_order == BUY || _order == SELL);\r\n\r\n        if (now > _expire + expireDelay) {\r\n            // already expired\r\n            return;\r\n        }\r\n\r\n        getVerifiedHash(\r\n            msg.sender,\r\n            _order, _token, _nonce, _price, _amount, _expire,\r\n            _v, _r, _s\r\n        );\r\n\r\n        filled[msg.sender][_nonce] = _amount;\r\n\r\n        Cancel(_order, msg.sender, _nonce, _token, _price, _amount);\r\n    }\r\n\r\n    // Does trade, places order\r\n    // Argument hell because of \"Stack to deep\" errors.\r\n    function trade(\r\n        // _nums[0] 1=BUY, 0=SELL\r\n        // _nums[1] trade.nonce\r\n        // _nums[2] trade.v\r\n        // _nums[3] trade.expire\r\n        // _nums[4] order[0].nonce              First order should have\r\n        // _nums[5] order[0].price              best available price\r\n        // _nums[6] order[0].amount\r\n        // _nums[7] order[0].expire\r\n        // _nums[8] order[0].v\r\n        // _nums[9] order[0].tradeAmount\r\n        // ...\r\n        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\r\n        // _nums[6N-1] order[N-1].price         N -> 6N+5\r\n        // _nums[6N]   order[N-1].amount        N -> 6N+6\r\n        // _nums[6N+1] order[N-1].expire        N -> 6N+7\r\n        // _nums[6N+2] order[N-1].v             N -> 6N+8\r\n        // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\r\n        uint[] _nums,\r\n        // _addrs[0] token\r\n        // _addrs[1] order[0].owner\r\n        // ...\r\n        // _addrs[N] order[N-1].owner           N -> N+1\r\n        address[] _addrs,\r\n        // _rss[0] trade.r\r\n        // _rss[1] trade.s\r\n        // _rss[2] order[0].r\r\n        // _rss[3] order[0].s\r\n        // ...\r\n        // _rss[2N]   order[N-1].r              N -> 2N+2\r\n        // _rss[2N+1] order[N-1].s              N -> 2N+3\r\n        bytes32[] _rss\r\n    ) public whenNotPaused {\r\n        // number of orders\r\n        uint N = _addrs.length - 1;\r\n\r\n        require(_nums.length == 6*N+4);\r\n        require(_rss.length == 2*N+2);\r\n\r\n        // Type of trade\r\n        // _nums[0] BUY or SELL\r\n        require(_nums[0] == BUY || _nums[0] == SELL);\r\n\r\n        // _nums[2] placeOrder.nonce\r\n        saveNonce(_nums[1]);\r\n\r\n        // _nums[3] trade.expire\r\n        require(now <= _nums[3]);\r\n\r\n        // Start building hash signed by server\r\n        // _nums[0] BUY or SELL\r\n        // _addrs[0] token\r\n        // _nums[1] nonce\r\n        // _nums[3] trade.expire\r\n        bytes32 tradeHash = keccak256(\r\n            this, msg.sender, uint8(_nums[0]), _addrs[0], _nums[1], _nums[3]\r\n        );\r\n\r\n        // Hash of an order signed by its owner\r\n        bytes32 orderHash;\r\n\r\n        for (uint i = 0; i < N; i++) {\r\n            checkExpiration(i, _nums);\r\n\r\n            orderHash = verifyOrder(i, _nums, _addrs, _rss);\r\n\r\n            // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\r\n            tradeHash = keccak256(tradeHash, orderHash, _nums[6*i+9]);\r\n\r\n            tradeOrder(i, _nums, _addrs);\r\n        }\r\n\r\n        checkTradeSignature(tradeHash, _nums, _rss);\r\n\r\n        sendTradeEvent(_nums, _addrs);\r\n    }\r\n\r\n    //\r\n    // Private\r\n    //\r\n\r\n    function saveNonce(uint _nonce) private {\r\n        require(trades[msg.sender][_nonce] == false);\r\n        trades[msg.sender][_nonce] = true;\r\n    }\r\n\r\n    // Throws error if order is expired\r\n    function checkExpiration(\r\n        uint _i, // order number\r\n        uint[] _nums\r\n    ) private view {\r\n        // _nums[6N+1] order[N-1].expire        N -> 6N+7\r\n        require(now <= _nums[6*_i+7] + expireDelay);\r\n    }\r\n\r\n    // Returns hash of order `_i`, signed by its owner\r\n    function verifyOrder(\r\n        uint _i, // order number\r\n        uint[] _nums,\r\n        address[] _addrs,\r\n        bytes32[] _rss\r\n    ) private view returns (bytes32 _orderHash) {\r\n        // _nums[0] BUY or SELL\r\n        // User is buying orders, that are selling, and vice versa\r\n        uint8 order = _nums[0] == BUY ? uint8(SELL) : uint8(BUY);\r\n\r\n        // _addrs[N] order[N-1].owner       N -> N+1\r\n        // _addrs[0] token\r\n        address owner = _addrs[_i+1];\r\n        address token = _addrs[0];\r\n\r\n        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\r\n        // _nums[6N-1] order[N-1].price         N -> 6N+5\r\n        // _nums[6N]   order[N-1].amount        N -> 6N+6\r\n        // _nums[6N+1] order[N-1].expire        N -> 6N+7\r\n        uint nonce = _nums[6*_i+4];\r\n        uint price = _nums[6*_i+5];\r\n        uint amount = _nums[6*_i+6];\r\n        uint expire = _nums[6*_i+7];\r\n\r\n        // _nums[6N+2] order[N-1].v             N -> 6N+8\r\n        // _rss[2N]   order[N-1].r              N -> 2N+2\r\n        // _rss[2N+1] order[N-1].s              N -> 2N+3\r\n        uint v = _nums[6*_i+8];\r\n        bytes32 r = _rss[2*_i+2];\r\n        bytes32 s = _rss[2*_i+3];\r\n\r\n        _orderHash = getVerifiedHash(\r\n            owner,\r\n            order, token, nonce, price, amount,\r\n            expire, v, r, s\r\n        );\r\n    }\r\n\r\n    // Returns number of traded tokens\r\n    function tradeOrder(\r\n        uint _i, // order number\r\n        uint[] _nums,\r\n        address[] _addrs\r\n    ) private {\r\n        // _nums[0] BUY or SELL\r\n        // _addrs[0] token\r\n        // _addrs[N] order[N-1].owner           N -> N+1\r\n        // _nums[6N-2] order[N-1].nonce         N -> 6N+4\r\n        // _nums[6N-1] order[N-1].price         N -> 6N+5\r\n        // _nums[6N]   order[N-1].amount        N -> 6N+6\r\n        // _nums[6N+3] order[N-1].tradeAmount   N -> 6N+9\r\n        executeOrder(\r\n            _nums[0],\r\n            _addrs[0],\r\n            _addrs[_i+1],\r\n            _nums[6*_i+4],\r\n            _nums[6*_i+5],\r\n            _nums[6*_i+6],\r\n            _nums[6*_i+9]\r\n        );\r\n    }\r\n\r\n    function checkTradeSignature(\r\n        bytes32 _tradeHash,\r\n        uint[] _nums,\r\n        bytes32[] _rss\r\n    ) private view {\r\n        // _nums[2] trade.v\r\n        // _rss[0] trade.r\r\n        // _rss[1] trade.s\r\n        require(ecrecover(\r\n            _tradeHash, uint8(_nums[2]), _rss[0], _rss[1]\r\n        ) == signer);\r\n    }\r\n\r\n    function sendTradeEvent(\r\n        uint[] _nums, address[] _addrs\r\n    ) private {\r\n        // _nums[1] nonce\r\n        // _nums[0] BUY or SELL\r\n        // _addrs[0] token\r\n        Trade(\r\n            msg.sender, _nums[1], _nums[0], _addrs[0],\r\n            tokens[msg.sender][_addrs[0]], balances[msg.sender]\r\n        );\r\n    }\r\n\r\n    // Executes no more than _tradeAmount tokens from order\r\n    function executeOrder(\r\n        uint    _trade,\r\n        address _token,\r\n        address _orderOwner,\r\n        uint    _orderNonce,\r\n        uint    _orderPrice,\r\n        uint    _orderAmount,\r\n        uint    _tradeAmount\r\n    ) private {\r\n        var (tradeTokens, tradeEther) = getTradeParameters(\r\n            _trade, _token, _orderOwner, _orderNonce, _orderPrice,\r\n            _orderAmount, _tradeAmount\r\n        );\r\n\r\n        filled[_orderOwner][_orderNonce] = SafeMath.add(\r\n            filled[_orderOwner][_orderNonce],\r\n            tradeTokens\r\n        );\r\n\r\n        // Sanity check: orders should never overfill\r\n        require(filled[_orderOwner][_orderNonce] <= _orderAmount);\r\n\r\n        uint makeFees = getFees(tradeEther, makeFee, _orderOwner);\r\n        uint takeFees = getFees(tradeEther, takeFee, msg.sender);\r\n\r\n        swap(\r\n            _trade, _token, _orderOwner, tradeTokens, tradeEther,\r\n            makeFees, takeFees\r\n        );\r\n\r\n        balances[feeCollector] = SafeMath.add(\r\n            balances[feeCollector],\r\n            SafeMath.add(takeFees, makeFees)\r\n        );\r\n\r\n        sendOrderEvent(\r\n            _orderOwner, _orderNonce, _orderPrice, tradeTokens,\r\n            _token, SafeMath.add(takeFees, makeFees)\r\n        );\r\n    }\r\n\r\n    function swap(\r\n        uint _trade,\r\n        address _token,\r\n        address _orderOwner,\r\n        uint _tradeTokens,\r\n        uint _tradeEther,\r\n        uint _makeFees,\r\n        uint _takeFees\r\n    ) private {\r\n        if (_trade == BUY) {\r\n            tokens[msg.sender][_token] = SafeMath.add(\r\n                tokens[msg.sender][_token], _tradeTokens\r\n            );\r\n            tokens[_orderOwner][_token] = SafeMath.sub(\r\n                tokens[_orderOwner][_token], _tradeTokens\r\n            );\r\n            balances[msg.sender] = SafeMath.sub(\r\n                balances[msg.sender], SafeMath.add(_tradeEther, _takeFees)\r\n            );\r\n            balances[_orderOwner] = SafeMath.add(\r\n                balances[_orderOwner], SafeMath.sub(_tradeEther, _makeFees)\r\n            );\r\n        } else {\r\n            tokens[msg.sender][_token] = SafeMath.sub(\r\n                tokens[msg.sender][_token], _tradeTokens\r\n            );\r\n            tokens[_orderOwner][_token] = SafeMath.add(\r\n                tokens[_orderOwner][_token], _tradeTokens\r\n            );\r\n            balances[msg.sender] = SafeMath.add(\r\n                balances[msg.sender], SafeMath.sub(_tradeEther, _takeFees)\r\n            );\r\n            balances[_orderOwner] = SafeMath.sub(\r\n                balances[_orderOwner], SafeMath.add(_tradeEther, _makeFees)\r\n            );\r\n        }\r\n    }\r\n\r\n    function sendOrderEvent(\r\n        address _orderOwner,\r\n        uint _orderNonce,\r\n        uint _orderPrice,\r\n        uint _tradeTokens,\r\n        address _token,\r\n        uint _fees\r\n    ) private {\r\n        Order(\r\n            _orderOwner,\r\n            _orderNonce,\r\n            _orderPrice,\r\n            _tradeTokens,\r\n            filled[_orderOwner][_orderNonce],\r\n            tokens[_orderOwner][_token],\r\n            balances[_orderOwner],\r\n            _fees\r\n        );\r\n    }\r\n\r\n    // Returns number of tokens that could be traded and its total price\r\n    function getTradeParameters(\r\n        uint _trade, address _token, address _orderOwner,\r\n        uint _orderNonce, uint _orderPrice, uint _orderAmount, uint _tradeAmount\r\n    ) private returns (uint _tokens, uint _totalPrice) {\r\n        // remains on order\r\n        _tokens = SafeMath.sub(\r\n            _orderAmount, filled[_orderOwner][_orderNonce]\r\n        );\r\n\r\n        // trade no more than needed\r\n        if (_tokens > _tradeAmount) {\r\n            _tokens = _tradeAmount;\r\n        }\r\n\r\n        if (_trade == BUY) {\r\n            // ask owner has less tokens than it is on ask\r\n            if (_tokens > tokens[_orderOwner][_token]) {\r\n                NotEnoughTokens(\r\n                    _orderOwner, _token, _tokens, tokens[_orderOwner][_token]\r\n                );\r\n                _tokens = tokens[_orderOwner][_token];\r\n            }\r\n        } else {\r\n            // not possible to sell more tokens than sender has\r\n            if (_tokens > tokens[msg.sender][_token]) {\r\n                NotEnoughTokens(\r\n                    msg.sender, _token, _tokens, tokens[msg.sender][_token]\r\n                );\r\n                _tokens = tokens[msg.sender][_token];\r\n            }\r\n        }\r\n\r\n        uint shouldHave = getPrice(_tokens, _orderPrice);\r\n\r\n        uint spendable;\r\n        if (_trade == BUY) {\r\n            // max ether sender can spent\r\n            spendable = reversePercent(\r\n                balances[msg.sender],\r\n                applyCoeff(takeFee, msg.sender)\r\n            );\r\n        } else {\r\n            // max ether bid owner can spent\r\n            spendable = reversePercent(\r\n                balances[_orderOwner],\r\n                applyCoeff(makeFee, _orderOwner)\r\n            );\r\n        }\r\n\r\n        if (shouldHave <= spendable) {\r\n            // everyone have needed amount of tokens & ether\r\n            _totalPrice = shouldHave;\r\n            return;\r\n        }\r\n\r\n        // less price -> less tokens\r\n        _tokens = SafeMath.div(\r\n            SafeMath.mul(spendable, PRICE_MUL), _orderPrice\r\n        );\r\n        _totalPrice = getPrice(_tokens, _orderPrice);\r\n\r\n        if (_trade == BUY) {\r\n            NotEnoughEther(\r\n                msg.sender,\r\n                addFees(shouldHave, applyCoeff(takeFee, msg.sender)),\r\n                _totalPrice\r\n            );\r\n        } else {\r\n            NotEnoughEther(\r\n                _orderOwner,\r\n                addFees(shouldHave, applyCoeff(makeFee, _orderOwner)),\r\n                _totalPrice\r\n            );\r\n        }\r\n    }\r\n\r\n    // Returns price of _tokens\r\n    // _orderPrice is price per 1e18 tokens\r\n    function getPrice(\r\n        uint _tokens, uint _orderPrice\r\n    ) private pure returns (uint) {\r\n        return SafeMath.div(\r\n            SafeMath.mul(_tokens, _orderPrice), PRICE_MUL\r\n        );\r\n    }\r\n\r\n    function getFees(\r\n        uint _eth, uint _fee, address _payer\r\n    ) private view returns (uint) {\r\n        // _eth * (_fee / FEE_MUL)\r\n        return SafeMath.div(\r\n            SafeMath.mul(_eth, applyCoeff(_fee, _payer)),\r\n            FEE_MUL\r\n        );\r\n    }\r\n\r\n    function applyCoeff(uint _fees, address _user) private view returns (uint) {\r\n        if (now >= coeffs[_user].expire) {\r\n            return _fees;\r\n        }\r\n        return SafeMath.div(\r\n            SafeMath.mul(_fees, coeffs[_user].coeff), 100\r\n        );\r\n    }\r\n\r\n    function addFees(uint _eth, uint _fee) private view returns (uint) {\r\n        // _eth * (1 + _fee / FEE_MUL)\r\n        return SafeMath.div(\r\n            SafeMath.mul(_eth, SafeMath.add(FEE_MUL, _fee)),\r\n            FEE_MUL\r\n        );\r\n    }\r\n\r\n    function subFees(uint _eth, uint _fee) private view returns (uint) {\r\n        // _eth * (1 - _fee / FEE_MUL)\r\n        return SafeMath.div(\r\n            SafeMath.mul(_eth, SafeMath.sub(FEE_MUL, _fee)),\r\n            FEE_MUL\r\n        );\r\n    }\r\n\r\n    // Returns maximum ether that can be spent if percent _fee will be added\r\n    function reversePercent(\r\n        uint _balance, uint _fee\r\n    ) private view returns (uint) {\r\n        // _trade + _fees = _balance\r\n        // _trade * (1 + _fee / FEE_MUL) = _balance\r\n        // _trade = _balance * FEE_MUL / (FEE_MUL + _fee)\r\n        return SafeMath.div(\r\n            SafeMath.mul(_balance, FEE_MUL),\r\n            SafeMath.add(FEE_MUL, _fee)\r\n        );\r\n    }\r\n\r\n    // Gets hash of an order, like it is done in `eth_signTypedData`\r\n    // See https://github.com/ethereum/EIPs/pull/712\r\n    function hashOrderTyped(\r\n        uint8 _order, address _token, uint _nonce, uint _price, uint _amount,\r\n        uint _expire\r\n    ) private view returns (bytes32) {\r\n        require(_order == BUY || _order == SELL);\r\n        return keccak256(\r\n            ETH_SIGN_TYPED_DATA_ARGHASH,\r\n            keccak256(\r\n                this,\r\n                _order == BUY ? \"BUY\" : \"SELL\",\r\n                _token,\r\n                _nonce,\r\n                _price,\r\n                _amount,\r\n                _expire\r\n            )\r\n        );\r\n    }\r\n\r\n    // Gets hash of an order for `eth_sign`\r\n    function hashOrder(\r\n        uint8 _order, address _token, uint _nonce, uint _price, uint _amount,\r\n        uint _expire\r\n    ) private view returns (bytes32) {\r\n        return keccak256(\r\n            \"\\x19Ethereum Signed Message:\\n32\",\r\n            keccak256(this, _order, _token, _nonce, _price, _amount, _expire)\r\n        );\r\n    }\r\n\r\n    // Returns hash of an order\r\n    // Reverts if signature is incorrect\r\n    function getVerifiedHash(\r\n        address _signer,\r\n        uint8 _order, address _token,\r\n        uint _nonce, uint _price, uint _amount, uint _expire,\r\n        uint _v, bytes32 _r, bytes32 _s\r\n    ) private view returns (bytes32 _hash) {\r\n        if (_v < 1000) {\r\n            _hash = hashOrderTyped(\r\n                _order, _token, _nonce, _price, _amount, _expire\r\n            );\r\n            require(ecrecover(_hash, uint8(_v), _r, _s) == _signer);\r\n        } else {\r\n            _hash = hashOrder(\r\n                _order, _token, _nonce, _price, _amount, _expire\r\n            );\r\n            require(ecrecover(_hash, uint8(_v - 1000), _r, _s) == _signer);\r\n        }\r\n    }\r\n\r\n    function packKey(\r\n        uint8 _coeff, uint128 _duration\r\n    ) private pure returns (uint) {\r\n        return (uint(_duration) << 8) + uint(_coeff);\r\n    }\r\n\r\n    function updateCoeff(\r\n        address _user, uint8 _coeff, uint128 _expire, uint price\r\n    ) private {\r\n        coeffs[_user] = Coeff(_coeff, _expire);\r\n        NewFeeCoeff(_user, _coeff, _expire, price);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_makeFee\",\"type\":\"uint256\"}],\"name\":\"setMakeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BUY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trades\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coeff\",\"type\":\"uint8\"},{\"name\":\"_duration\",\"type\":\"uint128\"}],\"name\":\"buyPack\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_takeFee\",\"type\":\"uint256\"}],\"name\":\"setTakeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coeff\",\"type\":\"uint8\"},{\"name\":\"_duration\",\"type\":\"uint128\"}],\"name\":\"delPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nums\",\"type\":\"uint256[]\"},{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_rss\",\"type\":\"bytes32[]\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_MUL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_order\",\"type\":\"uint8\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expire\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint256\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_expireDelay\",\"type\":\"uint256\"}],\"name\":\"setExpireDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_coeff\",\"type\":\"uint8\"},{\"name\":\"_duration\",\"type\":\"uint128\"}],\"name\":\"getPack\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"filled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expireDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"packs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"coeffs\",\"outputs\":[{\"name\":\"coeff\",\"type\":\"uint8\"},{\"name\":\"expire\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coeff\",\"type\":\"uint8\"},{\"name\":\"_expire\",\"type\":\"uint128\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"setCoeff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coeff\",\"type\":\"uint8\"},{\"name\":\"_duration\",\"type\":\"uint128\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"addPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_EXPIRE_DELAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_MUL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_SIGN_TYPED_DATA_ARGHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"makeFee\",\"type\":\"uint256\"}],\"name\":\"NewMakeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"takeFee\",\"type\":\"uint256\"}],\"name\":\"NewTakeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"coeff\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"expire\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewFeeCoeff\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"DepositEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"WithdrawEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"DepositToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"WithdrawToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"order\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"orderOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"orderNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tradeTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderFilled\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderOwnerFinalTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderOwnerFinalEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"trade\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"traderFinalTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"traderFinalEther\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shouldHaveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"actualAmount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shouldHaveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"actualAmount\",\"type\":\"uint256\"}],\"name\":\"NotEnoughEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"Ethen","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f2c24291897fbe28fed3c65cf6cf5a1c1b4e484e","Library":"","SwarmSource":"bzzr://679290352a07b8b2a8be66968734ca34dc3445d91f2f38fb81dc649992decd53"}]}