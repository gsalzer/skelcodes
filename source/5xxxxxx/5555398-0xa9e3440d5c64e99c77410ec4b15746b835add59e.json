{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract StorageBase is Ownable {\r\n\r\n    function withdrawBalance() external onlyOwner returns (bool) {\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = msg.sender.send(address(this).balance);\r\n        return res;\r\n    }\r\n}\r\n\r\n// owner of ActivityStorage should be ActivityCore contract address\r\ncontract ActivityStorage is StorageBase {\r\n\r\n    struct Activity {\r\n        // accept bid or not\r\n        bool isPause;\r\n        // limit max num of monster buyable per address\r\n        uint16 buyLimit;\r\n        // price (in wei)\r\n        uint128 packPrice;\r\n        // startDate (in seconds)\r\n        uint64 startDate;\r\n        // endDate (in seconds)\r\n        uint64 endDate;\r\n        // packId => address of bid winner\r\n        mapping(uint16 => address) soldPackToAddress;\r\n        // address => number of success bid\r\n        mapping(address => uint16) addressBoughtCount;\r\n    }\r\n\r\n    // limit max activityId to 65536, big enough\r\n    mapping(uint16 => Activity) public activities;\r\n\r\n    function createActivity(\r\n        uint16 _activityId,\r\n        uint16 _buyLimit,\r\n        uint128 _packPrice,\r\n        uint64 _startDate,\r\n        uint64 _endDate\r\n    ) \r\n        external\r\n        onlyOwner\r\n    {\r\n        // activity should not exist and can only be initialized once\r\n        require(activities[_activityId].buyLimit == 0);\r\n\r\n        activities[_activityId] = Activity({\r\n            isPause: false,\r\n            buyLimit: _buyLimit,\r\n            packPrice: _packPrice,\r\n            startDate: _startDate,\r\n            endDate: _endDate\r\n        });\r\n    }\r\n\r\n    function sellPackToAddress(\r\n        uint16 _activityId, \r\n        uint16 _packId, \r\n        address buyer\r\n    ) \r\n        external \r\n        onlyOwner\r\n    {\r\n        Activity storage activity = activities[_activityId];\r\n        activity.soldPackToAddress[_packId] = buyer;\r\n        activity.addressBoughtCount[buyer]++;\r\n    }\r\n\r\n    function pauseActivity(uint16 _activityId) external onlyOwner {\r\n        activities[_activityId].isPause = true;\r\n    }\r\n\r\n    function unpauseActivity(uint16 _activityId) external onlyOwner {\r\n        activities[_activityId].isPause = false;\r\n    }\r\n\r\n    function deleteActivity(uint16 _activityId) external onlyOwner {\r\n        delete activities[_activityId];\r\n    }\r\n\r\n    function getAddressBoughtCount(uint16 _activityId, address buyer) external view returns (uint16) {\r\n        return activities[_activityId].addressBoughtCount[buyer];\r\n    }\r\n\r\n    function getBuyerAddress(uint16 _activityId, uint16 packId) external view returns (address) {\r\n        return activities[_activityId].soldPackToAddress[packId];\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract HasNoContracts is Pausable {\r\n\r\n    function reclaimContract(address _contractAddr) external onlyOwner whenPaused {\r\n        Ownable contractInst = Ownable(_contractAddr);\r\n        contractInst.transferOwnership(owner);\r\n    }\r\n}\r\n\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract LogicBase is HasNoContracts {\r\n\r\n    /// The ERC-165 interface signature for ERC-721.\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\r\n    bytes4 constant InterfaceSignature_NFC = bytes4(0x9f40b779);\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    ERC721 public nonFungibleContract;\r\n\r\n    // Reference to storage contract\r\n    StorageBase public storageContract;\r\n\r\n    function LogicBase(address _nftAddress, address _storageAddress) public {\r\n        // paused by default\r\n        paused = true;\r\n\r\n        setNFTAddress(_nftAddress);\r\n\r\n        require(_storageAddress != address(0));\r\n        storageContract = StorageBase(_storageAddress);\r\n    }\r\n\r\n    // Very dangerous action, only when new contract has been proved working\r\n    // Requires storageContract already transferOwnership to the new contract\r\n    // This method is only used to transfer the balance to owner\r\n    function destroy() external onlyOwner whenPaused {\r\n        address storageOwner = storageContract.owner();\r\n        // owner of storageContract must not be the current contract otherwise the storageContract will forever not accessible\r\n        require(storageOwner != address(this));\r\n        // Transfers the current balance to the owner and terminates the contract\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // Very dangerous action, only when new contract has been proved working\r\n    // Requires storageContract already transferOwnership to the new contract\r\n    // This method is only used to transfer the balance to the new contract\r\n    function destroyAndSendToStorageOwner() external onlyOwner whenPaused {\r\n        address storageOwner = storageContract.owner();\r\n        // owner of storageContract must not be the current contract otherwise the storageContract will forever not accessible\r\n        require(storageOwner != address(this));\r\n        // Transfers the current balance to the new owner of the storage contract and terminates the contract\r\n        selfdestruct(storageOwner);\r\n    }\r\n\r\n    // override to make sure everything is initialized before the unpause\r\n    function unpause() public onlyOwner whenPaused {\r\n        // can not unpause when the logic contract is not initialzed\r\n        require(nonFungibleContract != address(0));\r\n        require(storageContract != address(0));\r\n        // can not unpause when ownership of storage contract is not the current contract\r\n        require(storageContract.owner() == address(this));\r\n\r\n        super.unpause();\r\n    }\r\n\r\n    function setNFTAddress(address _nftAddress) public onlyOwner {\r\n        require(_nftAddress != address(0));\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        require(candidateContract.supportsInterface(InterfaceSignature_NFC));\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    // Withdraw balance to the Core Contract\r\n    function withdrawBalance() external returns (bool) {\r\n        address nftAddress = address(nonFungibleContract);\r\n        // either Owner or Core Contract can trigger the withdraw\r\n        require(msg.sender == owner || msg.sender == nftAddress);\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = nftAddress.send(address(this).balance);\r\n        return res;\r\n    }\r\n\r\n    function withdrawBalanceFromStorageContract() external returns (bool) {\r\n        address nftAddress = address(nonFungibleContract);\r\n        // either Owner or Core Contract can trigger the withdraw\r\n        require(msg.sender == owner || msg.sender == nftAddress);\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = storageContract.withdrawBalance();\r\n        return res;\r\n    }\r\n}\r\n\r\ncontract ActivityCore is LogicBase {\r\n\r\n    bool public isActivityCore = true;\r\n\r\n    ActivityStorage activityStorage;\r\n\r\n    event ActivityCreated(uint16 activityId);\r\n    event ActivityBidSuccess(uint16 activityId, uint16 packId, address winner);\r\n\r\n    function ActivityCore(address _nftAddress, address _storageAddress) \r\n        LogicBase(_nftAddress, _storageAddress) public {\r\n            \r\n        activityStorage = ActivityStorage(_storageAddress);\r\n    }\r\n\r\n    function createActivity(\r\n        uint16 _activityId,\r\n        uint16 _buyLimit,\r\n        uint128 _packPrice,\r\n        uint64 _startDate,\r\n        uint64 _endDate\r\n    ) \r\n        external\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n        activityStorage.createActivity(_activityId, _buyLimit, _packPrice, _startDate, _endDate);\r\n\r\n        emit ActivityCreated(_activityId);\r\n    }\r\n\r\n    // Very dangerous action and should be only used for testing\r\n    // Must pause the contract first \r\n    function deleteActivity(\r\n        uint16 _activityId\r\n    )\r\n        external \r\n        onlyOwner\r\n        whenPaused\r\n    {\r\n        activityStorage.deleteActivity(_activityId);\r\n    }\r\n\r\n    function getActivity(\r\n        uint16 _activityId\r\n    ) \r\n        external \r\n        view  \r\n        returns (\r\n            bool isPause,\r\n            uint16 buyLimit,\r\n            uint128 packPrice,\r\n            uint64 startDate,\r\n            uint64 endDate\r\n        )\r\n    {\r\n        return activityStorage.activities(_activityId);\r\n    }\r\n    \r\n    function bid(uint16 _activityId, uint16 _packId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        bool isPause;\r\n        uint16 buyLimit;\r\n        uint128 packPrice;\r\n        uint64 startDate;\r\n        uint64 endDate;\r\n        (isPause, buyLimit, packPrice, startDate, endDate) = activityStorage.activities(_activityId);\r\n        // not allow to bid when activity is paused\r\n        require(!isPause);\r\n        // not allow to bid when activity is not initialized (buyLimit == 0)\r\n        require(buyLimit > 0);\r\n        // should send enough ether\r\n        require(msg.value >= packPrice);\r\n        // verify startDate & endDate\r\n        require(now >= startDate && now <= endDate);\r\n        // this pack is not sold out\r\n        require(activityStorage.getBuyerAddress(_activityId, _packId) == address(0));\r\n        // buyer not exceed buyLimit\r\n        require(activityStorage.getAddressBoughtCount(_activityId, msg.sender) < buyLimit);\r\n        // record in blockchain\r\n        activityStorage.sellPackToAddress(_activityId, _packId, msg.sender);\r\n        // emit the success event\r\n        emit ActivityBidSuccess(_activityId, _packId, msg.sender);\r\n    }\r\n}\r\n\r\ncontract CryptoStorage is StorageBase {\r\n\r\n    struct Monster {\r\n        uint32 matronId;\r\n        uint32 sireId;\r\n        uint32 siringWithId;\r\n        uint16 cooldownIndex;\r\n        uint16 generation;\r\n        uint64 cooldownEndBlock;\r\n        uint64 birthTime;\r\n        uint16 monsterId;\r\n        uint32 monsterNum;\r\n        bytes properties;\r\n    }\r\n\r\n    // ERC721 tokens\r\n    Monster[] internal monsters;\r\n\r\n    // total number of monster created from system instead of breeding\r\n    uint256 public promoCreatedCount;\r\n\r\n    // total number of monster created by system sale address\r\n    uint256 public systemCreatedCount;\r\n\r\n    // number of monsters in pregnant\r\n    uint256 public pregnantMonsters;\r\n    \r\n    // monsterId => total number\r\n    mapping (uint256 => uint32) public monsterCurrentNumber;\r\n    \r\n    // tokenId => owner address\r\n    mapping (uint256 => address) public monsterIndexToOwner;\r\n\r\n    // owner address => balance of tokens\r\n    mapping (address => uint256) public ownershipTokenCount;\r\n\r\n    // tokenId => approved address\r\n    mapping (uint256 => address) public monsterIndexToApproved;\r\n\r\n    function CryptoStorage() public {\r\n        // placeholder to make the first available monster to have a tokenId starts from 1\r\n        createMonster(0, 0, 0, 0, 0, \"\");\r\n    }\r\n\r\n    function createMonster(\r\n        uint256 _matronId,\r\n        uint256 _sireId,\r\n        uint256 _generation,\r\n        uint256 _birthTime,\r\n        uint256 _monsterId,\r\n        bytes _properties\r\n    ) \r\n        public \r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        require(_matronId == uint256(uint32(_matronId)));\r\n        require(_sireId == uint256(uint32(_sireId)));\r\n        require(_generation == uint256(uint16(_generation)));\r\n        require(_birthTime == uint256(uint64(_birthTime)));\r\n        require(_monsterId == uint256(uint16(_monsterId)));\r\n\r\n        monsterCurrentNumber[_monsterId]++;\r\n\r\n        Monster memory monster = Monster({\r\n            matronId: uint32(_matronId),\r\n            sireId: uint32(_sireId),\r\n            siringWithId: 0,\r\n            cooldownIndex: 0,\r\n            generation: uint16(_generation),\r\n            cooldownEndBlock: 0,\r\n            birthTime: uint64(_birthTime),\r\n            monsterId: uint16(_monsterId),\r\n            monsterNum: monsterCurrentNumber[_monsterId],\r\n            properties: _properties\r\n        });\r\n        uint256 tokenId = monsters.push(monster) - 1;\r\n\r\n        // overflow check\r\n        require(tokenId == uint256(uint32(tokenId)));\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function getMonster(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            bool isGestating,\r\n            bool isReady,\r\n            uint16 cooldownIndex,\r\n            uint64 nextActionAt,\r\n            uint32 siringWithId,\r\n            uint32 matronId,\r\n            uint32 sireId,\r\n            uint64 cooldownEndBlock,\r\n            uint16 generation,\r\n            uint64 birthTime,\r\n            uint32 monsterNum,\r\n            uint16 monsterId,\r\n            bytes properties\r\n        ) \r\n    {\r\n        Monster storage monster = monsters[_tokenId];\r\n\r\n        isGestating = (monster.siringWithId != 0);\r\n        isReady = (monster.cooldownEndBlock <= block.number);\r\n        cooldownIndex = monster.cooldownIndex;\r\n        nextActionAt = monster.cooldownEndBlock;\r\n        siringWithId = monster.siringWithId;\r\n        matronId = monster.matronId;\r\n        sireId = monster.sireId;\r\n        cooldownEndBlock = monster.cooldownEndBlock;\r\n        generation = monster.generation;\r\n        birthTime = monster.birthTime;\r\n        monsterNum = monster.monsterNum;\r\n        monsterId = monster.monsterId;\r\n        properties = monster.properties;\r\n    }\r\n\r\n    function getMonsterCount() external view returns (uint256) {\r\n        return monsters.length - 1;\r\n    }\r\n\r\n    function getMatronId(uint256 _tokenId) external view returns (uint32) {\r\n        return monsters[_tokenId].matronId;\r\n    }\r\n\r\n    function getSireId(uint256 _tokenId) external view returns (uint32) {\r\n        return monsters[_tokenId].sireId;\r\n    }\r\n\r\n    function getSiringWithId(uint256 _tokenId) external view returns (uint32) {\r\n        return monsters[_tokenId].siringWithId;\r\n    }\r\n    \r\n    function setSiringWithId(uint256 _tokenId, uint32 _siringWithId) external onlyOwner {\r\n        monsters[_tokenId].siringWithId = _siringWithId;\r\n    }\r\n\r\n    function deleteSiringWithId(uint256 _tokenId) external onlyOwner {\r\n        delete monsters[_tokenId].siringWithId;\r\n    }\r\n\r\n    function getCooldownIndex(uint256 _tokenId) external view returns (uint16) {\r\n        return monsters[_tokenId].cooldownIndex;\r\n    }\r\n\r\n    function setCooldownIndex(uint256 _tokenId) external onlyOwner {\r\n        monsters[_tokenId].cooldownIndex += 1;\r\n    }\r\n\r\n    function getGeneration(uint256 _tokenId) external view returns (uint16) {\r\n        return monsters[_tokenId].generation;\r\n    }\r\n\r\n    function getCooldownEndBlock(uint256 _tokenId) external view returns (uint64) {\r\n        return monsters[_tokenId].cooldownEndBlock;\r\n    }\r\n\r\n    function setCooldownEndBlock(uint256 _tokenId, uint64 _cooldownEndBlock) external onlyOwner {\r\n        monsters[_tokenId].cooldownEndBlock = _cooldownEndBlock;\r\n    }\r\n\r\n    function getBirthTime(uint256 _tokenId) external view returns (uint64) {\r\n        return monsters[_tokenId].birthTime;\r\n    }\r\n\r\n    function getMonsterId(uint256 _tokenId) external view returns (uint16) {\r\n        return monsters[_tokenId].monsterId;\r\n    }\r\n\r\n    function getMonsterNum(uint256 _tokenId) external view returns (uint32) {\r\n        return monsters[_tokenId].monsterNum;\r\n    }\r\n\r\n    function getProperties(uint256 _tokenId) external view returns (bytes) {\r\n        return monsters[_tokenId].properties;\r\n    }\r\n\r\n    function updateProperties(uint256 _tokenId, bytes _properties) external onlyOwner {\r\n        monsters[_tokenId].properties = _properties;\r\n    }\r\n    \r\n    function setMonsterIndexToOwner(uint256 _tokenId, address _owner) external onlyOwner {\r\n        monsterIndexToOwner[_tokenId] = _owner;\r\n    }\r\n\r\n    function increaseOwnershipTokenCount(address _owner) external onlyOwner {\r\n        ownershipTokenCount[_owner]++;\r\n    }\r\n\r\n    function decreaseOwnershipTokenCount(address _owner) external onlyOwner {\r\n        ownershipTokenCount[_owner]--;\r\n    }\r\n\r\n    function setMonsterIndexToApproved(uint256 _tokenId, address _approved) external onlyOwner {\r\n        monsterIndexToApproved[_tokenId] = _approved;\r\n    }\r\n    \r\n    function deleteMonsterIndexToApproved(uint256 _tokenId) external onlyOwner {\r\n        delete monsterIndexToApproved[_tokenId];\r\n    }\r\n\r\n    function increasePromoCreatedCount() external onlyOwner {\r\n        promoCreatedCount++;\r\n    }\r\n\r\n    function increaseSystemCreatedCount() external onlyOwner {\r\n        systemCreatedCount++;\r\n    }\r\n\r\n    function increasePregnantCounter() external onlyOwner {\r\n        pregnantMonsters++;\r\n    }\r\n\r\n    function decreasePregnantCounter() external onlyOwner {\r\n        pregnantMonsters--;\r\n    }\r\n}\r\n\r\ncontract ClockAuctionStorage is StorageBase {\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) at beginning of auction\r\n        uint128 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint128 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint64 duration;\r\n        // Time when auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n    function addAuction(\r\n        uint256 _tokenId,\r\n        address _seller,\r\n        uint128 _startingPrice,\r\n        uint128 _endingPrice,\r\n        uint64 _duration,\r\n        uint64 _startedAt\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        tokenIdToAuction[_tokenId] = Auction(\r\n            _seller,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            _startedAt\r\n        );\r\n    }\r\n\r\n    function removeAuction(uint256 _tokenId) public onlyOwner {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            address seller,\r\n            uint128 startingPrice,\r\n            uint128 endingPrice,\r\n            uint64 duration,\r\n            uint64 startedAt\r\n        )\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        return (\r\n            auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    function isOnAuction(uint256 _tokenId) external view returns (bool) {\r\n        return (tokenIdToAuction[_tokenId].startedAt > 0);\r\n    }\r\n\r\n    function getSeller(uint256 _tokenId) external view returns (address) {\r\n        return tokenIdToAuction[_tokenId].seller;\r\n    }\r\n\r\n    function transfer(ERC721 _nonFungibleContract, address _receiver, uint256 _tokenId) external onlyOwner {\r\n        // it will throw if transfer fails\r\n        _nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n}\r\n\r\ncontract SaleClockAuctionStorage is ClockAuctionStorage {\r\n    bool public isSaleClockAuctionStorage = true;\r\n\r\n    // total accumulate sold count\r\n    uint256 public totalSoldCount;\r\n\r\n    // last 3 sale price\r\n    uint256[3] public lastSoldPrices;\r\n\r\n    // current on sale auction count from system\r\n    uint256 public systemOnSaleCount;\r\n\r\n    // map of on sale token ids from system\r\n    mapping (uint256 => bool) systemOnSaleTokens;\r\n\r\n    function removeAuction(uint256 _tokenId) public onlyOwner {\r\n        // first remove auction from state variable\r\n        super.removeAuction(_tokenId);\r\n\r\n        // update system on sale record\r\n        if (systemOnSaleTokens[_tokenId]) {\r\n            delete systemOnSaleTokens[_tokenId];\r\n            \r\n            if (systemOnSaleCount > 0) {\r\n                systemOnSaleCount--;\r\n            }\r\n        }\r\n    }\r\n\r\n    function recordSystemOnSaleToken(uint256 _tokenId) external onlyOwner {\r\n        if (!systemOnSaleTokens[_tokenId]) {\r\n            systemOnSaleTokens[_tokenId] = true;\r\n            systemOnSaleCount++;\r\n        }\r\n    }\r\n\r\n    function recordSoldPrice(uint256 _price) external onlyOwner {\r\n        lastSoldPrices[totalSoldCount % 3] = _price;\r\n        totalSoldCount++;\r\n    }\r\n\r\n    function averageSoldPrice() external view returns (uint256) {\r\n        if (totalSoldCount == 0) return 0;\r\n        \r\n        uint256 sum = 0;\r\n        uint256 len = (totalSoldCount < 3 ? totalSoldCount : 3);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            sum += lastSoldPrices[i];\r\n        }\r\n        return sum / len;\r\n    }\r\n}\r\n\r\ncontract ClockAuction is LogicBase {\r\n    \r\n    // Reference to contract tracking auction state variables\r\n    ClockAuctionStorage public clockAuctionStorage;\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    // Minimum cut value on each auction (in WEI)\r\n    uint256 public minCutValue;\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner, address seller, uint256 sellerProceeds);\r\n    event AuctionCancelled(uint256 tokenId);\r\n\r\n    function ClockAuction(address _nftAddress, address _storageAddress, uint256 _cut, uint256 _minCutValue) \r\n        LogicBase(_nftAddress, _storageAddress) public\r\n    {\r\n        setOwnerCut(_cut);\r\n        setMinCutValue(_minCutValue);\r\n\r\n        clockAuctionStorage = ClockAuctionStorage(_storageAddress);\r\n    }\r\n\r\n    function setOwnerCut(uint256 _cut) public onlyOwner {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n    }\r\n\r\n    function setMinCutValue(uint256 _minCutValue) public onlyOwner {\r\n        minCutValue = _minCutValue;\r\n    }\r\n\r\n    function getMinPrice() public view returns (uint256) {\r\n        // return ownerCut > 0 ? (minCutValue / ownerCut * 10000) : 0;\r\n        // use minCutValue directly, when the price == minCutValue seller will get no profit\r\n        return minCutValue;\r\n    }\r\n\r\n    // Only auction from none system user need to verify the price\r\n    // System auction can set any price\r\n    function isValidPrice(uint256 _startingPrice, uint256 _endingPrice) public view returns (bool) {\r\n        return (_startingPrice < _endingPrice ? _startingPrice : _endingPrice) >= getMinPrice();\r\n    }\r\n\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        public\r\n        whenNotPaused\r\n    {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        \r\n        // assigning ownership to this clockAuctionStorage when in auction\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transferFrom(_seller, address(clockAuctionStorage), _tokenId);\r\n\r\n        // Require that all auctions have a duration of at least one minute.\r\n        require(_duration >= 1 minutes);\r\n\r\n        clockAuctionStorage.addAuction(\r\n            _tokenId,\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n\r\n        emit AuctionCreated(_tokenId, _startingPrice, _endingPrice, _duration);\r\n    }\r\n\r\n    function cancelAuction(uint256 _tokenId) external {\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n        address seller = clockAuctionStorage.getSeller(_tokenId);\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    function cancelAuctionWhenPaused(uint256 _tokenId) external whenPaused onlyOwner {\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n        address seller = clockAuctionStorage.getSeller(_tokenId);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    function getAuction(uint256 _tokenId)\r\n        public\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n        return clockAuctionStorage.getAuction(_tokenId);\r\n    }\r\n\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n        return _currentPrice(_tokenId);\r\n    }\r\n\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        clockAuctionStorage.removeAuction(_tokenId);\r\n        clockAuctionStorage.transfer(nonFungibleContract, _seller, _tokenId);\r\n        emit AuctionCancelled(_tokenId);\r\n    }\r\n\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount, address bidder) internal returns (uint256) {\r\n\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(_tokenId);\r\n        require(_bidAmount >= price);\r\n\r\n        address seller = clockAuctionStorage.getSeller(_tokenId);\r\n        uint256 sellerProceeds = 0;\r\n\r\n        // Remove the auction before sending the fees to the sender so we can't have a reentrancy attack\r\n        clockAuctionStorage.removeAuction(_tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the auctioneer's cut, so this subtraction can't go negative\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            sellerProceeds = price - auctioneerCut;\r\n\r\n            // transfer the sellerProceeds\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid\r\n        // transfer it back to bidder.\r\n        // this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n        bidder.transfer(bidExcess);\r\n\r\n        emit AuctionSuccessful(_tokenId, price, bidder, seller, sellerProceeds);\r\n\r\n        return price;\r\n    }\r\n\r\n    function _currentPrice(uint256 _tokenId) internal view returns (uint256) {\r\n\r\n        uint256 secondsPassed = 0;\r\n\r\n        address seller;\r\n        uint128 startingPrice;\r\n        uint128 endingPrice;\r\n        uint64 duration;\r\n        uint64 startedAt;\r\n        (seller, startingPrice, endingPrice, duration, startedAt) = clockAuctionStorage.getAuction(_tokenId);\r\n\r\n        if (now > startedAt) {\r\n            secondsPassed = now - startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            startingPrice,\r\n            endingPrice,\r\n            duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_secondsPassed >= _duration) {\r\n            return _endingPrice;\r\n        } else {\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        uint256 cutValue = _price * ownerCut / 10000;\r\n        if (_price < minCutValue) return cutValue;\r\n        if (cutValue > minCutValue) return cutValue;\r\n        return minCutValue;\r\n    }\r\n}\r\n\r\ncontract SaleClockAuction is ClockAuction {\r\n\r\n    bool public isSaleClockAuction = true;\r\n\r\n    address public systemSaleAddress;\r\n    uint256 public systemStartingPriceMin = 20 finney;\r\n    uint256 public systemEndingPrice = 0;\r\n    uint256 public systemAuctionDuration = 1 days;\r\n\r\n    function SaleClockAuction(address _nftAddr, address _storageAddress, address _systemSaleAddress, uint256 _cut, uint256 _minCutValue) \r\n        ClockAuction(_nftAddr, _storageAddress, _cut, _minCutValue) public\r\n    {\r\n        require(SaleClockAuctionStorage(_storageAddress).isSaleClockAuctionStorage());\r\n        \r\n        setSystemSaleAddress(_systemSaleAddress);\r\n    }\r\n  \r\n    function bid(uint256 _tokenId) external payable {\r\n        uint256 price = _bid(_tokenId, msg.value, msg.sender);\r\n        \r\n        clockAuctionStorage.transfer(nonFungibleContract, msg.sender, _tokenId);\r\n        \r\n        SaleClockAuctionStorage(clockAuctionStorage).recordSoldPrice(price);\r\n    }\r\n\r\n    function createSystemAuction(uint256 _tokenId) external {\r\n        require(msg.sender == address(nonFungibleContract));\r\n\r\n        createAuction(\r\n            _tokenId,\r\n            computeNextSystemSalePrice(),\r\n            systemEndingPrice,\r\n            systemAuctionDuration,\r\n            systemSaleAddress\r\n        );\r\n\r\n        SaleClockAuctionStorage(clockAuctionStorage).recordSystemOnSaleToken(_tokenId);\r\n    }\r\n\r\n    function setSystemSaleAddress(address _systemSaleAddress) public onlyOwner {\r\n        require(_systemSaleAddress != address(0));\r\n        systemSaleAddress = _systemSaleAddress;\r\n    }\r\n\r\n    function setSystemStartingPriceMin(uint256 _startingPrice) external onlyOwner {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        systemStartingPriceMin = _startingPrice;\r\n    }\r\n\r\n    function setSystemEndingPrice(uint256 _endingPrice) external onlyOwner {\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        systemEndingPrice = _endingPrice;\r\n    }\r\n\r\n    function setSystemAuctionDuration(uint256 _duration) external onlyOwner {\r\n        require(_duration == uint256(uint64(_duration)));\r\n        systemAuctionDuration = _duration;\r\n    }\r\n\r\n    function totalSoldCount() external view returns (uint256) {\r\n        return SaleClockAuctionStorage(clockAuctionStorage).totalSoldCount();\r\n    }\r\n\r\n    function systemOnSaleCount() external view returns (uint256) {\r\n        return SaleClockAuctionStorage(clockAuctionStorage).systemOnSaleCount();\r\n    }\r\n\r\n    function averageSoldPrice() external view returns (uint256) {\r\n        return SaleClockAuctionStorage(clockAuctionStorage).averageSoldPrice();\r\n    }\r\n\r\n    function computeNextSystemSalePrice() public view returns (uint256) {\r\n        uint256 avePrice = SaleClockAuctionStorage(clockAuctionStorage).averageSoldPrice();\r\n\r\n        require(avePrice == uint256(uint128(avePrice)));\r\n\r\n        uint256 nextPrice = avePrice + (avePrice / 2);\r\n\r\n        if (nextPrice < systemStartingPriceMin) {\r\n            nextPrice = systemStartingPriceMin;\r\n        }\r\n\r\n        return nextPrice;\r\n    }\r\n}\r\n\r\ncontract SiringClockAuctionStorage is ClockAuctionStorage {\r\n    bool public isSiringClockAuctionStorage = true;\r\n}\r\n\r\ncontract SiringClockAuction is ClockAuction {\r\n\r\n    bool public isSiringClockAuction = true;\r\n\r\n    function SiringClockAuction(address _nftAddr, address _storageAddress, uint256 _cut, uint256 _minCutValue) \r\n        ClockAuction(_nftAddr, _storageAddress, _cut, _minCutValue) public\r\n    {\r\n        require(SiringClockAuctionStorage(_storageAddress).isSiringClockAuctionStorage());\r\n    }\r\n\r\n    function bid(uint256 _tokenId, address bidder) external payable {\r\n        // can only be called by CryptoZoo\r\n        require(msg.sender == address(nonFungibleContract));\r\n        // get seller before the _bid for the auction will be removed once the bid success\r\n        address seller = clockAuctionStorage.getSeller(_tokenId);\r\n        // _bid checks that token ID is valid and will throw if bid fails\r\n        _bid(_tokenId, msg.value, bidder);\r\n        // transfer the monster back to the seller, the winner will get the child\r\n        clockAuctionStorage.transfer(nonFungibleContract, seller, _tokenId);\r\n    }\r\n}\r\n\r\ncontract ZooAccessControl is HasNoContracts {\r\n\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) public onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCFO(address _newCFO) public onlyCEO {\r\n        require(_newCFO != address(0));\r\n        cfoAddress = _newCFO;\r\n    }\r\n    \r\n    function setCOO(address _newCOO) public onlyCEO {\r\n        require(_newCOO != address(0));\r\n        cooAddress = _newCOO;\r\n    }\r\n}\r\n\r\ncontract Zoo721 is ZooAccessControl, ERC721 {\r\n\r\n    // ERC721 Required\r\n    string public constant name = \"Giftomon\";\r\n    // ERC721 Required\r\n    string public constant symbol = \"GTOM\";\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('transfer(address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('tokensOfOwner(address)'));\r\n\r\n    CryptoStorage public cryptoStorage;\r\n\r\n    function Zoo721(address _storageAddress) public {\r\n        require(_storageAddress != address(0));\r\n        cryptoStorage = CryptoStorage(_storageAddress);\r\n    }\r\n\r\n    // ERC165 Required\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    // ERC721 Required\r\n    function totalSupply() public view returns (uint) {\r\n        return cryptoStorage.getMonsterCount();\r\n    }\r\n    \r\n    // ERC721 Required\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return cryptoStorage.ownershipTokenCount(_owner);\r\n    }\r\n\r\n    // ERC721 Required\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner) {\r\n        owner = cryptoStorage.monsterIndexToOwner(_tokenId);\r\n        require(owner != address(0));\r\n    }\r\n\r\n    // ERC721 Required\r\n    function approve(address _to, uint256 _tokenId) external whenNotPaused {\r\n        require(_owns(msg.sender, _tokenId));\r\n        _approve(_tokenId, _to);\r\n        emit Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    // ERC721 Required\r\n    function transfer(address _to, uint256 _tokenId) external whenNotPaused {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Not allow to transfer to the contract itself except for system sale monsters\r\n        require(_to != address(this));\r\n        // You can only send your own cat.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    // ERC721 Required\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    // ERC721 Optional\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalTokens = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            uint256 tokenId;\r\n\r\n            for (tokenId = 1; tokenId <= totalTokens; tokenId++) {\r\n                if (cryptoStorage.monsterIndexToOwner(tokenId) == _owner) {\r\n                    result[resultIndex] = tokenId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        // increase number of token owned by _to\r\n        cryptoStorage.increaseOwnershipTokenCount(_to);\r\n\r\n        // transfer ownership\r\n        cryptoStorage.setMonsterIndexToOwner(_tokenId, _to);\r\n\r\n        // new monster born does not have previous owner\r\n        if (_from != address(0)) {\r\n            // decrease number of token owned by _from\r\n            cryptoStorage.decreaseOwnershipTokenCount(_from);\r\n            // clear any previously approved ownership exchange\r\n            cryptoStorage.deleteMonsterIndexToApproved(_tokenId);\r\n        }\r\n        \r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return cryptoStorage.monsterIndexToOwner(_tokenId) == _claimant;\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        cryptoStorage.setMonsterIndexToApproved(_tokenId, _approved);\r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return cryptoStorage.monsterIndexToApproved(_tokenId) == _claimant;\r\n    }\r\n}\r\n\r\ncontract CryptoZoo is Zoo721 {\r\n\r\n    uint256 public constant SYSTEM_CREATION_LIMIT = 10000;\r\n\r\n    // new monster storage fee for the coo\r\n    uint256 public autoBirthFee = 2 finney;\r\n\r\n    // an approximation of currently how many seconds are in between blocks.\r\n    uint256 public secondsPerBlock = 15;\r\n\r\n    // hatch duration in second by hatch times (start from 0)\r\n    // default to 1 minute if not set and minimum to 1 minute \r\n    // must be an integral multiple of 1 minute\r\n    uint32[] public hatchDurationByTimes = [uint32(1 minutes)];\r\n\r\n    // hatch duration multiple value by generation (start from 0)\r\n    // multiple = value / 60, 60 is the base value\r\n    // default to 60 if not set and minimum to 60\r\n    // must be an integral multiple of secondsPerBlock\r\n    uint32[] public hatchDurationMultiByGeneration = [uint32(60)];\r\n\r\n    // sale auctions\r\n    SaleClockAuction public saleAuction;\r\n    \r\n    // siring auctions\r\n    SiringClockAuction public siringAuction;\r\n\r\n    // activity core\r\n    ActivityCore public activityCore;\r\n\r\n    // events\r\n    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 matronCooldownEndBlock, uint256 sireCooldownEndBlock, uint256 breedCost);\r\n    event Birth(address owner, uint256 tokenId, uint256 matronId, uint256 sireId);\r\n\r\n    // Core Contract of Giftomon\r\n    function CryptoZoo(address _storageAddress, address _cooAddress, address _cfoAddress) Zoo721(_storageAddress) public {\r\n        // paused by default\r\n        paused = true;\r\n        // ceo defaults the the contract creator\r\n        ceoAddress = msg.sender;\r\n\r\n        setCOO(_cooAddress);\r\n        setCFO(_cfoAddress);\r\n    }\r\n\r\n    function() external payable {\r\n        require(\r\n            msg.sender == address(saleAuction) ||\r\n            msg.sender == address(siringAuction) ||\r\n            msg.sender == address(activityCore) || \r\n            msg.sender == cooAddress\r\n        );\r\n    }\r\n\r\n    // override to allow any CLevel to pause the contract\r\n    function pause() public onlyCLevel whenNotPaused {\r\n        super.pause();\r\n    }\r\n\r\n    // override to make sure everything is initialized before the unpause\r\n    function unpause() public onlyCEO whenPaused {\r\n        // can not unpause when CLevel addresses is not initialized\r\n        require(ceoAddress != address(0));\r\n        require(cooAddress != address(0));\r\n        require(cfoAddress != address(0));\r\n        // can not unpause when the logic contract is not initialzed\r\n        require(saleAuction != address(0));\r\n        require(siringAuction != address(0));\r\n        require(activityCore != address(0));\r\n        require(cryptoStorage != address(0));\r\n        // can not unpause when ownership of storage contract is not the current contract\r\n        require(cryptoStorage.owner() == address(this));\r\n\r\n        super.unpause();\r\n    }\r\n\r\n    // Very dangerous action, only when new contract has been proved working\r\n    // Requires cryptoStorage already transferOwnership to the new contract\r\n    // This method is only used to transfer the balance (authBirthFee used for giveBirth) to ceo\r\n    function destroy() external onlyCEO whenPaused {\r\n        address storageOwner = cryptoStorage.owner();\r\n        // owner of cryptoStorage must not be the current contract otherwise the cryptoStorage will forever in accessable\r\n        require(storageOwner != address(this));\r\n        // Transfers the current balance to the ceo and terminates the contract\r\n        selfdestruct(ceoAddress);\r\n    }\r\n\r\n    // Very dangerous action, only when new contract has been proved working\r\n    // Requires cryptoStorage already transferOwnership to the new contract\r\n    // This method is only used to transfer the balance (authBirthFee used for giveBirth) to the new contract\r\n    function destroyAndSendToStorageOwner() external onlyCEO whenPaused {\r\n        address storageOwner = cryptoStorage.owner();\r\n        // owner of cryptoStorage must not be the current contract otherwise the cryptoStorage will forever in accessable\r\n        require(storageOwner != address(this));\r\n        // Transfers the current balance to the new owner of the storage contract and terminates the contract\r\n        selfdestruct(storageOwner);\r\n    }\r\n\r\n    function setSaleAuctionAddress(address _address) external onlyCEO {\r\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\r\n        require(candidateContract.isSaleClockAuction());\r\n        saleAuction = candidateContract;\r\n    }\r\n\r\n    function setSiringAuctionAddress(address _address) external onlyCEO {\r\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\r\n        require(candidateContract.isSiringClockAuction());\r\n        siringAuction = candidateContract;\r\n    }\r\n\r\n    function setActivityCoreAddress(address _address) external onlyCEO {\r\n        ActivityCore candidateContract = ActivityCore(_address);\r\n        require(candidateContract.isActivityCore());\r\n        activityCore = candidateContract;\r\n    }\r\n\r\n    function withdrawBalance() external onlyCLevel {\r\n        uint256 balance = address(this).balance;\r\n        // Subtract all the currently pregnant kittens we have, plus 1 of margin.\r\n        uint256 subtractFees = (cryptoStorage.pregnantMonsters() + 1) * autoBirthFee;\r\n\r\n        if (balance > subtractFees) {\r\n            cfoAddress.transfer(balance - subtractFees);\r\n        }\r\n    }\r\n\r\n    function withdrawBalancesToNFC() external onlyCLevel {\r\n        saleAuction.withdrawBalance();\r\n        siringAuction.withdrawBalance();\r\n        activityCore.withdrawBalance();\r\n        cryptoStorage.withdrawBalance();\r\n    }\r\n\r\n    function withdrawBalancesToLogic() external onlyCLevel {\r\n        saleAuction.withdrawBalanceFromStorageContract();\r\n        siringAuction.withdrawBalanceFromStorageContract();\r\n        activityCore.withdrawBalanceFromStorageContract();\r\n    }\r\n\r\n    function setAutoBirthFee(uint256 val) external onlyCOO {\r\n        autoBirthFee = val;\r\n    }\r\n\r\n    function setAllHatchConfigs(\r\n        uint32[] _durationByTimes,\r\n        uint256 _secs,\r\n        uint32[] _multiByGeneration\r\n    )\r\n        external \r\n        onlyCLevel \r\n    {\r\n        setHatchDurationByTimes(_durationByTimes);\r\n        setSecondsPerBlock(_secs);\r\n        setHatchDurationMultiByGeneration(_multiByGeneration);\r\n    }\r\n\r\n    function setSecondsPerBlock(uint256 _secs) public onlyCLevel {\r\n        require(_secs < hatchDurationByTimes[0]);\r\n        secondsPerBlock = _secs;\r\n    }\r\n\r\n    // we must do a carefully check when set hatch duration configuration, since wrong value may break the whole cooldown logic\r\n    function setHatchDurationByTimes(uint32[] _durationByTimes) public onlyCLevel {\r\n        uint256 len = _durationByTimes.length;\r\n        // hatch duration should not be empty\r\n        require(len > 0);\r\n        // check overflow\r\n        require(len == uint256(uint16(len)));\r\n        \r\n        delete hatchDurationByTimes;\r\n        \r\n        uint32 value;\r\n        for (uint256 idx = 0; idx < len; idx++) {\r\n            value = _durationByTimes[idx];\r\n            \r\n            // duration must be larger than 1 minute, and must be an integral multiple of 1 minute\r\n            require(value >= 1 minutes && value % 1 minutes == 0);\r\n            \r\n            hatchDurationByTimes.push(value);\r\n        }\r\n    }\r\n    \r\n    function getHatchDurationByTimes() external view returns (uint32[]) {\r\n        return hatchDurationByTimes;\r\n    }\r\n\r\n    // we must do a carefully check when set hatch duration multi configuration, since wrong value may break the whole cooldown logic\r\n    function setHatchDurationMultiByGeneration(uint32[] _multiByGeneration) public onlyCLevel {\r\n        uint256 len = _multiByGeneration.length;\r\n        // multi configuration should not be empty\r\n        require(len > 0);\r\n        // check overflow\r\n        require(len == uint256(uint16(len)));\r\n        \r\n        delete hatchDurationMultiByGeneration;\r\n        \r\n        uint32 value;\r\n        for (uint256 idx = 0; idx < len; idx++) {\r\n            value = _multiByGeneration[idx];\r\n            \r\n            // multiple must be larger than 60, and must be an integral multiple of secondsPerBlock\r\n            require(value >= 60 && value % secondsPerBlock == 0);\r\n            \r\n            hatchDurationMultiByGeneration.push(value);\r\n        }\r\n    }\r\n\r\n    function getHatchDurationMultiByGeneration() external view returns (uint32[]) {\r\n        return hatchDurationMultiByGeneration;\r\n    }\r\n\r\n    function createPromoMonster(\r\n        uint32 _monsterId, \r\n        bytes _properties, \r\n        address _owner\r\n    )\r\n        public \r\n        onlyCOO \r\n        whenNotPaused \r\n    {\r\n        require(_owner != address(0));\r\n\r\n        _createMonster(\r\n            0, \r\n            0, \r\n            0, \r\n            uint64(now), \r\n            _monsterId, \r\n            _properties, \r\n            _owner\r\n        );\r\n\r\n        cryptoStorage.increasePromoCreatedCount();\r\n    }\r\n\r\n    function createPromoMonsterWithTokenId(\r\n        uint32 _monsterId, \r\n        bytes _properties, \r\n        address _owner, \r\n        uint256 _tokenId\r\n    ) \r\n        external \r\n        onlyCOO \r\n        whenNotPaused \r\n    {\r\n        require(_tokenId > 0 && cryptoStorage.getMonsterCount() + 1 == _tokenId);\r\n        \r\n        createPromoMonster(_monsterId, _properties, _owner);\r\n    }\r\n\r\n    function createSystemSaleAuction(\r\n        uint32 _monsterId, \r\n        bytes _properties, \r\n        uint16 _generation\r\n    )\r\n        external \r\n        onlyCOO\r\n        whenNotPaused\r\n    {\r\n        require(cryptoStorage.systemCreatedCount() < SYSTEM_CREATION_LIMIT);\r\n\r\n        uint256 tokenId = _createMonster(\r\n            0, \r\n            0, \r\n            _generation, \r\n            uint64(now), \r\n            _monsterId, \r\n            _properties, \r\n            saleAuction.systemSaleAddress()\r\n        );\r\n\r\n        _approve(tokenId, saleAuction);\r\n\r\n        saleAuction.createSystemAuction(tokenId);\r\n\r\n        cryptoStorage.increaseSystemCreatedCount();\r\n    }\r\n\r\n    function createSaleAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_tokenId > 0);\r\n        require(_owns(msg.sender, _tokenId));\r\n        // the monster must not pregnant othewise the birth child may owned by the the sale auction or the buyer\r\n        require(!isPregnant(_tokenId));\r\n        require(saleAuction.isValidPrice(_startingPrice, _endingPrice));\r\n        _approve(_tokenId, saleAuction);\r\n        // Sale auction throws if inputs are invalid and approve status will be reverted\r\n        saleAuction.createAuction(\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function createSiringAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_tokenId > 0);\r\n        require(_owns(msg.sender, _tokenId));\r\n        require(isReadyToBreed(_tokenId));\r\n        require(siringAuction.isValidPrice(_startingPrice, _endingPrice));\r\n        _approve(_tokenId, siringAuction);\r\n        // Siring auction throws if inputs are invalid and approve status will be reverted\r\n        siringAuction.createAuction(\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    // breed with the monster siring on market\r\n    function bidOnSiringAuction(\r\n        uint256 _sireId,\r\n        uint256 _matronId\r\n    )\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        require(_matronId > 0);\r\n        require(_owns(msg.sender, _matronId));\r\n        require(isReadyToBreed(_matronId));\r\n        require(isValidMatingPair(_matronId, _sireId));\r\n\r\n        // Define the current price of the auction.\r\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\r\n        uint256 breedCost = currentPrice + autoBirthFee;\r\n        require(msg.value >= breedCost);\r\n\r\n        // Siring auction will throw if the bid fails.\r\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId, msg.sender);\r\n        _breedWith(_matronId, _sireId, breedCost);\r\n    }\r\n\r\n    // breed with the monster of one's own\r\n    function breedWithAuto(uint256 _matronId, uint256 _sireId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        // Checks for payment.\r\n        require(msg.value >= autoBirthFee);\r\n\r\n        // Caller must own the matron and sire\r\n        require(_owns(msg.sender, _matronId));\r\n        require(_owns(msg.sender, _sireId));\r\n\r\n        // any monster in auction will be owned by the auction contract address,\r\n        // so the monster must not in auction if it's owned by the msg.sender\r\n\r\n        // Make sure matron isn't pregnant, or in the middle of a siring cooldown\r\n        require(isReadyToBreed(_matronId));\r\n\r\n        // Make sure sire isn't pregnant, or in the middle of a siring cooldown\r\n        require(isReadyToBreed(_sireId));\r\n\r\n        // Test that these cats are a valid mating pair.\r\n        require(isValidMatingPair(_matronId, _sireId));\r\n\r\n        // All checks passed, monster gets pregnant!\r\n        _breedWith(_matronId, _sireId, autoBirthFee);\r\n    }\r\n\r\n    function giveBirth(uint256 _matronId, uint256 _monsterId, uint256 _birthTime, bytes _properties)\r\n        external\r\n        whenNotPaused\r\n        onlyCOO\r\n        returns (uint256)\r\n    {\r\n        // the matron is a valid monster\r\n        require(cryptoStorage.getBirthTime(_matronId) != 0);\r\n\r\n        uint256 sireId = cryptoStorage.getSiringWithId(_matronId);\r\n        // the matron is pregnant if and only if this field is set\r\n        require(sireId != 0);\r\n\r\n        // no need to check cooldown of matron or sire \r\n        // since giveBirth can only be called by COO\r\n\r\n        // determine higher generation of the parents\r\n        uint16 parentGen = cryptoStorage.getGeneration(_matronId);\r\n        uint16 sireGen = cryptoStorage.getGeneration(sireId);\r\n        if (sireGen > parentGen) parentGen = sireGen;\r\n\r\n        address owner = cryptoStorage.monsterIndexToOwner(_matronId);\r\n        uint256 tokenId = _createMonster(\r\n            _matronId, \r\n            sireId,\r\n            parentGen + 1, \r\n            _birthTime, \r\n            _monsterId, \r\n            _properties, \r\n            owner\r\n        );\r\n\r\n        // clear pregnant related info\r\n        cryptoStorage.deleteSiringWithId(_matronId);\r\n\r\n        // decrease pregnant counter.\r\n        cryptoStorage.decreasePregnantCounter();\r\n\r\n        // send the blockchain storage fee to the coo\r\n        msg.sender.transfer(autoBirthFee);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function computeCooldownSeconds(uint16 _hatchTimes, uint16 _generation) public view returns (uint32) {\r\n        require(hatchDurationByTimes.length > 0);\r\n        require(hatchDurationMultiByGeneration.length > 0);\r\n\r\n        uint16 hatchTimesMax = uint16(hatchDurationByTimes.length - 1);\r\n        uint16 hatchTimes = (_hatchTimes > hatchTimesMax ? hatchTimesMax : _hatchTimes);\r\n        \r\n        uint16 generationMax = uint16(hatchDurationMultiByGeneration.length - 1);\r\n        uint16 generation = (_generation > generationMax ? generationMax : _generation);\r\n\r\n        return hatchDurationByTimes[hatchTimes] * hatchDurationMultiByGeneration[generation] / 60;\r\n    }\r\n\r\n    function isReadyToBreed(uint256 _tokenId) public view returns (bool) {\r\n        // not pregnant and not in cooldown\r\n        return (cryptoStorage.getSiringWithId(_tokenId) == 0) && (cryptoStorage.getCooldownEndBlock(_tokenId) <= uint64(block.number));\r\n    }\r\n\r\n    function isPregnant(uint256 _tokenId) public view returns (bool) {\r\n        // A monster is pregnant if and only if this field is set\r\n        return cryptoStorage.getSiringWithId(_tokenId) != 0;\r\n    }\r\n\r\n    function isValidMatingPair(uint256 _matronId, uint256 _sireId) public view returns (bool) {\r\n        // can't breed with itself!\r\n        if (_matronId == _sireId) {\r\n            return false;\r\n        }\r\n        uint32 matron_of_matron = cryptoStorage.getMatronId(_matronId);\r\n        uint32 sire_of_matron = cryptoStorage.getSireId(_matronId);\r\n        uint32 matron_of_sire = cryptoStorage.getMatronId(_sireId);\r\n        uint32 sire_of_sire = cryptoStorage.getSireId(_sireId);\r\n        // can't breed with their parents.\r\n        if (matron_of_matron == _sireId || sire_of_matron == _sireId) return false;\r\n        if (matron_of_sire == _matronId || sire_of_sire == _matronId) return false;\r\n        // if either cat is gen zero, they can breed without siblings check\r\n        if (matron_of_sire == 0 || matron_of_matron == 0) return true;\r\n        // can't breed with full or half siblings.\r\n        if (matron_of_sire == matron_of_matron || matron_of_sire == sire_of_matron) return false;\r\n        if (sire_of_sire == matron_of_matron || sire_of_sire == sire_of_matron) return false;    \r\n        return true;\r\n    }\r\n\r\n    function _createMonster(\r\n        uint256 _matronId,\r\n        uint256 _sireId,\r\n        uint256 _generation,\r\n        uint256 _birthTime,\r\n        uint256 _monsterId,\r\n        bytes _properties,\r\n        address _owner\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 tokenId = cryptoStorage.createMonster(\r\n            _matronId,\r\n            _sireId,\r\n            _generation,\r\n            _birthTime,\r\n            _monsterId,\r\n            _properties\r\n        );\r\n\r\n        _transfer(0, _owner, tokenId);\r\n        \r\n        emit Birth(_owner, tokenId, _matronId, _sireId);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function _breedWith(uint256 _matronId, uint256 _sireId, uint256 _breedCost) internal {\r\n        // Mark the matron as pregnant, keeping track of who the sire is.\r\n        cryptoStorage.setSiringWithId(_matronId, uint32(_sireId));\r\n\r\n        // Trigger the cooldown for both parents.\r\n        uint64 sireCooldownEndBlock = _triggerCooldown(_sireId);\r\n        uint64 matronCooldownEndBlock = _triggerCooldown(_matronId);\r\n\r\n        // increase pregnant counter.\r\n        cryptoStorage.increasePregnantCounter();\r\n        \r\n        // give birth time depends on the shorter cooldown of the two parents\r\n        emit Pregnant(\r\n            cryptoStorage.monsterIndexToOwner(_matronId),\r\n            _matronId,\r\n            _sireId,\r\n            matronCooldownEndBlock,\r\n            sireCooldownEndBlock,\r\n            _breedCost\r\n        );\r\n    }\r\n\r\n    // Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).\r\n    function _triggerCooldown(uint256 _tokenId) internal returns (uint64) {\r\n        uint32 cooldownSeconds = computeCooldownSeconds(cryptoStorage.getCooldownIndex(_tokenId), cryptoStorage.getGeneration(_tokenId));\r\n        uint64 cooldownEndBlock = uint64((cooldownSeconds / secondsPerBlock) + block.number);\r\n        cryptoStorage.setCooldownEndBlock(_tokenId, cooldownEndBlock);\r\n        // increate hatch times by 1\r\n        cryptoStorage.setCooldownIndex(_tokenId);\r\n        return cooldownEndBlock;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activityCore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cryptoStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSiringAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalancesToLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isPregnant\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"siringAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_monsterId\",\"type\":\"uint32\"},{\"name\":\"_properties\",\"type\":\"bytes\"},{\"name\":\"_generation\",\"type\":\"uint16\"}],\"name\":\"createSystemSaleAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_monsterId\",\"type\":\"uint32\"},{\"name\":\"_properties\",\"type\":\"bytes\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"createPromoMonsterWithTokenId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createSaleAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matronId\",\"type\":\"uint256\"},{\"name\":\"_monsterId\",\"type\":\"uint256\"},{\"name\":\"_birthTime\",\"type\":\"uint256\"},{\"name\":\"_properties\",\"type\":\"bytes\"}],\"name\":\"giveBirth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createSiringAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setAutoBirthFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hatchTimes\",\"type\":\"uint16\"},{\"name\":\"_generation\",\"type\":\"uint16\"}],\"name\":\"computeCooldownSeconds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secs\",\"type\":\"uint256\"}],\"name\":\"setSecondsPerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSaleAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hatchDurationByTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_multiByGeneration\",\"type\":\"uint32[]\"}],\"name\":\"setHatchDurationMultiByGeneration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYSTEM_CREATION_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setActivityCoreAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalancesToNFC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_monsterId\",\"type\":\"uint32\"},{\"name\":\"_properties\",\"type\":\"bytes\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createPromoMonster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHatchDurationByTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_durationByTimes\",\"type\":\"uint32[]\"},{\"name\":\"_secs\",\"type\":\"uint256\"},{\"name\":\"_multiByGeneration\",\"type\":\"uint32[]\"}],\"name\":\"setAllHatchConfigs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoBirthFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyAndSendToStorageOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHatchDurationMultiByGeneration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_durationByTimes\",\"type\":\"uint32[]\"}],\"name\":\"setHatchDurationByTimes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_matronId\",\"type\":\"uint256\"},{\"name\":\"_sireId\",\"type\":\"uint256\"}],\"name\":\"isValidMatingPair\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isReadyToBreed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hatchDurationMultiByGeneration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sireId\",\"type\":\"uint256\"},{\"name\":\"_matronId\",\"type\":\"uint256\"}],\"name\":\"bidOnSiringAuction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matronId\",\"type\":\"uint256\"},{\"name\":\"_sireId\",\"type\":\"uint256\"}],\"name\":\"breedWithAuto\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_storageAddress\",\"type\":\"address\"},{\"name\":\"_cooAddress\",\"type\":\"address\"},{\"name\":\"_cfoAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"matronId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sireId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"matronCooldownEndBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sireCooldownEndBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"breedCost\",\"type\":\"uint256\"}],\"name\":\"Pregnant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"matronId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sireId\",\"type\":\"uint256\"}],\"name\":\"Birth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CryptoZoo","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005e2d66856a2fc7eaf843d65721e2ea20c4e8b2330000000000000000000000000761efe3e147af93b9f5c238913baf3bf241e71b000000000000000000000000d451de0f02c4e8553babda572e4582b0c5461081","Library":"","SwarmSource":"bzzr://89a05b996e772c210bdce8d50368e03ce45be6b9218e98e59a204d16cf90542b"}]}