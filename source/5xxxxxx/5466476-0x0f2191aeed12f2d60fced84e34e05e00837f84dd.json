{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Just Price Protocol Smart Contract.\r\n * Copyright Â© 2018 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.4.20;\r\n\r\n//import \"./SafeMath.sol\";\r\n//import \"./OrgonToken.sol\";\r\n//import \"./OrisSpace.sol\";\r\ncontract SafeMath {\r\n  uint256 constant private MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Add two uint256 values, throw in case of overflow.\r\n   *\r\n   * @param x first value to add\r\n   * @param y second value to add\r\n   * @return x + y\r\n   */\r\n  function safeAdd (uint256 x, uint256 y)\r\n  pure internal\r\n  returns (uint256 z) {\r\n    assert (x <= MAX_UINT256 - y);\r\n    return x + y;\r\n  }\r\n\r\n  /**\r\n   * Subtract one uint256 value from another, throw in case of underflow.\r\n   *\r\n   * @param x value to subtract from\r\n   * @param y value to subtract\r\n   * @return x - y\r\n   */\r\n  function safeSub (uint256 x, uint256 y)\r\n  pure internal\r\n  returns (uint256 z) {\r\n    assert (x >= y);\r\n    return x - y;\r\n  }\r\n\r\n  /**\r\n   * Multiply two uint256 values, throw in case of overflow.\r\n   *\r\n   * @param x first value to multiply\r\n   * @param y second value to multiply\r\n   * @return x * y\r\n   */\r\n  function safeMul (uint256 x, uint256 y)\r\n  pure internal\r\n  returns (uint256 z) {\r\n    if (y == 0) return 0; // Prevent division by zero at the next line\r\n    assert (x <= MAX_UINT256 / y);\r\n    return x * y;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /**\r\n   * Get total number of tokens in circulation.\r\n   *\r\n   * @return total number of tokens in circulation\r\n   */\r\n  function totalSupply () public view returns (uint256 supply);\r\n\r\n  /**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n   *        owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   */\r\n  function balanceOf (address _owner) public view returns (uint256 balance);\r\n\r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transfer (address _to, uint256 _value)\r\n  public returns (bool success);\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transferFrom (address _from, address _to, uint256 _value)\r\n  public returns (bool success);\r\n\r\n  /**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   *\r\n   * @param _spender address to allow the owner of to transfer tokens from\r\n   *        message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   */\r\n  function approve (address _spender, uint256 _value)\r\n  public returns (bool success);\r\n\r\n  /**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   */\r\n  function allowance (address _owner, address _spender)\r\n  public view returns (uint256 remaining);\r\n\r\n  /**\r\n   * Logged when tokens were transferred from one owner to another.\r\n   *\r\n   * @param _from address of the owner, tokens were transferred from\r\n   * @param _to address of the owner, tokens were transferred to\r\n   * @param _value number of tokens transferred\r\n   */\r\n  event Transfer (address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * Logged when owner approved his tokens to be transferred by some spender.\r\n   *\r\n   * @param _owner owner who approved his tokens to be transferred\r\n   * @param _spender spender who were allowed to transfer the tokens belonging\r\n   *        to the owner\r\n   * @param _value number of tokens belonging to the owner, approved to be\r\n   *        transferred by the spender\r\n   */\r\n  event Approval (\r\n    address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract OrisSpace {\r\n  /**\r\n   * Start Oris Space smart contract.\r\n   *\r\n   * @param _returnAmount amount of tokens to return to message sender.\r\n   */\r\n  function start (uint256 _returnAmount) public;\r\n}\r\n\r\ncontract OrgonToken is Token {\r\n  /**\r\n   * Create _value new tokens and give new created tokens to msg.sender.\r\n   * May only be called by smart contract owner.\r\n   *\r\n   * @param _value number of tokens to create\r\n   * @return true if tokens were created successfully, false otherwise\r\n   */\r\n  function createTokens (uint256 _value) public returns (bool);\r\n\r\n  /**\r\n   * Burn given number of tokens belonging to message sender.\r\n   * May only be called by smart contract owner.\r\n   *\r\n   * @param _value number of tokens to burn\r\n   * @return true on success, false on error\r\n   */\r\n  function burnTokens (uint256 _value) public returns (bool);\r\n}\r\n\r\n/**\r\n * Just Price Protocol Smart Contract that serves as market maker for Orgon\r\n * tokens.\r\n */\r\ncontract JustPriceProtocol is SafeMath {\r\n  /**\r\n   * 2^128.\r\n   */\r\n  uint256 internal constant TWO_128 = 0x100000000000000000000000000000000;\r\n\r\n  /**\r\n   * Sale start time (2018-04-19 06:00:00 UTC)\r\n   */\r\n  uint256 internal constant SALE_START_TIME = 1524117600;\r\n\r\n  /**\r\n   * \"Reserve\" stage deadline (2018-07-08 00:00:00 UTC)\r\n   */\r\n  uint256 internal constant RESERVE_DEADLINE = 1531008000;\r\n\r\n  /**\r\n   * Maximum amount to be collected during \"reserve\" stage.\r\n   */\r\n  uint256 internal constant RESERVE_MAX_AMOUNT = 72500 ether;\r\n\r\n  /**\r\n   * Minimum amount to be collected during \"reserve\" stage.\r\n   */\r\n  uint256 internal constant RESERVE_MIN_AMOUNT = 30000 ether;\r\n\r\n  /**\r\n   * Maximum number of tokens to be sold during \"reserve\" stage.\r\n   */\r\n  uint256 internal constant RESERVE_MAX_TOKENS = 82881476.72e9;\r\n\r\n  /**\r\n   * ORNG/ETH ratio after \"reserve\" stage in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_RATIO = 72500 ether / 725000000e9;\r\n\r\n  /**\r\n   * Maximum amount of ETH to collect at price 1.\r\n   */\r\n  uint256 internal constant RESERVE_THRESHOLD_1 = 10000 ether;\r\n\r\n  /**\r\n   * Price 1 in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_PRICE_1 = 0.00080 ether / 1e9;\r\n\r\n  /**\r\n   * Maximum amount of ETH to collect at price 2.\r\n   */\r\n  uint256 internal constant RESERVE_THRESHOLD_2 = 20000 ether;\r\n\r\n  /**\r\n   * Price 2 in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_PRICE_2 = 0.00082 ether / 1e9;\r\n\r\n  /**\r\n   * Maximum amount of ETH to collect at price 3.\r\n   */\r\n  uint256 internal constant RESERVE_THRESHOLD_3 = 30000 ether;\r\n\r\n  /**\r\n   * Price 3 in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_PRICE_3 = 0.00085 ether / 1e9;\r\n\r\n  /**\r\n   * Maximum amount of ETH to collect at price 4.\r\n   */\r\n  uint256 internal constant RESERVE_THRESHOLD_4 = 40000 ether;\r\n\r\n  /**\r\n   * Price 4 in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_PRICE_4 = 0.00088 ether / 1e9;\r\n\r\n  /**\r\n   * Maximum amount of ETH to collect at price 5.\r\n   */\r\n  uint256 internal constant RESERVE_THRESHOLD_5 = 50000 ether;\r\n\r\n  /**\r\n   * Price 5 in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_PRICE_5 = 0.00090 ether / 1e9;\r\n\r\n  /**\r\n   * Maximum amount of ETH to collect at price 6.\r\n   */\r\n  uint256 internal constant RESERVE_THRESHOLD_6 = 60000 ether;\r\n\r\n  /**\r\n   * Price 6 in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_PRICE_6 = 0.00092 ether / 1e9;\r\n\r\n  /**\r\n   * Maximum amount of ETH to collect at price 7.\r\n   */\r\n  uint256 internal constant RESERVE_THRESHOLD_7 = 70000 ether;\r\n\r\n  /**\r\n   * Price 7 in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_PRICE_7 = 0.00095 ether / 1e9;\r\n\r\n  /**\r\n   * Maximum amount of ETH to collect at price 8.\r\n   */\r\n  uint256 internal constant RESERVE_THRESHOLD_8 = 72500 ether;\r\n\r\n  /**\r\n   * Price 8 in Wei per ORGN unit.\r\n   */\r\n  uint256 internal constant RESERVE_PRICE_8 = 0.00098 ether / 1e9;\r\n\r\n  /**\r\n   * \"Growth\" stage ends once this many tokens were issued.\r\n   */\r\n  uint256 internal constant GROWTH_MAX_TOKENS = 1000000000e9;\r\n\r\n  /**\r\n   * Maximum duration of \"growth\" stage.\r\n   */\r\n  uint256 internal constant GROWTH_MAX_DURATION = 285 days;\r\n\r\n  /**\r\n   * Numerator of fraction of tokens bought at \"reserve\" stage to be delivered\r\n   * before \"growth\" stage start.\r\n   */\r\n  uint256 internal constant GROWTH_MIN_DELIVERED_NUMERATOR = 75;\r\n\r\n  /**\r\n   * Denominator of fraction of tokens bought at \"reserve\" stage to be delivered\r\n   * before \"growth\" stage start.\r\n   */\r\n  uint256 internal constant GROWTH_MIN_DELIVERED_DENOMINATIOR = 100;\r\n\r\n  /**\r\n   * Numerator of fraction of total votes to be given to a new K1 address for\r\n   * vote to succeed.\r\n   */\r\n  uint256 internal constant REQUIRED_VOTES_NUMERATIOR = 51;\r\n\r\n  /**\r\n   * Denominator of fraction of total votes to be given to a new K1 address for\r\n   * vote to succeed.\r\n   */\r\n  uint256 internal constant REQUIRED_VOTES_DENOMINATOR = 100;\r\n\r\n  /**\r\n   * Fee denominator (1 / 20000 = 0.00005).\r\n   */\r\n  uint256 internal constant FEE_DENOMINATOR = 20000;\r\n\r\n  /**\r\n   * Delay after start of \"growth\" stage before fee may be changed.\r\n   */\r\n  uint256 internal constant FEE_CHANGE_DELAY = 650 days;\r\n\r\n  /**\r\n   * Minimum fee (1 / 20000 = 0.0005).\r\n   */\r\n  uint256 internal constant MIN_FEE = 1;\r\n\r\n  /**\r\n   * Maximum fee (2000 / 20000 = 0.1).\r\n   */\r\n  uint256 internal constant MAX_FEE = 2000;\r\n\r\n  /**\r\n   * Deploy Just Price Protocol smart contract with given Orgon Token,\r\n   * Oris Space, and K1 wallet.\r\n   *\r\n   * @param _orgonToken Orgon Token to use\r\n   * @param _orisSpace Oris Space to use\r\n   * @param _k1 address of K1 wallet\r\n   */\r\n  function JustPriceProtocol (\r\n    OrgonToken _orgonToken, OrisSpace _orisSpace, address _k1)\r\n  public {\r\n    orgonToken = _orgonToken;\r\n    orisSpace = _orisSpace;\r\n    k1 = _k1;\r\n  }\r\n\r\n  /**\r\n   * When called with no data does the same as buyTokens ().\r\n   */\r\n  function () public payable {\r\n    require (msg.data.length == 0);\r\n\r\n    buyTokens ();\r\n  }\r\n\r\n  /**\r\n   * Buy tokens.\r\n   */\r\n  function buyTokens () public payable {\r\n    require (msg.value > 0);\r\n\r\n    updateStage ();\r\n\r\n    if (stage == Stage.RESERVE)\r\n      buyTokensReserve ();\r\n    else if (stage == Stage.GROWTH || stage == Stage.LIFE)\r\n      buyTokensGrowthLife ();\r\n    else revert (); // No buying in current stage\r\n  }\r\n\r\n  /**\r\n   * Sell tokens.\r\n   *\r\n   * @param _value number of tokens to sell\r\n   */\r\n  function sellTokens (uint256 _value) public {\r\n    require (_value > 0);\r\n    require (_value < TWO_128);\r\n\r\n    updateStage ();\r\n    require (stage == Stage.LIFE);\r\n\r\n    assert (reserveAmount < TWO_128);\r\n    uint256 totalSupply = orgonToken.totalSupply ();\r\n    require (totalSupply < TWO_128);\r\n\r\n    require (_value <= totalSupply);\r\n\r\n    uint256 toPay = safeMul (\r\n      reserveAmount,\r\n      safeSub (\r\n        TWO_128,\r\n        pow_10 (safeSub (TWO_128, (_value << 128) / totalSupply)))) >> 128;\r\n\r\n    require (orgonToken.transferFrom (msg.sender, this, _value));\r\n    require (orgonToken.burnTokens (_value));\r\n\r\n    reserveAmount = safeSub (reserveAmount, toPay);\r\n\r\n    msg.sender.transfer (toPay);\r\n  }\r\n\r\n  /**\r\n   * Deliver tokens sold during \"reserve\" stage to corresponding investors.\r\n   *\r\n   * @param _investors addresses of investors to deliver tokens to\r\n   */\r\n  function deliver (address [] _investors) public {\r\n    updateStage ();\r\n    require (\r\n      stage == Stage.BEFORE_GROWTH ||\r\n      stage == Stage.GROWTH ||\r\n      stage == Stage.LIFE);\r\n\r\n    for (uint256 i = 0; i < _investors.length; i++) {\r\n      address investorAddress = _investors [i];\r\n      Investor storage investor = investors [investorAddress];\r\n\r\n      uint256 toDeliver = investor.tokensBought;\r\n      investor.tokensBought = 0;\r\n      investor.etherInvested = 0;\r\n\r\n      if (toDeliver > 0) {\r\n        require (orgonToken.transfer (investorAddress, toDeliver));\r\n        reserveTokensDelivered = safeAdd (reserveTokensDelivered, toDeliver);\r\n\r\n        Delivery (investorAddress, toDeliver);\r\n      }\r\n    }\r\n\r\n    if (stage == Stage.BEFORE_GROWTH &&\r\n      safeMul (reserveTokensDelivered, GROWTH_MIN_DELIVERED_DENOMINATIOR) >=\r\n        safeMul (reserveTokensSold, GROWTH_MIN_DELIVERED_NUMERATOR)) {\r\n      stage = Stage.GROWTH;\r\n      growthDeadline = currentTime () + GROWTH_MAX_DURATION;\r\n      feeChangeEnableTime = currentTime () + FEE_CHANGE_DELAY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Refund investors who bought tokens during \"reserve\" stage.\r\n   *\r\n   * @param _investors addresses of investors to refund\r\n   */\r\n  function refund (address [] _investors) public {\r\n    updateStage ();\r\n    require (stage == Stage.REFUND);\r\n\r\n    for (uint256 i = 0; i < _investors.length; i++) {\r\n      address investorAddress = _investors [i];\r\n      Investor storage investor = investors [investorAddress];\r\n\r\n      uint256 toBurn = investor.tokensBought;\r\n      uint256 toRefund = investor.etherInvested;\r\n\r\n      investor.tokensBought = 0;\r\n      investor.etherInvested = 0;\r\n\r\n      if (toBurn > 0)\r\n        require (orgonToken.burnTokens (toBurn));\r\n\r\n      if (toRefund > 0) {\r\n        investorAddress.transfer (toRefund);\r\n\r\n        Refund (investorAddress, toRefund);\r\n      }\r\n    }\r\n  }\r\n\r\n  function vote (address _newK1) public {\r\n    updateStage ();\r\n\r\n    require (stage == Stage.LIFE);\r\n    require (!k1Changed);\r\n\r\n    uint256 votesCount = voteNumbers [msg.sender];\r\n    if (votesCount > 0) {\r\n      address oldK1 = votes [msg.sender];\r\n      if (_newK1 != oldK1) {\r\n        if (oldK1 != address (0)) {\r\n          voteResults [oldK1] = safeSub (voteResults [oldK1], votesCount);\r\n\r\n          VoteRevocation (msg.sender, oldK1, votesCount);\r\n        }\r\n\r\n        votes [msg.sender] = _newK1;\r\n\r\n        if (_newK1 != address (0)) {\r\n          voteResults [_newK1] = safeAdd (voteResults [_newK1], votesCount);\r\n          Vote (msg.sender, _newK1, votesCount);\r\n\r\n          if (safeMul (voteResults [_newK1], REQUIRED_VOTES_DENOMINATOR) >=\r\n            safeMul (totalVotesNumber, REQUIRED_VOTES_NUMERATIOR)) {\r\n            k1 = _newK1;\r\n            k1Changed = true;\r\n\r\n            K1Change (_newK1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set new fee numerator.\r\n   *\r\n   * @param _fee new fee numerator.\r\n   */\r\n  function setFee (uint256 _fee) public {\r\n    require (msg.sender == k1);\r\n\r\n    require (_fee >= MIN_FEE);\r\n    require (_fee <= MAX_FEE);\r\n\r\n    updateStage ();\r\n\r\n    require (stage == Stage.GROWTH || stage == Stage.LIFE);\r\n    require (currentTime () >= feeChangeEnableTime);\r\n\r\n    require (safeSub (_fee, 1) <= fee);\r\n    require (safeAdd (_fee, 1) >= fee);\r\n\r\n    if (fee != _fee) {\r\n      fee = _fee;\r\n\r\n      FeeChange (_fee);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get number of tokens bought by given investor during reserve stage that are\r\n   * not yet delivered to him.\r\n   *\r\n   * @param _investor address of investor to get number of outstanding tokens\r\n   *       for\r\n   * @return number of non-delivered tokens given investor bought during reserve\r\n   *         stage\r\n   */\r\n  function outstandingTokens (address _investor) public view returns (uint256) {\r\n    return investors [_investor].tokensBought;\r\n  }\r\n\r\n  /**\r\n   * Get current stage of Just Price Protocol.\r\n   *\r\n   * @param _currentTime current time in seconds since epoch\r\n   * @return current stage of Just Price Protocol\r\n   */\r\n  function getStage (uint256 _currentTime) public view returns (Stage) {\r\n    Stage currentStage = stage;\r\n\r\n    if (currentStage == Stage.BEFORE_RESERVE) {\r\n      if (_currentTime >= SALE_START_TIME)\r\n        currentStage = Stage.RESERVE;\r\n      else return currentStage;\r\n    }\r\n\r\n    if (currentStage == Stage.RESERVE) {\r\n      if (_currentTime >= RESERVE_DEADLINE) {\r\n        if (reserveAmount >= RESERVE_MIN_AMOUNT)\r\n          currentStage = Stage.BEFORE_GROWTH;\r\n        else currentStage = Stage.REFUND;\r\n      }\r\n\r\n      return currentStage;\r\n    }\r\n\r\n    if (currentStage == Stage.GROWTH) {\r\n      if (_currentTime >= growthDeadline) {\r\n        currentStage = Stage.LIFE;\r\n      }\r\n    }\r\n\r\n    return currentStage;\r\n  }\r\n\r\n  /**\r\n   * Return total number of votes eligible for choosing new K1 address.\r\n   *\r\n   * @return total number of votes eligible for choosing new K1 address\r\n   */\r\n  function totalEligibleVotes () public view returns (uint256) {\r\n    return totalVotesNumber;\r\n  }\r\n\r\n  /**\r\n   * Return number of votes eligible for choosing new K1 address given investor\r\n   * has.\r\n   *\r\n   * @param _investor address of investor to get number of eligible votes of\r\n   * @return Number of eligible votes given investor has\r\n   */\r\n  function eligibleVotes (address _investor) public view returns (uint256) {\r\n    return voteNumbers [_investor];\r\n  }\r\n\r\n  /**\r\n   * Get number of votes for the given new K1 address.\r\n   *\r\n   * @param _newK1 new K1 address to get number of votes for\r\n   * @return number of votes for the given new K1 address\r\n   */\r\n  function votesFor (address _newK1) public view returns (uint256) {\r\n    return voteResults [_newK1];\r\n  }\r\n\r\n  /**\r\n   * Buy tokens during \"reserve\" stage.\r\n   */\r\n  function buyTokensReserve () internal {\r\n    require (stage == Stage.RESERVE);\r\n\r\n    uint256 toBuy = 0;\r\n    uint256 toRefund = msg.value;\r\n    uint256 etherInvested = 0;\r\n    uint256 tokens;\r\n    uint256 tokensValue;\r\n\r\n    if (reserveAmount < RESERVE_THRESHOLD_1) {\r\n      tokens = min (\r\n        toRefund,\r\n        safeSub (RESERVE_THRESHOLD_1, reserveAmount)) /\r\n        RESERVE_PRICE_1;\r\n\r\n      if (tokens > 0) {\r\n        tokensValue = safeMul (tokens, RESERVE_PRICE_1);\r\n\r\n        toBuy = safeAdd (toBuy, tokens);\r\n        toRefund = safeSub (toRefund, tokensValue);\r\n        etherInvested = safeAdd (etherInvested, tokensValue);\r\n        reserveAmount = safeAdd (reserveAmount, tokensValue);\r\n      }\r\n    }\r\n\r\n    if (reserveAmount < RESERVE_THRESHOLD_2) {\r\n      tokens = min (\r\n        toRefund,\r\n        safeSub (RESERVE_THRESHOLD_2, reserveAmount)) /\r\n        RESERVE_PRICE_2;\r\n\r\n      if (tokens > 0) {\r\n        tokensValue = safeMul (tokens, RESERVE_PRICE_2);\r\n\r\n        toBuy = safeAdd (toBuy, tokens);\r\n        toRefund = safeSub (toRefund, tokensValue);\r\n        etherInvested = safeAdd (etherInvested, tokensValue);\r\n        reserveAmount = safeAdd (reserveAmount, tokensValue);\r\n      }\r\n    }\r\n\r\n    if (reserveAmount < RESERVE_THRESHOLD_3) {\r\n      tokens = min (\r\n        toRefund,\r\n        safeSub (RESERVE_THRESHOLD_3, reserveAmount)) /\r\n        RESERVE_PRICE_3;\r\n\r\n      if (tokens > 0) {\r\n        tokensValue = safeMul (tokens, RESERVE_PRICE_3);\r\n\r\n        toBuy = safeAdd (toBuy, tokens);\r\n        toRefund = safeSub (toRefund, tokensValue);\r\n        etherInvested = safeAdd (etherInvested, tokensValue);\r\n        reserveAmount = safeAdd (reserveAmount, tokensValue);\r\n      }\r\n    }\r\n\r\n    if (reserveAmount < RESERVE_THRESHOLD_4) {\r\n      tokens = min (\r\n        toRefund,\r\n        safeSub (RESERVE_THRESHOLD_4, reserveAmount)) /\r\n        RESERVE_PRICE_4;\r\n\r\n      if (tokens > 0) {\r\n        tokensValue = safeMul (tokens, RESERVE_PRICE_4);\r\n\r\n        toBuy = safeAdd (toBuy, tokens);\r\n        toRefund = safeSub (toRefund, tokensValue);\r\n        etherInvested = safeAdd (etherInvested, tokensValue);\r\n        reserveAmount = safeAdd (reserveAmount, tokensValue);\r\n      }\r\n    }\r\n\r\n    if (reserveAmount < RESERVE_THRESHOLD_5) {\r\n      tokens = min (\r\n        toRefund,\r\n        safeSub (RESERVE_THRESHOLD_5, reserveAmount)) /\r\n        RESERVE_PRICE_5;\r\n\r\n      if (tokens > 0) {\r\n        tokensValue = safeMul (tokens, RESERVE_PRICE_5);\r\n\r\n        toBuy = safeAdd (toBuy, tokens);\r\n        toRefund = safeSub (toRefund, tokensValue);\r\n        etherInvested = safeAdd (etherInvested, tokensValue);\r\n        reserveAmount = safeAdd (reserveAmount, tokensValue);\r\n      }\r\n    }\r\n\r\n    if (reserveAmount < RESERVE_THRESHOLD_6) {\r\n      tokens = min (\r\n        toRefund,\r\n        safeSub (RESERVE_THRESHOLD_6, reserveAmount)) /\r\n        RESERVE_PRICE_6;\r\n\r\n      if (tokens > 0) {\r\n        tokensValue = safeMul (tokens, RESERVE_PRICE_6);\r\n\r\n        toBuy = safeAdd (toBuy, tokens);\r\n        toRefund = safeSub (toRefund, tokensValue);\r\n        etherInvested = safeAdd (etherInvested, tokensValue);\r\n        reserveAmount = safeAdd (reserveAmount, tokensValue);\r\n      }\r\n    }\r\n\r\n    if (reserveAmount < RESERVE_THRESHOLD_7) {\r\n      tokens = min (\r\n        toRefund,\r\n        safeSub (RESERVE_THRESHOLD_7, reserveAmount)) /\r\n        RESERVE_PRICE_7;\r\n\r\n      if (tokens > 0) {\r\n        tokensValue = safeMul (tokens, RESERVE_PRICE_7);\r\n\r\n        toBuy = safeAdd (toBuy, tokens);\r\n        toRefund = safeSub (toRefund, tokensValue);\r\n        etherInvested = safeAdd (etherInvested, tokensValue);\r\n        reserveAmount = safeAdd (reserveAmount, tokensValue);\r\n      }\r\n    }\r\n\r\n    if (reserveAmount < RESERVE_THRESHOLD_8) {\r\n      tokens = min (\r\n        toRefund,\r\n        safeSub (RESERVE_THRESHOLD_8, reserveAmount)) /\r\n        RESERVE_PRICE_8;\r\n\r\n      if (tokens > 0) {\r\n        tokensValue = safeMul (tokens, RESERVE_PRICE_8);\r\n\r\n        toBuy = safeAdd (toBuy, tokens);\r\n        toRefund = safeSub (toRefund, tokensValue);\r\n        etherInvested = safeAdd (etherInvested, tokensValue);\r\n        reserveAmount = safeAdd (reserveAmount, tokensValue);\r\n      }\r\n    }\r\n\r\n    if (toBuy > 0) {\r\n      Investor storage investor = investors [msg.sender];\r\n\r\n      investor.tokensBought = safeAdd (\r\n        investor.tokensBought, toBuy);\r\n\r\n      investor.etherInvested = safeAdd (\r\n        investor.etherInvested, etherInvested);\r\n\r\n      reserveTokensSold = safeAdd (reserveTokensSold, toBuy);\r\n\r\n      require (orgonToken.createTokens (toBuy));\r\n\r\n      voteNumbers [msg.sender] = safeAdd (voteNumbers [msg.sender], toBuy);\r\n      totalVotesNumber = safeAdd (totalVotesNumber, toBuy);\r\n\r\n      Investment (msg.sender, etherInvested, toBuy);\r\n\r\n      if (safeSub (RESERVE_THRESHOLD_8, reserveAmount) <\r\n        RESERVE_PRICE_8) {\r\n\r\n        orisSpace.start (0);\r\n\r\n        stage = Stage.BEFORE_GROWTH;\r\n      }\r\n    }\r\n\r\n    if (toRefund > 0)\r\n      msg.sender.transfer (toRefund);\r\n  }\r\n\r\n  /**\r\n   * Buy tokens during \"growth\" or \"life\" stage.\r\n   */\r\n  function buyTokensGrowthLife () internal {\r\n    require (stage == Stage.GROWTH || stage == Stage.LIFE);\r\n\r\n    require (msg.value < TWO_128);\r\n\r\n    uint256 totalSupply = orgonToken.totalSupply ();\r\n    assert (totalSupply < TWO_128);\r\n\r\n    uint256 toBuy = safeMul (\r\n      totalSupply,\r\n      safeSub (\r\n        root_10 (safeAdd (TWO_128, (msg.value << 128) / reserveAmount)),\r\n        TWO_128)) >> 128;\r\n\r\n    reserveAmount = safeAdd (reserveAmount, msg.value);\r\n    require (reserveAmount < TWO_128);\r\n\r\n    if (toBuy > 0) {\r\n      require (orgonToken.createTokens (toBuy));\r\n      require (orgonToken.totalSupply () < TWO_128);\r\n\r\n      uint256 feeAmount = safeMul (toBuy, fee) / FEE_DENOMINATOR;\r\n\r\n      require (orgonToken.transfer (msg.sender, safeSub (toBuy, feeAmount)));\r\n\r\n      if (feeAmount > 0)\r\n        require (orgonToken.transfer (k1, feeAmount));\r\n\r\n      if (stage == Stage.GROWTH) {\r\n        uint256 votesCount = toBuy;\r\n\r\n        totalSupply = orgonToken.totalSupply ();\r\n        if (totalSupply >= GROWTH_MAX_TOKENS) {\r\n          stage = Stage.LIFE;\r\n          votesCount = safeSub (\r\n            votesCount,\r\n            safeSub (totalSupply, GROWTH_MAX_TOKENS));\r\n        }\r\n\r\n        voteNumbers [msg.sender] =\r\n          safeAdd (voteNumbers [msg.sender], votesCount);\r\n        totalVotesNumber = safeAdd (totalVotesNumber, votesCount);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update stage of Just Price Protocol and return updated stage.\r\n   *\r\n   * @return updated stage of Just Price Protocol\r\n   */\r\n  function updateStage () internal returns (Stage) {\r\n    Stage currentStage = getStage (currentTime ());\r\n    if (stage != currentStage) {\r\n      if (currentStage == Stage.BEFORE_GROWTH) {\r\n        // \"Reserve\" stage deadline reached and minimum amount collected\r\n        uint256 tokensToBurn =\r\n          safeSub (\r\n            safeAdd (\r\n              safeAdd (\r\n                safeSub (RESERVE_MAX_AMOUNT, reserveAmount),\r\n                safeSub (RESERVE_RATIO, 1)) /\r\n                RESERVE_RATIO,\r\n              reserveTokensSold),\r\n            RESERVE_MAX_TOKENS);\r\n\r\n        orisSpace.start (tokensToBurn);\r\n        if (tokensToBurn > 0)\r\n          require (orgonToken.burnTokens (tokensToBurn));\r\n      }\r\n\r\n      stage = currentStage;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get minimum of two values.\r\n   *\r\n   * @param x first value\r\n   * @param y second value\r\n   * @return minimum of two values\r\n   */\r\n  function min (uint256 x, uint256 y) internal pure returns (uint256) {\r\n    return x < y ? x : y;\r\n  }\r\n\r\n  /**\r\n   * Calculate 2^128 * (x / 2^128)^(1/10).\r\n   *\r\n   * @param x parameter x\r\n   * @return 2^128 * (x / 2^128)^(1/10)\r\n   */\r\n  function root_10 (uint256 x) internal pure returns (uint256 y) {\r\n    uint256 shift = 0;\r\n\r\n    while (x > TWO_128) {\r\n      x >>= 10;\r\n      shift += 1;\r\n    }\r\n\r\n    if (x == TWO_128 || x == 0) y = x;\r\n    else {\r\n      uint256 x128 = x << 128;\r\n      y = TWO_128;\r\n\r\n      uint256 t = x;\r\n      while (true) {\r\n        t <<= 10;\r\n        if (t < TWO_128) y >>= 1;\r\n        else break;\r\n      }\r\n\r\n      for (uint256 i = 0; i < 16; i++) {\r\n        uint256 y9;\r\n\r\n        if (y == TWO_128) y9 = y;\r\n        else {\r\n          uint256 y2 = (y * y) >> 128;\r\n          uint256 y4 = (y2 * y2) >> 128;\r\n          uint256 y8 = (y4 * y4) >> 128;\r\n          y9 = (y * y8) >> 128;\r\n        }\r\n\r\n        y = (9 * y + x128 / y9) / 10;\r\n\r\n        assert (y <= TWO_128);\r\n      }\r\n    }\r\n\r\n    y <<= shift;\r\n  }\r\n\r\n  /**\r\n   * Calculate 2^128 * (x / 2^128)^10.\r\n   *\r\n   * @param x parameter x\r\n   * @return 2^128 * (x / 2^128)^10\r\n   */\r\n  function pow_10 (uint256 x) internal pure returns (uint256) {\r\n    require (x <= TWO_128);\r\n\r\n    if (x == TWO_128) return x;\r\n    else {\r\n      uint256 x2 = (x * x) >> 128;\r\n      uint256 x4 = (x2 * x2) >> 128;\r\n      uint256 x8 = (x4 * x4) >> 128;\r\n      return (x2 * x8) >> 128;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current time in seconds since epoch.\r\n   *\r\n   * @return current time in seconds since epoch\r\n   */\r\n  function currentTime () internal view returns (uint256) {\r\n    return block.timestamp;\r\n  }\r\n\r\n  /**\r\n   * Just Price Protocol stages.\r\n   * +----------------+\r\n   * | BEFORE_RESERVE |\r\n   * +----------------+\r\n   *         |\r\n   *         | Sale start time reached\r\n   *         V\r\n   *    +---------+   Reserve deadline reached\r\n   *    | RESERVE |-------------------------------+\r\n   *    +---------+                               |\r\n   *         |                                    |\r\n   *         | 72500 ETH collected                |\r\n   *         V                                    |\r\n   * +---------------+ 39013,174672 ETH collected |\r\n   * | BEFORE_GROWTH |<---------------------------O\r\n   * +---------------+                            |\r\n   *         |                                    | 39013,174672 ETH not collected\r\n   *         | 80% of tokens delivered            |\r\n   *         V                                    V\r\n   *  +------------+                         +--------+\r\n   *  |   GROWTH   |                         | REFUND |\r\n   *  +------------+                         +--------+\r\n   *         |\r\n   *         | 1,500,000,000 tokens issued or 365 days passed since start of \"GROWTH\" stage\r\n   *         V\r\n   *     +------+\r\n   *     | LIFE |\r\n   *     +------+\r\n   */\r\n  enum Stage {\r\n    BEFORE_RESERVE, // Before start of \"Reserve\" stage\r\n    RESERVE, // \"Reserve\" stage\r\n    BEFORE_GROWTH, // Between \"Reserve\" and \"Growth\" stages\r\n    GROWTH, // \"Grows\" stage\r\n    LIFE, // \"Life\" stage\r\n    REFUND // \"Refund\" stage\r\n  }\r\n\r\n  /**\r\n   * Orgon Token smart contract.\r\n   */\r\n  OrgonToken internal orgonToken;\r\n\r\n  /**\r\n   * Oris Space spart contract.\r\n   */\r\n  OrisSpace internal orisSpace;\r\n\r\n  /**\r\n   * Address of K1 smart contract.\r\n   */\r\n  address internal k1;\r\n\r\n  /**\r\n   * Last known stage of Just Price Protocol\r\n   */\r\n  Stage internal stage = Stage.BEFORE_RESERVE;\r\n\r\n  /**\r\n   * Amount of ether in reserve.\r\n   */\r\n  uint256 internal reserveAmount;\r\n\r\n  /**\r\n   * Number of tokens sold during \"reserve\" stage.\r\n   */\r\n  uint256 internal reserveTokensSold;\r\n\r\n  /**\r\n   * Number of tokens sold during \"reserve\" stage that were already delivered to\r\n   * investors.\r\n   */\r\n  uint256 internal reserveTokensDelivered;\r\n\r\n  /**\r\n   * \"Growth\" stage deadline.\r\n   */\r\n  uint256 internal growthDeadline;\r\n\r\n  /**\r\n   * Mapping from address of a person who bought some tokens during \"reserve\"\r\n   * stage to information about how many tokens he bought to how much ether\r\n   * invested.\r\n   */\r\n  mapping (address => Investor) internal investors;\r\n\r\n  /**\r\n   * Mapping from address of an investor to the number of votes this investor\r\n   * has.\r\n   */\r\n  mapping (address => uint256) internal voteNumbers;\r\n\r\n  /**\r\n   * Mapping from address of an investor to the new K1 address this investor\r\n   * voted for.\r\n   */\r\n  mapping (address => address) internal votes;\r\n\r\n  /**\r\n   * Mapping from suggested new K1 address to the number of votes for this\r\n   * address.\r\n   */\r\n  mapping (address => uint256) internal voteResults;\r\n\r\n  /**\r\n   * Total number of eligible votes.\r\n   */\r\n  uint256 internal totalVotesNumber;\r\n\r\n  /**\r\n   * Whether K1 address was already changed via voting.\r\n   */\r\n  bool internal k1Changed = false;\r\n\r\n  /**\r\n   * Fee enumerator.  (2 / 20000 = 0.0001);\r\n   */\r\n  uint256 internal fee = 2;\r\n\r\n  /**\r\n   * Time when fee changing is enabled.\r\n   */\r\n  uint256 internal feeChangeEnableTime;\r\n\r\n  /**\r\n   * Encapsulates information about a person who bought some tokens during\r\n   * \"reserve\" stage.\r\n   */\r\n  struct Investor {\r\n    /**\r\n     * Number of tokens bought during reserve stage.\r\n     */\r\n    uint256 tokensBought;\r\n\r\n    /**\r\n     * Ether invested during reserve stage.\r\n     */\r\n    uint256 etherInvested;\r\n  }\r\n\r\n  /**\r\n   * Logged when investor invested some ether during \"reserve\" stage.\r\n   *\r\n   * @param investor address of investor\r\n   * @param value amount of ether invested\r\n   * @param amount number of tokens issued for investor\r\n   */\r\n  event Investment (address indexed investor, uint256 value, uint256 amount);\r\n\r\n  /**\r\n   * Logged when tokens bought at \"reserve\" stage were delivered to investor.\r\n   *\r\n   * @param investor address of investor whom tokens were delivered to\r\n   * @param amount number of tokens delivered\r\n   */\r\n  event Delivery (address indexed investor, uint256 amount);\r\n\r\n  /**\r\n   * Logged when investment was refunded.\r\n   *\r\n   * @param investor address of investor whose investment was refunded\r\n   * @param value amount of ether refunded\r\n   */\r\n  event Refund (address indexed investor, uint256 value);\r\n\r\n  /**\r\n   * Logged when K1 address was changed.\r\n   *\r\n   * @param k1 new K1 address\r\n   */\r\n  event K1Change (address k1);\r\n\r\n  /**\r\n   * Logged when investor voted for new K1 address.\r\n   * \r\n   * @param investor investor who voted for new K1 address\r\n   * @param newK1 new K1 address investor voted for\r\n   * @param votes number of votes investor has\r\n   */\r\n  event Vote (address indexed investor, address indexed newK1, uint256 votes);\r\n\r\n  /**\r\n   * Logged when investor revoked vote for new K1 address.\r\n   * \r\n   * @param investor investor who revoked vote for new K1 address\r\n   * @param newK1 new K1 address investor revoked vote for\r\n   * @param votes number of votes investor has\r\n   */\r\n  event VoteRevocation (\r\n    address indexed investor, address indexed newK1, uint256 votes);\r\n\r\n  /**\r\n   * Logged when fee was changed.\r\n   *\r\n   * @param fee new fee numerator\r\n   */\r\n  event FeeChange (uint256 fee);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_currentTime\",\"type\":\"uint256\"}],\"name\":\"getStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"deliver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEligibleVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sellTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newK1\",\"type\":\"address\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_newK1\",\"type\":\"address\"}],\"name\":\"votesFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"eligibleVotes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"outstandingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_orgonToken\",\"type\":\"address\"},{\"name\":\"_orisSpace\",\"type\":\"address\"},{\"name\":\"_k1\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Investment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Delivery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"k1\",\"type\":\"address\"}],\"name\":\"K1Change\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newK1\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newK1\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"VoteRevocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeChange\",\"type\":\"event\"}]","ContractName":"JustPriceProtocol","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009c43a9d11eb1457e52960bcd226b279f61f337b1000000000000000000000000eed9670a0d9a579ce28a616bde072b7bda343e850000000000000000000000004bb92847a429a7633b7e9ae09779e5db52d9f3d9","Library":"","SwarmSource":"bzzr://ebc7fbd8cfb82e9a433a685ef237a92e2d6e0dc5b9053c803512ebfa0fb680e5"}]}