{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// (c) SecureVote 2018\r\n// github.com/secure-vote/sv-light-smart-contracts\r\n\r\ninterface BBFarmIface {\r\n    /* events */\r\n\r\n    event BBFarmInit(bytes4 namespace);\r\n    event BallotCreatedWithID(uint ballotId);\r\n\r\n    /* from permissioned */\r\n\r\n    function upgradeMe(address newSC) external;\r\n\r\n    /* global bbfarm getters */\r\n\r\n    function getNamespace() external view returns (bytes4);\r\n    function getVersion() external view returns (uint);\r\n    function getBBLibVersion() external view returns (uint256);\r\n    function getNBallots() external view returns (uint256);\r\n\r\n    /* init a ballot */\r\n\r\n    // note that the ballotId returned INCLUDES the namespace.\r\n    function initBallot( bytes32 specHash\r\n                       , uint256 packed\r\n                       , IxIface ix\r\n                       , address bbAdmin\r\n                       , bytes24 extraData\r\n                       ) external returns (uint ballotId);\r\n\r\n    /* Sponsorship of ballots */\r\n\r\n    function sponsor(uint ballotId) external payable;\r\n\r\n    /* Voting functions */\r\n\r\n    function submitVote(uint ballotId, bytes32 vote, bytes extra) external;\r\n    function submitProxyVote(bytes32[5] proxyReq, bytes extra) external;\r\n\r\n    /* Ballot Getters */\r\n\r\n    function getDetails(uint ballotId, address voter) external view returns\r\n            ( bool hasVoted\r\n            , uint nVotesCast\r\n            , bytes32 secKey\r\n            , uint16 submissionBits\r\n            , uint64 startTime\r\n            , uint64 endTime\r\n            , bytes32 specHash\r\n            , bool deprecated\r\n            , address ballotOwner\r\n            , bytes16 extraData);\r\n\r\n    function getVote(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra);\r\n    function getTotalSponsorship(uint ballotId) external view returns (uint);\r\n    function getSponsorsN(uint ballotId) external view returns (uint);\r\n    function getSponsor(uint ballotId, uint sponsorN) external view returns (address sender, uint amount);\r\n    function getCreationTs(uint ballotId) external view returns (uint);\r\n\r\n    /* Admin on ballots */\r\n    function revealSeckey(uint ballotId, bytes32 sk) external;\r\n    function setEndTime(uint ballotId, uint64 newEndTime) external;  // note: testing only\r\n    function setDeprecated(uint ballotId) external;\r\n    function setBallotOwner(uint ballotId, address newOwner) external;\r\n}\r\n\r\nlibrary BBLib {\r\n    using BytesLib for bytes;\r\n\r\n    // ballot meta\r\n    uint256 constant BB_VERSION = 5;\r\n\r\n    // voting settings\r\n    uint16 constant USE_ETH = 1;          // 2^0\r\n    uint16 constant USE_SIGNED = 2;       // 2^1\r\n    uint16 constant USE_NO_ENC = 4;       // 2^2\r\n    uint16 constant USE_ENC = 8;          // 2^3\r\n\r\n    // ballot settings\r\n    uint16 constant IS_BINDING = 8192;    // 2^13\r\n    uint16 constant IS_OFFICIAL = 16384;  // 2^14\r\n    uint16 constant USE_TESTING = 32768;  // 2^15\r\n\r\n    // other consts\r\n    uint32 constant MAX_UINT32 = 0xFFFFFFFF;\r\n\r\n    //// ** Storage Variables\r\n\r\n    // struct for ballot\r\n    struct Vote {\r\n        bytes32 voteData;\r\n        bytes32 castTsAndSender;\r\n        bytes extra;\r\n    }\r\n\r\n    struct Sponsor {\r\n        address sender;\r\n        uint amount;\r\n    }\r\n\r\n    //// ** Events\r\n    event CreatedBallot(bytes32 _specHash, uint64 startTs, uint64 endTs, uint16 submissionBits);\r\n    event SuccessfulVote(address indexed voter, uint voteId);\r\n    event SeckeyRevealed(bytes32 secretKey);\r\n    event TestingEnabled();\r\n    event DeprecatedContract();\r\n\r\n\r\n    // The big database struct\r\n\r\n\r\n    struct DB {\r\n        // Maps to store ballots, along with corresponding log of voters.\r\n        // Should only be modified through internal functions\r\n        mapping (uint256 => Vote) votes;\r\n        uint256 nVotesCast;\r\n\r\n        // we need replay protection for proxy ballots - this will let us check against a sequence number\r\n        // note: votes directly from a user ALWAYS take priority b/c they do not have sequence numbers\r\n        // (sequencing is done by Ethereum itself via the tx nonce).\r\n        mapping (address => uint32) sequenceNumber;\r\n\r\n        // NOTE - We don't actually want to include the encryption PublicKey because _it's included in the ballotSpec_.\r\n        // It's better to ensure ppl actually have the ballot spec by not including it in the contract.\r\n        // Plus we're already storing the hash of the ballotSpec anyway...\r\n\r\n        // Private key to be set after ballot conclusion - curve25519\r\n        bytes32 ballotEncryptionSeckey;\r\n\r\n        // packed contains:\r\n        // 1. Timestamps for start and end of ballot (UTC)\r\n        // 2. bits used to decide which options are enabled or disabled for submission of ballots\r\n        uint256 packed;\r\n\r\n        // specHash by which to validate the ballots integrity\r\n        bytes32 specHash;\r\n        // extradata if we need it - allows us to upgrade spechash format, etc\r\n        bytes16 extraData;\r\n\r\n        // allow tracking of sponsorship for this ballot & connection to index\r\n        Sponsor[] sponsors;\r\n        IxIface index;\r\n\r\n        // deprecation flag - doesn't actually do anything besides signal that this contract is deprecated;\r\n        bool deprecated;\r\n\r\n        address ballotOwner;\r\n        uint256 creationTs;\r\n    }\r\n\r\n\r\n    // ** Modifiers -- note, these are functions here to allow use as a lib\r\n    function requireBallotClosed(DB storage db) internal view {\r\n        require(now > BPackedUtils.packedToEndTime(db.packed), \"!b-closed\");\r\n    }\r\n\r\n    function requireBallotOpen(DB storage db) internal view {\r\n        uint64 _n = uint64(now);\r\n        uint64 startTs;\r\n        uint64 endTs;\r\n        (, startTs, endTs) = BPackedUtils.unpackAll(db.packed);\r\n        require(_n >= startTs && _n < endTs, \"!b-open\");\r\n        require(db.deprecated == false, \"b-deprecated\");\r\n    }\r\n\r\n    function requireBallotOwner(DB storage db) internal view {\r\n        require(msg.sender == db.ballotOwner, \"!b-owner\");\r\n    }\r\n\r\n    function requireTesting(DB storage db) internal view {\r\n        require(isTesting(BPackedUtils.packedToSubmissionBits(db.packed)), \"!testing\");\r\n    }\r\n\r\n    /* Library meta */\r\n\r\n    function getVersion() external view returns (uint) {\r\n        // even though this is constant we want to make sure that it's actually\r\n        // callable on Ethereum so we don't accidentally package the constant code\r\n        // in with an SC using BBLib. This function _must_ be external.\r\n        return BB_VERSION;\r\n    }\r\n\r\n    /* Functions */\r\n\r\n    // \"Constructor\" function - init core params on deploy\r\n    // timestampts are uint64s to give us plenty of room for millennia\r\n    function init(DB storage db, bytes32 _specHash, uint256 _packed, IxIface ix, address ballotOwner, bytes16 extraData) external {\r\n        db.index = ix;\r\n        db.ballotOwner = ballotOwner;\r\n\r\n        uint64 startTs;\r\n        uint64 endTs;\r\n        uint16 sb;\r\n        (sb, startTs, endTs) = BPackedUtils.unpackAll(_packed);\r\n\r\n        bool _testing = isTesting(sb);\r\n        if (_testing) {\r\n            emit TestingEnabled();\r\n        } else {\r\n            require(endTs > now, \"bad-end-time\");\r\n\r\n            // 0x1ff2 is 0001111111110010 in binary\r\n            // by ANDing with subBits we make sure that only bits in positions 0,2,3,13,14,15\r\n            // can be used. these correspond to the option flags at the top, and ETH ballots\r\n            // that are enc'd or plaintext.\r\n            require(sb & 0x1ff2 == 0, \"bad-sb\");\r\n\r\n            // if we give bad submission bits (e.g. all 0s) then refuse to deploy ballot\r\n            bool okaySubmissionBits = 1 == (isEthNoEnc(sb) ? 1 : 0) + (isEthWithEnc(sb) ? 1 : 0);\r\n            require(okaySubmissionBits, \"!valid-sb\");\r\n\r\n            // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\r\n            // (which someone might be able to do if they could set the timestamp in the past)\r\n            startTs = startTs > now ? startTs : uint64(now);\r\n        }\r\n        require(db.specHash == bytes32(0), \"b-exists\");\r\n        require(_specHash != bytes32(0), \"null-specHash\");\r\n        db.specHash = _specHash;\r\n\r\n        db.packed = BPackedUtils.pack(sb, startTs, endTs);\r\n        db.creationTs = now;\r\n\r\n        if (extraData != bytes16(0)) {\r\n            db.extraData = extraData;\r\n        }\r\n\r\n        emit CreatedBallot(db.specHash, startTs, endTs, sb);\r\n    }\r\n\r\n    /* sponsorship */\r\n\r\n    function logSponsorship(DB storage db, uint value) internal {\r\n        db.sponsors.push(Sponsor(msg.sender, value));\r\n    }\r\n\r\n    /* getters */\r\n\r\n    function getVote(DB storage db, uint id) internal view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\r\n        return (db.votes[id].voteData, address(db.votes[id].castTsAndSender), db.votes[id].extra, uint(db.votes[id].castTsAndSender) >> 160);\r\n    }\r\n\r\n    function getSequenceNumber(DB storage db, address voter) internal view returns (uint32) {\r\n        return db.sequenceNumber[voter];\r\n    }\r\n\r\n    function getTotalSponsorship(DB storage db) internal view returns (uint total) {\r\n        for (uint i = 0; i < db.sponsors.length; i++) {\r\n            total += db.sponsors[i].amount;\r\n        }\r\n    }\r\n\r\n    function getSponsor(DB storage db, uint i) external view returns (address sender, uint amount) {\r\n        sender = db.sponsors[i].sender;\r\n        amount = db.sponsors[i].amount;\r\n    }\r\n\r\n    /* ETH BALLOTS */\r\n\r\n    // Ballot submission\r\n    // note: if USE_ENC then curve25519 keys should be generated for\r\n    // each ballot (then thrown away).\r\n    // the curve25519 PKs go in the extra param\r\n    function submitVote(DB storage db, bytes32 voteData, bytes extra) external {\r\n        _addVote(db, voteData, msg.sender, extra);\r\n        // set the sequence number to max uint32 to disable proxy submitted ballots\r\n        // after a voter submits a transaction personally - effectivley disables proxy\r\n        // ballots. You can _always_ submit a new vote _personally_ with this scheme.\r\n        if (db.sequenceNumber[msg.sender] != MAX_UINT32) {\r\n            // using an IF statement here let's us save 4800 gas on repeat votes at the cost of 20k extra gas initially\r\n            db.sequenceNumber[msg.sender] = MAX_UINT32;\r\n        }\r\n    }\r\n\r\n    // Boundaries for constructing the msg we'll validate the signature of\r\n    function submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra) external {\r\n        // a proxy vote (where the vote is submitted (i.e. tx fee paid by someone else)\r\n        // docs for datastructs: https://github.com/secure-vote/tokenvote/blob/master/Docs/DataStructs.md\r\n\r\n        bytes32 r = proxyReq[0];\r\n        bytes32 s = proxyReq[1];\r\n        uint8 v = uint8(proxyReq[2][0]);\r\n        // converting to uint248 will truncate the first byte, and we can then convert it to a bytes31.\r\n        bytes31 proxyReq2 = bytes31(uint248(proxyReq[2]));\r\n        // proxyReq[3] is ballotId - required for verifying sig but not used for anything else\r\n        bytes32 ballotId = proxyReq[3];\r\n        bytes32 voteData = proxyReq[4];\r\n\r\n        // using abi.encodePacked is much cheaper than making bytes in other ways...\r\n        bytes memory signed = abi.encodePacked(proxyReq2, ballotId, voteData, extra);\r\n        bytes32 msgHash = keccak256(signed);\r\n        // need to be sure we are signing the entire ballot and any extra data that comes with it\r\n        address voter = ecrecover(msgHash, v, r, s);\r\n\r\n        // we need to make sure that this is the most recent vote the voter made, and that it has\r\n        // not been seen before. NOTE: we've already validated the BBFarm namespace before this, so\r\n        // we know it's meant for _this_ ballot.\r\n        uint32 sequence = uint32(proxyReq2);  // last 4 bytes of proxyReq2 - the sequence number\r\n        _proxyReplayProtection(db, voter, sequence);\r\n\r\n        _addVote(db, voteData, voter, extra);\r\n    }\r\n\r\n    function _addVote(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\r\n        requireBallotOpen(db);\r\n\r\n        id = db.nVotesCast;\r\n        db.votes[id].voteData = voteData;\r\n        // pack the casting ts right next to the sender\r\n        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);\r\n        if (extra.length > 0) {\r\n            db.votes[id].extra = extra;\r\n        }\r\n        db.nVotesCast += 1;\r\n        emit SuccessfulVote(sender, id);\r\n    }\r\n\r\n    function _proxyReplayProtection(DB storage db, address voter, uint32 sequence) internal {\r\n        // we want the replay protection sequence number to be STRICTLY MORE than what\r\n        // is stored in the mapping. This means we can set sequence to MAX_UINT32 to disable\r\n        // any future votes.\r\n        require(db.sequenceNumber[voter] < sequence, \"bad-sequence-n\");\r\n        db.sequenceNumber[voter] = sequence;\r\n    }\r\n\r\n    /* Admin */\r\n\r\n    function setEndTime(DB storage db, uint64 newEndTime) external {\r\n        uint16 sb;\r\n        uint64 sTs;\r\n        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);\r\n        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);\r\n    }\r\n\r\n    function revealSeckey(DB storage db, bytes32 sk) internal {\r\n        db.ballotEncryptionSeckey = sk;\r\n        emit SeckeyRevealed(sk);\r\n    }\r\n\r\n    /* Submission Bits (Ballot Classifications) */\r\n\r\n    // do (bits & SETTINGS_MASK) to get just operational bits (as opposed to testing or official flag)\r\n    uint16 constant SETTINGS_MASK = 0xFFFF ^ USE_TESTING ^ IS_OFFICIAL ^ IS_BINDING;\r\n\r\n    function isEthNoEnc(uint16 submissionBits) pure internal returns (bool) {\r\n        return checkFlags(submissionBits, USE_ETH | USE_NO_ENC);\r\n    }\r\n\r\n    function isEthWithEnc(uint16 submissionBits) pure internal returns (bool) {\r\n        return checkFlags(submissionBits, USE_ETH | USE_ENC);\r\n    }\r\n\r\n    function isOfficial(uint16 submissionBits) pure internal returns (bool) {\r\n        return (submissionBits & IS_OFFICIAL) == IS_OFFICIAL;\r\n    }\r\n\r\n    function isBinding(uint16 submissionBits) pure internal returns (bool) {\r\n        return (submissionBits & IS_BINDING) == IS_BINDING;\r\n    }\r\n\r\n    function isTesting(uint16 submissionBits) pure internal returns (bool) {\r\n        return (submissionBits & USE_TESTING) == USE_TESTING;\r\n    }\r\n\r\n    function qualifiesAsCommunityBallot(uint16 submissionBits) pure internal returns (bool) {\r\n        // if submissionBits AND any of the bits that make this _not_ a community\r\n        // ballot is equal to zero that means none of those bits were active, so\r\n        // it could be a community ballot\r\n        return (submissionBits & (IS_BINDING | IS_OFFICIAL | USE_ENC)) == 0;\r\n    }\r\n\r\n    function checkFlags(uint16 submissionBits, uint16 expected) pure internal returns (bool) {\r\n        // this should ignore ONLY the testing/flag bits - all other bits are significant\r\n        uint16 sBitsNoSettings = submissionBits & SETTINGS_MASK;\r\n        // then we want ONLY expected\r\n        return sBitsNoSettings == expected;\r\n    }\r\n}\r\n\r\nlibrary BPackedUtils {\r\n\r\n    // the uint16 ending at 128 bits should be 0s\r\n    uint256 constant sbMask        = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;\r\n    uint256 constant startTimeMask = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;\r\n    uint256 constant endTimeMask   = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;\r\n\r\n    function packedToSubmissionBits(uint256 packed) internal pure returns (uint16) {\r\n        return uint16(packed >> 128);\r\n    }\r\n\r\n    function packedToStartTime(uint256 packed) internal pure returns (uint64) {\r\n        return uint64(packed >> 64);\r\n    }\r\n\r\n    function packedToEndTime(uint256 packed) internal pure returns (uint64) {\r\n        return uint64(packed);\r\n    }\r\n\r\n    function unpackAll(uint256 packed) internal pure returns (uint16 submissionBits, uint64 startTime, uint64 endTime) {\r\n        submissionBits = uint16(packed >> 128);\r\n        startTime = uint64(packed >> 64);\r\n        endTime = uint64(packed);\r\n    }\r\n\r\n    function pack(uint16 sb, uint64 st, uint64 et) internal pure returns (uint256 packed) {\r\n        return uint256(sb) << 128 | uint256(st) << 64 | uint256(et);\r\n    }\r\n\r\n    function setSB(uint256 packed, uint16 newSB) internal pure returns (uint256) {\r\n        return (packed & sbMask) | uint256(newSB) << 128;\r\n    }\r\n\r\n    // function setStartTime(uint256 packed, uint64 startTime) internal pure returns (uint256) {\r\n    //     return (packed & startTimeMask) | uint256(startTime) << 64;\r\n    // }\r\n\r\n    // function setEndTime(uint256 packed, uint64 endTime) internal pure returns (uint256) {\r\n    //     return (packed & endTimeMask) | uint256(endTime);\r\n    // }\r\n}\r\n\r\ninterface BallotBoxIface {\r\n    function getVersion() external pure returns (uint256);\r\n\r\n    function getVote(uint256) external view returns (bytes32 voteData, address sender, bytes32 encPK);\r\n\r\n    function getDetails(address voter) external view returns (\r\n        bool hasVoted,\r\n        uint nVotesCast,\r\n        bytes32 secKey,\r\n        uint16 submissionBits,\r\n        uint64 startTime,\r\n        uint64 endTime,\r\n        bytes32 specHash,\r\n        bool deprecated,\r\n        address ballotOwner);\r\n\r\n    function getTotalSponsorship() external view returns (uint);\r\n\r\n    function submitVote(bytes32 voteData, bytes32 encPK) external;\r\n\r\n    function revealSeckey(bytes32 sk) external;\r\n    function setEndTime(uint64 newEndTime) external;\r\n    function setDeprecated() external;\r\n\r\n    function setOwner(address) external;\r\n    function getOwner() external view returns (address);\r\n\r\n    event CreatedBallot(bytes32 specHash, uint64 startTs, uint64 endTs, uint16 submissionBits);\r\n    event SuccessfulVote(address indexed voter, uint voteId);\r\n    event SeckeyRevealed(bytes32 secretKey);\r\n}\r\n\r\ninterface BBAuxIface {\r\n    function isTesting(BallotBoxIface bb) external view returns (bool);\r\n    function isOfficial(BallotBoxIface bb) external view returns (bool);\r\n    function isBinding(BallotBoxIface bb) external view returns (bool);\r\n    function qualifiesAsCommunityBallot(BallotBoxIface bb) external view returns (bool);\r\n\r\n\r\n    function isDeprecated(BallotBoxIface bb) external view returns (bool);\r\n    function getEncSeckey(BallotBoxIface bb) external view returns (bytes32);\r\n    function getSpecHash(BallotBoxIface bb) external view returns (bytes32);\r\n    function getSubmissionBits(BallotBoxIface bb) external view returns (uint16);\r\n    function getStartTime(BallotBoxIface bb) external view returns (uint64);\r\n    function getEndTime(BallotBoxIface bb) external view returns (uint64);\r\n    function getNVotesCast(BallotBoxIface bb) external view returns (uint256 nVotesCast);\r\n\r\n    function hasVoted(BallotBoxIface bb, address voter) external view returns (bool hv);\r\n}\r\n\r\ninterface IxIface {\r\n    function doUpgrade(address) external;\r\n\r\n    function addBBFarm(BBFarmIface bbFarm) external returns (uint8 bbFarmId);\r\n    function emergencySetABackend(bytes32 toSet, address newSC) external;\r\n    function emergencySetBBFarm(uint8 bbFarmId, address _bbFarm) external;\r\n    function emergencySetDAdmin(bytes32 democHash, address newAdmin) external;\r\n\r\n    function getPayments() external view returns (IxPaymentsIface);\r\n    function getBackend() external view returns (IxBackendIface);\r\n    function getBBFarm(uint8 bbFarmId) external view returns (BBFarmIface);\r\n    function getBBFarmID(bytes4 bbNamespace) external view returns (uint8 bbFarmId);\r\n\r\n    function getVersion() external view returns (uint256);\r\n\r\n    function dInit(address defualtErc20) external payable returns (bytes32);\r\n\r\n    function setDErc20(bytes32 democHash, address newErc20) external;\r\n    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external returns (uint);\r\n    function dDeprecateCategory(bytes32 democHash, uint categoryId) external;\r\n    function dUpgradeToPremium(bytes32 democHash) external;\r\n    function dDowngradeToBasic(bytes32 democHash) external;\r\n    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\r\n\r\n    /* democ getters (that used to be here) should be called on either backend or payments directly */\r\n    /* use IxLib for convenience functions from other SCs */\r\n\r\n    /* ballot deployment */\r\n    // only ix owner - used for adding past or special ballots\r\n    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed) external;\r\n    function dDeployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint256 packed) external payable returns (uint);\r\n\r\n\r\n    /* events */\r\n    event PaymentMade(uint[2] valAndRemainder);\r\n    event Emergency(bytes32 setWhat);\r\n    event EmergencyDemocAdmin(bytes32 democHash, address newAdmin);\r\n    event EmergencyBBFarm(uint16 bbFarmId);\r\n    event AddedBBFarm(uint16 bbFarmId);\r\n    event ManuallyAddedBallot(bytes32 democHash, uint256 ballotId, uint256 packed);\r\n    // from backend\r\n    event NewBallot(bytes32 indexed democHash, uint ballotN);\r\n    event NewDemoc(bytes32 democHash);\r\n    event DemocAdminSet(bytes32 indexed democHash, address admin);\r\n    // from BBFarm\r\n    event BallotCreatedWithID(uint ballotId);\r\n}\r\n\r\ninterface IxPaymentsIface {\r\n    function upgradeMe(address) external;\r\n\r\n    function payoutAll() external;\r\n\r\n    function setPayTo(address) external;\r\n    function getPayTo() external view returns (address);\r\n    function setMinorEditsAddr(address) external;\r\n\r\n    function getCommunityBallotCentsPrice() external view returns (uint);\r\n    function setCommunityBallotCentsPrice(uint) external;\r\n    function getCommunityBallotWeiPrice() external view returns (uint);\r\n\r\n    function setBasicCentsPricePer30Days(uint amount) external;\r\n    function getBasicCentsPricePer30Days() external view returns(uint);\r\n    function getBasicExtraBallotFeeWei() external view returns (uint);\r\n    function getBasicBallotsPer30Days() external view returns (uint);\r\n    function setBasicBallotsPer30Days(uint amount) external;\r\n    function setPremiumMultiplier(uint8 amount) external;\r\n    function getPremiumMultiplier() external view returns (uint8);\r\n    function getPremiumCentsPricePer30Days() external view returns (uint);\r\n    function setWeiPerCent(uint) external;\r\n    function setFreeExtension(bytes32 democHash, bool hasFreeExt) external;\r\n    function getWeiPerCent() external view returns (uint weiPerCent);\r\n    function getUsdEthExchangeRate() external view returns (uint centsPerEth);\r\n\r\n    function weiBuysHowManySeconds(uint amount) external view returns (uint secs);\r\n\r\n    function downgradeToBasic(bytes32 democHash) external;\r\n    function upgradeToPremium(bytes32 democHash) external;\r\n    function doFreeExtension(bytes32 democHash) external;\r\n\r\n    function payForDemocracy(bytes32 democHash) external payable;\r\n    function accountInGoodStanding(bytes32 democHash) external view returns (bool);\r\n    function getSecondsRemaining(bytes32 democHash) external view returns (uint);\r\n    function getPremiumStatus(bytes32 democHash) external view returns (bool);\r\n    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension);\r\n    function getFreeExtension(bytes32 democHash) external view returns (bool);\r\n\r\n    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external;\r\n\r\n    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external;\r\n    function getDenyPremium(bytes32 democHash) external view returns (bool);\r\n\r\n    function getPaymentLogN() external view returns (uint);\r\n    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue);\r\n\r\n    event UpgradedToPremium(bytes32 indexed democHash);\r\n    event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref);\r\n    event AccountPayment(bytes32 indexed democHash, uint additionalSeconds);\r\n    event SetCommunityBallotFee(uint amount);\r\n    event SetBasicCentsPricePer30Days(uint amount);\r\n    event SetPremiumMultiplier(uint8 multiplier);\r\n    event DowngradeToBasic(bytes32 indexed democHash);\r\n    event UpgradeToPremium(bytes32 indexed democHash);\r\n    event SetExchangeRate(uint weiPerCent);\r\n    event FreeExtension(bytes32 democHash);\r\n}\r\n\r\ninterface IxBackendIface {\r\n    function upgradeMe(address) external;\r\n\r\n    /* global getters */\r\n    function getGDemocsN() external view returns (uint);\r\n    function getGDemoc(uint id) external view returns (bytes32);\r\n    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes);\r\n\r\n    /* democ admin */\r\n    function dInit(address defaultErc20) external returns (bytes32);\r\n    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool recordTowardsBasicLimit) external;\r\n    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external returns (uint);\r\n    function dDeprecateCategory(bytes32 democHash, uint categoryId) external;\r\n    function setDAdmin(bytes32 democHash, address newAdmin) external;\r\n    function setDErc20(bytes32 democHash, address newErc20) external;\r\n    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\r\n\r\n    /* global democ getters */\r\n    function getDInfo(bytes32 democHash) external view returns (address erc20, address admin, uint256 nBallots);\r\n    function getDErc20(bytes32 democHash) external view returns (address);\r\n    function getDAdmin(bytes32 democHash) external view returns (address);\r\n    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\r\n\r\n    function getDBallotsN(bytes32 democHash) external view returns (uint256);\r\n    function getDBallotID(bytes32 democHash, uint n) external view returns (uint ballotId);\r\n    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256);\r\n    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256);\r\n\r\n    function getDCategoriesN(bytes32 democHash) external view returns (uint);\r\n    function getDCategory(bytes32 democHash, uint categoryId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint parent);\r\n\r\n    /* just for prefix stuff */\r\n    function getDHash(bytes13 prefix) external view returns (bytes32);\r\n\r\n    /* events */\r\n    event NewBallot(bytes32 indexed democHash, uint ballotN);\r\n    event NewDemoc(bytes32 democHash);\r\n    event DemocAdminSet(bytes32 indexed democHash, address admin);\r\n}\r\n\r\ncontract SVBallotConsts {\r\n    // voting settings\r\n    uint16 constant USE_ETH = 1;          // 2^0\r\n    uint16 constant USE_SIGNED = 2;       // 2^1\r\n    uint16 constant USE_NO_ENC = 4;       // 2^2\r\n    uint16 constant USE_ENC = 8;          // 2^3\r\n\r\n    // ballot settings\r\n    uint16 constant IS_BINDING = 8192;    // 2^13\r\n    uint16 constant IS_OFFICIAL = 16384;  // 2^14\r\n    uint16 constant USE_TESTING = 32768;  // 2^15\r\n}\r\n\r\ncontract safeSend {\r\n    bool private txMutex3847834;\r\n\r\n    // we want to be able to call outside contracts (e.g. the admin proxy contract)\r\n    // but reentrency is bad, so here's a mutex.\r\n    function doSafeSend(address toAddr, uint amount) internal {\r\n        doSafeSendWData(toAddr, \"\", amount);\r\n    }\r\n\r\n    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\r\n        require(txMutex3847834 == false, \"ss-guard\");\r\n        txMutex3847834 = true;\r\n        // we need to use address.call.value(v)() because we want\r\n        // to be able to send to other contracts, even with no data,\r\n        // which might use more than 2300 gas in their fallback function.\r\n        require(toAddr.call.value(amount)(data), \"ss-failed\");\r\n        txMutex3847834 = false;\r\n    }\r\n}\r\n\r\ncontract payoutAllC is safeSend {\r\n    address _payTo;\r\n\r\n    constructor() public {\r\n        _payTo = msg.sender;\r\n    }\r\n\r\n    function payoutAll() external {\r\n        doSafeSend(_payTo, address(this).balance);\r\n    }\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    event OwnerChanged(address newOwner);\r\n\r\n    modifier only_owner() {\r\n        require(msg.sender == owner, \"only_owner: forbidden\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address newOwner) only_owner() external {\r\n        owner = newOwner;\r\n        emit OwnerChanged(newOwner);\r\n    }\r\n}\r\n\r\ncontract hasAdmins is owned {\r\n    mapping (uint => mapping (address => bool)) admins;\r\n    uint public currAdminEpoch = 0;\r\n    bool public adminsDisabledForever = false;\r\n    address[] adminLog;\r\n\r\n    event AdminAdded(address indexed newAdmin);\r\n    event AdminRemoved(address indexed oldAdmin);\r\n    event AdminEpochInc();\r\n    event AdminDisabledForever();\r\n\r\n    modifier only_admin() {\r\n        require(adminsDisabledForever == false, \"admins must not be disabled\");\r\n        require(isAdmin(msg.sender), \"only_admin: forbidden\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _setAdmin(msg.sender, true);\r\n    }\r\n\r\n    function isAdmin(address a) view public returns (bool) {\r\n        return admins[currAdminEpoch][a];\r\n    }\r\n\r\n    function getAdminLogN() view external returns (uint) {\r\n        return adminLog.length;\r\n    }\r\n\r\n    function getAdminLog(uint n) view external returns (address) {\r\n        return adminLog[n];\r\n    }\r\n\r\n    function upgradeMeAdmin(address newAdmin) only_admin() external {\r\n        // note: already checked msg.sender has admin with `only_admin` modifier\r\n        require(msg.sender != owner, \"owner cannot upgrade self\");\r\n        _setAdmin(msg.sender, false);\r\n        _setAdmin(newAdmin, true);\r\n    }\r\n\r\n    function setAdmin(address a, bool _givePerms) only_admin() external {\r\n        require(a != msg.sender && a != owner, \"cannot change your own (or owner's) permissions\");\r\n        _setAdmin(a, _givePerms);\r\n    }\r\n\r\n    function _setAdmin(address a, bool _givePerms) internal {\r\n        admins[currAdminEpoch][a] = _givePerms;\r\n        if (_givePerms) {\r\n            emit AdminAdded(a);\r\n            adminLog.push(a);\r\n        } else {\r\n            emit AdminRemoved(a);\r\n        }\r\n    }\r\n\r\n    // safety feature if admins go bad or something\r\n    function incAdminEpoch() only_owner() external {\r\n        currAdminEpoch++;\r\n        admins[currAdminEpoch][msg.sender] = true;\r\n        emit AdminEpochInc();\r\n    }\r\n\r\n    // this is internal so contracts can all it, but not exposed anywhere in this\r\n    // contract.\r\n    function disableAdminForever() internal {\r\n        currAdminEpoch++;\r\n        adminsDisabledForever = true;\r\n        emit AdminDisabledForever();\r\n    }\r\n}\r\n\r\ncontract permissioned is owned, hasAdmins {\r\n    mapping (address => bool) editAllowed;\r\n    bool public adminLockdown = false;\r\n\r\n    event PermissionError(address editAddr);\r\n    event PermissionGranted(address editAddr);\r\n    event PermissionRevoked(address editAddr);\r\n    event PermissionsUpgraded(address oldSC, address newSC);\r\n    event SelfUpgrade(address oldSC, address newSC);\r\n    event AdminLockdown();\r\n\r\n    modifier only_editors() {\r\n        require(editAllowed[msg.sender], \"only_editors: forbidden\");\r\n        _;\r\n    }\r\n\r\n    modifier no_lockdown() {\r\n        require(adminLockdown == false, \"no_lockdown: check failed\");\r\n        _;\r\n    }\r\n\r\n\r\n    constructor() owned() hasAdmins() public {\r\n    }\r\n\r\n\r\n    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\r\n        editAllowed[e] = _editPerms;\r\n        if (_editPerms)\r\n            emit PermissionGranted(e);\r\n        else\r\n            emit PermissionRevoked(e);\r\n    }\r\n\r\n    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\r\n        editAllowed[oldSC] = false;\r\n        editAllowed[newSC] = true;\r\n        emit PermissionsUpgraded(oldSC, newSC);\r\n    }\r\n\r\n    // always allow SCs to upgrade themselves, even after lockdown\r\n    function upgradeMe(address newSC) only_editors() external {\r\n        editAllowed[msg.sender] = false;\r\n        editAllowed[newSC] = true;\r\n        emit SelfUpgrade(msg.sender, newSC);\r\n    }\r\n\r\n    function hasPermissions(address a) public view returns (bool) {\r\n        return editAllowed[a];\r\n    }\r\n\r\n    function doLockdown() external only_owner() no_lockdown() {\r\n        disableAdminForever();\r\n        adminLockdown = true;\r\n        emit AdminLockdown();\r\n    }\r\n}\r\n\r\ncontract upgradePtr {\r\n    address ptr = address(0);\r\n\r\n    modifier not_upgraded() {\r\n        require(ptr == address(0), \"upgrade pointer is non-zero\");\r\n        _;\r\n    }\r\n\r\n    function getUpgradePointer() view external returns (address) {\r\n        return ptr;\r\n    }\r\n\r\n    function doUpgradeInternal(address nextSC) internal {\r\n        ptr = nextSC;\r\n    }\r\n}\r\n\r\ninterface ERC20Interface {\r\n    // Get the total token supply\r\n    function totalSupply() constant external returns (uint256 _totalSupply);\r\n\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) constant external returns (uint256 balance);\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    // this function is required for some DEX functionality\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\nlibrary MemArrApp {\r\n\r\n    // A simple library to allow appending to memory arrays.\r\n\r\n    function appendUint256(uint256[] memory arr, uint256 val) internal pure returns (uint256[] memory toRet) {\r\n        toRet = new uint256[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendUint128(uint128[] memory arr, uint128 val) internal pure returns (uint128[] memory toRet) {\r\n        toRet = new uint128[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendUint64(uint64[] memory arr, uint64 val) internal pure returns (uint64[] memory toRet) {\r\n        toRet = new uint64[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendUint32(uint32[] memory arr, uint32 val) internal pure returns (uint32[] memory toRet) {\r\n        toRet = new uint32[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendUint16(uint16[] memory arr, uint16 val) internal pure returns (uint16[] memory toRet) {\r\n        toRet = new uint16[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendBool(bool[] memory arr, bool val) internal pure returns (bool[] memory toRet) {\r\n        toRet = new bool[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendBytes32(bytes32[] memory arr, bytes32 val) internal pure returns (bytes32[] memory toRet) {\r\n        toRet = new bytes32[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendBytes32Pair(bytes32[2][] memory arr, bytes32[2] val) internal pure returns (bytes32[2][] memory toRet) {\r\n        toRet = new bytes32[2][](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendBytes(bytes[] memory arr, bytes val) internal pure returns (bytes[] memory toRet) {\r\n        toRet = new bytes[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n    function appendAddress(address[] memory arr, address val) internal pure returns (address[] memory toRet) {\r\n        toRet = new address[](arr.length + 1);\r\n\r\n        for (uint256 i = 0; i < arr.length; i++) {\r\n            toRet[i] = arr[i];\r\n        }\r\n\r\n        toRet[arr.length] = val;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLib.DB storage\"},{\"name\":\"_specHash\",\"type\":\"bytes32\"},{\"name\":\"_packed\",\"type\":\"uint256\"},{\"name\":\"ix\",\"type\":\"IxIface\"},{\"name\":\"ballotOwner\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes16\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLib.DB storage\"},{\"name\":\"voteData\",\"type\":\"bytes32\"},{\"name\":\"extra\",\"type\":\"bytes\"}],\"name\":\"submitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLib.DB storage\"},{\"name\":\"proxyReq\",\"type\":\"bytes32[5]\"},{\"name\":\"extra\",\"type\":\"bytes\"}],\"name\":\"submitProxyVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLib.DB storage\"},{\"name\":\"newEndTime\",\"type\":\"uint64\"}],\"name\":\"setEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLib.DB storage\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getSponsor\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_specHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"startTs\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"endTs\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"submissionBits\",\"type\":\"uint16\"}],\"name\":\"CreatedBallot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"voteId\",\"type\":\"uint256\"}],\"name\":\"SuccessfulVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"secretKey\",\"type\":\"bytes32\"}],\"name\":\"SeckeyRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TestingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DeprecatedContract\",\"type\":\"event\"}]","ContractName":"BBLib","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://36b5760eb53083a9896274dd27e8a84e35066f4df7225a027262884c4e0c7536"}]}