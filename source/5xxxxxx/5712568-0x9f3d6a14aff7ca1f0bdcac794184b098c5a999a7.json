{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\ncontract RouletteRules {\r\n    function getTotalBetAmount(bytes32 first16, bytes32 second16) public pure returns(uint totalBetAmount);\r\n    function getBetResult(bytes32 betTypes, bytes32 first16, bytes32 second16, uint wheelResult) public view returns(uint wonAmount);\r\n}\r\n\r\ncontract OracleRoulette {\r\n\r\n    //*********************************************\r\n    // Infrastructure\r\n    //*********************************************\r\n\r\n    RouletteRules rouletteRules;\r\n    address developer;\r\n    address operator;\r\n    // enable or disable contract\r\n    // cannot place new bets if enabled\r\n    bool shouldGateGuard;\r\n    // save timestamp for gate guard\r\n    uint sinceGateGuarded;\r\n\r\n    constructor(address _rouletteRules) public payable {\r\n        rouletteRules = RouletteRules(_rouletteRules);\r\n        developer = msg.sender;\r\n        operator = msg.sender;\r\n        shouldGateGuard = false;\r\n        // set as the max value\r\n        sinceGateGuarded = ~uint(0);\r\n    }\r\n\r\n    modifier onlyDeveloper() {\r\n        require(msg.sender == developer);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operator);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDeveloperOrOperator() {\r\n        require(msg.sender == developer || msg.sender == operator);\r\n        _;\r\n    }\r\n\r\n    modifier shouldGateGuardForEffectiveTime() {\r\n        // This is to protect players\r\n        // preventing the owner from running away with the contract balance\r\n        // when players are still playing the game.\r\n        // This function can only be operated\r\n        // after specified minutes has passed since gate guard is up.\r\n        require(shouldGateGuard == true && (sinceGateGuarded - now) > 10 minutes);\r\n        _;\r\n    }\r\n\r\n    function changeDeveloper(address newDeveloper) external onlyDeveloper {\r\n        developer = newDeveloper;\r\n    }\r\n\r\n    function changeOperator(address newOperator) external onlyDeveloper {\r\n        operator = newOperator;\r\n    }\r\n\r\n    function setShouldGateGuard(bool flag) external onlyDeveloperOrOperator {\r\n        if (flag) sinceGateGuarded = now;\r\n        shouldGateGuard = flag;\r\n    }\r\n\r\n    function setRouletteRules(address _newRouletteRules) external onlyDeveloperOrOperator shouldGateGuardForEffectiveTime {\r\n        rouletteRules = RouletteRules(_newRouletteRules);\r\n    }\r\n\r\n    // only be called in case the contract may need to be destroyed\r\n    function destroyContract() external onlyDeveloper shouldGateGuardForEffectiveTime {\r\n        selfdestruct(developer);\r\n    }\r\n\r\n    // only be called for maintenance reasons\r\n    function withdrawFund(uint amount) external onlyDeveloper shouldGateGuardForEffectiveTime {\r\n        require(address(this).balance >= amount);\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    // for fund deposit\r\n    // make contract payable\r\n    function () external payable {}\r\n\r\n    //*********************************************\r\n    // Game Settings & House State Variables\r\n    //*********************************************\r\n\r\n    uint BET_UNIT = 0.0002 ether;\r\n    uint BLOCK_TARGET_DELAY = 0;\r\n    // EVM is only able to store hashes of latest 256 blocks\r\n    uint constant MAXIMUM_DISTANCE_FROM_BLOCK_TARGET_DELAY = 250;\r\n    uint MAX_BET = 1 ether;\r\n    uint MAX_GAME_PER_BLOCK = 10;\r\n\r\n    function setBetUnit(uint newBetUnitInWei) external onlyDeveloperOrOperator shouldGateGuardForEffectiveTime {\r\n        require(newBetUnitInWei > 0);\r\n        BET_UNIT = newBetUnitInWei;\r\n    }\r\n\r\n    function setBlockTargetDelay(uint newTargetDelay) external onlyDeveloperOrOperator {\r\n        require(newTargetDelay >= 0);\r\n        BLOCK_TARGET_DELAY = newTargetDelay;\r\n    }\r\n\r\n    function setMaxBet(uint newMaxBet) external onlyDeveloperOrOperator {\r\n        MAX_BET = newMaxBet;\r\n    }\r\n\r\n    function setMaxGamePerBlock(uint newMaxGamePerBlock) external onlyDeveloperOrOperator {\r\n        MAX_GAME_PER_BLOCK = newMaxGamePerBlock;\r\n    }\r\n\r\n    //*********************************************\r\n    // Service Interface\r\n    //*********************************************\r\n\r\n    event GameError(address player, string message);\r\n    event GameStarted(address player, uint gameId, uint targetBlock);\r\n    event GameEnded(address player, uint wheelResult, uint wonAmount);\r\n\r\n    function placeBet(bytes32 betTypes, bytes32 first16, bytes32 second16) external payable {\r\n        // check gate guard\r\n        if (shouldGateGuard == true) {\r\n            emit GameError(msg.sender, \"Entrance not allowed!\");\r\n            revert();\r\n        }\r\n\r\n        // check if the received ether is the same as specified in the bets\r\n        uint betAmount = rouletteRules.getTotalBetAmount(first16, second16) * BET_UNIT;\r\n        // if the amount does not match\r\n        if (betAmount == 0 || msg.value != betAmount || msg.value > MAX_BET) {\r\n            emit GameError(msg.sender, \"Wrong bet amount!\");\r\n            revert();\r\n        }\r\n\r\n        // set target block\r\n        // current block number + target delay\r\n        uint targetBlock = block.number + BLOCK_TARGET_DELAY;\r\n\r\n        // check if MAX_GAME_PER_BLOCK is reached\r\n        uint historyLength = gameHistory.length;\r\n        if (historyLength > 0) {\r\n            uint counter;\r\n            for (uint i = historyLength - 1; i >= 0; i--) {\r\n                if (gameHistory[i].targetBlock == targetBlock) {\r\n                    counter++;\r\n                    if (counter > MAX_GAME_PER_BLOCK) {\r\n                        emit GameError(msg.sender, \"Reached max game per block!\");\r\n                        revert();\r\n                    }\r\n                } else break;\r\n            }\r\n        }\r\n\r\n        // start a new game\r\n        // init wheelResult with number 100\r\n        Game memory newGame = Game(uint8(GameStatus.PENDING), 100, msg.sender, targetBlock, betTypes, first16, second16);\r\n        uint gameId = gameHistory.push(newGame) - 1;\r\n        emit GameStarted(msg.sender, gameId, targetBlock);\r\n    }\r\n\r\n    function resolveBet(uint gameId) external {\r\n        // get game from history\r\n        Game storage game = gameHistory[gameId];\r\n\r\n        // should not proceed if game status is not PENDING\r\n        if (game.status != uint(GameStatus.PENDING)) {\r\n            emit GameError(game.player, \"Game is not pending!\");\r\n            revert();\r\n        }\r\n\r\n        // see if current block is early/late enough to get the block hash\r\n        // if it's too early to resolve bet\r\n        if (block.number <= game.targetBlock) {\r\n            emit GameError(game.player, \"Too early to resolve bet!\");\r\n            revert();\r\n        }\r\n        // if it's too late to retrieve the block hash\r\n        if (block.number - game.targetBlock > MAXIMUM_DISTANCE_FROM_BLOCK_TARGET_DELAY) {\r\n            // mark game status as rejected\r\n            game.status = uint8(GameStatus.REJECTED);\r\n            emit GameError(game.player, \"Too late to resolve bet!\");\r\n            revert();\r\n        }\r\n\r\n        // get hash of set target block\r\n        bytes32 blockHash = blockhash(game.targetBlock);\r\n        // double check that the queried hash is not zero\r\n        if (blockHash == 0) {\r\n            // mark game status as rejected\r\n            game.status = uint8(GameStatus.REJECTED);\r\n            emit GameError(game.player, \"blockhash() returned zero!\");\r\n            revert();\r\n        }\r\n\r\n        // generate random number of 0~36\r\n        // blockhash of target block, address of game player, address of contract as source of entropy\r\n        game.wheelResult = uint8(keccak256(blockHash, game.player, address(this))) % 37;\r\n\r\n        // resolve won amount\r\n        uint wonAmount = rouletteRules.getBetResult(game.betTypes, game.first16, game.second16, game.wheelResult) * BET_UNIT;\r\n        // set status first to prevent possible reentrancy attack within same transaction\r\n        game.status = uint8(GameStatus.RESOLVED);\r\n        // transfer if the amount is bigger than 0\r\n        if (wonAmount > 0) {\r\n            game.player.transfer(wonAmount);\r\n        }\r\n        emit GameEnded(game.player, game.wheelResult, wonAmount);\r\n    }\r\n\r\n    //*********************************************\r\n    // Game Interface\r\n    //*********************************************\r\n\r\n    Game[] private gameHistory;\r\n\r\n    enum GameStatus {\r\n        INITIAL,\r\n        PENDING,\r\n        RESOLVED,\r\n        REJECTED\r\n    }\r\n\r\n    struct Game {\r\n        uint8 status;\r\n        uint8 wheelResult;\r\n        address player;\r\n        uint256 targetBlock;\r\n        // one byte specifies one bet type\r\n        bytes32 betTypes;\r\n        // two bytes per bet amount on each type\r\n        bytes32 first16;\r\n        bytes32 second16;\r\n    }\r\n\r\n    //*********************************************\r\n    // Query Functions\r\n    //*********************************************\r\n\r\n    function queryGameStatus(uint gameId) external view returns(uint8) {\r\n        Game memory game = gameHistory[gameId];\r\n        return uint8(game.status);\r\n    }\r\n\r\n    function queryBetUnit() external view returns(uint) {\r\n        return BET_UNIT;\r\n    }\r\n\r\n    function queryGameHistory(uint gameId) external view returns(\r\n        address player, uint256 targetBlock, uint8 status, uint8 wheelResult,\r\n        bytes32 betTypes, bytes32 first16, bytes32 second16\r\n    ) {\r\n        Game memory g = gameHistory[gameId];\r\n        player = g.player;\r\n        targetBlock = g.targetBlock;\r\n        status = g.status;\r\n        wheelResult = g.wheelResult;\r\n        betTypes = g.betTypes;\r\n        first16 = g.first16;\r\n        second16 = g.second16;\r\n    }\r\n\r\n    function queryGameHistoryLength() external view returns(uint length) {\r\n        return gameHistory.length;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDeveloper\",\"type\":\"address\"}],\"name\":\"changeDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"queryGameStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"resolveBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxGamePerBlock\",\"type\":\"uint256\"}],\"name\":\"setMaxGamePerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTargetDelay\",\"type\":\"uint256\"}],\"name\":\"setBlockTargetDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryGameHistoryLength\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxBet\",\"type\":\"uint256\"}],\"name\":\"setMaxBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betTypes\",\"type\":\"bytes32\"},{\"name\":\"first16\",\"type\":\"bytes32\"},{\"name\":\"second16\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBetUnitInWei\",\"type\":\"uint256\"}],\"name\":\"setBetUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queryBetUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRouletteRules\",\"type\":\"address\"}],\"name\":\"setRouletteRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"queryGameHistory\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"targetBlock\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"wheelResult\",\"type\":\"uint8\"},{\"name\":\"betTypes\",\"type\":\"bytes32\"},{\"name\":\"first16\",\"type\":\"bytes32\"},{\"name\":\"second16\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setShouldGateGuard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rouletteRules\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"GameError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"targetBlock\",\"type\":\"uint256\"}],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wheelResult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wonAmount\",\"type\":\"uint256\"}],\"name\":\"GameEnded\",\"type\":\"event\"}]","ContractName":"OracleRoulette","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000dca82e4dfbce4442b19a85df47fd64aeaaf55d9f","Library":"","SwarmSource":"bzzr://597f4d825af0860751515ec60c1a7f384fa54b31c2af9a60cdd34b59f91ba40e"}]}