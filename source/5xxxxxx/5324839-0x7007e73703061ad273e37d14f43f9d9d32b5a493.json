{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Basic contracts\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n    * @dev transfer contracts for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of contracts to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Burn(burner, _value);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 contracts\r\n *\r\n * @dev Implementation of the basic standard contracts.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n *\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n\r\n}\r\n\r\ncontract PAXToken is BurnableToken, PausableToken {\r\n\r\n    using SafeMath for uint;\r\n\r\n    string public constant name = \"Pax Token\";\r\n\r\n    string public constant symbol = \"PAX\";\r\n\r\n    uint32 public constant decimals = 10;\r\n\r\n    uint256 public constant INITIAL_SUPPLY = 999500000 * (10 ** uint256(decimals));\r\n\r\n    /**\r\n     * @dev Constructor that gives msg.sender all of existing tokens.\r\n     * @param _company address reserve tokens (300000000)\r\n     * @param _founders_1 address reserve tokens (300000000)\r\n     * @param _founders_2 address reserve tokens (50000000)\r\n     * @param _isPause bool (pause === true)\r\n     */\r\n    function PAXToken(address _company, address _founders_1, address _founders_2, bool _isPause) public {\r\n        require(_company != address(0) && _founders_1 != address(0) && _founders_2 != address(0));\r\n        paused = _isPause;\r\n        totalSupply = INITIAL_SUPPLY;\r\n        balances[msg.sender] = 349500000 * (10 ** uint256(decimals));\r\n        balances[_company] = 300000000 * (10 ** uint256(decimals));\r\n        balances[_founders_1] = 300000000 * (10 ** uint256(decimals));\r\n        balances[_founders_2] = 50000000 * (10 ** uint256(decimals));\r\n        emit Transfer(0x0, msg.sender, balances[msg.sender]);\r\n        emit Transfer(0x0, _company, balances[_company]);\r\n        emit Transfer(0x0, _founders_1, balances[_founders_1]);\r\n        emit Transfer(0x0, _founders_2, balances[_founders_2]);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev transfer contracts for a specified address, despite the pause state\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function ownersTransfer(address _to, uint256 _value) public onlyOwner returns (bool) {\r\n        return BasicToken.transfer(_to, _value);\r\n    }\r\n}\r\n\r\ncontract Crowdsale is Pausable {\r\n\r\n    struct stageInfo {\r\n        uint start;\r\n        uint stop;\r\n        uint duration;\r\n        uint bonus;\r\n        uint limit;\r\n    }\r\n\r\n    /**\r\n     * @dev Mapping with stageId = stageInfo\r\n     */\r\n    mapping (uint => stageInfo) public stages;\r\n\r\n    /**\r\n     * @dev Mapping with adress = with balance\r\n     */\r\n    mapping(address => uint) public balances;\r\n\r\n    /**\r\n     * @dev Softcap\r\n     */\r\n    uint public constant softcap = 2500 ether;\r\n\r\n    /**\r\n     * @dev xDecimals\r\n     */\r\n    uint public constant decimals = 1E10;\r\n\r\n    /**\r\n     * @dev ICO Period Number\r\n     */\r\n    uint public period = 5;\r\n\r\n    /**\r\n     * @dev Total number of minted tokens\r\n     */\r\n    uint public hardcap;\r\n\r\n    /**\r\n     * @dev Cost of the token\r\n     */\r\n    uint public rate;\r\n\r\n    /**\r\n     * @dev Number of sold tokens\r\n     */\r\n    uint public totalSold = 0;\r\n\r\n    /**\r\n     * @dev Assembled Eth\r\n     */\r\n    uint256 public sumWei;\r\n\r\n    /**\r\n     * @dev ICO Status\r\n     */\r\n    bool public state;\r\n\r\n    /**\r\n     * @dev Once call flag\r\n     */\r\n    bool public requireOnce = true;\r\n\r\n    /**\r\n     * @dev Once burning flag\r\n     */\r\n    bool public isBurned;\r\n\r\n    /**\r\n     * @dev Reserve tokens adress for company (300000000)\r\n     */\r\n    address public company;\r\n\r\n    /**\r\n     * @dev Reserve tokens adress for founders first (300000000)\r\n     */\r\n    address public founders_1;\r\n\r\n    /**\r\n     * @dev Reserve tokens adress for founders second (50000000)\r\n     */\r\n    address public founders_2;\r\n\r\n    /**\r\n     * @dev The address to which the received ether will be sent\r\n     */\r\n    address public multisig;\r\n\r\n    /**\r\n     * @dev Tokens classes\r\n     */\r\n    PAXToken public token;\r\n\r\n    /**\r\n     * @dev Number of coins for the typical period\r\n     */\r\n    uint private constant typicalBonus = 100;\r\n\r\n    /**\r\n     * @dev Sending tokens\r\n     */\r\n    uint private sendingTokens;\r\n\r\n    /**\r\n     * @dev Time left\r\n     */\r\n    uint private timeLeft;\r\n\r\n    /**\r\n     * @dev Pause date\r\n     */\r\n    uint private pauseDate;\r\n\r\n    /**\r\n     * @dev Paused by value flag\r\n     */\r\n    bool private pausedByValue;\r\n\r\n    /**\r\n     * @dev Manual pause flag\r\n     */\r\n    bool private manualPause;\r\n\r\n\r\n    event StartICO();\r\n\r\n    event StopICO();\r\n\r\n    event BurnUnsoldTokens();\r\n\r\n    event NewWalletAddress(address _to);\r\n\r\n    event Refund(address _wallet, uint _val);\r\n\r\n    event DateMoved(uint value);\r\n\r\n    using SafeMath for uint;\r\n\r\n    modifier saleIsOn() {\r\n        require(state);\r\n        uint stageId = getStageId();\r\n        if (period != stageId || stageId == 5) {\r\n            usersPause();\r\n            (msg.sender).transfer(msg.value);\r\n        }\r\n        else\r\n            _;\r\n    }\r\n\r\n    modifier isUnderHardCap() {\r\n        uint tokenBalance = token.balanceOf(this);\r\n        require(\r\n            tokenBalance <= hardcap &&\r\n            tokenBalance >= 500\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    function Crowdsale(address _company, address _founders_1, address _founders_2, address _token) public {\r\n        multisig = owner;\r\n        rate = (uint)(1 ether).div(5000);\r\n\r\n        stages[0] = stageInfo({\r\n            start: 0,\r\n            stop: 0,\r\n            duration: 14 days,\r\n            bonus: 130,\r\n            limit:  44500000 * decimals\r\n            });\r\n\r\n        stages[1] = stageInfo({\r\n            start: 0,\r\n            stop: 0,\r\n            duration: 14 days,\r\n            bonus: 115,\r\n            limit:  85000000 * decimals\r\n            });\r\n\r\n        stages[2] = stageInfo({\r\n            start: 0,\r\n            stop: 0,\r\n            duration: 14 days,\r\n            bonus: 110,\r\n            limit:  100000000 * decimals\r\n            });\r\n\r\n        stages[3] = stageInfo({\r\n            start: 0,\r\n            stop: 0,\r\n            duration: 14 days,\r\n            bonus: 105,\r\n            limit:  120000000 * decimals\r\n            });\r\n\r\n        hardcap = 349500000 * decimals;\r\n\r\n        token = PAXToken(_token);\r\n\r\n        company = _company;\r\n        founders_1 = _founders_1;\r\n        founders_2 = _founders_2;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Fallback function\r\n     */\r\n    function() whenNotPaused saleIsOn external payable {\r\n        require (msg.value > 0);\r\n        sendTokens(msg.value, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Manual sending tokens\r\n     * @param _to address where sending tokens\r\n     * @param _value uint256 value tokens for sending\r\n     */\r\n    function manualSendTokens(address _to, uint256 _value) public onlyOwner returns(bool) {\r\n        uint tokens = _value;\r\n        uint avalibleTokens = token.balanceOf(this);\r\n\r\n        if (tokens < avalibleTokens) {\r\n            if (tokens <= stages[3].limit) {\r\n                stages[3].limit = (stages[3].limit).sub(tokens);\r\n            } else if (tokens <= (stages[3].limit).add(stages[2].limit)) {\r\n                stages[2].limit = (stages[2].limit).sub(tokens.sub(stages[3].limit));\r\n                stages[3].limit = 0;\r\n            } else if (tokens <= (stages[3].limit).add(stages[2].limit).add(stages[1].limit)) {\r\n                stages[1].limit = (stages[1].limit).sub(tokens.sub(stages[3].limit).sub(stages[2].limit));\r\n                stages[3].limit = 0;\r\n                stages[2].limit = 0;\r\n            } else if (tokens <= (stages[3].limit).add(stages[2].limit).add(stages[1].limit).add(stages[0].limit)) {\r\n                stages[0].limit = (stages[0].limit).sub(tokens.sub(stages[3].limit).sub(stages[2].limit).sub(stages[1].limit));\r\n                stages[3].limit = 0;\r\n                stages[2].limit = 0;\r\n                stages[1].limit = 0;\r\n            }\r\n        } else {\r\n            tokens = avalibleTokens;\r\n            stages[3].limit = 0;\r\n            stages[2].limit = 0;\r\n            stages[1].limit = 0;\r\n            stages[0].limit = 0;\r\n        }\r\n\r\n        sendingTokens = sendingTokens.add(tokens);\r\n        sumWei = sumWei.add(tokens.mul(rate).div(decimals));\r\n        totalSold = totalSold.add(tokens);\r\n        token.ownersTransfer(_to, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Return Etherium all investors\r\n     */\r\n    function refund() public {\r\n        require(sumWei < softcap && !state);\r\n        uint value = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        emit Refund(msg.sender, value);\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Burning all tokens on mintAddress\r\n     */\r\n    function burnUnsoldTokens() onlyOwner public returns(bool) {\r\n        require(!state);\r\n        require(!isBurned);\r\n        isBurned = true;\r\n        emit BurnUnsoldTokens();\r\n        token.burn(token.balanceOf(this));\r\n        if (token.paused()) {\r\n            token.unpause();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Starting ICO\r\n     */\r\n    function startICO() public onlyOwner returns(bool) {\r\n        require(stages[0].start >= now);\r\n        require(requireOnce);\r\n        requireOnce = false;\r\n        state = true;\r\n        period = 0;\r\n        emit StartICO();\r\n        token.ownersTransfer(company, (uint)(300000000).mul(decimals));\r\n        token.ownersTransfer(founders_1, (uint)(300000000).mul(decimals));\r\n        token.ownersTransfer(founders_2, (uint)(50000000).mul(decimals));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Turning off the ICO\r\n     */\r\n    function stopICO() onlyOwner public returns(bool) {\r\n        state = false;\r\n        emit StopICO();\r\n        if (token.paused()) {\r\n            token.unpause();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        manualPause = true;\r\n        usersPause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        uint shift = now.sub(pauseDate);\r\n        dateMove(shift);\r\n        period = getStageId();\r\n        pausedByValue = false;\r\n        manualPause = false;\r\n        super.unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Withdrawal Etherium from smart-contract\r\n     */\r\n    function withDrawal() public onlyOwner {\r\n        if(!state && sumWei >= softcap) {\r\n            multisig.transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns stage id\r\n     */\r\n    function getStageId() public view returns(uint) {\r\n        uint stageId;\r\n        uint today = now;\r\n\r\n        if (today < stages[0].stop) {\r\n            stageId = 0;\r\n\r\n        } else if (today >= stages[1].start &&\r\n        today < stages[1].stop ) {\r\n            stageId = 1;\r\n\r\n        } else if (today >= stages[2].start &&\r\n        today < stages[2].stop ) {\r\n            stageId = 2;\r\n\r\n        } else if (today >= stages[3].start &&\r\n        today < stages[3].stop ) {\r\n            stageId = 3;\r\n\r\n        } else if (today >= stages[3].stop) {\r\n            stageId = 4;\r\n\r\n        } else {\r\n            return 5;\r\n        }\r\n\r\n        uint tempId = (stageId > period) ? stageId : period;\r\n        return tempId;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Limit of coins for the period and Number of coins taking\r\n     * into account the bonus for the period\r\n     */\r\n    function getStageData() public view returns(uint tempLimit, uint tempBonus) {\r\n        uint stageId = getStageId();\r\n        tempBonus = stages[stageId].bonus;\r\n\r\n        if (stageId == 0) {\r\n            tempLimit = stages[0].limit;\r\n\r\n        } else if (stageId == 1) {\r\n            tempLimit = (stages[0].limit).add(stages[1].limit);\r\n\r\n        } else if (stageId == 2) {\r\n            tempLimit = (stages[0].limit).add(stages[1].limit).add(stages[2].limit);\r\n\r\n        } else if (stageId == 3) {\r\n            tempLimit = (stages[0].limit).add(stages[1].limit).add(stages[2].limit).add(stages[3].limit);\r\n\r\n        } else {\r\n            tempLimit = token.balanceOf(this);\r\n            tempBonus = typicalBonus;\r\n            return;\r\n        }\r\n        tempLimit = tempLimit.sub(totalSold);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount for which you can redeem all tokens for the current period\r\n     */\r\n    function calculateStagePrice() public view returns(uint price) {\r\n        uint limit;\r\n        uint bonusCoefficient;\r\n        (limit, bonusCoefficient) = getStageData();\r\n\r\n        price = limit.mul(rate).mul(100).div(bonusCoefficient).div(decimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Sending tokens to the recipient, based on the amount of ether that it sent\r\n     * @param _etherValue uint Amount of sent ether\r\n     * @param _to address The address which you want to transfer to\r\n     */\r\n    function sendTokens(uint _etherValue, address _to) internal isUnderHardCap {\r\n        uint limit;\r\n        uint bonusCoefficient;\r\n        (limit, bonusCoefficient) = getStageData();\r\n        uint tokens = (_etherValue).mul(bonusCoefficient).mul(decimals).div(100);\r\n        tokens = tokens.div(rate);\r\n        bool needPause;\r\n\r\n        if (tokens > limit) {\r\n            needPause = true;\r\n            uint stageEther = calculateStagePrice();\r\n            period++;\r\n            if (period == 4) {\r\n                balances[msg.sender] = balances[msg.sender].add(stageEther);\r\n                sumWei = sumWei.add(stageEther);\r\n                token.ownersTransfer(_to, limit);\r\n                totalSold = totalSold.add(limit);\r\n                _to.transfer(_etherValue.sub(stageEther));\r\n                state = false;\r\n                return;\r\n            }\r\n            balances[msg.sender] = balances[msg.sender].add(stageEther);\r\n            sumWei = sumWei.add(stageEther);\r\n            token.ownersTransfer(_to, limit);\r\n            totalSold = totalSold.add(limit);\r\n            sendTokens(_etherValue.sub(stageEther), _to);\r\n\r\n        } else {\r\n            require(tokens <= token.balanceOf(this));\r\n            if (limit.sub(tokens) < 500) {\r\n                needPause = true;\r\n                period++;\r\n            }\r\n            balances[msg.sender] = balances[msg.sender].add(_etherValue);\r\n            sumWei = sumWei.add(_etherValue);\r\n            token.ownersTransfer(_to, tokens);\r\n            totalSold = totalSold.add(tokens);\r\n        }\r\n\r\n        if (needPause) {\r\n            pausedByValue = true;\r\n            usersPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev called by the contract to pause, triggers stopped state\r\n     */\r\n    function usersPause() private {\r\n        pauseDate = now;\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Moving date after the pause\r\n     * @param _shift uint Time in seconds\r\n     */\r\n    function dateMove(uint _shift) private returns(bool) {\r\n        require(_shift > 0);\r\n\r\n        uint i;\r\n\r\n        if (pausedByValue) {\r\n            stages[period].start = now;\r\n            stages[period].stop = (stages[period].start).add(stages[period].duration);\r\n\r\n            for (i = period + 1; i < 4; i++) {\r\n                stages[i].start = stages[i - 1].stop;\r\n                stages[i].stop = (stages[i].start).add(stages[i].duration);\r\n            }\r\n\r\n        } else {\r\n            if (manualPause) stages[period].stop = (stages[period].stop).add(_shift);\r\n\r\n            for (i = period + 1; i < 4; i++) {\r\n                stages[i].start = (stages[i].start).add(_shift);\r\n                stages[i].stop = (stages[i].stop).add(_shift);\r\n            }\r\n        }\r\n\r\n        emit DateMoved(_shift);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens available for sale\r\n     */\r\n    function tokensAmount() public view returns(uint) {\r\n        return token.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of supplied tokens\r\n     */\r\n    function tokensSupply() public view returns(uint) {\r\n        return token.totalSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Set start date\r\n     * @param _start uint Time start\r\n     */\r\n    function setStartDate(uint _start) public onlyOwner returns(bool) {\r\n        require(_start > now);\r\n        require(requireOnce);\r\n\r\n        stages[0].start = _start;\r\n        stages[0].stop = _start.add(stages[0].duration);\r\n        stages[1].start = stages[0].stop;\r\n        stages[1].stop = stages[1].start.add(stages[1].duration);\r\n        stages[2].start = stages[1].stop;\r\n        stages[2].stop = stages[2].start.add(stages[2].duration);\r\n        stages[3].start = stages[2].stop;\r\n        stages[3].stop = stages[3].start.add(stages[3].duration);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets new multisig address to which the received ether will be sent\r\n     * @param _to address\r\n     */\r\n    function setMultisig(address _to) public onlyOwner returns(bool) {\r\n        require(_to != address(0));\r\n        multisig = _to;\r\n        emit NewWalletAddress(_to);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Change first adress with reserve(300000000 tokens)\r\n     * @param _company address\r\n     */\r\n    function setReserveForCompany(address _company) public onlyOwner {\r\n        require(_company != address(0));\r\n        require(requireOnce);\r\n        company = _company;\r\n    }\r\n\r\n    /**\r\n     * @dev Change second adress with reserve(300000000 tokens)\r\n     * @param _founders_1 address\r\n     */\r\n    function setReserveForFoundersFirst(address _founders_1) public onlyOwner {\r\n        require(_founders_1 != address(0));\r\n        require(requireOnce);\r\n        founders_1 = _founders_1;\r\n    }\r\n\r\n    /**\r\n     * @dev Change third adress with reserve(50000000 tokens)\r\n     * @param _founders_2 address\r\n     */\r\n    function setReserveForFoundersSecond(address _founders_2) public onlyOwner {\r\n        require(_founders_2 != address(0));\r\n        require(requireOnce);\r\n        founders_2 = _founders_2;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"manualSendTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"founders_1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"founders_2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"company\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_founders_1\",\"type\":\"address\"}],\"name\":\"setReserveForFoundersFirst\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sumWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withDrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startICO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"setStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stages\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"stop\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"bonus\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStageId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_founders_2\",\"type\":\"address\"}],\"name\":\"setReserveForFoundersSecond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnUnsoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStageData\",\"outputs\":[{\"name\":\"tempLimit\",\"type\":\"uint256\"},{\"name\":\"tempBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBurned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopICO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateStagePrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requireOnce\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_company\",\"type\":\"address\"}],\"name\":\"setReserveForCompany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setMultisig\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_company\",\"type\":\"address\"},{\"name\":\"_founders_1\",\"type\":\"address\"},{\"name\":\"_founders_2\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StartICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StopICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BurnUnsoldTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"NewWalletAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DateMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002d966a9a4d88af10c0abafe3b7565bb8c2e1db5e0000000000000000000000002d966a9a4d88af10c0abafe3b7565bb8c2e1db5e0000000000000000000000002d966a9a4d88af10c0abafe3b7565bb8c2e1db5e000000000000000000000000df41d02dd21865d7d651aad3663de4186c8b763b","Library":"","SwarmSource":"bzzr://821a32d286a737df03f81c45dde21d50a8022af5e01677e2a792728c491ee057"}]}