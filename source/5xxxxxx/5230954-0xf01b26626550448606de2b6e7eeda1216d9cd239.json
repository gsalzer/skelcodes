{"status":"1","message":"OK","result":[{"SourceCode":"contract SHA3_512 {\r\n    function SHA3_512() public {}\r\n\r\n    function keccak_f(uint[25] A) pure internal returns(uint[25]) {\r\n        uint[5] memory C;\r\n        uint[5] memory D;\r\n        //uint x;\r\n        //uint y;\r\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\r\n        uint[25] memory B;\r\n\r\n        uint[24] memory RC= [\r\n                   uint(0x0000000000000001),\r\n                   0x0000000000008082,\r\n                   0x800000000000808A,\r\n                   0x8000000080008000,\r\n                   0x000000000000808B,\r\n                   0x0000000080000001,\r\n                   0x8000000080008081,\r\n                   0x8000000000008009,\r\n                   0x000000000000008A,\r\n                   0x0000000000000088,\r\n                   0x0000000080008009,\r\n                   0x000000008000000A,\r\n                   0x000000008000808B,\r\n                   0x800000000000008B,\r\n                   0x8000000000008089,\r\n                   0x8000000000008003,\r\n                   0x8000000000008002,\r\n                   0x8000000000000080,\r\n                   0x000000000000800A,\r\n                   0x800000008000000A,\r\n                   0x8000000080008081,\r\n                   0x8000000000008080,\r\n                   0x0000000080000001,\r\n                   0x8000000080008008 ];\r\n\r\n        for( uint i = 0 ; i < 24 ; i++ ) {\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];\r\n            }*/\r\n\r\n            C[0]=A[0]^A[1]^A[2]^A[3]^A[4];\r\n            C[1]=A[5]^A[6]^A[7]^A[8]^A[9];\r\n            C[2]=A[10]^A[11]^A[12]^A[13]^A[14];\r\n            C[3]=A[15]^A[16]^A[17]^A[18]^A[19];\r\n            C[4]=A[20]^A[21]^A[22]^A[23]^A[24];\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\r\n            }*/\r\n\r\n\r\n            D[0]=C[4] ^ ((C[1] * 2)&0xffffffffffffffff | (C[1] / (2 ** 63)));\r\n            D[1]=C[0] ^ ((C[2] * 2)&0xffffffffffffffff | (C[2] / (2 ** 63)));\r\n            D[2]=C[1] ^ ((C[3] * 2)&0xffffffffffffffff | (C[3] / (2 ** 63)));\r\n            D[3]=C[2] ^ ((C[4] * 2)&0xffffffffffffffff | (C[4] / (2 ** 63)));\r\n            D[4]=C[3] ^ ((C[0] * 2)&0xffffffffffffffff | (C[0] / (2 ** 63)));\r\n\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = A[5*x+y] ^ D[x];\r\n                }\r\n            }*/\r\n\r\n\r\n\r\n            A[0]=A[0] ^ D[0];\r\n            A[1]=A[1] ^ D[0];\r\n            A[2]=A[2] ^ D[0];\r\n            A[3]=A[3] ^ D[0];\r\n            A[4]=A[4] ^ D[0];\r\n            A[5]=A[5] ^ D[1];\r\n            A[6]=A[6] ^ D[1];\r\n            A[7]=A[7] ^ D[1];\r\n            A[8]=A[8] ^ D[1];\r\n            A[9]=A[9] ^ D[1];\r\n            A[10]=A[10] ^ D[2];\r\n            A[11]=A[11] ^ D[2];\r\n            A[12]=A[12] ^ D[2];\r\n            A[13]=A[13] ^ D[2];\r\n            A[14]=A[14] ^ D[2];\r\n            A[15]=A[15] ^ D[3];\r\n            A[16]=A[16] ^ D[3];\r\n            A[17]=A[17] ^ D[3];\r\n            A[18]=A[18] ^ D[3];\r\n            A[19]=A[19] ^ D[3];\r\n            A[20]=A[20] ^ D[4];\r\n            A[21]=A[21] ^ D[4];\r\n            A[22]=A[22] ^ D[4];\r\n            A[23]=A[23] ^ D[4];\r\n            A[24]=A[24] ^ D[4];\r\n\r\n            /*Rho and pi steps*/\r\n            B[0]=A[0];\r\n            B[8]=((A[1] * (2 ** 36))&0xffffffffffffffff | (A[1] / (2 ** 28)));\r\n            B[11]=((A[2] * (2 ** 3))&0xffffffffffffffff | (A[2] / (2 ** 61)));\r\n            B[19]=((A[3] * (2 ** 41))&0xffffffffffffffff | (A[3] / (2 ** 23)));\r\n            B[22]=((A[4] * (2 ** 18))&0xffffffffffffffff | (A[4] / (2 ** 46)));\r\n            B[2]=((A[5] * (2 ** 1))&0xffffffffffffffff | (A[5] / (2 ** 63)));\r\n            B[5]=((A[6] * (2 ** 44))&0xffffffffffffffff | (A[6] / (2 ** 20)));\r\n            B[13]=((A[7] * (2 ** 10))&0xffffffffffffffff | (A[7] / (2 ** 54)));\r\n            B[16]=((A[8] * (2 ** 45))&0xffffffffffffffff | (A[8] / (2 ** 19)));\r\n            B[24]=((A[9] * (2 ** 2))&0xffffffffffffffff | (A[9] / (2 ** 62)));\r\n            B[4]=((A[10] * (2 ** 62))&0xffffffffffffffff | (A[10] / (2 ** 2)));\r\n            B[7]=((A[11] * (2 ** 6))&0xffffffffffffffff | (A[11] / (2 ** 58)));\r\n            B[10]=((A[12] * (2 ** 43))&0xffffffffffffffff | (A[12] / (2 ** 21)));\r\n            B[18]=((A[13] * (2 ** 15))&0xffffffffffffffff | (A[13] / (2 ** 49)));\r\n            B[21]=((A[14] * (2 ** 61))&0xffffffffffffffff | (A[14] / (2 ** 3)));\r\n            B[1]=((A[15] * (2 ** 28))&0xffffffffffffffff | (A[15] / (2 ** 36)));\r\n            B[9]=((A[16] * (2 ** 55))&0xffffffffffffffff | (A[16] / (2 ** 9)));\r\n            B[12]=((A[17] * (2 ** 25))&0xffffffffffffffff | (A[17] / (2 ** 39)));\r\n            B[15]=((A[18] * (2 ** 21))&0xffffffffffffffff | (A[18] / (2 ** 43)));\r\n            B[23]=((A[19] * (2 ** 56))&0xffffffffffffffff | (A[19] / (2 ** 8)));\r\n            B[3]=((A[20] * (2 ** 27))&0xffffffffffffffff | (A[20] / (2 ** 37)));\r\n            B[6]=((A[21] * (2 ** 20))&0xffffffffffffffff | (A[21] / (2 ** 44)));\r\n            B[14]=((A[22] * (2 ** 39))&0xffffffffffffffff | (A[22] / (2 ** 25)));\r\n            B[17]=((A[23] * (2 ** 8))&0xffffffffffffffff | (A[23] / (2 ** 56)));\r\n            B[20]=((A[24] * (2 ** 14))&0xffffffffffffffff | (A[24] / (2 ** 50)));\r\n\r\n            /*Xi state*/\r\n            /*\r\n            for( x = 0 ; x < 5 ; x++ ) {\r\n                for( y = 0 ; y < 5 ; y++ ) {\r\n                    A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\r\n                }\r\n            }*/\r\n\r\n\r\n            A[0]=B[0]^((~B[5]) & B[10]);\r\n            A[1]=B[1]^((~B[6]) & B[11]);\r\n            A[2]=B[2]^((~B[7]) & B[12]);\r\n            A[3]=B[3]^((~B[8]) & B[13]);\r\n            A[4]=B[4]^((~B[9]) & B[14]);\r\n            A[5]=B[5]^((~B[10]) & B[15]);\r\n            A[6]=B[6]^((~B[11]) & B[16]);\r\n            A[7]=B[7]^((~B[12]) & B[17]);\r\n            A[8]=B[8]^((~B[13]) & B[18]);\r\n            A[9]=B[9]^((~B[14]) & B[19]);\r\n            A[10]=B[10]^((~B[15]) & B[20]);\r\n            A[11]=B[11]^((~B[16]) & B[21]);\r\n            A[12]=B[12]^((~B[17]) & B[22]);\r\n            A[13]=B[13]^((~B[18]) & B[23]);\r\n            A[14]=B[14]^((~B[19]) & B[24]);\r\n            A[15]=B[15]^((~B[20]) & B[0]);\r\n            A[16]=B[16]^((~B[21]) & B[1]);\r\n            A[17]=B[17]^((~B[22]) & B[2]);\r\n            A[18]=B[18]^((~B[23]) & B[3]);\r\n            A[19]=B[19]^((~B[24]) & B[4]);\r\n            A[20]=B[20]^((~B[0]) & B[5]);\r\n            A[21]=B[21]^((~B[1]) & B[6]);\r\n            A[22]=B[22]^((~B[2]) & B[7]);\r\n            A[23]=B[23]^((~B[3]) & B[8]);\r\n            A[24]=B[24]^((~B[4]) & B[9]);\r\n\r\n            /*Last step*/\r\n            A[0]=A[0]^RC[i];\r\n        }\r\n\r\n\r\n        return A;\r\n    }\r\n\r\n\r\n    function sponge(uint[9] M) pure internal returns(uint[16]) {\r\n        require( (M.length * 8) == 72 );\r\n        M[8] = 0x8000000000000001;\r\n\r\n        uint r = 72;\r\n        uint w = 8;\r\n        uint size = M.length * 8;\r\n\r\n        uint[25] memory S;\r\n        uint i; uint y; uint x;\r\n        /*Absorbing Phase*/\r\n        for( i = 0 ; i < size/r ; i++ ) {\r\n            for( y = 0 ; y < 5 ; y++ ) {\r\n                for( x = 0 ; x < 5 ; x++ ) {\r\n                    if( (x+5*y) < (r/w) ) {\r\n                        S[5*x+y] = S[5*x+y] ^ M[i*9 + x + 5*y];\r\n                    }\r\n                }\r\n            }\r\n            S = keccak_f(S);\r\n        }\r\n\r\n        /*Squeezing phase*/\r\n        uint[16] memory result;\r\n        uint b = 0;\r\n        while( b < 16 ) {\r\n            for( y = 0 ; y < 5 ; y++ ) {\r\n                for( x = 0 ; x < 5 ; x++ ) {\r\n                    if( (x+5*y)<(r/w) && (b<16) ) {\r\n                        result[b] = S[5*x+y] & 0xFFFFFFFF;\r\n                        result[b+1] = S[5*x+y] / 0x100000000;\r\n                        b+=2;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n   }\r\n\r\n   function hash(uint64[8] input) pure internal returns(uint32[16] output) {\r\n\r\n       uint i;\r\n       uint[9] memory M;\r\n       for(i = 0 ; i < 8 ; i++) {\r\n           M[i] = uint(input[i]);\r\n       }\r\n\r\n       uint[16] memory result = sponge(M);\r\n\r\n       for(i = 0 ; i < 16 ; i++) {\r\n           output[i] = uint32(result[i]);\r\n       }\r\n   }\r\n\r\n}\r\n\r\n\r\ncontract TeikhosBounty is SHA3_512 {\r\n\r\n    // Proof-of-public-key in format 2xbytes32, to support xor operator and ecrecover r, s v format\r\n    bytes32 proof_of_public_key1 = hex\"501802c3b21818b74a6a77b24a9eec140bd8c196712467135740c217a32ff17b\";\r\n    bytes32 proof_of_public_key2 = hex\"5a011cbd1416f0fa7f4a81f2c0f64bcafe06d8239a38b820a8efbef4abf11f20\";\r\n    \r\n    function authenticate(bytes _publicKey) public { // Accepts an array of bytes, for example [\"0x00\",\"0xaa\", \"0xff\"]\r\n\r\n        // Use SHA3_512 library to get a sha3_512 hash of public key\r\n\r\n        uint64[8] memory input;\r\n\r\n        // The evm is big endian, have to reverse the bytes\r\n\r\n        bytes memory reversed = new bytes(64);\r\n\r\n        for(uint i = 0; i < 64; i++) {\r\n            reversed[i] = _publicKey[63 - i];\r\n        }\r\n\r\n        for(i = 0; i < 8; i++) {\r\n            bytes8 oneEigth;\r\n            // Load 8 byte from reversed public key at position 32 + i * 8\r\n            assembly {\r\n                oneEigth := mload(add(reversed, add(32, mul(i, 8)))) \r\n            }\r\n            input[7 - i] = uint64(oneEigth);\r\n        }\r\n\r\n        uint32[16] memory output = hash(input);\r\n        \r\n        bytes memory reverseHash = new bytes(64);\r\n        \r\n        for(i = 0; i < 16; i++) {\r\n            bytes4 oneSixteenth = bytes4(output[15 - i]);\r\n            // Store 4 byte in keyHash at position 32 + i * 4\r\n            assembly { mstore(add(reverseHash, add(32, mul(i, 4))), oneSixteenth) }\r\n        }\r\n\r\n        bytes memory keyHash = new bytes(64);\r\n\r\n        for(i = 0; i < 64; i++) {\r\n            keyHash[i] = reverseHash[63 - i];\r\n        }\r\n\r\n        // Split hash of public key in 2xbytes32, to support xor operator and ecrecover r, s v format\r\n\r\n        bytes32 hash1;\r\n        bytes32 hash2;\r\n\r\n        assembly {\r\n        hash1 := mload(add(keyHash,0x20))\r\n        hash2 := mload(add(keyHash,0x40))\r\n        }\r\n\r\n        // Use xor (reverse cipher) to get signature in r, s v format\r\n        bytes32 r = proof_of_public_key1 ^ hash1;\r\n        bytes32 s = proof_of_public_key2 ^ hash2;\r\n\r\n        // Get msgHash for use with ecrecover\r\n        bytes32 msgHash = keccak256(\"\\x19Ethereum Signed Message:\\n64\", _publicKey);\r\n\r\n        // Get address from public key\r\n        address signer = address(keccak256(_publicKey));\r\n\r\n        // The value v is not known, try both 27 and 28\r\n        if(ecrecover(msgHash, 27, r, s) == signer) selfdestruct(msg.sender);\r\n        if(ecrecover(msgHash, 28, r, s) == signer) selfdestruct(msg.sender);\r\n    }\r\n    \r\n    function() public payable {}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_publicKey\",\"type\":\"bytes\"}],\"name\":\"authenticate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"TeikhosBounty","CompilerVersion":"v0.4.22-nightly.2018.3.8+commit.fbc29f6d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://eabda10ef5e3fea16246a9e312405f550dee42c06aebcbd109461197c34bd8de"}]}