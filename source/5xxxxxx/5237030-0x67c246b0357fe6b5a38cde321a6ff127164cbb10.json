{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// WARNING. The examples used in the formulas in the comments are the right formulas. However, they are not implemented like this to prevent overflows. \r\n// The formulas in the contract do work the same as in the comments. \r\n\r\n// NOTE: In part two of the contract, the DIVIDEND is explained. \r\n// The dividend has a very easy implementation\r\n// the price of the token rise when bought.\r\n// when it's sold, price will decrease with 50% of rate of price bought\r\n// if you sell, you will sell all tokens, and you have thus to buy in at higher price\r\n// make sure you hold dividend for a long time.\r\n\r\ncontract RobinHood{\r\n    // Owner of this contract\r\n    address public owner;\r\n    \r\n    // % of dev fee (can be set to 0,1,2,3,4,5 %);\r\n    uint8 devFee = 5;\r\n    // Users who want to create their own Robin Hood tower have to pay this. Can be reset to any value.\r\n    uint256 public amountToCreate = 20000000000000000;\r\n    \r\n    // If this is false, you cannot use the contract. It can be opened by owner. After that, it cannot be closed anymore.\r\n    // If it is not open, you cannot interact with the contract.\r\n    bool public open = false;\r\n    \r\n    event TowerCreated(uint256 id);\r\n    event TowerBought(uint256 id);\r\n    event TowerWon(uint256 id);\r\n\r\n    // Tower struct. \r\n    struct Tower{\r\n        //Timer in seconds: Base time for how long the new owner of the Tower has to wait until he can pay the amount.\r\n        uint32 timer; \r\n        // Timestamp: if this is 0, the contract does not run. If it runs it is set to the blockchain timestamp. \r\n        // If Timestamp + GetTime() > Blockchain timestamp the user will be paid out  by the person who tries to buy the tower OR the user can decide to buy himself.\r\n        uint256 timestamp;\r\n        // Payout of the amount in percent. Ranges from 0 - 10000. Here 0 is 0 % and 10000 is 100%.\r\n        // This percentage of amount is paid to owner of tower. \r\n        // The other part of amount stays in Tower and can be collected by new people.\r\n        // However, if the amount is larger or equal than the minPrice, the Tower will immediately change the timestamp and move on.\r\n        // This means that the owner of the tower does not change, and can possibly collect the amount more times, if no one buys!!\r\n        uint16 payout; \r\n        // Price increasate, ranged again from 0-10000 (0 = 0%, 10000 = 100%), which decides how much the price increases if someone buys the tower.\r\n        // Ex: 5000 means that if the price is 1 ETH and if someone buys it, then the new price is 1 * (1 + 5000/10000) = 1.5 ETH.\r\n        uint16 priceIncrease; // priceIncrease in percent (same)\r\n        // Price, which can be checked to see how much the tower costs. Initially set to minPrice.\r\n        uint256 price;\r\n        // Amount which the Tower has to pay to the owner.\r\n        uint256 amount; \r\n        // Min Price: the minimum price in wei. Is also the setting to make the contract move on if someone has been paid (if amount >= minPrice);\r\n        // The minimum price is 1 szabo, maximum price is 1 ether. Both are included in the range.\r\n        uint256 minPrice; \r\n        // If you create a contract (not developer) then you are allowed to set a fee which you will get from people who buy your Tower.\r\n        // Ranged again from 0 -> 10000,  but the maximum value is 2500 (25%) minimum is 0 (0%).\r\n        // Developer is not allowed to set creatorFee.\r\n        uint16 creatorFee; \r\n        // This is the amount, in wei, to set at which amount the time necessary to wait will reduce by half.\r\n        // If this is set to 0, this option is not allowed and the time delta is always the same.\r\n        // The minimum wait time is 5 minutes.\r\n        // The time to wait is calculated by: Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime)\r\n        uint256 amountToHalfTime; \r\n        // If someone wins, the price is reduced by this. The new price is calculated by:\r\n        // Tower.price = max(Tower.price * Tower.minPriceAfterWin/10000, Tower.minPrice);\r\n        // Again, this value is ranged from 0 (0%) to 10000 (100%), all values allowed.\r\n        // Note that price will always be the minimum price or higher.\r\n        // If this is set to 0, price will always be set back to new price.\r\n        // If it is set to 10000, the price will NOT change!\r\n        uint16 minPriceAfterWin; // also in percent. \r\n        // Address of the creator of this tower. Used to pay creatorFee. Developer will not receive creatorFee because his creatorFee is automatically set to 0.\r\n        address creator;\r\n        // The current owner of this Tower. If he owns it for longer than getTime() of this Tower, he will receive his portion of the amount in the Tower.\r\n        address owner;\r\n        // You can add a quote to troll your fellow friends. Hopefully they won't buy your tower!\r\n        string quote;\r\n    }\r\n    \r\n   \r\n    // Mapping of all towers, indexed by ID. Starting at 0. \r\n    mapping(uint256 => Tower) public Towers;\r\n    \r\n    // Take track of at what position we insert the Tower. \r\n    uint256 public next_tower_index=0;\r\n\r\n    // Check if contract is open. \r\n    // If value is send and contract is not open, it is reverted and you will get it back. \r\n    // Note that if contract is open it cannot be closed anymore.\r\n    modifier onlyOpen(){\r\n        if (open){\r\n            _;\r\n        }\r\n        else{\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    // Check if owner or if contract is open. This works for the AddTower function so owner (developer) can already add Towers. \r\n    // Note that if contract is open it cannot be closed anymore. \r\n    // If value is send it will be reverted if you are not owner or the contract is not open. \r\n    modifier onlyOpenOrOwner(){\r\n        if (open || msg.sender == owner){\r\n            _;\r\n        }\r\n        else{\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    // Functions only for owner (developer)\r\n    // If you send something to a owner function you will get your ethers back via revert. \r\n    modifier onlyOwner(){\r\n        if (msg.sender == owner){\r\n            _;\r\n        }\r\n        else{\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    \r\n    // Constructor. \r\n    // Setups 4 towers. \r\n    function RobinHood() public{\r\n        // Log contract developer\r\n        owner = msg.sender;\r\n    \r\n        \r\n        \r\n        // FIRST tower. (ID = 0)\r\n        // Robin Hood has to climb a tower!\r\n        // 10 minutes time range!\r\n        // 90% payout of the amount \r\n        // 30% price increase \r\n        // Timer halfs at 5 ETH. This is a lot, but realize that this high value is choosen because the timer cannot shrink to fast. \r\n        // At 5 ETH the limit is only 5 minutes, the minimum!\r\n        // Minimum price is 2 finney. \r\n        // Price reduces 90% (100% - 10%) after someone has won the tower!\r\n        // 0% creator fee. \r\n       \r\n       \r\n        AddTower(600, 9000, 3000, 5000000000000000000, 2000000000000000, 1000, 0);\r\n    \r\n    \r\n        // SECOND tower (ID = 1)\r\n        // Robin Hood has to search a house!\r\n        // 10 minutes tme range \r\n        // 50% payout \r\n        // 1.5% price increase \r\n        // Timer halfs at 2.5 ETH (also a lot, but at this time then timer is minimum (5 min))\r\n        // Price is 4 finney\r\n        // Price is reduced to 4 finney if won \r\n        // 0% fee \r\n        \r\n        AddTower(600, 5000,150 , 2500000000000000000, 4000000000000000, 0, 0);\r\n  \r\n        // THIRD tower. (ID = 2)\r\n        // Robin Hood has to explore a forest!\r\n        // 1 hour time range!\r\n        // 50% payout of the amount \r\n        // 10% price increase \r\n        // Timer halfs at 1 ETH. \r\n        // Minimum price is 5 finney. \r\n        // Price reduces 50% (100% - 50%) after someone has won the tower!\r\n        // 0% creator fee. \r\n        AddTower(3600, 5000, 1000, (1000000000000000000), 5000000000000000, 5000, 0);\r\n\r\n        // FOURTH tower. (ID = 3)\r\n        // Robin Hood has to cross a sea to an island!\r\n        // 1 day time range!\r\n        // 75% payout of the amount \r\n        // 20% price increase \r\n        // Timer halfs at 2 ETH.\r\n        // Minimum price is 10 finney. \r\n        // Price reduces 75% (100% - 25%) after someone has won the tower!\r\n        // 0% creator fee. \r\n        AddTower(86400, 7500, 2000, (2000000000000000000), 10000000000000000, 2500, 0);\r\n         \r\n\r\n  \r\n        // FIFTH tower (ID = 4)\r\n        // Robin Hood has to fly with a rocket to a nearby asteroid!\r\n        // 1 week time range!\r\n        // 75% payout of the amount \r\n        // 25% price increase \r\n        // Timer halfs at 2.5 ETH.\r\n        // Minimum price is 50 finney. \r\n        // Price reduces 100% (100% - 0%) after someone has won the tower!\r\n        // 0% creator fee. \r\n        AddTower(604800, 7500, 2500, (2500000000000000000), 50000000000000000, 0, 0);\r\n    }\r\n    \r\n    // Developer (owner) can open game \r\n    // Open can only be set true once, can never be set false again. \r\n    function OpenGame() public onlyOwner{\r\n        open = true;\r\n    }\r\n    \r\n    // Developer can change fee. \r\n    // DevFee is only a simple int, so can  be 0,1,2,3,4,5 \r\n    // Fee has to be less or equal to 5, otherwise it is reverted. \r\n    function ChangeFee(uint8 _fee) public onlyOwner{\r\n        require(_fee <= 5);\r\n        devFee = _fee;\r\n    }\r\n    \r\n    // Developer change amount price to add tower. \r\n    function ChangeAmountPrice(uint256 _newPrice) public onlyOwner{\r\n        amountToCreate = _newPrice;\r\n    }\r\n    \r\n    // Add Tower. Only possible if you are developer OR if contract is open. \r\n    // If you want to buy a tower, you have to pay amountToCreate (= wei) to developer. \r\n    // The default value is 0.02 ETH.\r\n    // You can check the price (in wei) either on site or by reading the contract on etherscan.\r\n    \r\n    // _timer: Timer in seconds for how long someone has to wait before he wins the tower. This is constant and will not be changed. \r\n    // If you set _amountToHalfTime to nonzero, getTimer will reduce less amounts (minimum 300 seconds, maximum _timer) from the formula Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime) \r\n    // _timer has to be between 300 seconds ( 5 minutes) and maximally 366 days (366*24*60*60) (which is maximally one year);\r\n    \r\n    //_payout: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Sets how much percentage of the Tower.amount is paid to Tower.owner if he wins. \r\n    // The rest of the amount of that tower which stays over will be kept inside the tower, up for a new round. \r\n    // If someone wins and amount is more than the minPrice, timestamp is set to the blockchain timer and new round is started without changing the owner of the Tower!\r\n    \r\n    // _priceIncrease: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Sets how much percentage the price will increase. Note that \"100%\" is always added. \r\n    // If you set it at 5000 (which is 50%) then the total increase of price is 150%. So if someone buys tower for price at 1 ETH, the new price is then 1.5 ETH. \r\n    \r\n    // _amountToHalfTime: number of Wei which sets how much Wei you need in order to reduce the time necessary to hold tower to win for 50%.\r\n    // Formula used is Tower.time * (Tower.amountToHalfTime / (Tower.amount + Tower.amountToHalfTime) to calculate the time necessary.\r\n    // If you set 0, then this formula is not used and Tower.time is always returned.\r\n    // Due to overflows the minimum amount (which is reasonable) is still 1/1000 finney. \r\n    // Do not make this number extremely high. \r\n    \r\n    // _minPrice: amount of Wei which the starting price of the Tower is. Minimum is 1/1000 finney, max is 1 ETH. \r\n    // This is also the check value to see if the round moves on after someone has won. If amount >= minPrice then the timestamp will be upgraded and a new round will start\r\n    // Of course that is after paying the owner of this tower. The owner of the tower does not change. He can win multiple times, in theory. \r\n    \r\n    // _minPriceAfterWin: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. After someone wins, the new price of the game is calculated.\r\n    // This is done by doing Tower.price * (Tower.minPriceAfterWin) / 10000; \r\n    // If Tower.price is now less than Tower.minPrice then the Tower.price will be set to Tower.minPrice.\r\n\r\n    // _creatorFee: number between 0-10000, is a pecent: 0% = 0, 100% = 10000. Maximum is 2500 (25%), with 2500 included. \r\n    // If you create a tower, you can set this value. If people pay the tower, then this percentage of the price is taken and is sent to you.\r\n    // The rest, after subtracting the dev fee, will be put into Tower.amount. \r\n    \r\n    function AddTower(uint32 _timer, uint16 _payout, uint16 _priceIncrease, uint256 _amountToHalfTime, uint256 _minPrice, uint16 _minPriceAfterWin, uint16 _creatorFee) public payable onlyOpenOrOwner returns (uint256) {\r\n        require (_timer >= 300); // Need at least 5 minutes\r\n        require (_timer <= 31622400);\r\n        require (_payout >= 0 && _payout <= 10000);\r\n        require (_priceIncrease >= 0 && _priceIncrease <= 10000);\r\n        require (_minPriceAfterWin >= 0 && _minPriceAfterWin <= 10000);\r\n       //amount to half time can be everything, but has to be 0 OR 1000000000000 due to division rules\r\n        require(_amountToHalfTime == 0 || _amountToHalfTime >= 1000000000000);\r\n        require(_creatorFee >= 0 && _creatorFee <= 2500);\r\n        require(_minPrice >= (1 szabo) && _minPrice <= (1 ether));\r\n        if (msg.sender == owner){\r\n            // If owner make sure creator fee is 0.\r\n            _creatorFee = 0;\r\n            if (msg.value > 0){\r\n                owner.transfer(msg.value);\r\n            }\r\n        }\r\n        else{\r\n            if (msg.value >= amountToCreate){\r\n                uint256 toDiv = (mul(amountToCreate, tokenDividend))/100;\r\n                uint256 left = sub(amountToCreate, toDiv);\r\n                owner.transfer(left);\r\n                addDividend(toDiv);\r\n                processBuyAmount(amountToCreate);\r\n            }\r\n            else{\r\n                revert(); // not enough ETH send.\r\n            }\r\n            uint256 diff = sub(msg.value, amountToCreate);\r\n            // If you send to much, you will get rest back.\r\n            // Might be case if amountToCreate is transferred and this is not seen. \r\n            if (diff >= 0){\r\n                msg.sender.transfer(diff);\r\n            }\r\n        }\r\n   \r\n        // Check latest values. \r\n\r\n        \r\n        // Create tower. \r\n        var NewTower = Tower(_timer, 0, _payout, _priceIncrease, _minPrice, 0, _minPrice, _creatorFee, _amountToHalfTime, _minPriceAfterWin, msg.sender, msg.sender, \"\");\r\n        \r\n        // Insert this into array. \r\n        Towers[next_tower_index] = NewTower;\r\n        \r\n        // Emit TowerCreated event. \r\n        emit TowerCreated(next_tower_index);\r\n        \r\n        // Upgrade index for next tower.\r\n        next_tower_index = add(next_tower_index, 1);\r\n        return (next_tower_index - 1);\r\n    }\r\n    \r\n    // getTimer of TowerID to see how much time (in seconds) you need to win that tower. \r\n    // only works if contract is open. \r\n    // id = tower id (note that \"first tower\" has ID 0 into the mapping)\r\n    function getTimer(uint256 _id) public onlyOpen returns (uint256)  {\r\n        require(_id < next_tower_index);\r\n        var UsedTower = Towers[_id];\r\n        //unsigned long long int pr =  totalPriceHalf/((total)/1000000000000+ totalPriceHalf/1000000000000);    \r\n        // No half time? Return tower.\r\n        if (UsedTower.amountToHalfTime == 0){\r\n            return UsedTower.timer;\r\n        }\r\n        \r\n        uint256 var2 = UsedTower.amountToHalfTime;\r\n        uint256 var3 = add(UsedTower.amount / 1000000000000, UsedTower.amountToHalfTime / 1000000000000);\r\n        \r\n        \r\n       if (var2 == 0 && var3 == 0){\r\n           // exception, both are zero!? Weird, return timer.\r\n           return UsedTower.timer;\r\n       }\r\n       \r\n\r\n       \r\n       uint256 target = (mul(UsedTower.timer, var2/var3 )/1000000000000);\r\n       \r\n       // Warning, if for some reason the calculation get super low, it will return 300, which is the absolute minimum.\r\n       //This prevents users from winning because people don't have enough time to edit gas, which would be unfair.\r\n       if (target < 300){\r\n           return 300;\r\n       }\r\n       \r\n       return target;\r\n    }\r\n    \r\n    // Internal payout function. \r\n    function Payout_intern(uint256 _id) internal {\r\n        //payout.\r\n        \r\n        var UsedTower = Towers[_id];\r\n        // Calculate how much has to be paid. \r\n        uint256 Paid = mul(UsedTower.amount, UsedTower.payout) / 10000;\r\n        \r\n        // Remove paid from amount. \r\n        UsedTower.amount = sub(UsedTower.amount, Paid);\r\n        \r\n        // Send this Paid amount to owner. \r\n        UsedTower.owner.transfer(Paid);\r\n        \r\n        // Calculate new price. \r\n        uint256 newPrice = (UsedTower.price * UsedTower.minPriceAfterWin)/10000;\r\n        \r\n        // Check if lower than minPrice; if yes, set it to minPrice. \r\n        if (newPrice < UsedTower.minPrice){\r\n            newPrice = UsedTower.minPrice;\r\n        }\r\n        \r\n        // Upgrade tower price. \r\n        UsedTower.price = newPrice;\r\n        \r\n         // Will we move on with game?\r\n        if (UsedTower.amount > UsedTower.minPrice){\r\n            // RESTART game. OWNER STAYS SAME \r\n            UsedTower.timestamp = block.timestamp;\r\n        }\r\n        else{\r\n            // amount too low. do not restart.\r\n            UsedTower.timestamp = 0;\r\n        }\r\n    \r\n        // Emit TowerWon event. \r\n        emit TowerWon(_id);\r\n    }\r\n    \r\n    \r\n    // TakePrize, can be called by everyone if contract is open.\r\n    // Usually owner of tower can call this. \r\n    // Note that if you are too late because someone else paid it, then this person will pay you. \r\n    // There is no way to cheat that.\r\n    // id = tower id. (id's start with 0, not 1!)\r\n    function TakePrize(uint256 _id) public onlyOpen{\r\n        require(_id < next_tower_index);\r\n        var UsedTower = Towers[_id];\r\n        require(UsedTower.timestamp > 0); // otherwise game has not started.\r\n        var Timing = getTimer(_id);\r\n        if (block.timestamp > (add(UsedTower.timestamp,  Timing))){\r\n            Payout_intern(_id);\r\n        }\r\n        else{\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    // Shoot the previous Robin Hood! \r\n    // If you want, you can also buy your own tower again. This might be used to extract leftovers into the amount. \r\n    \r\n    // _id = tower id   (starts at 0 for first tower);\r\n    // _quote is optional: you can upload a quote to troll your enemies.\r\n    function ShootRobinHood(uint256 _id, string _quote) public payable onlyOpen{\r\n        require(_id < next_tower_index);\r\n        var UsedTower = Towers[_id];\r\n        var Timing = getTimer(_id);\r\n    \r\n        // Check if game has started and if we are too late. If yes, we pay out and return. \r\n        if (UsedTower.timestamp != 0 && block.timestamp > (add(UsedTower.timestamp,  Timing))){\r\n            Payout_intern(_id);\r\n            // We will not buy, give tokens back. \r\n            if (msg.value > 0){\r\n                msg.sender.transfer(msg.value);\r\n            }\r\n            return;\r\n        }\r\n        \r\n        // Check if enough price. \r\n        require(msg.value >= UsedTower.price);\r\n        // Tower can still be bought, great. \r\n        \r\n        uint256 devFee_used = (mul( UsedTower.price, 5))/100;\r\n        uint256 creatorFee = (mul(UsedTower.creatorFee, UsedTower.price)) / 10000;\r\n        uint256 divFee = (mul(UsedTower.price,  tokenDividend)) / 100;\r\n        \r\n        // Add dividend\r\n        addDividend(divFee);\r\n        // Buy div tokens \r\n        processBuyAmount(UsedTower.price);\r\n        \r\n        // Calculate what we put into amount (ToPay)\r\n        \r\n        uint256 ToPay = sub(sub(UsedTower.price, devFee_used), creatorFee);\r\n        \r\n        //Pay creator the creator fee. \r\n        uint256 diff = sub(msg.value, UsedTower.price);\r\n        if (creatorFee != 0){\r\n            UsedTower.creator.transfer(creatorFee);\r\n        }\r\n        // Did you send too much? Get back difference. \r\n        if (diff > 0){\r\n            msg.sender.transfer(diff); \r\n        }\r\n        \r\n        // Pay dev. \r\n        owner.transfer(devFee_used);\r\n        \r\n        // Change results. \r\n        // Set timestamp to current time. \r\n        UsedTower.timestamp = block.timestamp;\r\n        // Set you as owner \r\n        UsedTower.owner = msg.sender;\r\n        // Set (or reset) quote \r\n        UsedTower.quote = _quote;\r\n        // Add ToPay to amount, which you can earn if you win. \r\n        UsedTower.amount = add(UsedTower.amount, sub(ToPay, divFee));\r\n        // Upgrade price of tower\r\n        UsedTower.price = (UsedTower.price * (10000 + UsedTower.priceIncrease)) / 10000;\r\n        \r\n        // Emit TowerBought event \r\n        emit TowerBought(_id);\r\n    }\r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    // Not interesting, safe math functions\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      if (a == 0) {\r\n         return 0;\r\n      }\r\n      uint256 c = a * b;\r\n      assert(c / a == b);\r\n      return c;\r\n   }\r\n\r\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n      uint256 c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n      return c;\r\n   }\r\n\r\n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      assert(b <= a);\r\n      return a - b;\r\n   }\r\n\r\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      uint256 c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n   }\r\n    \r\n    \r\n    // START OF DIVIDEND PART\r\n\r\n\r\n    // total number of tokens\r\n    uint256 public numTokens;\r\n    // amount of dividend in pool \r\n    uint256 public ethDividendAmount;\r\n    // 15 szabo start price per token \r\n    uint256 constant public tokenStartPrice = 1000000000000;\r\n    // 1 szabo increase per token \r\n    uint256 constant public tokenIncrease = 100000000000;\r\n    \r\n    // token price tracker. \r\n    uint256 public tokenPrice = tokenStartPrice;\r\n    \r\n    // percentage token dividend \r\n    uint8 constant public tokenDividend = 5;\r\n    \r\n    // token scale factor to make sure math is correct.\r\n    uint256 constant public tokenScaleFactor = 1000;\r\n    \r\n    // address link to how much token that address has \r\n    mapping(address => uint256) public tokensPerAddress;\r\n    //mapping(address => uint256) public payments;\r\n    \r\n    \r\n    // add dividend to pool\r\n    function addDividend(uint256 amt) internal {\r\n        ethDividendAmount = ethDividendAmount + amt;\r\n    }\r\n    \r\n    // get how much tokens you get for amount \r\n    // bah area calculation results in a quadratic equation\r\n    // i hate square roots in solidity\r\n    function getNumTokens(uint256 amt) internal  returns (uint256){\r\n        uint256 a = tokenIncrease;\r\n        uint256 b = 2*tokenPrice - tokenIncrease;\r\n      //  var c = -2*amt;\r\n        uint256 D = b*b + 8*a*amt;\r\n        uint256 sqrtD = tokenScaleFactor*sqrt(D);\r\n        //uint256 (sqrtD - b) / (2*a);\r\n        return (sqrtD - (b * tokenScaleFactor)) / (2*a);\r\n    }\r\n    \r\n    // buy tokens, only being called from robinhood. \r\n    function processBuyAmount(uint256 amt) internal {\r\n        uint256 tokens = getNumTokens(amt );\r\n        tokensPerAddress[msg.sender] = add(tokensPerAddress[msg.sender], tokens);\r\n\r\n        \r\n        numTokens = add(numTokens, tokens);\r\n        //uint256 tokens_normscale = tokens;\r\n        //pushuint(tokens);\r\n        \r\n        // check new price.\r\n        \r\n        //tokenPrice = tokenPrice + (( (tokens * tokens ) + tokens) / 2) * tokenIncrease;\r\n        \r\n       tokenPrice = add(tokenPrice , ((mul(tokenIncrease, tokens))/tokenScaleFactor));\r\n\r\n    }\r\n    \r\n    // sell ALL your tokens to claim your dividend \r\n    function sellTokens() public {\r\n        uint256 tokens = tokensPerAddress[msg.sender];\r\n        if (tokens > 0 && numTokens >= tokens){\r\n            // get amount of tokens: \r\n            uint256 usetk = numTokens;\r\n            uint256 amt = 0;\r\n            if (numTokens > 0){\r\n             amt = (mul(tokens, ethDividendAmount))/numTokens ;\r\n            }\r\n            if (numTokens < tokens){\r\n                usetk = tokens;\r\n            }\r\n            \r\n            // update price. \r\n            \r\n            uint256 nPrice = (sub(tokenPrice, ((mul(tokenIncrease, tokens))/ (2*tokenScaleFactor)))) ;\r\n            \r\n            if (nPrice < tokenStartPrice){\r\n                nPrice = tokenStartPrice;\r\n            }\r\n            tokenPrice = nPrice; \r\n            \r\n            // update tokens \r\n            \r\n            tokensPerAddress[msg.sender] = 0; \r\n            \r\n            // update total tokens \r\n            \r\n            if (tokens <= numTokens){\r\n                numTokens = numTokens - tokens; \r\n            }\r\n            else{\r\n                numTokens = 0;\r\n            }\r\n            \r\n            \r\n            // update dividend \r\n            \r\n            if (amt <= ethDividendAmount){\r\n                ethDividendAmount = ethDividendAmount - amt;\r\n            }\r\n            else{\r\n                ethDividendAmount = 0;\r\n            }\r\n            \r\n            // pay \r\n            \r\n            if (amt > 0){\r\n                msg.sender.transfer(amt);\r\n            }\r\n        }\r\n    }\r\n    \r\n    // square root function, taken from ethereum stack exchange \r\n    function sqrt(uint x) internal returns (uint y) {\r\n    uint z = (x + 1) / 2;\r\n    y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokenStartPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"OpenGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint8\"}],\"name\":\"ChangeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"TakePrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"next_tower_index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensPerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenIncrease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Towers\",\"outputs\":[{\"name\":\"timer\",\"type\":\"uint32\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint16\"},{\"name\":\"priceIncrease\",\"type\":\"uint16\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"minPrice\",\"type\":\"uint256\"},{\"name\":\"creatorFee\",\"type\":\"uint16\"},{\"name\":\"amountToHalfTime\",\"type\":\"uint256\"},{\"name\":\"minPriceAfterWin\",\"type\":\"uint16\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"quote\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_quote\",\"type\":\"string\"}],\"name\":\"ShootRobinHood\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountToCreate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenScaleFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timer\",\"type\":\"uint32\"},{\"name\":\"_payout\",\"type\":\"uint16\"},{\"name\":\"_priceIncrease\",\"type\":\"uint16\"},{\"name\":\"_amountToHalfTime\",\"type\":\"uint256\"},{\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"name\":\"_minPriceAfterWin\",\"type\":\"uint16\"},{\"name\":\"_creatorFee\",\"type\":\"uint16\"}],\"name\":\"AddTower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethDividendAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"ChangeAmountPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"open\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TowerCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TowerBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TowerWon\",\"type\":\"event\"}]","ContractName":"RobinHood","CompilerVersion":"v0.4.22-nightly.2018.3.8+commit.fbc29f6d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://09af4c5de919570344b713e8903628b3c7e2e335ed1ecb83a97a730af059c5b6"}]}