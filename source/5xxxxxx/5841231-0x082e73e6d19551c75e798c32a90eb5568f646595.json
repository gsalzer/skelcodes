{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Interface {\r\n     function totalSupply() public constant returns (uint);\r\n     function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n     function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n     function transfer(address to, uint tokens) public returns (bool success);\r\n     function approve(address spender, uint tokens) public returns (bool success);\r\n     function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n     function mint(address from, address to, uint tokens) public;\r\n     event Transfer(address indexed from, address indexed to, uint tokens);\r\n     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\ncontract AdvertisementContract {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    struct Advertisement {\r\n      address advertiser;\r\n      uint advertisementId;\r\n      string advertisementLink;\r\n      uint amountToBePaid;\r\n      //Voter[] voterList;\r\n      bool isUnlocked;    \r\n    }\r\n\r\n    struct Voter {\r\n      address publicKey;\r\n      uint amountEarned;  \r\n    }\r\n    \r\n    \r\n    struct VoteAdvertisementPayoutScheme {\r\n      uint voterPercentage; \r\n      uint systemPercentage;  \r\n    }\r\n    \r\n    // The token that would be sold using this contract \r\n    ERC20Interface public token;\r\n    //Objects for use within program\r\n    \r\n    VoteAdvertisementPayoutScheme voteAdvertismentPayoutSchemeObj;\r\n    Advertisement advertisement;\r\n    Voter voter;\r\n    uint counter = 0;\r\n    address public wallet;\r\n    \r\n    mapping (uint=>Voter[]) advertisementVoterList;\r\n    \r\n    mapping (uint=>Advertisement) advertisementList;\r\n    \r\n    uint localIntAsPerNeed;\r\n    address localAddressAsPerNeed;\r\n    Voter[] voters;\r\n   \r\n    constructor(address _wallet,address _tokenAddress) public {\r\n      wallet = _wallet;\r\n      token = ERC20Interface(_tokenAddress);\r\n      setup();\r\n    }\r\n        \r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n    \r\n   \r\n    function setup() internal {\r\n        voteAdvertismentPayoutSchemeObj = VoteAdvertisementPayoutScheme({voterPercentage: 79, systemPercentage: 21});\r\n    }\r\n    \r\n    function uploadAdvertisement(uint adId,string advLink, address advertiserAddress, uint uploadTokenAmount) public\r\n    {\r\n        require(msg.sender == wallet);\r\n        token.mint(advertiserAddress,wallet,uploadTokenAmount*10**18);    //tokens deducted from advertiser's wallet\r\n        advertisement = Advertisement({\r\n            advertiser : advertiserAddress,\r\n            advertisementId : adId,\r\n            advertisementLink : advLink,\r\n            amountToBePaid : uploadTokenAmount*10**18,\r\n            isUnlocked : false\r\n        });\r\n        advertisementList[adId] = advertisement;\r\n    }\r\n    \r\n    function AdvertisementPayout (uint advId) public\r\n    {\r\n        require(msg.sender == wallet);\r\n        require(token.balanceOf(wallet)>=advertisementList[advId].amountToBePaid);\r\n        require(advertisementList[advId].advertisementId == advId);\r\n        require(advertisementList[advId].isUnlocked == true);\r\n        require(advertisementList[advId].amountToBePaid > 0);\r\n        uint j = 0;\r\n        \r\n        //calculating voters payout\r\n        voters = advertisementVoterList[advertisementList[advId].advertisementId];\r\n        localIntAsPerNeed = voteAdvertismentPayoutSchemeObj.voterPercentage;\r\n        uint voterPayout = advertisementList[advId].amountToBePaid.mul(localIntAsPerNeed);\r\n        voterPayout = voterPayout.div(100);\r\n        uint perVoterPayout = voterPayout.div(voters.length);\r\n        \r\n        //calculating system payout\r\n        localIntAsPerNeed = voteAdvertismentPayoutSchemeObj.systemPercentage;\r\n        uint systemPayout = advertisementList[advId].amountToBePaid.mul(localIntAsPerNeed);\r\n        systemPayout = systemPayout.div(100);\r\n        \r\n        \r\n        //doing voter payout\r\n        for (j=0;j<voters.length;j++)\r\n        {\r\n            token.mint(wallet,voters[j].publicKey,perVoterPayout);\r\n            voters[j].amountEarned = voters[j].amountEarned.add(perVoterPayout);\r\n            advertisementList[advId].amountToBePaid = advertisementList[advId].amountToBePaid.sub(perVoterPayout);\r\n        }\r\n        //logString(\"Voter payout done\");\r\n        \r\n        //catering for system payout (not trnasferring tokens as the wallet is where all tokens are already)\r\n        advertisementList[advId].amountToBePaid = advertisementList[advId].amountToBePaid.sub(systemPayout);\r\n        //logString(\"System payout done\");     \r\n                 \r\n        require(advertisementList[advId].amountToBePaid == 0);\r\n                \r\n    }\r\n    \r\n   function VoteAdvertisement(uint adId, address voterPublicKey) public \r\n   {\r\n        require(advertisementList[adId].advertisementId == adId);\r\n        require(advertisementList[adId].isUnlocked == false);\r\n        //logString(\"advertisement found\");\r\n        voter = Voter({publicKey: voterPublicKey, amountEarned : 0});\r\n        advertisementVoterList[adId].push(voter);\r\n        //logString(\"Vote added\");\r\n    }\r\n    function unlockAdvertisement(uint adId) public\r\n    {\r\n        require(msg.sender == wallet);\r\n        require(advertisementList[adId].advertisementId == adId);\r\n        advertisementList[adId].isUnlocked = true;\r\n    }\r\n    function getTokenBalance() public constant returns (uint) {\r\n        return token.balanceOf(msg.sender);\r\n    }\r\n\r\n    function changeWalletAddress(address newWallet) public  \r\n    {\r\n        require(msg.sender == wallet);\r\n        wallet = newWallet;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"adId\",\"type\":\"uint256\"}],\"name\":\"unlockAdvertisement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adId\",\"type\":\"uint256\"},{\"name\":\"advLink\",\"type\":\"string\"},{\"name\":\"advertiserAddress\",\"type\":\"address\"},{\"name\":\"uploadTokenAmount\",\"type\":\"uint256\"}],\"name\":\"uploadAdvertisement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adId\",\"type\":\"uint256\"},{\"name\":\"voterPublicKey\",\"type\":\"address\"}],\"name\":\"VoteAdvertisement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"changeWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"advId\",\"type\":\"uint256\"}],\"name\":\"AdvertisementPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"AdvertisementContract","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000310ec7780d07ae2caafc01545e5b824275167b54000000000000000000000000b1d43457ad3bb176ddf19d12282ca38063ed2e32","Library":"","SwarmSource":"bzzr://c1b73f5003c76d5d497b78e3ae1f0f3d61dba6d4cb70e726cad9b07c099ea72e"}]}