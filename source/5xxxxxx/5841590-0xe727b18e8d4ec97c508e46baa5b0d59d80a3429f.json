{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ncontract IWhitelist {\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n}\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n/*\r\n    Contract Features interface\r\n*/\r\ncontract IContractFeatures {\r\n    function isSupported(address _contract, uint256 _features) public view returns (bool);\r\n    function enableFeatures(uint256 _features, bool _enable) public;\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n/*\r\n    Bancor Converter interface\r\n*/\r\ncontract IBancorConverter {\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function conversionWhitelist() public view returns (IWhitelist) {}\r\n    // deprecated, backward compatibility\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n}\r\n\r\n/*\r\n    Bancor converter dedicated interface\r\n*/\r\ncontract IBancorConverterExtended is IBancorConverter, IOwned {\r\n    function token() public view returns (ISmartToken) {}\r\n    function quickBuyPath(uint256 _index) public view returns (IERC20Token) { _index; }\r\n    function maxConversionFee() public view returns (uint32) {}\r\n    function conversionFee() public view returns (uint32) {}\r\n    function connectorTokenCount() public view returns (uint16);\r\n    function reserveTokenCount() public view returns (uint16);\r\n    function connectorTokens(uint256 _index) public view returns (IERC20Token) { _index; }\r\n    function reserveTokens(uint256 _index) public view returns (IERC20Token) { _index; }\r\n    function setConversionWhitelist(IWhitelist _whitelist) public;\r\n    function getQuickBuyPathLength() public view returns (uint256);\r\n    function transferTokenOwnership(address _newOwner) public;\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n    function acceptTokenOwnership() public;\r\n    function transferManagement(address _newManager) public;\r\n    function acceptManagement() public;\r\n    function setConversionFee(uint32 _conversionFee) public;\r\n    function setQuickBuyPath(IERC20Token[] _path) public;\r\n    function addConnector(IERC20Token _token, uint32 _weight, bool _enableVirtualBalance) public;\r\n    function updateConnector(IERC20Token _connectorToken, uint32 _weight, bool _enableVirtualBalance, uint256 _virtualBalance) public;\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view returns (uint256);\r\n    function getReserveBalance(IERC20Token _reserveToken) public view returns (uint256);\r\n    function connectors(address _address) public view returns (\r\n        uint256 virtualBalance, \r\n        uint32 weight, \r\n        bool isVirtualBalanceEnabled, \r\n        bool isPurchaseEnabled, \r\n        bool isSet\r\n    );\r\n    function reserves(address _address) public view returns (\r\n        uint256 virtualBalance, \r\n        uint32 weight, \r\n        bool isVirtualBalanceEnabled, \r\n        bool isPurchaseEnabled, \r\n        bool isSet\r\n    );\r\n}\r\n\r\n/*\r\n    Bancor Converter Factory interface\r\n*/\r\ncontract IBancorConverterFactory {\r\n    function createConverter(\r\n        ISmartToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee,\r\n        IERC20Token _connectorToken,\r\n        uint32 _connectorWeight\r\n    )\r\n    public returns (address);\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still needs to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n/**\r\n    Id definitions for bancor contracts\r\n\r\n    Can be used in conjunction with the contract registry to get contract addresses\r\n*/\r\ncontract ContractIds {\r\n    // generic\r\n    bytes32 public constant CONTRACT_FEATURES = \"ContractFeatures\";\r\n\r\n    // bancor logic\r\n    bytes32 public constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 public constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 public constant BANCOR_GAS_PRICE_LIMIT = \"BancorGasPriceLimit\";\r\n    bytes32 public constant BANCOR_CONVERTER_FACTORY = \"BancorConverterFactory\";\r\n}\r\n\r\n/**\r\n    Id definitions for bancor contract features\r\n\r\n    Can be used to query the ContractFeatures contract to check whether a certain feature is supported by a contract\r\n*/\r\ncontract FeatureIds {\r\n    // converter features\r\n    uint256 public constant CONVERTER_CONVERSION_WHITELIST = 1 << 0;\r\n}\r\n\r\n/*\r\n    Bancor Converter Upgrader\r\n\r\n    The Bancor converter upgrader contract allows upgrading an older Bancor converter\r\n    contract (0.4 and up) to the latest version.\r\n    To begin the upgrade process, first transfer the converter ownership to the upgrader\r\n    contract and then call the upgrade function.\r\n    At the end of the process, the ownership of the newly upgraded converter will be transferred\r\n    back to the original owner.\r\n    The address of the new converter is available in the ConverterUpgrade event.\r\n*/\r\ncontract BancorConverterUpgrader is Owned, ContractIds, FeatureIds {\r\n    string public version = '0.3';\r\n\r\n    IContractRegistry public registry;                      // contract registry contract address\r\n\r\n    // triggered when the contract accept a converter ownership\r\n    event ConverterOwned(address indexed _converter, address indexed _owner);\r\n    // triggered when the upgrading process is done\r\n    event ConverterUpgrade(address indexed _oldConverter, address indexed _newConverter);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    constructor(IContractRegistry _registry) public {\r\n        registry = _registry;\r\n    }\r\n\r\n    /*\r\n        @dev allows the owner to update the contract registry contract address\r\n\r\n        @param _registry   address of a contract registry contract\r\n    */\r\n    function setRegistry(IContractRegistry _registry) public ownerOnly {\r\n        registry = _registry;\r\n    }\r\n\r\n    /**\r\n        @dev upgrade an old converter to the latest version\r\n        will throw if ownership wasn't transferred to the upgrader before calling this function.\r\n        ownership of the new converter will be transferred back to the original owner.\r\n        fires the ConverterUpgrade event upon success.\r\n\r\n        @param _oldConverter   old converter contract address\r\n        @param _version        old converter version\r\n    */\r\n    function upgrade(IBancorConverterExtended _oldConverter, bytes32 _version) public {\r\n        bool formerVersions = false;\r\n        if (_version == \"0.4\")\r\n            formerVersions = true;\r\n        acceptConverterOwnership(_oldConverter);\r\n        IBancorConverterExtended newConverter = createConverter(_oldConverter);\r\n        copyConnectors(_oldConverter, newConverter, formerVersions);\r\n        copyConversionFee(_oldConverter, newConverter);\r\n        copyQuickBuyPath(_oldConverter, newConverter);\r\n        transferConnectorsBalances(_oldConverter, newConverter, formerVersions);                \r\n        ISmartToken token = _oldConverter.token();\r\n\r\n        if (token.owner() == address(_oldConverter)) {\r\n            _oldConverter.transferTokenOwnership(newConverter);\r\n            newConverter.acceptTokenOwnership();\r\n        }\r\n\r\n        _oldConverter.transferOwnership(msg.sender);\r\n        newConverter.transferOwnership(msg.sender);\r\n        newConverter.transferManagement(msg.sender);\r\n\r\n        emit ConverterUpgrade(address(_oldConverter), address(newConverter));\r\n    }\r\n\r\n    /**\r\n        @dev the first step when upgrading a converter is to transfer the ownership to the local contract.\r\n        the upgrader contract then needs to accept the ownership transfer before initiating\r\n        the upgrade process.\r\n        fires the ConverterOwned event upon success\r\n\r\n        @param _oldConverter       converter to accept ownership of\r\n    */\r\n    function acceptConverterOwnership(IBancorConverterExtended _oldConverter) private {\r\n        require(msg.sender == _oldConverter.owner());\r\n        _oldConverter.acceptOwnership();\r\n        emit ConverterOwned(_oldConverter, this);\r\n    }\r\n\r\n    /**\r\n        @dev creates a new converter with same basic data as the original old converter\r\n        the newly created converter will have no connectors at this step.\r\n\r\n        @param _oldConverter    old converter contract address\r\n\r\n        @return the new converter  new converter contract address\r\n    */\r\n    function createConverter(IBancorConverterExtended _oldConverter) private returns(IBancorConverterExtended) {\r\n        IWhitelist whitelist;\r\n        ISmartToken token = _oldConverter.token();\r\n        uint32 maxConversionFee = _oldConverter.maxConversionFee();\r\n\r\n        IBancorConverterFactory converterFactory = IBancorConverterFactory(registry.addressOf(ContractIds.BANCOR_CONVERTER_FACTORY));\r\n        address converterAdderess  = converterFactory.createConverter(\r\n            token,\r\n            registry,\r\n            maxConversionFee,\r\n            IERC20Token(address(0)),\r\n            0\r\n        );\r\n\r\n        IBancorConverterExtended converter = IBancorConverterExtended(converterAdderess);\r\n        converter.acceptOwnership();\r\n        converter.acceptManagement();\r\n\r\n        // get the contract features address from the registry\r\n        IContractFeatures features = IContractFeatures(registry.addressOf(ContractIds.CONTRACT_FEATURES));\r\n\r\n        if (features.isSupported(_oldConverter, FeatureIds.CONVERTER_CONVERSION_WHITELIST)) {\r\n            whitelist = _oldConverter.conversionWhitelist();\r\n            if (whitelist != address(0))\r\n                converter.setConversionWhitelist(whitelist);\r\n        }\r\n\r\n        return converter;\r\n    }\r\n\r\n    /**\r\n        @dev copies the connectors from the old converter to the new one.\r\n        note that this will not work for an unlimited number of connectors due to block gas limit constraints.\r\n\r\n        @param _oldConverter    old converter contract address\r\n        @param _newConverter    new converter contract address\r\n        @param _isLegacyVersion true if the converter version is under 0.5\r\n    */\r\n    function copyConnectors(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter, bool _isLegacyVersion)\r\n        private\r\n    {\r\n        uint256 virtualBalance;\r\n        uint32 weight;\r\n        bool isVirtualBalanceEnabled;\r\n        bool isPurchaseEnabled;\r\n        bool isSet;\r\n        uint16 connectorTokenCount = _isLegacyVersion ? _oldConverter.reserveTokenCount() : _oldConverter.connectorTokenCount();\r\n\r\n        for (uint16 i = 0; i < connectorTokenCount; i++) {\r\n            address connectorAddress = _isLegacyVersion ? _oldConverter.reserveTokens(i) : _oldConverter.connectorTokens(i);\r\n            (virtualBalance, weight, isVirtualBalanceEnabled, isPurchaseEnabled, isSet) = readConnector(\r\n                _oldConverter,\r\n                connectorAddress,\r\n                _isLegacyVersion\r\n            );\r\n\r\n            IERC20Token connectorToken = IERC20Token(connectorAddress);\r\n            _newConverter.addConnector(connectorToken, weight, isVirtualBalanceEnabled);\r\n\r\n            if (isVirtualBalanceEnabled)\r\n                _newConverter.updateConnector(connectorToken, weight, isVirtualBalanceEnabled, virtualBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev copies the conversion fee from the old converter to the new one\r\n\r\n        @param _oldConverter    old converter contract address\r\n        @param _newConverter    new converter contract address\r\n    */\r\n    function copyConversionFee(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter) private {\r\n        uint32 conversionFee = _oldConverter.conversionFee();\r\n        _newConverter.setConversionFee(conversionFee);\r\n    }\r\n\r\n    /**\r\n        @dev copies the quick buy path from the old converter to the new one\r\n\r\n        @param _oldConverter    old converter contract address\r\n        @param _newConverter    new converter contract address\r\n    */\r\n    function copyQuickBuyPath(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter) private {\r\n        uint256 quickBuyPathLength = _oldConverter.getQuickBuyPathLength();\r\n        if (quickBuyPathLength <= 0)\r\n            return;\r\n\r\n        IERC20Token[] memory path = new IERC20Token[](quickBuyPathLength);\r\n        for (uint256 i = 0; i < quickBuyPathLength; i++) {\r\n            path[i] = _oldConverter.quickBuyPath(i);\r\n        }\r\n\r\n        _newConverter.setQuickBuyPath(path);\r\n    }\r\n\r\n    /**\r\n        @dev transfers the balance of each connector in the old converter to the new one.\r\n        note that the function assumes that the new converter already has the exact same number of\r\n        also, this will not work for an unlimited number of connectors due to block gas limit constraints.\r\n\r\n        @param _oldConverter    old converter contract address\r\n        @param _newConverter    new converter contract address\r\n        @param _isLegacyVersion true if the converter version is under 0.5\r\n    */\r\n    function transferConnectorsBalances(IBancorConverterExtended _oldConverter, IBancorConverterExtended _newConverter, bool _isLegacyVersion)\r\n        private\r\n    {\r\n        uint256 connectorBalance;\r\n        uint16 connectorTokenCount = _isLegacyVersion ? _oldConverter.reserveTokenCount() : _oldConverter.connectorTokenCount();\r\n\r\n        for (uint16 i = 0; i < connectorTokenCount; i++) {\r\n            address connectorAddress = _isLegacyVersion ? _oldConverter.reserveTokens(i) : _oldConverter.connectorTokens(i);\r\n            IERC20Token connector = IERC20Token(connectorAddress);\r\n            connectorBalance = connector.balanceOf(_oldConverter);\r\n            _oldConverter.withdrawTokens(connector, address(_newConverter), connectorBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev returns the connector settings\r\n\r\n        @param _converter       old converter contract address\r\n        @param _address         connector's address to read from\r\n        @param _isLegacyVersion true if the converter version is under 0.5\r\n\r\n        @return connector's settings\r\n    */\r\n    function readConnector(IBancorConverterExtended _converter, address _address, bool _isLegacyVersion) \r\n        private\r\n        view\r\n        returns(uint256 virtualBalance, uint32 weight, bool isVirtualBalanceEnabled, bool isPurchaseEnabled, bool isSet)\r\n    {\r\n        return _isLegacyVersion ? _converter.reserves(_address) : _converter.connectors(_address);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_CONVERTER_FACTORY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_FORMULA\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_FEATURES\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_NETWORK\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_GAS_PRICE_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONVERTER_CONVERSION_WHITELIST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldConverter\",\"type\":\"address\"},{\"name\":\"_version\",\"type\":\"bytes32\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ConverterOwned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldConverter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newConverter\",\"type\":\"address\"}],\"name\":\"ConverterUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"BancorConverterUpgrader","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"0000000000000000000000007148b1c9154bcf273a2c7d7b90e3edc6fee395e6","Library":"","SwarmSource":"bzzr://cc69c11beea1575763487d7a578ea090499145cd1d350c28afcc2b9951dca5e1"}]}