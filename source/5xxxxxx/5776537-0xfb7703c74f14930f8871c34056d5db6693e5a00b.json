{"status":"1","message":"OK","result":[{"SourceCode":"//v1.0.14\r\n//License: Apache2.0\r\npragma solidity ^0.4.21;\r\n\r\nlibrary IexecLib\r\n{\r\n\t/***************************************************************************/\r\n\t/*                              Market Order                               */\r\n\t/***************************************************************************/\r\n\tenum MarketOrderDirectionEnum\r\n\t{\r\n\t\tUNSET,\r\n\t\tBID,\r\n\t\tASK,\r\n\t\tCLOSED\r\n\t}\r\n\tstruct MarketOrder\r\n\t{\r\n\t\tMarketOrderDirectionEnum direction;\r\n\t\tuint256 category;        // runtime selection\r\n\t\tuint256 trust;           // for PoCo\r\n\t\tuint256 value;           // value/cost/price\r\n\t\tuint256 volume;          // quantity of instances (total)\r\n\t\tuint256 remaining;       // remaining instances\r\n\t\taddress workerpool;      // BID can use null for any\r\n\t\taddress workerpoolOwner; // fix ownership if workerpool ownership change during the workorder steps\r\n\t}\r\n\r\n\t/***************************************************************************/\r\n\t/*                               Work Order                                */\r\n\t/***************************************************************************/\r\n\tenum WorkOrderStatusEnum\r\n\t{\r\n\t\tUNSET,     // Work order not yet initialized (invalid address)\r\n\t\tACTIVE,    // Marketed → constributions are open\r\n\t\tREVEALING, // Starting consensus reveal\r\n\t\tCLAIMED,   // failed consensus\r\n\t\tCOMPLETED  // Concensus achieved\r\n\t}\r\n\r\n\t/***************************************************************************/\r\n\t/*                                Consensus                                */\r\n\t/*                                   ---                                   */\r\n\t/*                         used in WorkerPool.sol                          */\r\n\t/***************************************************************************/\r\n\tstruct Consensus\r\n\t{\r\n\t\tuint256 poolReward;\r\n\t\tuint256 stakeAmount;\r\n\t\tbytes32 consensus;\r\n\t\tuint256 revealDate;\r\n\t\tuint256 revealCounter;\r\n\t\tuint256 consensusTimeout;\r\n\t\tuint256 winnerCount;\r\n\t\taddress[] contributors;\r\n\t\taddress workerpoolOwner;\r\n\t\tuint256 schedulerRewardRatioPolicy;\r\n\r\n\t}\r\n\r\n\t/***************************************************************************/\r\n\t/*                              Contribution                               */\r\n\t/*                                   ---                                   */\r\n\t/*                         used in WorkerPool.sol                          */\r\n\t/***************************************************************************/\r\n\tenum ContributionStatusEnum\r\n\t{\r\n\t\tUNSET,\r\n\t\tAUTHORIZED,\r\n\t\tCONTRIBUTED,\r\n\t\tPROVED,\r\n\t\tREJECTED\r\n\t}\r\n\tstruct Contribution\r\n\t{\r\n\t\tContributionStatusEnum status;\r\n\t\tbytes32 resultHash;\r\n\t\tbytes32 resultSign;\r\n\t\taddress enclaveChallenge;\r\n\t\tuint256 score;\r\n\t\tuint256 weight;\r\n\t}\r\n\r\n\t/***************************************************************************/\r\n\t/*                Account / ContributionHistory / Category                 */\r\n\t/*                                   ---                                   */\r\n\t/*                          used in IexecHub.sol                           */\r\n\t/***************************************************************************/\r\n\tstruct Account\r\n\t{\r\n\t\tuint256 stake;\r\n\t\tuint256 locked;\r\n\t}\r\n\r\n\tstruct ContributionHistory // for credibility computation, f = failed/total\r\n\t{\r\n\t\tuint256 success;\r\n\t\tuint256 failed;\r\n\t}\r\n\r\n\tstruct Category\r\n\t{\r\n\t\tuint256 catid;\r\n\t\tstring  name;\r\n\t\tstring  description;\r\n\t\tuint256 workClockTimeRef;\r\n\t}\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract TokenSpender {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n * last open zepplin version used for : add sub mul div function : https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n* commit : https://github.com/OpenZeppelin/zeppelin-solidity/commit/815d9e1f457f57cfbb1b4e889f2255c9a517f661\r\n */\r\nlibrary SafeMathOZ\r\n{\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tif (a == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn a >= b ? a : b;\r\n\t}\r\n\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn a < b ? a : b;\r\n\t}\r\n\r\n\tfunction mulByFraction(uint256 a, uint256 b, uint256 c) internal pure returns (uint256)\r\n\t{\r\n\t\treturn div(mul(a, b), c);\r\n\t}\r\n\r\n\tfunction percentage(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn mulByFraction(a, b, 100);\r\n\t}\r\n\t// Source : https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\r\n\tfunction log(uint x) internal pure returns (uint y)\r\n\t{\r\n\t\tassembly\r\n\t\t{\r\n\t\t\tlet arg := x\r\n\t\t\tx := sub(x,1)\r\n\t\t\tx := or(x, div(x, 0x02))\r\n\t\t\tx := or(x, div(x, 0x04))\r\n\t\t\tx := or(x, div(x, 0x10))\r\n\t\t\tx := or(x, div(x, 0x100))\r\n\t\t\tx := or(x, div(x, 0x10000))\r\n\t\t\tx := or(x, div(x, 0x100000000))\r\n\t\t\tx := or(x, div(x, 0x10000000000000000))\r\n\t\t\tx := or(x, div(x, 0x100000000000000000000000000000000))\r\n\t\t\tx := add(x, 1)\r\n\t\t\tlet m := mload(0x40)\r\n\t\t\tmstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\r\n\t\t\tmstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\r\n\t\t\tmstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\r\n\t\t\tmstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\r\n\t\t\tmstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\r\n\t\t\tmstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\r\n\t\t\tmstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\r\n\t\t\tmstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\r\n\t\t\tmstore(0x40, add(m, 0x100))\r\n\t\t\tlet magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\r\n\t\t\tlet shift := 0x100000000000000000000000000000000000000000000000000000000000000\r\n\t\t\tlet a := div(mul(x, magic), shift)\r\n\t\t\ty := div(mload(add(m,sub(255,a))), shift)\r\n\t\t\ty := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract OwnableOZ\r\n{\r\n\taddress public m_owner;\r\n\tbool    public m_changeable;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner()\r\n\t{\r\n\t\trequire(msg.sender == m_owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction OwnableOZ() public\r\n\t{\r\n\t\tm_owner      = msg.sender;\r\n\t\tm_changeable = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param _newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction setImmutableOwnership(address _newOwner) public onlyOwner\r\n\t{\r\n\t\trequire(m_changeable);\r\n\t\trequire(_newOwner != address(0));\r\n\t\temit OwnershipTransferred(m_owner, _newOwner);\r\n\t\tm_owner      = _newOwner;\r\n\t\tm_changeable = false;\r\n\t}\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract RLC is ERC20, SafeMath, Ownable {\r\n\r\n    /* Public variables of the token */\r\n  string public name;       //fancy name\r\n  string public symbol;\r\n  uint8 public decimals;    //How many decimals to show.\r\n  string public version = 'v0.1';\r\n  uint public initialSupply;\r\n  uint public totalSupply;\r\n  bool public locked;\r\n  //uint public unlockBlock;\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  // lock transfer during the ICO\r\n  modifier onlyUnlocked() {\r\n    if (msg.sender != owner && locked) throw;\r\n    _;\r\n  }\r\n\r\n  /*\r\n   *  The RLC Token created with the time at which the crowdsale end\r\n   */\r\n\r\n  function RLC() {\r\n    // lock the transfer function during the crowdsale\r\n    locked = true;\r\n    //unlockBlock=  now + 45 days; // (testnet) - for mainnet put the block number\r\n\r\n    initialSupply = 87000000000000000;\r\n    totalSupply = initialSupply;\r\n    balances[msg.sender] = initialSupply;// Give the creator all initial tokens\r\n    name = 'iEx.ec Network Token';        // Set the name for display purposes\r\n    symbol = 'RLC';                       // Set the symbol for display purposes\r\n    decimals = 9;                        // Amount of decimals for display purposes\r\n  }\r\n\r\n  function unlock() onlyOwner {\r\n    locked = false;\r\n  }\r\n\r\n  function burn(uint256 _value) returns (bool){\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\r\n    totalSupply = safeSub(totalSupply, _value);\r\n    Transfer(msg.sender, 0x0, _value);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyUnlocked returns (bool) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n    /* Approve and then comunicate the approved contract in a single tx */\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData){\r\n      TokenSpender spender = TokenSpender(_spender);\r\n      if (approve(_spender, _value)) {\r\n          spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n      }\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract IexecHubInterface\r\n{\r\n\tRLC public rlc;\r\n\r\n\tfunction attachContracts(\r\n\t\taddress _tokenAddress,\r\n\t\taddress _marketplaceAddress,\r\n\t\taddress _workerPoolHubAddress,\r\n\t\taddress _appHubAddress,\r\n\t\taddress _datasetHubAddress)\r\n\t\tpublic;\r\n\r\n\tfunction setCategoriesCreator(\r\n\t\taddress _categoriesCreator)\r\n\tpublic;\r\n\r\n\tfunction createCategory(\r\n\t\tstring  _name,\r\n\t\tstring  _description,\r\n\t\tuint256 _workClockTimeRef)\r\n\tpublic returns (uint256 catid);\r\n\r\n\tfunction createWorkerPool(\r\n\t\tstring  _description,\r\n\t\tuint256 _subscriptionLockStakePolicy,\r\n\t\tuint256 _subscriptionMinimumStakePolicy,\r\n\t\tuint256 _subscriptionMinimumScorePolicy)\r\n\texternal returns (address createdWorkerPool);\r\n\r\n\tfunction createApp(\r\n\t\tstring  _appName,\r\n\t\tuint256 _appPrice,\r\n\t\tstring  _appParams)\r\n\texternal returns (address createdApp);\r\n\r\n\tfunction createDataset(\r\n\t\tstring  _datasetName,\r\n\t\tuint256 _datasetPrice,\r\n\t\tstring  _datasetParams)\r\n\texternal returns (address createdDataset);\r\n\r\n\tfunction buyForWorkOrder(\r\n\t\tuint256 _marketorderIdx,\r\n\t\taddress _workerpool,\r\n\t\taddress _app,\r\n\t\taddress _dataset,\r\n\t\tstring  _params,\r\n\t\taddress _callback,\r\n\t\taddress _beneficiary)\r\n\texternal returns (address);\r\n\r\n\tfunction isWoidRegistred(\r\n\t\taddress _woid)\r\n\tpublic view returns (bool);\r\n\r\n\tfunction lockWorkOrderCost(\r\n\t\taddress _requester,\r\n\t\taddress _workerpool, // Address of a smartcontract\r\n\t\taddress _app,        // Address of a smartcontract\r\n\t\taddress _dataset)    // Address of a smartcontract\r\n\tinternal returns (uint256);\r\n\r\n\tfunction claimFailedConsensus(\r\n\t\taddress _woid)\r\n\tpublic returns (bool);\r\n\r\n\tfunction finalizeWorkOrder(\r\n\t\taddress _woid,\r\n\t\tstring  _stdout,\r\n\t\tstring  _stderr,\r\n\t\tstring  _uri)\r\n\tpublic returns (bool);\r\n\r\n\tfunction getCategoryWorkClockTimeRef(\r\n\t\tuint256 _catId)\r\n\tpublic view returns (uint256 workClockTimeRef);\r\n\r\n\tfunction existingCategory(\r\n\t\tuint256 _catId)\r\n\tpublic view  returns (bool categoryExist);\r\n\r\n\tfunction getCategory(\r\n\t\tuint256 _catId)\r\n\t\tpublic view returns (uint256 catid, string name, string  description, uint256 workClockTimeRef);\r\n\r\n\tfunction getWorkerStatus(\r\n\t\taddress _worker)\r\n\tpublic view returns (address workerPool, uint256 workerScore);\r\n\r\n\tfunction getWorkerScore(address _worker) public view returns (uint256 workerScore);\r\n\r\n\tfunction registerToPool(address _worker) public returns (bool subscribed);\r\n\r\n\tfunction unregisterFromPool(address _worker) public returns (bool unsubscribed);\r\n\r\n\tfunction evictWorker(address _worker) public returns (bool unsubscribed);\r\n\r\n\tfunction removeWorker(address _workerpool, address _worker) internal returns (bool unsubscribed);\r\n\r\n\tfunction lockForOrder(address _user, uint256 _amount) public returns (bool);\r\n\r\n\tfunction unlockForOrder(address _user, uint256 _amount) public returns (bool);\r\n\r\n\tfunction lockForWork(address _woid, address _user, uint256 _amount) public returns (bool);\r\n\r\n\tfunction unlockForWork(address _woid, address _user, uint256 _amount) public returns (bool);\r\n\r\n\tfunction rewardForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public returns (bool);\r\n\r\n\tfunction seizeForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public returns (bool);\r\n\r\n\tfunction deposit(uint256 _amount) external returns (bool);\r\n\r\n\tfunction withdraw(uint256 _amount) external returns (bool);\r\n\r\n\tfunction checkBalance(address _owner) public view returns (uint256 stake, uint256 locked);\r\n\r\n\tfunction reward(address _user, uint256 _amount) internal returns (bool);\r\n\r\n\tfunction seize(address _user, uint256 _amount) internal returns (bool);\r\n\r\n\tfunction lock(address _user, uint256 _amount) internal returns (bool);\r\n\r\n\tfunction unlock(address _user, uint256 _amount) internal returns (bool);\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract IexecHubAccessor\r\n{\r\n\tIexecHubInterface internal iexecHubInterface;\r\n\r\n\tmodifier onlyIexecHub()\r\n\t{\r\n\t\trequire(msg.sender == address(iexecHubInterface));\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction IexecHubAccessor(address _iexecHubAddress) public\r\n\t{\r\n\t\trequire(_iexecHubAddress != address(0));\r\n\t\tiexecHubInterface = IexecHubInterface(_iexecHubAddress);\r\n\t}\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract MarketplaceInterface\r\n{\r\n\tfunction createMarketOrder(\r\n\t\tIexecLib.MarketOrderDirectionEnum _direction,\r\n\t\tuint256 _category,\r\n\t\tuint256 _trust,\r\n\t\tuint256 _value,\r\n\t\taddress _workerpool,\r\n\t\tuint256 _volume)\r\n\tpublic returns (uint);\r\n\r\n\tfunction closeMarketOrder(\r\n\t\tuint256 _marketorderIdx)\r\n\tpublic returns (bool);\r\n\r\n\tfunction getMarketOrderValue(\r\n\t\tuint256 _marketorderIdx)\r\n\tpublic view returns(uint256);\r\n\r\n\tfunction getMarketOrderWorkerpoolOwner(\r\n\t\tuint256 _marketorderIdx)\r\n\tpublic view returns(address);\r\n\r\n\tfunction getMarketOrderCategory(\r\n\t\tuint256 _marketorderIdx)\r\n\tpublic view returns (uint256);\r\n\r\n\tfunction getMarketOrderTrust(\r\n\t\tuint256 _marketorderIdx)\r\n\tpublic view returns(uint256);\r\n\r\n\tfunction getMarketOrder(\r\n\t\tuint256 _marketorderIdx)\r\n\tpublic view returns(\r\n\t\tIexecLib.MarketOrderDirectionEnum direction,\r\n\t\tuint256 category,       // runtime selection\r\n\t\tuint256 trust,          // for PoCo\r\n\t\tuint256 value,          // value/cost/price\r\n\t\tuint256 volume,         // quantity of instances (total)\r\n\t\tuint256 remaining,      // remaining instances\r\n\t\taddress workerpool);    // BID can use null for any\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract MarketplaceAccessor\r\n{\r\n\taddress              internal marketplaceAddress;\r\n\tMarketplaceInterface internal marketplaceInterface;\r\n/* not used\r\n\tmodifier onlyMarketplace()\r\n\t{\r\n\t\trequire(msg.sender == marketplaceAddress);\r\n\t\t_;\r\n\t}*/\r\n\r\n\tfunction MarketplaceAccessor(address _marketplaceAddress) public\r\n\t{\r\n\t\trequire(_marketplaceAddress != address(0));\r\n\t\tmarketplaceAddress   = _marketplaceAddress;\r\n\t\tmarketplaceInterface = MarketplaceInterface(_marketplaceAddress);\r\n\t}\r\n}\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract WorkOrder\r\n{\r\n\r\n\r\n\tevent WorkOrderActivated();\r\n\tevent WorkOrderReActivated();\r\n\tevent WorkOrderRevealing();\r\n\tevent WorkOrderClaimed  ();\r\n\tevent WorkOrderCompleted();\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tIexecLib.WorkOrderStatusEnum public m_status;\r\n\r\n\tuint256 public m_marketorderIdx;\r\n\r\n\taddress public m_app;\r\n\taddress public m_dataset;\r\n\taddress public m_workerpool;\r\n\taddress public m_requester;\r\n\r\n\tuint256 public m_emitcost;\r\n\tstring  public m_params;\r\n\taddress public m_callback;\r\n\taddress public m_beneficiary;\r\n\r\n\tbytes32 public m_resultCallbackProof;\r\n\tstring  public m_stdout;\r\n\tstring  public m_stderr;\r\n\tstring  public m_uri;\r\n\r\n\taddress public m_iexecHubAddress;\r\n\r\n\tmodifier onlyIexecHub()\r\n\t{\r\n\t\trequire(msg.sender == m_iexecHubAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction WorkOrder(\r\n\t\tuint256 _marketorderIdx,\r\n\t\taddress _requester,\r\n\t\taddress _app,\r\n\t\taddress _dataset,\r\n\t\taddress _workerpool,\r\n\t\tuint256 _emitcost,\r\n\t\tstring  _params,\r\n\t\taddress _callback,\r\n\t\taddress _beneficiary)\r\n\tpublic\r\n\t{\r\n\t\tm_iexecHubAddress = msg.sender;\r\n\t\trequire(_requester != address(0));\r\n\t\tm_status         = IexecLib.WorkOrderStatusEnum.ACTIVE;\r\n\t\tm_marketorderIdx = _marketorderIdx;\r\n\t\tm_app            = _app;\r\n\t\tm_dataset        = _dataset;\r\n\t\tm_workerpool     = _workerpool;\r\n\t\tm_requester      = _requester;\r\n\t\tm_emitcost       = _emitcost;\r\n\t\tm_params         = _params;\r\n\t\tm_callback       = _callback;\r\n\t\tm_beneficiary    = _beneficiary;\r\n\t\t// needed for the scheduler to authorize api token access on this m_beneficiary address in case _requester is a smart contract.\r\n\t}\r\n\r\n\tfunction startRevealingPhase() public returns (bool)\r\n\t{\r\n\t\trequire(m_workerpool == msg.sender);\r\n\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.ACTIVE);\r\n\t\tm_status = IexecLib.WorkOrderStatusEnum.REVEALING;\r\n\t\temit WorkOrderRevealing();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction reActivate() public returns (bool)\r\n\t{\r\n\t\trequire(m_workerpool == msg.sender);\r\n\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\r\n\t\tm_status = IexecLib.WorkOrderStatusEnum.ACTIVE;\r\n\t\temit WorkOrderReActivated();\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction claim() public onlyIexecHub\r\n\t{\r\n\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.ACTIVE || m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\r\n\t\tm_status = IexecLib.WorkOrderStatusEnum.CLAIMED;\r\n\t\temit WorkOrderClaimed();\r\n\t}\r\n\r\n\r\n\tfunction setResult(string _stdout, string _stderr, string _uri) public onlyIexecHub\r\n\t{\r\n\t\trequire(m_status == IexecLib.WorkOrderStatusEnum.REVEALING);\r\n\t\tm_status = IexecLib.WorkOrderStatusEnum.COMPLETED;\r\n\t\tm_stdout = _stdout;\r\n\t\tm_stderr = _stderr;\r\n\t\tm_uri    = _uri;\r\n\t\tm_resultCallbackProof =keccak256(_stdout,_stderr,_uri);\r\n\t\temit WorkOrderCompleted();\r\n\t}\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract App is OwnableOZ, IexecHubAccessor\r\n{\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tstring        public m_appName;\r\n\tuint256       public m_appPrice;\r\n\tstring        public m_appParams;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction App(\r\n\t\taddress _iexecHubAddress,\r\n\t\tstring  _appName,\r\n\t\tuint256 _appPrice,\r\n\t\tstring  _appParams)\r\n\tIexecHubAccessor(_iexecHubAddress)\r\n\tpublic\r\n\t{\r\n\t\t// tx.origin == owner\r\n\t\t// msg.sender == DatasetHub\r\n\t\trequire(tx.origin != msg.sender);\r\n\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\r\n\r\n\t\tm_appName   = _appName;\r\n\t\tm_appPrice  = _appPrice;\r\n\t\tm_appParams = _appParams;\r\n\r\n\t}\r\n\r\n\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract AppHub is OwnableOZ // is Owned by IexecHub\r\n{\r\n\r\n\tusing SafeMathOZ for uint256;\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tmapping(address => uint256)                     m_appCountByOwner;\r\n\tmapping(address => mapping(uint256 => address)) m_appByOwnerByIndex;\r\n\tmapping(address => bool)                        m_appRegistered;\r\n\r\n\tmapping(uint256 => address)                     m_appByIndex;\r\n\tuint256 public                                  m_totalAppCount;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction AppHub() public\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Methods\r\n\t */\r\n\tfunction isAppRegistered(address _app) public view returns (bool)\r\n\t{\r\n\t\treturn m_appRegistered[_app];\r\n\t}\r\n\tfunction getAppsCount(address _owner) public view returns (uint256)\r\n\t{\r\n\t\treturn m_appCountByOwner[_owner];\r\n\t}\r\n\tfunction getApp(address _owner, uint256 _index) public view returns (address)\r\n\t{\r\n\t\treturn m_appByOwnerByIndex[_owner][_index];\r\n\t}\r\n\tfunction getAppByIndex(uint256 _index) public view returns (address)\r\n\t{\r\n\t\treturn m_appByIndex[_index];\r\n\t}\r\n\r\n\tfunction addApp(address _owner, address _app) internal\r\n\t{\r\n\t\tuint id = m_appCountByOwner[_owner].add(1);\r\n\t\tm_totalAppCount=m_totalAppCount.add(1);\r\n\t\tm_appByIndex       [m_totalAppCount] = _app;\r\n\t\tm_appCountByOwner  [_owner]          = id;\r\n\t\tm_appByOwnerByIndex[_owner][id]      = _app;\r\n\t\tm_appRegistered    [_app]            = true;\r\n\t}\r\n\r\n\tfunction createApp(\r\n\t\tstring  _appName,\r\n\t\tuint256 _appPrice,\r\n\t\tstring  _appParams)\r\n\tpublic onlyOwner /*owner == IexecHub*/ returns (address createdApp)\r\n\t{\r\n\t\t// tx.origin == owner\r\n\t\t// msg.sender == IexecHub\r\n\t\taddress newApp = new App(\r\n\t\t\tmsg.sender,\r\n\t\t\t_appName,\r\n\t\t\t_appPrice,\r\n\t\t\t_appParams\r\n\t\t);\r\n\t\taddApp(tx.origin, newApp);\r\n\t\treturn newApp;\r\n\t}\r\n\r\n}\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract Dataset is OwnableOZ, IexecHubAccessor\r\n{\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tstring            public m_datasetName;\r\n\tuint256           public m_datasetPrice;\r\n\tstring            public m_datasetParams;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction Dataset(\r\n\t\taddress _iexecHubAddress,\r\n\t\tstring  _datasetName,\r\n\t\tuint256 _datasetPrice,\r\n\t\tstring  _datasetParams)\r\n\tIexecHubAccessor(_iexecHubAddress)\r\n\tpublic\r\n\t{\r\n\t\t// tx.origin == owner\r\n\t\t// msg.sender == DatasetHub\r\n\t\trequire(tx.origin != msg.sender);\r\n\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\r\n\r\n\t\tm_datasetName   = _datasetName;\r\n\t\tm_datasetPrice  = _datasetPrice;\r\n\t\tm_datasetParams = _datasetParams;\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract DatasetHub is OwnableOZ // is Owned by IexecHub\r\n{\r\n\tusing SafeMathOZ for uint256;\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tmapping(address => uint256)                     m_datasetCountByOwner;\r\n\tmapping(address => mapping(uint256 => address)) m_datasetByOwnerByIndex;\r\n\tmapping(address => bool)                        m_datasetRegistered;\r\n\r\n\tmapping(uint256 => address)                     m_datasetByIndex;\r\n\tuint256 public                                  m_totalDatasetCount;\r\n\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction DatasetHub() public\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Methods\r\n\t */\r\n\tfunction isDatasetRegistred(address _dataset) public view returns (bool)\r\n\t{\r\n\t\treturn m_datasetRegistered[_dataset];\r\n\t}\r\n\tfunction getDatasetsCount(address _owner) public view returns (uint256)\r\n\t{\r\n\t\treturn m_datasetCountByOwner[_owner];\r\n\t}\r\n\tfunction getDataset(address _owner, uint256 _index) public view returns (address)\r\n\t{\r\n\t\treturn m_datasetByOwnerByIndex[_owner][_index];\r\n\t}\r\n\tfunction getDatasetByIndex(uint256 _index) public view returns (address)\r\n\t{\r\n\t\treturn m_datasetByIndex[_index];\r\n\t}\r\n\r\n\tfunction addDataset(address _owner, address _dataset) internal\r\n\t{\r\n\t\tuint id = m_datasetCountByOwner[_owner].add(1);\r\n\t\tm_totalDatasetCount = m_totalDatasetCount.add(1);\r\n\t\tm_datasetByIndex       [m_totalDatasetCount] = _dataset;\r\n\t\tm_datasetCountByOwner  [_owner]              = id;\r\n\t\tm_datasetByOwnerByIndex[_owner][id]          = _dataset;\r\n\t\tm_datasetRegistered    [_dataset]            = true;\r\n\t}\r\n\r\n\tfunction createDataset(\r\n\t\tstring _datasetName,\r\n\t\tuint256 _datasetPrice,\r\n\t\tstring _datasetParams)\r\n\tpublic onlyOwner /*owner == IexecHub*/ returns (address createdDataset)\r\n\t{\r\n\t\t// tx.origin == owner\r\n\t\t// msg.sender == IexecHub\r\n\t\taddress newDataset = new Dataset(\r\n\t\t\tmsg.sender,\r\n\t\t\t_datasetName,\r\n\t\t\t_datasetPrice,\r\n\t\t\t_datasetParams\r\n\t\t);\r\n\t\taddDataset(tx.origin, newDataset);\r\n\t\treturn newDataset;\r\n\t}\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract WorkerPoolHub is OwnableOZ // is Owned by IexecHub\r\n{\r\n\r\n\tusing SafeMathOZ for uint256;\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\t// worker => workerPool\r\n\tmapping(address => address)                     m_workerAffectation;\r\n\t// owner => index\r\n\tmapping(address => uint256)                     m_workerPoolCountByOwner;\r\n\t// owner => index => workerPool\r\n\tmapping(address => mapping(uint256 => address)) m_workerPoolByOwnerByIndex;\r\n\t//  workerPool => owner // stored in the workerPool\r\n\t/* mapping(address => address)                     m_ownerByWorkerPool; */\r\n\tmapping(address => bool)                        m_workerPoolRegistered;\r\n\r\n\tmapping(uint256 => address)                     m_workerPoolByIndex;\r\n\tuint256 public                                  m_totalWorkerPoolCount;\r\n\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction WorkerPoolHub() public\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Methods\r\n\t */\r\n\tfunction isWorkerPoolRegistered(address _workerPool) public view returns (bool)\r\n\t{\r\n\t\treturn m_workerPoolRegistered[_workerPool];\r\n\t}\r\n\tfunction getWorkerPoolsCount(address _owner) public view returns (uint256)\r\n\t{\r\n\t\treturn m_workerPoolCountByOwner[_owner];\r\n\t}\r\n\tfunction getWorkerPool(address _owner, uint256 _index) public view returns (address)\r\n\t{\r\n\t\treturn m_workerPoolByOwnerByIndex[_owner][_index];\r\n\t}\r\n\tfunction getWorkerPoolByIndex(uint256 _index) public view returns (address)\r\n\t{\r\n\t\treturn m_workerPoolByIndex[_index];\r\n\t}\r\n\tfunction getWorkerAffectation(address _worker) public view returns (address workerPool)\r\n\t{\r\n\t\treturn m_workerAffectation[_worker];\r\n\t}\r\n\r\n\tfunction addWorkerPool(address _owner, address _workerPool) internal\r\n\t{\r\n\t\tuint id = m_workerPoolCountByOwner[_owner].add(1);\r\n\t\tm_totalWorkerPoolCount = m_totalWorkerPoolCount.add(1);\r\n\t\tm_workerPoolByIndex       [m_totalWorkerPoolCount] = _workerPool;\r\n\t\tm_workerPoolCountByOwner  [_owner]                 = id;\r\n\t\tm_workerPoolByOwnerByIndex[_owner][id]             = _workerPool;\r\n\t\tm_workerPoolRegistered    [_workerPool]            = true;\r\n\t}\r\n\r\n\tfunction createWorkerPool(\r\n\t\tstring _description,\r\n\t\tuint256 _subscriptionLockStakePolicy,\r\n\t\tuint256 _subscriptionMinimumStakePolicy,\r\n\t\tuint256 _subscriptionMinimumScorePolicy,\r\n\t\taddress _marketplaceAddress)\r\n\texternal onlyOwner /*owner == IexecHub*/ returns (address createdWorkerPool)\r\n\t{\r\n\t\t// tx.origin == owner\r\n\t\t// msg.sender == IexecHub\r\n\t\t// At creating ownership is transfered to tx.origin\r\n\t\taddress newWorkerPool = new WorkerPool(\r\n\t\t\tmsg.sender, // iexecHubAddress\r\n\t\t\t_description,\r\n\t\t\t_subscriptionLockStakePolicy,\r\n\t\t\t_subscriptionMinimumStakePolicy,\r\n\t\t\t_subscriptionMinimumScorePolicy,\r\n\t\t\t_marketplaceAddress\r\n\t\t);\r\n\t\taddWorkerPool(tx.origin, newWorkerPool);\r\n\t\treturn newWorkerPool;\r\n\t}\r\n\r\n\tfunction registerWorkerAffectation(address _workerPool, address _worker) public onlyOwner /*owner == IexecHub*/ returns (bool subscribed)\r\n\t{\r\n\t\t// you must have no cuurent affectation on others worker Pool\r\n\t\trequire(m_workerAffectation[_worker] == address(0));\r\n\t\tm_workerAffectation[_worker] = _workerPool;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction unregisterWorkerAffectation(address _workerPool, address _worker) public onlyOwner /*owner == IexecHub*/ returns (bool unsubscribed)\r\n\t{\r\n\t\trequire(m_workerAffectation[_worker] == _workerPool);\r\n\t\tm_workerAffectation[_worker] = address(0);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title IexecHub\r\n */\r\n\r\ncontract IexecHub\r\n{\r\n\tusing SafeMathOZ for uint256;\r\n\r\n\t/**\r\n\t* RLC contract for token transfers.\r\n\t*/\r\n\tRLC public rlc;\r\n\r\n\tuint256 public constant STAKE_BONUS_RATIO         = 10;\r\n\tuint256 public constant STAKE_BONUS_MIN_THRESHOLD = 1000;\r\n\tuint256 public constant SCORE_UNITARY_SLASH       = 50;\r\n\r\n\t/**\r\n\t * Slaves contracts\r\n\t */\r\n\tAppHub        public appHub;\r\n\tDatasetHub    public datasetHub;\r\n\tWorkerPoolHub public workerPoolHub;\r\n\r\n\t/**\r\n\t * Market place\r\n\t */\r\n\tMarketplace public marketplace;\r\n\tmodifier onlyMarketplace()\r\n\t{\r\n\t\trequire(msg.sender == address(marketplace));\r\n\t\t_;\r\n\t}\r\n\t/**\r\n\t * Categories\r\n\t */\r\n\tmapping(uint256 => IexecLib.Category) public m_categories;\r\n\tuint256                               public m_categoriesCount;\r\n\taddress                               public m_categoriesCreator;\r\n\tmodifier onlyCategoriesCreator()\r\n\t{\r\n\t\trequire(msg.sender == m_categoriesCreator);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Escrow\r\n\t */\r\n\tmapping(address => IexecLib.Account) public m_accounts;\r\n\r\n\r\n\t/**\r\n\t * workOrder Registered\r\n\t */\r\n\tmapping(address => bool) public m_woidRegistered;\r\n\tmodifier onlyRegisteredWoid(address _woid)\r\n\t{\r\n\t\trequire(m_woidRegistered[_woid]);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Reputation for PoCo\r\n\t */\r\n\tmapping(address => uint256)  public m_scores;\r\n\tIexecLib.ContributionHistory public m_contributionHistory;\r\n\r\n\r\n\tevent WorkOrderActivated(address woid, address indexed workerPool);\r\n\tevent WorkOrderClaimed  (address woid, address workerPool);\r\n\tevent WorkOrderCompleted(address woid, address workerPool);\r\n\r\n\tevent CreateApp       (address indexed appOwner,        address indexed app,        string appName,     uint256 appPrice,     string appParams    );\r\n\tevent CreateDataset   (address indexed datasetOwner,    address indexed dataset,    string datasetName, uint256 datasetPrice, string datasetParams);\r\n\tevent CreateWorkerPool(address indexed workerPoolOwner, address indexed workerPool, string workerPoolDescription                                        );\r\n\r\n\tevent CreateCategory  (uint256 catid, string name, string description, uint256 workClockTimeRef);\r\n\r\n\tevent WorkerPoolSubscription  (address indexed workerPool, address worker);\r\n\tevent WorkerPoolUnsubscription(address indexed workerPool, address worker);\r\n\tevent WorkerPoolEviction      (address indexed workerPool, address worker);\r\n\r\n\tevent AccurateContribution(address woid, address indexed worker);\r\n\tevent FaultyContribution  (address woid, address indexed worker);\r\n\r\n\tevent Deposit (address owner, uint256 amount);\r\n\tevent Withdraw(address owner, uint256 amount);\r\n\tevent Reward  (address user,  uint256 amount);\r\n\tevent Seize   (address user,  uint256 amount);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction IexecHub()\r\n\tpublic\r\n\t{\r\n\t\tm_categoriesCreator = msg.sender;\r\n\t}\r\n\r\n\tfunction attachContracts(\r\n\t\taddress _tokenAddress,\r\n\t\taddress _marketplaceAddress,\r\n\t\taddress _workerPoolHubAddress,\r\n\t\taddress _appHubAddress,\r\n\t\taddress _datasetHubAddress)\r\n\tpublic onlyCategoriesCreator\r\n\t{\r\n\t\trequire(address(rlc) == address(0));\r\n\t\trlc                = RLC          (_tokenAddress        );\r\n\t\tmarketplace        = Marketplace  (_marketplaceAddress  );\r\n\t\tworkerPoolHub      = WorkerPoolHub(_workerPoolHubAddress);\r\n\t\tappHub             = AppHub       (_appHubAddress       );\r\n\t\tdatasetHub         = DatasetHub   (_datasetHubAddress   );\r\n\r\n\t}\r\n\r\n\tfunction setCategoriesCreator(address _categoriesCreator)\r\n\tpublic onlyCategoriesCreator\r\n\t{\r\n\t\tm_categoriesCreator = _categoriesCreator;\r\n\t}\r\n\t/**\r\n\t * Factory\r\n\t */\r\n\r\n\tfunction createCategory(\r\n\t\tstring  _name,\r\n\t\tstring  _description,\r\n\t\tuint256 _workClockTimeRef)\r\n\tpublic onlyCategoriesCreator returns (uint256 catid)\r\n\t{\r\n\t\tm_categoriesCount                  = m_categoriesCount.add(1);\r\n\t\tIexecLib.Category storage category = m_categories[m_categoriesCount];\r\n\t\tcategory.catid                     = m_categoriesCount;\r\n\t\tcategory.name                      = _name;\r\n\t\tcategory.description               = _description;\r\n\t\tcategory.workClockTimeRef          = _workClockTimeRef;\r\n\t\temit CreateCategory(m_categoriesCount, _name, _description, _workClockTimeRef);\r\n\t\treturn m_categoriesCount;\r\n\t}\r\n\r\n\tfunction createWorkerPool(\r\n\t\tstring  _description,\r\n\t\tuint256 _subscriptionLockStakePolicy,\r\n\t\tuint256 _subscriptionMinimumStakePolicy,\r\n\t\tuint256 _subscriptionMinimumScorePolicy)\r\n\texternal returns (address createdWorkerPool)\r\n\t{\r\n\t\taddress newWorkerPool = workerPoolHub.createWorkerPool(\r\n\t\t\t_description,\r\n\t\t\t_subscriptionLockStakePolicy,\r\n\t\t\t_subscriptionMinimumStakePolicy,\r\n\t\t\t_subscriptionMinimumScorePolicy,\r\n\t\t\taddress(marketplace)\r\n\t\t);\r\n\t\temit CreateWorkerPool(tx.origin, newWorkerPool, _description);\r\n\t\treturn newWorkerPool;\r\n\t}\r\n\r\n\tfunction createApp(\r\n\t\tstring  _appName,\r\n\t\tuint256 _appPrice,\r\n\t\tstring  _appParams)\r\n\texternal returns (address createdApp)\r\n\t{\r\n\t\taddress newApp = appHub.createApp(\r\n\t\t\t_appName,\r\n\t\t\t_appPrice,\r\n\t\t\t_appParams\r\n\t\t);\r\n\t\temit CreateApp(tx.origin, newApp, _appName, _appPrice, _appParams);\r\n\t\treturn newApp;\r\n\t}\r\n\r\n\tfunction createDataset(\r\n\t\tstring  _datasetName,\r\n\t\tuint256 _datasetPrice,\r\n\t\tstring  _datasetParams)\r\n\texternal returns (address createdDataset)\r\n\t{\r\n\t\taddress newDataset = datasetHub.createDataset(\r\n\t\t\t_datasetName,\r\n\t\t\t_datasetPrice,\r\n\t\t\t_datasetParams\r\n\t\t\t);\r\n\t\temit CreateDataset(tx.origin, newDataset, _datasetName, _datasetPrice, _datasetParams);\r\n\t\treturn newDataset;\r\n\t}\r\n\r\n\t/**\r\n\t * WorkOrder Emission\r\n\t */\r\n\tfunction buyForWorkOrder(\r\n\t\tuint256 _marketorderIdx,\r\n\t\taddress _workerpool,\r\n\t\taddress _app,\r\n\t\taddress _dataset,\r\n\t\tstring  _params,\r\n\t\taddress _callback,\r\n\t\taddress _beneficiary)\r\n\texternal returns (address)\r\n\t{\r\n\t\taddress requester = msg.sender;\r\n\t\trequire(marketplace.consumeMarketOrderAsk(_marketorderIdx, requester, _workerpool));\r\n\r\n\t\tuint256 emitcost = lockWorkOrderCost(requester, _workerpool, _app, _dataset);\r\n\r\n\t\tWorkOrder workorder = new WorkOrder(\r\n\t\t\t_marketorderIdx,\r\n\t\t\trequester,\r\n\t\t\t_app,\r\n\t\t\t_dataset,\r\n\t\t\t_workerpool,\r\n\t\t\temitcost,\r\n\t\t\t_params,\r\n\t\t\t_callback,\r\n\t\t\t_beneficiary\r\n\t\t);\r\n\r\n\t\tm_woidRegistered[workorder] = true;\r\n\r\n\t\trequire(WorkerPool(_workerpool).emitWorkOrder(workorder, _marketorderIdx));\r\n\r\n\t\temit WorkOrderActivated(workorder, _workerpool);\r\n\t\treturn workorder;\r\n\t}\r\n\r\n\tfunction isWoidRegistred(address _woid) public view returns (bool)\r\n\t{\r\n\t\treturn m_woidRegistered[_woid];\r\n\t}\r\n\r\n\tfunction lockWorkOrderCost(\r\n\t\taddress _requester,\r\n\t\taddress _workerpool, // Address of a smartcontract\r\n\t\taddress _app,        // Address of a smartcontract\r\n\t\taddress _dataset)    // Address of a smartcontract\r\n\tinternal returns (uint256)\r\n\t{\r\n\t\t// APP\r\n\t\tApp app = App(_app);\r\n\t\trequire(appHub.isAppRegistered (_app));\r\n\t\t// initialize usercost with dapp price\r\n\t\tuint256 emitcost = app.m_appPrice();\r\n\r\n\t\t// DATASET\r\n\t\tif (_dataset != address(0)) // address(0) → no dataset\r\n\t\t{\r\n\t\t\tDataset dataset = Dataset(_dataset);\r\n\t\t\trequire(datasetHub.isDatasetRegistred(_dataset));\r\n\t\t\t// add optional datasetPrice for userCost\r\n\t\t\temitcost = emitcost.add(dataset.m_datasetPrice());\r\n\t\t}\r\n\r\n\t\t// WORKERPOOL\r\n\t\trequire(workerPoolHub.isWorkerPoolRegistered(_workerpool));\r\n\r\n\t\trequire(lock(_requester, emitcost)); // Lock funds for app + dataset payment\r\n\r\n\t\treturn emitcost;\r\n\t}\r\n\r\n\t/**\r\n\t * WorkOrder life cycle\r\n\t */\r\n\r\n\tfunction claimFailedConsensus(address _woid)\r\n\tpublic onlyRegisteredWoid(_woid) returns (bool)\r\n\t{\r\n\t\tWorkOrder  workorder  = WorkOrder(_woid);\r\n\t\trequire(workorder.m_requester() == msg.sender);\r\n\t\tWorkerPool workerpool = WorkerPool(workorder.m_workerpool());\r\n\r\n\t\tIexecLib.WorkOrderStatusEnum currentStatus = workorder.m_status();\r\n\t\trequire(currentStatus == IexecLib.WorkOrderStatusEnum.ACTIVE || currentStatus == IexecLib.WorkOrderStatusEnum.REVEALING);\r\n\t\t// Unlock stakes for all workers\r\n\t\trequire(workerpool.claimFailedConsensus(_woid));\r\n\t\tworkorder.claim(); // revert on error\r\n\r\n\t\t/* uint256 value           = marketplace.getMarketOrderValue(workorder.m_marketorderIdx()); // revert if not exist */\r\n\t\t/* address workerpoolOwner = marketplace.getMarketOrderWorkerpoolOwner(workorder.m_marketorderIdx()); // revert if not exist */\r\n\t\tuint256 value;\r\n\t\taddress workerpoolOwner;\r\n\t\t(,,,value,,,,workerpoolOwner) = marketplace.getMarketOrder(workorder.m_marketorderIdx()); // Single call cost less gas\r\n\t\tuint256 workerpoolStake = value.percentage(marketplace.ASK_STAKE_RATIO());\r\n\r\n\t\trequire(unlock (workorder.m_requester(), value.add(workorder.m_emitcost()))); // UNLOCK THE FUNDS FOR REINBURSEMENT\r\n\t\trequire(seize  (workerpoolOwner,         workerpoolStake));\r\n\t\t// put workerpoolOwner stake seize into iexecHub address for bonus for scheduler on next well finalized Task\r\n\t\trequire(reward (this,                    workerpoolStake));\r\n\t\trequire(lock   (this,                    workerpoolStake));\r\n\r\n\t\temit WorkOrderClaimed(_woid, workorder.m_workerpool());\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction finalizeWorkOrder(\r\n\t\taddress _woid,\r\n\t\tstring  _stdout,\r\n\t\tstring  _stderr,\r\n\t\tstring  _uri)\r\n\tpublic onlyRegisteredWoid(_woid) returns (bool)\r\n\t{\r\n\t\tWorkOrder workorder = WorkOrder(_woid);\r\n\t\trequire(workorder.m_workerpool() == msg.sender);\r\n\t\trequire(workorder.m_status()     == IexecLib.WorkOrderStatusEnum.REVEALING);\r\n\r\n\t\t// APP\r\n\t\tApp     app      = App(workorder.m_app());\r\n\t\tuint256 appPrice = app.m_appPrice();\r\n\t\tif (appPrice > 0)\r\n\t\t{\r\n\t\t\trequire(reward(app.m_owner(), appPrice));\r\n\t\t}\r\n\r\n\t\t// DATASET\r\n\t\tDataset dataset = Dataset(workorder.m_dataset());\r\n\t\tif (dataset != address(0))\r\n\t\t{\r\n\t\t\tuint256 datasetPrice = dataset.m_datasetPrice();\r\n\t\t\tif (datasetPrice > 0)\r\n\t\t\t{\r\n\t\t\t\trequire(reward(dataset.m_owner(), datasetPrice));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// WORKERPOOL → rewarding done by the caller itself\r\n\r\n\t\t/**\r\n\t\t * seize stacked funds from requester.\r\n\t\t * reward = value: was locked at market making\r\n\t\t * emitcost: was locked at when emiting the workorder\r\n\t\t */\r\n\t\t/* uint256 value           = marketplace.getMarketOrderValue(workorder.m_marketorderIdx()); // revert if not exist */\r\n\t\t/* address workerpoolOwner = marketplace.getMarketOrderWorkerpoolOwner(workorder.m_marketorderIdx()); // revert if not exist */\r\n\t\tuint256 value;\r\n\t\taddress workerpoolOwner;\r\n\t\t(,,,value,,,,workerpoolOwner) = marketplace.getMarketOrder(workorder.m_marketorderIdx()); // Single call cost less gas\r\n\t\tuint256 workerpoolStake       = value.percentage(marketplace.ASK_STAKE_RATIO());\r\n\r\n\t\trequire(seize (workorder.m_requester(), value.add(workorder.m_emitcost()))); // seize funds for payment (market value + emitcost)\r\n\t\trequire(unlock(workerpoolOwner,         workerpoolStake)); // unlock scheduler stake\r\n\r\n\t\t// write results\r\n\t\tworkorder.setResult(_stdout, _stderr, _uri); // revert on error\r\n\r\n\t\t// Rien ne se perd, rien ne se crée, tout se transfere\r\n\t\t// distribute bonus to scheduler. jackpot bonus come from scheduler stake loose on IexecHub contract\r\n\t\t// we reuse the varaible value for the kitty / fraction of the kitty (stack too deep)\r\n\t\t/* (,value) = checkBalance(this); // kitty is locked on `this` wallet */\r\n\t\tvalue = m_accounts[this].locked; // kitty is locked on `this` wallet\r\n\t\tif(value > 0)\r\n\t\t{\r\n\t\t\tvalue = value.min(value.percentage(STAKE_BONUS_RATIO).max(STAKE_BONUS_MIN_THRESHOLD));\r\n\t\t\trequire(seize(this,             value));\r\n\t\t\trequire(reward(workerpoolOwner, value));\r\n\t\t}\r\n\r\n\t\temit WorkOrderCompleted(_woid, workorder.m_workerpool());\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Views\r\n\t */\r\n\tfunction getCategoryWorkClockTimeRef(uint256 _catId) public view returns (uint256 workClockTimeRef)\r\n\t{\r\n\t\trequire(existingCategory(_catId));\r\n\t\treturn m_categories[_catId].workClockTimeRef;\r\n\t}\r\n\r\n\tfunction existingCategory(uint256 _catId) public view  returns (bool categoryExist)\r\n\t{\r\n\t\treturn m_categories[_catId].catid > 0;\r\n\t}\r\n\r\n\tfunction getCategory(uint256 _catId) public view returns (uint256 catid, string name, string  description, uint256 workClockTimeRef)\r\n\t{\r\n\t\trequire(existingCategory(_catId));\r\n\t\treturn (\r\n\t\t\tm_categories[_catId].catid,\r\n\t\t\tm_categories[_catId].name,\r\n\t\t\tm_categories[_catId].description,\r\n\t\t\tm_categories[_catId].workClockTimeRef\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getWorkerStatus(address _worker) public view returns (address workerPool, uint256 workerScore)\r\n\t{\r\n\t\treturn (workerPoolHub.getWorkerAffectation(_worker), m_scores[_worker]);\r\n\t}\r\n\r\n\tfunction getWorkerScore(address _worker) public view returns (uint256 workerScore)\r\n\t{\r\n\t\treturn m_scores[_worker];\r\n\t}\r\n\r\n\t/**\r\n\t * Worker subscription\r\n\t */\r\n\tfunction registerToPool(address _worker) public returns (bool subscribed)\r\n\t// msg.sender = workerPool\r\n\t{\r\n\t\tWorkerPool workerpool = WorkerPool(msg.sender);\r\n\t\t// Check credentials\r\n\t\trequire(workerPoolHub.isWorkerPoolRegistered(msg.sender));\r\n\t\t// Lock worker deposit\r\n\t\trequire(lock(_worker, workerpool.m_subscriptionLockStakePolicy()));\r\n\t\t// Check subscription policy\r\n\t\trequire(m_accounts[_worker].stake >= workerpool.m_subscriptionMinimumStakePolicy());\r\n\t\trequire(m_scores[_worker]         >= workerpool.m_subscriptionMinimumScorePolicy());\r\n\t\t// Update affectation\r\n\t\trequire(workerPoolHub.registerWorkerAffectation(msg.sender, _worker));\r\n\t\t// Trigger event notice\r\n\t\temit WorkerPoolSubscription(msg.sender, _worker);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction unregisterFromPool(address _worker) public returns (bool unsubscribed)\r\n\t// msg.sender = workerPool\r\n\t{\r\n\t\trequire(removeWorker(msg.sender, _worker));\r\n\t\t// Trigger event notice\r\n\t\temit WorkerPoolUnsubscription(msg.sender, _worker);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction evictWorker(address _worker) public returns (bool unsubscribed)\r\n\t// msg.sender = workerpool\r\n\t{\r\n\t\trequire(removeWorker(msg.sender, _worker));\r\n\t\t// Trigger event notice\r\n\t\temit WorkerPoolEviction(msg.sender, _worker);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction removeWorker(address _workerpool, address _worker) internal returns (bool unsubscribed)\r\n\t{\r\n\t\tWorkerPool workerpool = WorkerPool(_workerpool);\r\n\t\t// Check credentials\r\n\t\trequire(workerPoolHub.isWorkerPoolRegistered(_workerpool));\r\n\t\t// Unlick worker stake\r\n\t\trequire(unlock(_worker, workerpool.m_subscriptionLockStakePolicy()));\r\n\t\t// Update affectation\r\n\t\trequire(workerPoolHub.unregisterWorkerAffectation(_workerpool, _worker));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Stake, reward and penalty functions\r\n\t */\r\n\t/* Marketplace */\r\n\tfunction lockForOrder(address _user, uint256 _amount) public onlyMarketplace returns (bool)\r\n\t{\r\n\t\trequire(lock(_user, _amount));\r\n\t\treturn true;\r\n\t}\r\n\tfunction unlockForOrder(address _user, uint256 _amount) public  onlyMarketplace returns (bool)\r\n\t{\r\n\t\trequire(unlock(_user, _amount));\r\n\t\treturn true;\r\n\t}\r\n\t/* Work */\r\n\tfunction lockForWork(address _woid, address _user, uint256 _amount) public onlyRegisteredWoid(_woid) returns (bool)\r\n\t{\r\n\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\r\n\t\trequire(lock(_user, _amount));\r\n\t\treturn true;\r\n\t}\r\n\tfunction unlockForWork(address _woid, address _user, uint256 _amount) public onlyRegisteredWoid(_woid) returns (bool)\r\n\t{\r\n\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\r\n\t\trequire(unlock(_user, _amount));\r\n\t\treturn true;\r\n\t}\r\n\tfunction rewardForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public onlyRegisteredWoid(_woid) returns (bool)\r\n\t{\r\n\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\r\n\t\trequire(reward(_worker, _amount));\r\n\t\tif (_reputation)\r\n\t\t{\r\n\t\t\tm_contributionHistory.success = m_contributionHistory.success.add(1);\r\n\t\t\tm_scores[_worker] = m_scores[_worker].add(1);\r\n\t\t\temit AccurateContribution(_woid, _worker);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tfunction seizeForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public onlyRegisteredWoid(_woid) returns (bool)\r\n\t{\r\n\t\trequire(WorkOrder(_woid).m_workerpool() == msg.sender);\r\n\t\trequire(seize(_worker, _amount));\r\n\t\tif (_reputation)\r\n\t\t{\r\n\t\t\tm_contributionHistory.failed = m_contributionHistory.failed.add(1);\r\n\t\t\tm_scores[_worker] = m_scores[_worker].sub(m_scores[_worker].min(SCORE_UNITARY_SLASH));\r\n\t\t\temit FaultyContribution(_woid, _worker);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t/**\r\n\t * Wallet methods: public\r\n\t */\r\n\tfunction deposit(uint256 _amount) external returns (bool)\r\n\t{\r\n\t\trequire(rlc.transferFrom(msg.sender, address(this), _amount));\r\n\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.add(_amount);\r\n\t\temit Deposit(msg.sender, _amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction withdraw(uint256 _amount) external returns (bool)\r\n\t{\r\n\t\tm_accounts[msg.sender].stake = m_accounts[msg.sender].stake.sub(_amount);\r\n\t\trequire(rlc.transfer(msg.sender, _amount));\r\n\t\temit Withdraw(msg.sender, _amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction checkBalance(address _owner) public view returns (uint256 stake, uint256 locked)\r\n\t{\r\n\t\treturn (m_accounts[_owner].stake, m_accounts[_owner].locked);\r\n\t}\r\n\t/**\r\n\t * Wallet methods: Internal\r\n\t */\r\n\tfunction reward(address _user, uint256 _amount) internal returns (bool)\r\n\t{\r\n\t\tm_accounts[_user].stake = m_accounts[_user].stake.add(_amount);\r\n\t\temit Reward(_user, _amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction seize(address _user, uint256 _amount) internal returns (bool)\r\n\t{\r\n\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\r\n\t\temit Seize(_user, _amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction lock(address _user, uint256 _amount) internal returns (bool)\r\n\t{\r\n\t\tm_accounts[_user].stake  = m_accounts[_user].stake.sub(_amount);\r\n\t\tm_accounts[_user].locked = m_accounts[_user].locked.add(_amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction unlock(address _user, uint256 _amount) internal returns (bool)\r\n\t{\r\n\t\tm_accounts[_user].locked = m_accounts[_user].locked.sub(_amount);\r\n\t\tm_accounts[_user].stake  = m_accounts[_user].stake.add(_amount);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract IexecCallbackInterface\r\n{\r\n\r\n\tfunction workOrderCallback(\r\n\t\taddress _woid,\r\n\t\tstring  _stdout,\r\n\t\tstring  _stderr,\r\n\t\tstring  _uri) public returns (bool);\r\n\r\n\tevent WorkOrderCallback(address woid, string stdout, string stderr, string uri);\r\n}\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract WorkerPool is OwnableOZ, IexecHubAccessor, MarketplaceAccessor\r\n{\r\n\tusing SafeMathOZ for uint256;\r\n\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tstring                      public m_description;\r\n\tuint256                     public m_stakeRatioPolicy;               // % of reward to stake\r\n\tuint256                     public m_schedulerRewardRatioPolicy;     // % of reward given to scheduler\r\n\tuint256                     public m_subscriptionLockStakePolicy;    // Stake locked when in workerpool - Constant set by constructor, do not update\r\n\tuint256                     public m_subscriptionMinimumStakePolicy; // Minimum stake for subscribing\r\n\tuint256                     public m_subscriptionMinimumScorePolicy; // Minimum score for subscribing\r\n\taddress[]                   public m_workers;\r\n\tmapping(address => uint256) public m_workerIndex;\r\n\r\n\t// mapping(woid => IexecLib.Consensus)\r\n\tmapping(address => IexecLib.Consensus) public m_consensus;\r\n\t// mapping(woid => worker address => Contribution);\r\n\tmapping(address => mapping(address => IexecLib.Contribution)) public m_contributions;\r\n\r\n\tuint256 public constant REVEAL_PERIOD_DURATION_RATIO  = 2;\r\n\tuint256 public constant CONSENSUS_DURATION_RATIO      = 10;\r\n\r\n\t/**\r\n\t * Address of slave/related contracts\r\n\t */\r\n\taddress        public  m_workerPoolHubAddress;\r\n\r\n\r\n\t/**\r\n\t * Events\r\n\t */\r\n\tevent WorkerPoolPolicyUpdate(\r\n\t\tuint256 oldStakeRatioPolicy,               uint256 newStakeRatioPolicy,\r\n\t\tuint256 oldSchedulerRewardRatioPolicy,     uint256 newSchedulerRewardRatioPolicy,\r\n\t\tuint256 oldSubscriptionMinimumStakePolicy, uint256 newSubscriptionMinimumStakePolicy,\r\n\t\tuint256 oldSubscriptionMinimumScorePolicy, uint256 newSubscriptionMinimumScorePolicy);\r\n\r\n\tevent WorkOrderActive         (address indexed woid);\r\n\tevent WorkOrderClaimed        (address indexed woid);\r\n\r\n\tevent AllowWorkerToContribute (address indexed woid, address indexed worker, uint256 workerScore);\r\n\tevent Contribute              (address indexed woid, address indexed worker, bytes32 resultHash);\r\n\tevent RevealConsensus         (address indexed woid, bytes32 consensus);\r\n\tevent Reveal                  (address indexed woid, address indexed worker, bytes32 result);\r\n\tevent Reopen                  (address indexed woid);\r\n  event FinalizeWork            (address indexed woid, string stdout, string stderr, string uri);\r\n\r\n\r\n\r\n\tevent WorkerSubscribe         (address indexed worker);\r\n\tevent WorkerUnsubscribe       (address indexed worker);\r\n\tevent WorkerEviction          (address indexed worker);\r\n\r\n\t/**\r\n\t * Methods\r\n\t */\r\n\t// Constructor\r\n\tfunction WorkerPool(\r\n\t\taddress _iexecHubAddress,\r\n\t\tstring  _description,\r\n\t\tuint256 _subscriptionLockStakePolicy,\r\n\t\tuint256 _subscriptionMinimumStakePolicy,\r\n\t\tuint256 _subscriptionMinimumScorePolicy,\r\n\t\taddress _marketplaceAddress)\r\n\tIexecHubAccessor(_iexecHubAddress)\r\n\tMarketplaceAccessor(_marketplaceAddress)\r\n\tpublic\r\n\t{\r\n\t\t// tx.origin == owner\r\n\t\t// msg.sender ==  WorkerPoolHub\r\n\t\trequire(tx.origin != msg.sender);\r\n\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\r\n\r\n\t\tm_description                    = _description;\r\n\t\tm_stakeRatioPolicy               = 30; // % of the work order price to stake\r\n\t\tm_schedulerRewardRatioPolicy     = 1;  // % of the work reward going to scheduler vs workers reward\r\n\t\tm_subscriptionLockStakePolicy    = _subscriptionLockStakePolicy; // only at creation. cannot be change to respect lock/unlock of worker stake\r\n\t\tm_subscriptionMinimumStakePolicy = _subscriptionMinimumStakePolicy;\r\n\t\tm_subscriptionMinimumScorePolicy = _subscriptionMinimumScorePolicy;\r\n\t\tm_workerPoolHubAddress           = msg.sender;\r\n\r\n\t}\r\n\r\n\tfunction changeWorkerPoolPolicy(\r\n\t\tuint256 _newStakeRatioPolicy,\r\n\t\tuint256 _newSchedulerRewardRatioPolicy,\r\n\t\tuint256 _newSubscriptionMinimumStakePolicy,\r\n\t\tuint256 _newSubscriptionMinimumScorePolicy)\r\n\tpublic onlyOwner\r\n\t{\r\n\t\temit WorkerPoolPolicyUpdate(\r\n\t\t\tm_stakeRatioPolicy,               _newStakeRatioPolicy,\r\n\t\t\tm_schedulerRewardRatioPolicy,     _newSchedulerRewardRatioPolicy,\r\n\t\t\tm_subscriptionMinimumStakePolicy, _newSubscriptionMinimumStakePolicy,\r\n\t\t\tm_subscriptionMinimumScorePolicy, _newSubscriptionMinimumScorePolicy\r\n\t\t);\r\n\t\trequire(_newSchedulerRewardRatioPolicy <= 100);\r\n\t\tm_stakeRatioPolicy               = _newStakeRatioPolicy;\r\n\t\tm_schedulerRewardRatioPolicy     = _newSchedulerRewardRatioPolicy;\r\n\t\tm_subscriptionMinimumStakePolicy = _newSubscriptionMinimumStakePolicy;\r\n\t\tm_subscriptionMinimumScorePolicy = _newSubscriptionMinimumScorePolicy;\r\n\t}\r\n\r\n\t/************************* worker list management **************************/\r\n\tfunction getWorkerAddress(uint _index) public view returns (address)\r\n\t{\r\n\t\treturn m_workers[_index];\r\n\t}\r\n\tfunction getWorkerIndex(address _worker) public view returns (uint)\r\n\t{\r\n\t\tuint index = m_workerIndex[_worker];\r\n\t\trequire(m_workers[index] == _worker);\r\n\t\treturn index;\r\n\t}\r\n\tfunction getWorkersCount() public view returns (uint)\r\n\t{\r\n\t\treturn m_workers.length;\r\n\t}\r\n\r\n\tfunction subscribeToPool() public returns (bool)\r\n\t{\r\n\t\t// msg.sender = worker\r\n\t\trequire(iexecHubInterface.registerToPool(msg.sender));\r\n\t\tuint index = m_workers.push(msg.sender);\r\n\t\tm_workerIndex[msg.sender] = index.sub(1);\r\n\t\temit WorkerSubscribe(msg.sender);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction unsubscribeFromPool() public  returns (bool)\r\n\t{\r\n\t\t// msg.sender = worker\r\n\t\trequire(iexecHubInterface.unregisterFromPool(msg.sender));\r\n\t\trequire(removeWorker(msg.sender));\r\n\t\temit WorkerUnsubscribe(msg.sender);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction evictWorker(address _worker) public onlyOwner returns (bool)\r\n\t{\r\n\t\t// msg.sender = scheduler\r\n\t\trequire(iexecHubInterface.evictWorker(_worker));\r\n\t\trequire(removeWorker(_worker));\r\n\t\temit WorkerEviction(_worker);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction removeWorker(address _worker) internal returns (bool)\r\n\t{\r\n\t\tuint index = getWorkerIndex(_worker); // fails if worker not registered\r\n\t\taddress lastWorker = m_workers[m_workers.length.sub(1)];\r\n\t\tm_workers    [index     ] = lastWorker;\r\n\t\tm_workerIndex[lastWorker] = index;\r\n\t\tdelete m_workers[m_workers.length.sub(1)];\r\n\t\tm_workers.length = m_workers.length.sub(1);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getConsensusDetails(address _woid) public view returns (\r\n\t\tuint256 c_poolReward,\r\n\t\tuint256 c_stakeAmount,\r\n\t\tbytes32 c_consensus,\r\n\t\tuint256 c_revealDate,\r\n\t\tuint256 c_revealCounter,\r\n\t\tuint256 c_consensusTimeout,\r\n\t\tuint256 c_winnerCount,\r\n\t\taddress c_workerpoolOwner)\r\n\t{\r\n\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\r\n\t\treturn (\r\n\t\t\tconsensus.poolReward,\r\n\t\t\tconsensus.stakeAmount,\r\n\t\t\tconsensus.consensus,\r\n\t\t\tconsensus.revealDate,\r\n\t\t\tconsensus.revealCounter,\r\n\t\t\tconsensus.consensusTimeout,\r\n\t\t\tconsensus.winnerCount,\r\n\t\t\tconsensus.workerpoolOwner\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getContributorsCount(address _woid) public view returns (uint256 contributorsCount)\r\n\t{\r\n\t\treturn m_consensus[_woid].contributors.length;\r\n\t}\r\n\r\n\tfunction getContributor(address _woid, uint256 index) public view returns (address contributor)\r\n\t{\r\n\t\treturn m_consensus[_woid].contributors[index];\r\n\t}\r\n\r\n\tfunction existingContribution(address _woid, address _worker) public view  returns (bool contributionExist)\r\n\t{\r\n\t\treturn m_contributions[_woid][_worker].status != IexecLib.ContributionStatusEnum.UNSET;\r\n\t}\r\n\r\n\tfunction getContribution(address _woid, address _worker) public view returns\r\n\t(\r\n\t\tIexecLib.ContributionStatusEnum status,\r\n\t\tbytes32 resultHash,\r\n\t\tbytes32 resultSign,\r\n\t\taddress enclaveChallenge,\r\n\t\tuint256 score,\r\n\t\tuint256 weight)\r\n\t{\r\n\t\trequire(existingContribution(_woid, _worker)); // no silent value returned\r\n\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][_worker];\r\n\t\treturn (\r\n\t\t\tcontribution.status,\r\n\t\t\tcontribution.resultHash,\r\n\t\t\tcontribution.resultSign,\r\n\t\t\tcontribution.enclaveChallenge,\r\n\t\t\tcontribution.score,\r\n\t\t\tcontribution.weight\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**************************** Works management *****************************/\r\n\tfunction emitWorkOrder(address _woid, uint256 _marketorderIdx) public onlyIexecHub returns (bool)\r\n\t{\r\n\t\tuint256 catid   = marketplaceInterface.getMarketOrderCategory(_marketorderIdx);\r\n\t\tuint256 timeout = iexecHubInterface.getCategoryWorkClockTimeRef(catid).mul(CONSENSUS_DURATION_RATIO).add(now);\r\n\r\n\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\r\n\t\tconsensus.poolReward                 = marketplaceInterface.getMarketOrderValue(_marketorderIdx);\r\n\t\tconsensus.workerpoolOwner            = marketplaceInterface.getMarketOrderWorkerpoolOwner(_marketorderIdx);\r\n\t\tconsensus.stakeAmount                = consensus.poolReward.percentage(m_stakeRatioPolicy);\r\n\t\tconsensus.consensusTimeout            = timeout;\r\n\t\tconsensus.schedulerRewardRatioPolicy = m_schedulerRewardRatioPolicy;\r\n\r\n\t\temit WorkOrderActive(_woid);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction claimFailedConsensus(address _woid) public onlyIexecHub returns (bool)\r\n\t{\r\n\t  IexecLib.Consensus storage consensus = m_consensus[_woid];\r\n\t\trequire(now > consensus.consensusTimeout);\r\n\t\tuint256 i;\r\n\t\taddress w;\r\n\t\tfor (i = 0; i < consensus.contributors.length; ++i)\r\n\t\t{\r\n\t\t\tw = consensus.contributors[i];\r\n\t\t\tif (m_contributions[_woid][w].status != IexecLib.ContributionStatusEnum.AUTHORIZED)\r\n\t\t\t{\r\n\t\t\t\trequire(iexecHubInterface.unlockForWork(_woid, w, consensus.stakeAmount));\r\n\t\t\t}\r\n\t\t}\r\n\t\temit WorkOrderClaimed(_woid);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowWorkersToContribute(address _woid, address[] _workers, address _enclaveChallenge) public onlyOwner /*onlySheduler*/ returns (bool)\r\n\t{\r\n\t\tfor (uint i = 0; i < _workers.length; ++i)\r\n\t\t{\r\n\t\t\trequire(allowWorkerToContribute(_woid, _workers[i], _enclaveChallenge));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowWorkerToContribute(address _woid, address _worker, address _enclaveChallenge) public onlyOwner /*onlySheduler*/ returns (bool)\r\n\t{\r\n\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\r\n\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.ACTIVE);\r\n\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][_worker];\r\n\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\r\n\t\trequire(now <= consensus.consensusTimeout);\r\n\r\n\t\taddress workerPool;\r\n\t\tuint256 workerScore;\r\n\t\t(workerPool, workerScore) = iexecHubInterface.getWorkerStatus(_worker); // workerPool, workerScore\r\n\t\trequire(workerPool == address(this));\r\n\r\n\t\trequire(contribution.status == IexecLib.ContributionStatusEnum.UNSET);\r\n\t\tcontribution.status           = IexecLib.ContributionStatusEnum.AUTHORIZED;\r\n\t\tcontribution.enclaveChallenge = _enclaveChallenge;\r\n\r\n\t\temit AllowWorkerToContribute(_woid, _worker, workerScore);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction contribute(address _woid, bytes32 _resultHash, bytes32 _resultSign, uint8 _v, bytes32 _r, bytes32 _s) public returns (uint256 workerStake)\r\n\t{\r\n\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\r\n\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\r\n\t\trequire(now <= consensus.consensusTimeout);\r\n\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.ACTIVE); // can't contribute on a claimed or completed workorder\r\n\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][msg.sender];\r\n\r\n\t\t// msg.sender = a worker\r\n\t\trequire(_resultHash != 0x0);\r\n\t\trequire(_resultSign != 0x0);\r\n\t\tif (contribution.enclaveChallenge != address(0))\r\n\t\t{\r\n\t\t\trequire(contribution.enclaveChallenge == ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n64\", _resultHash, _resultSign), _v, _r, _s));\r\n\t\t}\r\n\r\n\t\trequire(contribution.status == IexecLib.ContributionStatusEnum.AUTHORIZED);\r\n\t\tcontribution.status     = IexecLib.ContributionStatusEnum.CONTRIBUTED;\r\n\t\tcontribution.resultHash = _resultHash;\r\n\t\tcontribution.resultSign = _resultSign;\r\n\t\tcontribution.score      = iexecHubInterface.getWorkerScore(msg.sender);\r\n\t\tconsensus.contributors.push(msg.sender);\r\n\r\n\t\trequire(iexecHubInterface.lockForWork(_woid, msg.sender, consensus.stakeAmount));\r\n\t\temit Contribute(_woid, msg.sender, _resultHash);\r\n\t\treturn consensus.stakeAmount;\r\n\t}\r\n\r\n\tfunction revealConsensus(address _woid, bytes32 _consensus) public onlyOwner /*onlySheduler*/ returns (bool)\r\n\t{\r\n\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\r\n\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\r\n\t\trequire(now <= consensus.consensusTimeout);\r\n\t\trequire(WorkOrder(_woid).startRevealingPhase());\r\n\r\n\t\tconsensus.winnerCount = 0;\r\n\t\tfor (uint256 i = 0; i<consensus.contributors.length; ++i)\r\n\t\t{\r\n\t\t\taddress w = consensus.contributors[i];\r\n\t\t\tif (\r\n\t\t\t\tm_contributions[_woid][w].resultHash == _consensus\r\n\t\t\t\t&&\r\n\t\t\t\tm_contributions[_woid][w].status == IexecLib.ContributionStatusEnum.CONTRIBUTED // REJECTED contribution must not be count\r\n\t\t\t)\r\n\t\t\t{\r\n\t\t\t\tconsensus.winnerCount = consensus.winnerCount.add(1);\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(consensus.winnerCount > 0); // you cannot revealConsensus if no worker has contributed to this hash\r\n\r\n\t\tconsensus.consensus  = _consensus;\r\n\t\tconsensus.revealDate = iexecHubInterface.getCategoryWorkClockTimeRef(marketplaceInterface.getMarketOrderCategory(WorkOrder(_woid).m_marketorderIdx())).mul(REVEAL_PERIOD_DURATION_RATIO).add(now); // is it better to store th catid ?\r\n\t\temit RevealConsensus(_woid, _consensus);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction reveal(address _woid, bytes32 _result) public returns (bool)\r\n\t{\r\n\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\r\n\t\tIexecLib.Consensus    storage consensus    = m_consensus[_woid];\r\n\t\trequire(now <= consensus.consensusTimeout);\r\n\t\tIexecLib.Contribution storage contribution = m_contributions[_woid][msg.sender];\r\n\r\n\t\trequire(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.REVEALING     );\r\n\t\trequire(consensus.revealDate        >  now                                        );\r\n\t\trequire(contribution.status         == IexecLib.ContributionStatusEnum.CONTRIBUTED);\r\n\t\trequire(contribution.resultHash     == consensus.consensus                        );\r\n\t\trequire(contribution.resultHash     == keccak256(_result                        ) );\r\n\t\trequire(contribution.resultSign     == keccak256(_result ^ keccak256(msg.sender)) );\r\n\r\n\t\tcontribution.status     = IexecLib.ContributionStatusEnum.PROVED;\r\n\t\tconsensus.revealCounter = consensus.revealCounter.add(1);\r\n\r\n\t\temit Reveal(_woid, msg.sender, _result);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction reopen(address _woid) public onlyOwner /*onlySheduler*/ returns (bool)\r\n\t{\r\n\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\r\n\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\r\n\t\trequire(now <= consensus.consensusTimeout);\r\n\t\trequire(consensus.revealDate <= now && consensus.revealCounter == 0);\r\n\t\trequire(WorkOrder(_woid).reActivate());\r\n\r\n\t\tfor (uint256 i = 0; i < consensus.contributors.length; ++i)\r\n\t\t{\r\n\t\t\taddress w = consensus.contributors[i];\r\n\t\t\tif (m_contributions[_woid][w].resultHash == consensus.consensus)\r\n\t\t\t{\r\n\t\t\t\tm_contributions[_woid][w].status = IexecLib.ContributionStatusEnum.REJECTED;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Reset to status before revealConsensus. Must be after REJECTED traitement above because of consensus.consensus check\r\n\t\tconsensus.winnerCount = 0;\r\n\t\tconsensus.consensus   = 0x0;\r\n\t\tconsensus.revealDate  = 0;\r\n\t\temit Reopen(_woid);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// if sheduler never call finalized ? no incetive to do that. schedulermust be pay also at this time\r\n\tfunction finalizeWork(address _woid, string _stdout, string _stderr, string _uri) public onlyOwner /*onlySheduler*/ returns (bool)\r\n\t{\r\n\t\trequire(iexecHubInterface.isWoidRegistred(_woid));\r\n\t\tIexecLib.Consensus storage consensus = m_consensus[_woid];\r\n\t\trequire(now <= consensus.consensusTimeout);\r\n\t\trequire((consensus.revealDate <= now && consensus.revealCounter > 0) || (consensus.revealCounter == consensus.winnerCount)); // consensus.winnerCount never 0 at this step\r\n\r\n\t\t// add penalized to the call worker to contribution and they never contribute ?\r\n\t\trequire(distributeRewards(_woid, consensus));\r\n\r\n\t\trequire(iexecHubInterface.finalizeWorkOrder(_woid, _stdout, _stderr, _uri));\r\n\t\temit FinalizeWork(_woid,_stdout,_stderr,_uri);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction distributeRewards(address _woid, IexecLib.Consensus _consensus) internal returns (bool)\r\n\t{\r\n\t\tuint256 i;\r\n\t\taddress w;\r\n\t\tuint256 workerBonus;\r\n\t\tuint256 workerWeight;\r\n\t\tuint256 totalWeight;\r\n\t\tuint256 individualWorkerReward;\r\n\t\tuint256 totalReward = _consensus.poolReward;\r\n\t\taddress[] memory contributors = _consensus.contributors;\r\n\t\tfor (i = 0; i<contributors.length; ++i)\r\n\t\t{\r\n\t\t\tw = contributors[i];\r\n\t\t\tIexecLib.Contribution storage c = m_contributions[_woid][w];\r\n\t\t\tif (c.status == IexecLib.ContributionStatusEnum.PROVED)\r\n\t\t\t{\r\n\t\t\t\tworkerBonus  = (c.enclaveChallenge != address(0)) ? 3 : 1; // TODO: bonus sgx = 3 ?\r\n\t\t\t\tworkerWeight = 1 + c.score.mul(workerBonus).log();\r\n\t\t\t\ttotalWeight  = totalWeight.add(workerWeight);\r\n\t\t\t\tc.weight     = workerWeight; // store so we don't have to recompute\r\n\t\t\t}\r\n\t\t\telse // ContributionStatusEnum.REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\r\n\t\t\t{\r\n\t\t\t\ttotalReward = totalReward.add(_consensus.stakeAmount);\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(totalWeight > 0);\r\n\r\n\t\t// compute how much is going to the workers\r\n\t\tuint256 totalWorkersReward = totalReward.percentage(uint256(100).sub(_consensus.schedulerRewardRatioPolicy));\r\n\r\n\t\tfor (i = 0; i<contributors.length; ++i)\r\n\t\t{\r\n\t\t\tw = contributors[i];\r\n\t\t\tif (m_contributions[_woid][w].status == IexecLib.ContributionStatusEnum.PROVED)\r\n\t\t\t{\r\n\t\t\t\tindividualWorkerReward = totalWorkersReward.mulByFraction(m_contributions[_woid][w].weight, totalWeight);\r\n\t\t\t\ttotalReward  = totalReward.sub(individualWorkerReward);\r\n\t\t\t\trequire(iexecHubInterface.unlockForWork(_woid, w, _consensus.stakeAmount));\r\n\t\t\t\trequire(iexecHubInterface.rewardForWork(_woid, w, individualWorkerReward, true));\r\n\t\t\t}\r\n\t\t\telse // WorkStatusEnum.POCO_REJECT or ContributionStatusEnum.CONTRIBUTED (not revealed)\r\n\t\t\t{\r\n\t\t\t\trequire(iexecHubInterface.seizeForWork(_woid, w, _consensus.stakeAmount, true));\r\n\t\t\t\t// No Reward\r\n\t\t\t}\r\n\t\t}\r\n\t\t// totalReward now contains the scheduler share\r\n\t\trequire(iexecHubInterface.rewardForWork(_woid, _consensus.workerpoolOwner, totalReward, false));\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract Marketplace is IexecHubAccessor\r\n{\r\n\tusing SafeMathOZ for uint256;\r\n\r\n\t/**\r\n\t * Marketplace\r\n\t */\r\n\tuint                                 public m_orderCount;\r\n\tmapping(uint =>IexecLib.MarketOrder) public m_orderBook;\r\n\r\n\tuint256 public constant ASK_STAKE_RATIO  = 30;\r\n\r\n\t/**\r\n\t * Events\r\n\t */\r\n\tevent MarketOrderCreated   (uint marketorderIdx);\r\n\tevent MarketOrderClosed    (uint marketorderIdx);\r\n\tevent MarketOrderAskConsume(uint marketorderIdx, address requester);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction Marketplace(address _iexecHubAddress)\r\n\tIexecHubAccessor(_iexecHubAddress)\r\n\tpublic\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Market orders\r\n\t */\r\n\tfunction createMarketOrder(\r\n\t\tIexecLib.MarketOrderDirectionEnum _direction,\r\n\t\tuint256 _category,\r\n\t\tuint256 _trust,\r\n\t\tuint256 _value,\r\n\t\taddress _workerpool,\r\n\t\tuint256 _volume)\r\n\tpublic returns (uint)\r\n\t{\r\n\t\trequire(iexecHubInterface.existingCategory(_category));\r\n\t\trequire(_volume >0);\r\n\t\tm_orderCount = m_orderCount.add(1);\r\n\t\tIexecLib.MarketOrder storage marketorder    = m_orderBook[m_orderCount];\r\n\t\tmarketorder.direction      = _direction;\r\n\t\tmarketorder.category       = _category;\r\n\t\tmarketorder.trust          = _trust;\r\n\t\tmarketorder.value          = _value;\r\n\t\tmarketorder.volume         = _volume;\r\n\t\tmarketorder.remaining      = _volume;\r\n\r\n\t\tif (_direction == IexecLib.MarketOrderDirectionEnum.ASK)\r\n\t\t{\r\n\t\t\trequire(WorkerPool(_workerpool).m_owner() == msg.sender);\r\n\r\n\t\t\trequire(iexecHubInterface.lockForOrder(msg.sender, _value.percentage(ASK_STAKE_RATIO).mul(_volume))); // mul must be done after percentage to avoid rounding errors\r\n\t\t\tmarketorder.workerpool      = _workerpool;\r\n\t\t\tmarketorder.workerpoolOwner = msg.sender;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// no BID implementation\r\n\t\t\trevert();\r\n\t\t}\r\n\t\temit MarketOrderCreated(m_orderCount);\r\n\t\treturn m_orderCount;\r\n\t}\r\n\r\n\tfunction closeMarketOrder(uint256 _marketorderIdx) public returns (bool)\r\n\t{\r\n\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\r\n\t\tif (marketorder.direction == IexecLib.MarketOrderDirectionEnum.ASK)\r\n\t\t{\r\n\t\t\trequire(marketorder.workerpoolOwner == msg.sender);\r\n\t\t\trequire(iexecHubInterface.unlockForOrder(marketorder.workerpoolOwner, marketorder.value.percentage(ASK_STAKE_RATIO).mul(marketorder.remaining))); // mul must be done after percentage to avoid rounding errors\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// no BID implementation\r\n\t\t\trevert();\r\n\t\t}\r\n\t\tmarketorder.direction = IexecLib.MarketOrderDirectionEnum.CLOSED;\r\n\t\temit MarketOrderClosed(_marketorderIdx);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Assets consumption\r\n\t */\r\n\tfunction consumeMarketOrderAsk(\r\n\t\tuint256 _marketorderIdx,\r\n\t\taddress _requester,\r\n\t\taddress _workerpool)\r\n\tpublic onlyIexecHub returns (bool)\r\n\t{\r\n\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\r\n\t\trequire(marketorder.direction  == IexecLib.MarketOrderDirectionEnum.ASK);\r\n\t\trequire(marketorder.remaining  >  0);\r\n\t\trequire(marketorder.workerpool == _workerpool);\r\n\r\n\t\tmarketorder.remaining = marketorder.remaining.sub(1);\r\n\t\tif (marketorder.remaining == 0)\r\n\t\t{\r\n\t\t\tmarketorder.direction = IexecLib.MarketOrderDirectionEnum.CLOSED;\r\n\t\t}\r\n\t\trequire(iexecHubInterface.lockForOrder(_requester, marketorder.value));\r\n\t\temit MarketOrderAskConsume(_marketorderIdx, _requester);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction existingMarketOrder(uint256 _marketorderIdx) public view  returns (bool marketOrderExist)\r\n\t{\r\n\t\treturn m_orderBook[_marketorderIdx].category > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Views\r\n\t */\r\n\tfunction getMarketOrderValue(uint256 _marketorderIdx) public view returns (uint256)\r\n\t{\r\n\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\r\n\t\treturn m_orderBook[_marketorderIdx].value;\r\n\t}\r\n\tfunction getMarketOrderWorkerpoolOwner(uint256 _marketorderIdx) public view returns (address)\r\n\t{\r\n\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\r\n\t\treturn m_orderBook[_marketorderIdx].workerpoolOwner;\r\n\t}\r\n\tfunction getMarketOrderCategory(uint256 _marketorderIdx) public view returns (uint256)\r\n\t{\r\n\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\r\n\t\treturn m_orderBook[_marketorderIdx].category;\r\n\t}\r\n\tfunction getMarketOrderTrust(uint256 _marketorderIdx) public view returns (uint256)\r\n\t{\r\n\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\r\n\t\treturn m_orderBook[_marketorderIdx].trust;\r\n\t}\r\n\tfunction getMarketOrder(uint256 _marketorderIdx) public view returns\r\n\t(\r\n\t\tIexecLib.MarketOrderDirectionEnum direction,\r\n\t\tuint256 category,       // runtime selection\r\n\t\tuint256 trust,          // for PoCo\r\n\t\tuint256 value,          // value/cost/price\r\n\t\tuint256 volume,         // quantity of instances (total)\r\n\t\tuint256 remaining,      // remaining instances\r\n\t\taddress workerpool,     // BID can use null for any\r\n\t\taddress workerpoolOwner)\r\n\t{\r\n\t\trequire(existingMarketOrder(_marketorderIdx)); // no silent value returned\r\n\t\tIexecLib.MarketOrder storage marketorder = m_orderBook[_marketorderIdx];\r\n\t\treturn (\r\n\t\t\tmarketorder.direction,\r\n\t\t\tmarketorder.category,\r\n\t\t\tmarketorder.trust,\r\n\t\t\tmarketorder.value,\r\n\t\t\tmarketorder.volume,\r\n\t\t\tmarketorder.remaining,\r\n\t\t\tmarketorder.workerpool,\r\n\t\t\tmarketorder.workerpoolOwner\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Callback Proof managment\r\n\t */\r\n\r\n\tevent WorkOrderCallbackProof(address indexed woid, address requester, address beneficiary,address indexed callbackTo, address indexed gasCallbackProvider,string stdout, string stderr , string uri);\r\n\r\n\t//mapping(workorder => bool)\r\n\t mapping(address => bool) m_callbackDone;\r\n\r\n\t function isCallbackDone(address _woid) public view  returns (bool callbackDone)\r\n\t {\r\n\t\t return m_callbackDone[_woid];\r\n\t }\r\n\r\n\t function workOrderCallback(address _woid,string _stdout, string _stderr, string _uri) public\r\n\t {\r\n\t\t require(iexecHubInterface.isWoidRegistred(_woid));\r\n\t\t require(!isCallbackDone(_woid));\r\n\t\t m_callbackDone[_woid] = true;\r\n\t\t require(WorkOrder(_woid).m_status() == IexecLib.WorkOrderStatusEnum.COMPLETED);\r\n\t\t require(WorkOrder(_woid).m_resultCallbackProof() == keccak256(_stdout,_stderr,_uri));\r\n\t\t address callbackTo =WorkOrder(_woid).m_callback();\r\n\t\t require(callbackTo != address(0));\r\n\t\t require(IexecCallbackInterface(callbackTo).workOrderCallback(\r\n\t\t\t _woid,\r\n\t\t\t _stdout,\r\n\t\t\t _stderr,\r\n\t\t\t _uri\r\n\t\t ));\r\n\t\t emit WorkOrderCallbackProof(_woid,WorkOrder(_woid).m_requester(),WorkOrder(_woid).m_beneficiary(),callbackTo,tx.origin,_stdout,_stderr,_uri);\r\n\t }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_marketorderIdx\",\"type\":\"uint256\"},{\"name\":\"_requester\",\"type\":\"address\"},{\"name\":\"_workerpool\",\"type\":\"address\"}],\"name\":\"consumeMarketOrderAsk\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"getMarketOrderTrust\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"existingMarketOrder\",\"outputs\":[{\"name\":\"marketOrderExist\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"getMarketOrderValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"m_orderBook\",\"outputs\":[{\"name\":\"direction\",\"type\":\"uint8\"},{\"name\":\"category\",\"type\":\"uint256\"},{\"name\":\"trust\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"volume\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"},{\"name\":\"workerpool\",\"type\":\"address\"},{\"name\":\"workerpoolOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"getMarketOrderCategory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_woid\",\"type\":\"address\"},{\"name\":\"_stdout\",\"type\":\"string\"},{\"name\":\"_stderr\",\"type\":\"string\"},{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"workOrderCallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"getMarketOrderWorkerpoolOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"closeMarketOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_orderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASK_STAKE_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_woid\",\"type\":\"address\"}],\"name\":\"isCallbackDone\",\"outputs\":[{\"name\":\"callbackDone\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_direction\",\"type\":\"uint8\"},{\"name\":\"_category\",\"type\":\"uint256\"},{\"name\":\"_trust\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_workerpool\",\"type\":\"address\"},{\"name\":\"_volume\",\"type\":\"uint256\"}],\"name\":\"createMarketOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"getMarketOrder\",\"outputs\":[{\"name\":\"direction\",\"type\":\"uint8\"},{\"name\":\"category\",\"type\":\"uint256\"},{\"name\":\"trust\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"volume\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"},{\"name\":\"workerpool\",\"type\":\"address\"},{\"name\":\"workerpoolOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_iexecHubAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"MarketOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"marketorderIdx\",\"type\":\"uint256\"}],\"name\":\"MarketOrderClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"marketorderIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"MarketOrderAskConsume\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"woid\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"callbackTo\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"gasCallbackProvider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stdout\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"stderr\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"WorkOrderCallbackProof\",\"type\":\"event\"}]","ContractName":"Marketplace","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000d5ef019ca4c5cc413ee892ced89d7107c5f424d","Library":"","SwarmSource":"bzzr://b668c5108a5814f2559e74c0479fac009c4511209da1afccf95c8e16c36ab40e"}]}