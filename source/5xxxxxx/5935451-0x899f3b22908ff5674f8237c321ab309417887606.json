{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/TokenDestructible.sol\r\n\r\n/**\r\n * @title TokenDestructible:\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev Base contract that can be destroyed by owner. All funds in contract including\r\n * listed tokens will be sent to the owner.\r\n */\r\ncontract TokenDestructible is Ownable {\r\n\r\n  function TokenDestructible() public payable { }\r\n\r\n  /**\r\n   * @notice Terminate contract and refund to owner\r\n   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to\r\n   refund.\r\n   * @notice The called token contracts could try to re-enter this contract. Only\r\n   supply token contracts you trust.\r\n   */\r\n  function destroy(address[] tokens) onlyOwner public {\r\n\r\n    // Transfer tokens to owner\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      ERC20Basic token = ERC20Basic(tokens[i]);\r\n      uint256 balance = token.balanceOf(this);\r\n      token.transfer(owner, balance);\r\n    }\r\n\r\n    // Transfer Eth to owner and terminate contract\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\n// File: contracts/Atonomi.sol\r\n\r\n// solhint-disable-line\r\n\r\n\r\n\r\n\r\n/// @title ERC-20 Token Standard\r\n/// @author Fabian Vogelsteller <fabian@ethereum.org>, Vitalik Buterin <vitalik.buterin@ethereum.org>\r\n/// @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\ninterface ERC20Interface {\r\n    function decimals() public constant returns (uint8);\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);   // solhint-disable-line\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n/// @title Safe Math library\r\n/// @dev Math operations with safety checks that throw on error\r\n/// @dev https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\nlibrary SafeMath {\r\n    /// @dev Multiplies two numbers, throws on overflow.\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /// @dev Integer division of two numbers, truncating the quotient.\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /// @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /// @dev Adds two numbers, throws on overflow.\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/// @dev Interface for the Network Settings contract\r\ninterface SettingsInterface {\r\n    function registrationFee() external view returns (uint256);\r\n    function activationFee() external view returns (uint256);\r\n    function defaultReputationReward() external view returns (uint256);\r\n    function reputationIRNNodeShare() external view returns (uint256);\r\n    function blockThreshold() external view returns (uint256);\r\n}\r\n\r\n\r\n/// @title Atonomi Smart Contract\r\n/// @author Atonomi\r\n/// @notice Governs the activation, registration, and reputation of devices on the Atonomi network\r\n/// @dev Ownable: Owner governs the access of Atonomi Admins, Fees, and Rewards on the network\r\n/// @dev Pausable: Gives ability for Owner to pull emergency stop to prevent actions on the network\r\n/// @dev TokenDestructible: Gives owner ability to kill the contract and extract funds to a new contract\r\ncontract Atonomi is Pausable, TokenDestructible {\r\n    using SafeMath for uint256;\r\n\r\n    /// @title ATMI Token\r\n    /// @notice Standard ERC20 Token\r\n    /// @dev AMLToken source: https://github.com/TokenMarketNet/ico/blob/master/contracts/AMLToken.sol\r\n    ERC20Interface public token;\r\n\r\n    /// @title Network Settings\r\n    /// @notice Atonomi Owner controlled settings are governed in this contract\r\n    SettingsInterface public settings;\r\n\r\n    ///\r\n    /// STORAGE MAPPINGS \r\n    ///\r\n    /// @title Atonomi Devices registry\r\n    /// @notice Contains all devices participating in the Atonomi Network\r\n    /// @dev Key is a keccak256 hash of the device id\r\n    /// @dev Value is a struct that contains the device status and metadata\r\n    mapping (bytes32 => Device) public devices;\r\n\r\n    /// @title Atonomi Participant whitelist\r\n    /// @notice Contains all the network participants\r\n    /// @dev Atonomi Admins: Govern the access to manufacturers and IRN Nodes on the network\r\n    /// @dev IRN Nodes: Governs reputation score data of devices\r\n    /// @dev Manufacturers: Governs devices on the network\r\n    /// @dev Key is ethereum account of the participant\r\n    /// @dev Value is a struct that contains the role of the participant\r\n    mapping (address => NetworkMember) public network;\r\n\r\n    /// @title Token Pools\r\n    /// @notice each manufacturer will manage a pool of tokens for reputation rewards\r\n    /// @dev Key is ethereum account for pool owner\r\n    /// @dev Value is struct representing token pool attributes\r\n    /// @dev incoming tokens will come from registrations, activations, or public donations\r\n    /// @dev outgoing tokens will come from reputation rewards\r\n    mapping (address => TokenPool) public pools;\r\n\r\n    /// @title Reward Balances\r\n    /// @notice balances of rewards that are able to be claimed by participants\r\n    /// @dev Key is ethereum account of the owner of the tokens\r\n    /// @dev Value is tokens available for withdraw\r\n    mapping (address => uint256) public rewards;\r\n\r\n    /// @title Lookup by Manufacturer ID the wallet for reputation rewards\r\n    /// @dev Key is the manufacturer id\r\n    /// @dev Value is ethereum account to be rewarded\r\n    mapping (bytes32 => address) public manufacturerRewards;\r\n\r\n    /// @title Track last write by reputation author\r\n    /// @dev First key is the ethereum address of the reputation author\r\n    /// @dev Second key is the device id\r\n    /// @dev Value is the block number of the last time the author has submitted a score for the device\r\n    mapping (address => mapping (bytes32 => uint256)) public authorWrites;\r\n\r\n    /// @title Default Repuration score for manufacturers\r\n    /// @dev Key is the manufacturer id\r\n    /// @dev value is the score to use for newly registered devices\r\n    mapping (bytes32 => bytes32) public defaultManufacturerReputations;\r\n\r\n    ///\r\n    /// TYPES \r\n    ///\r\n    /// @title Atonomi Device\r\n    /// @notice Contains the device state on the Atonomi network\r\n    /// @dev manufacturerId is the manufacturer the device belongs to\r\n    /// @dev deviceType is the type of device categorized by the manufacturer\r\n    /// @dev registered is true when device is registered, otherwise false\r\n    /// @dev activated is true when device is activated, otherwise false\r\n    /// @dev reputationScore is official Atonomi Reputation score for the device\r\n    /// @dev devicePublicKey is public key used by IRN Nodes for validation\r\n    struct Device {\r\n        bytes32 manufacturerId;\r\n        bytes32 deviceType;\r\n        bool registered;\r\n        bool activated;\r\n        bytes32 reputationScore;\r\n        bytes32 devicePublicKey;\r\n    }\r\n\r\n    /// @title Token Pool\r\n    /// @notice Contains balance and reputation reward amounts for each token pool\r\n    /// @dev balance is total amount of tokens available in the pool\r\n    /// @dev rewardAmount is the total amount distributed between the manufacturer and reputation author\r\n    struct TokenPool {\r\n        uint256 balance;\r\n        uint256 rewardAmount;\r\n    }\r\n\r\n    /// @title Atonomi Network Participant\r\n    /// @notice Contains role information for a participant\r\n    /// @dev isIRNAdmin is true if participant is an IRN Admin, otherwise false\r\n    /// @dev isManufacturer is true if participant is a Manufacturer, otherwise false\r\n    /// @dev isIRNNode is true if participant is an IRN Node, otherwise false\r\n    /// @dev memberId is the manufacturer id, for all other participants this will be 0\r\n    struct NetworkMember {\r\n        bool isIRNAdmin;\r\n        bool isManufacturer;\r\n        bool isIRNNode;\r\n        bytes32 memberId;\r\n    }\r\n\r\n    ///\r\n    /// MODIFIERS\r\n    ///\r\n    /// @notice only manufacturers can call, otherwise throw\r\n    modifier onlyManufacturer() {\r\n        require(network[msg.sender].isManufacturer, \"must be a manufacturer\");\r\n        _;\r\n    }\r\n\r\n    /// @notice only IRNAdmins or Owner can call, otherwise throw\r\n    modifier onlyIRNorOwner() {\r\n        require(msg.sender == owner || network[msg.sender].isIRNAdmin, \"must be owner or an irn admin\");\r\n        _;\r\n    }\r\n\r\n    /// @notice only IRN Nodes can call, otherwise throw\r\n    modifier onlyIRNNode() {\r\n        require(network[msg.sender].isIRNNode, \"must be an irn node\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Constructor sets the ERC Token contract and initial values for network fees\r\n    /// @param _token is the Atonomi Token contract address (must be ERC20)\r\n    /// @param _settings is the Atonomi Network Settings contract address\r\n    constructor (\r\n        address _token,\r\n        address _settings) public {\r\n        require(_token != address(0), \"token address cannot be 0x0\");\r\n        require(_settings != address(0), \"settings address cannot be 0x0\");\r\n        token = ERC20Interface(_token);\r\n        settings = SettingsInterface(_settings);\r\n    }\r\n\r\n    ///\r\n    /// EVENTS \r\n    ///\r\n    /// @notice emitted on successful device registration\r\n    /// @param _sender manufacturer paying for registration\r\n    /// @param _fee registration fee paid by manufacturer\r\n    /// @param _deviceHashKey keccak256 hash of device id used as the key in devices mapping\r\n    /// @param _manufacturerId of the manufacturer the device belongs to\r\n    /// @param _deviceType is the type of device categorized by the manufacturer\r\n    event DeviceRegistered(\r\n        address indexed _sender,\r\n        uint256 _fee,\r\n        bytes32 indexed _deviceHashKey,\r\n        bytes32 indexed _manufacturerId,\r\n        bytes32 _deviceType\r\n    );\r\n\r\n    /// @notice emitted on successful device activation\r\n    /// @param _sender manufacturer or device owner paying for activation\r\n    /// @param _fee registration fee paid by manufacturer\r\n    /// @param _deviceId the real device id (only revealed after activation)\r\n    /// @param _manufacturerId of the manufacturer the device belongs to\r\n    /// @param _deviceType is the type of device categorized by the manufacturer\r\n    event DeviceActivated(\r\n        address indexed _sender,\r\n        uint256 _fee,\r\n        bytes32 indexed _deviceId,\r\n        bytes32 indexed _manufacturerId,\r\n        bytes32 _deviceType\r\n    );\r\n\r\n    /// @notice emitted on reputation change for a device\r\n    /// @param _deviceId device id of the target device\r\n    /// @param _deviceType is the type of device categorized by the manufacturer\r\n    /// @param _newScore updated reputation score\r\n    /// @param _irnNode IRN node submitting the new reputation\r\n    /// @param _irnReward tokens awarded to irn node\r\n    /// @param _manufacturerWallet manufacturer associated with the device is rewared a share of tokens\r\n    /// @param _manufacturerReward tokens awarded to contributor\r\n    event ReputationScoreUpdated(\r\n        bytes32 indexed _deviceId,\r\n        bytes32 _deviceType,\r\n        bytes32 _newScore,\r\n        address indexed _irnNode,\r\n        uint256 _irnReward,\r\n        address indexed _manufacturerWallet,\r\n        uint256 _manufacturerReward\r\n    );\r\n\r\n    /// @notice emitted on successful addition of network member address\r\n    /// @param _sender ethereum account of participant that made the change\r\n    /// @param _member address of added member\r\n    /// @param _memberId manufacturer id for manufacturer, otherwise 0x0\r\n    event NetworkMemberAdded(\r\n        address indexed _sender,\r\n        address indexed _member,\r\n        bytes32 indexed _memberId\r\n    );\r\n\r\n    /// @notice emitted on successful removal of network member address\r\n    /// @param _sender ethereum account of participant that made the change\r\n    /// @param _member address of removed member\r\n    /// @param _memberId manufacturer id for manufacturer, otherwise 0x0\r\n    event NetworkMemberRemoved(\r\n        address indexed _sender,\r\n        address indexed _member,\r\n        bytes32 indexed _memberId\r\n    );\r\n\r\n    /// @notice emitted everytime a manufacturer changes their wallet for rewards\r\n    /// @param _old ethereum account\r\n    /// @param _new ethereum account\r\n    /// @param _manufacturerId that the member belongs to\r\n    event ManufacturerRewardWalletChanged(\r\n        address indexed _old,\r\n        address indexed _new,\r\n        bytes32 indexed _manufacturerId\r\n    );\r\n\r\n    /// @notice emitted everytime a token pool reward amount changes\r\n    /// @param _sender ethereum account of the token pool owner\r\n    /// @param _newReward new reward value in ATMI tokens\r\n    event TokenPoolRewardUpdated(\r\n        address indexed _sender,\r\n        uint256 _newReward\r\n    );\r\n\r\n    /// @notice emitted everytime someone donates tokens to a manufacturer\r\n    /// @param _sender ethereum account of the donater\r\n    /// @param _manufacturerId of the manufacturer\r\n    /// @param _manufacturer ethereum account\r\n    /// @param _amount of tokens deposited\r\n    event TokensDeposited(\r\n        address indexed _sender,\r\n        bytes32 indexed _manufacturerId,\r\n        address indexed _manufacturer,\r\n        uint256 _amount\r\n    );\r\n    \r\n    /// @notice emitted everytime a participant withdraws from token pool\r\n    /// @param _sender ethereum account of participant that made the change\r\n    /// @param _amount tokens withdrawn\r\n    event TokensWithdrawn(\r\n        address indexed _sender,\r\n        uint256 _amount\r\n    );\r\n\r\n    /// @notice emitted everytime the default reputation for a manufacturer changes\r\n    /// @param _sender ethereum account of participant that made the change\r\n    /// @param _manufacturerId of the manufacturer\r\n    /// @param _newDefaultScore to use for newly registered devices\r\n    event DefaultReputationScoreChanged(\r\n        address indexed _sender,\r\n        bytes32 indexed _manufacturerId,\r\n        bytes32 _newDefaultScore\r\n    );\r\n\r\n    ///\r\n    /// DEVICE ONBOARDING\r\n    ///\r\n    /// @notice registers device on the Atonomi network\r\n    /// @param _deviceIdHash keccak256 hash of the device's id (needs to be hashed by caller)\r\n    /// @param _deviceType is the type of device categorized by the manufacturer\r\n    /// @dev devicePublicKey is public key used by IRN Nodes for validation\r\n    /// @return true if successful, otherwise false\r\n    /// @dev msg.sender is expected to be the manufacturer\r\n    /// @dev tokens will be deducted from the manufacturer and added to the token pool\r\n    /// @dev owner has ability to pause this operation\r\n    function registerDevice(\r\n        bytes32 _deviceIdHash,\r\n        bytes32 _deviceType,\r\n        bytes32 _devicePublicKey)\r\n        public onlyManufacturer whenNotPaused returns (bool)\r\n    {\r\n        uint256 registrationFee = settings.registrationFee();\r\n        Device memory d = _registerDevice(msg.sender, _deviceIdHash, _deviceType, _devicePublicKey);\r\n        emit DeviceRegistered(\r\n            msg.sender,\r\n            registrationFee,\r\n            _deviceIdHash,\r\n            d.manufacturerId,\r\n            _deviceType);\r\n        _depositTokens(msg.sender, registrationFee);\r\n        require(token.transferFrom(msg.sender, address(this), registrationFee), \"transferFrom failed\");\r\n        return true;\r\n    }\r\n\r\n    /// @notice Activates the device\r\n    /// @param _deviceId id of the real device id to be activated (not the hash of the device id)\r\n    /// @return true if successful, otherwise false\r\n    /// @dev if the hash doesnt match, the device is considered not registered and will throw\r\n    /// @dev anyone with the device id (in hand) is considered the device owner\r\n    /// @dev tokens will be deducted from the device owner and added to the token pool\r\n    /// @dev owner has ability to pause this operation\r\n    function activateDevice(bytes32 _deviceId) public whenNotPaused returns (bool) {\r\n        uint256 activationFee = settings.activationFee();\r\n        Device memory d = _activateDevice(_deviceId);\r\n        emit DeviceActivated(msg.sender, activationFee, _deviceId, d.manufacturerId, d.deviceType);\r\n        address manufacturer = manufacturerRewards[d.manufacturerId];\r\n        require(manufacturer != address(this), \"manufacturer is unknown\");\r\n        _depositTokens(manufacturer, activationFee);\r\n        require(token.transferFrom(msg.sender, address(this), activationFee), \"transferFrom failed\");\r\n        return true;\r\n    }\r\n\r\n    /// @notice Registers and immediately activates device, used by manufacturers to prepay activation\r\n    /// @param _deviceId id of the real device id to be activated (not the has of the device id)\r\n    /// @param _deviceType is the type of device categorized by the manufacturer\r\n    /// @return true if successful, otherwise false\r\n    /// @dev since the manufacturer is trusted, no need for the caller to hash the device id\r\n    /// @dev msg.sender is expected to be the manufacturer\r\n    /// @dev tokens will be deducted from the manufacturer and added to the token pool\r\n    /// @dev owner has ability to pause this operation\r\n    function registerAndActivateDevice(\r\n        bytes32 _deviceId,\r\n        bytes32 _deviceType,\r\n        bytes32 _devicePublicKey) \r\n        public onlyManufacturer whenNotPaused returns (bool)\r\n    {\r\n        uint256 registrationFee = settings.registrationFee();\r\n        uint256 activationFee = settings.activationFee();\r\n\r\n        bytes32 deviceIdHash = keccak256(_deviceId);\r\n        Device memory d = _registerDevice(msg.sender, deviceIdHash, _deviceType, _devicePublicKey);\r\n        bytes32 manufacturerId = d.manufacturerId;\r\n        emit DeviceRegistered(msg.sender, registrationFee, deviceIdHash, manufacturerId, _deviceType);\r\n\r\n        d = _activateDevice(_deviceId);\r\n        emit DeviceActivated(msg.sender, activationFee, _deviceId, manufacturerId, _deviceType);\r\n\r\n        uint256 fee = registrationFee.add(activationFee);\r\n        _depositTokens(msg.sender, fee);\r\n        require(token.transferFrom(msg.sender, address(this), fee), \"transferFrom failed\");\r\n        return true;\r\n    }\r\n\r\n    ///\r\n    /// REPUTATION MANAGEMENT\r\n    ///\r\n    /// @notice updates reputation for a device\r\n    /// @param _deviceId target device Id\r\n    /// @param _reputationScore updated reputation score computed by the author\r\n    /// @return true if successful, otherwise false\r\n    /// @dev msg.sender is expected to be the reputation author (either irn node or the reputation auditor)\r\n    /// @dev tokens will be deducted from the contract pool\r\n    /// @dev author and manufacturer will be rewarded a split of the tokens\r\n    /// @dev owner has ability to pause this operation\r\n    function updateReputationScore(\r\n        bytes32 _deviceId,\r\n        bytes32 _reputationScore)\r\n        public onlyIRNNode whenNotPaused returns (bool)\r\n    {\r\n        Device memory d = _updateReputationScore(_deviceId, _reputationScore);\r\n\r\n        address _manufacturerWallet = manufacturerRewards[d.manufacturerId];\r\n        require(_manufacturerWallet != address(0), \"_manufacturerWallet cannot be 0x0\");\r\n        require(_manufacturerWallet != msg.sender, \"manufacturers cannot collect the full reward\");\r\n\r\n        uint256 irnReward;\r\n        uint256 manufacturerReward;\r\n        (irnReward, manufacturerReward) = getReputationRewards(msg.sender, _manufacturerWallet, _deviceId);\r\n        _distributeRewards(_manufacturerWallet, msg.sender, irnReward);\r\n        _distributeRewards(_manufacturerWallet, _manufacturerWallet, manufacturerReward);\r\n        emit ReputationScoreUpdated(\r\n            _deviceId,\r\n            d.deviceType,\r\n            _reputationScore,\r\n            msg.sender,\r\n            irnReward,\r\n            _manufacturerWallet,\r\n            manufacturerReward);\r\n        authorWrites[msg.sender][_deviceId] = block.number;\r\n        return true;\r\n    }\r\n\r\n    /// @notice computes the portion of the reputation reward allotted to the manufacturer and author\r\n    /// @param author is the reputation node submitting the score\r\n    /// @param manufacturer is the token pool owner\r\n    /// @param deviceId of the device being updated\r\n    /// @return irnReward and manufacturerReward\r\n    function getReputationRewards(\r\n        address author,\r\n        address manufacturer,\r\n        bytes32 deviceId)\r\n        public view returns (uint256 irnReward, uint256 manufacturerReward)\r\n    {\r\n        uint256 lastWrite = authorWrites[author][deviceId];\r\n        uint256 blocks = 0;\r\n        if (lastWrite > 0) {\r\n            blocks = block.number.sub(lastWrite);\r\n        }\r\n        uint256 totalRewards = calculateReward(pools[manufacturer].rewardAmount, blocks);\r\n        irnReward = totalRewards.mul(settings.reputationIRNNodeShare()).div(100);\r\n        manufacturerReward = totalRewards.sub(irnReward);\r\n    }\r\n\r\n    /// @notice computes total reward based on the authors last submission\r\n    /// @param rewardAmount total amount available for reward\r\n    /// @param blocksSinceLastWrite number of blocks since last write\r\n    /// @return actual reward available\r\n    function calculateReward(uint256 rewardAmount, uint256 blocksSinceLastWrite) public view returns (uint256) {\r\n        uint256 totalReward = rewardAmount;\r\n        uint256 blockThreshold = settings.blockThreshold();\r\n        if (blocksSinceLastWrite > 0 && blocksSinceLastWrite < blockThreshold) {\r\n            uint256 multiplier = 10 ** uint256(token.decimals());\r\n            totalReward = rewardAmount.mul(blocksSinceLastWrite.mul(multiplier)).div(blockThreshold.mul(multiplier));\r\n        }\r\n        return totalReward;\r\n    }\r\n\r\n    ///\r\n    /// BULK OPERATIONS\r\n    ///\r\n    /// @notice registers multiple devices on the Atonomi network\r\n    /// @param _deviceIdHashes array of keccak256 hashed ID's of each device\r\n    /// @param _deviceTypes array of types of device categorized by the manufacturer\r\n    /// @param _devicePublicKeys array of public keys associated with the devices\r\n    /// @return true if successful, otherwise false\r\n    /// @dev msg.sender is expected to be the manufacturer\r\n    /// @dev tokens will be deducted from the manufacturer and added to the token pool\r\n    /// @dev owner has ability to pause this operation\r\n    function registerDevices(\r\n        bytes32[] _deviceIdHashes,\r\n        bytes32[] _deviceTypes,\r\n        bytes32[] _devicePublicKeys)\r\n        public onlyManufacturer whenNotPaused returns (bool)\r\n    {\r\n        require(_deviceIdHashes.length > 0, \"at least one device is required\");\r\n        require(\r\n            _deviceIdHashes.length == _deviceTypes.length,\r\n            \"device type array needs to be same size as devices\"\r\n        );\r\n        require(\r\n            _deviceIdHashes.length == _devicePublicKeys.length,\r\n            \"device public key array needs to be same size as devices\"\r\n        );\r\n\r\n        uint256 runningBalance = 0;\r\n        uint256 registrationFee = settings.registrationFee();\r\n        for (uint256 i = 0; i < _deviceIdHashes.length; i++) {\r\n            bytes32 deviceIdHash = _deviceIdHashes[i];\r\n            bytes32 deviceType = _deviceTypes[i];\r\n            bytes32 devicePublicKey = _devicePublicKeys[i];\r\n            Device memory d = _registerDevice(msg.sender, deviceIdHash, deviceType, devicePublicKey);\r\n            emit DeviceRegistered(msg.sender, registrationFee, deviceIdHash, d.manufacturerId, deviceType);\r\n\r\n            runningBalance = runningBalance.add(registrationFee);\r\n        }\r\n\r\n        _depositTokens(msg.sender, runningBalance);\r\n        require(token.transferFrom(msg.sender, address(this), runningBalance), \"transferFrom failed\");\r\n        return true;\r\n    }\r\n\r\n    ///\r\n    /// WHITELIST PARTICIPANT MANAGEMENT\r\n    ///\r\n    /// @notice add a member to the network\r\n    /// @param _member ethereum address of member to be added\r\n    /// @param _isIRNAdmin true if an irn admin, otherwise false\r\n    /// @param _isManufacturer true if an manufactuter, otherwise false\r\n    /// @param _memberId manufacturer id for manufacturers, otherwise 0x0\r\n    /// @return true if successful, otherwise false\r\n    /// @dev _memberId is only relevant for manufacturer, but is flexible to allow use for other purposes\r\n    /// @dev msg.sender is expected to be either owner or irn admin\r\n    function addNetworkMember(\r\n        address _member,\r\n        bool _isIRNAdmin,\r\n        bool _isManufacturer,\r\n        bool _isIRNNode,\r\n        bytes32 _memberId)\r\n        public onlyIRNorOwner returns(bool)\r\n    {\r\n        NetworkMember storage m = network[_member];\r\n        require(!m.isIRNAdmin, \"already an irn admin\");\r\n        require(!m.isManufacturer, \"already a manufacturer\");\r\n        require(!m.isIRNNode, \"already an irn node\");\r\n        require(m.memberId == 0, \"already assigned a member id\");\r\n\r\n        m.isIRNAdmin = _isIRNAdmin;\r\n        m.isManufacturer = _isManufacturer;\r\n        m.isIRNNode = _isIRNNode;\r\n        m.memberId = _memberId;\r\n\r\n        if (m.isManufacturer) {\r\n            require(_memberId != 0, \"manufacturer id is required\");\r\n\r\n            // keep lookup for rewards in sync\r\n            require(manufacturerRewards[m.memberId] == address(0), \"manufacturer is already assigned\");\r\n            manufacturerRewards[m.memberId] = _member;\r\n\r\n            // set reputation reward if token pool doesnt exist\r\n            if (pools[_member].rewardAmount == 0) {\r\n                pools[_member].rewardAmount = settings.defaultReputationReward();\r\n            }\r\n        }\r\n\r\n        emit NetworkMemberAdded(msg.sender, _member, _memberId);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice remove a member from the network\r\n    /// @param _member ethereum address of member to be removed\r\n    /// @return true if successful, otherwise false\r\n    /// @dev msg.sender is expected to be either owner or irn admin\r\n    function removeNetworkMember(address _member) public onlyIRNorOwner returns(bool) {\r\n        bytes32 memberId = network[_member].memberId;\r\n        if (network[_member].isManufacturer) {\r\n            // remove token pool if there is a zero balance\r\n            if (pools[_member].balance == 0) {\r\n                delete pools[_member];\r\n            }\r\n\r\n            // keep lookup with rewards in sync\r\n            delete manufacturerRewards[memberId];\r\n        }\r\n\r\n        delete network[_member];\r\n\r\n        emit NetworkMemberRemoved(msg.sender, _member, memberId);\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // TOKEN POOL MANAGEMENT\r\n    //\r\n    /// @notice changes the ethereum wallet for a manufacturer used in reputation rewards\r\n    /// @param _new new ethereum account\r\n    /// @return true if successful, otherwise false\r\n    /// @dev msg.sender is expected to be original manufacturer account\r\n    function changeManufacturerWallet(address _new) public onlyManufacturer returns (bool) {\r\n        require(_new != address(0), \"new address cannot be 0x0\");\r\n\r\n        NetworkMember memory old = network[msg.sender];\r\n        require(old.isManufacturer && old.memberId != 0, \"must be a manufacturer\");\r\n\r\n        // copy permissions\r\n        require(!network[_new].isIRNAdmin, \"already an irn admin\");\r\n        require(!network[_new].isManufacturer, \"already a manufacturer\");\r\n        require(!network[_new].isIRNNode, \"already an irn node\");\r\n        require(network[_new].memberId == 0, \"memberId already exists\");\r\n        network[_new] = NetworkMember(\r\n            old.isIRNAdmin,\r\n            old.isManufacturer,\r\n            old.isIRNNode,\r\n            old.memberId\r\n        );\r\n\r\n        // transfer balance from old pool to the new pool\r\n        require(pools[_new].balance == 0 && pools[_new].rewardAmount == 0, \"new token pool already exists\");\r\n        pools[_new].balance = pools[msg.sender].balance;\r\n        pools[_new].rewardAmount = pools[msg.sender].rewardAmount;\r\n        delete pools[msg.sender];\r\n\r\n        // update reward mapping\r\n        manufacturerRewards[old.memberId] = _new;\r\n\r\n        // delete old member\r\n        delete network[msg.sender];\r\n\r\n        emit ManufacturerRewardWalletChanged(msg.sender, _new, old.memberId);\r\n        return true;\r\n    }\r\n\r\n    /// @notice allows a token pool owner to set a new reward amount\r\n    /// @param newReward new reputation reward amount\r\n    /// @return true if successful, otherwise false\r\n    /// @dev msg.sender expected to be manufacturer\r\n    function setTokenPoolReward(uint256 newReward) public onlyManufacturer returns (bool) {\r\n        require(newReward != 0, \"newReward is required\");\r\n\r\n        TokenPool storage p = pools[msg.sender];\r\n        require(p.rewardAmount != newReward, \"newReward should be different\");\r\n\r\n        p.rewardAmount = newReward;\r\n        emit TokenPoolRewardUpdated(msg.sender, newReward);\r\n        return true;\r\n    }\r\n\r\n    /// @notice anyone can donate tokens to a manufacturer's pool\r\n    /// @param manufacturerId of the manufacturer to receive the tokens\r\n    /// @param amount of tokens to deposit\r\n    function depositTokens(bytes32 manufacturerId, uint256 amount) public returns (bool) {\r\n        require(manufacturerId != 0, \"manufacturerId is required\");\r\n        require(amount > 0, \"amount is required\");\r\n\r\n        address manufacturer = manufacturerRewards[manufacturerId];\r\n        require(manufacturer != address(0));\r\n\r\n        _depositTokens(manufacturer, amount);\r\n        emit TokensDeposited(msg.sender, manufacturerId, manufacturer, amount);\r\n\r\n        require(token.transferFrom(msg.sender, address(this), amount));\r\n        return true;\r\n    }\r\n\r\n    /// @notice allows participants in the Atonomi network to claim their rewards\r\n    /// @return true if successful, otherwise false\r\n    /// @dev owner has ability to pause this operation\r\n    function withdrawTokens() public whenNotPaused returns (bool) {\r\n        uint256 amount = rewards[msg.sender];\r\n        require(amount > 0, \"amount is zero\");\r\n\r\n        rewards[msg.sender] = 0;\r\n        emit TokensWithdrawn(msg.sender, amount);\r\n\r\n        require(token.transfer(msg.sender, amount), \"token transfer failed\");\r\n        return true;\r\n    }\r\n\r\n    /// @notice allows the owner to change the default reputation for manufacturers\r\n    /// @param _manufacturerId of the manufacturer\r\n    /// @param _newDefaultScore to use for newly registered devices\r\n    /// @return true if successful, otherwise false\r\n    /// @dev owner is the only one with this feature\r\n    function setDefaultReputationForManufacturer(\r\n        bytes32 _manufacturerId,\r\n        bytes32 _newDefaultScore) public onlyOwner returns (bool) {\r\n        require(_manufacturerId != 0, \"_manufacturerId is required\");\r\n        require(\r\n            _newDefaultScore != defaultManufacturerReputations[_manufacturerId],\r\n            \"_newDefaultScore should be different\"\r\n        );\r\n\r\n        defaultManufacturerReputations[_manufacturerId] = _newDefaultScore;\r\n        emit DefaultReputationScoreChanged(msg.sender, _manufacturerId, _newDefaultScore);\r\n        return true;\r\n    }\r\n\r\n    ///\r\n    /// INTERNAL FUNCTIONS\r\n    ///\r\n    /// @dev track balances of any deposits going into a token pool\r\n    function _depositTokens(address _owner, uint256 _amount) internal {\r\n        pools[_owner].balance = pools[_owner].balance.add(_amount);\r\n    }\r\n\r\n    /// @dev track balances of any rewards going out of the token pool\r\n    function _distributeRewards(address _manufacturer, address _owner, uint256 _amount) internal {\r\n        require(_amount > 0, \"_amount is required\");\r\n        pools[_manufacturer].balance = pools[_manufacturer].balance.sub(_amount);\r\n        rewards[_owner] = rewards[_owner].add(_amount);\r\n    }\r\n\r\n    /// @dev ensure a device is validated for registration\r\n    /// @dev updates device registry\r\n    function _registerDevice(\r\n        address _manufacturer,\r\n        bytes32 _deviceIdHash,\r\n        bytes32 _deviceType,\r\n        bytes32 _devicePublicKey) internal returns (Device) {\r\n        require(_manufacturer != address(0), \"manufacturer is required\");\r\n        require(_deviceIdHash != 0, \"device id hash is required\");\r\n        require(_deviceType != 0, \"device type is required\");\r\n        require(_devicePublicKey != 0, \"device public key is required\");\r\n\r\n        Device storage d = devices[_deviceIdHash];\r\n        require(!d.registered, \"device is already registered\");\r\n        require(!d.activated, \"device is already activated\");\r\n\r\n        bytes32 manufacturerId = network[_manufacturer].memberId;\r\n        require(manufacturerId != 0, \"manufacturer id is unknown\");\r\n\r\n        d.manufacturerId = manufacturerId;\r\n        d.deviceType = _deviceType;\r\n        d.registered = true;\r\n        d.activated = false;\r\n        d.reputationScore = defaultManufacturerReputations[manufacturerId];\r\n        d.devicePublicKey = _devicePublicKey;\r\n        return d;\r\n    }\r\n\r\n    /// @dev ensure a device is validated for activation\r\n    /// @dev updates device registry\r\n    function _activateDevice(bytes32 _deviceId) internal returns (Device) {\r\n        bytes32 deviceIdHash = keccak256(_deviceId);\r\n        Device storage d = devices[deviceIdHash];\r\n        require(d.registered, \"not registered\");\r\n        require(!d.activated, \"already activated\");\r\n        require(d.manufacturerId != 0, \"no manufacturer id was found\");\r\n\r\n        d.activated = true;\r\n        return d;\r\n    }\r\n\r\n    /// @dev ensure a device is validated for a new reputation score\r\n    /// @dev updates device registry\r\n    function _updateReputationScore(bytes32 _deviceId, bytes32 _reputationScore) internal returns (Device) {\r\n        require(_deviceId != 0, \"device id is empty\");\r\n\r\n        Device storage d = devices[keccak256(_deviceId)];\r\n        require(d.registered, \"not registered\");\r\n        require(d.activated, \"not activated\");\r\n        require(d.reputationScore != _reputationScore, \"new score needs to be different\");\r\n\r\n        d.reputationScore = _reputationScore;\r\n        return d;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"manufacturerRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"},{\"name\":\"_isIRNAdmin\",\"type\":\"bool\"},{\"name\":\"_isManufacturer\",\"type\":\"bool\"},{\"name\":\"_isIRNNode\",\"type\":\"bool\"},{\"name\":\"_memberId\",\"type\":\"bytes32\"}],\"name\":\"addNetworkMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"name\":\"blocksSinceLastWrite\",\"type\":\"uint256\"}],\"name\":\"calculateReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manufacturerId\",\"type\":\"bytes32\"},{\"name\":\"_newDefaultScore\",\"type\":\"bytes32\"}],\"name\":\"setDefaultReputationForManufacturer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"author\",\"type\":\"address\"},{\"name\":\"manufacturer\",\"type\":\"address\"},{\"name\":\"deviceId\",\"type\":\"bytes32\"}],\"name\":\"getReputationRewards\",\"outputs\":[{\"name\":\"irnReward\",\"type\":\"uint256\"},{\"name\":\"manufacturerReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manufacturerId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newReward\",\"type\":\"uint256\"}],\"name\":\"setTokenPoolReward\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"_reputationScore\",\"type\":\"bytes32\"}],\"name\":\"updateReputationScore\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"defaultManufacturerReputations\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"}],\"name\":\"activateDevice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"name\":\"_deviceType\",\"type\":\"bytes32\"},{\"name\":\"_devicePublicKey\",\"type\":\"bytes32\"}],\"name\":\"registerAndActivateDevice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceIdHash\",\"type\":\"bytes32\"},{\"name\":\"_deviceType\",\"type\":\"bytes32\"},{\"name\":\"_devicePublicKey\",\"type\":\"bytes32\"}],\"name\":\"registerDevice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"changeManufacturerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_deviceIdHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_deviceTypes\",\"type\":\"bytes32[]\"},{\"name\":\"_devicePublicKeys\",\"type\":\"bytes32[]\"}],\"name\":\"registerDevices\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pools\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeNetworkMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"network\",\"outputs\":[{\"name\":\"isIRNAdmin\",\"type\":\"bool\"},{\"name\":\"isManufacturer\",\"type\":\"bool\"},{\"name\":\"isIRNNode\",\"type\":\"bool\"},{\"name\":\"memberId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"devices\",\"outputs\":[{\"name\":\"manufacturerId\",\"type\":\"bytes32\"},{\"name\":\"deviceType\",\"type\":\"bytes32\"},{\"name\":\"registered\",\"type\":\"bool\"},{\"name\":\"activated\",\"type\":\"bool\"},{\"name\":\"reputationScore\",\"type\":\"bytes32\"},{\"name\":\"devicePublicKey\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settings\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"authorWrites\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_settings\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_deviceHashKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_manufacturerId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_deviceType\",\"type\":\"bytes32\"}],\"name\":\"DeviceRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_fee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_manufacturerId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_deviceType\",\"type\":\"bytes32\"}],\"name\":\"DeviceActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_deviceId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_deviceType\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_newScore\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_irnNode\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_irnReward\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_manufacturerWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_manufacturerReward\",\"type\":\"uint256\"}],\"name\":\"ReputationScoreUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_member\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_memberId\",\"type\":\"bytes32\"}],\"name\":\"NetworkMemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_member\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_memberId\",\"type\":\"bytes32\"}],\"name\":\"NetworkMemberRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_new\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_manufacturerId\",\"type\":\"bytes32\"}],\"name\":\"ManufacturerRewardWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newReward\",\"type\":\"uint256\"}],\"name\":\"TokenPoolRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_manufacturerId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_manufacturer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_manufacturerId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_newDefaultScore\",\"type\":\"bytes32\"}],\"name\":\"DefaultReputationScoreChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Atonomi","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000097aeb5066e1a590e868b511457beb6fe99d329f50000000000000000000000002566c658331eac75d3b3ccd0e45c78d9cf6c4c4c","Library":"","SwarmSource":"bzzr://4d2ff784448524fb6edf8e9272a47100642593d626e1d13ec6015e6dfe28949b"}]}