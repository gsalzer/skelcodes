{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity^0.4.24;\r\n\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool); \r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address src) external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function allowance(address tokenOwner, address spender) external constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n}\r\n\r\ncontract Accounting {\r\n\r\n    using DSMath for uint;\r\n\r\n    bool internal _in;\r\n    \r\n    modifier noReentrance() {\r\n        require(!_in);\r\n        _in = true;\r\n        _;\r\n        _in = false;\r\n    }\r\n    \r\n    //keeping track of total ETH and token balances\r\n    uint public totalETH;\r\n    mapping (address => uint) public totalTokenBalances;\r\n\r\n    struct Account {\r\n        bytes32 name;\r\n        uint balanceETH;\r\n        mapping (address => uint) tokenBalances;\r\n    }\r\n\r\n    Account base = Account({\r\n        name: \"Base\",\r\n        balanceETH: 0       \r\n    });\r\n\r\n    event ETHDeposited(bytes32 indexed account, address indexed from, uint value);\r\n    event ETHSent(bytes32 indexed account, address indexed to, uint value);\r\n    event ETHTransferred(bytes32 indexed fromAccount, bytes32 indexed toAccount, uint value);\r\n    event TokenTransferred(bytes32 indexed fromAccount, bytes32 indexed toAccount, address indexed token, uint value);\r\n    event TokenDeposited(bytes32 indexed account, address indexed token, address indexed from, uint value);    \r\n    event TokenSent(bytes32 indexed account, address indexed token, address indexed to, uint value);\r\n\r\n    function baseETHBalance() public constant returns(uint) {\r\n        return base.balanceETH;\r\n    }\r\n\r\n    function baseTokenBalance(address token) public constant returns(uint) {\r\n        return base.tokenBalances[token];\r\n    }\r\n\r\n    function depositETH(Account storage a, address _from, uint _value) internal {\r\n        a.balanceETH = a.balanceETH.add(_value);\r\n        totalETH = totalETH.add(_value);\r\n        emit ETHDeposited(a.name, _from, _value);\r\n    }\r\n\r\n    function depositToken(Account storage a, address _token, address _from, uint _value) \r\n    internal noReentrance \r\n    {        \r\n        require(ERC20(_token).transferFrom(_from, address(this), _value));\r\n        totalTokenBalances[_token] = totalTokenBalances[_token].add(_value);\r\n        a.tokenBalances[_token] = a.tokenBalances[_token].add(_value);\r\n        emit TokenDeposited(a.name, _token, _from, _value);\r\n    }\r\n\r\n    function sendETH(Account storage a, address _to, uint _value) \r\n    internal noReentrance \r\n    {\r\n        require(a.balanceETH >= _value);\r\n        require(_to != address(0));\r\n        \r\n        a.balanceETH = a.balanceETH.sub(_value);\r\n        totalETH = totalETH.sub(_value);\r\n\r\n        _to.transfer(_value);\r\n        \r\n        emit ETHSent(a.name, _to, _value);\r\n    }\r\n\r\n    function transact(Account storage a, address _to, uint _value, bytes data) \r\n    internal noReentrance \r\n    {\r\n        require(a.balanceETH >= _value);\r\n        require(_to != address(0));\r\n        \r\n        a.balanceETH = a.balanceETH.sub(_value);\r\n        totalETH = totalETH.sub(_value);\r\n\r\n        require(_to.call.value(_value)(data));\r\n        \r\n        emit ETHSent(a.name, _to, _value);\r\n    }\r\n\r\n    function sendToken(Account storage a, address _token, address _to, uint _value) \r\n    internal noReentrance \r\n    {\r\n        require(a.tokenBalances[_token] >= _value);\r\n        require(_to != address(0));\r\n        \r\n        a.tokenBalances[_token] = a.tokenBalances[_token].sub(_value);\r\n        totalTokenBalances[_token] = totalTokenBalances[_token].sub(_value);\r\n\r\n        require(ERC20(_token).transfer(_to, _value));\r\n        emit TokenSent(a.name, _token, _to, _value);\r\n    }\r\n\r\n    function transferETH(Account storage _from, Account storage _to, uint _value) \r\n    internal \r\n    {\r\n        require(_from.balanceETH >= _value);\r\n        _from.balanceETH = _from.balanceETH.sub(_value);\r\n        _to.balanceETH = _to.balanceETH.add(_value);\r\n        emit ETHTransferred(_from.name, _to.name, _value);\r\n    }\r\n\r\n    function transferToken(Account storage _from, Account storage _to, address _token, uint _value)\r\n    internal\r\n    {\r\n        require(_from.tokenBalances[_token] >= _value);\r\n        _from.tokenBalances[_token] = _from.tokenBalances[_token].sub(_value);\r\n        _to.tokenBalances[_token] = _to.tokenBalances[_token].add(_value);\r\n        emit TokenTransferred(_from.name, _to.name, _token, _value);\r\n    }\r\n\r\n    function balanceETH(Account storage toAccount,  uint _value) internal {\r\n        require(address(this).balance >= totalETH.add(_value));\r\n        depositETH(toAccount, address(this), _value);\r\n    }\r\n\r\n    function balanceToken(Account storage toAccount, address _token, uint _value) internal noReentrance {\r\n        uint balance = ERC20(_token).balanceOf(this);\r\n        require(balance >= totalTokenBalances[_token].add(_value));\r\n\r\n        toAccount.tokenBalances[_token] = toAccount.tokenBalances[_token].add(_value);\r\n        emit TokenDeposited(toAccount.name, _token, address(this), _value);\r\n    }\r\n    \r\n}\r\n\r\n\r\n///Base contract with all the events, getters, and simple logic\r\ncontract ButtonBase is DSAuth, Accounting {\r\n    ///Using a the original DSMath as a library\r\n    using DSMath for uint;\r\n\r\n    uint constant ONE_PERCENT_WAD = 10 ** 16;// 1 wad is 10^18, so 1% in wad is 10^16\r\n    uint constant ONE_WAD = 10 ** 18;\r\n\r\n    uint public totalRevenue;\r\n    uint public totalCharity;\r\n    uint public totalWon;\r\n\r\n    uint public totalPresses;\r\n\r\n    ///Button parameters - note that these can change\r\n    uint public startingPrice = 2 finney;\r\n    uint internal _priceMultiplier = 106 * 10 **16;\r\n    uint32 internal _n = 4; //increase the price after every n presses\r\n    uint32 internal _period = 30 minutes;// what's the period for pressing the button\r\n    uint internal _newCampaignFraction = ONE_PERCENT_WAD; //1%\r\n    uint internal _devFraction = 10 * ONE_PERCENT_WAD - _newCampaignFraction; //9%\r\n    uint internal _charityFraction = 5 * ONE_PERCENT_WAD; //5%\r\n    uint internal _jackpotFraction = 85 * ONE_PERCENT_WAD; //85%\r\n    \r\n    address public charityBeneficiary;\r\n\r\n    ///Internal accounts to hold value:\r\n    Account revenue = \r\n    Account({\r\n        name: \"Revenue\",\r\n        balanceETH: 0\r\n    });\r\n\r\n    Account nextCampaign = \r\n    Account({\r\n        name: \"Next Campaign\",\r\n        balanceETH: 0       \r\n    });\r\n\r\n    Account charity = \r\n    Account({\r\n        name: \"Charity\",\r\n        balanceETH: 0\r\n    });\r\n\r\n    ///Accounts of winners\r\n    mapping (address => Account) winners;\r\n\r\n    /// Function modifier to put limits on how values can be set\r\n    modifier limited(uint value, uint min, uint max) {\r\n        require(value >= min && value <= max);\r\n        _;\r\n    }\r\n\r\n    /// A function modifier which limits how often a function can be executed\r\n    mapping (bytes4 => uint) internal _lastExecuted;\r\n    modifier timeLimited(uint _howOften) {\r\n        require(_lastExecuted[msg.sig].add(_howOften) <= now);\r\n        _lastExecuted[msg.sig] = now;\r\n        _;\r\n    }\r\n\r\n    ///Button events\r\n    event Pressed(address by, uint paid, uint64 timeLeft);\r\n    event Started(uint startingETH, uint32 period, uint i);\r\n    event Winrar(address guy, uint jackpot);\r\n    ///Settings changed events\r\n    event CharityChanged(address newCharityBeneficiary);\r\n    event ButtonParamsChanged(uint startingPrice, uint32 n, uint32 period, uint priceMul);\r\n    event AccountingParamsChanged(uint devFraction, uint charityFraction, uint jackpotFraction);\r\n\r\n    ///Struct that represents a button champaign\r\n    struct ButtonCampaign {\r\n        uint price; ///Every campaign starts with some price  \r\n        uint priceMultiplier;/// Price will be increased by this much every n presses\r\n        uint devFraction; /// this much will go to the devs (10^16 = 1%)\r\n        uint charityFraction;/// This much will go to charity\r\n        uint jackpotFraction;/// This much will go to the winner (last presser)\r\n        uint newCampaignFraction;/// This much will go to the next campaign starting balance\r\n\r\n        address lastPresser;\r\n        uint64 deadline;\r\n        uint40 presses;\r\n        uint32 n;\r\n        uint32 period;\r\n        bool finalized;\r\n\r\n        Account total;/// base account to hold all the value until the campaign is finalized \r\n    }\r\n\r\n    uint public lastCampaignID;\r\n    ButtonCampaign[] campaigns;\r\n\r\n    /// implemented in the child contract\r\n    function press() public payable;\r\n    \r\n    function () public payable {\r\n        press();\r\n    }\r\n\r\n    ///Getters:\r\n\r\n    ///Check if there's an active campaign\r\n    function active() public view returns(bool) {\r\n        if(campaigns.length == 0) { \r\n            return false;\r\n        } else {\r\n            return campaigns[lastCampaignID].deadline >= now;\r\n        }\r\n    }\r\n\r\n    ///Get information about the latest campaign or the next campaign if the last campaign has ended, but no new one has started\r\n    function latestData() external view returns(\r\n        uint price, uint jackpot, uint char, uint64 deadline, uint presses, address lastPresser\r\n        ) {\r\n        price = this.price();\r\n        jackpot = this.jackpot();\r\n        char = this.charityBalance();\r\n        deadline = this.deadline();\r\n        presses = this.presses();\r\n        lastPresser = this.lastPresser();\r\n    }\r\n\r\n    ///Get the latest parameters\r\n    function latestParams() external view returns(\r\n        uint jackF, uint revF, uint charF, uint priceMul, uint nParam\r\n    ) {\r\n        jackF = this.jackpotFraction();\r\n        revF = this.revenueFraction();\r\n        charF = this.charityFraction();\r\n        priceMul = this.priceMultiplier();\r\n        nParam = this.n();\r\n    }\r\n\r\n    ///Get the last winner address\r\n    function lastWinner() external view returns(address) {\r\n        if(campaigns.length == 0) {\r\n            return address(0x0);\r\n        } else {\r\n            if(active()) {\r\n                return this.winner(lastCampaignID - 1);\r\n            } else {\r\n                return this.winner(lastCampaignID);\r\n            }\r\n        }\r\n    }\r\n\r\n    ///Get the total stats (cumulative for all campaigns)\r\n    function totalsData() external view returns(uint _totalWon, uint _totalCharity, uint _totalPresses) {\r\n        _totalWon = this.totalWon();\r\n        _totalCharity = this.totalCharity();\r\n        _totalPresses = this.totalPresses();\r\n    }\r\n   \r\n   /// The latest price for pressing the button\r\n    function price() external view returns(uint) {\r\n        if(active()) {\r\n            return campaigns[lastCampaignID].price;\r\n        } else {\r\n            return startingPrice;\r\n        }\r\n    }\r\n\r\n    /// The latest jackpot fraction - note the fractions can be changed, but they don't affect any currently running campaign\r\n    function jackpotFraction() public view returns(uint) {\r\n        if(active()) {\r\n            return campaigns[lastCampaignID].jackpotFraction;\r\n        } else {\r\n            return _jackpotFraction;\r\n        }\r\n    }\r\n\r\n    /// The latest revenue fraction\r\n    function revenueFraction() public view returns(uint) {\r\n        if(active()) {\r\n            return campaigns[lastCampaignID].devFraction;\r\n        } else {\r\n            return _devFraction;\r\n        }\r\n    }\r\n\r\n    /// The latest charity fraction\r\n    function charityFraction() public view returns(uint) {\r\n        if(active()) {\r\n            return campaigns[lastCampaignID].charityFraction;\r\n        } else {\r\n            return _charityFraction;\r\n        }\r\n    }\r\n\r\n    /// The latest price multiplier\r\n    function priceMultiplier() public view returns(uint) {\r\n        if(active()) {\r\n            return campaigns[lastCampaignID].priceMultiplier;\r\n        } else {\r\n            return _priceMultiplier;\r\n        }\r\n    }\r\n\r\n    /// The latest preiod\r\n    function period() public view returns(uint) {\r\n        if(active()) {\r\n            return campaigns[lastCampaignID].period;\r\n        } else {\r\n            return _period;\r\n        }\r\n    }\r\n\r\n    /// The latest N - the price will increase every Nth presses\r\n    function n() public view returns(uint) {\r\n        if(active()) {\r\n            return campaigns[lastCampaignID].n;\r\n        } else {\r\n            return _n;\r\n        }\r\n    }\r\n\r\n    /// How much time is left in seconds if there's a running campaign\r\n    function timeLeft() external view returns(uint) {\r\n        if (active()) {\r\n            return campaigns[lastCampaignID].deadline - now;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /// What is the latest campaign's deadline\r\n    function deadline() external view returns(uint64) {\r\n        return campaigns[lastCampaignID].deadline;\r\n    }\r\n\r\n    /// The number of presses for the current campaign\r\n    function presses() external view returns(uint) {\r\n        if(active()) {\r\n            return campaigns[lastCampaignID].presses;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /// Last presser\r\n    function lastPresser() external view returns(address) {\r\n        return campaigns[lastCampaignID].lastPresser;\r\n    }\r\n\r\n    /// Returns the winner for any given campaign ID\r\n    function winner(uint campaignID) external view returns(address) {\r\n        return campaigns[campaignID].lastPresser;\r\n    }\r\n\r\n    /// The current (or next) campaign's jackpot\r\n    function jackpot() external view returns(uint) {\r\n        if(active()){\r\n            return campaigns[lastCampaignID].total.balanceETH.wmul(campaigns[lastCampaignID].jackpotFraction);\r\n        } else {\r\n            if(!campaigns[lastCampaignID].finalized) {\r\n                return campaigns[lastCampaignID].total.balanceETH.wmul(campaigns[lastCampaignID].jackpotFraction)\r\n                    .wmul(campaigns[lastCampaignID].newCampaignFraction);\r\n            } else {\r\n                return nextCampaign.balanceETH.wmul(_jackpotFraction);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Current/next campaign charity balance\r\n    function charityBalance() external view returns(uint) {\r\n        if(active()){\r\n            return campaigns[lastCampaignID].total.balanceETH.wmul(campaigns[lastCampaignID].charityFraction);\r\n        } else {\r\n            if(!campaigns[lastCampaignID].finalized) {\r\n                return campaigns[lastCampaignID].total.balanceETH.wmul(campaigns[lastCampaignID].charityFraction)\r\n                    .wmul(campaigns[lastCampaignID].newCampaignFraction);\r\n            } else {\r\n                return nextCampaign.balanceETH.wmul(_charityFraction);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Revenue account current balance\r\n    function revenueBalance() external view returns(uint) {\r\n        return revenue.balanceETH;\r\n    }\r\n\r\n    /// The starting balance of the next campaign\r\n    function nextCampaignBalance() external view returns(uint) {        \r\n        if(!campaigns[lastCampaignID].finalized) {\r\n            return campaigns[lastCampaignID].total.balanceETH.wmul(campaigns[lastCampaignID].newCampaignFraction);\r\n        } else {\r\n            return nextCampaign.balanceETH;\r\n        }\r\n    }\r\n\r\n    /// Total cumulative presses for all campaigns\r\n    function totalPresses() external view returns(uint) {\r\n        if (!campaigns[lastCampaignID].finalized) {\r\n            return totalPresses.add(campaigns[lastCampaignID].presses);\r\n        } else {\r\n            return totalPresses;\r\n        }\r\n    }\r\n\r\n    /// Total cumulative charity for all campaigns\r\n    function totalCharity() external view returns(uint) {\r\n        if (!campaigns[lastCampaignID].finalized) {\r\n            return totalCharity.add(campaigns[lastCampaignID].total.balanceETH.wmul(campaigns[lastCampaignID].charityFraction));\r\n        } else {\r\n            return totalCharity;\r\n        }\r\n    }\r\n\r\n    /// Total cumulative revenue for all campaigns\r\n    function totalRevenue() external view returns(uint) {\r\n        if (!campaigns[lastCampaignID].finalized) {\r\n            return totalRevenue.add(campaigns[lastCampaignID].total.balanceETH.wmul(campaigns[lastCampaignID].devFraction));\r\n        } else {\r\n            return totalRevenue;\r\n        }\r\n    }\r\n\r\n    /// Returns the balance of any winner\r\n    function hasWon(address _guy) external view returns(uint) {\r\n        return winners[_guy].balanceETH;\r\n    }\r\n\r\n    /// Functions for handling value\r\n\r\n    /// Withdrawal function for winners\r\n    function withdrawJackpot() public {\r\n        require(winners[msg.sender].balanceETH > 0, \"Nothing to withdraw!\");\r\n        sendETH(winners[msg.sender], msg.sender, winners[msg.sender].balanceETH);\r\n    }\r\n\r\n    /// Any winner can chose to donate their jackpot\r\n    function donateJackpot() public {\r\n        require(winners[msg.sender].balanceETH > 0, \"Nothing to donate!\");\r\n        transferETH(winners[msg.sender], charity, winners[msg.sender].balanceETH);\r\n    }\r\n\r\n    /// Dev revenue withdrawal function\r\n    function withdrawRevenue() public auth {\r\n        sendETH(revenue, owner, revenue.balanceETH);\r\n    }\r\n\r\n    /// Dev charity transfer function - sends all of the charity balance to the pre-set charity address\r\n    /// Note that there's nothing stopping the devs to wait and set the charity beneficiary to their own address\r\n    /// and drain the charity balance for themselves. We would not do that as it would not make sense and it would\r\n    /// damage our reputation, but this is the only \"weak\" spot of the contract where it requires trust in the devs\r\n    function sendCharityETH(bytes callData) public auth {\r\n        // donation receiver might be a contract, so transact instead of a simple send\r\n        transact(charity, charityBeneficiary, charity.balanceETH, callData);\r\n    }\r\n\r\n    /// This allows the owner to withdraw surplus ETH\r\n    function redeemSurplusETH() public auth {\r\n        uint surplus = address(this).balance.sub(totalETH);\r\n        balanceETH(base, surplus);\r\n        sendETH(base, msg.sender, base.balanceETH);\r\n    }\r\n\r\n    /// This allows the owner to withdraw surplus Tokens\r\n    function redeemSurplusERC20(address token) public auth {\r\n        uint realTokenBalance = ERC20(token).balanceOf(this);\r\n        uint surplus = realTokenBalance.sub(totalTokenBalances[token]);\r\n        balanceToken(base, token, surplus);\r\n        sendToken(base, token, msg.sender, base.tokenBalances[token]);\r\n    }\r\n\r\n    /// withdraw surplus ETH\r\n    function withdrawBaseETH() public auth {\r\n        sendETH(base, msg.sender, base.balanceETH);\r\n    }\r\n\r\n    /// withdraw surplus tokens\r\n    function withdrawBaseERC20(address token) public auth {\r\n        sendToken(base, token, msg.sender, base.tokenBalances[token]);\r\n    }\r\n\r\n    ///Setters\r\n\r\n    /// Set button parameters\r\n    function setButtonParams(uint startingPrice_, uint priceMul_, uint32 period_, uint32 n_) public \r\n    auth\r\n    limited(startingPrice_, 1 szabo, 10 ether) ///Parameters are limited\r\n    limited(priceMul_, ONE_WAD, 10 * ONE_WAD) // 100% to 10000% (1x to 10x)\r\n    limited(period_, 30 seconds, 1 weeks)\r\n    {\r\n        startingPrice = startingPrice_;\r\n        _priceMultiplier = priceMul_;\r\n        _period = period_;\r\n        _n = n_;\r\n        emit ButtonParamsChanged(startingPrice_, n_, period_, priceMul_);\r\n    }\r\n\r\n    /// Fractions must add up to 100%, and can only be set every 2 weeks\r\n    function setAccountingParams(uint _devF, uint _charityF, uint _newCampF) public \r\n    auth\r\n    limited(_devF.add(_charityF).add(_newCampF), 0, ONE_WAD) // up to 100% - charity fraction could be set to 100% for special occasions\r\n    timeLimited(2 weeks) { // can only be changed once every 4 weeks\r\n        require(_charityF <= ONE_WAD); // charity fraction can be up to 100%\r\n        require(_devF <= 20 * ONE_PERCENT_WAD); //can't set the dev fraction to more than 20%\r\n        require(_newCampF <= 10 * ONE_PERCENT_WAD);//less than 10%\r\n        _devFraction = _devF;\r\n        _charityFraction = _charityF;\r\n        _newCampaignFraction = _newCampF;\r\n        _jackpotFraction = ONE_WAD.sub(_devF).sub(_charityF).sub(_newCampF);\r\n        emit AccountingParamsChanged(_devF, _charityF, _jackpotFraction);\r\n    }\r\n\r\n    ///Charity beneficiary can only be changed every 13 weeks\r\n    function setCharityBeneficiary(address _charity) public \r\n    auth\r\n    timeLimited(13 weeks) \r\n    {   \r\n        require(_charity != address(0));\r\n        charityBeneficiary = _charity;\r\n        emit CharityChanged(_charity);\r\n    }\r\n\r\n}\r\n\r\n/// Main contract with key logic\r\ncontract TheButton is ButtonBase {\r\n    \r\n    using DSMath for uint;\r\n\r\n    ///If the contract is stopped no new campaigns can be started, but any running campaing is not affected\r\n    bool public stopped;\r\n\r\n    constructor() public {\r\n        stopped = true;\r\n    }\r\n\r\n    /// Press logic\r\n    function press() public payable {\r\n        //the last campaign\r\n        ButtonCampaign storage c = campaigns[lastCampaignID];\r\n        if (active()) {// if active\r\n            _press(c);//register press\r\n            depositETH(c.total, msg.sender, msg.value);// handle ETH\r\n        } else { //if inactive (after deadline)\r\n            require(!stopped, \"Contract stopped!\");//make sure we're not stopped\r\n            if(!c.finalized) {//if not finalized\r\n                _finalizeCampaign(c);// finalize last campaign\r\n            } \r\n            _newCampaign();// start new campaign\r\n            c = campaigns[lastCampaignID];\r\n                    \r\n            _press(c);//resigter press\r\n            depositETH(c.total, msg.sender, msg.value);//handle ETH\r\n        } \r\n    }\r\n\r\n    function start() external payable auth {\r\n        require(stopped, \"Already started!\");\r\n        stopped = false;\r\n        \r\n        if(campaigns.length != 0) {//if there was a past campaign\r\n            ButtonCampaign storage c = campaigns[lastCampaignID];\r\n            require(c.finalized, \"Last campaign not finalized!\");//make sure it was finalized\r\n        }             \r\n        _newCampaign();//start new campaign\r\n        c = campaigns[lastCampaignID];\r\n        _press(c);\r\n        depositETH(c.total, msg.sender, msg.value);// deposit ETH        \r\n    }\r\n\r\n    ///Stopping will only affect new campaigns, not already running ones\r\n    function stop() external auth {\r\n        require(!stopped, \"Already stopped!\");\r\n        stopped = true;\r\n    }\r\n    \r\n    /// Anyone can finalize campaigns in case the devs stop the contract\r\n    function finalizeLastCampaign() external {\r\n        require(stopped);\r\n        ButtonCampaign storage c = campaigns[lastCampaignID];\r\n        _finalizeCampaign(c);\r\n    }\r\n\r\n    function finalizeCampaign(uint id) external {\r\n        require(stopped);\r\n        ButtonCampaign storage c = campaigns[id];\r\n        _finalizeCampaign(c);\r\n    }\r\n\r\n    //Press logic\r\n    function _press(ButtonCampaign storage c) internal {\r\n        require(c.deadline >= now, \"After deadline!\");//must be before the deadline\r\n        require(msg.value >= c.price, \"Not enough value!\");// must have at least the price value\r\n        c.presses += 1;//no need for safe math, as it is not a critical calculation\r\n        c.lastPresser = msg.sender;\r\n             \r\n        if(c.presses % c.n == 0) {// increase the price every n presses\r\n            c.price = c.price.wmul(c.priceMultiplier);\r\n        }           \r\n\r\n        emit Pressed(msg.sender, msg.value, c.deadline - uint64(now));\r\n        c.deadline = uint64(now.add(c.period)); // set the new deadline\r\n    }\r\n\r\n    /// starting a new campaign\r\n    function _newCampaign() internal {\r\n        require(!active(), \"A campaign is already running!\");\r\n        require(_devFraction.add(_charityFraction).add(_jackpotFraction).add(_newCampaignFraction) == ONE_WAD, \"Accounting is incorrect!\");\r\n        \r\n        uint _campaignID = campaigns.length++;\r\n        ButtonCampaign storage c = campaigns[_campaignID];\r\n        lastCampaignID = _campaignID;\r\n\r\n        c.price = startingPrice;\r\n        c.priceMultiplier = _priceMultiplier;\r\n        c.devFraction = _devFraction;\r\n        c.charityFraction = _charityFraction;\r\n        c.jackpotFraction = _jackpotFraction;\r\n        c.newCampaignFraction = _newCampaignFraction;\r\n        c.deadline = uint64(now.add(_period));\r\n        c.n = _n;\r\n        c.period = _period;\r\n        c.total.name = keccak256(abi.encodePacked(\"Total\", lastCampaignID));//setting the name of the campaign's accaount     \r\n        transferETH(nextCampaign, c.total, nextCampaign.balanceETH);\r\n        emit Started(c.total.balanceETH, _period, lastCampaignID); \r\n    }\r\n\r\n    /// Finalize campaign logic\r\n    function _finalizeCampaign(ButtonCampaign storage c) internal {\r\n        require(c.deadline < now, \"Before deadline!\");\r\n        require(!c.finalized, \"Already finalized!\");\r\n        \r\n        if(c.presses != 0) {//If there were presses\r\n            uint totalBalance = c.total.balanceETH;\r\n            //Handle all of the accounting            \r\n            transferETH(c.total, winners[c.lastPresser], totalBalance.wmul(c.jackpotFraction));\r\n            winners[c.lastPresser].name = bytes32(c.lastPresser);\r\n            totalWon = totalWon.add(totalBalance.wmul(c.jackpotFraction));\r\n\r\n            transferETH(c.total, revenue, totalBalance.wmul(c.devFraction));\r\n            totalRevenue = totalRevenue.add(totalBalance.wmul(c.devFraction));\r\n\r\n            transferETH(c.total, charity, totalBalance.wmul(c.charityFraction));\r\n            totalCharity = totalCharity.add(totalBalance.wmul(c.charityFraction));\r\n\r\n            //avoiding rounding errors - just transfer the leftover\r\n            // transferETH(c.total, nextCampaign, c.total.balanceETH);\r\n\r\n            totalPresses = totalPresses.add(c.presses);\r\n\r\n            emit Winrar(c.lastPresser, totalBalance.wmul(c.jackpotFraction));\r\n        } \r\n        // if there will be no next campaign\r\n        if(stopped) {\r\n            //transfer leftover to devs' base account\r\n            transferETH(c.total, base, c.total.balanceETH);\r\n        } else {\r\n            //otherwise transfer to next campaign\r\n            transferETH(c.total, nextCampaign, c.total.balanceETH);\r\n        }\r\n        c.finalized = true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextCampaignBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revenueFraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestData\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"char\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint64\"},{\"name\":\"presses\",\"type\":\"uint256\"},{\"name\":\"lastPresser\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestParams\",\"outputs\":[{\"name\":\"jackF\",\"type\":\"uint256\"},{\"name\":\"revF\",\"type\":\"uint256\"},{\"name\":\"charF\",\"type\":\"uint256\"},{\"name\":\"priceMul\",\"type\":\"uint256\"},{\"name\":\"nParam\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"campaignID\",\"type\":\"uint256\"}],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPresses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"n\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRevenue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"press\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_charity\",\"type\":\"address\"}],\"name\":\"setCharityBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"finalizeCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotFraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"charityBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"redeemSurplusERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"charityBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemSurplusETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalTokenBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_guy\",\"type\":\"address\"}],\"name\":\"hasWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revenueBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startingPrice_\",\"type\":\"uint256\"},{\"name\":\"priceMul_\",\"type\":\"uint256\"},{\"name\":\"period_\",\"type\":\"uint32\"},{\"name\":\"n_\",\"type\":\"uint32\"}],\"name\":\"setButtonParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawBaseERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"baseTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRevenue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseETHBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCharity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBaseETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_devF\",\"type\":\"uint256\"},{\"name\":\"_charityF\",\"type\":\"uint256\"},{\"name\":\"_newCampF\",\"type\":\"uint256\"}],\"name\":\"setAccountingParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCampaignID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPresser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeLastCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"charityFraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"sendCharityETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalsData\",\"outputs\":[{\"name\":\"_totalWon\",\"type\":\"uint256\"},{\"name\":\"_totalCharity\",\"type\":\"uint256\"},{\"name\":\"_totalPresses\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"paid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeLeft\",\"type\":\"uint64\"}],\"name\":\"Pressed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startingETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"Winrar\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newCharityBeneficiary\",\"type\":\"address\"}],\"name\":\"CharityChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"n\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"period\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"priceMul\",\"type\":\"uint256\"}],\"name\":\"ButtonParamsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"devFraction\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"charityFraction\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"jackpotFraction\",\"type\":\"uint256\"}],\"name\":\"AccountingParamsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ETHDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ETHSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAccount\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"toAccount\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ETHTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAccount\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"toAccount\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"TheButton","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://afe0ed8a03cbfe0653593a76f81941e2b57b87e9322b15135418a61449d686a8"}]}