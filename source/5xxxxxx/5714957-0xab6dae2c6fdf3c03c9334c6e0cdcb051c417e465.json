{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Administratable is Ownable {\r\n    mapping (address => bool) admins;\r\n\r\n    event AdminAdded(address indexed _admin);\r\n\r\n    event AdminRemoved(address indexed _admin);\r\n\r\n    modifier onlyAdmin() {\r\n        require(admins[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function addAdmin(address _addressToAdd) external onlyOwner {\r\n        require(_addressToAdd != address(0));\r\n        admins[_addressToAdd] = true;\r\n\r\n        emit AdminAdded(_addressToAdd);\r\n    }\r\n\r\n    function removeAdmin(address _addressToRemove) external onlyOwner {\r\n        require(_addressToRemove != address(0));\r\n        admins[_addressToRemove] = false;\r\n\r\n        emit AdminRemoved(_addressToRemove);\r\n    }\r\n}\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\ncontract ERC865 is ERC20 {\r\n\r\n    function transferPreSigned(\r\n        bytes _signature,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function approvePreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function increaseApprovalPreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _addedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function decreaseApprovalPreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _subtractedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function transferFromPreSigned(\r\n        bytes _signature,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function revokeSignature(bytes _signature)\r\n    public\r\n    returns (bool);\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20  {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  mapping(address => uint256) public balances;\r\n\r\n  uint256 _totalSupply;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC865Token is ERC865, StandardToken {\r\n\r\n    /* Nonces of transfers performed */\r\n    mapping(bytes => bool) nonces;\r\n\r\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\r\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\r\n    event SignatureRevoked(bytes signature, address indexed from);\r\n\r\n    /**\r\n     * @notice Submit a presigned transfer\r\n     * @param _signature bytes The signature, issued by the owner.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function transferPreSigned(\r\n        bytes _signature,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(!nonces[_signature]);\r\n\r\n        bytes32 hashedTx = transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\r\n\r\n        address from = recover(hashedTx, _signature);\r\n        require(from != address(0));\r\n\r\n        nonces[_signature] = true;\r\n\r\n        balances[from] = balances[from].sub(_value).sub(_fee);\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[msg.sender] = balances[msg.sender].add(_fee);\r\n\r\n        emit Transfer(from, _to, _value);\r\n        emit Transfer(from, msg.sender, _fee);\r\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Submit a presigned approval\r\n     * @param _signature bytes The signature, issued by the owner.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _value uint256 The amount of tokens to allow.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function approvePreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_spender != address(0));\r\n        require(!nonces[_signature]);\r\n\r\n        bytes32 hashedTx = approvePreSignedHashing(address(this), _spender, _value, _fee, _nonce);\r\n        address from = recover(hashedTx, _signature);\r\n        require(from != address(0));\r\n\r\n        nonces[_signature] = true;\r\n\r\n        allowed[from][_spender] = _value;\r\n        balances[from] = balances[from].sub(_fee);\r\n        balances[msg.sender] = balances[msg.sender].add(_fee);\r\n\r\n        emit Approval(from, _spender, _value);\r\n        emit Transfer(from, msg.sender, _fee);\r\n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Increase the amount of tokens that an owner allowed to a spender.\r\n     * @param _signature bytes The signature, issued by the owner.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function increaseApprovalPreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _addedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_spender != address(0));\r\n        require(!nonces[_signature]);\r\n\r\n        bytes32 hashedTx = increaseApprovalPreSignedHashing(address(this), _spender, _addedValue, _fee, _nonce);\r\n        address from = recover(hashedTx, _signature);\r\n        require(from != address(0));\r\n\r\n        nonces[_signature] = true;\r\n\r\n        allowed[from][_spender] = allowed[from][_spender].add(_addedValue);\r\n        balances[from] = balances[from].sub(_fee);\r\n        balances[msg.sender] = balances[msg.sender].add(_fee);\r\n\r\n        emit Approval(from, _spender, allowed[from][_spender]);\r\n        emit Transfer(from, msg.sender, _fee);\r\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Decrease the amount of tokens that an owner allowed to a spender.\r\n     * @param _signature bytes The signature, issued by the owner\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function decreaseApprovalPreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _subtractedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_spender != address(0));\r\n        require(!nonces[_signature]);\r\n\r\n        bytes32 hashedTx = decreaseApprovalPreSignedHashing(address(this), _spender, _subtractedValue, _fee, _nonce);\r\n        address from = recover(hashedTx, _signature);\r\n        require(from != address(0));\r\n\r\n        nonces[_signature] = true;\r\n\r\n        uint oldValue = allowed[from][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[from][_spender] = 0;\r\n        } else {\r\n            allowed[from][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        balances[from] = balances[from].sub(_fee);\r\n        balances[msg.sender] = balances[msg.sender].add(_fee);\r\n\r\n        emit Approval(from, _spender, _subtractedValue);\r\n        emit Transfer(from, msg.sender, _fee);\r\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowed[from][_spender], _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from one address to another\r\n     * @param _signature bytes The signature, issued by the spender.\r\n     * @param _from address The address which you want to send tokens from.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function transferFromPreSigned(\r\n        bytes _signature,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(!nonces[_signature]);\r\n\r\n        bytes32 hashedTx = transferFromPreSignedHashing(address(this), _from, _to, _value, _fee, _nonce);\r\n\r\n        address spender = recover(hashedTx, _signature);\r\n        require(spender != address(0));\r\n\r\n        nonces[_signature] = true;\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][spender] = allowed[_from][spender].sub(_value);\r\n\r\n        balances[spender] = balances[spender].sub(_fee);\r\n        balances[msg.sender] = balances[msg.sender].add(_fee);\r\n        nonces[_signature] = true;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        emit Transfer(spender, msg.sender, _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Revote previously approved signature\r\n     * @param  _signature bytes The signature to revoke\r\n     * @return bool  Returns true if revocation was successful\r\n     */\r\n    function revokeSignature(bytes _signature) public returns (bool) {\r\n        require(!nonces[_signature]);\r\n        nonces[_signature] = true;\r\n\r\n        emit SignatureRevoked(_signature, msg.sender);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Hash (keccak256) of the payload used by transferPreSigned\r\n     * @param _token address The address of the token.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function transferPreSignedHashing(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"48664c16\": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */\r\n        return keccak256(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Hash (keccak256) of the payload used by approvePreSigned\r\n     * @param _token address The address of the token\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _value uint256 The amount of tokens to allow.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function approvePreSignedHashing(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"f7ac9c2e\": approvePreSignedHashing(address,address,uint256,uint256,uint256) */\r\n        return keccak256(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Hash (keccak256) of the payload used by increaseApprovalPreSigned\r\n     * @param _token address The address of the token\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function increaseApprovalPreSignedHashing(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _addedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"a45f71ff\": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\r\n        return keccak256(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce);\r\n    }\r\n\r\n     /**\r\n      * @notice Hash (keccak256) of the payload used by decreaseApprovalPreSigned\r\n      * @param _token address The address of the token\r\n      * @param _spender address The address which will spend the funds.\r\n      * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\r\n      * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n      * @param _nonce uint256 Presigned transaction number.\r\n      */\r\n    function decreaseApprovalPreSignedHashing(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _subtractedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"59388d78\": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */\r\n        return keccak256(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Hash (keccak256) of the payload used by transferFromPreSigned\r\n     * @param _token address The address of the token\r\n     * @param _from address The address which you want to send tokens from.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function transferFromPreSignedHashing(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"b7656dc5\": transferFromPreSignedHashing(address,address,address,uint256,uint256,uint256) */\r\n        return keccak256(bytes4(0xb7656dc5), _token, _from, _to, _value, _fee, _nonce);\r\n    }\r\n\r\n    /**\r\n     * @notice Recover signer address from a message by using his signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n      bytes32 r;\r\n      bytes32 s;\r\n      uint8 v;\r\n\r\n      //Check the signature length\r\n      if (sig.length != 65) {\r\n        return (address(0));\r\n      }\r\n\r\n      // Divide the signature in r, s and v variables\r\n      assembly {\r\n        r := mload(add(sig, 32))\r\n        s := mload(add(sig, 64))\r\n        v := byte(0, mload(add(sig, 96)))\r\n      }\r\n\r\n      // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n      if (v < 27) {\r\n        v += 27;\r\n      }\r\n\r\n      // If the version is correct return the signer address\r\n      if (v != 27 && v != 28) {\r\n        return (address(0));\r\n      } else {\r\n        return ecrecover(hash, v, r, s);\r\n      }\r\n    }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Paused();\r\n    event Unpaused();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n}\r\n\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // How many token units a buyer gets per wei\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  // Amount of token sold in wei\r\n  uint256 public tokenWeiSold;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per wei\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n  constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n    tokenWeiSold = tokenWeiSold.add(tokens);\r\n\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n\r\n    _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(_beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) pure internal {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n    token.transfer(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Nu mber of tokens to be purchased\r\n   */\r\n  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n    _deliverTokens(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) pure internal {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n    return _weiAmount.mul(rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\ncontract AllowanceCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  address public tokenWallet;\r\n\r\n  /**\r\n   * @dev Constructor, takes token wallet address.\r\n   * @param _tokenWallet Address holding the tokens, which has approved allowance to the crowdsale\r\n   */\r\n  constructor(address _tokenWallet) public {\r\n    require(_tokenWallet != address(0));\r\n    tokenWallet = _tokenWallet;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks the amount of tokens left in the allowance.\r\n   * @return Amount of tokens left in the allowance\r\n   */\r\n  function remainingTokens() public view returns (uint256) {\r\n    return token.allowance(tokenWallet, this);\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides parent behavior by transferring tokens from wallet.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _tokenAmount Amount of tokens purchased\r\n   */\r\n  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n    token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);\r\n  }\r\n}\r\ncontract CappedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public cap;\r\n\r\n    /**\r\n    * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\r\n    * @param _cap Max amount of wei to be contributed\r\n    */\r\n    constructor(uint256 _cap) public {\r\n        require(_cap > 0);\r\n        cap = _cap;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks whether the cap has been reached.\r\n    * @return Whether the cap was reached\r\n    */\r\n    function capReached() public view returns (bool) {\r\n        return weiRaised >= cap;\r\n    }\r\n\r\n    /**\r\n    * @dev Extend parent behavior requiring purchase to respect the funding cap.\r\n    * @param _beneficiary Token purchaser\r\n    * @param _weiAmount Amount of wei contributed\r\n    */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount);\r\n        require(weiRaised.add(_weiAmount) <= cap);\r\n    }\r\n\r\n}\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\ncontract WhitelistedCrowdsale is Crowdsale, Administratable {\r\n\r\n  mapping(address => bool) public whitelist;\r\n\r\n  /**\r\n   * Event for logging adding to whitelist\r\n   * @param _address the address to add to the whitelist\r\n   */\r\n  event AddedToWhitelist(address indexed _address);\r\n\r\n  /**\r\n   * Event for logging removing from whitelist\r\n   * @param _address the address to remove from the whitelist\r\n   */\r\n  event RemovedFromWhitelist(address indexed _address);\r\n\r\n\r\n  /**\r\n   * @dev Reverts if beneficiary is not whitelisted. Can be used when extending this contract.\r\n   */\r\n  modifier isWhitelisted(address _beneficiary) {\r\n    require(whitelist[_beneficiary]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds single address to whitelist.\r\n   * @param _beneficiary Address to be added to the whitelist\r\n   */\r\n  function addToWhitelist(address _beneficiary) external onlyAdmin {\r\n    whitelist[_beneficiary] = true;\r\n    emit AddedToWhitelist(_beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds list of addresses to whitelist. Not overloaded due to limitations with truffle testing.\r\n   * @param _beneficiaries Addresses to be added to the whitelist\r\n   */\r\n  function addManyToWhitelist(address[] _beneficiaries) external onlyAdmin {\r\n    for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n      whitelist[_beneficiaries[i]] = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes single address from whitelist.\r\n   * @param _beneficiary Address to be removed to the whitelist\r\n   */\r\n  function removeFromWhitelist(address _beneficiary) external onlyAdmin {\r\n    whitelist[_beneficiary] = false;\r\n    emit RemovedFromWhitelist(_beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring beneficiary to be in whitelist.\r\n   * @param _beneficiary Token beneficiary\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isWhitelisted(_beneficiary) {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\ncontract PostDeliveryCrowdsale is TimedCrowdsale, Administratable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public balances;\r\n  /**\r\n   * Event for logging when token sale tokens are withdrawn\r\n   * @param _address the address to withdraw tokens for\r\n   * @param _amount the amount withdrawn for this address\r\n   */\r\n  event TokensWithdrawn(address indexed _address, uint256 _amount);\r\n\r\n  /**\r\n   * @dev Withdraw tokens only after crowdsale ends.\r\n   */\r\n  function withdrawTokens(address _beneficiary) public onlyAdmin {\r\n    require(hasClosed());\r\n    uint256 amount = balances[_beneficiary];\r\n    require(amount > 0);\r\n    balances[_beneficiary] = 0;\r\n    _deliverTokens(_beneficiary, amount);\r\n    emit TokensWithdrawn(_beneficiary, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides parent by storing balances instead of issuing tokens right away.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _tokenAmount Amount of tokens purchased\r\n   */\r\n  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\r\n  }\r\n\r\n  function getBalance(address _beneficiary) public returns (uint256) {\r\n      return balances[_beneficiary];\r\n  }\r\n\r\n}\r\n\r\ncontract MultiRoundCrowdsale is  Crowdsale, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct SaleRound {\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 rate;\r\n        uint256 roundCap;\r\n        uint256 minPurchase;\r\n    }\r\n\r\n    SaleRound seedRound;\r\n    SaleRound presale;\r\n    SaleRound crowdsaleWeek1;\r\n    SaleRound crowdsaleWeek2;\r\n    SaleRound crowdsaleWeek3;\r\n    SaleRound crowdsaleWeek4;\r\n\r\n    bool public saleRoundsSet = false;\r\n\r\n    /**\r\n     * Sets the parameters for each round.\r\n     *\r\n     * Each round is defined by an array, with each field mapping to a field in the SaleRound struct.\r\n     * The array elements are as follows:\r\n     * array[0]: start time of the round\r\n     * array[1]: end time of the round\r\n     * array[2]: the exchange rate of this round. i.e number of TIP per ETH\r\n     * array[3]: The cumulative cap of this round\r\n     * array[4]: Minimum purchase of this round\r\n     *\r\n     * @param _seedRound [description]\r\n     * @param _presale [description]\r\n     * @param _crowdsaleWeek1 [description]\r\n     * @param _crowdsaleWeek2 [description]\r\n     * @param _crowdsaleWeek3 [description]\r\n     * @param _crowdsaleWeek4 [description]\r\n     */\r\n    function setTokenSaleRounds(uint256[5] _seedRound, uint256[5] _presale, uint256[5] _crowdsaleWeek1, uint256[5] _crowdsaleWeek2, uint256[5] _crowdsaleWeek3, uint256[5] _crowdsaleWeek4) external onlyOwner returns (bool) {\r\n        // This function can only be called once\r\n        require(!saleRoundsSet);\r\n\r\n        // Check that each round end time is after the start time\r\n        require(_seedRound[0] < _seedRound[1]);\r\n        require(_presale[0] < _presale[1]);\r\n        require(_crowdsaleWeek1[0] < _crowdsaleWeek1[1]);\r\n        require(_crowdsaleWeek2[0] < _crowdsaleWeek2[1]);\r\n        require(_crowdsaleWeek3[0] < _crowdsaleWeek3[1]);\r\n        require(_crowdsaleWeek4[0] < _crowdsaleWeek4[1]);\r\n\r\n        // Check that each round ends before the next begins\r\n        require(_seedRound[1] < _presale[0]);\r\n        require(_presale[1] < _crowdsaleWeek1[0]);\r\n        require(_crowdsaleWeek1[1] < _crowdsaleWeek2[0]);\r\n        require(_crowdsaleWeek2[1] < _crowdsaleWeek3[0]);\r\n        require(_crowdsaleWeek3[1] < _crowdsaleWeek4[0]);\r\n\r\n        seedRound      = SaleRound(_seedRound[0], _seedRound[1], _seedRound[2], _seedRound[3], _seedRound[4]);\r\n        presale        = SaleRound(_presale[0], _presale[1], _presale[2], _presale[3], _presale[4]);\r\n        crowdsaleWeek1 = SaleRound(_crowdsaleWeek1[0], _crowdsaleWeek1[1], _crowdsaleWeek1[2], _crowdsaleWeek1[3], _crowdsaleWeek1[4]);\r\n        crowdsaleWeek2 = SaleRound(_crowdsaleWeek2[0], _crowdsaleWeek2[1], _crowdsaleWeek2[2], _crowdsaleWeek2[3], _crowdsaleWeek2[4]);\r\n        crowdsaleWeek3 = SaleRound(_crowdsaleWeek3[0], _crowdsaleWeek3[1], _crowdsaleWeek3[2], _crowdsaleWeek3[3], _crowdsaleWeek3[4]);\r\n        crowdsaleWeek4 = SaleRound(_crowdsaleWeek4[0], _crowdsaleWeek4[1], _crowdsaleWeek4[2], _crowdsaleWeek4[3], _crowdsaleWeek4[4]);\r\n\r\n        saleRoundsSet = true;\r\n        return saleRoundsSet;\r\n    }\r\n\r\n    function getCurrentRound() internal view returns (SaleRound) {\r\n        require(saleRoundsSet);\r\n\r\n        uint256 currentTime = block.timestamp;\r\n        if (currentTime > seedRound.start && currentTime <= seedRound.end) {\r\n            return seedRound;\r\n        } else if (currentTime > presale.start && currentTime <= presale.end) {\r\n            return presale;\r\n        } else if (currentTime > crowdsaleWeek1.start && currentTime <= crowdsaleWeek1.end) {\r\n            return crowdsaleWeek1;\r\n        } else if (currentTime > crowdsaleWeek2.start && currentTime <= crowdsaleWeek2.end) {\r\n            return crowdsaleWeek2;\r\n        } else if (currentTime > crowdsaleWeek3.start && currentTime <= crowdsaleWeek3.end) {\r\n            return crowdsaleWeek3;\r\n        } else if (currentTime > crowdsaleWeek4.start && currentTime <= crowdsaleWeek4.end) {\r\n            return crowdsaleWeek4;\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function getCurrentRate() public view returns (uint256) {\r\n        require(saleRoundsSet);\r\n        SaleRound memory currentRound = getCurrentRound();\r\n        return currentRound.rate;\r\n    }\r\n\r\n    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        require(_weiAmount != 0);\r\n        uint256 currentRate = getCurrentRate();\r\n        require(currentRate != 0);\r\n\r\n        return currentRate.mul(_weiAmount);\r\n    }\r\n}\r\n\r\ncontract TipToken is ERC865Token, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant TOTAL_SUPPLY = 10 ** 9;\r\n\r\n    string public constant name = \"Tip Token\";\r\n    string public constant symbol = \"TIP\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping (address => string) aliases;\r\n    mapping (string => address) addresses;\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() public {\r\n        _totalSupply = TOTAL_SUPPLY * (10**uint256(decimals));\r\n        balances[owner] = _totalSupply;\r\n        emit Transfer(address(0), owner, _totalSupply);\r\n    }\r\n\r\n    /**\r\n     * Returns the available supple (total supply minus tokens held by owner)\r\n     */\r\n    function availableSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balances[owner]).sub(balances[address(0)]);\r\n    }\r\n\r\n    /**\r\n     * Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n     * from the token owner's account. The `spender` contract function\r\n     * `receiveApproval(...)` is then executed\r\n     */\r\n    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Don't accept ETH.\r\n     */\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * Owner can transfer out any accidentally sent ERC20 tokens\r\n     */\r\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {\r\n        return ERC20(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    /**\r\n     * Sets the alias for the msg.sender's address.\r\n     * @param alias the alias to attach to an address\r\n     */\r\n    function setAlias(string alias) public {\r\n        aliases[msg.sender] = alias;\r\n        addresses[alias] = msg.sender;\r\n    }\r\n}\r\n\r\ncontract TipTokenCrowdsale is MultiRoundCrowdsale, CappedCrowdsale, WhitelistedCrowdsale, AllowanceCrowdsale, PostDeliveryCrowdsale, Pausable {\r\n\r\n    /**\r\n     * Contract name\r\n     * String name - the name of the contract\r\n     */\r\n    string public constant name = \"Tip Token Crowdsale\";\r\n\r\n\r\n    /**\r\n     * @param _vault Address where collected funds will be forwarded to\r\n     * @param _tokenWallet Address holding the tokens, which has approved allowance to the crowdsale\r\n     * @param _cap the maximum number of tokens to be collected in the sale\r\n     * @param _token Address of the token being sold\r\n     */\r\n    constructor(\r\n        ERC20 _token,\r\n        address _tokenWallet,\r\n        address _vault,\r\n        uint256 _cap,\r\n        uint256 _start, uint256 _end, uint256 _baseRate\r\n        ) public\r\n        Crowdsale(_baseRate, _vault, _token)\r\n        CappedCrowdsale(_cap)\r\n        TimedCrowdsale(_start, _end)\r\n        PostDeliveryCrowdsale()\r\n        WhitelistedCrowdsale()\r\n        AllowanceCrowdsale(_tokenWallet)\r\n        MultiRoundCrowdsale()\r\n        {\r\n    }\r\n\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused() {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount);\r\n\r\n        SaleRound memory currentRound = getCurrentRound();\r\n        require(weiRaised.add(_weiAmount) <= currentRound.roundCap);\r\n        require(balances[_beneficiary].add(_weiAmount) >= currentRound.minPurchase);\r\n    }\r\n\r\n    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        return MultiRoundCrowdsale._getTokenAmount(_weiAmount);\r\n    }\r\n\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n        AllowanceCrowdsale._deliverTokens(_beneficiary, _tokenAmount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressToRemove\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleRoundsSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressToAdd\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"addManyToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seedRound\",\"type\":\"uint256[5]\"},{\"name\":\"_presale\",\"type\":\"uint256[5]\"},{\"name\":\"_crowdsaleWeek1\",\"type\":\"uint256[5]\"},{\"name\":\"_crowdsaleWeek2\",\"type\":\"uint256[5]\"},{\"name\":\"_crowdsaleWeek3\",\"type\":\"uint256[5]\"},{\"name\":\"_crowdsaleWeek4\",\"type\":\"uint256[5]\"}],\"name\":\"setTokenSaleRounds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWeiSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokenWallet\",\"type\":\"address\"},{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_baseRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"TipTokenCrowdsale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000059ae863232238a8bd7953bdfc1b4796f8e9a5b4e0000000000000000000000002b73e72c0f00067e1a69c1ff90e6fb391ff3ac620000000000000000000000009e0660bafe5f8c731e0b306528b321bf8aa4d7d20000000000000000000000000000000000000000000009d60f3e615a3e880000000000000000000000000000000000000000000000000000000000005b118298000000000000000000000000000000000000000000000000000000005b77617f0000000000000000000000000000000000000000000000000000000000002710","Library":"","SwarmSource":"bzzr://e3d5ba02fa4235007a35c174e65b23085531095d9ef17915f8f308e9336fd897"}]}