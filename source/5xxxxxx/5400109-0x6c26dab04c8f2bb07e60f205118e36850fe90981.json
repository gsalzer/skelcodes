{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n// ETH in, tokens out to lottery winner.\r\n\r\ncontract PoWMLottery {\r\n    using SafeMath for uint256;\r\n    \r\n    // Contract setup\r\n    bool public isLotteryOpen = false;\r\n    address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B);\r\n    POWM maths = POWM(POWM_address);\r\n    address owner;\r\n    \r\n    // Datasets\r\n    mapping (uint256 => address) public gamblers;\r\n    mapping (address => uint256) public token_buyins;\r\n    mapping (address => uint256) public last_round_bought;\r\n    \r\n    uint256 public num_tickets_current_round = 0;\r\n    uint256 public current_round = 0;\r\n    uint256 public numTokensInLottery = 0;\r\n    \r\n    address masternode_referrer;\r\n    \r\n    // Can't buy more than 25 tokens.\r\n    uint256 public MAX_TOKEN_BUYIN = 25;\r\n    \r\n    function PoWMLottery() public {\r\n        current_round = 1;\r\n        owner = msg.sender;\r\n        masternode_referrer = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function donateToLottery() public payable returns(uint256) {\r\n        uint256 tokens_before = maths.myTokens();\r\n        maths.buy.value(msg.value)(masternode_referrer);\r\n        uint256 tokens_after = maths.myTokens();\r\n        numTokensInLottery = maths.myTokens();\r\n        return tokens_after - tokens_before;\r\n    }\r\n\r\n    /**\r\n     * Buys tickets. Fails if > 25 tickets are attempted to buy.\r\n     */\r\n    function buyTickets() public payable {\r\n        require(isLotteryOpen == true);\r\n        require(last_round_bought[msg.sender] != current_round);\r\n        \r\n        // Buy the tokens.\r\n        // Should be between 0 and 25.\r\n        uint256 tokens_before = maths.myTokens();\r\n        maths.buy.value(msg.value)(masternode_referrer);\r\n        uint256 tokens_after = maths.myTokens();\r\n        uint256 tokens_bought = SafeMath.sub(tokens_after, tokens_before).div(1e18);\r\n        require(tokens_bought >= 1 && tokens_bought <= MAX_TOKEN_BUYIN);\r\n        numTokensInLottery = maths.myTokens();\r\n        \r\n        // Set last_round_bought = current round and token_buyins value\r\n        // Uses a for loop to put up to 25 tickets in.\r\n        uint8 i = 0;\r\n        while (i < tokens_bought) {\r\n            i++;\r\n            \r\n            gamblers[num_tickets_current_round] = msg.sender;\r\n            num_tickets_current_round++;\r\n        }\r\n\r\n        token_buyins[msg.sender] = tokens_bought;\r\n        last_round_bought[msg.sender] = current_round;\r\n    }\r\n    \r\n    function setMaxTokenBuyin(uint256 tokens) public onlyOwner {\r\n        require(isLotteryOpen == false);\r\n        require(tokens > 0);\r\n        \r\n        MAX_TOKEN_BUYIN = tokens;\r\n    }\r\n    \r\n    function openLottery() onlyOwner public {\r\n        require(isLotteryOpen == false);\r\n        current_round++;\r\n        isLotteryOpen = true;\r\n        num_tickets_current_round = 0;\r\n    }\r\n    \r\n    // We need to be payable in order to receive dividends.\r\n    // And if not sent from the contract, let people buy in this way.\r\n    function () public payable {\r\n        if(msg.sender != address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B)) {\r\n            buyTickets();\r\n        }\r\n    }\r\n    \r\n    function closeLotteryAndPickWinner() onlyOwner public {\r\n        require(isLotteryOpen == true);\r\n        isLotteryOpen = false;\r\n        \r\n        // Pick winner as a pseudo-random hash of the timestamp among all the current winners\r\n        // YES we know this isn't /truly/ random but unless the prize is worth more than the block mining reward\r\n        //  it doesn't fucking matter.\r\n        uint256 winning_number = uint256(keccak256(block.blockhash(block.number - 1))) % num_tickets_current_round;\r\n        address winner = gamblers[winning_number];\r\n        masternode_referrer = winner;\r\n        \r\n        // ERC20 transfer & clear out our tokens.\r\n        uint256 exact_tokens = maths.myTokens();\r\n        maths.transfer(winner, exact_tokens);\r\n        numTokensInLottery = 0;\r\n        \r\n        // transfer any divs we got\r\n        winner.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\n// Function prototypes for PoWM\r\ncontract POWM {\r\n    function buy(address _referredBy) public payable returns(uint256) {}\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {}\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) returns(bool) {}\r\n    function myTokens() public view returns(uint256) {}\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gamblers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeLotteryAndPickWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTokensInLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"last_round_bought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"token_buyins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"num_tickets_current_round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setMaxTokenBuyin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateToLottery\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLotteryOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKEN_BUYIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"PoWMLottery","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://284c7df39825b8db8cc2e7d3b1dce25b70b343329698fddb2860b9df0ad48e8a"}]}