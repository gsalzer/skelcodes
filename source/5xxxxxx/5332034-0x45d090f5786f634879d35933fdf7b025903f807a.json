{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n// This is an ERC-20 token contract based on Open Zepplin's StandardToken\r\n// and MintableToken plus the ability to burn tokens.\r\n//\r\n// We had to copy over the code instead of inheriting because of changes\r\n// to the modifier lists of some functions:\r\n//   * transfer(), transferFrom() and approve() are not callable during\r\n//     the minting period, only after MintingFinished()\r\n//   * mint() can only be called by the minter who is not the owner\r\n//     but the HoloTokenSale contract.\r\n//\r\n// Token can be burned by a special 'destroyer' role that can only\r\n// burn its tokens.\r\ncontract HoloToken is Ownable {\r\n  string public constant name = \"HoloToken\";\r\n  string public constant symbol = \"HOT\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintingFinished();\r\n  event Burn(uint256 amount);\r\n\r\n  uint256 public totalSupply;\r\n\r\n\r\n  //==================================================================================\r\n  // Zeppelin BasicToken (plus modifier to not allow transfers during minting period):\r\n  //==================================================================================\r\n\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public whenMintingFinished returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n\r\n  //=====================================================================================\r\n  // Zeppelin StandardToken (plus modifier to not allow transfers during minting period):\r\n  //=====================================================================================\r\n  mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public whenMintingFinished returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public whenMintingFinished returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n\r\n  //=====================================================================================\r\n  // Minting:\r\n  //=====================================================================================\r\n\r\n  bool public mintingFinished = false;\r\n  address public destroyer;\r\n  address public minter;\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier whenMintingFinished() {\r\n    require(mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier onlyMinter() {\r\n    require(msg.sender == minter);\r\n    _;\r\n  }\r\n\r\n  function setMinter(address _minter) external onlyOwner {\r\n    minter = _minter;\r\n  }\r\n\r\n  function mint(address _to, uint256 _amount) external onlyMinter canMint  returns (bool) {\r\n    require(balances[_to] + _amount > balances[_to]); // Guard against overflow\r\n    require(totalSupply + _amount > totalSupply);     // Guard against overflow  (this should never happen)\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n  }\r\n\r\n  function finishMinting() external onlyMinter returns (bool) {\r\n    mintingFinished = true;\r\n    MintingFinished();\r\n    return true;\r\n  }\r\n\r\n\r\n  //=====================================================================================\r\n  // Burning:\r\n  //=====================================================================================\r\n\r\n\r\n  modifier onlyDestroyer() {\r\n     require(msg.sender == destroyer);\r\n     _;\r\n  }\r\n\r\n  function setDestroyer(address _destroyer) external onlyOwner {\r\n    destroyer = _destroyer;\r\n  }\r\n\r\n  function burn(uint256 _amount) external onlyDestroyer {\r\n    require(balances[destroyer] >= _amount && _amount > 0);\r\n    balances[destroyer] = balances[destroyer].sub(_amount);\r\n    totalSupply = totalSupply.sub(_amount);\r\n    Burn(_amount);\r\n  }\r\n}\r\n\r\n\r\n// This contract holds a mapping of known funders with:\r\n// * a boolean flag for whitelist status\r\n// * number of reserved tokens for each day\r\ncontract HoloWhitelist is Ownable {\r\n  address public updater;\r\n\r\n  struct KnownFunder {\r\n    bool whitelisted;\r\n    mapping(uint => uint256) reservedTokensPerDay;\r\n  }\r\n\r\n  mapping(address => KnownFunder) public knownFunders;\r\n\r\n  event Whitelisted(address[] funders);\r\n  event ReservedTokensSet(uint day, address[] funders, uint256[] reservedTokens);\r\n\r\n  modifier onlyUpdater {\r\n    require(msg.sender == updater);\r\n    _;\r\n  }\r\n\r\n  function HoloWhitelist() public {\r\n    updater = msg.sender;\r\n  }\r\n\r\n  function setUpdater(address new_updater) external onlyOwner {\r\n    updater = new_updater;\r\n  }\r\n\r\n  // Adds funders to the whitelist in batches.\r\n  function whitelist(address[] funders) external onlyUpdater {\r\n    for (uint i = 0; i < funders.length; i++) {\r\n        knownFunders[funders[i]].whitelisted = true;\r\n    }\r\n    Whitelisted(funders);\r\n  }\r\n\r\n  // Removes funders from the whitelist in batches.\r\n  function unwhitelist(address[] funders) external onlyUpdater {\r\n    for (uint i = 0; i < funders.length; i++) {\r\n        knownFunders[funders[i]].whitelisted = false;\r\n    }\r\n  }\r\n\r\n  // Stores reserved tokens for several funders in a batch\r\n  // but all for the same day.\r\n  // * day is 0-based\r\n  function setReservedTokens(uint day, address[] funders, uint256[] reservedTokens) external onlyUpdater {\r\n    for (uint i = 0; i < funders.length; i++) {\r\n        knownFunders[funders[i]].reservedTokensPerDay[day] = reservedTokens[i];\r\n    }\r\n    ReservedTokensSet(day, funders, reservedTokens);\r\n  }\r\n\r\n  // Used in HoloSale to check if funder is allowed\r\n  function isWhitelisted(address funder) external view returns (bool) {\r\n    return knownFunders[funder].whitelisted;\r\n  }\r\n\r\n  // Used in HoloSale to get reserved tokens per funder\r\n  // and per day.\r\n  // * day is 0-based\r\n  function reservedTokens(address funder, uint day) external view returns (uint256) {\r\n    return knownFunders[funder].reservedTokensPerDay[day];\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n// This contract is a crowdsale based on Zeppelin's Crowdsale.sol but with\r\n// several changes:\r\n//   * the token contract as well as the supply contract get injected\r\n//     with setTokenContract() and setSupplyContract()\r\n//   * we have a dynamic token supply per day which we hold in the statsByDay\r\n//   * once per day, the *updater* role runs the update function to make the\r\n//     contract read the new supply and switch to the next day\r\n//   * we have a minimum amount in ETH per transaction\r\n//   * we have a maximum amount per transaction relative to the daily supply\r\n//\r\n//\r\ncontract HoloSale is Ownable, Pausable{\r\n  using SafeMath for uint256;\r\n\r\n  // Start and end block where purchases are allowed (both inclusive)\r\n  uint256 public startBlock;\r\n  uint256 public endBlock;\r\n  // Factor between wei and full Holo tokens.\r\n  // (i.e. a rate of 10^18 means one Holo per Ether)\r\n  uint256 public rate;\r\n  // Ratio of the current supply a transaction is allowed to by\r\n  uint256 public maximumPercentageOfDaysSupply;\r\n  // Minimum amount of wei a transaction has to send\r\n  uint256 public minimumAmountWei;\r\n  // address where funds are being send to on successful buy\r\n  address public wallet;\r\n\r\n  // The token being minted on sale\r\n  HoloToken private tokenContract;\r\n  // The contract to check beneficiaries' address against\r\n  // and to hold number of reserved tokens per day\r\n  HoloWhitelist private whitelistContract;\r\n\r\n  // The account that is allowed to call update()\r\n  // which will happen once per day during the sale period\r\n  address private updater;\r\n\r\n  // Will be set to true by finalize()\r\n  bool private finalized = false;\r\n\r\n  uint256 public totalSupply;\r\n\r\n  // For every day of the sale we store one instance of this struct\r\n  struct Day {\r\n    // The supply available to sell on this day\r\n    uint256 supply;\r\n    // The number of unreserved tokens sold on this day\r\n    uint256 soldFromUnreserved;\r\n    // Number of tokens reserved today\r\n    uint256 reserved;\r\n    // Number of reserved tokens sold today\r\n    uint256 soldFromReserved;\r\n    // We are storing how much fuel each user has bought per day\r\n    // to be able to apply our relative cap per user per day\r\n    // (i.e. nobody is allowed to buy more than 10% of each day's supply)\r\n    mapping(address => uint256) fuelBoughtByAddress;\r\n  }\r\n\r\n  // Growing list of days\r\n  Day[] public statsByDay;\r\n\r\n  event CreditsCreated(address beneficiary, uint256 amountWei, uint256 amountHolos);\r\n  event Update(uint256 newTotalSupply, uint256 reservedTokensNextDay);\r\n\r\n  modifier onlyUpdater {\r\n    require(msg.sender == updater);\r\n    _;\r\n  }\r\n\r\n  // Converts wei to smallest fraction of Holo tokens.\r\n  // 'rate' is meant to give the factor between weis and full Holo tokens,\r\n  // hence the division by 10^18.\r\n  function holosForWei(uint256 amountWei) internal view returns (uint256) {\r\n    return amountWei * rate / 1000000000000000000;\r\n  }\r\n\r\n  // Contstructor takes start and end block of the sale period,\r\n  // the rate that defines how many full Holo token are being minted per wei\r\n  // (since the Holo token has 18 decimals, 1000000000000000000 would mean that\r\n  // one full Holo is minted per Ether),\r\n  // minimum and maximum limits for incoming ETH transfers\r\n  // and the wallet to which the Ethers are being transfered on updated()\r\n  function HoloSale(\r\n    uint256 _startBlock, uint256 _endBlock,\r\n    uint256 _rate,\r\n    uint256 _minimumAmountWei, uint256 _maximumPercentageOfDaysSupply,\r\n    address _wallet) public\r\n  {\r\n    require(_startBlock >= block.number);\r\n    require(_endBlock >= _startBlock);\r\n    require(_rate > 0);\r\n    require(_wallet != 0x0);\r\n\r\n    updater = msg.sender;\r\n    startBlock = _startBlock;\r\n    endBlock = _endBlock;\r\n    rate = _rate;\r\n    maximumPercentageOfDaysSupply = _maximumPercentageOfDaysSupply;\r\n    minimumAmountWei = _minimumAmountWei;\r\n    wallet = _wallet;\r\n  }\r\n\r\n  //---------------------------------------------------------------------------\r\n  // Setters and Getters:\r\n  //---------------------------------------------------------------------------\r\n\r\n  function setUpdater(address _updater) external onlyOwner {\r\n    updater = _updater;\r\n  }\r\n\r\n  function setTokenContract(HoloToken _tokenContract) external onlyOwner {\r\n    tokenContract = _tokenContract;\r\n  }\r\n\r\n  function setWhitelistContract(HoloWhitelist _whitelistContract) external onlyOwner {\r\n    whitelistContract = _whitelistContract;\r\n  }\r\n\r\n  function currentDay() public view returns (uint) {\r\n    return statsByDay.length;\r\n  }\r\n\r\n  function todaysSupply() external view returns (uint) {\r\n    return statsByDay[currentDay()-1].supply;\r\n  }\r\n\r\n  function todaySold() external view returns (uint) {\r\n    return statsByDay[currentDay()-1].soldFromUnreserved + statsByDay[currentDay()-1].soldFromReserved;\r\n  }\r\n\r\n  function todayReserved() external view returns (uint) {\r\n    return statsByDay[currentDay()-1].reserved;\r\n  }\r\n\r\n  function boughtToday(address beneficiary) external view returns (uint) {\r\n    return statsByDay[currentDay()-1].fuelBoughtByAddress[beneficiary];\r\n  }\r\n\r\n  //---------------------------------------------------------------------------\r\n  // Sending money / adding asks\r\n  //---------------------------------------------------------------------------\r\n\r\n  // Fallback function can be used to buy fuel\r\n  function () public payable {\r\n    buyFuel(msg.sender);\r\n  }\r\n\r\n  // Main function that checks all conditions and then mints fuel tokens\r\n  // and transfers the ETH to our wallet\r\n  function buyFuel(address beneficiary) public payable whenNotPaused{\r\n    require(currentDay() > 0);\r\n    require(whitelistContract.isWhitelisted(beneficiary));\r\n    require(beneficiary != 0x0);\r\n    require(withinPeriod());\r\n\r\n    // Calculate how many Holos this transaction would buy\r\n    uint256 amountOfHolosAsked = holosForWei(msg.value);\r\n\r\n    // Get current day\r\n    uint dayIndex = statsByDay.length-1;\r\n    Day storage today = statsByDay[dayIndex];\r\n\r\n    // Funders who took part in the crowdfund could have reserved tokens\r\n    uint256 reservedHolos = whitelistContract.reservedTokens(beneficiary, dayIndex);\r\n    // If they do, make sure to subtract what they bought already today\r\n    uint256 alreadyBought = today.fuelBoughtByAddress[beneficiary];\r\n    if(alreadyBought >= reservedHolos) {\r\n      reservedHolos = 0;\r\n    } else {\r\n      reservedHolos = reservedHolos.sub(alreadyBought);\r\n    }\r\n\r\n    // Calculate if they asked more than they have reserved\r\n    uint256 askedMoreThanReserved;\r\n    uint256 useFromReserved;\r\n    if(amountOfHolosAsked > reservedHolos) {\r\n      askedMoreThanReserved = amountOfHolosAsked.sub(reservedHolos);\r\n      useFromReserved = reservedHolos;\r\n    } else {\r\n      askedMoreThanReserved = 0;\r\n      useFromReserved = amountOfHolosAsked;\r\n    }\r\n\r\n    if(reservedHolos == 0) {\r\n      // If this transaction is not claiming reserved tokens\r\n      // it has to be over the minimum.\r\n      // (Reserved tokens must be claimable even if it would be just few)\r\n      require(msg.value >= minimumAmountWei);\r\n    }\r\n\r\n    // The non-reserved tokens asked must not exceed the max-ratio\r\n    // nor the available supply.\r\n    require(lessThanMaxRatio(beneficiary, askedMoreThanReserved, today));\r\n    require(lessThanSupply(askedMoreThanReserved, today));\r\n\r\n    // Everything fine if we're here\r\n    // Send ETH to our wallet\r\n    wallet.transfer(msg.value);\r\n    // Mint receipts\r\n    tokenContract.mint(beneficiary, amountOfHolosAsked);\r\n    // Log this sale\r\n    today.soldFromUnreserved = today.soldFromUnreserved.add(askedMoreThanReserved);\r\n    today.soldFromReserved = today.soldFromReserved.add(useFromReserved);\r\n    today.fuelBoughtByAddress[beneficiary] = today.fuelBoughtByAddress[beneficiary].add(amountOfHolosAsked);\r\n    CreditsCreated(beneficiary, msg.value, amountOfHolosAsked);\r\n  }\r\n\r\n  // Returns true if we are in the live period of the sale\r\n  function withinPeriod() internal constant returns (bool) {\r\n    uint256 current = block.number;\r\n    return current >= startBlock && current <= endBlock;\r\n  }\r\n\r\n  // Returns true if amount + plus fuel bought today already is not above\r\n  // the maximum share one could buy today\r\n  function lessThanMaxRatio(address beneficiary, uint256 amount, Day storage today) internal view returns (bool) {\r\n    uint256 boughtTodayBefore = today.fuelBoughtByAddress[beneficiary];\r\n    return boughtTodayBefore.add(amount).mul(100).div(maximumPercentageOfDaysSupply) <= today.supply;\r\n  }\r\n\r\n  // Returns false if amount would buy more fuel than we can sell today\r\n  function lessThanSupply(uint256 amount, Day today) internal pure returns (bool) {\r\n    return today.soldFromUnreserved.add(amount) <= today.supply.sub(today.reserved);\r\n  }\r\n\r\n  //---------------------------------------------------------------------------\r\n  // Update\r\n  //---------------------------------------------------------------------------\r\n\r\n\r\n  function update(uint256 newTotalSupply, uint256 reservedTokensNextDay) external onlyUpdater {\r\n    totalSupply = newTotalSupply;\r\n    // daysSupply is the amount of tokens (*10^18) that we can sell today\r\n    uint256 daysSupply = newTotalSupply.sub(tokenContract.totalSupply());\r\n    statsByDay.push(Day(daysSupply, 0, reservedTokensNextDay, 0));\r\n    Update(newTotalSupply, reservedTokensNextDay);\r\n  }\r\n\r\n  //---------------------------------------------------------------------------\r\n  // Finalize\r\n  //---------------------------------------------------------------------------\r\n\r\n  // Returns true if crowdsale event has ended\r\n  function hasEnded() public constant returns (bool) {\r\n    return block.number > endBlock;\r\n  }\r\n\r\n  // Mints a third of all tokens minted so far for the team.\r\n  // => Team ends up with 25% of all tokens.\r\n  // Also calls finishMinting() on the token contract which makes it\r\n  // impossible to mint more.\r\n  function finalize() external onlyOwner {\r\n    require(!finalized);\r\n    require(hasEnded());\r\n    uint256 receiptsMinted = tokenContract.totalSupply();\r\n    uint256 shareForTheTeam = receiptsMinted.div(3);\r\n    tokenContract.mint(wallet, shareForTheTeam);\r\n    tokenContract.finishMinting();\r\n    finalized = true;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelistContract\",\"type\":\"address\"}],\"name\":\"setWhitelistContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTotalSupply\",\"type\":\"uint256\"},{\"name\":\"reservedTokensNextDay\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"todaySold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"boughtToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"todaysSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumAmountWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"statsByDay\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"},{\"name\":\"soldFromUnreserved\",\"type\":\"uint256\"},{\"name\":\"reserved\",\"type\":\"uint256\"},{\"name\":\"soldFromReserved\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_updater\",\"type\":\"address\"}],\"name\":\"setUpdater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumPercentageOfDaysSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyFuel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"todayReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_minimumAmountWei\",\"type\":\"uint256\"},{\"name\":\"_maximumPercentageOfDaysSupply\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountHolos\",\"type\":\"uint256\"}],\"name\":\"CreditsCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newTotalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reservedTokensNextDay\",\"type\":\"uint256\"}],\"name\":\"Update\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"HoloSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000005185240000000000000000000000000000000000000000000000000000000000544b4c00000000000000000000000000000000000000000003a60317502b839a7c7600000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007912afd603e09a3d379658fd01777b117265e3b8","Library":"","SwarmSource":"bzzr://07130e7540ed2bb62e03a8937f85b88cd2047ad457f0d0bda4754753bcd08ff2"}]}