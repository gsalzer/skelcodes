{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n *\r\n * @title McFly.aero - main contract\r\n * @author Copyright (c) 2018 McFly.aero\r\n * @author Dmitriy Khizhinskiy\r\n * @author \"MIT\"\r\n *\r\n */ \r\n\r\n/**\r\n * @title ERC20 Basic smart contract\r\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * @author \"Manuel Araoz <manuelaraoz@gmail.com>\"\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\r\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\r\n */\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable smart contract\r\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * @author \"Manuel Araoz <manuelaraoz@gmail.com>\"\r\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\r\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public candidate;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Allows the current owner to _request_ transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function requestOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        candidate = newOwner;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Allows the _NEW_ candidate to complete transfer control of the contract to him.\r\n    */\r\n    function confirmOwnership() public {\r\n        require(candidate == msg.sender);\r\n        owner = candidate;\r\n        OwnershipTransferred(owner, candidate);        \r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title MultiOwners smart contract\r\n * @author Copyright (c) 2018 McFly.aero\r\n * @author Dmitriy Khizhinskiy\r\n * @author \"MIT\"\r\n */\r\ncontract MultiOwners {\r\n\r\n    event AccessGrant(address indexed owner);\r\n    event AccessRevoke(address indexed owner);\r\n    \r\n    mapping(address => bool) owners;\r\n    address public publisher;\r\n\r\n\r\n    function MultiOwners() public {\r\n        owners[msg.sender] = true;\r\n        publisher = msg.sender;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() { \r\n        require(owners[msg.sender] == true);\r\n        _; \r\n    }\r\n\r\n\r\n    function isOwner() constant public returns (bool) {\r\n        return owners[msg.sender] ? true : false;\r\n    }\r\n\r\n\r\n    function checkOwner(address maybe_owner) constant public returns (bool) {\r\n        return owners[maybe_owner] ? true : false;\r\n    }\r\n\r\n\r\n    function grant(address _owner) onlyOwner public {\r\n        owners[_owner] = true;\r\n        AccessGrant(_owner);\r\n    }\r\n\r\n\r\n    function revoke(address _owner) onlyOwner public {\r\n        require(_owner != publisher);\r\n        require(msg.sender != _owner);\r\n\r\n        owners[_owner] = false;\r\n        AccessRevoke(_owner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * @author \"Manuel Araoz <manuelaraoz@gmail.com>\"\r\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BasicToken smart contract\r\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * @author \"Manuel Araoz <manuelaraoz@gmail.com>\"\r\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\r\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    uint256 totalSupply_;\r\n\r\n    /**\r\n    * @dev total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 smart contract\r\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * @author \"Manuel Araoz <manuelaraoz@gmail.com>\"\r\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\r\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\r\n */\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * @author \"Manuel Araoz <manuelaraoz@gmail.com>\"\r\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\r\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n  \r\n    /** \r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Mintable token smart contract\r\n * @author Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * @author \"Manuel Araoz <manuelaraoz@gmail.com>\"\r\n * @dev license: \"MIT\", source: https://github.com/OpenZeppelin/zeppelin-solidity\r\n * @author modification: Dmitriy Khizhinskiy @McFly.aero\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Function to mint tokens\r\n    * @param _to The address that will receive the minted tokens.\r\n    * @param _amount The amount of tokens to mint.\r\n    * @return A boolean that indicates if the operation was successful.\r\n    */\r\n    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Mint(_to, _amount);\r\n        Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Function to stop minting new tokens.\r\n    * @return True if the operation was successful.\r\n    */\r\n    function finishMinting() onlyOwner canMint public returns (bool) {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title McFly token smart contract\r\n * @author Copyright (c) 2018 McFly.aero\r\n * @author Dmitriy Khizhinskiy\r\n * @author \"MIT\"\r\n */\r\ncontract McFlyToken is MintableToken {\r\n    string public constant name = \"McFlyToken\";\r\n    string public constant symbol = \"McFLY\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    /// @dev mapping for whitelist\r\n    mapping(address=>bool) whitelist;\r\n\r\n    /// @dev event throw when allowed to transfer address added to whitelist\r\n    /// @param from address\r\n    event AllowTransfer(address from);\r\n\r\n    /// @dev check for allowence of transfer\r\n    modifier canTransfer() {\r\n        require(mintingFinished || whitelist[msg.sender]);\r\n        _;        \r\n    }\r\n\r\n    /// @dev add address to whitelist\r\n    /// @param from address to add\r\n    function allowTransfer(address from) onlyOwner public {\r\n        whitelist[from] = true;\r\n        AllowTransfer(from);\r\n    }\r\n\r\n    /// @dev Do the transfer from address to address value\r\n    /// @param from address from\r\n    /// @param to address to\r\n    /// @param value uint256\r\n    function transferFrom(address from, address to, uint256 value) canTransfer public returns (bool) {\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    /// @dev Do the transfer from token address to \"to\" address value\r\n    /// @param to address to\r\n    /// @param value uint256 value\r\n    function transfer(address to, uint256 value) canTransfer public returns (bool) {\r\n        return super.transfer(to, value);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Haltable smart contract - controls owner access\r\n * @author Copyright (c) 2018 McFly.aero\r\n * @author Dmitriy Khizhinskiy\r\n * @author \"MIT\"\r\n */\r\ncontract Haltable is MultiOwners {\r\n    bool public halted;\r\n\r\n    modifier stopInEmergency {\r\n        require(!halted);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyInEmergency {\r\n        require(halted);\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev called by the owner on emergency, triggers stopped state\r\n    function halt() external onlyOwner {\r\n        halted = true;\r\n    }\r\n\r\n\r\n    /// @dev called by the owner on end of emergency, returns to normal state\r\n    function unhalt() external onlyOwner onlyInEmergency {\r\n        halted = false;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title McFly crowdsale smart contract \r\n * @author Copyright (c) 2018 McFly.aero\r\n * @author Dmitriy Khizhinskiy\r\n * @author \"MIT\"\r\n * @dev inherited from MultiOwners & Haltable\r\n */\r\ncontract McFlyCrowd is MultiOwners, Haltable {\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev Total ETH received during WAVES, TLP1.2 & window[1-5]\r\n    uint256 public counter_in; // tlp2\r\n    \r\n    /// @dev minimum ETH to partisipate in window 1-5\r\n    uint256 public minETHin = 1e18; // 1 ETH\r\n\r\n    /// @dev Token\r\n    McFlyToken public token;\r\n\r\n    /// @dev Withdraw wallet\r\n    address public wallet;\r\n\r\n    /// @dev start and end timestamp for TLP 1.2, other values callculated\r\n    uint256 public sT2; // startTimeTLP2\r\n    uint256 constant dTLP2 = 118 days; // days of TLP2\r\n    uint256 constant dBt = 60 days; // days between Windows\r\n    uint256 constant dW = 12 days; // 12 days for 3,4,5,6,7 windows;\r\n\r\n    /// @dev Cap maximum possible tokens for minting\r\n    uint256 public constant hardCapInTokens = 1800e24; // 1,800,000,000 MFL\r\n\r\n    /// @dev maximum possible tokens for sell \r\n    uint256 public constant mintCapInTokens = 1260e24; // 1,260,000,000 MFL\r\n\r\n    /// @dev tokens crowd within TLP2\r\n    uint256 public crowdTokensTLP2;\r\n\r\n    uint256 public _preMcFly;\r\n\r\n    /// @dev maximum possible tokens for fund minting\r\n    uint256 constant fundTokens = 270e24; // 270,000,000 MFL\r\n    uint256 public fundTotalSupply;\r\n    address public fundMintingAgent;\r\n\r\n    /// @dev maximum possible tokens to convert from WAVES\r\n    uint256 constant wavesTokens = 100e24; // 100,000,000 MFL\r\n    address public wavesAgent;\r\n    address public wavesGW;\r\n\r\n    /// @dev Vesting param for team, advisory, reserve.\r\n    uint256 constant VestingPeriodInSeconds = 30 days; // 24 month\r\n    uint256 constant VestingPeriodsCount = 24;\r\n\r\n    /// @dev Team 10%\r\n    uint256 constant _teamTokens = 180e24;\r\n    uint256 public teamTotalSupply;\r\n    address public teamWallet;\r\n\r\n    /// @dev Bounty 5% (2% + 3%)\r\n    /// @dev Bounty online 2%\r\n    uint256 constant _bountyOnlineTokens = 36e24;\r\n    address public bountyOnlineWallet;\r\n    address public bountyOnlineGW;\r\n\r\n    /// @dev Bounty offline 3%\r\n    uint256 constant _bountyOfflineTokens = 54e24;\r\n    address public bountyOfflineWallet;\r\n\r\n    /// @dev Advisory 5%\r\n    uint256 constant _advisoryTokens = 90e24;\r\n    uint256 public advisoryTotalSupply;\r\n    address public advisoryWallet;\r\n\r\n    /// @dev Reserved for future 9%\r\n    uint256 constant _reservedTokens = 162e24;\r\n    uint256 public reservedTotalSupply;\r\n    address public reservedWallet;\r\n\r\n    /// @dev AirDrop 1%\r\n    uint256 constant _airdropTokens = 18e24;\r\n    address public airdropWallet;\r\n    address public airdropGW;\r\n\r\n    /// @dev PreMcFly wallet (MFL)\r\n    address public preMcFlyWallet;\r\n\r\n    /// @dev Ppl structure for Win1-5\r\n    struct Ppl {\r\n        address addr;\r\n        uint256 amount;\r\n    }\r\n    mapping (uint32 => Ppl) public ppls;\r\n\r\n    /// @dev Window structure for Win1-5\r\n    struct Window {\r\n        bool active;\r\n        uint256 totalEthInWindow;\r\n        uint32 totalTransCnt;\r\n        uint32 refundIndex;\r\n        uint256 tokenPerWindow;\r\n    } \r\n    mapping (uint8 => Window) public ww;\r\n\r\n\r\n    /// @dev Events\r\n    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);\r\n    event TokenPurchaseInWindow(address indexed beneficiary, uint256 value, uint8 winnum, uint32 totalcnt, uint256 totaleth1);\r\n    event TransferOddEther(address indexed beneficiary, uint256 value);\r\n    event FundMinting(address indexed beneficiary, uint256 value);\r\n    event WithdrawVesting(address indexed beneficiary, uint256 period, uint256 value, uint256 valueTotal);\r\n    event TokenWithdrawAtWindow(address indexed beneficiary, uint256 value);\r\n    event SetFundMintingAgent(address newAgent);\r\n    event SetTeamWallet(address newTeamWallet);\r\n    event SetAdvisoryWallet(address newAdvisoryWallet);\r\n    event SetReservedWallet(address newReservedWallet);\r\n    event SetStartTimeTLP2(uint256 newStartTimeTLP2);\r\n    event SetMinETHincome(uint256 newMinETHin);\r\n    event NewWindow(uint8 winNum, uint256 amountTokensPerWin);\r\n    event TokenETH(uint256 totalEth, uint32 totalCnt);\r\n\r\n\r\n    /// @dev check for Non zero value\r\n    modifier validPurchase() {\r\n        require(msg.value != 0);\r\n        _;        \r\n    }\r\n\r\n\r\n    /**\r\n     * @dev conctructor of contract, set main params, create new token, do minting for some wallets\r\n     * @param _startTimeTLP2 - set date time of starting of TLP2 (main date!)\r\n     * @param _preMcFlyTotalSupply - set amount in wei total supply of previouse contract (MFL)\r\n     * @param _wallet - wallet for transfer ETH to it\r\n     * @param _wavesAgent - wallet for WAVES gw\r\n     * @param _wavesGW    - wallet for WAVES gw\r\n     * @param _fundMintingAgent - wallet who allowed to mint before TLP2\r\n     * @param _teamWallet - wallet for team vesting\r\n     * @param _bountyOnlineWallet - wallet for online bounty\r\n     * @param _bountyOnlineGW - wallet for online bounty GW\r\n     * @param _bountyOfflineWallet - wallet for offline bounty\r\n     * @param _advisoryWallet - wallet for advisory vesting\r\n     * @param _reservedWallet - wallet for reserved vesting\r\n     * @param _airdropWallet - wallet for airdrop\r\n     * @param _airdropGW - wallet for airdrop GW\r\n     * @param _preMcFlyWallet - wallet for transfer old MFL->McFly (once)\r\n     */\r\n    function McFlyCrowd(\r\n        uint256 _startTimeTLP2,\r\n        uint256 _preMcFlyTotalSupply,\r\n        address _wallet,\r\n        address _wavesAgent,\r\n        address _wavesGW,\r\n        address _fundMintingAgent,\r\n        address _teamWallet,\r\n        address _bountyOnlineWallet,\r\n        address _bountyOnlineGW,\r\n        address _bountyOfflineWallet,\r\n        address _advisoryWallet,\r\n        address _reservedWallet,\r\n        address _airdropWallet,\r\n        address _airdropGW,\r\n        address _preMcFlyWallet\r\n    ) public \r\n    {   \r\n        require(_startTimeTLP2 >= block.timestamp);\r\n        require(_preMcFlyTotalSupply > 0);\r\n        require(_wallet != 0x0);\r\n        require(_wavesAgent != 0x0);\r\n        require(_wavesGW != 0x0);\r\n        require(_fundMintingAgent != 0x0);\r\n        require(_teamWallet != 0x0);\r\n        require(_bountyOnlineWallet != 0x0);\r\n        require(_bountyOnlineGW != 0x0);\r\n        require(_bountyOfflineWallet != 0x0);\r\n        require(_advisoryWallet != 0x0);\r\n        require(_reservedWallet != 0x0);\r\n        require(_airdropWallet != 0x0);\r\n        require(_airdropGW != 0x0);\r\n        require(_preMcFlyWallet != 0x0);\r\n\r\n        token = new McFlyToken();\r\n\r\n        wallet = _wallet;\r\n\r\n        sT2 = _startTimeTLP2;\r\n\r\n        wavesAgent = _wavesAgent;\r\n        wavesGW = _wavesGW;\r\n\r\n        fundMintingAgent = _fundMintingAgent;\r\n\r\n        teamWallet = _teamWallet;\r\n        bountyOnlineWallet = _bountyOnlineWallet;\r\n        bountyOnlineGW = _bountyOnlineGW;\r\n        bountyOfflineWallet = _bountyOfflineWallet;\r\n        advisoryWallet = _advisoryWallet;\r\n        reservedWallet = _reservedWallet;\r\n        airdropWallet = _airdropWallet;\r\n        airdropGW = _airdropGW;\r\n        preMcFlyWallet = _preMcFlyWallet;\r\n\r\n        /// @dev Mint all tokens and than control it by vesting\r\n        _preMcFly = _preMcFlyTotalSupply;\r\n        token.mint(preMcFlyWallet, _preMcFly); // McFly for thansfer to old MFL owners\r\n        token.allowTransfer(preMcFlyWallet);\r\n        crowdTokensTLP2 = crowdTokensTLP2.add(_preMcFly);\r\n\r\n        token.mint(wavesAgent, wavesTokens); // 100,000,000 MFL\r\n        token.allowTransfer(wavesAgent);\r\n        token.allowTransfer(wavesGW);\r\n        crowdTokensTLP2 = crowdTokensTLP2.add(wavesTokens);\r\n\r\n        token.mint(this, _teamTokens); // mint to contract address\r\n\r\n        token.mint(bountyOnlineWallet, _bountyOnlineTokens);\r\n        token.allowTransfer(bountyOnlineWallet);\r\n        token.allowTransfer(bountyOnlineGW);\r\n\r\n        token.mint(bountyOfflineWallet, _bountyOfflineTokens);\r\n        token.allowTransfer(bountyOfflineWallet);\r\n\r\n        token.mint(this, _advisoryTokens);\r\n\r\n        token.mint(this, _reservedTokens);\r\n\r\n        token.mint(airdropWallet, _airdropTokens);\r\n        token.allowTransfer(airdropWallet);\r\n        token.allowTransfer(airdropGW);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev check is TLP2 is active?\r\n     * @return false if crowd TLP2 event was ended\r\n     */\r\n    function withinPeriod() constant public returns (bool) {\r\n        return (now >= sT2 && now <= (sT2+dTLP2));\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev check is TLP2 is active and minting Not finished\r\n     * @return false if crowd event was ended\r\n     */\r\n    function running() constant public returns (bool) {\r\n        return withinPeriod() && !token.mintingFinished();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev check current stage name\r\n     * @return uint8 stage number\r\n     */\r\n    function stageName() constant public returns (uint8) {\r\n        uint256 eT2 = sT2+dTLP2;\r\n\r\n        if (now < sT2) {return 101;} // not started\r\n        if (now >= sT2 && now <= eT2) {return (102);} // TLP1.2\r\n\r\n        if (now > eT2 && now < eT2+dBt) {return (103);} // preTLP1.3\r\n        if (now >= (eT2+dBt) && now <= (eT2+dBt+dW)) {return (0);} // TLP1.3\r\n        if (now > (eT2+dBt+dW) && now < (eT2+dBt+dW+dBt)) {return (104);} // preTLP1.4\r\n        if (now >= (eT2+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW)) {return (1);} // TLP1.4\r\n        if (now > (eT2+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt)) {return (105);} // preTLP1.5\r\n        if (now >= (eT2+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW)) {return (2);} // TLP1.5\r\n        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (106);} // preTLP1.6\r\n        if (now >= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (3);} // TLP1.6\r\n        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW) && now < (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt)) {return (107);} // preTLP1.7\r\n        if (now >= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt) && now <= (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (4);} // TLP1.7\"\r\n        if (now > (eT2+dBt+dW+dBt+dW+dBt+dW+dBt+dW+dBt+dW)) {return (200);} // Finished\r\n        return (201); // unknown\r\n    }\r\n\r\n\r\n    /** \r\n     * @dev change agent for minting\r\n     * @param agent - new agent address\r\n     */\r\n    function setFundMintingAgent(address agent) onlyOwner public {\r\n        fundMintingAgent = agent;\r\n        SetFundMintingAgent(agent);\r\n    }\r\n\r\n\r\n    /** \r\n     * @dev change wallet for team vesting (this make possible to set smart-contract address later)\r\n     * @param _newTeamWallet - new wallet address\r\n     */\r\n    function setTeamWallet(address _newTeamWallet) onlyOwner public {\r\n        teamWallet = _newTeamWallet;\r\n        SetTeamWallet(_newTeamWallet);\r\n    }\r\n\r\n\r\n    /** \r\n     * @dev change wallet for advisory vesting (this make possible to set smart-contract address later)\r\n     * @param _newAdvisoryWallet - new wallet address\r\n     */\r\n    function setAdvisoryWallet(address _newAdvisoryWallet) onlyOwner public {\r\n        advisoryWallet = _newAdvisoryWallet;\r\n        SetAdvisoryWallet(_newAdvisoryWallet);\r\n    }\r\n\r\n\r\n    /** \r\n     * @dev change wallet for reserved vesting (this make possible to set smart-contract address later)\r\n     * @param _newReservedWallet - new wallet address\r\n     */\r\n    function setReservedWallet(address _newReservedWallet) onlyOwner public {\r\n        reservedWallet = _newReservedWallet;\r\n        SetReservedWallet(_newReservedWallet);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev change min ETH income during Window1-5\r\n     * @param _minETHin - new limit\r\n     */\r\n    function setMinETHin(uint256 _minETHin) onlyOwner public {\r\n        minETHin = _minETHin;\r\n        SetMinETHincome(_minETHin);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev set TLP1.X (2-7) start & end dates\r\n     * @param _at - new or old start date\r\n     */\r\n    function setStartEndTimeTLP(uint256 _at) onlyOwner public {\r\n        require(block.timestamp < sT2); // forbid change time when TLP1.2 is active\r\n        require(block.timestamp < _at); // should be great than current block timestamp\r\n\r\n        sT2 = _at;\r\n        SetStartTimeTLP2(_at);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Large Token Holder minting \r\n     * @param to - mint to address\r\n     * @param amount - how much mint\r\n     */\r\n    function fundMinting(address to, uint256 amount) stopInEmergency public {\r\n        require(msg.sender == fundMintingAgent || isOwner());\r\n        require(block.timestamp < sT2);\r\n        require(fundTotalSupply.add(amount) <= fundTokens);\r\n        require(token.totalSupply().add(amount) <= hardCapInTokens);\r\n\r\n        fundTotalSupply = fundTotalSupply.add(amount);\r\n        token.mint(to, amount);\r\n        FundMinting(to, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev calculate amount\r\n     * @param  amount - ether to be converted to tokens\r\n     * @param  at - current time\r\n     * @param  _totalSupply - total supplied tokens\r\n     * @return tokens amount that we should send to our dear ppl\r\n     * @return odd ethers amount, which contract should send back\r\n     */\r\n    function calcAmountAt(\r\n        uint256 amount,\r\n        uint256 at,\r\n        uint256 _totalSupply\r\n    ) public constant returns (uint256, uint256) \r\n    {\r\n        uint256 estimate;\r\n        uint256 price;\r\n        \r\n        if (at >= sT2 && at <= (sT2+dTLP2)) {\r\n            if (at <= sT2 + 15 days) {price = 12e13;} else if (at <= sT2 + 30 days) {\r\n                price = 14e13;} else if (at <= sT2 + 45 days) {\r\n                    price = 16e13;} else if (at <= sT2 + 60 days) {\r\n                        price = 18e13;} else if (at <= sT2 + 75 days) {\r\n                            price = 20e13;} else if (at <= sT2 + 90 days) {\r\n                                price = 22e13;} else if (at <= sT2 + 105 days) {\r\n                                    price = 24e13;} else if (at <= sT2 + 118 days) {\r\n                                        price = 26e13;} else {revert();}\r\n        } else {revert();}\r\n\r\n        estimate = _totalSupply.add(amount.mul(1e18).div(price));\r\n\r\n        if (estimate > hardCapInTokens) {\r\n            return (\r\n                hardCapInTokens.sub(_totalSupply),\r\n                estimate.sub(hardCapInTokens).mul(price).div(1e18)\r\n            );\r\n        }\r\n        return (estimate.sub(_totalSupply), 0);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev fallback for processing ether\r\n     */\r\n    function() external payable {\r\n        return getTokens(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev sell token and send to contributor address\r\n     * @param contributor address\r\n     */\r\n    function getTokens(address contributor) payable stopInEmergency validPurchase public {\r\n        uint256 amount;\r\n        uint256 oddEthers;\r\n        uint256 ethers;\r\n        uint256 _at;\r\n        uint8 _winNum;\r\n\r\n        _at = block.timestamp;\r\n\r\n        require(contributor != 0x0);\r\n       \r\n        if (withinPeriod()) {\r\n        \r\n            (amount, oddEthers) = calcAmountAt(msg.value, _at, token.totalSupply());\r\n  \r\n            require(amount.add(token.totalSupply()) <= hardCapInTokens);\r\n\r\n            ethers = msg.value.sub(oddEthers);\r\n\r\n            token.mint(contributor, amount); // fail if minting is finished\r\n            TokenPurchase(contributor, ethers, amount);\r\n            counter_in = counter_in.add(ethers);\r\n            crowdTokensTLP2 = crowdTokensTLP2.add(amount);\r\n\r\n            if (oddEthers > 0) {\r\n                require(oddEthers < msg.value);\r\n                contributor.transfer(oddEthers);\r\n                TransferOddEther(contributor, oddEthers);\r\n            }\r\n\r\n            wallet.transfer(ethers);\r\n        } else {\r\n            require(msg.value >= minETHin); // checks min ETH income\r\n            _winNum = stageName();\r\n            require(_winNum >= 0 && _winNum < 5);\r\n            Window storage w = ww[_winNum];\r\n\r\n            require(w.tokenPerWindow > 0); // check that we have tokens!\r\n\r\n            w.totalEthInWindow = w.totalEthInWindow.add(msg.value);\r\n            ppls[w.totalTransCnt].addr = contributor;\r\n            ppls[w.totalTransCnt].amount = msg.value;\r\n            w.totalTransCnt++;\r\n            TokenPurchaseInWindow(contributor, msg.value, _winNum, w.totalTransCnt, w.totalEthInWindow);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev close Window and transfer Eth to wallet address\r\n     * @param _winNum - number of window 0-4 to close\r\n     */\r\n    function closeWindow(uint8 _winNum) onlyOwner stopInEmergency public {\r\n        require(ww[_winNum].active);\r\n        ww[_winNum].active = false;\r\n\r\n        wallet.transfer(this.balance);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev transfer tokens to ppl accts (window1-5)\r\n     * @param _winNum - number of window 0-4 to close\r\n     */\r\n    function sendTokensWindow(uint8 _winNum) onlyOwner stopInEmergency public {\r\n        uint256 _tokenPerETH;\r\n        uint256 _tokenToSend = 0;\r\n        address _tempAddr;\r\n        uint32 index = ww[_winNum].refundIndex;\r\n\r\n        TokenETH(ww[_winNum].totalEthInWindow, ww[_winNum].totalTransCnt);\r\n\r\n        require(ww[_winNum].active);\r\n        require(ww[_winNum].totalEthInWindow > 0);\r\n        require(ww[_winNum].totalTransCnt > 0);\r\n\r\n        _tokenPerETH = ww[_winNum].tokenPerWindow.div(ww[_winNum].totalEthInWindow); // max McFly in window / ethInWindow\r\n\r\n        while (index < ww[_winNum].totalTransCnt && msg.gas > 100000) {\r\n            _tokenToSend = _tokenPerETH.mul(ppls[index].amount);\r\n            ppls[index].amount = 0;\r\n            _tempAddr = ppls[index].addr;\r\n            ppls[index].addr = 0;\r\n            index++;\r\n            token.transfer(_tempAddr, _tokenToSend);\r\n            TokenWithdrawAtWindow(_tempAddr, _tokenToSend);\r\n        }\r\n        ww[_winNum].refundIndex = index;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev open new window 0-5 and write totl token per window in structure\r\n     * @param _winNum - number of window 0-4 to close\r\n     * @param _tokenPerWindow - total token for window 0-4\r\n     */\r\n    function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {\r\n        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);\r\n        NewWindow(_winNum, _tokenPerWindow);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Finish crowdsale TLP1.2 period and open window1-5 crowdsale\r\n     */\r\n    function finishCrowd() onlyOwner public {\r\n        uint256 _tokenPerWindow;\r\n        require(now > (sT2.add(dTLP2)) || hardCapInTokens == token.totalSupply());\r\n        require(!token.mintingFinished());\r\n\r\n        _tokenPerWindow = (mintCapInTokens.sub(crowdTokensTLP2).sub(fundTotalSupply)).div(5);\r\n        token.mint(this, _tokenPerWindow.mul(5)); // mint to contract address\r\n        // shoud be MAX tokens minted!!! 1,800,000,000\r\n        for (uint8 y = 0; y < 5; y++) {\r\n            newWindow(y, _tokenPerWindow);\r\n        }\r\n\r\n        token.finishMinting();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev withdraw tokens amount within vesting rules for team, advisory and reserved\r\n     * @param withdrawWallet - wallet to transfer tokens\r\n     * @param withdrawTokens - amount of tokens to transfer to\r\n     * @param withdrawTotalSupply - total amount of tokens transfered to account\r\n     * @return unit256 total amount of tokens after transfer\r\n     */\r\n    function vestingWithdraw(address withdrawWallet, uint256 withdrawTokens, uint256 withdrawTotalSupply) private returns (uint256) {\r\n        require(token.mintingFinished());\r\n        require(msg.sender == withdrawWallet || isOwner());\r\n\r\n        uint256 currentPeriod = (block.timestamp.sub(sT2.add(dTLP2))).div(VestingPeriodInSeconds);\r\n        if (currentPeriod > VestingPeriodsCount) {\r\n            currentPeriod = VestingPeriodsCount;\r\n        }\r\n        uint256 tokenAvailable = withdrawTokens.mul(currentPeriod).div(VestingPeriodsCount).sub(withdrawTotalSupply);  // RECHECK!!!!!\r\n\r\n        require((withdrawTotalSupply.add(tokenAvailable)) <= withdrawTokens);\r\n\r\n        uint256 _withdrawTotalSupply = withdrawTotalSupply.add(tokenAvailable);\r\n\r\n        token.transfer(withdrawWallet, tokenAvailable);\r\n        WithdrawVesting(withdrawWallet, currentPeriod, tokenAvailable, _withdrawTotalSupply);\r\n\r\n        return _withdrawTotalSupply;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev withdraw tokens amount within vesting rules for team\r\n     */\r\n    function teamWithdraw() public {\r\n        teamTotalSupply = vestingWithdraw(teamWallet, _teamTokens, teamTotalSupply);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev withdraw tokens amount within vesting rules for advisory\r\n     */\r\n    function advisoryWithdraw() public {\r\n        advisoryTotalSupply = vestingWithdraw(advisoryWallet, _advisoryTokens, advisoryTotalSupply);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev withdraw tokens amount within vesting rules for reserved wallet\r\n     */\r\n    function reservedWithdraw() public {\r\n        reservedTotalSupply = vestingWithdraw(reservedWallet, _reservedTokens, reservedTotalSupply);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"candidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"requestOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"allowTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"}],\"name\":\"AllowTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"McFlyToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4c830ad51b026fcc939bebe3d3fca769676dd770800ad28ffb1d1e8806a0fb59"}]}