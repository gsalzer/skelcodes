{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n   @title ERC827 interface, an extension of ERC20 token standard\r\n\r\n   Interface of a ERC827 token, following the ERC20 standard with extra\r\n   methods to transfer value and data and execute calls in transfers and\r\n   approvals.\r\n */\r\ncontract ERC827 is ERC20 {\r\n\r\n  function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\r\n  function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\r\n  function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\r\n\r\n}\r\n\r\ncontract AccessControl {\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress || \r\n            msg.sender == ceoAddress || \r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new CFO\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ninterface RandomInterface {\r\n\r\n  function maxRandom() public returns (uint256 randomNumber);\r\n\r\n  function random(uint256 _upper) public returns (uint256 randomNumber);\r\n\r\n  function randomNext(uint256 _seed, uint256 _upper) public pure returns(uint256, uint256);\r\n}\r\n\r\ncontract PlayerInterface {\r\n    function checkOwner(address _owner, uint32[11] _ids) public view returns (bool);\r\n    function queryPlayerType(uint32[11] _ids) public view returns (uint32[11] playerTypes);\r\n    function queryPlayer(uint32 _id) public view returns (uint16[8]);\r\n    function queryPlayerUnAwakeSkillIds(uint32[11] _playerIds) public view returns (uint16[11] playerUnAwakeSkillIds);\r\n    function tournamentResult(uint32[3][11][32] _playerAwakeSkills) public;\r\n}\r\n\r\n/// @title TournamentBase contract for BS.\r\ncontract TournamentBase {\r\n\r\n    event Enter(address user, uint256 fee, uint8 defenceCount, uint8 midfieldCount, uint8 forwardCount, uint32[11] playerIds);\r\n    event CancelEnter(address user);\r\n    event StartCompetition(uint256 id, uint256 time, address[32] users);\r\n    event CancelCompetition(uint256 id);\r\n    event Sponsor(address user, uint256 competitionId, address target, uint256 fee);\r\n    \r\n    event Ball(uint256 competitionId, uint8 gameIndex, address user, uint32 playerId, uint8 time);\r\n    event Battle(uint256 competitionId, uint8 gameIndex, address userA, uint8 scoreA, address userB, uint8 scoreB);\r\n    event Champion(uint256 competitionId, address user);\r\n    event EndCompetition(uint256 competitionId, uint256 totalReward, uint256 totalWeight, uint8[32] teamWinCounts);\r\n\r\n    event Reward(uint256 competitionId, address target, uint8 winCount, address user, uint256 sponsorAmount, uint256 amount);\r\n\r\n    uint256 public minEnterFee = 100*(10**18);\r\n    //uint256 public constant sponsorInterval = 1 hours;\r\n    uint32[5] public operatingCosts = [100, 100, 120, 160, 240];\r\n\r\n    struct Team {\r\n      uint256 fees;\r\n      uint32[11] playerIds;\r\n      uint16[11] playerAtkWeights;\r\n      uint128 index;\r\n      TeamStatus status;\r\n      uint16 attack;\r\n      uint16 defense;\r\n      uint16 stamina;\r\n    }\r\n\r\n    enum TeamStatus { Normal, Enter, Competition }\r\n    enum PlayerPosType { GoalKeeper, Defence, Midfield, Forward }\r\n    enum CompetitionStatus { None, Start, End, Cancel }\r\n\r\n    struct SponsorsInfo {\r\n        mapping(address => uint256) sponsors;\r\n        uint256 totalAmount;\r\n    }\r\n\r\n    struct CompetitionInfo {\r\n        uint256 totalReward;\r\n        uint256 totalWeight;\r\n        uint8[32] teamWinCounts;\r\n        address[32] users;\r\n        //uint64 startTime;\r\n        CompetitionStatus status;\r\n        uint8 userCount;\r\n    }\r\n\r\n    mapping (address => Team) public userToTeam;\r\n    address[] teamUserInfo;\r\n\r\n    uint256 nextCompetitionId;\r\n    mapping (uint256 => CompetitionInfo) public competitionInfos;\r\n    mapping (uint256 => mapping (uint256 => SponsorsInfo)) public sponsorInfos;\r\n\r\n    PlayerInterface bsCoreContract;\r\n    RandomInterface randomContract;\r\n    ERC827 public joyTokenContract;\r\n}\r\n\r\ncontract PlayerSkill {\r\n    enum SkillType { Undefined, WinGamesInOneTournament, ScoreInOneGame, ScoreInOneTournament, \r\n        FanOfPlayerID, ChampionWithPlayerID, HattricksInOneTuournament, Terminator,\r\n        LonelyKiller, VictoryBringer, Saver, ICanDoBetterTournament, ICanDoBetter, \r\n        LearnFromFailure, LearnFromFailureTournament}\r\n\r\n    struct SkillConfig {\r\n        SkillType skillType;\r\n        uint32 target;\r\n        uint8 addAttri;\r\n    }\r\n\r\n    function _getSkill(uint16 skillId) internal pure returns(uint16, uint16) {\r\n        return (skillId >> 2, (skillId & 0x03));\r\n    }\r\n\r\n    function triggerSkill(uint32[11][32] _playerIds, uint8[32] _teamWinCounts, uint8[4][31] _gameScores,\r\n            uint8[3][3][31] _gameBalls, uint8[5][11][32] _playerBalls, uint16[11][32] _playerUnAwakeSkillIds,\r\n            uint32[3][11][32] _playerAwakeSkills) internal pure {\r\n\r\n        SkillConfig[35] memory skillConfigs = _getSkillConfigs();\r\n        for (uint8 i = 0; i < 32; i++) {\r\n            for (uint8 j = 0; j < 11; j++) {\r\n                uint16 skillId = _playerUnAwakeSkillIds[i][j];\r\n                if (skillId > 0) {\r\n                    uint16 addAttriType;\r\n                    (skillId, addAttriType) = _getSkill(skillId);\r\n                    SkillConfig memory skillConfig = skillConfigs[skillId];\r\n\r\n                    if (skillConfig.skillType != SkillType.Undefined) {\r\n                        if (_triggerSkill(skillConfig, i, j, _teamWinCounts, _gameScores, _gameBalls, _playerBalls)){\r\n                            _playerAwakeSkills[i][j][0] = _playerIds[i][j];\r\n                            _playerAwakeSkills[i][j][1] = addAttriType;\r\n                            _playerAwakeSkills[i][j][2] = skillConfig.addAttri;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getSkillConfigs() internal pure returns(SkillConfig[35]) {\r\n        return [\r\n            SkillConfig(SkillType.Undefined, 0, 0),\r\n            SkillConfig(SkillType.WinGamesInOneTournament,1,1),\r\n            SkillConfig(SkillType.WinGamesInOneTournament,2,2),\r\n            SkillConfig(SkillType.WinGamesInOneTournament,3,3),\r\n            SkillConfig(SkillType.WinGamesInOneTournament,4,4),\r\n            SkillConfig(SkillType.WinGamesInOneTournament,5,5),\r\n            SkillConfig(SkillType.ScoreInOneGame,1,1),\r\n            SkillConfig(SkillType.ScoreInOneGame,2,3),\r\n            SkillConfig(SkillType.ScoreInOneGame,3,5),\r\n            SkillConfig(SkillType.ScoreInOneGame,4,7),\r\n            SkillConfig(SkillType.ScoreInOneGame,5,10),\r\n            SkillConfig(SkillType.ScoreInOneTournament,10,3),\r\n            SkillConfig(SkillType.ScoreInOneTournament,13,4),\r\n            SkillConfig(SkillType.ScoreInOneTournament,16,5),\r\n            SkillConfig(SkillType.ScoreInOneTournament,20,8),\r\n            SkillConfig(SkillType.VictoryBringer,1,4),\r\n            SkillConfig(SkillType.VictoryBringer,3,6),\r\n            SkillConfig(SkillType.VictoryBringer,5,8),\r\n            SkillConfig(SkillType.Saver,1,5),\r\n            SkillConfig(SkillType.Saver,3,7),\r\n            SkillConfig(SkillType.Saver,5,10),\r\n            SkillConfig(SkillType.HattricksInOneTuournament,1,3),\r\n            SkillConfig(SkillType.HattricksInOneTuournament,3,6),\r\n            SkillConfig(SkillType.HattricksInOneTuournament,5,10),\r\n            SkillConfig(SkillType.Terminator,1,5),\r\n            SkillConfig(SkillType.Terminator,3,8),\r\n            SkillConfig(SkillType.Terminator,5,12),\r\n            SkillConfig(SkillType.LonelyKiller,1,5),\r\n            SkillConfig(SkillType.LonelyKiller,3,7),\r\n            SkillConfig(SkillType.LonelyKiller,5,10),\r\n            SkillConfig(SkillType.ICanDoBetterTournament,15,0),\r\n            SkillConfig(SkillType.ICanDoBetter,5,0),\r\n            SkillConfig(SkillType.LearnFromFailure,5,5),\r\n            SkillConfig(SkillType.LearnFromFailureTournament,15,8),\r\n            SkillConfig(SkillType.ChampionWithPlayerID,0,5)\r\n        ];\r\n    }\r\n\r\n    function _triggerSkill(SkillConfig memory _skillConfig, uint8 _teamIndex, uint8 _playerIndex,\r\n            uint8[32] _teamWinCounts, uint8[4][31] _gameScores, uint8[3][3][31] _gameBalls,\r\n            uint8[5][11][32] _playerBalls) internal pure returns(bool) {\r\n\r\n        uint256 i;\r\n        uint256 accumulateValue = 0;\r\n        if (SkillType.WinGamesInOneTournament == _skillConfig.skillType) {\r\n            return _teamWinCounts[_teamIndex] >= _skillConfig.target;\r\n        }\r\n\r\n        if (SkillType.ScoreInOneGame == _skillConfig.skillType) {\r\n            for (i = 0; i < 5; i++) {\r\n                if (_playerBalls[_teamIndex][_playerIndex][i] >= _skillConfig.target) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (SkillType.ScoreInOneTournament == _skillConfig.skillType) {\r\n            for (i = 0; i < 5; i++) {\r\n                accumulateValue += _playerBalls[_teamIndex][_playerIndex][i];\r\n            }\r\n            return accumulateValue >= _skillConfig.target;\r\n        }\r\n\r\n\r\n/*         if (SkillType.ChampionWithPlayerID == _skillConfig.skillType) {\r\n            if (_teamWinCounts[_teamIndex] >= 5) {\r\n                for (i = 0; i < 11; i++) {\r\n                    if (_playerIds[i] == _skillConfig.target) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        } */\r\n\r\n        if (SkillType.HattricksInOneTuournament == _skillConfig.skillType) {\r\n            for (i = 0; i < 5; i++) {\r\n                if (_playerBalls[_teamIndex][_playerIndex][i] >= 3) {\r\n                    accumulateValue++;\r\n                }\r\n            }\r\n\r\n            return accumulateValue >= _skillConfig.target;\r\n        }\r\n\r\n        if (SkillType.Terminator == _skillConfig.skillType) {\r\n            for (i = 0; i < 31; i++) {\r\n                if ((_gameScores[i][0] == _teamIndex && _gameScores[i][2] == _gameScores[i][3]+1)\r\n                    || (_gameScores[i][1] == _teamIndex && _gameScores[i][2]+1 == _gameScores[i][3])) {\r\n                    if (_gameBalls[i][2][1] == _teamIndex && _gameBalls[i][2][2] == _playerIndex) {\r\n                        accumulateValue++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return accumulateValue >= _skillConfig.target;\r\n        }\r\n\r\n        if (SkillType.LonelyKiller == _skillConfig.skillType) {\r\n            for (i = 0; i < 31; i++) {\r\n                if ((_gameScores[i][0] == _teamIndex && _gameScores[i][2] == 1 && _gameScores[i][3] == 0)\r\n                    || (_gameScores[i][1] == _teamIndex && _gameScores[i][2] == 0 && _gameScores[i][3] == 1)) {\r\n                    if (_gameBalls[i][2][1] == _teamIndex && _gameBalls[i][2][2] == _playerIndex) {\r\n                        accumulateValue++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return accumulateValue >= _skillConfig.target;\r\n        }\r\n\r\n        if (SkillType.VictoryBringer == _skillConfig.skillType) {\r\n            for (i = 0; i < 31; i++) {\r\n                if ((_gameScores[i][0] == _teamIndex && _gameScores[i][2] > _gameScores[i][3])\r\n                    || (_gameScores[i][1] == _teamIndex && _gameScores[i][2] < _gameScores[i][3])) {\r\n                    if (_gameBalls[i][0][1] == _teamIndex && _gameBalls[i][0][2] == _playerIndex) {\r\n                        accumulateValue++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return accumulateValue >= _skillConfig.target;\r\n        }\r\n\r\n        if (SkillType.Saver == _skillConfig.skillType) {\r\n            for (i = 0; i < 31; i++) {\r\n                if (_gameBalls[i][1][1] == _teamIndex && _gameBalls[i][1][2] == _playerIndex) {\r\n                    accumulateValue++;\r\n                }\r\n            }\r\n            return accumulateValue >= _skillConfig.target;\r\n        }\r\n\r\n        if (SkillType.ICanDoBetterTournament == _skillConfig.skillType) {\r\n            for (i = 0; i < 31; i++) {\r\n                if (_gameScores[i][0] == _teamIndex) {\r\n                    accumulateValue += _gameScores[i][3];\r\n                }\r\n\r\n                if (_gameScores[i][1] == _teamIndex) {\r\n                    accumulateValue += _gameScores[i][2];\r\n                }\r\n            }\r\n            return accumulateValue >= _skillConfig.target;\r\n        }\r\n\r\n        if (SkillType.ICanDoBetter == _skillConfig.skillType) {\r\n            for (i = 0; i < 31; i++) {\r\n                if ((_gameScores[i][0] == _teamIndex && _gameScores[i][3] >= _skillConfig.target)\r\n                    || (_gameScores[i][1] == _teamIndex && _gameScores[i][2] >= _skillConfig.target)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (SkillType.LearnFromFailure == _skillConfig.skillType && _teamIndex == 0) {\r\n            for (i = 0; i < 31; i++) {\r\n                if ((_gameScores[i][0] == _teamIndex && _gameScores[i][3] >= _skillConfig.target)\r\n                    || (_gameScores[i][1] == _teamIndex && _gameScores[i][2] >= _skillConfig.target)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (SkillType.LearnFromFailureTournament == _skillConfig.skillType && _teamIndex == 0) {\r\n            for (i = 0; i < 31; i++) {\r\n                if (_gameScores[i][0] == _teamIndex) {\r\n                    accumulateValue += _gameScores[i][3];\r\n                }\r\n\r\n                if (_gameScores[i][1] == _teamIndex) {\r\n                    accumulateValue += _gameScores[i][2];\r\n                }\r\n            }\r\n            return accumulateValue >= _skillConfig.target;\r\n        }\r\n    }\r\n}\r\n\r\ncontract TournamentCompetition is TournamentBase, PlayerSkill {\r\n\r\n    uint256 constant rangeParam = 90;\r\n    uint256 constant halfBattleMinutes = 45;\r\n    uint256 constant minBattleMinutes = 2;\r\n\r\n    struct BattleTeam {\r\n        uint16[11] playerAtkWeights;\r\n        uint16 attack;\r\n        uint16 defense;\r\n        uint16 stamina;\r\n    }\r\n    struct BattleInfo {\r\n        uint256 competitionId;\r\n        uint256 seed;\r\n        uint256 maxRangeA;\r\n        uint256 maxRangeB;\r\n        uint8[32] teamIndexs;\r\n        BattleTeam[32] teamInfos;\r\n        uint32[11][32] allPlayerIds;\r\n        address addressA;\r\n        address addressB;\r\n        uint8 roundIndex;\r\n        uint8 gameIndex;\r\n        uint8 teamLength;\r\n        uint8 indexA;\r\n        uint8 indexB;\r\n    }\r\n\r\n    function competition(uint256 _competitionId, CompetitionInfo storage ci, uint8[32] _teamWinCounts, uint32[3][11][32] _playerAwakeSkills) internal {\r\n        uint8[4][31] memory gameScores;\r\n        uint8[3][3][31] memory gameBalls;\r\n        uint8[5][11][32] memory playerBalls;\r\n        uint16[11][32] memory playerUnAwakeSkillIds;\r\n\r\n        BattleInfo memory battleInfo;\r\n        battleInfo.competitionId = _competitionId;\r\n        battleInfo.seed = randomContract.maxRandom();\r\n        battleInfo.teamLength = uint8(ci.userCount);\r\n        for (uint8 i = 0; i < battleInfo.teamLength; i++) {\r\n            battleInfo.teamIndexs[i] = i;\r\n        }\r\n\r\n        _queryBattleInfo(ci, battleInfo, playerUnAwakeSkillIds);\r\n        while (battleInfo.teamLength > 1) {\r\n            _battle(ci, battleInfo, gameScores, gameBalls, playerBalls);\r\n            for (i = 0; i < battleInfo.teamLength; i++) {\r\n                _teamWinCounts[battleInfo.teamIndexs[i]] += 1;\r\n            }\r\n        }\r\n        address winner = ci.users[battleInfo.teamIndexs[0]];\r\n        Champion(_competitionId, winner);\r\n\r\n        triggerSkill(battleInfo.allPlayerIds, _teamWinCounts, gameScores, \r\n            gameBalls, playerBalls, playerUnAwakeSkillIds, _playerAwakeSkills);\r\n    }\r\n\r\n    function _queryBattleInfo(CompetitionInfo storage ci, BattleInfo memory _battleInfo, uint16[11][32] memory _playerUnAwakeSkillIds) internal view {\r\n        for (uint8 i = 0; i < _battleInfo.teamLength; i++) {\r\n\r\n            Team storage team = userToTeam[ci.users[i]];\r\n            _battleInfo.allPlayerIds[i] = team.playerIds;\r\n\r\n            _battleInfo.teamInfos[i].playerAtkWeights = team.playerAtkWeights;\r\n            _battleInfo.teamInfos[i].attack = team.attack;\r\n            _battleInfo.teamInfos[i].defense = team.defense;\r\n            _battleInfo.teamInfos[i].stamina = team.stamina;\r\n\r\n            _playerUnAwakeSkillIds[i] = bsCoreContract.queryPlayerUnAwakeSkillIds(_battleInfo.allPlayerIds[i]);\r\n\r\n            // uint256[3] memory teamAttrs;\r\n            // (teamAttrs, _battleInfo.teamInfos[i].playerAtkWeights) = _calTeamAttribute(ci.users[i], team.defenceCount, team.midfieldCount, team.forwardCount, _battleInfo.allPlayerIds[i]);   \r\n\r\n            // _battleInfo.teamInfos[i].attack = uint16(teamAttrs[0]);\r\n            // _battleInfo.teamInfos[i].defense = uint16(teamAttrs[1]);\r\n            // _battleInfo.teamInfos[i].stamina = uint16(teamAttrs[2]);\r\n        }\r\n    }\r\n\r\n    function _battle(CompetitionInfo storage _ci, BattleInfo _battleInfo, uint8[4][31] _gameScores,\r\n            uint8[3][3][31] _gameBalls, uint8[5][11][32] _playerBalls) internal {\r\n        uint8 resultTeamLength = 0;\r\n        for (uint8 i = 0; i < _battleInfo.teamLength; i+=2) {\r\n            uint8 a = _battleInfo.teamIndexs[i];\r\n            uint8 b = _battleInfo.teamIndexs[i+1];\r\n            uint8 scoreA;\r\n            uint8 scoreB;\r\n            _battleInfo.indexA = a;\r\n            _battleInfo.indexB = b;\r\n            _battleInfo.addressA = _ci.users[a];\r\n            _battleInfo.addressB = _ci.users[b];\r\n            (scoreA, scoreB) = _battleTeam(_battleInfo, _gameScores, _gameBalls, _playerBalls);\r\n            if (scoreA > scoreB) {\r\n                _battleInfo.teamIndexs[resultTeamLength++] = a;\r\n            } else {\r\n                _battleInfo.teamIndexs[resultTeamLength++] = b;\r\n            }\r\n            Battle(_battleInfo.competitionId, _battleInfo.gameIndex, _battleInfo.addressA, scoreA, _battleInfo.addressB, scoreB);\r\n        }\r\n\r\n        _battleInfo.roundIndex++;\r\n        _battleInfo.teamLength = resultTeamLength;\r\n    }\r\n\r\n    function _battleTeam(BattleInfo _battleInfo, uint8[4][31] _gameScores, uint8[3][3][31] _gameBalls, \r\n            uint8[5][11][32] _playerBalls) internal returns (uint8 scoreA, uint8 scoreB) {\r\n        BattleTeam memory _aTeam = _battleInfo.teamInfos[_battleInfo.indexA];\r\n        BattleTeam memory _bTeam = _battleInfo.teamInfos[_battleInfo.indexB];\r\n        _battleInfo.maxRangeA = 5 + rangeParam*_bTeam.defense/_aTeam.attack;\r\n        _battleInfo.maxRangeB = 5 + rangeParam*_aTeam.defense/_bTeam.attack;\r\n        //DebugRange(_a, _b, _aTeam.attack, _aTeam.defense, _aTeam.stamina, _bTeam.attack, _bTeam.defense, _bTeam.stamina, maxRangeA, maxRangeB);\r\n        //DebugRange2(maxRangeA, maxRangeB);\r\n        _battleScore(_battleInfo, 0, _playerBalls, _gameBalls);\r\n\r\n        _battleInfo.maxRangeA = 5 + rangeParam*(uint256(_bTeam.defense)*uint256(_bTeam.stamina)*(100+uint256(_aTeam.stamina)))/(uint256(_aTeam.attack)*uint256(_aTeam.stamina)*(100+uint256(_bTeam.stamina)));\r\n        _battleInfo.maxRangeB = 5 + rangeParam*(uint256(_aTeam.defense)*uint256(_aTeam.stamina)*(100+uint256(_bTeam.stamina)))/(uint256(_bTeam.attack)*uint256(_bTeam.stamina)*(100+uint256(_aTeam.stamina)));\r\n        //DebugRange2(maxRangeA, maxRangeB);\r\n        _battleScore(_battleInfo, halfBattleMinutes, _playerBalls, _gameBalls);\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i < 11; i++) {\r\n            scoreA += _playerBalls[_battleInfo.indexA][i][_battleInfo.roundIndex];\r\n            scoreB += _playerBalls[_battleInfo.indexB][i][_battleInfo.roundIndex];\r\n        }\r\n        if (scoreA == scoreB) {\r\n            _battleInfo.maxRangeA = 5 + rangeParam * (uint256(_bTeam.defense)*uint256(_bTeam.stamina)*uint256(_bTeam.stamina)*(100+uint256(_aTeam.stamina))*(100+uint256(_aTeam.stamina)))/(uint256(_aTeam.attack)*uint256(_aTeam.stamina)*uint256(_aTeam.stamina)*(100+uint256(_bTeam.stamina))*(100+uint256(_bTeam.stamina)));\r\n            _battleInfo.maxRangeB = 5 + rangeParam * (uint256(_aTeam.defense)*uint256(_aTeam.stamina)*uint256(_aTeam.stamina)*(100+uint256(_bTeam.stamina))*(100+uint256(_bTeam.stamina)))/(uint256(_bTeam.attack)*uint256(_bTeam.stamina)*uint256(_bTeam.stamina)*(100+uint256(_aTeam.stamina))*(100+uint256(_aTeam.stamina)));\r\n            //DebugRange2(maxRangeA, maxRangeB);\r\n            (scoreA, scoreB) = _battleOvertimeScore(_battleInfo, scoreA, scoreB, _playerBalls, _gameBalls);\r\n        }\r\n\r\n        _gameScores[_battleInfo.gameIndex][0] = _battleInfo.indexA;\r\n        _gameScores[_battleInfo.gameIndex][1] = _battleInfo.indexB;\r\n        _gameScores[_battleInfo.gameIndex][2] = scoreA;\r\n        _gameScores[_battleInfo.gameIndex][3] = scoreB;\r\n        _battleInfo.gameIndex++;\r\n    }\r\n\r\n    function _battleScore(BattleInfo _battleInfo, uint256 _timeoffset, uint8[5][11][32] _playerBalls, uint8[3][3][31] _gameBalls) internal {\r\n        uint256 _battleMinutes = 0;\r\n        while (_battleMinutes < halfBattleMinutes - minBattleMinutes) {\r\n            bool isAWin;\r\n            uint256 scoreTime;\r\n            uint8 index;\r\n            (isAWin, scoreTime) = _battleOneScore(_battleInfo);\r\n            _battleMinutes += scoreTime;\r\n            if (_battleMinutes <= halfBattleMinutes) {\r\n                uint8 teamIndex;\r\n                address addressWin;\r\n\r\n                if (isAWin) {\r\n                    teamIndex = _battleInfo.indexA;\r\n                    addressWin = _battleInfo.addressA;\r\n                } else {\r\n                    teamIndex = _battleInfo.indexB;\r\n                    addressWin = _battleInfo.addressB;\r\n                }\r\n\r\n                (_battleInfo.seed, index) = _randBall(_battleInfo.seed, _battleInfo.teamInfos[teamIndex].playerAtkWeights);\r\n                uint32 playerId = _battleInfo.allPlayerIds[teamIndex][index];\r\n                Ball(_battleInfo.competitionId, _battleInfo.gameIndex+1, addressWin, playerId, uint8(_timeoffset+_battleMinutes));\r\n                _playerBalls[teamIndex][index][_battleInfo.roundIndex]++;\r\n                _onBall(_battleInfo.gameIndex, teamIndex, index, uint8(_timeoffset+_battleMinutes), _gameBalls);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _battleOneScore(BattleInfo _battleInfo) internal view returns(bool, uint256) {\r\n        uint256 tA;\r\n        (_battleInfo.seed, tA) = randomContract.randomNext(_battleInfo.seed, _battleInfo.maxRangeA-minBattleMinutes+1);\r\n        tA += minBattleMinutes;\r\n        uint256 tB;\r\n        (_battleInfo.seed, tB) = randomContract.randomNext(_battleInfo.seed, _battleInfo.maxRangeB-minBattleMinutes+1);\r\n        tB += minBattleMinutes;\r\n        if (tA < tB || (tA == tB && _battleInfo.seed % 2 == 0)) {\r\n           return (true, tA);\r\n        } else {\r\n           return (false, tB);\r\n        }\r\n    }\r\n\r\n    function _randBall(uint256 _seed, uint16[11] memory _atkWeight) internal view returns(uint256, uint8) {\r\n        uint256 rand;\r\n        (_seed, rand) = randomContract.randomNext(_seed, _atkWeight[_atkWeight.length-1]);\r\n        rand += 1;\r\n        for (uint8 i = 0; i < _atkWeight.length; i++) {\r\n            if (_atkWeight[i] >= rand) {\r\n                return (_seed, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _onBall(uint8 _gameIndex, uint8 _teamIndex, uint8 _playerIndex, uint8 _time, uint8[3][3][31] _gameBalls) internal pure {\r\n        if (_gameBalls[_gameIndex][0][0] == 0) {\r\n            _gameBalls[_gameIndex][0][0] = _time;\r\n            _gameBalls[_gameIndex][0][1] = _teamIndex;\r\n            _gameBalls[_gameIndex][0][2] = _playerIndex;\r\n        }\r\n\r\n        _gameBalls[_gameIndex][2][0] = _time;\r\n        _gameBalls[_gameIndex][2][1] = _teamIndex;\r\n        _gameBalls[_gameIndex][2][2] = _playerIndex;\r\n    }\r\n\r\n    function _onOverTimeBall(uint8 _gameIndex, uint8 _teamIndex, uint8 _playerIndex, uint8 _time, uint8[3][3][31] _gameBalls) internal pure {\r\n        _gameBalls[_gameIndex][1][0] = _time;\r\n        _gameBalls[_gameIndex][1][1] = _teamIndex;\r\n        _gameBalls[_gameIndex][1][2] = _playerIndex;\r\n    }\r\n\r\n    function _battleOvertimeScore(BattleInfo _battleInfo, uint8 _scoreA, uint8 _scoreB,\r\n            uint8[5][11][32] _playerBalls, uint8[3][3][31] _gameBalls) internal returns(uint8 scoreA, uint8 scoreB) {\r\n        bool isAWin;\r\n        uint8 index;\r\n        uint256 scoreTime;\r\n        (isAWin, scoreTime) = _battleOneScore(_battleInfo);\r\n        scoreTime = scoreTime % 30 + 90;\r\n        uint8 teamIndex;\r\n        address addressWin;\r\n        if (isAWin) {\r\n            teamIndex = _battleInfo.indexA;\r\n            scoreA = _scoreA + 1;\r\n            scoreB = _scoreB;\r\n\r\n            addressWin = _battleInfo.addressA;\r\n        } else {\r\n            teamIndex = _battleInfo.indexB;\r\n            scoreA = _scoreA;\r\n            scoreB = _scoreB + 1;\r\n\r\n            addressWin = _battleInfo.addressB;\r\n        }\r\n\r\n        (_battleInfo.seed, index) = _randBall(_battleInfo.seed, _battleInfo.teamInfos[teamIndex].playerAtkWeights);\r\n        uint32 playerId = _battleInfo.allPlayerIds[teamIndex][index];\r\n        Ball(_battleInfo.competitionId, _battleInfo.gameIndex+1, addressWin, playerId, uint8(scoreTime));\r\n        _playerBalls[teamIndex][index][_battleInfo.roundIndex]++;\r\n\r\n        _onBall(_battleInfo.gameIndex, teamIndex, index, uint8(scoreTime), _gameBalls);\r\n        _onOverTimeBall(_battleInfo.gameIndex, teamIndex, index, uint8(scoreTime), _gameBalls);\r\n    }\r\n}\r\n\r\ncontract TournamentInterface {\r\n    /// @dev simply a boolean to indicate this is the contract we expect to be\r\n    function isTournament() public pure returns (bool);\r\n    function isPlayerIdle(address _owner, uint256 _playerId) public view returns (bool);\r\n}\r\n\r\n/// @title Tournament contract for BS.\r\ncontract TournamentCore is TournamentInterface, TournamentCompetition, AccessControl {\r\n\r\n    using SafeMath for uint256;\r\n    function TournamentCore(address _joyTokenContract, address _bsCoreContract, address _randomAddress, address _CFOAddress) public {\r\n\r\n        // the creator of the contract is the initial CEO\r\n        ceoAddress = msg.sender;\r\n\r\n        // the creator of the contract is also the initial COO\r\n        cooAddress = msg.sender;\r\n\r\n        cfoAddress = _CFOAddress;\r\n\r\n        randomContract = RandomInterface(_randomAddress);\r\n\r\n        joyTokenContract = ERC827(_joyTokenContract);\r\n        bsCoreContract = PlayerInterface(_bsCoreContract);\r\n\r\n        nextCompetitionId = 1;\r\n    }\r\n\r\n    function isTournament() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function setMinEnterFee(uint256 minFee) external onlyCEO {\r\n        minEnterFee = minFee;\r\n    }\r\n\r\n    function setOperatingCost(uint32[5] costs) external onlyCEO {\r\n        operatingCosts = costs;\r\n    }\r\n\r\n    function getOperationCost(uint256 teamCount) public view returns (uint256) {\r\n        uint256 cost = 0;\r\n        if (teamCount <= 2) {\r\n            cost = operatingCosts[0];\r\n        } else if(teamCount <= 4) {\r\n            cost = operatingCosts[1];\r\n        } else if(teamCount <= 8) {\r\n            cost = operatingCosts[2];\r\n        } else if(teamCount <= 16) {\r\n            cost = operatingCosts[3];\r\n        } else {\r\n            cost = operatingCosts[4];\r\n        }\r\n        return cost.mul(10**18);\r\n    }\r\n\r\n    function isPlayerIdle(address _owner, uint256 _playerId) public view returns (bool) {\r\n        Team storage teamInfo = userToTeam[_owner];\r\n        for (uint256 i = 0; i < teamInfo.playerIds.length; i++) {\r\n            if (teamInfo.playerIds[i] == _playerId) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function enter(address _sender, uint256 _fees, uint8 _defenceCount, uint8 _midfieldCount, uint8 _forwardCount,\r\n            uint32[11] _playerIds) external whenNotPaused {\r\n        require(_fees >= minEnterFee);\r\n        require(_playerIds.length == 11);\r\n        require(_defenceCount >= 1 && _defenceCount <= 5);\r\n        require(_midfieldCount >= 1 && _midfieldCount <= 5);\r\n        require(_forwardCount >= 1 && _forwardCount <= 5);\r\n        require(_defenceCount + _midfieldCount + _forwardCount == 10);\r\n\r\n        require(msg.sender == address(joyTokenContract) || msg.sender == _sender);\r\n\r\n        require(joyTokenContract.transferFrom(_sender, address(this), _fees));\r\n\r\n        uint32[11] memory ids = _playerIds;\r\n        _insertSortMemory(ids);\r\n        for (uint256 i = 0; i < 11 - 1; i++) {\r\n            require(ids[i] < ids[i + 1]);\r\n        }\r\n\r\n        require(bsCoreContract.checkOwner(_sender, _playerIds));\r\n        uint32[11] memory playerTypes = bsCoreContract.queryPlayerType(_playerIds);\r\n        _insertSortMemory(playerTypes);\r\n        for (i = 0; i < 11 - 1; i++) {\r\n            if (playerTypes[i] > 0) {\r\n                break;\r\n            }\r\n        }\r\n        for (; i < 11 - 1; i++) {\r\n            require(playerTypes[i] < playerTypes[i + 1]);\r\n        }\r\n\r\n        Team storage teamInfo = userToTeam[_sender];\r\n        require(teamInfo.status == TeamStatus.Normal);\r\n        enterInner(_sender, _fees, _defenceCount, _midfieldCount, _forwardCount, _playerIds, teamInfo);\r\n\r\n        Enter(_sender, _fees, _defenceCount, _midfieldCount, _forwardCount, _playerIds);\r\n    }\r\n\r\n    function cancelEnter(address _user) external onlyCOO {\r\n        Team storage teamInfo = userToTeam[_user];\r\n        require(teamInfo.status == TeamStatus.Enter);\r\n        uint256 fees = teamInfo.fees;\r\n        uint128 index = teamInfo.index;\r\n        require(teamUserInfo[index-1] == _user);\r\n        if (index < teamUserInfo.length) {\r\n            address user = teamUserInfo[teamUserInfo.length-1];\r\n            teamUserInfo[index-1] = user;\r\n            userToTeam[user].index = index;\r\n        }\r\n        teamUserInfo.length--;\r\n        delete userToTeam[_user];\r\n\r\n        require(joyTokenContract.transfer(_user, fees));\r\n        CancelEnter(_user);\r\n    }\r\n\r\n    function cancelAllEnter() external onlyCOO {\r\n        for (uint256 i = 0; i < teamUserInfo.length; i++) {\r\n            address user = teamUserInfo[i];\r\n            Team storage teamInfo = userToTeam[user];\r\n            require(teamInfo.status == TeamStatus.Enter);\r\n            uint256 fees = teamInfo.fees;\r\n\r\n            // uint256 index = teamInfo.index;\r\n            // require(teamUserInfo[index-1] == user);\r\n\r\n            delete userToTeam[user];\r\n\r\n            require(joyTokenContract.transfer(user, fees));\r\n            CancelEnter(user);\r\n        }\r\n        teamUserInfo.length = 0;\r\n    }\r\n\r\n    function enterInner(address _sender, uint256 _value, uint8 _defenceCount, uint8 _midfieldCount, uint8 _forwardCount,\r\n        uint32[11] _playerIds, Team storage _teamInfo) internal {\r\n\r\n        uint16[11] memory playerAtkWeights;\r\n        uint256[3] memory teamAttrs;\r\n        (teamAttrs, playerAtkWeights) = _calTeamAttribute(_defenceCount, _midfieldCount, _forwardCount, _playerIds);\r\n        uint256 teamIdx = teamUserInfo.length++;\r\n        teamUserInfo[teamIdx] = _sender;\r\n        _teamInfo.status = TeamStatus.Enter;\r\n\r\n        require((teamIdx + 1) == uint256(uint128(teamIdx + 1)));\r\n        _teamInfo.index = uint128(teamIdx + 1);\r\n\r\n        _teamInfo.attack = uint16(teamAttrs[0]);\r\n        _teamInfo.defense = uint16(teamAttrs[1]);\r\n        _teamInfo.stamina = uint16(teamAttrs[2]);\r\n\r\n        _teamInfo.playerIds = _playerIds;\r\n        _teamInfo.playerAtkWeights = playerAtkWeights;\r\n\r\n        _teamInfo.fees = _value;\r\n    }\r\n\r\n    function getTeamAttribute(uint8 _defenceCount, uint8 _midfieldCount, uint8 _forwardCount,\r\n        uint32[11] _playerIds) external view returns (uint256 attack, uint256 defense, uint256 stamina) {\r\n        uint256[3] memory teamAttrs;\r\n        uint16[11] memory playerAtkWeights;\r\n        (teamAttrs, playerAtkWeights) = _calTeamAttribute(_defenceCount, _midfieldCount, _forwardCount, _playerIds);\r\n        attack = teamAttrs[0];\r\n        defense = teamAttrs[1];\r\n        stamina = teamAttrs[2];\r\n    }\r\n\r\n    function _calTeamAttribute(uint8 _defenceCount, uint8 _midfieldCount, uint8 _forwardCount,\r\n        uint32[11] _playerIds) internal view returns (uint256[3] _attrs, uint16[11] _playerAtkWeights) {\r\n\r\n        uint256[3][11] memory playerAttrs;\r\n\r\n        _getAttribute(_playerIds, 0, PlayerPosType.GoalKeeper, 1, 0, playerAttrs);\r\n        uint8 startIndex = 1;\r\n        uint8 i;\r\n        for (i = startIndex; i < startIndex + _defenceCount; i++) {\r\n            _getAttribute(_playerIds, i, PlayerPosType.Defence, _defenceCount, i - startIndex, playerAttrs);\r\n        }\r\n        startIndex = startIndex + _defenceCount;\r\n        for (i = startIndex; i < startIndex + _midfieldCount; i++) {\r\n            _getAttribute(_playerIds, i, PlayerPosType.Midfield, _midfieldCount, i - startIndex, playerAttrs);\r\n        }\r\n        startIndex = startIndex + _midfieldCount;\r\n        for (i = startIndex; i < startIndex + _forwardCount; i++) {\r\n            _getAttribute(_playerIds, i, PlayerPosType.Forward, _forwardCount, i - startIndex, playerAttrs);\r\n        }\r\n\r\n        uint16 lastAtkWeight = 0;\r\n        for (i = 0; i < _playerIds.length; i++) {\r\n            _attrs[0] += playerAttrs[i][0];\r\n            _attrs[1] += playerAttrs[i][1];\r\n            _attrs[2] += playerAttrs[i][2];\r\n            _playerAtkWeights[i] = uint16(lastAtkWeight + playerAttrs[i][0] / 10000);\r\n            lastAtkWeight = _playerAtkWeights[i];\r\n        }\r\n\r\n        _attrs[0] /= 10000;\r\n        _attrs[1] /= 10000;\r\n        _attrs[2] /= 10000;\r\n    }\r\n\r\n    function _getAttribute(uint32[11] _playerIds, uint8 _i, PlayerPosType _type, uint8 _typeSize, uint8 _typeIndex, uint256[3][11] playerAttrs)\r\n    internal view {\r\n        uint8 xPos;\r\n        uint8 yPos;\r\n        (xPos, yPos) = _getPos(_type, _typeSize, _typeIndex);\r\n\r\n        uint16[8] memory a = bsCoreContract.queryPlayer(_playerIds[_i]);\r\n        uint256 aWeight;\r\n        uint256 dWeight;\r\n        (aWeight, dWeight) = _getWeight(yPos);\r\n        uint256 sWeight = 100 - aWeight - dWeight;\r\n        if (_type == PlayerPosType.GoalKeeper && a[5] == 1) {\r\n            dWeight += dWeight;\r\n        }\r\n        uint256 xWeight = 50;\r\n        if (xPos + 1 >= a[4] && xPos <= a[4] + 1) {\r\n            xWeight = 100;\r\n        }\r\n        playerAttrs[_i][0] = (a[1] * aWeight * xWeight);\r\n        playerAttrs[_i][1] = (a[2] * dWeight * xWeight);\r\n        playerAttrs[_i][2] = (a[3] * sWeight * xWeight);\r\n    }\r\n\r\n    function _getWeight(uint256 yPos) internal pure returns (uint256, uint256) {\r\n        if (yPos == 0) {\r\n            return (5, 90);\r\n        }\r\n        if (yPos == 1) {\r\n            return (10, 80);\r\n        }\r\n        if (yPos == 2) {\r\n            return (10, 70);\r\n        }\r\n        if (yPos == 3) {\r\n            return (10, 60);\r\n        }\r\n        if (yPos == 4) {\r\n            return (20, 30);\r\n        }\r\n        if (yPos == 5) {\r\n            return (20, 20);\r\n        }\r\n        if (yPos == 6) {\r\n            return (30, 20);\r\n        }\r\n        if (yPos == 7) {\r\n            return (60, 10);\r\n        }\r\n        if (yPos == 8) {\r\n            return (70, 10);\r\n        }\r\n        if (yPos == 9) {\r\n            return (80, 10);\r\n        }\r\n    }\r\n\r\n    function _getPos(PlayerPosType _type, uint8 _size, uint8 _index) internal pure returns (uint8, uint8) {\r\n        uint8 yPosOffset = 0;\r\n        if (_type == PlayerPosType.GoalKeeper) {\r\n            return (3, 0);\r\n        }\r\n        if (_type == PlayerPosType.Midfield) {\r\n            yPosOffset += 3;\r\n        }\r\n        if (_type == PlayerPosType.Forward) {\r\n            yPosOffset += 6;\r\n        }\r\n        if (_size == 5) {\r\n            if (_index == 0) {\r\n                return (0, 2 + yPosOffset);\r\n            }\r\n            if (_index == 1) {\r\n                return (2, 2 + yPosOffset);\r\n            }\r\n            if (_index == 2) {\r\n                return (4, 2 + yPosOffset);\r\n            }\r\n            if (_index == 3) {\r\n                return (6, 2 + yPosOffset);\r\n            } else {\r\n                return (3, 3 + yPosOffset);\r\n            }\r\n        }\r\n        if (_size == 4) {\r\n            if (_index == 0) {\r\n                return (0, 2 + yPosOffset);\r\n            }\r\n            if (_index == 1) {\r\n                return (2, 2 + yPosOffset);\r\n            }\r\n            if (_index == 2) {\r\n                return (4, 2 + yPosOffset);\r\n            } else {\r\n                return (6, 2 + yPosOffset);\r\n            }\r\n        }\r\n        if (_size == 3) {\r\n            if (_index == 0) {\r\n                return (1, 2 + yPosOffset);\r\n            }\r\n            if (_index == 1) {\r\n                return (3, 2 + yPosOffset);\r\n            } else {\r\n                return (5, 2 + yPosOffset);\r\n            }\r\n        }\r\n        if (_size == 2) {\r\n            if (_index == 0) {\r\n                return (2, 2 + yPosOffset);\r\n            } else {\r\n                return (4, 2 + yPosOffset);\r\n            }\r\n        }\r\n        if (_size == 1) {\r\n            return (3, 2 + yPosOffset);\r\n        }\r\n    }\r\n\r\n    ///\r\n    function start(uint8 _minTeamCount) external onlyCOO whenNotPaused returns (uint256) {\r\n        require(teamUserInfo.length >= _minTeamCount);\r\n\r\n        uint256 competitionId = nextCompetitionId++;\r\n        CompetitionInfo storage ci = competitionInfos[competitionId];\r\n        //ci.startTime = uint64(now);\r\n        ci.status = CompetitionStatus.Start;\r\n\r\n        //randomize the last _minTeamCount(=32) teams, and take them out.\r\n        uint256 i;\r\n        uint256 startI = teamUserInfo.length - _minTeamCount;\r\n        uint256 j;\r\n        require(ci.users.length >= _minTeamCount);\r\n        ci.userCount = _minTeamCount;\r\n        uint256 seed = randomContract.maxRandom();\r\n        address[32] memory selectUserInfo;\r\n        for (i = startI; i < teamUserInfo.length; i++) {\r\n            selectUserInfo[i - startI] = teamUserInfo[i];\r\n        }\r\n        i = teamUserInfo.length;\r\n        teamUserInfo.length = teamUserInfo.length - _minTeamCount;\r\n        for (; i > startI; i--) {\r\n\r\n            //random from 0 to i\r\n            uint256 m;\r\n            (seed, m) = randomContract.randomNext(seed, i);\r\n\r\n            //take out [m], put into competitionInfo\r\n            address user;\r\n            if (m < startI) {\r\n                user = teamUserInfo[m];\r\n            } else {\r\n                user = selectUserInfo[m-startI];\r\n            }\r\n            ci.users[j] = user;\r\n            Team storage teamInfo = userToTeam[user];\r\n            teamInfo.status = TeamStatus.Competition;\r\n            teamInfo.index = uint128(competitionId);\r\n\r\n            SponsorsInfo storage si = sponsorInfos[competitionId][j];\r\n            si.sponsors[user] = (si.sponsors[user]).add(teamInfo.fees);\r\n            si.totalAmount = (si.totalAmount).add(teamInfo.fees);\r\n\r\n            //exchange [i - 1] and [m]\r\n            if (m != i - 1) {\r\n\r\n                user = selectUserInfo[i - 1 - startI];\r\n            \r\n                if (m < startI) {\r\n                    teamUserInfo[m] = user;\r\n                    userToTeam[user].index = uint128(m + 1);\r\n                } else {\r\n                    selectUserInfo[m - startI] = user;\r\n                }\r\n            }\r\n\r\n            //delete [i - 1]\r\n            //delete teamUserInfo[i - 1];\r\n            j++;\r\n        }\r\n\r\n        StartCompetition(competitionId, now, ci.users);\r\n\r\n        return competitionId;\r\n    }\r\n\r\n    function sponsor(address _sender, uint256 _competitionId, uint256 _teamIdx, uint256 _count) external whenNotPaused returns (bool) {\r\n        require(msg.sender == address(joyTokenContract) || msg.sender == _sender);\r\n\r\n        CompetitionInfo storage ci = competitionInfos[_competitionId];\r\n        require(ci.status == CompetitionStatus.Start);\r\n        //require(now < ci.startTime + sponsorInterval);\r\n\r\n        require(joyTokenContract.transferFrom(_sender, address(this), _count));\r\n\r\n        require(_teamIdx < ci.userCount);\r\n        address targetUser = ci.users[_teamIdx];\r\n        Team storage teamInfo = userToTeam[targetUser];\r\n        require(teamInfo.status == TeamStatus.Competition);\r\n        \r\n        SponsorsInfo storage si = sponsorInfos[_competitionId][_teamIdx];\r\n        si.sponsors[_sender] = (si.sponsors[_sender]).add(_count);\r\n        si.totalAmount = (si.totalAmount).add(_count);\r\n\r\n        Sponsor(_sender, _competitionId, targetUser, _count);\r\n    }\r\n\r\n    function reward(uint256 _competitionId, uint256 _teamIdx) external whenNotPaused {\r\n        require(_teamIdx < 32);\r\n\r\n        SponsorsInfo storage si = sponsorInfos[_competitionId][_teamIdx];\r\n        uint256 baseValue = si.sponsors[msg.sender];\r\n        require(baseValue > 0);\r\n        CompetitionInfo storage ci = competitionInfos[_competitionId];\r\n        if (ci.status == CompetitionStatus.Cancel) {\r\n            // if (msg.sender == ci.users[_teamIdx]) {\r\n            //     Team storage teamInfo = userToTeam[msg.sender];\r\n            //     require(teamInfo.index == _competitionId && teamInfo.status == TeamStatus.Competition);\r\n            //     delete userToTeam[msg.sender];\r\n            // }\r\n            delete si.sponsors[msg.sender];\r\n            require(joyTokenContract.transfer(msg.sender, baseValue));\r\n        } else if (ci.status == CompetitionStatus.End) {\r\n            require(ci.teamWinCounts[_teamIdx] > 0);\r\n\r\n            uint256 rewardValue = baseValue.mul(_getWinCountWeight(ci.teamWinCounts[_teamIdx]));\r\n            rewardValue = ci.totalReward.mul(rewardValue) / ci.totalWeight;\r\n            rewardValue = rewardValue.add(baseValue);\r\n\r\n            Reward(_competitionId, ci.users[_teamIdx], ci.teamWinCounts[_teamIdx], msg.sender, baseValue, rewardValue);\r\n\r\n            delete si.sponsors[msg.sender];\r\n\r\n            require(joyTokenContract.transfer(msg.sender, rewardValue));\r\n        }\r\n    }\r\n\r\n    function competition(uint256 _id) external onlyCOO whenNotPaused {\r\n        CompetitionInfo storage ci = competitionInfos[_id];\r\n        require(ci.status == CompetitionStatus.Start);\r\n\r\n        uint8[32] memory teamWinCounts;\r\n        uint32[3][11][32] memory playerAwakeSkills;\r\n        TournamentCompetition.competition(_id, ci, teamWinCounts, playerAwakeSkills);\r\n\r\n        _reward(_id, ci, teamWinCounts);\r\n\r\n        bsCoreContract.tournamentResult(playerAwakeSkills);\r\n\r\n        for (uint256 i = 0; i < ci.userCount; i++) {\r\n            delete userToTeam[ci.users[i]];\r\n        }\r\n    }\r\n\r\n    function cancelCompetition(uint256 _id) external onlyCOO {\r\n        CompetitionInfo storage ci = competitionInfos[_id];\r\n        require(ci.status == CompetitionStatus.Start);\r\n        ci.status = CompetitionStatus.Cancel;\r\n\r\n        for (uint256 i = 0; i < ci.userCount; i++) {\r\n            //Team storage teamInfo = userToTeam[ci.users[i]];\r\n            //require(teamInfo.index == _id && teamInfo.status == TeamStatus.Competition);\r\n\r\n            delete userToTeam[ci.users[i]];\r\n        }\r\n\r\n        CancelCompetition(_id);\r\n    }\r\n\r\n    function _getWinCountWeight(uint256 _winCount) internal pure returns (uint256) {\r\n        if (_winCount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (_winCount == 1) {\r\n            return 1;\r\n        }\r\n\r\n        if (_winCount == 2) {\r\n            return 2;\r\n        }\r\n\r\n        if (_winCount == 3) {\r\n            return 3;\r\n        }\r\n\r\n        if (_winCount == 4) {\r\n            return 4;\r\n        }\r\n\r\n        if (_winCount >= 5) {\r\n            return 8;\r\n        }\r\n    }\r\n\r\n    function _reward(uint256 _competitionId, CompetitionInfo storage ci, uint8[32] teamWinCounts) internal {\r\n        uint256 totalReward = 0;\r\n        uint256 totalWeight = 0;\r\n        uint256 i;\r\n        for (i = 0; i < ci.userCount; i++) {\r\n            if (teamWinCounts[i] == 0) {\r\n                totalReward = totalReward.add(sponsorInfos[_competitionId][i].totalAmount);\r\n            } else {\r\n                uint256 weight = sponsorInfos[_competitionId][i].totalAmount;\r\n                weight = weight.mul(_getWinCountWeight(teamWinCounts[i]));\r\n                totalWeight = totalWeight.add(weight);\r\n            }\r\n        }\r\n\r\n        uint256 cost = getOperationCost(ci.userCount);\r\n\r\n        uint256 ownerCut;\r\n        if (totalReward > cost) {\r\n            ownerCut = cost.add((totalReward - cost).mul(3)/100);\r\n            totalReward = totalReward.sub(ownerCut);\r\n        } else {\r\n            ownerCut = totalReward;\r\n            totalReward = 0;\r\n        }\r\n\r\n        require(joyTokenContract.transfer(cfoAddress, ownerCut));\r\n\r\n        ci.totalReward = totalReward;\r\n        ci.totalWeight = totalWeight;\r\n        ci.teamWinCounts = teamWinCounts;\r\n        ci.status = CompetitionStatus.End;\r\n\r\n        EndCompetition(_competitionId, totalReward, totalWeight, teamWinCounts);\r\n    }\r\n\r\n    function _insertSortMemory(uint32[11] arr) internal pure {\r\n        uint256 n = arr.length;\r\n        uint256 i;\r\n        uint32 key;\r\n        uint256 j;\r\n\r\n        for (i = 1; i < n; i++) {\r\n            key = arr[i];\r\n\r\n            for (j = i; j > 0 && arr[j-1] > key; j--) {\r\n                arr[j] = arr[j-1];\r\n            }\r\n\r\n            arr[j] = key;\r\n        }\r\n    }\r\n\r\n    function getTeam(address _owner) external view returns (uint256 index, uint256 fees, uint32[11] playerIds,\r\n            uint16[11] playerAtkWeights, TeamStatus status, uint16 attack, uint16 defense, uint16 stamina) {\r\n        Team storage teamInfo = userToTeam[_owner];\r\n        index = teamInfo.index;\r\n        fees = teamInfo.fees;\r\n        playerIds = teamInfo.playerIds;\r\n        playerAtkWeights = teamInfo.playerAtkWeights;\r\n        status = teamInfo.status;\r\n        attack = teamInfo.attack;\r\n        defense = teamInfo.defense;\r\n        stamina = teamInfo.stamina;\r\n    }\r\n\r\n    function getCompetitionInfo(uint256 _id) external view returns (uint256 totalReward, uint256 totalWeight,\r\n            address[32] users, uint8[32] teamWinCounts, uint8 userCount, CompetitionStatus status) {\r\n        CompetitionInfo storage ci = competitionInfos[_id];\r\n        //startTime = ci.startTime;\r\n        totalReward = ci.totalReward;\r\n        totalWeight = ci.totalWeight;\r\n        users = ci.users;\r\n        teamWinCounts = ci.teamWinCounts;\r\n        userCount = ci.userCount;\r\n        status = ci.status;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getCompetitionInfo\",\"outputs\":[{\"name\":\"totalReward\",\"type\":\"uint256\"},{\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"name\":\"users\",\"type\":\"address[32]\"},{\"name\":\"teamWinCounts\",\"type\":\"uint8[32]\"},{\"name\":\"userCount\",\"type\":\"uint8\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_defenceCount\",\"type\":\"uint8\"},{\"name\":\"_midfieldCount\",\"type\":\"uint8\"},{\"name\":\"_forwardCount\",\"type\":\"uint8\"},{\"name\":\"_playerIds\",\"type\":\"uint32[11]\"}],\"name\":\"getTeamAttribute\",\"outputs\":[{\"name\":\"attack\",\"type\":\"uint256\"},{\"name\":\"defense\",\"type\":\"uint256\"},{\"name\":\"stamina\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joyTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"teamCount\",\"type\":\"uint256\"}],\"name\":\"getOperationCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"cancelEnter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatingCosts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sponsorInfos\",\"outputs\":[{\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToTeam\",\"outputs\":[{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint128\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"attack\",\"type\":\"uint16\"},{\"name\":\"defense\",\"type\":\"uint16\"},{\"name\":\"stamina\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTournament\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelAllEnter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"competition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTeam\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"playerIds\",\"type\":\"uint32[11]\"},{\"name\":\"playerAtkWeights\",\"type\":\"uint16[11]\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"attack\",\"type\":\"uint16\"},{\"name\":\"defense\",\"type\":\"uint16\"},{\"name\":\"stamina\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"competitionInfos\",\"outputs\":[{\"name\":\"totalReward\",\"type\":\"uint256\"},{\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"userCount\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_competitionId\",\"type\":\"uint256\"},{\"name\":\"_teamIdx\",\"type\":\"uint256\"}],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"costs\",\"type\":\"uint32[5]\"}],\"name\":\"setOperatingCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_competitionId\",\"type\":\"uint256\"},{\"name\":\"_teamIdx\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"sponsor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minTeamCount\",\"type\":\"uint8\"}],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_fees\",\"type\":\"uint256\"},{\"name\":\"_defenceCount\",\"type\":\"uint8\"},{\"name\":\"_midfieldCount\",\"type\":\"uint8\"},{\"name\":\"_forwardCount\",\"type\":\"uint8\"},{\"name\":\"_playerIds\",\"type\":\"uint32[11]\"}],\"name\":\"enter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"cancelCompetition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minFee\",\"type\":\"uint256\"}],\"name\":\"setMinEnterFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_playerId\",\"type\":\"uint256\"}],\"name\":\"isPlayerIdle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minEnterFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_joyTokenContract\",\"type\":\"address\"},{\"name\":\"_bsCoreContract\",\"type\":\"address\"},{\"name\":\"_randomAddress\",\"type\":\"address\"},{\"name\":\"_CFOAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"defenceCount\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"midfieldCount\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"forwardCount\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"playerIds\",\"type\":\"uint32[11]\"}],\"name\":\"Enter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"CancelEnter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"users\",\"type\":\"address[32]\"}],\"name\":\"StartCompetition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"CancelCompetition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"competitionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Sponsor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"competitionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gameIndex\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint8\"}],\"name\":\"Ball\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"competitionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gameIndex\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"userA\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"scoreA\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"userB\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"scoreB\",\"type\":\"uint8\"}],\"name\":\"Battle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"competitionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Champion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"competitionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalReward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"teamWinCounts\",\"type\":\"uint8[32]\"}],\"name\":\"EndCompetition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"competitionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winCount\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sponsorAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"}]","ContractName":"TournamentCore","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000eac3cf28cc9bf82915804325ef9e05ac65de79e3000000000000000000000000e9b9480767774ccb29f3502629bfab1ed74bee36000000000000000000000000092fc5e91c67b9a5a280f760a61893bbc647d55d000000000000000000000000b0433bf21b0cddc652a7c82635046221239a01f7","Library":"","SwarmSource":"bzzr://3056774084b8f2b8d3edb126687a6699e3593195bfeb6cb4c4b91e1594482fb7"}]}