{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n * @title ERC20\r\n * @dev ERC20 interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// @dev Crowdsale interface for Etheal Normal Sale, functions needed from outside.\r\ncontract iEthealSale {\r\n    bool public paused;\r\n    uint256 public minContribution;\r\n    uint256 public whitelistThreshold;\r\n    mapping (address => uint256) public stakes;\r\n    function setPromoBonus(address _investor, uint256 _value) public;\r\n    function buyTokens(address _beneficiary) public payable;\r\n    function depositEth(address _beneficiary, uint256 _time, bytes _whitelistSign) public payable;\r\n    function depositOffchain(address _beneficiary, uint256 _amount, uint256 _time) public;\r\n    function hasEnded() public constant returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title claim accidentally sent tokens\r\n */\r\ncontract HasNoTokens is Ownable {\r\n    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\r\n\r\n    /// @notice This method can be used to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    /// @param _claimer Address that tokens will be send to\r\n    function extractTokens(address _token, address _claimer) onlyOwner public {\r\n        if (_token == 0x0) {\r\n            _claimer.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20 token = ERC20(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(_claimer, balance);\r\n        ExtractedTokens(_token, _claimer, balance);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title EthealWhitelist\r\n * @author thesved\r\n * @notice EthealWhitelist contract which handles KYC\r\n */\r\ncontract EthealWhitelist is Ownable {\r\n    using ECRecovery for bytes32;\r\n\r\n    // signer address for offchain whitelist signing\r\n    address public signer;\r\n\r\n    // storing whitelisted addresses\r\n    mapping(address => bool) public isWhitelisted;\r\n\r\n    event WhitelistSet(address indexed _address, bool _state);\r\n\r\n    ////////////////\r\n    // Constructor\r\n    ////////////////\r\n    function EthealWhitelist(address _signer) {\r\n        require(_signer != address(0));\r\n\r\n        signer = _signer;\r\n    }\r\n\r\n    /// @notice set signing address after deployment\r\n    function setSigner(address _signer) public onlyOwner {\r\n        require(_signer != address(0));\r\n\r\n        signer = _signer;\r\n    }\r\n\r\n    ////////////////\r\n    // Whitelisting: only owner\r\n    ////////////////\r\n\r\n    /// @notice Set whitelist state for an address.\r\n    function setWhitelist(address _addr, bool _state) public onlyOwner {\r\n        require(_addr != address(0));\r\n        isWhitelisted[_addr] = _state;\r\n        WhitelistSet(_addr, _state);\r\n    }\r\n\r\n    /// @notice Set whitelist state for multiple addresses\r\n    function setManyWhitelist(address[] _addr, bool _state) public onlyOwner {\r\n        for (uint256 i = 0; i < _addr.length; i++) {\r\n            setWhitelist(_addr[i], _state);\r\n        }\r\n    }\r\n\r\n    /// @notice offchain whitelist check\r\n    function isOffchainWhitelisted(address _addr, bytes _sig) public view returns (bool) {\r\n        bytes32 hash = keccak256(\"\\x19Ethereum Signed Message:\\n20\",_addr);\r\n        return hash.recover(_sig) == signer;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title EthealDeposit\r\n * @author thesved\r\n * @dev This contract is used for storing funds while doing Whitelist\r\n */\r\ncontract EthealDeposit is Ownable, HasNoTokens {\r\n    using SafeMath for uint256;\r\n\r\n    // storing deposits: make sure they fit in 2 x 32 byte\r\n    struct Deposit {\r\n        uint256 amount;         // 32 byte\r\n        address beneficiary;    // 20 byte\r\n        uint64 time;            // 8 byte\r\n        bool cleared;           // 1 bit\r\n    }\r\n    uint256 public transactionCount;\r\n    uint256 public pendingCount;\r\n    mapping (uint256 => Deposit) public transactions;    // store transactions\r\n    mapping (address => uint256[]) public addressTransactions;  // store transaction ids for addresses\r\n    \r\n    // sale contract to which we forward funds\r\n    iEthealSale public sale;\r\n    EthealWhitelist public whitelist;\r\n\r\n    event LogDeposited(address indexed beneficiary, uint256 weiAmount, uint256 id);\r\n    event LogRefunded(address indexed beneficiary, uint256 weiAmount, uint256 id);\r\n    event LogForwarded(address indexed beneficiary, uint256 weiAmount, uint256 id);\r\n\r\n    ////////////////\r\n    // Constructor\r\n    ////////////////\r\n\r\n    /// @notice Etheal deposit constructor\r\n    /// @param _sale address of sale contract\r\n    /// @param _whitelist address of whitelist contract\r\n    function EthealDeposit(address _sale, address _whitelist) {\r\n        require(_sale != address(0));\r\n        sale = iEthealSale(_sale);\r\n        whitelist = EthealWhitelist(_whitelist);\r\n    }\r\n\r\n    /// @notice Set sale contract address\r\n    function setSale(address _sale) public onlyOwner {\r\n        sale = iEthealSale(_sale);\r\n    }\r\n\r\n    /// @notice Set whitelist contract address\r\n    function setWhitelist(address _whitelist) public onlyOwner {\r\n        whitelist = EthealWhitelist(_whitelist);\r\n    }\r\n\r\n    /// @dev Override HasNoTokens#extractTokens to not be able to extract tokens until saleEnd and everyone got their funds back\r\n    function extractTokens(address _token, address _claimer) public onlyOwner saleEnded {\r\n        require(pendingCount == 0);\r\n\r\n        super.extractTokens(_token, _claimer);\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // Deposit, forward, refund\r\n    ////////////////\r\n\r\n    modifier whitelistSet() {\r\n        require(address(whitelist) != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier saleNotEnded() {\r\n        require(address(sale) != address(0) && !sale.hasEnded());\r\n        _;\r\n    }\r\n\r\n    modifier saleNotPaused() {\r\n        require(address(sale) != address(0) && !sale.paused());\r\n        _;\r\n    }\r\n\r\n    modifier saleEnded() {\r\n        require(address(sale) != address(0) && sale.hasEnded());\r\n        _;\r\n    }\r\n\r\n    /// @notice payable fallback calls the deposit function\r\n    function() public payable {\r\n        deposit(msg.sender, \"\");\r\n    }\r\n\r\n    /// @notice depositing for investor, return transaction Id\r\n    /// @param _investor address of investor\r\n    /// @param _whitelistSign offchain whitelist signiture for address, optional\r\n    function deposit(address _investor, bytes _whitelistSign) public payable whitelistSet saleNotEnded returns (uint256) {\r\n        require(_investor != address(0));\r\n        require(msg.value > 0);\r\n        require(msg.value >= sale.minContribution());\r\n\r\n        uint256 transactionId = addTransaction(_investor, msg.value);\r\n\r\n        // forward transaction automatically if whitelist is okay, so the transaction doesnt revert\r\n        if (whitelist.isWhitelisted(_investor) \r\n            || whitelist.isOffchainWhitelisted(_investor, _whitelistSign) \r\n            || sale.whitelistThreshold() >= sale.stakes(_investor).add(msg.value)\r\n        ) {\r\n            // only forward if sale is not paused\r\n            if (!sale.paused()) {\r\n                forwardTransactionInternal(transactionId, _whitelistSign);\r\n            }\r\n        }\r\n\r\n        return transactionId;\r\n    }\r\n\r\n    /// @notice forwarding a transaction\r\n    function forwardTransaction(uint256 _id, bytes _whitelistSign) public whitelistSet saleNotEnded saleNotPaused {\r\n        require(forwardTransactionInternal(_id, _whitelistSign));\r\n    }\r\n\r\n    /// @notice forwarding multiple transactions: check whitelist\r\n    function forwardManyTransaction(uint256[] _ids) public whitelistSet saleNotEnded saleNotPaused {\r\n        uint256 _threshold = sale.whitelistThreshold();\r\n\r\n        for (uint256 i=0; i<_ids.length; i++) {\r\n            // only forward if it is within threshold or whitelisted, so the transaction doesnt revert\r\n            if ( whitelist.isWhitelisted(transactions[_ids[i]].beneficiary) \r\n                || _threshold >= sale.stakes(transactions[_ids[i]].beneficiary).add(transactions[_ids[i]].amount )\r\n            ) {\r\n                forwardTransactionInternal(_ids[i],\"\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice forwarding transactions for an investor\r\n    function forwardInvestorTransaction(address _investor, bytes _whitelistSign) public whitelistSet saleNotEnded saleNotPaused {\r\n        bool _whitelisted = whitelist.isWhitelisted(_investor) || whitelist.isOffchainWhitelisted(_investor, _whitelistSign);\r\n        uint256 _amount = sale.stakes(_investor);\r\n        uint256 _threshold = sale.whitelistThreshold();\r\n\r\n        for (uint256 i=0; i<addressTransactions[_investor].length; i++) {\r\n            _amount = _amount.add(transactions[ addressTransactions[_investor][i] ].amount);\r\n            // only forward if it is within threshold or whitelisted, so the transaction doesnt revert\r\n            if (_whitelisted || _threshold >= _amount) {\r\n                forwardTransactionInternal(addressTransactions[_investor][i], _whitelistSign);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice refunding a transaction\r\n    function refundTransaction(uint256 _id) public saleEnded {\r\n        require(refundTransactionInternal(_id));\r\n    }\r\n\r\n    /// @notice refunding multiple transactions\r\n    function refundManyTransaction(uint256[] _ids) public saleEnded {\r\n        for (uint256 i=0; i<_ids.length; i++) {\r\n            refundTransactionInternal(_ids[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice refunding an investor\r\n    function refundInvestor(address _investor) public saleEnded {\r\n        for (uint256 i=0; i<addressTransactions[_investor].length; i++) {\r\n            refundTransactionInternal(addressTransactions[_investor][i]);\r\n        }\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // Internal functions\r\n    ////////////////\r\n\r\n    /// @notice add transaction and returns its id\r\n    function addTransaction(address _investor, uint256 _amount) internal returns (uint256) {\r\n        uint256 transactionId = transactionCount;\r\n\r\n        // save transaction\r\n        transactions[transactionId] = Deposit({\r\n            amount: _amount,\r\n            beneficiary: _investor,\r\n            time: uint64(now),\r\n            cleared : false\r\n        });\r\n\r\n        // save transactionId for investor address\r\n        addressTransactions[_investor].push(transactionId);\r\n\r\n        transactionCount = transactionCount.add(1);\r\n        pendingCount = pendingCount.add(1);\r\n        LogDeposited(_investor, _amount, transactionId);\r\n\r\n        return transactionId;\r\n    }\r\n\r\n    /// @notice Forwarding a transaction, internal function, doesn't check sale status for speed up mass actions.\r\n    /// @return whether forward was successful or not\r\n    function forwardTransactionInternal(uint256 _id, bytes memory _whitelistSign) internal returns (bool) {\r\n        require(_id < transactionCount);\r\n\r\n        // if already cleared then return false\r\n        if (transactions[_id].cleared) {\r\n            return false;\r\n        }\r\n\r\n        // fixing bytes data to argument call data: data -> {data position}{data length}data\r\n        bytes memory _whitelistCall = bytesToArgument(_whitelistSign, 96);\r\n\r\n        // forwarding transaction to sale contract\r\n        if (! sale.call.value(transactions[_id].amount)(bytes4(keccak256('depositEth(address,uint256,bytes)')), transactions[_id].beneficiary, uint256(transactions[_id].time), _whitelistCall) ) {\r\n            return false;\r\n        }\r\n        transactions[_id].cleared = true;\r\n\r\n        pendingCount = pendingCount.sub(1);\r\n        LogForwarded(transactions[_id].beneficiary, transactions[_id].amount, _id);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Fixing low level call for providing signature information: create proper padding for bytes information\r\n    function bytesToArgument(bytes memory _sign, uint256 _position) internal pure returns (bytes memory c) {\r\n        uint256 signLength = _sign.length;\r\n        uint256 totalLength = signLength.add(64);\r\n        uint256 loopMax = signLength.add(31).div(32);\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(m, totalLength)          // store the total length\r\n            mstore(add(m,32), _position)    // where does the data start\r\n            mstore(add(m,64), signLength)   // store the length of signature\r\n            for {  let i := 0 } lt(i, loopMax) { i := add(1, i) } { mstore(add(m, mul(32, add(3, i))), mload(add(_sign, mul(32, add(1, i))))) }\r\n            mstore(0x40, add(m, add(32, totalLength)))\r\n            c := m\r\n        }\r\n    }\r\n\r\n    /// @notice Send back non-cleared transactions after sale is over, not checking status for speeding up mass actions\r\n    function refundTransactionInternal(uint256 _id) internal returns (bool) {\r\n        require(_id < transactionCount);\r\n\r\n        // if already cleared then return false\r\n        if (transactions[_id].cleared) {\r\n            return false;\r\n        }\r\n\r\n        // sending back funds\r\n        transactions[_id].cleared = true;\r\n        transactions[_id].beneficiary.transfer(transactions[_id].amount);\r\n\r\n        pendingCount = pendingCount.sub(1);\r\n        LogRefunded(transactions[_id].beneficiary, transactions[_id].amount, _id);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    ////////////////\r\n    // External functions\r\n    ////////////////\r\n\r\n    /// @notice gives back transaction ids based on filtering\r\n    function getTransactionIds(uint256 from, uint256 to, bool _cleared, bool _nonCleared) view external returns (uint256[] ids) {\r\n        uint256 i = 0;\r\n        uint256 results = 0;\r\n        uint256[] memory _ids = new uint256[](transactionCount);\r\n\r\n        // search in contributors\r\n        for (i = 0; i < transactionCount; i++) {\r\n            if (_cleared && transactions[i].cleared || _nonCleared && !transactions[i].cleared) {\r\n                _ids[results] = i;\r\n                results++;\r\n            }\r\n        }\r\n\r\n        ids = new uint256[](results);\r\n        for (i = from; i <= to && i < results; i++) {\r\n            ids[i] = _ids[i];\r\n        }\r\n\r\n        return ids;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressTransactions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sale\",\"type\":\"address\"}],\"name\":\"setSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_whitelistSign\",\"type\":\"bytes\"}],\"name\":\"forwardInvestorTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"forwardManyTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint64\"},{\"name\":\"cleared\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"_cleared\",\"type\":\"bool\"},{\"name\":\"_nonCleared\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"refundManyTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_whitelistSign\",\"type\":\"bytes\"}],\"name\":\"forwardTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_whitelistSign\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"refundTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_claimer\",\"type\":\"address\"}],\"name\":\"extractTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"refundInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_sale\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogForwarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ExtractedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthealDeposit","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000064386613c1abc7a2ce3c00765f505c025d10b8b1000000000000000000000000dcdb78ba8d4c9eddbe6798b8bb7d05ca52c3be75","Library":"","SwarmSource":"bzzr://8349127ec195b84ad2fbd0102cd7d41a5f4959fce224a85d71fb85bacaad3b66"}]}