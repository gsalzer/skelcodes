{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function safeMul(uint a, uint b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title BytesToTypes\r\n * @dev The BytesToTypes contract converts the memory byte arrays to the standard solidity types\r\n * @author pouladzade@gmail.com\r\n */\r\n\r\ncontract BytesToTypes {\r\n    \r\n\r\n    function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n    \r\n    function bytesToBool(uint _offst, bytes memory _input) internal pure returns (bool _output) {\r\n        \r\n        uint8 x;\r\n        assembly {\r\n            x := mload(add(_input, _offst))\r\n        }\r\n        x==0 ? _output = false : _output = true;\r\n    }   \r\n        \r\n    function getStringSize(uint _offst, bytes memory _input) internal pure returns(uint size){\r\n        \r\n        assembly{\r\n            \r\n            size := mload(add(_input,_offst))\r\n            let chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1\r\n            \r\n            if gt(mod(size,32),0) {// if size%32 > 0\r\n                chunk_count := add(chunk_count,1)\r\n            } \r\n            \r\n             size := mul(chunk_count,32)// first 32 bytes reseves for size in strings\r\n        }\r\n    }\r\n\r\n    function bytesToString(uint _offst, bytes memory _input, bytes memory _output) internal  {\r\n\r\n        uint size = 32;\r\n        assembly {\r\n            let loop_index:= 0\r\n                  \r\n            let chunk_count\r\n            \r\n            size := mload(add(_input,_offst))\r\n            chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1\r\n            \r\n            if gt(mod(size,32),0) {\r\n                chunk_count := add(chunk_count,1)  // chunk_count++\r\n            }\r\n                \r\n            \r\n            loop:\r\n                mstore(add(_output,mul(loop_index,32)),mload(add(_input,_offst)))\r\n                _offst := sub(_offst,32)           // _offst -= 32\r\n                loop_index := add(loop_index,1)\r\n                \r\n            jumpi(loop , lt(loop_index , chunk_count))\r\n            \r\n        }\r\n    }\r\n\r\n    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n\r\n    function bytesToBytes32(uint _offst, bytes memory  _input) internal pure returns (bytes32 _output) {\r\n\r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    /*function bytesToBytes32(uint _offst, bytes memory  _input, bytes32 _output) internal pure {\r\n        \r\n        assembly {\r\n            mstore(_output , add(_input, _offst))\r\n            mstore(add(_output,32) , add(add(_input, _offst),32))\r\n        }\r\n    }*/\r\n    \r\n    function bytesToInt8(uint _offst, bytes memory  _input) internal pure returns (int8 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n    \r\n    function bytesToInt16(uint _offst, bytes memory _input) internal pure returns (int16 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt24(uint _offst, bytes memory _input) internal pure returns (int24 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt32(uint _offst, bytes memory _input) internal pure returns (int32 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt40(uint _offst, bytes memory _input) internal pure returns (int40 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt48(uint _offst, bytes memory _input) internal pure returns (int48 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt56(uint _offst, bytes memory _input) internal pure returns (int56 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt64(uint _offst, bytes memory _input) internal pure returns (int64 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt72(uint _offst, bytes memory _input) internal pure returns (int72 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt80(uint _offst, bytes memory _input) internal pure returns (int80 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt88(uint _offst, bytes memory _input) internal pure returns (int88 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt96(uint _offst, bytes memory _input) internal pure returns (int96 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\t\r\n\tfunction bytesToInt104(uint _offst, bytes memory _input) internal pure returns (int104 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n    \r\n    function bytesToInt112(uint _offst, bytes memory _input) internal pure returns (int112 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt120(uint _offst, bytes memory _input) internal pure returns (int120 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt128(uint _offst, bytes memory _input) internal pure returns (int128 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt136(uint _offst, bytes memory _input) internal pure returns (int136 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt144(uint _offst, bytes memory _input) internal pure returns (int144 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt152(uint _offst, bytes memory _input) internal pure returns (int152 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt160(uint _offst, bytes memory _input) internal pure returns (int160 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt168(uint _offst, bytes memory _input) internal pure returns (int168 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt176(uint _offst, bytes memory _input) internal pure returns (int176 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt184(uint _offst, bytes memory _input) internal pure returns (int184 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt192(uint _offst, bytes memory _input) internal pure returns (int192 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt200(uint _offst, bytes memory _input) internal pure returns (int200 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt208(uint _offst, bytes memory _input) internal pure returns (int208 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt216(uint _offst, bytes memory _input) internal pure returns (int216 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt224(uint _offst, bytes memory _input) internal pure returns (int224 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt232(uint _offst, bytes memory _input) internal pure returns (int232 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt240(uint _offst, bytes memory _input) internal pure returns (int240 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt248(uint _offst, bytes memory _input) internal pure returns (int248 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt256(uint _offst, bytes memory _input) internal pure returns (int256 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n\tfunction bytesToUint8(uint _offst, bytes memory _input) internal pure returns (uint8 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint16(uint _offst, bytes memory _input) internal pure returns (uint16 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint24(uint _offst, bytes memory _input) internal pure returns (uint24 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint32(uint _offst, bytes memory _input) internal pure returns (uint32 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint40(uint _offst, bytes memory _input) internal pure returns (uint40 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint48(uint _offst, bytes memory _input) internal pure returns (uint48 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint56(uint _offst, bytes memory _input) internal pure returns (uint56 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint64(uint _offst, bytes memory _input) internal pure returns (uint64 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint72(uint _offst, bytes memory _input) internal pure returns (uint72 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint80(uint _offst, bytes memory _input) internal pure returns (uint80 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint88(uint _offst, bytes memory _input) internal pure returns (uint88 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint96(uint _offst, bytes memory _input) internal pure returns (uint96 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\t\r\n\tfunction bytesToUint104(uint _offst, bytes memory _input) internal pure returns (uint104 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint112(uint _offst, bytes memory _input) internal pure returns (uint112 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint120(uint _offst, bytes memory _input) internal pure returns (uint120 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint128(uint _offst, bytes memory _input) internal pure returns (uint128 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint136(uint _offst, bytes memory _input) internal pure returns (uint136 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint144(uint _offst, bytes memory _input) internal pure returns (uint144 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint152(uint _offst, bytes memory _input) internal pure returns (uint152 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint160(uint _offst, bytes memory _input) internal pure returns (uint160 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint168(uint _offst, bytes memory _input) internal pure returns (uint168 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint176(uint _offst, bytes memory _input) internal pure returns (uint176 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint184(uint _offst, bytes memory _input) internal pure returns (uint184 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint192(uint _offst, bytes memory _input) internal pure returns (uint192 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint200(uint _offst, bytes memory _input) internal pure returns (uint200 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint208(uint _offst, bytes memory _input) internal pure returns (uint208 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint216(uint _offst, bytes memory _input) internal pure returns (uint216 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint224(uint _offst, bytes memory _input) internal pure returns (uint224 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint232(uint _offst, bytes memory _input) internal pure returns (uint232 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint240(uint _offst, bytes memory _input) internal pure returns (uint240 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint248(uint _offst, bytes memory _input) internal pure returns (uint248 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint256(uint _offst, bytes memory _input) internal pure returns (uint256 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n    \r\n}\r\n\r\n\r\ninterface ITradeable {\r\n    \r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    \r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    \r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n}\r\n\r\n\r\n\r\ncontract ITrader {\r\n\r\n  function getDataLength(\r\n  ) public pure returns (uint256);\r\n\r\n  function getProtocol(\r\n  ) public pure returns (uint8);\r\n\r\n  function getAvailableVolume(\r\n    bytes orderData\r\n  ) public view returns(uint);\r\n\r\n  function isExpired(\r\n    bytes orderData\r\n  ) public view returns (bool); \r\n\r\n  function trade(\r\n    bool isSell,\r\n    bytes orderData,\r\n    uint volume,\r\n    uint volumeEth\r\n  ) public;\r\n  \r\n  function getFillVolumes(\r\n    bool isSell,\r\n    bytes orderData,\r\n    uint volume,\r\n    uint volumeEth\r\n  ) public view returns(uint, uint);\r\n\r\n}\r\n\r\ncontract ITraders {\r\n\r\n  /// @dev Add a valid trader address. Only owner.\r\n  function addTrader(uint8 id, ITrader trader) public;\r\n\r\n  /// @dev Remove a trader address. Only owner.\r\n  function removeTrader(uint8 id) public;\r\n\r\n  /// @dev Get trader by id.\r\n  function getTrader(uint8 id) public view returns(ITrader);\r\n\r\n  /// @dev Check if an address is a valid trader.\r\n  function isValidTraderAddress(address addr) public view returns(bool);\r\n\r\n}\r\n\r\ncontract Members is Ownable {\r\n\r\n  mapping(address => bool) public members; // Mappings of addresses of allowed addresses\r\n\r\n  modifier onlyMembers() {\r\n    require(isValidMember(msg.sender));\r\n    _;\r\n  }\r\n\r\n  /// @dev Check if an address is a valid member.\r\n  function isValidMember(address _member) public view returns(bool) {\r\n    return members[_member];\r\n  }\r\n\r\n  /// @dev Add a valid member address. Only owner.\r\n  function addMember(address _member) public onlyOwner {\r\n    members[_member] = true;\r\n  }\r\n\r\n  /// @dev Remove a member address. Only owner.\r\n  function removeMember(address _member) public onlyOwner {\r\n    delete members[_member];\r\n  }\r\n}\r\n\r\n\r\ncontract IFeeWallet {\r\n\r\n  function getFee(\r\n    uint amount) public view returns(uint);\r\n\r\n  function collect(\r\n    address _affiliate) public payable;\r\n}\r\n\r\n\r\ncontract FeeWallet is IFeeWallet, Ownable, Members {\r\n\r\n  address public serviceAccount; // Address of service account\r\n  uint public servicePercentage; // Percentage times (1 ether)\r\n  uint public affiliatePercentage; // Percentage times (1 ether)\r\n\r\n  mapping (address => uint) public pendingWithdrawals; // Balances\r\n\r\n  constructor(\r\n    address _serviceAccount,\r\n    uint _servicePercentage,\r\n    uint _affiliatePercentage) public\r\n  {\r\n    serviceAccount = _serviceAccount;\r\n    servicePercentage = _servicePercentage;\r\n    affiliatePercentage = _affiliatePercentage;\r\n  }\r\n\r\n  /// @dev Set the new service account. Only owner.\r\n  function changeServiceAccount(address _serviceAccount) public onlyOwner {\r\n    serviceAccount = _serviceAccount;\r\n  }\r\n\r\n  /// @dev Set the service percentage. Only owner.\r\n  function changeServicePercentage(uint _servicePercentage) public onlyOwner {\r\n    servicePercentage = _servicePercentage;\r\n  }\r\n\r\n  /// @dev Set the affiliate percentage. Only owner.\r\n  function changeAffiliatePercentage(uint _affiliatePercentage) public onlyOwner {\r\n    affiliatePercentage = _affiliatePercentage;\r\n  }\r\n\r\n  /// @dev Calculates the service fee for a specific amount. Only owner.\r\n  function getFee(uint amount) public view returns(uint)  {\r\n    return SafeMath.safeMul(amount, servicePercentage) / (1 ether);\r\n  }\r\n\r\n  /// @dev Calculates the affiliate amount for a specific amount. Only owner.\r\n  function getAffiliateAmount(uint amount) public view returns(uint)  {\r\n    return SafeMath.safeMul(amount, affiliatePercentage) / (1 ether);\r\n  }\r\n\r\n  /// @dev Collects fees according to last payment receivedi. Only valid smart contracts.\r\n  function collect(\r\n    address _affiliate) public payable onlyMembers\r\n  {\r\n    if(_affiliate == address(0))\r\n      pendingWithdrawals[serviceAccount] += msg.value;\r\n    else {\r\n      uint affiliateAmount = getAffiliateAmount(msg.value);\r\n      pendingWithdrawals[_affiliate] += affiliateAmount;\r\n      pendingWithdrawals[serviceAccount] += SafeMath.safeSub(msg.value, affiliateAmount);\r\n    }\r\n  }\r\n\r\n  /// @dev Withdraw.\r\n  function withdraw() public {\r\n    uint amount = pendingWithdrawals[msg.sender];\r\n    pendingWithdrawals[msg.sender] = 0;\r\n    msg.sender.transfer(amount);\r\n  }\r\n}\r\ncontract ZodiacERC20 is Ownable, BytesToTypes {\r\n  string constant public VERSION = '2.0.0';\r\n\r\n  ITraders public traders; // Smart contract that hold the list of valid traders\r\n  IFeeWallet public feeWallet; // Smart contract that hold the fees collected\r\n  bool public tradingEnabled; // Switch to enable or disable the contract\r\n\r\n  event Sell(\r\n    address account,\r\n    address destinationAddr,\r\n    address traedeable,\r\n    uint volume,\r\n    uint volumeEth,\r\n    uint volumeEffective,\r\n    uint volumeEthEffective\r\n  );\r\n  event Buy(\r\n    address account,\r\n    address destinationAddr,\r\n    address traedeable,\r\n    uint volume,\r\n    uint volumeEth,\r\n    uint volumeEffective,\r\n    uint volumeEthEffective\r\n  );\r\n\r\n\r\n  constructor(ITraders _traders, IFeeWallet _feeWallet) public {\r\n    traders = _traders;\r\n    feeWallet = _feeWallet;\r\n    tradingEnabled = true;\r\n  }\r\n\r\n  /// @dev Only accepts payment from smart contract traders.\r\n  function() public payable {\r\n  //  require(traders.isValidTraderAddress(msg.sender));\r\n  }\r\n\r\n  /// @dev Setter for feeWallet smart contract (Only owner)\r\n  function changeFeeWallet(IFeeWallet _feeWallet) public onlyOwner {\r\n    feeWallet = _feeWallet;\r\n  }\r\n\r\n  /// @dev Setter for traders smart contract (Only owner)\r\n  function changeTraders(ITraders _traders) public onlyOwner {\r\n    traders = _traders;\r\n  }\r\n\r\n  /// @dev Enable/Disable trading with smart contract (Only owner)\r\n  function changeTradingEnabled(bool enabled) public onlyOwner {\r\n    tradingEnabled = enabled;\r\n  }\r\n\r\n  /// @dev Buy a token.\r\n  function buy(\r\n    ITradeable tradeable,\r\n    uint volume,\r\n    bytes ordersData,\r\n    address destinationAddr,\r\n    address affiliate\r\n  ) external payable\r\n  {\r\n\r\n    require(tradingEnabled);\r\n\r\n    // Execute the trade (at most fullfilling volume)\r\n    trade(\r\n      false,\r\n      tradeable,\r\n      volume,\r\n      ordersData,\r\n      affiliate\r\n    );\r\n\r\n    // Since our balance before trade was 0. What we bought is our current balance.\r\n    uint volumeEffective = tradeable.balanceOf(this);\r\n\r\n    // We make sure that something was traded\r\n    require(volumeEffective > 0);\r\n\r\n    // Used ethers are: balance_before - balance_after.\r\n    // And since before call balance=0; then balance_before = msg.value\r\n    uint volumeEthEffective = SafeMath.safeSub(msg.value, address(this).balance);\r\n\r\n    // IMPORTANT: Check that: effective_price <= agreed_price (guarantee a good deal for the buyer)\r\n    require(\r\n      SafeMath.safeDiv(volumeEthEffective, volumeEffective) <=\r\n      SafeMath.safeDiv(msg.value, volume)\r\n    );\r\n\r\n    // Return remaining ethers\r\n    if(address(this).balance > 0) {\r\n      destinationAddr.transfer(address(this).balance);\r\n    }\r\n\r\n    // Send the tokens\r\n    transferTradeable(tradeable, destinationAddr, volumeEffective);\r\n\r\n    emit Buy(msg.sender, destinationAddr, tradeable, volume, msg.value, volumeEffective, volumeEthEffective);\r\n  }\r\n\r\n  /// @dev sell a token.\r\n  function sell(\r\n    ITradeable tradeable,\r\n    uint volume,\r\n    uint volumeEth,\r\n    bytes ordersData,\r\n    address destinationAddr,\r\n    address affiliate\r\n  ) external\r\n  {\r\n    require(tradingEnabled);\r\n\r\n    // We transfer to ouselves the user's trading volume, to operate on it\r\n    // note: Our balance is 0 before this\r\n    require(tradeable.transferFrom(msg.sender, this, volume));\r\n\r\n    // Execute the trade (at most fullfilling volume)\r\n    trade(\r\n      true,\r\n      tradeable,\r\n      volume,\r\n      ordersData,\r\n      affiliate\r\n    );\r\n\r\n    // Check how much we traded. Our balance = volume - tradedVolume\r\n    // then: tradedVolume = volume - balance\r\n    uint volumeEffective = SafeMath.safeSub(volume, tradeable.balanceOf(this));\r\n\r\n    // We make sure that something was traded\r\n    require(volumeEffective > 0);\r\n\r\n    // Collects service fee\r\n    uint volumeEthEffective = collectSellFee(affiliate);\r\n\r\n    // IMPORTANT: Check that: effective_price >= agreed_price (guarantee a good deal for the seller)\r\n    require(\r\n      SafeMath.safeDiv(volumeEthEffective, volumeEffective) >=\r\n      SafeMath.safeDiv(volumeEth, volume)\r\n    );\r\n\r\n    // Return remaining volume\r\n    if (volumeEffective < volume) {\r\n     transferTradeable(tradeable, destinationAddr, SafeMath.safeSub(volume, volumeEffective));\r\n    }\r\n\r\n    // Send ethers obtained\r\n    destinationAddr.transfer(volumeEthEffective);\r\n\r\n    emit Sell(msg.sender, destinationAddr, tradeable, volume, volumeEth, volumeEffective, volumeEthEffective);\r\n  }\r\n\r\n\r\n  /// @dev Trade buy or sell orders.\r\n  function trade(\r\n    bool isSell,\r\n    ITradeable tradeable,\r\n    uint volume,\r\n    bytes ordersData,\r\n    address affiliate\r\n  ) internal\r\n  {\r\n    uint remainingVolume = volume;\r\n    uint offset = ordersData.length;\r\n\r\n    while(offset > 0 && remainingVolume > 0) {\r\n      //Get the trader\r\n      uint8 protocolId = bytesToUint8(offset, ordersData);\r\n      ITrader trader = traders.getTrader(protocolId);\r\n      require(trader != address(0));\r\n\r\n      //Get the order data\r\n      uint dataLength = trader.getDataLength();\r\n      offset = SafeMath.safeSub(offset, dataLength);\r\n      bytes memory orderData = slice(ordersData, offset, dataLength);\r\n\r\n      //Fill order\r\n      remainingVolume = fillOrder(\r\n         isSell,\r\n         tradeable,\r\n         trader,\r\n         remainingVolume,\r\n         orderData,\r\n         affiliate\r\n      );\r\n    }\r\n  }\r\n\r\n  /// @dev Fills a buy order.\r\n  function fillOrder(\r\n    bool isSell,\r\n    ITradeable tradeable,\r\n    ITrader trader,\r\n    uint remaining,\r\n    bytes memory orderData,\r\n    address affiliate\r\n    ) internal returns(uint)\r\n  {\r\n\r\n    //Checks that there is enoughh amount to execute the trade\r\n    uint volume;\r\n    uint volumeEth;\r\n    (volume, volumeEth) = trader.getFillVolumes(\r\n      isSell,\r\n      orderData,\r\n      remaining,\r\n      address(this).balance\r\n    );\r\n\r\n    if(volume > 0) {\r\n\r\n      if(isSell) {\r\n        //Approve available amount of token to trader\r\n        require(tradeable.approve(trader, volume));\r\n      } else {\r\n        //Collects service fee\r\n        //TODO: transfer fees after all iteration\r\n        volumeEth = collectBuyFee(volumeEth, affiliate);\r\n        address(trader).transfer(volumeEth);\r\n      }\r\n\r\n      //Call trader to trade orders\r\n      trader.trade(\r\n        isSell,\r\n        orderData,\r\n        volume,\r\n        volumeEth\r\n      );\r\n\r\n    }\r\n\r\n    return SafeMath.safeSub(remaining, volume);\r\n  }\r\n\r\n  /// @dev Transfer tradeables to user account.\r\n  function transferTradeable(ITradeable tradeable, address account, uint amount) internal {\r\n    require(tradeable.transfer(account, amount));\r\n  }\r\n\r\n  // @dev Collect service/affiliate fee for a buy\r\n  function collectBuyFee(uint ethers, address affiliate) internal returns(uint) {\r\n    uint remaining;\r\n    uint fee = feeWallet.getFee(ethers);\r\n    //If there is enough remaining to pay fee, it substract from the balance\r\n    if(SafeMath.safeSub(address(this).balance, ethers) >= fee)\r\n      remaining = ethers;\r\n    else\r\n      remaining = SafeMath.safeSub(SafeMath.safeSub(ethers, address(this).balance), fee);\r\n    feeWallet.collect.value(fee)(affiliate);\r\n    return remaining;\r\n  }\r\n\r\n  // @dev Collect service/affiliate fee for a sell\r\n  function collectSellFee(address affiliate) internal returns(uint) {\r\n    uint fee = feeWallet.getFee(address(this).balance);\r\n    feeWallet.collect.value(fee)(affiliate);\r\n    return address(this).balance;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"changeTradingEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeable\",\"type\":\"address\"},{\"name\":\"volume\",\"type\":\"uint256\"},{\"name\":\"ordersData\",\"type\":\"bytes\"},{\"name\":\"destinationAddr\",\"type\":\"address\"},{\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeWallet\",\"type\":\"address\"}],\"name\":\"changeFeeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeable\",\"type\":\"address\"},{\"name\":\"volume\",\"type\":\"uint256\"},{\"name\":\"volumeEth\",\"type\":\"uint256\"},{\"name\":\"ordersData\",\"type\":\"bytes\"},{\"name\":\"destinationAddr\",\"type\":\"address\"},{\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"traders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_traders\",\"type\":\"address\"}],\"name\":\"changeTraders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_traders\",\"type\":\"address\"},{\"name\":\"_feeWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destinationAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"traedeable\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"volume\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEffective\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEthEffective\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destinationAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"traedeable\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"volume\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEffective\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"volumeEthEffective\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"}]","ContractName":"ZodiacERC20","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004cf723f59f86e0837d33de40dca910dc38996d9e000000000000000000000000a803c226c8281550454523191375695928dcfe92","Library":"","SwarmSource":"bzzr://57311dc762e938aaf9792b83a8a12f5caded9b85c65fbca9dda841619c971c11"}]}