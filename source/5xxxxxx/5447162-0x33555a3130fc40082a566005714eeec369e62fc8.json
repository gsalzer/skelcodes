{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// ERC20 contract which has the dividend shares of Ethopolis in it \r\n// The old contract had a bug in it, thanks to ccashwell for notifying.\r\n// Contact: etherguy@mail.com \r\n// ethopolis.io \r\n// etherguy.surge.sh [if the .io site is up this might be outdated, one of those sites will be up-to-date]\r\n// Selling tokens (and buying them) will be online at etherguy.surge.sh/dividends.html and might be moved to the ethopolis site.\r\n\r\ncontract Dividends {\r\n\r\n    string public name = \"Ethopolis Shares\";      //  token name\r\n    string public symbol = \"EPS\";           //  token symbol\r\n    uint256 public decimals = 18;            //  token digit\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    uint256 public totalSupply = 10000000* (10 ** uint256(decimals));\r\n    \r\n    uint256 SellFee = 1250; // max is 10 000\r\n\r\n\r\n    address owner = 0x0;\r\n\r\n    modifier isOwner {\r\n        assert(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    modifier validAddress {\r\n        assert(0x0 != msg.sender);\r\n        _;\r\n    }\r\n\r\n    function Dividends() public {\r\n        owner = msg.sender;\r\n\r\n\r\n        // PREMINED TOKENS \r\n        \r\n        // EG\r\n        balanceOf[ address(0x690F34053ddC11bdFF95D44bdfEb6B0b83CBAb58)] =  8000000* (10 ** uint256(decimals));// was: TokenSupply - 400000;\r\n        // HE\r\n        balanceOf[ address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285)] = 200000* (10 ** uint256(decimals));\r\n        // PG\r\n        balanceOf[ address(0x26581d1983ced8955C170eB4d3222DCd3845a092)] = 200000* (10 ** uint256(decimals));\r\n\r\n        // BOUGHT tokens in the OLD contract         \r\n        balanceOf[ address(0x3130259deEdb3052E24FAD9d5E1f490CB8CCcaa0)] = 97000* (10 ** uint256(decimals));\r\n        balanceOf[ address(0x4f0d861281161f39c62B790995fb1e7a0B81B07b)] = 199800* (10 ** uint256(decimals));\r\n        balanceOf[ address(0x36E058332aE39efaD2315776B9c844E30d07388B)] =  20000* (10 ** uint256(decimals));\r\n        balanceOf[ address(0x1f2672E17fD7Ec4b52B7F40D41eC5C477fe85c0c)] =  40000* (10 ** uint256(decimals));\r\n        balanceOf[ address(0xedDaD54E9e1F8dd01e815d84b255998a0a901BbF)] =  20000* (10 ** uint256(decimals));\r\n        balanceOf[ address(0x0a3239799518E7F7F339867A4739282014b97Dcf)] = 499000* (10 ** uint256(decimals));\r\n        balanceOf[ address(0x29A9c76aD091c015C12081A1B201c3ea56884579)] = 600000* (10 ** uint256(decimals));\r\n        balanceOf[ address(0x0668deA6B5ec94D7Ce3C43Fe477888eee2FC1b2C)] = 100000* (10 ** uint256(decimals));\r\n        balanceOf[ address(0x0982a0bf061f3cec2a004b4d2c802F479099C971)] =  20000* (10 ** uint256(decimals));\r\n        \r\n        balanceOf [address(\t0xA78EfC3A01CB8f2F47137B97f9546B46275f54a6)] =  3000* (10 ** uint256(decimals));\r\n        balanceOf [address(\t0x522273122b20212FE255875a4737b6F50cc72006)] =  1000* (10 ** uint256(decimals));\r\n        balanceOf [address(\t0xc1c51098ff73f311ECD6E855e858225F531812c4)] =  200* (10 ** uint256(decimals));\r\n\r\n        // Etherscan likes it very much if we emit these events \r\n        emit Transfer(0x0, 0x690F34053ddC11bdFF95D44bdfEb6B0b83CBAb58, 8000000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285, 200000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x26581d1983ced8955C170eB4d3222DCd3845a092, 200000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x3130259deEdb3052E24FAD9d5E1f490CB8CCcaa0, 97000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x4f0d861281161f39c62B790995fb1e7a0B81B07b, 199800* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x36E058332aE39efaD2315776B9c844E30d07388B, 20000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x1f2672E17fD7Ec4b52B7F40D41eC5C477fe85c0c, 40000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0xedDaD54E9e1F8dd01e815d84b255998a0a901BbF, 20000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x0a3239799518E7F7F339867A4739282014b97Dcf, 499000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x29A9c76aD091c015C12081A1B201c3ea56884579, 600000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x0668deA6B5ec94D7Ce3C43Fe477888eee2FC1b2C, 100000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x0982a0bf061f3cec2a004b4d2c802F479099C971, 20000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0xA78EfC3A01CB8f2F47137B97f9546B46275f54a6, 3000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0x522273122b20212FE255875a4737b6F50cc72006, 1000* (10 ** uint256(decimals)));\r\n        emit Transfer(0x0, 0xc1c51098ff73f311ECD6E855e858225F531812c4, 200* (10 ** uint256(decimals)));\r\n       \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value)  public validAddress returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        // after transfer have enough to pay sell order \r\n        require(sub(balanceOf[msg.sender], SellOrders[msg.sender][0]) >= _value);\r\n        require(msg.sender != _to);\r\n\r\n        uint256 _toBal = balanceOf[_to];\r\n        uint256 _fromBal = balanceOf[msg.sender];\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        \r\n        uint256 _sendFrom = _withdraw(msg.sender, _fromBal, false,0);\r\n        uint256 _sendTo = _withdraw(_to, _toBal, false, _sendFrom);\r\n        \r\n        msg.sender.transfer(_sendFrom);\r\n        _to.transfer(_sendTo);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    // forcetransfer does not do any withdrawals\r\n    function _forceTransfer(address _from, address _to, uint256  _value) internal validAddress {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        \r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public validAddress returns (bool success) {\r\n                // after transfer have enough to pay sell order \r\n        require(_from != _to);\r\n        require(sub(balanceOf[_from], SellOrders[_from][0]) >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        require(allowance[_from][msg.sender] >= _value);\r\n        uint256 _toBal = balanceOf[_to];\r\n        uint256 _fromBal = balanceOf[_from];\r\n        balanceOf[_to] += _value;\r\n        balanceOf[_from] -= _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        emit Transfer(_from, _to, _value);\r\n        \r\n        // Call withdrawal of old amounts \r\n        CancelOrder();\r\n        uint256 _sendFrom = _withdraw(_from, _fromBal,false,0);\r\n        uint256 _sendTo = _withdraw(_to, _toBal,false,_sendTo);\r\n        \r\n        _from.transfer(_sendFrom);\r\n        _to.transfer(_sendTo);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public validAddress returns (bool success) {\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function setSymbol(string _symb) public isOwner {\r\n        symbol = _symb;\r\n    }\r\n\r\n    function setName(string _name) public isOwner {\r\n        name = _name;\r\n    }\r\n    \r\n    function newOwner(address who) public isOwner validAddress {\r\n        owner = who;\r\n    }\r\n    \r\n    function setFee(uint256 fee) public isOwner {\r\n        require (fee <= 2500);\r\n        SellFee = fee;\r\n    }\r\n\r\n\r\n// Market stuff start \r\n    \r\n    mapping(address => uint256[2]) public SellOrders;\r\n    mapping(address => uint256) public LastBalanceWithdrawn;\r\n    uint256 TotalOut;\r\n    \r\n    function Withdraw() public{\r\n        _withdraw(msg.sender, balanceOf[msg.sender], true,0);\r\n    }\r\n    \r\n    function ViewSellOrder(address who) public view returns (uint256, uint256){\r\n        return (SellOrders[who][0], SellOrders[who][1]);\r\n    }\r\n    \r\n    // if dosend is set to false then the calling function MUST send the fees \r\n    // subxtra is to handle the \"high LastBalanceWithdrawn bug\" \r\n    // this bug was caused because the Buyer actually gets a too high LastBalanceWithdrawn;\r\n    // this is a minor bug and could be fixed by adding these funds to the contract (which is usually not a large amount)\r\n    // if the contract gets a lot of divs live then that should not be an issue because any new withdrawal will set it to a right value \r\n    // anyways it is fixed now \r\n    function _withdraw(address to, uint256 tkns, bool dosend, uint256 subxtra) internal returns (uint256){\r\n        // calculate how much wei you get \r\n        if (tkns == 0){\r\n            // ok we just reset the timer then \r\n            LastBalanceWithdrawn[msg.sender] = sub(sub(add(address(this).balance, TotalOut),msg.value),subxtra);\r\n            return 0;\r\n        }\r\n        // remove msg.value is exists. if it is nonzero then the call came from Buy, do not include this in balance. \r\n        uint256 total_volume_in = address(this).balance + TotalOut - msg.value;\r\n        // get volume in since last withdrawal; \r\n        uint256 Delta = sub(total_volume_in, LastBalanceWithdrawn[to]);\r\n        \r\n        uint256 Get = (tkns * Delta) / totalSupply;\r\n        \r\n        TotalOut = TotalOut + Get;\r\n        \r\n        LastBalanceWithdrawn[to] = sub(sub(sub(add(address(this).balance, TotalOut), Get),msg.value),subxtra);\r\n        \r\n        emit WithdrawalComplete(to, Get);\r\n        if (dosend){\r\n            to.transfer(Get);\r\n            return 0;\r\n        }\r\n        else{//7768\r\n            return Get;\r\n        }\r\n        \r\n    }\r\n    \r\n    function GetDivs(address who) public view returns (uint256){\r\n         uint256 total_volume_in = address(this).balance + TotalOut;\r\n         uint256 Delta = sub(total_volume_in, LastBalanceWithdrawn[who]);\r\n         uint256 Get = (balanceOf[who] * Delta) / totalSupply;\r\n         return (Get);\r\n    }\r\n    \r\n    function CancelOrder() public {\r\n        _cancelOrder(msg.sender);\r\n    }\r\n    \r\n    function _cancelOrder(address target) internal{\r\n         SellOrders[target][0] = 0;\r\n         emit SellOrderCancelled(target);\r\n    }\r\n    \r\n    \r\n    // the price is per 10^decimals tokens \r\n    function PlaceSellOrder(uint256 amount, uint256 price) public {\r\n        require(price > 0);\r\n        require(balanceOf[msg.sender] >= amount);\r\n        SellOrders[msg.sender] = [amount, price];\r\n        emit SellOrderPlaced(msg.sender, amount, price);\r\n    }\r\n\r\n    // Safe buy order where user specifies the max amount to buy and the max price; prevents snipers changing their price \r\n    function Buy(address target, uint256 maxamount, uint256 maxprice) public payable {\r\n        require(SellOrders[target][0] > 0);\r\n        require(SellOrders[target][1] <= maxprice);\r\n        uint256 price = SellOrders[target][1];\r\n        uint256 amount_buyable = (mul(msg.value, uint256(10**decimals))) / price; \r\n        \r\n        // decide how much we buy \r\n        \r\n        if (amount_buyable > SellOrders[target][0]){\r\n            amount_buyable = SellOrders[target][0];\r\n        }\r\n        if (amount_buyable > maxamount){\r\n            amount_buyable = maxamount;\r\n        }\r\n        //10000000000000000000,14999999999999\r\n        //\"0xca35b7d915458ef540ade6068dfe2f44e8fa733c\",10000000000000000000,14999999999999\r\n        uint256 total_payment = mul(amount_buyable, price) / (uint256(10 ** decimals));\r\n        \r\n        // Let's buy tokens and actually pay, okay?\r\n        require(amount_buyable > 0 && total_payment > 0); \r\n        \r\n        // From the amount we actually pay, we take exchange fee from it \r\n        \r\n        uint256 Fee = mul(total_payment, SellFee) / 10000;\r\n        uint256 Left = total_payment - Fee; \r\n        \r\n        uint256 Excess = msg.value - total_payment;\r\n        \r\n        uint256 OldTokensSeller = balanceOf[target];\r\n        uint256 OldTokensBuyer = balanceOf[msg.sender];\r\n\r\n        // Change it in memory \r\n        _forceTransfer(target, msg.sender, amount_buyable);\r\n        \r\n        // Pay out withdrawals and reset timer\r\n        // Prevents double withdrawals in same tx\r\n        \r\n        // Change sell order \r\n        SellOrders[target][0] = sub(SellOrders[target][0],amount_buyable);\r\n        \r\n        \r\n        // start all transfer stuff \r\n\r\n        uint256 _sendTarget = _withdraw(target, OldTokensSeller, false,0);\r\n        uint256 _sendBuyer = _withdraw(msg.sender, OldTokensBuyer, false, _sendTarget);\r\n        \r\n        // in one transfer saves gas, but its not nice in the etherscan logs \r\n        target.transfer(add(Left, _sendTarget));\r\n        \r\n        if (add(Excess, _sendBuyer) > 0){\r\n            msg.sender.transfer(add(Excess,_sendBuyer));\r\n        }\r\n        \r\n        if (Fee > 0){\r\n            owner.transfer(Fee);\r\n        }\r\n     \r\n        emit SellOrderFilled(msg.sender, target, amount_buyable,  price, Left);\r\n    }\r\n\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event SellOrderPlaced(address who, uint256 available, uint256 price);\r\n    event SellOrderFilled(address buyer, address seller, uint256 tokens, uint256 price, uint256 payment);\r\n    event SellOrderCancelled(address who);\r\n    event WithdrawalComplete(address who, uint256 got);\r\n    \r\n    \r\n    // thanks for divs \r\n    function() public payable{\r\n        \r\n    }\r\n    \r\n    // safemath \r\n    \r\n      function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"GetDivs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"CancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PlaceSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"maxamount\",\"type\":\"uint256\"},{\"name\":\"maxprice\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ViewSellOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"newOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"LastBalanceWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symb\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SellOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"available\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"SellOrderPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"SellOrderFilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"SellOrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"got\",\"type\":\"uint256\"}],\"name\":\"WithdrawalComplete\",\"type\":\"event\"}]","ContractName":"Dividends","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2688bb0556bd07c9e120475ad6d92499dae457a0c8b26170917feac537bf2395"}]}