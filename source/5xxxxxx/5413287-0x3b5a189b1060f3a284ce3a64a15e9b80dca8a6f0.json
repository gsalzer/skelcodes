{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\n// \"Proof of Commitment\" fun pre-launch competition for NBAOnline!\r\n\r\n//  Full details and game smart contract will shortly be able:\r\n//  ~~ https://nbaonline.io ~~\r\n\r\n//  This contest will award some of the keen NBAOnline players\r\n\r\n//  ALL ETHER DEPOSITED INTO THIS PROMO CAN BE WITHDRAWN BY PLAYER AT ANY\r\n//  TIME BUT PRIZES WILL BE DRAWN: SATURDAY 14TH APRIL (LAUNCH)\r\n//  AT WHICH POINT ALL ETHER WILL ALSO BE REFUNDED TO PLAYERS\r\n\r\n\r\n//  PRIZES:\r\n//  0.5 ether (top eth deposit)\r\n//  0.35 ether (1 random deposit)\r\n//  0.15 ether (1 random deposit)\r\n\r\ncontract NBAOnlineLaunchPromotion {\r\n    \r\n    // First Goo Players!\r\n    mapping(address => uint256) public deposits;\r\n    mapping(address => bool) depositorAlreadyStored;\r\n    address[] public depositors;\r\n\r\n    // To trigger contest end only\r\n    address public ownerAddress;\r\n    \r\n    // Flag so can only be awarded once\r\n    bool public prizesAwarded = false;\r\n    \r\n    // Ether to be returned to depositor on launch\r\n\t// 1day = 86400\r\n    uint256 public constant LAUNCH_DATE = 1523678400; // Saturday, 14 April 2018 00:00:00 (seconds) ET\r\n    \r\n    // Proof of Commitment contest prizes\r\n    uint256 private constant TOP_DEPOSIT_PRIZE = 0.5 ether;\r\n    uint256 private constant RANDOM_DEPOSIT_PRIZE1 = 0.35 ether;\r\n    uint256 private constant RANDOM_DEPOSIT_PRIZE2 = 0.15 ether;\r\n    \r\n    function NBAOnlineLaunchPromotion() public payable {\r\n        require(msg.value == 1 ether); // Owner must provide enough for prizes\r\n        ownerAddress = msg.sender;\r\n    }\r\n    \r\n    \r\n    function deposit() external payable {\r\n        uint256 existing = deposits[msg.sender];\r\n        \r\n        // Safely store the ether sent\r\n        deposits[msg.sender] = SafeMath.add(msg.value, existing);\r\n        \r\n        // Finally store contest details\r\n        if (msg.value >= 0.01 ether && !depositorAlreadyStored[msg.sender]) {\r\n            depositors.push(msg.sender);\r\n            depositorAlreadyStored[msg.sender] = true;\r\n        }\r\n    }\r\n    \r\n    function refund() external {\r\n        // Safely transfer players deposit back\r\n        uint256 depositAmount = deposits[msg.sender];\r\n        deposits[msg.sender] = 0; // Can't withdraw twice obviously\r\n        msg.sender.transfer(depositAmount);\r\n    }\r\n    \r\n    \r\n    function refundPlayer(address depositor) external {\r\n        require(msg.sender == ownerAddress);\r\n        \r\n        // Safely transfer back to player\r\n        uint256 depositAmount = deposits[depositor];\r\n        deposits[depositor] = 0; // Can't withdraw twice obviously\r\n        \r\n        // Sends back to correct depositor\r\n        depositor.transfer(depositAmount);\r\n    }\r\n    \r\n    \r\n    function awardPrizes() external {\r\n        require(msg.sender == ownerAddress);\r\n        require(now >= LAUNCH_DATE);\r\n        require(!prizesAwarded);\r\n        \r\n        // Ensure only ran once\r\n        prizesAwarded = true;\r\n        \r\n        uint256 highestDeposit;\r\n        address highestDepositWinner;\r\n        \r\n        for (uint256 i = 0; i < depositors.length; i++) {\r\n            address depositor = depositors[i];\r\n            \r\n            // No tie allowed!\r\n            if (deposits[depositor] > highestDeposit) {\r\n                highestDeposit = deposits[depositor];\r\n                highestDepositWinner = depositor;\r\n            }\r\n        }\r\n        \r\n        uint256 numContestants = depositors.length;\r\n        uint256 seed1 = numContestants + block.timestamp;\r\n        uint256 seed2 = seed1 + (numContestants*2);\r\n        \r\n        address randomDepositWinner1 = depositors[randomContestant(numContestants, seed1)];\r\n        address randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];\r\n        \r\n        // Just incase\r\n        while(randomDepositWinner2 == randomDepositWinner1) {\r\n            seed2++;\r\n            randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];\r\n        }\r\n        \r\n        highestDepositWinner.transfer(TOP_DEPOSIT_PRIZE);\r\n        randomDepositWinner1.transfer(RANDOM_DEPOSIT_PRIZE1);\r\n        randomDepositWinner2.transfer(RANDOM_DEPOSIT_PRIZE2);\r\n    }\r\n    \r\n    \r\n    // Random enough for small contest\r\n    function randomContestant(uint256 contestants, uint256 seed) constant internal returns (uint256 result){\r\n        return addmod(uint256(block.blockhash(block.number-1)), seed, contestants);   \r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"prizesAwarded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"awardPrizes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"refundPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LAUNCH_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"}]","ContractName":"NBAOnlineLaunchPromotion","CompilerVersion":"v0.4.21-nightly.2018.3.5+commit.cd6ffbdf","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ed95ecaa9bfd65ae4365c729d927ac90fccc8e63e56cc5ab8647b494e094e290"}]}