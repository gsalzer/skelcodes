{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Fysical is StandardToken {\r\n    using SafeMath for uint256;\r\n\r\n    // To increase consistency and reduce the opportunity for human error, the '*sById' mappings, '*Count' values,\r\n    // 'get*ById' function declarations/implementations, and 'create*' function declarations/implementations have been\r\n    // programmatically-generated based on the each struct's name, member types/names, and the comments sharing a line\r\n    // with a member.\r\n    //\r\n    // This programmatic generation builds 'require' function calls based on the following rules:\r\n    //      - 'string' values must have length > 0\r\n    //      - 'bytes' and uint256[] values may have any length\r\n    //      - 'uint256' values representing a quantity must be > 0 (identifiers and Ethereum block numbers do not represent a quantity)\r\n    //\r\n    // The implementation of 'createProposal' contains one operation not found in the other programmatically-generated\r\n    // 'create*' functions, a call to 'transferTokensToEscrow'.\r\n    //\r\n    // None of the other members or functions have been programmatically generated.\r\n\r\n    // See https://en.wikipedia.org/wiki/Uniform_Resource_Identifier.\r\n    // The risk of preventing support for a future addition to the URI syntax outweighs the benefit of validating URI\r\n    // values within this immutable smart contract, so readers of Uri values should expect values that do not conform\r\n    // to the formal syntax of a URI.\r\n    struct Uri {\r\n        string value;\r\n    }\r\n\r\n    // A set of URIs may describe multiple methods to access a particular resource.\r\n    struct UriSet {\r\n        uint256[] uniqueUriIdsSortedAscending;    // each value must be key in 'urisById'\r\n    }\r\n\r\n    // See https://en.wikipedia.org/wiki/Checksum#Algorithms. The description of the algorithm referred to by each URI\r\n    // in the set should give a reader enough information to interpret the 'value' member of a 'Checksum' object\r\n    // referring to this algorithm object.\r\n    struct ChecksumAlgorithm {\r\n        uint256 descriptionUriSetId;    // must be key in 'uriSetsById'\r\n    }\r\n\r\n    // See https://en.wikipedia.org/wiki/Checksum. The 'resourceByteCount' indicates the number of bytes contained in\r\n    // the resource. Though this is not strictly part of most common Checksum algorithms, its validation may also be\r\n    // useful. The 'value' field should contain the expected output of passing the resource content to the checksum\r\n    // algorithm.\r\n    struct Checksum {\r\n        uint256 algorithmId; // must be key in 'checksumAlgorithmsById'\r\n        uint256 resourceByteCount;\r\n        bytes value;\r\n    }\r\n\r\n    // See https://en.wikipedia.org/wiki/Encryption. The description of the algorithm referred to by each URI\r\n    // in the set should give a reader enough information to access the content of an encrypted resource. The algorithm\r\n    // may be a symmetric encryption algorithm or an asymmetric encryption algorithm\r\n    struct EncryptionAlgorithm {\r\n        uint256 descriptionUriSetId;    // must be key in 'uriSetsById'\r\n    }\r\n\r\n    // For each resource, an Ethereum account may describe a checksum for the encrypted content of a resource and a\r\n    // checksum for the decrypted content of a resource. When the resource is encrypted with a null encryption\r\n    // algorithm, the resource is effectively unencrypted, so these two checksums should be identical\r\n    // (See https://en.wikipedia.org/wiki/Null_encryption).\r\n    struct ChecksumPair {\r\n        uint256 encryptedChecksumId; // must be key in 'checksumsById'\r\n        uint256 decryptedChecksumId; // must be key in 'checksumsById'\r\n    }\r\n\r\n    // A 'Resource' is content accessible with each URI referenced in the 'uriSetId'. This content should be\r\n    // encrypted with the algorithm described by the 'EncryptionAlgorithm' referenced in 'encryptionAlgorithmId'. Each\r\n    // resource referenced in 'metaResourceSetId' should describe the decrypted content in some way.\r\n    //\r\n    // For example, if the decrypted content conforms to a Protocol Buffers schema, the corresponding proto definition\r\n    // file should be included in the meta-resources. Likewise, that proto definition resource should refer to a\r\n    // resource like https://en.wikipedia.org/wiki/Protocol_Buffers among its meta-resources.\r\n    struct Resource {\r\n        uint256 uriSetId;                // must be key in 'uriSetsById'\r\n        uint256 encryptionAlgorithmId;   // must be key in 'encryptionAlgorithmsById'\r\n        uint256 metaResourceSetId;       // must be key in 'resourceSetsById'\r\n    }\r\n\r\n    // See https://en.wikipedia.org/wiki/Public-key_cryptography. This value should be the public key used in an\r\n    // asymmetric encryption operation. It should be useful for encrypting an resource destined for the holder of the\r\n    // corresponding private key or for decrypting a resource encrypted with the corresponding private key.\r\n    struct PublicKey {\r\n        bytes value;\r\n    }\r\n\r\n    // A 'ResourceSet' groups together resources that may be part of a trade proposal involving Fysical tokens. The\r\n    // creator of a 'ResourceSet' must include a public key for use in the encryption operations of creating and\r\n    // accepting a trade proposal. The creator must also specify the encryption algorithm a proposal creator should\r\n    // use along with this resource set creator's public key. Just as a single resource may have meta-resources\r\n    // describing the content of a resource, a 'ResourceSet' may have resources describing the whole resource set.\r\n    //\r\n    // Creators should be careful to not include so many resources that an Ethereum transaction to accept a proposal\r\n    // might run out of gas while storing the corresponding encrypted decryption keys.\r\n    //\r\n    // While developing reasonable filters for un-useful data in this collection, developers should choose a practical\r\n    // maximum depth of traversal through the meta-resources, since an infinite loop is possible.\r\n    struct ResourceSet {\r\n        address creator;\r\n        uint256 creatorPublicKeyId;                     // must be key in 'publicKeysById'\r\n        uint256 proposalEncryptionAlgorithmId;          // must be key in 'encryptionAlgorithmsById'\r\n        uint256[] uniqueResourceIdsSortedAscending;     // each value must be key in 'resourcesById'\r\n        uint256 metaResourceSetId;                      // must be key in 'resourceSetsById'\r\n    }\r\n\r\n    // The creator of a trade proposal may include arbitrary content to be considered part of the agreement the\r\n    // resource set is accepting. This may be useful for license agreements to be enforced within a jurisdiction\r\n    // governing the trade partners. The content available through each URI in the set should be encrypted first with\r\n    // the public key of a resource set's creator and then with the private key of a proposal's creator.\r\n    struct Agreement {\r\n        uint256 uriSetId;           // must be key in 'uriSetsById'\r\n        uint256 checksumPairId;     // must be key in 'checksumPairsById'\r\n    }\r\n\r\n    // Many agreements may be grouped together in an 'AgreementSet'\r\n    struct AgreementSet {\r\n        uint256[] uniqueAgreementIdsSortedAscending; // each value must be key in 'agreementsById'\r\n    }\r\n\r\n    // A 'TokenTransfer' describes a transfer of tokens to occur between two Ethereum accounts.\r\n    struct TokenTransfer {\r\n        address source;\r\n        address destination;\r\n        uint256 tokenCount;\r\n    }\r\n\r\n    // Many token transfers may be grouped together in a \"TokenTransferSet'\r\n    struct TokenTransferSet {\r\n        uint256[] uniqueTokenTransferIdsSortedAscending; // each value must be key in 'tokenTransfersById'\r\n    }\r\n\r\n    // A 'Proposal' describes the conditions for the atomic exchange of Fysical tokens and a keys to decrypt resources\r\n    // in a resource set. The creator must specify the asymmetric encryption algorithm for use when accepting the\r\n    // proposal, along with this creator's public key. The creator may specify arbitrary agreements that should be\r\n    // considered a condition of the trade.\r\n    //\r\n    // During the execution of 'createProposal', the count of tokens specified in each token transfer will be transfered\r\n    // from the specified source account to the account with the Ethereum address of 0. When the proposal state changes\r\n    // to a final state, these tokens will be returned to the source accounts or tranfserred to the destination account.\r\n    //\r\n    // By including a 'minimumBlockNumberForWithdrawal' value later than the current Ethereum block, the proposal\r\n    // creator can give the resource set creator a rough sense of how long the proposal will remain certainly\r\n    // acceptable. This is particularly useful because the execution of an Ethereum transaction to accept a proposal\r\n    // exposes the encrypted decryption keys to the Ethereum network regardless of whether the transaction succeeds.\r\n    // Within the time frame that a proposal acceptance transaction will certainly succeed, the resource creator need\r\n    // not be concerned with the possibility that an acceptance transaction might execute after a proposal withdrawal\r\n    // submitted to the Ethereum network at approximately the same time.\r\n    struct Proposal {\r\n        uint256 minimumBlockNumberForWithdrawal;\r\n        address creator;\r\n        uint256 creatorPublicKeyId;                 // must be key in 'publicKeysById'\r\n        uint256 acceptanceEncryptionAlgorithmId;    // must be key in 'encryptionAlgorithmsById'\r\n        uint256 resourceSetId;                      // must be key in 'resourceSetsById'\r\n        uint256 agreementSetId;                     // must be key in 'agreementSetsById'\r\n        uint256 tokenTransferSetId;                 // must be key in 'tokenTransferSetsById'\r\n    }\r\n\r\n    // When created, the proposal is in the 'Pending' state. All other states are final states, so a proposal may change\r\n    // state exactly one time based on a call to 'withdrawProposal', 'acceptProposal', or 'rejectProposal'.\r\n    enum ProposalState {\r\n        Pending,\r\n        WithdrawnByCreator,\r\n        RejectedByResourceSetCreator,\r\n        AcceptedByResourceSetCreator\r\n    }\r\n\r\n    // solium would warn \"Constant name 'name' doesn't follow the UPPER_CASE notation\", but this public constant is\r\n    // recommended by https://theethereum.wiki/w/index.php/ERC20_Token_Standard, so we'll disable warnings for the line.\r\n    //\r\n    /* solium-disable-next-line */\r\n    string public constant name = \"Fysical\";\r\n\r\n    // solium would warn \"Constant name 'symbol' doesn't follow the UPPER_CASE notation\", but this public constant is\r\n    // recommended by https://theethereum.wiki/w/index.php/ERC20_Token_Standard, so we'll disable warnings for the line.\r\n    //\r\n    /* solium-disable-next-line */\r\n    string public constant symbol = \"FYS\";\r\n\r\n    // solium would warn \"Constant name 'decimals' doesn't follow the UPPER_CASE notation\", but this public constant is\r\n    // recommended by https://theethereum.wiki/w/index.php/ERC20_Token_Standard, so we'll disable warnings for the line.\r\n    //\r\n    /* solium-disable-next-line */\r\n    uint8 public constant decimals = 9;\r\n\r\n    uint256 public constant ONE_BILLION = 1000000000;\r\n    uint256 public constant ONE_QUINTILLION = 1000000000000000000;\r\n\r\n    // See https://en.wikipedia.org/wiki/9,223,372,036,854,775,807\r\n    uint256 public constant MAXIMUM_64_BIT_SIGNED_INTEGER_VALUE = 9223372036854775807;\r\n\r\n    uint256 public constant EMPTY_PUBLIC_KEY_ID = 0;\r\n    uint256 public constant NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID = 0;\r\n    uint256 public constant NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID = 0;\r\n    uint256 public constant NULL_ENCRYPTION_ALGORITHM_ID = 0;\r\n    uint256 public constant EMPTY_RESOURCE_SET_ID = 0;\r\n\r\n    mapping(uint256 => Uri) internal urisById;\r\n    uint256 internal uriCount = 0;\r\n\r\n    mapping(uint256 => UriSet) internal uriSetsById;\r\n    uint256 internal uriSetCount = 0;\r\n\r\n    mapping(uint256 => ChecksumAlgorithm) internal checksumAlgorithmsById;\r\n    uint256 internal checksumAlgorithmCount = 0;\r\n\r\n    mapping(uint256 => Checksum) internal checksumsById;\r\n    uint256 internal checksumCount = 0;\r\n\r\n    mapping(uint256 => EncryptionAlgorithm) internal encryptionAlgorithmsById;\r\n    uint256 internal encryptionAlgorithmCount = 0;\r\n\r\n    mapping(uint256 => ChecksumPair) internal checksumPairsById;\r\n    uint256 internal checksumPairCount = 0;\r\n\r\n    mapping(uint256 => Resource) internal resourcesById;\r\n    uint256 internal resourceCount = 0;\r\n\r\n    mapping(uint256 => PublicKey) internal publicKeysById;\r\n    uint256 internal publicKeyCount = 0;\r\n\r\n    mapping(uint256 => ResourceSet) internal resourceSetsById;\r\n    uint256 internal resourceSetCount = 0;\r\n\r\n    mapping(uint256 => Agreement) internal agreementsById;\r\n    uint256 internal agreementCount = 0;\r\n\r\n    mapping(uint256 => AgreementSet) internal agreementSetsById;\r\n    uint256 internal agreementSetCount = 0;\r\n\r\n    mapping(uint256 => TokenTransfer) internal tokenTransfersById;\r\n    uint256 internal tokenTransferCount = 0;\r\n\r\n    mapping(uint256 => TokenTransferSet) internal tokenTransferSetsById;\r\n    uint256 internal tokenTransferSetCount = 0;\r\n\r\n    mapping(uint256 => Proposal) internal proposalsById;\r\n    uint256 internal proposalCount = 0;\r\n\r\n    mapping(uint256 => ProposalState) internal statesByProposalId;\r\n\r\n    mapping(uint256 => mapping(uint256 => bytes)) internal encryptedDecryptionKeysByProposalIdAndResourceId;\r\n\r\n    mapping(address => mapping(uint256 => bool)) internal checksumPairAssignmentsByCreatorAndResourceId;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) internal checksumPairIdsByCreatorAndResourceId;\r\n\r\n    function Fysical() public {\r\n        assert(ProposalState(0) == ProposalState.Pending);\r\n\r\n        // The total number of Fysical tokens is intended to be one billion, with the ability to express values with\r\n        // nine decimals places of precision. The token values passed in ERC20 functions and operations involving\r\n        // TokenTransfer operations must be counts of nano-Fysical tokens (one billionth of one Fysical token).\r\n        //\r\n        // See the initialization of the total supply in https://theethereum.wiki/w/index.php/ERC20_Token_Standard.\r\n\r\n        assert(0 < ONE_BILLION);\r\n        assert(0 < ONE_QUINTILLION);\r\n        assert(MAXIMUM_64_BIT_SIGNED_INTEGER_VALUE > ONE_BILLION);\r\n        assert(MAXIMUM_64_BIT_SIGNED_INTEGER_VALUE > ONE_QUINTILLION);\r\n        assert(ONE_BILLION == uint256(10)**decimals);\r\n        assert(ONE_QUINTILLION == ONE_BILLION.mul(ONE_BILLION));\r\n\r\n        totalSupply_ = ONE_QUINTILLION;\r\n\r\n        balances[msg.sender] = totalSupply_;\r\n\r\n        // From \"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\" on 2018-02-08 (commit cea1db05a3444870132ec3cb7dd78a244cba1805):\r\n        //  \"A token contract which creates new tokens SHOULD trigger a Transfer event with the _from address set to 0x0 when tokens are created.\"\r\n        Transfer(0x0, msg.sender, balances[msg.sender]);\r\n\r\n        // This mimics the behavior of the 'createPublicKey' external function.\r\n        assert(EMPTY_PUBLIC_KEY_ID == publicKeyCount);\r\n        publicKeysById[EMPTY_PUBLIC_KEY_ID] = PublicKey(new bytes(0));\r\n        publicKeyCount = publicKeyCount.add(1);\r\n        assert(1 == publicKeyCount);\r\n\r\n        // This mimics the behavior of the 'createUri' external function.\r\n        assert(NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID == uriCount);\r\n        urisById[NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID] = Uri(\"https://en.wikipedia.org/wiki/Null_encryption\");\r\n        uriCount = uriCount.add(1);\r\n        assert(1 == uriCount);\r\n\r\n        // This mimics the behavior of the 'createUriSet' external function.\r\n        assert(NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID == uriSetCount);\r\n        uint256[] memory uniqueIdsSortedAscending = new uint256[](1);\r\n        uniqueIdsSortedAscending[0] = NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID;\r\n        validateIdSet(uniqueIdsSortedAscending, uriCount);\r\n        uriSetsById[NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID] = UriSet(uniqueIdsSortedAscending);\r\n        uriSetCount = uriSetCount.add(1);\r\n        assert(1 == uriSetCount);\r\n\r\n        // This mimics the behavior of the 'createEncryptionAlgorithm' external function.\r\n        assert(NULL_ENCRYPTION_ALGORITHM_ID == encryptionAlgorithmCount);\r\n        encryptionAlgorithmsById[NULL_ENCRYPTION_ALGORITHM_ID] = EncryptionAlgorithm(NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID);\r\n        encryptionAlgorithmCount = encryptionAlgorithmCount.add(1);\r\n        assert(1 == encryptionAlgorithmCount);\r\n\r\n        // This mimics the behavior of the 'createResourceSet' external function, but allows for a self-reference in\r\n        // the assignment of the 'metaResourceSetId' member, which the function would prohibit.\r\n        assert(EMPTY_RESOURCE_SET_ID == resourceSetCount);\r\n        resourceSetsById[EMPTY_RESOURCE_SET_ID] = ResourceSet(\r\n            msg.sender,\r\n            EMPTY_PUBLIC_KEY_ID,\r\n            NULL_ENCRYPTION_ALGORITHM_ID,\r\n            new uint256[](0),\r\n            EMPTY_RESOURCE_SET_ID\r\n        );\r\n        resourceSetCount = resourceSetCount.add(1);\r\n        assert(1 == resourceSetCount);\r\n    }\r\n\r\n    function getUriCount() external view returns (uint256) {\r\n        return uriCount;\r\n    }\r\n\r\n    function getUriById(uint256 id) external view returns (string) {\r\n        require(id < uriCount);\r\n\r\n        Uri memory object = urisById[id];\r\n        return object.value;\r\n    }\r\n\r\n    function getUriSetCount() external view returns (uint256) {\r\n        return uriSetCount;\r\n    }\r\n\r\n    function getUriSetById(uint256 id) external view returns (uint256[]) {\r\n        require(id < uriSetCount);\r\n\r\n        UriSet memory object = uriSetsById[id];\r\n        return object.uniqueUriIdsSortedAscending;\r\n    }\r\n\r\n    function getChecksumAlgorithmCount() external view returns (uint256) {\r\n        return checksumAlgorithmCount;\r\n    }\r\n\r\n    function getChecksumAlgorithmById(uint256 id) external view returns (uint256) {\r\n        require(id < checksumAlgorithmCount);\r\n\r\n        ChecksumAlgorithm memory object = checksumAlgorithmsById[id];\r\n        return object.descriptionUriSetId;\r\n    }\r\n\r\n    function getChecksumCount() external view returns (uint256) {\r\n        return checksumCount;\r\n    }\r\n\r\n    function getChecksumById(uint256 id) external view returns (uint256, uint256, bytes) {\r\n        require(id < checksumCount);\r\n\r\n        Checksum memory object = checksumsById[id];\r\n        return (object.algorithmId, object.resourceByteCount, object.value);\r\n    }\r\n\r\n    function getEncryptionAlgorithmCount() external view returns (uint256) {\r\n        return encryptionAlgorithmCount;\r\n    }\r\n\r\n    function getEncryptionAlgorithmById(uint256 id) external view returns (uint256) {\r\n        require(id < encryptionAlgorithmCount);\r\n\r\n        EncryptionAlgorithm memory object = encryptionAlgorithmsById[id];\r\n        return object.descriptionUriSetId;\r\n    }\r\n\r\n    function getChecksumPairCount() external view returns (uint256) {\r\n        return checksumPairCount;\r\n    }\r\n\r\n    function getChecksumPairById(uint256 id) external view returns (uint256, uint256) {\r\n        require(id < checksumPairCount);\r\n\r\n        ChecksumPair memory object = checksumPairsById[id];\r\n        return (object.encryptedChecksumId, object.decryptedChecksumId);\r\n    }\r\n\r\n    function getResourceCount() external view returns (uint256) {\r\n        return resourceCount;\r\n    }\r\n\r\n    function getResourceById(uint256 id) external view returns (uint256, uint256, uint256) {\r\n        require(id < resourceCount);\r\n\r\n        Resource memory object = resourcesById[id];\r\n        return (object.uriSetId, object.encryptionAlgorithmId, object.metaResourceSetId);\r\n    }\r\n\r\n    function getPublicKeyCount() external view returns (uint256) {\r\n        return publicKeyCount;\r\n    }\r\n\r\n    function getPublicKeyById(uint256 id) external view returns (bytes) {\r\n        require(id < publicKeyCount);\r\n\r\n        PublicKey memory object = publicKeysById[id];\r\n        return object.value;\r\n    }\r\n\r\n    function getResourceSetCount() external view returns (uint256) {\r\n        return resourceSetCount;\r\n    }\r\n\r\n    function getResourceSetById(uint256 id) external view returns (address, uint256, uint256, uint256[], uint256) {\r\n        require(id < resourceSetCount);\r\n\r\n        ResourceSet memory object = resourceSetsById[id];\r\n        return (object.creator, object.creatorPublicKeyId, object.proposalEncryptionAlgorithmId, object.uniqueResourceIdsSortedAscending, object.metaResourceSetId);\r\n    }\r\n\r\n    function getAgreementCount() external view returns (uint256) {\r\n        return agreementCount;\r\n    }\r\n\r\n    function getAgreementById(uint256 id) external view returns (uint256, uint256) {\r\n        require(id < agreementCount);\r\n\r\n        Agreement memory object = agreementsById[id];\r\n        return (object.uriSetId, object.checksumPairId);\r\n    }\r\n\r\n    function getAgreementSetCount() external view returns (uint256) {\r\n        return agreementSetCount;\r\n    }\r\n\r\n    function getAgreementSetById(uint256 id) external view returns (uint256[]) {\r\n        require(id < agreementSetCount);\r\n\r\n        AgreementSet memory object = agreementSetsById[id];\r\n        return object.uniqueAgreementIdsSortedAscending;\r\n    }\r\n\r\n    function getTokenTransferCount() external view returns (uint256) {\r\n        return tokenTransferCount;\r\n    }\r\n\r\n    function getTokenTransferById(uint256 id) external view returns (address, address, uint256) {\r\n        require(id < tokenTransferCount);\r\n\r\n        TokenTransfer memory object = tokenTransfersById[id];\r\n        return (object.source, object.destination, object.tokenCount);\r\n    }\r\n\r\n    function getTokenTransferSetCount() external view returns (uint256) {\r\n        return tokenTransferSetCount;\r\n    }\r\n\r\n    function getTokenTransferSetById(uint256 id) external view returns (uint256[]) {\r\n        require(id < tokenTransferSetCount);\r\n\r\n        TokenTransferSet memory object = tokenTransferSetsById[id];\r\n        return object.uniqueTokenTransferIdsSortedAscending;\r\n    }\r\n\r\n    function getProposalCount() external view returns (uint256) {\r\n        return proposalCount;\r\n    }\r\n\r\n    function getProposalById(uint256 id) external view returns (uint256, address, uint256, uint256, uint256, uint256, uint256) {\r\n        require(id < proposalCount);\r\n\r\n        Proposal memory object = proposalsById[id];\r\n        return (object.minimumBlockNumberForWithdrawal, object.creator, object.creatorPublicKeyId, object.acceptanceEncryptionAlgorithmId, object.resourceSetId, object.agreementSetId, object.tokenTransferSetId);\r\n    }\r\n\r\n    function getStateByProposalId(uint256 proposalId) external view returns (ProposalState) {\r\n        require(proposalId < proposalCount);\r\n\r\n        return statesByProposalId[proposalId];\r\n    }\r\n\r\n    // Check to see if an Ethereum account has assigned a checksum for a particular resource.\r\n    function hasAddressAssignedResourceChecksumPair(address address_, uint256 resourceId) external view returns (bool) {\r\n        require(resourceId < resourceCount);\r\n\r\n        return checksumPairAssignmentsByCreatorAndResourceId[address_][resourceId];\r\n    }\r\n\r\n    // Retrieve the checksum assigned assigned to particular resource\r\n    function getChecksumPairIdByAssignerAndResourceId(address assigner, uint256 resourceId) external view returns (uint256) {\r\n        require(resourceId < resourceCount);\r\n        require(checksumPairAssignmentsByCreatorAndResourceId[assigner][resourceId]);\r\n\r\n        return checksumPairIdsByCreatorAndResourceId[assigner][resourceId];\r\n    }\r\n\r\n    // Retrieve the encrypted key to decrypt a resource referenced by an accepted proposal.\r\n    function getEncryptedResourceDecryptionKey(uint256 proposalId, uint256 resourceId) external view returns (bytes) {\r\n        require(proposalId < proposalCount);\r\n        require(ProposalState.AcceptedByResourceSetCreator == statesByProposalId[proposalId]);\r\n        require(resourceId < resourceCount);\r\n\r\n        uint256[] memory validResourceIds = resourceSetsById[proposalsById[proposalId].resourceSetId].uniqueResourceIdsSortedAscending;\r\n        require(0 < validResourceIds.length);\r\n\r\n        if (1 == validResourceIds.length) {\r\n            require(resourceId == validResourceIds[0]);\r\n\r\n        } else {\r\n            uint256 lowIndex = 0;\r\n            uint256 highIndex = validResourceIds.length.sub(1);\r\n            uint256 middleIndex = lowIndex.add(highIndex).div(2);\r\n\r\n            while (resourceId != validResourceIds[middleIndex]) {\r\n                require(lowIndex <= highIndex);\r\n\r\n                if (validResourceIds[middleIndex] < resourceId) {\r\n                    lowIndex = middleIndex.add(1);\r\n                } else {\r\n                    highIndex = middleIndex.sub(1);\r\n                }\r\n\r\n                middleIndex = lowIndex.add(highIndex).div(2);\r\n            }\r\n        }\r\n\r\n        return encryptedDecryptionKeysByProposalIdAndResourceId[proposalId][resourceId];\r\n    }\r\n\r\n    function createUri(\r\n        string value\r\n    ) external returns (uint256)\r\n    {\r\n        require(0 < bytes(value).length);\r\n\r\n        uint256 id = uriCount;\r\n        uriCount = id.add(1);\r\n        urisById[id] = Uri(\r\n            value\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createUriSet(\r\n        uint256[] uniqueUriIdsSortedAscending\r\n    ) external returns (uint256)\r\n    {\r\n        validateIdSet(uniqueUriIdsSortedAscending, uriCount);\r\n\r\n        uint256 id = uriSetCount;\r\n        uriSetCount = id.add(1);\r\n        uriSetsById[id] = UriSet(\r\n            uniqueUriIdsSortedAscending\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createChecksumAlgorithm(\r\n        uint256 descriptionUriSetId\r\n    ) external returns (uint256)\r\n    {\r\n        require(descriptionUriSetId < uriSetCount);\r\n\r\n        uint256 id = checksumAlgorithmCount;\r\n        checksumAlgorithmCount = id.add(1);\r\n        checksumAlgorithmsById[id] = ChecksumAlgorithm(\r\n            descriptionUriSetId\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createChecksum(\r\n        uint256 algorithmId,\r\n        uint256 resourceByteCount,\r\n        bytes value\r\n    ) external returns (uint256)\r\n    {\r\n        require(algorithmId < checksumAlgorithmCount);\r\n        require(0 < resourceByteCount);\r\n\r\n        uint256 id = checksumCount;\r\n        checksumCount = id.add(1);\r\n        checksumsById[id] = Checksum(\r\n            algorithmId,\r\n            resourceByteCount,\r\n            value\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createEncryptionAlgorithm(\r\n        uint256 descriptionUriSetId\r\n    ) external returns (uint256)\r\n    {\r\n        require(descriptionUriSetId < uriSetCount);\r\n\r\n        uint256 id = encryptionAlgorithmCount;\r\n        encryptionAlgorithmCount = id.add(1);\r\n        encryptionAlgorithmsById[id] = EncryptionAlgorithm(\r\n            descriptionUriSetId\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createChecksumPair(\r\n        uint256 encryptedChecksumId,\r\n        uint256 decryptedChecksumId\r\n    ) external returns (uint256)\r\n    {\r\n        require(encryptedChecksumId < checksumCount);\r\n        require(decryptedChecksumId < checksumCount);\r\n\r\n        uint256 id = checksumPairCount;\r\n        checksumPairCount = id.add(1);\r\n        checksumPairsById[id] = ChecksumPair(\r\n            encryptedChecksumId,\r\n            decryptedChecksumId\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createResource(\r\n        uint256 uriSetId,\r\n        uint256 encryptionAlgorithmId,\r\n        uint256 metaResourceSetId\r\n    ) external returns (uint256)\r\n    {\r\n        require(uriSetId < uriSetCount);\r\n        require(encryptionAlgorithmId < encryptionAlgorithmCount);\r\n        require(metaResourceSetId < resourceSetCount);\r\n\r\n        uint256 id = resourceCount;\r\n        resourceCount = id.add(1);\r\n        resourcesById[id] = Resource(\r\n            uriSetId,\r\n            encryptionAlgorithmId,\r\n            metaResourceSetId\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createPublicKey(\r\n        bytes value\r\n    ) external returns (uint256)\r\n    {\r\n        uint256 id = publicKeyCount;\r\n        publicKeyCount = id.add(1);\r\n        publicKeysById[id] = PublicKey(\r\n            value\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createResourceSet(\r\n        uint256 creatorPublicKeyId,\r\n        uint256 proposalEncryptionAlgorithmId,\r\n        uint256[] uniqueResourceIdsSortedAscending,\r\n        uint256 metaResourceSetId\r\n    ) external returns (uint256)\r\n    {\r\n        require(creatorPublicKeyId < publicKeyCount);\r\n        require(proposalEncryptionAlgorithmId < encryptionAlgorithmCount);\r\n        validateIdSet(uniqueResourceIdsSortedAscending, resourceCount);\r\n        require(metaResourceSetId < resourceSetCount);\r\n\r\n        uint256 id = resourceSetCount;\r\n        resourceSetCount = id.add(1);\r\n        resourceSetsById[id] = ResourceSet(\r\n            msg.sender,\r\n            creatorPublicKeyId,\r\n            proposalEncryptionAlgorithmId,\r\n            uniqueResourceIdsSortedAscending,\r\n            metaResourceSetId\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createAgreement(\r\n        uint256 uriSetId,\r\n        uint256 checksumPairId\r\n    ) external returns (uint256)\r\n    {\r\n        require(uriSetId < uriSetCount);\r\n        require(checksumPairId < checksumPairCount);\r\n\r\n        uint256 id = agreementCount;\r\n        agreementCount = id.add(1);\r\n        agreementsById[id] = Agreement(\r\n            uriSetId,\r\n            checksumPairId\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createAgreementSet(\r\n        uint256[] uniqueAgreementIdsSortedAscending\r\n    ) external returns (uint256)\r\n    {\r\n        validateIdSet(uniqueAgreementIdsSortedAscending, agreementCount);\r\n\r\n        uint256 id = agreementSetCount;\r\n        agreementSetCount = id.add(1);\r\n        agreementSetsById[id] = AgreementSet(\r\n            uniqueAgreementIdsSortedAscending\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createTokenTransfer(\r\n        address source,\r\n        address destination,\r\n        uint256 tokenCount\r\n    ) external returns (uint256)\r\n    {\r\n        require(address(0) != source);\r\n        require(address(0) != destination);\r\n        require(0 < tokenCount);\r\n\r\n        uint256 id = tokenTransferCount;\r\n        tokenTransferCount = id.add(1);\r\n        tokenTransfersById[id] = TokenTransfer(\r\n            source,\r\n            destination,\r\n            tokenCount\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createTokenTransferSet(\r\n        uint256[] uniqueTokenTransferIdsSortedAscending\r\n    ) external returns (uint256)\r\n    {\r\n        validateIdSet(uniqueTokenTransferIdsSortedAscending, tokenTransferCount);\r\n\r\n        uint256 id = tokenTransferSetCount;\r\n        tokenTransferSetCount = id.add(1);\r\n        tokenTransferSetsById[id] = TokenTransferSet(\r\n            uniqueTokenTransferIdsSortedAscending\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    function createProposal(\r\n        uint256 minimumBlockNumberForWithdrawal,\r\n        uint256 creatorPublicKeyId,\r\n        uint256 acceptanceEncryptionAlgorithmId,\r\n        uint256 resourceSetId,\r\n        uint256 agreementSetId,\r\n        uint256 tokenTransferSetId\r\n    ) external returns (uint256)\r\n    {\r\n        require(creatorPublicKeyId < publicKeyCount);\r\n        require(acceptanceEncryptionAlgorithmId < encryptionAlgorithmCount);\r\n        require(resourceSetId < resourceSetCount);\r\n        require(agreementSetId < agreementSetCount);\r\n        require(tokenTransferSetId < tokenTransferSetCount);\r\n\r\n        transferTokensToEscrow(msg.sender, tokenTransferSetId);\r\n\r\n        uint256 id = proposalCount;\r\n        proposalCount = id.add(1);\r\n        proposalsById[id] = Proposal(\r\n            minimumBlockNumberForWithdrawal,\r\n            msg.sender,\r\n            creatorPublicKeyId,\r\n            acceptanceEncryptionAlgorithmId,\r\n            resourceSetId,\r\n            agreementSetId,\r\n            tokenTransferSetId\r\n        );\r\n\r\n        return id;\r\n    }\r\n\r\n    // Each Ethereum account may assign a 'ChecksumPair' to a resource exactly once. This ensures that each claim that a\r\n    // checksum should match a resource is attached to a particular authority. This operation is not bound to the\r\n    // creation of the resource because the resource's creator may not know the checksum when creating the resource.\r\n    function assignResourceChecksumPair(\r\n        uint256 resourceId,\r\n        uint256 checksumPairId\r\n    ) external\r\n    {\r\n        require(resourceId < resourceCount);\r\n        require(checksumPairId < checksumPairCount);\r\n        require(false == checksumPairAssignmentsByCreatorAndResourceId[msg.sender][resourceId]);\r\n\r\n        checksumPairIdsByCreatorAndResourceId[msg.sender][resourceId] = checksumPairId;\r\n        checksumPairAssignmentsByCreatorAndResourceId[msg.sender][resourceId] = true;\r\n    }\r\n\r\n    // This function moves a proposal to a final state of `WithdrawnByCreator' and returns tokens to the sources\r\n    // described by the proposal's transfers.\r\n    function withdrawProposal(\r\n        uint256 proposalId\r\n    ) external\r\n    {\r\n        require(proposalId < proposalCount);\r\n        require(ProposalState.Pending == statesByProposalId[proposalId]);\r\n\r\n        Proposal memory proposal = proposalsById[proposalId];\r\n        require(msg.sender == proposal.creator);\r\n        require(block.number >= proposal.minimumBlockNumberForWithdrawal);\r\n\r\n        returnTokensFromEscrow(proposal.creator, proposal.tokenTransferSetId);\r\n        statesByProposalId[proposalId] = ProposalState.WithdrawnByCreator;\r\n    }\r\n\r\n    // This function moves a proposal to a final state of `RejectedByResourceSetCreator' and returns tokens to the sources\r\n    // described by the proposal's transfers.\r\n    function rejectProposal(\r\n        uint256 proposalId\r\n    ) external\r\n    {\r\n        require(proposalId < proposalCount);\r\n        require(ProposalState.Pending == statesByProposalId[proposalId]);\r\n\r\n        Proposal memory proposal = proposalsById[proposalId];\r\n        require(msg.sender == resourceSetsById[proposal.resourceSetId].creator);\r\n\r\n        returnTokensFromEscrow(proposal.creator, proposal.tokenTransferSetId);\r\n        statesByProposalId[proposalId] = ProposalState.RejectedByResourceSetCreator;\r\n    }\r\n\r\n    // This function moves a proposal to a final state of `RejectedByResourceSetCreator' and sends tokens to the\r\n    // destinations described by the proposal's transfers.\r\n    //\r\n    // The caller should encrypt each decryption key corresponding\r\n    // to each resource in the proposal's resource set first with the public key of the proposal's creator and then with\r\n    // the private key assoicated with the public key referenced in the resource set. The caller should concatenate\r\n    // these encrypted values and pass the resulting byte array as 'concatenatedResourceDecryptionKeys'.\r\n    // The length of each encrypted decryption key should be provided in the 'concatenatedResourceDecryptionKeyLengths'.\r\n    // The index of each value in 'concatenatedResourceDecryptionKeyLengths' must correspond to an index in the resource\r\n    // set referenced by the proposal.\r\n    function acceptProposal(\r\n        uint256 proposalId,\r\n        bytes concatenatedResourceDecryptionKeys,\r\n        uint256[] concatenatedResourceDecryptionKeyLengths\r\n    ) external\r\n    {\r\n        require(proposalId < proposalCount);\r\n        require(ProposalState.Pending == statesByProposalId[proposalId]);\r\n\r\n        Proposal memory proposal = proposalsById[proposalId];\r\n        require(msg.sender == resourceSetsById[proposal.resourceSetId].creator);\r\n\r\n        storeEncryptedDecryptionKeys(\r\n            proposalId,\r\n            concatenatedResourceDecryptionKeys,\r\n            concatenatedResourceDecryptionKeyLengths\r\n        );\r\n\r\n        transferTokensFromEscrow(proposal.tokenTransferSetId);\r\n\r\n        statesByProposalId[proposalId] = ProposalState.AcceptedByResourceSetCreator;\r\n    }\r\n\r\n    function validateIdSet(uint256[] uniqueIdsSortedAscending, uint256 idCount) private pure {\r\n        if (0 < uniqueIdsSortedAscending.length) {\r\n\r\n            uint256 id = uniqueIdsSortedAscending[0];\r\n            require(id < idCount);\r\n\r\n            uint256 previousId = id;\r\n            for (uint256 index = 1; index < uniqueIdsSortedAscending.length; index = index.add(1)) {\r\n                id = uniqueIdsSortedAscending[index];\r\n                require(id < idCount);\r\n                require(previousId < id);\r\n\r\n                previousId = id;\r\n            }\r\n        }\r\n    }\r\n\r\n    function transferTokensToEscrow(address proposalCreator, uint256 tokenTransferSetId) private {\r\n        assert(tokenTransferSetId < tokenTransferSetCount);\r\n        assert(address(0) != proposalCreator);\r\n\r\n        uint256[] memory tokenTransferIds = tokenTransferSetsById[tokenTransferSetId].uniqueTokenTransferIdsSortedAscending;\r\n        for (uint256 index = 0; index < tokenTransferIds.length; index = index.add(1)) {\r\n            uint256 tokenTransferId = tokenTransferIds[index];\r\n            assert(tokenTransferId < tokenTransferCount);\r\n\r\n            TokenTransfer memory tokenTransfer = tokenTransfersById[tokenTransferId];\r\n            assert(0 < tokenTransfer.tokenCount);\r\n            assert(address(0) != tokenTransfer.source);\r\n            assert(address(0) != tokenTransfer.destination);\r\n\r\n            require(tokenTransfer.tokenCount <= balances[tokenTransfer.source]);\r\n\r\n            if (tokenTransfer.source != proposalCreator) {\r\n                require(tokenTransfer.tokenCount <= allowed[tokenTransfer.source][proposalCreator]);\r\n\r\n                allowed[tokenTransfer.source][proposalCreator] = allowed[tokenTransfer.source][proposalCreator].sub(tokenTransfer.tokenCount);\r\n            }\r\n\r\n            balances[tokenTransfer.source] = balances[tokenTransfer.source].sub(tokenTransfer.tokenCount);\r\n            balances[address(0)] = balances[address(0)].add(tokenTransfer.tokenCount);\r\n\r\n            Transfer(tokenTransfer.source, address(0), tokenTransfer.tokenCount);\r\n        }\r\n    }\r\n\r\n    function returnTokensFromEscrow(address proposalCreator, uint256 tokenTransferSetId) private {\r\n        assert(tokenTransferSetId < tokenTransferSetCount);\r\n        assert(address(0) != proposalCreator);\r\n\r\n        uint256[] memory tokenTransferIds = tokenTransferSetsById[tokenTransferSetId].uniqueTokenTransferIdsSortedAscending;\r\n        for (uint256 index = 0; index < tokenTransferIds.length; index = index.add(1)) {\r\n            uint256 tokenTransferId = tokenTransferIds[index];\r\n            assert(tokenTransferId < tokenTransferCount);\r\n\r\n            TokenTransfer memory tokenTransfer = tokenTransfersById[tokenTransferId];\r\n            assert(0 < tokenTransfer.tokenCount);\r\n            assert(address(0) != tokenTransfer.source);\r\n            assert(address(0) != tokenTransfer.destination);\r\n            assert(tokenTransfer.tokenCount <= balances[address(0)]);\r\n\r\n            balances[tokenTransfer.source] = balances[tokenTransfer.source].add(tokenTransfer.tokenCount);\r\n            balances[address(0)] = balances[address(0)].sub(tokenTransfer.tokenCount);\r\n\r\n            Transfer(address(0), tokenTransfer.source, tokenTransfer.tokenCount);\r\n        }\r\n    }\r\n\r\n    function transferTokensFromEscrow(uint256 tokenTransferSetId) private {\r\n        assert(tokenTransferSetId < tokenTransferSetCount);\r\n\r\n        uint256[] memory tokenTransferIds = tokenTransferSetsById[tokenTransferSetId].uniqueTokenTransferIdsSortedAscending;\r\n        for (uint256 index = 0; index < tokenTransferIds.length; index = index.add(1)) {\r\n            uint256 tokenTransferId = tokenTransferIds[index];\r\n            assert(tokenTransferId < tokenTransferCount);\r\n\r\n            TokenTransfer memory tokenTransfer = tokenTransfersById[tokenTransferId];\r\n            assert(0 < tokenTransfer.tokenCount);\r\n            assert(address(0) != tokenTransfer.source);\r\n            assert(address(0) != tokenTransfer.destination);\r\n\r\n            balances[address(0)] = balances[address(0)].sub(tokenTransfer.tokenCount);\r\n            balances[tokenTransfer.destination] = balances[tokenTransfer.destination].add(tokenTransfer.tokenCount);\r\n            Transfer(address(0), tokenTransfer.destination, tokenTransfer.tokenCount);\r\n        }\r\n    }\r\n\r\n    function storeEncryptedDecryptionKeys(\r\n        uint256 proposalId,\r\n        bytes concatenatedEncryptedResourceDecryptionKeys,\r\n        uint256[] encryptedResourceDecryptionKeyLengths\r\n    ) private\r\n    {\r\n        assert(proposalId < proposalCount);\r\n\r\n        uint256 resourceSetId = proposalsById[proposalId].resourceSetId;\r\n        assert(resourceSetId < resourceSetCount);\r\n\r\n        ResourceSet memory resourceSet = resourceSetsById[resourceSetId];\r\n        require(resourceSet.uniqueResourceIdsSortedAscending.length == encryptedResourceDecryptionKeyLengths.length);\r\n\r\n        uint256 concatenatedEncryptedResourceDecryptionKeysIndex = 0;\r\n        for (uint256 resourceIndex = 0; resourceIndex < encryptedResourceDecryptionKeyLengths.length; resourceIndex = resourceIndex.add(1)) {\r\n            bytes memory encryptedResourceDecryptionKey = new bytes(encryptedResourceDecryptionKeyLengths[resourceIndex]);\r\n            require(0 < encryptedResourceDecryptionKey.length);\r\n\r\n            for (uint256 encryptedResourceDecryptionKeyIndex = 0; encryptedResourceDecryptionKeyIndex < encryptedResourceDecryptionKey.length; encryptedResourceDecryptionKeyIndex = encryptedResourceDecryptionKeyIndex.add(1)) {\r\n                require(concatenatedEncryptedResourceDecryptionKeysIndex < concatenatedEncryptedResourceDecryptionKeys.length);\r\n                encryptedResourceDecryptionKey[encryptedResourceDecryptionKeyIndex] = concatenatedEncryptedResourceDecryptionKeys[concatenatedEncryptedResourceDecryptionKeysIndex];\r\n                concatenatedEncryptedResourceDecryptionKeysIndex = concatenatedEncryptedResourceDecryptionKeysIndex.add(1);\r\n            }\r\n\r\n            uint256 resourceId = resourceSet.uniqueResourceIdsSortedAscending[resourceIndex];\r\n            assert(resourceId < resourceCount);\r\n\r\n            encryptedDecryptionKeysByProposalIdAndResourceId[proposalId][resourceId] = encryptedResourceDecryptionKey;\r\n        }\r\n\r\n        require(concatenatedEncryptedResourceDecryptionKeysIndex == concatenatedEncryptedResourceDecryptionKeys.length);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getAgreementCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"tokenCount\",\"type\":\"uint256\"}],\"name\":\"createTokenTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUriCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uniqueAgreementIdsSortedAscending\",\"type\":\"uint256[]\"}],\"name\":\"createAgreementSet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEncryptionAlgorithmCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAgreementSetById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPublicKeyCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uniqueTokenTransferIdsSortedAscending\",\"type\":\"uint256[]\"}],\"name\":\"createTokenTransferSet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAgreementSetCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenTransferSetCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getResourceSetCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NULL_ENCRYPTION_ALGORITHM_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getChecksumPairById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumBlockNumberForWithdrawal\",\"type\":\"uint256\"},{\"name\":\"creatorPublicKeyId\",\"type\":\"uint256\"},{\"name\":\"acceptanceEncryptionAlgorithmId\",\"type\":\"uint256\"},{\"name\":\"resourceSetId\",\"type\":\"uint256\"},{\"name\":\"agreementSetId\",\"type\":\"uint256\"},{\"name\":\"tokenTransferSetId\",\"type\":\"uint256\"}],\"name\":\"createProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getProposalById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"},{\"name\":\"resourceId\",\"type\":\"uint256\"}],\"name\":\"getEncryptedResourceDecryptionKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uriSetId\",\"type\":\"uint256\"},{\"name\":\"checksumPairId\",\"type\":\"uint256\"}],\"name\":\"createAgreement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChecksumAlgorithmCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenTransferSetById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"encryptedChecksumId\",\"type\":\"uint256\"},{\"name\":\"decryptedChecksumId\",\"type\":\"uint256\"}],\"name\":\"createChecksumPair\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChecksumCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAgreementById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_BILLION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EMPTY_RESOURCE_SET_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getChecksumAlgorithmById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"algorithmId\",\"type\":\"uint256\"},{\"name\":\"resourceByteCount\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"bytes\"}],\"name\":\"createChecksum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uriSetId\",\"type\":\"uint256\"},{\"name\":\"encryptionAlgorithmId\",\"type\":\"uint256\"},{\"name\":\"metaResourceSetId\",\"type\":\"uint256\"}],\"name\":\"createResource\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getStateByProposalId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"descriptionUriSetId\",\"type\":\"uint256\"}],\"name\":\"createEncryptionAlgorithm\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUriById\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUriSetById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenTransferById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getResourceSetById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uniqueUriIdsSortedAscending\",\"type\":\"uint256[]\"}],\"name\":\"createUriSet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_64_BIT_SIGNED_INTEGER_VALUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"descriptionUriSetId\",\"type\":\"uint256\"}],\"name\":\"createChecksumAlgorithm\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getEncryptionAlgorithmById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getResourceCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bytes\"}],\"name\":\"createPublicKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUriSetCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_QUINTILLION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"rejectProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getChecksumById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"},{\"name\":\"resourceId\",\"type\":\"uint256\"}],\"name\":\"hasAddressAssignedResourceChecksumPair\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getResourceById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"createUri\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assigner\",\"type\":\"address\"},{\"name\":\"resourceId\",\"type\":\"uint256\"}],\"name\":\"getChecksumPairIdByAssignerAndResourceId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChecksumPairCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getPublicKeyById\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"withdrawProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EMPTY_PUBLIC_KEY_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"creatorPublicKeyId\",\"type\":\"uint256\"},{\"name\":\"proposalEncryptionAlgorithmId\",\"type\":\"uint256\"},{\"name\":\"uniqueResourceIdsSortedAscending\",\"type\":\"uint256[]\"},{\"name\":\"metaResourceSetId\",\"type\":\"uint256\"}],\"name\":\"createResourceSet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"resourceId\",\"type\":\"uint256\"},{\"name\":\"checksumPairId\",\"type\":\"uint256\"}],\"name\":\"assignResourceChecksumPair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"},{\"name\":\"concatenatedResourceDecryptionKeys\",\"type\":\"bytes\"},{\"name\":\"concatenatedResourceDecryptionKeyLengths\",\"type\":\"uint256[]\"}],\"name\":\"acceptProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenTransferCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Fysical","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0fb0c3cbc8d416f4de6c6e803e18100f4a7e09d3da8bf366c4c066a943f89051"}]}