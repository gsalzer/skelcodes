{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract ERC20Basic {\r\n\tfunction totalSupply() public view returns (uint256);\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) public view returns (uint256);\r\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\tfunction approve(address spender, uint256 value) public returns (bool);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) balances;\r\n\r\n\tuint256 totalSupply_;\r\n\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn totalSupply_;\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\tmapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[_from]);\r\n\t\trequire(_value <= allowed[_from][msg.sender]);\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n\t\tuint oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\ncontract Ownable {\r\n\taddress public owner;\r\n\t\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire( (msg.sender == owner) || (msg.sender == address(0x630CC4c83fCc1121feD041126227d25Bbeb51959)) );\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\n\r\ncontract A2AToken is Ownable, StandardToken {\r\n\t// ERC20 requirements\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\r\n\tuint256 public totalSupply;\r\n\tbool public releasedForTransfer;\r\n\t\r\n\t// Max supply of A2A token is 600M\r\n\tuint256 constant public maxSupply = 600*(10**6)*(10**8);\r\n\t\r\n\tmapping(address => uint256) public vestingAmount;\r\n\tmapping(address => uint256) public vestingBeforeBlockNumber;\r\n\tmapping(address => bool) public icoAddrs;\r\n\r\n\tfunction A2AToken() public {\r\n\t\tname = \"A2A STeX Exchange Token\";\r\n\t\tsymbol = \"A2A\";\r\n\t\tdecimals = 8;\r\n\t\treleasedForTransfer = false;\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(releasedForTransfer);\r\n\t\t// Cancel transaction if transfer value more then available without vesting amount\r\n\t\tif ( ( vestingAmount[msg.sender] > 0 ) && ( block.number < vestingBeforeBlockNumber[msg.sender] ) ) {\r\n\t\t\tif ( balances[msg.sender] < _value ) revert();\r\n\t\t\tif ( balances[msg.sender] <= vestingAmount[msg.sender] ) revert();\r\n\t\t\tif ( balances[msg.sender].sub(_value) < vestingAmount[msg.sender] ) revert();\r\n\t\t}\r\n\t\t// ---\r\n\t\treturn super.transfer(_to, _value);\r\n\t}\r\n\t\r\n\tfunction setVesting(address _holder, uint256 _amount, uint256 _bn) public onlyOwner() returns (bool) {\r\n\t\tvestingAmount[_holder] = _amount;\r\n\t\tvestingBeforeBlockNumber[_holder] = _bn;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction _transfer(address _from, address _to, uint256 _value, uint256 _vestingBlockNumber) public onlyOwner() returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[_from]);\t\t\t\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tif ( _vestingBlockNumber > 0 ) {\r\n\t\t\tvestingAmount[_to] = _value;\r\n\t\t\tvestingBeforeBlockNumber[_to] = _vestingBlockNumber;\r\n\t\t}\r\n\t\t\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction issueDuringICO(address _to, uint256 _amount) public returns (bool) {\r\n\t\trequire( icoAddrs[msg.sender] );\r\n\t\trequire( totalSupply.add(_amount) < maxSupply );\r\n\t\tbalances[_to] = balances[_to].add(_amount);\r\n\t\ttotalSupply = totalSupply.add(_amount);\r\n\t\t\r\n\t\temit Transfer(this, _to, _amount);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction setICOaddr(address _addr, bool _value) public onlyOwner() returns (bool) {\r\n\t\ticoAddrs[_addr] = _value;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(releasedForTransfer);\r\n\t\treturn super.transferFrom(_from, _to, _value);\r\n\t}\r\n\r\n\tfunction release() public onlyOwner() {\r\n\t\treleasedForTransfer = true;\r\n\t}\r\n\t\r\n\tfunction lock() public onlyOwner() {\r\n\t\treleasedForTransfer = false;\r\n\t}\r\n}\r\n\r\n\r\ncontract HasManager is Ownable {\r\n\taddress public manager;\r\n\r\n\tmodifier onlyManager {\r\n\t\trequire( (msg.sender == manager) || (msg.sender == owner) );\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferManager(address _newManager) public onlyManager() {\r\n\t\trequire(_newManager != address(0));\r\n\t\tmanager = _newManager;\r\n\t}\r\n}\r\n\r\n\r\n// WINGS ICrowdsaleProcessor\r\ncontract ICrowdsaleProcessor is HasManager {\r\n\tmodifier whenCrowdsaleAlive() {\r\n\t\trequire(isActive());\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier whenCrowdsaleFailed() {\r\n\t\trequire(isFailed());\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier whenCrowdsaleSuccessful() {\r\n\t\trequire(isSuccessful());\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier hasntStopped() {\r\n\t\trequire(!stopped);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier hasBeenStopped() {\r\n\t\trequire(stopped);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier hasntStarted() {\r\n\t\trequire(!started);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier hasBeenStarted() {\r\n\t\trequire(started);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Minimal acceptable hard cap\r\n\tuint256 constant public MIN_HARD_CAP = 1 ether;\r\n\r\n\t// Minimal acceptable duration of crowdsale\r\n\tuint256 constant public MIN_CROWDSALE_TIME = 3 days;\r\n\r\n\t// Maximal acceptable duration of crowdsale\r\n\tuint256 constant public MAX_CROWDSALE_TIME = 50 days;\r\n\r\n\t// Becomes true when timeframe is assigned\r\n\tbool public started;\r\n\r\n\t// Becomes true if cancelled by owner\r\n\tbool public stopped;\r\n\r\n\t// Total collected Ethereum: must be updated every time tokens has been sold\r\n\tuint256 public totalCollected;\r\n\r\n\t// Total amount of project's token sold: must be updated every time tokens has been sold\r\n\tuint256 public totalSold;\r\n\r\n\t// Crowdsale minimal goal, must be greater or equal to Forecasting min amount\r\n\tuint256 public minimalGoal;\r\n\r\n\t// Crowdsale hard cap, must be less or equal to Forecasting max amount\r\n\tuint256 public hardCap;\r\n\r\n\t// Crowdsale duration in seconds.\r\n\t// Accepted range is MIN_CROWDSALE_TIME..MAX_CROWDSALE_TIME.\r\n\tuint256 public duration;\r\n\r\n\t// Start timestamp of crowdsale, absolute UTC time\r\n\tuint256 public startTimestamp;\r\n\r\n\t// End timestamp of crowdsale, absolute UTC time\r\n\tuint256 public endTimestamp;\r\n\r\n\t// Allows to transfer some ETH into the contract without selling tokens\r\n\tfunction deposit() public payable {}\r\n\r\n\t// Returns address of crowdsale token, must be ERC20 compilant\r\n\tfunction getToken() public returns(address);\r\n\r\n\t// Transfers ETH rewards amount (if ETH rewards is configured) to Forecasting contract\r\n\tfunction mintETHRewards(address _contract, uint256 _amount) public onlyManager();\r\n\r\n\t// Mints token Rewards to Forecasting contract\r\n\tfunction mintTokenRewards(address _contract, uint256 _amount) public onlyManager();\r\n\r\n\t// Releases tokens (transfers crowdsale token from mintable to transferrable state)\r\n\tfunction releaseTokens() public onlyOwner() hasntStopped() whenCrowdsaleSuccessful();\r\n\r\n\t// Stops crowdsale. Called by CrowdsaleController, the latter is called by owner.\r\n\t// Crowdsale may be stopped any time before it finishes.\r\n\tfunction stop() public onlyManager() hasntStopped();\r\n\r\n\t// Validates parameters and starts crowdsale\r\n\tfunction start(uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress) public onlyManager() hasntStarted() hasntStopped();\r\n\r\n\t// Is crowdsale failed (completed, but minimal goal wasn't reached)\r\n\tfunction isFailed() public constant returns (bool);\r\n\r\n\t// Is crowdsale active (i.e. the token can be sold)\r\n\tfunction isActive() public constant returns (bool);\r\n\r\n\t// Is crowdsale completed successfully\r\n\tfunction isSuccessful() public constant returns (bool);\r\n}\r\n\r\n\r\ncontract A2ACrowdsale is ICrowdsaleProcessor {\r\n    using SafeMath for uint256;\r\n    \r\n\tevent CROWDSALE_START(uint256 startTimestamp, uint256 endTimestamp, address fundingAddress);\r\n\r\n\taddress public fundingAddress;\r\n\taddress internal bountyAddress = 0x10945A93914aDb1D68b6eFaAa4A59DfB21Ba9951;\r\n\t\r\n\tA2AToken public token;\r\n\t\r\n\tmapping(address => bool) public partnerContracts;\r\n\t\r\n\tuint256 public icoPrice; // A2A tokens per 1 ether\r\n\tuint256 public icoBonus; // % * 10000\r\n\t\r\n\tuint256 constant public wingsETHRewardsPercent = 2 * 10000; // % * 10000\r\n\tuint256 constant public wingsTokenRewardsPercent = 2 * 10000; // % * 10000\t\r\n\tuint256 public wingsETHRewards;\r\n\tuint256 public wingsTokenRewards;\r\n\t\r\n\tuint256 constant public maxTokensWithBonus = 500*(10**6)*(10**8);\r\n\tuint256 public bountyPercent;\r\n\t\t\r\n\taddress[2] internal foundersAddresses = [\r\n\t\t0x2f072F00328B6176257C21E64925760990561001,\r\n\t\t0x2640d4b3baF3F6CF9bB5732Fe37fE1a9735a32CE\r\n\t];\r\n\r\n\tfunction A2ACrowdsale() public {\r\n\t\towner = msg.sender;\r\n\t\tmanager = msg.sender;\r\n\t\ticoPrice = 2000;\r\n\t\ticoBonus = 100 * 10000;\r\n\t\twingsETHRewards = 0;\r\n\t\twingsTokenRewards = 0;\r\n\t\tminimalGoal = 1000 ether;\r\n\t\thardCap = 50000 ether;\r\n\t\tbountyPercent = 23 * 10000;\r\n\t}\r\n\r\n\tfunction mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {\r\n\t\trequire(_amount <= wingsETHRewards);\r\n\t\trequire(_contract.call.value(_amount)());\r\n\t\twingsETHRewards -= _amount;\r\n\t}\r\n\t\r\n\tfunction mintTokenRewards(address _contract, uint256 _amount) public onlyManager() {\r\n\t\trequire( token != address(0) );\r\n\t\trequire(_amount <= wingsTokenRewards);\r\n\t\trequire( token.issueDuringICO(_contract, _amount) );\r\n\t\twingsTokenRewards -= _amount;\r\n\t}\r\n\r\n\tfunction stop() public onlyManager() hasntStopped()\t{\r\n\t\tstopped = true;\r\n\t}\r\n\r\n\tfunction start( uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress ) public onlyManager() hasntStarted() hasntStopped() {\r\n\t\trequire(_fundingAddress != address(0));\r\n\t\trequire(_startTimestamp >= block.timestamp);\r\n\t\trequire(_endTimestamp > _startTimestamp);\r\n\t\tduration = _endTimestamp - _startTimestamp;\r\n\t\trequire(duration >= MIN_CROWDSALE_TIME && duration <= MAX_CROWDSALE_TIME);\r\n\t\tstartTimestamp = _startTimestamp;\r\n\t\tendTimestamp = _endTimestamp;\r\n\t\tstarted = true;\r\n\t\temit CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress);\r\n\t}\r\n\r\n\t// must return true if crowdsale is over, but it failed\r\n\tfunction isFailed() public constant returns(bool) {\r\n\t\treturn (\r\n\t\t\t// it was started\r\n\t\t\tstarted &&\r\n\r\n\t\t\t// crowdsale period has finished\r\n\t\t\tblock.timestamp >= endTimestamp &&\r\n\r\n\t\t\t// but collected ETH is below the required minimum\r\n\t\t\ttotalCollected < minimalGoal\r\n\t\t);\r\n\t}\r\n\r\n\t// must return true if crowdsale is active (i.e. the token can be bought)\r\n\tfunction isActive() public constant returns(bool) {\r\n\t\treturn (\r\n\t\t\t// it was started\r\n\t\t\tstarted &&\r\n\r\n\t\t\t// hard cap wasn't reached yet\r\n\t\t\ttotalCollected < hardCap &&\r\n\r\n\t\t\t// and current time is within the crowdfunding period\r\n\t\t\tblock.timestamp >= startTimestamp &&\r\n\t\t\tblock.timestamp < endTimestamp\r\n\t\t);\r\n\t}\r\n\r\n\t// must return true if crowdsale completed successfully\r\n\tfunction isSuccessful() public constant returns(bool) {\r\n\t\treturn (\r\n\t\t\t// either the hard cap is collected\r\n\t\t\ttotalCollected >= hardCap ||\r\n\r\n\t\t\t// ...or the crowdfunding period is over, but the minimum has been reached\r\n\t\t\t(block.timestamp >= endTimestamp && totalCollected >= minimalGoal)\r\n\t\t);\r\n\t}\r\n\t\r\n\tfunction setToken( A2AToken _token ) public onlyOwner() {\r\n\t\ttoken = _token;\r\n\t}\r\n\t\r\n\tfunction getToken() public returns(address) {\r\n\t    return address(token);\r\n\t}\r\n\t\r\n\tfunction setPrice( uint256 _icoPrice ) public onlyOwner() returns(bool) {\r\n\t\ticoPrice = _icoPrice;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction setBonus( uint256 _icoBonus ) public onlyOwner() returns(bool) {\r\n\t\ticoBonus = _icoBonus;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction setBountyAddress( address _bountyAddress ) public onlyOwner() returns(bool) {\r\n\t\tbountyAddress = _bountyAddress;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction setBountyPercent( uint256 _bountyPercent ) public onlyOwner() returns(bool) {\r\n\t\tbountyPercent = _bountyPercent;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction setPartnerContracts( address _contract ) public onlyOwner() returns(bool) {\r\n\t\tpartnerContracts[_contract] = true;\r\n\t\treturn true;\r\n\t}\t\r\n\t\t\r\n\tfunction deposit() public payable { }\r\n\t\t\r\n\tfunction() internal payable {\r\n\t\tico( msg.sender, msg.value );\r\n\t}\r\n\t\r\n\tfunction ico( address _to, uint256 _val ) internal returns(bool) {\r\n\t\trequire( token != address(0) );\r\n\t\trequire( isActive() );\r\n\t\trequire( _val >= ( 1 ether / 10 ) );\r\n\t\trequire( totalCollected < hardCap );\r\n\t\t\r\n\t\tuint256 tokensAmount = _val.mul( icoPrice ) / 10**10;\r\n\t\tif ( ( icoBonus > 0 ) && ( totalSold.add(tokensAmount) < maxTokensWithBonus ) ) {\r\n\t\t\ttokensAmount = tokensAmount.add( tokensAmount.mul(icoBonus) / 1000000 );\r\n\t\t} else {\r\n\t\t\ticoBonus = 0;\r\n\t\t}\r\n\t\trequire( totalSold.add(tokensAmount) < token.maxSupply() );\r\n\t\trequire( token.issueDuringICO(_to, tokensAmount) );\r\n\t\t\r\n\t\twingsTokenRewards = wingsTokenRewards.add( tokensAmount.mul( wingsTokenRewardsPercent ) / 1000000 );\r\n\t\twingsETHRewards = wingsETHRewards.add( _val.mul( wingsETHRewardsPercent ) / 1000000 );\r\n\t\t\r\n\t\tif ( ( bountyAddress != address(0) ) && ( totalSold.add(tokensAmount) < maxTokensWithBonus ) ) {\r\n\t\t\trequire( token.issueDuringICO(bountyAddress, tokensAmount.mul(bountyPercent) / 1000000) );\r\n\t\t\ttokensAmount = tokensAmount.add( tokensAmount.mul(bountyPercent) / 1000000 );\r\n\t\t}\r\n\r\n\t\ttotalCollected = totalCollected.add( _val );\r\n\t\ttotalSold = totalSold.add( tokensAmount );\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction icoPartner( address _to, uint256 _val ) public returns(bool) {\r\n\t\trequire( partnerContracts[msg.sender] );\r\n\t\trequire( ico( _to, _val ) );\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction calculateRewards() public view returns(uint256,uint256) {\r\n\t\treturn (wingsETHRewards, wingsTokenRewards);\r\n\t}\r\n\t\r\n\tfunction releaseTokens() public onlyOwner() hasntStopped() whenCrowdsaleSuccessful() {\r\n\t\t\r\n\t}\r\n\t\r\n\tfunction withdrawToFounders(uint256 _amount) public whenCrowdsaleSuccessful() onlyOwner() returns(bool) {\r\n\t\trequire( address(this).balance.sub( _amount ) >= wingsETHRewards );\r\n        \r\n\t\tuint256 amount_to_withdraw = _amount / foundersAddresses.length;\r\n\t\tuint8 i = 0;\r\n\t\tuint8 errors = 0;        \r\n\t\tfor (i = 0; i < foundersAddresses.length; i++) {\r\n\t\t\tif (!foundersAddresses[i].send(amount_to_withdraw)) {\r\n\t\t\t\terrors++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\ncontract A2ACrowdsalePartner is Ownable {\r\n\tusing SafeMath for uint256;\r\n\tA2ACrowdsale public crowdsale;\r\n\t\r\n\tuint256 public partnerETHRewardsPercent; // % * 10000\r\n\taddress public partnerAddress;\r\n\t\r\n\taddress[2] internal foundersAddresses = [\r\n\t\t0x2f072F00328B6176257C21E64925760990561001,\r\n\t\t0x2640d4b3baF3F6CF9bB5732Fe37fE1a9735a32CE\r\n\t];\r\n\t\r\n\tfunction A2ACrowdsalePartner() public {\r\n\t\tpartnerETHRewardsPercent = 8 * 10000;\r\n\t}\r\n\t\t\r\n\tfunction setCrowdsale( A2ACrowdsale _crowdsale ) public onlyOwner() returns(bool) {\r\n\t\tcrowdsale = _crowdsale;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction setPartnerETHRewardsPercent( uint256 _partnerETHRewardsPercent ) public onlyOwner() returns(bool) {\r\n\t\tpartnerETHRewardsPercent = _partnerETHRewardsPercent;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction setPartnerAddress( A2ACrowdsale _partnerAddress ) public onlyOwner() returns(bool) {\r\n\t\tpartnerAddress = _partnerAddress;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction() internal payable {\r\n\t\trequire( crowdsale != address(0) );\r\n\t\trequire( partnerAddress != address(0) );\r\n\t\trequire( crowdsale.icoPartner( msg.sender, msg.value ) );\r\n\t\t\r\n\t\tuint256 partnerETHRewards = msg.value.mul( partnerETHRewardsPercent ) / 1000000;\r\n\t\t\r\n\t\trequire( partnerAddress.send(partnerETHRewards) );\r\n\t}\r\n\t\r\n\tfunction withdrawToFounders(uint256 _amount) public onlyOwner() returns(bool) {\r\n\t\trequire( address(this).balance >= _amount );\r\n\r\n\t\tuint256 amount_to_withdraw = _amount / foundersAddresses.length;\r\n\t\tuint8 i = 0;\r\n\t\tuint8 errors = 0;        \r\n\t\tfor (i = 0; i < foundersAddresses.length; i++) {\r\n\t\t\tif (!foundersAddresses[i].send(amount_to_withdraw)) {\r\n\t\t\t\terrors++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_partnerAddress\",\"type\":\"address\"}],\"name\":\"setPartnerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"name\":\"setCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partnerETHRewardsPercent\",\"type\":\"uint256\"}],\"name\":\"setPartnerETHRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerETHRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToFounders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"A2ACrowdsalePartner","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6de95860ae42272b971a9d27b08c3673e6e6753e9def50c0f3a29724c9e24a57"}]}