{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// File: contracts/DateTime.sol\r\n\r\ncontract DateTime {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct _DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) public pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) public pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n\r\n                // Minute\r\n                dt.minute = getMinute(timestamp);\r\n\r\n                // Second\r\n                dt.second = getSecond(timestamp);\r\n\r\n                // Day of week.\r\n                dt.weekday = getWeekday(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n\r\n        function getMinute(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60) % 60);\r\n        }\r\n\r\n        function getSecond(uint timestamp) public pure returns (uint8) {\r\n                return uint8(timestamp % 60);\r\n        }\r\n\r\n        function getWeekday(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, 0, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, minute, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n                uint16 i;\r\n\r\n                // Year\r\n                for (i = ORIGIN_YEAR; i < year; i++) {\r\n                        if (isLeapYear(i)) {\r\n                                timestamp += LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                timestamp += YEAR_IN_SECONDS;\r\n                        }\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                for (i = 1; i < month; i++) {\r\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n                }\r\n\r\n                // Day\r\n                timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n                // Hour\r\n                timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n                // Minute\r\n                timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n                // Second\r\n                timestamp += second;\r\n\r\n                return timestamp;\r\n        }\r\n}\r\n\r\n// File: contracts/ISimpleCrowdsale.sol\r\n\r\ninterface ISimpleCrowdsale {\r\n    function getSoftCap() external view returns(uint256);\r\n    function isContributorInLists(address contributorAddress) external view returns(bool);\r\n    function processReservationFundContribution(\r\n        address contributor,\r\n        uint256 tokenAmount,\r\n        uint256 tokenBonusAmount\r\n    ) external payable;\r\n}\r\n\r\n// File: contracts/fund/ICrowdsaleFund.sol\r\n\r\n/**\r\n * @title ICrowdsaleFund\r\n * @dev Fund methods used by crowdsale contract\r\n */\r\ninterface ICrowdsaleFund {\r\n    /**\r\n    * @dev Function accepts user`s contributed ether and logs contribution\r\n    * @param contributor Contributor wallet address.\r\n    */\r\n    function processContribution(address contributor) external payable;\r\n    /**\r\n    * @dev Function is called on the end of successful crowdsale\r\n    */\r\n    function onCrowdsaleEnd() external;\r\n    /**\r\n    * @dev Function is called if crowdsale failed to reach soft cap\r\n    */\r\n    function enableCrowdsaleRefund() external;\r\n}\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n    /**\r\n    * @dev constructor\r\n    */\r\n    function SafeMath() public {\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/ownership/MultiOwnable.sol\r\n\r\n/**\r\n * @title MultiOwnable\r\n * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\r\n * functions, this simplifies the implementation of \"users permissions\".\r\n */\r\ncontract MultiOwnable {\r\n    address public manager; // address used to set owners\r\n    address[] public owners;\r\n    mapping(address => bool) public ownerByAddress;\r\n\r\n    event SetOwners(address[] owners);\r\n\r\n    modifier onlyOwner() {\r\n        require(ownerByAddress[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev MultiOwnable constructor sets the manager\r\n     */\r\n    function MultiOwnable() public {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to set owners addresses\r\n     */\r\n    function setOwners(address[] _owners) public {\r\n        require(msg.sender == manager);\r\n        _setOwners(_owners);\r\n\r\n    }\r\n\r\n    function _setOwners(address[] _owners) internal {\r\n        for(uint256 i = 0; i < owners.length; i++) {\r\n            ownerByAddress[owners[i]] = false;\r\n        }\r\n\r\n\r\n        for(uint256 j = 0; j < _owners.length; j++) {\r\n            ownerByAddress[_owners[j]] = true;\r\n        }\r\n        owners = _owners;\r\n        SetOwners(_owners);\r\n    }\r\n\r\n    function getOwners() public constant returns (address[]) {\r\n        return owners;\r\n    }\r\n}\r\n\r\n// File: contracts/token/IERC20Token.sol\r\n\r\n/**\r\n * @title IERC20Token - ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20Token {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value)  public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\r\n    function approve(address _spender, uint256 _value)  public returns (bool success);\r\n    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// File: contracts/token/ERC20Token.sol\r\n\r\n/**\r\n * @title ERC20Token - ERC20 base implementation\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Token is IERC20Token, SafeMath {\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n// File: contracts/token/ITokenEventListener.sol\r\n\r\n/**\r\n * @title ITokenEventListener\r\n * @dev Interface which should be implemented by token listener\r\n */\r\ninterface ITokenEventListener {\r\n    /**\r\n     * @dev Function is called after token transfer/transferFrom\r\n     * @param _from Sender address\r\n     * @param _to Receiver address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function onTokenTransfer(address _from, address _to, uint256 _value) external;\r\n}\r\n\r\n// File: contracts/token/ManagedToken.sol\r\n\r\n/**\r\n * @title ManagedToken\r\n * @dev ERC20 compatible token with issue and destroy facilities\r\n * @dev All transfers can be monitored by token event listener\r\n */\r\ncontract ManagedToken is ERC20Token, MultiOwnable {\r\n    bool public allowTransfers = false;\r\n    bool public issuanceFinished = false;\r\n\r\n    ITokenEventListener public eventListener;\r\n\r\n    event AllowTransfersChanged(bool _newState);\r\n    event Issue(address indexed _to, uint256 _value);\r\n    event Destroy(address indexed _from, uint256 _value);\r\n    event IssuanceFinished();\r\n\r\n    modifier transfersAllowed() {\r\n        require(allowTransfers);\r\n        _;\r\n    }\r\n\r\n    modifier canIssue() {\r\n        require(!issuanceFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev ManagedToken constructor\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owners Owners list\r\n     */\r\n    function ManagedToken(address _listener, address[] _owners) public {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        }\r\n        _setOwners(_owners);\r\n    }\r\n\r\n    /**\r\n     * @dev Enable/disable token transfers. Can be called only by owners\r\n     * @param _allowTransfers True - allow False - disable\r\n     */\r\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\r\n        allowTransfers = _allowTransfers;\r\n        AllowTransfersChanged(_allowTransfers);\r\n    }\r\n\r\n    /**\r\n     * @dev Set/remove token event listener\r\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\r\n     */\r\n    function setListener(address _listener) public onlyOwner {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        } else {\r\n            delete eventListener;\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transfer(_to, _value);\r\n        if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transferFrom(_from, _to, _value);\r\n        if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(_from, _to, _value);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function hasListener() internal view returns(bool) {\r\n        if(eventListener == address(0)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Issue tokens to specified wallet\r\n     * @param _to Wallet address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\r\n        totalSupply = safeAdd(totalSupply, _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Issue(_to, _value);\r\n        Transfer(address(0), _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\r\n     * @dev Fund contract address must be in the list of owners to burn token during refund\r\n     * @param _from Wallet address\r\n     * @param _value Amount of tokens to destroy\r\n     */\r\n    function destroy(address _from, uint256 _value) external {\r\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\r\n        require(balances[_from] >= _value);\r\n        totalSupply = safeSub(totalSupply, _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        Transfer(_from, address(0), _value);\r\n        Destroy(_from, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Finish token issuance\r\n     * @return True if success\r\n     */\r\n    function finishIssuance() public onlyOwner returns (bool) {\r\n        issuanceFinished = true;\r\n        IssuanceFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/Fund.sol\r\n\r\ncontract Fund is ICrowdsaleFund, SafeMath, MultiOwnable {\r\n    enum FundState {\r\n        Crowdsale,\r\n        CrowdsaleRefund,\r\n        TeamWithdraw,\r\n        Refund\r\n    }\r\n\r\n    FundState public state = FundState.Crowdsale;\r\n    ManagedToken public token;\r\n\r\n    uint256 public constant INITIAL_TAP = 192901234567901; // (wei/sec) == 500 ether/month\r\n\r\n    address public teamWallet;\r\n    uint256 public crowdsaleEndDate;\r\n\r\n    address public referralTokenWallet;\r\n    address public foundationTokenWallet;\r\n    address public reserveTokenWallet;\r\n    address public bountyTokenWallet;\r\n    address public companyTokenWallet;\r\n    address public advisorTokenWallet;\r\n    address public lockedTokenAddress;\r\n    address public refundManager;\r\n\r\n    uint256 public tap;\r\n    uint256 public lastWithdrawTime = 0;\r\n    uint256 public firstWithdrawAmount = 0;\r\n\r\n    address public crowdsaleAddress;\r\n    mapping(address => uint256) public contributions;\r\n\r\n    event RefundContributor(address tokenHolder, uint256 amountWei, uint256 timestamp);\r\n    event RefundHolder(address tokenHolder, uint256 amountWei, uint256 tokenAmount, uint256 timestamp);\r\n    event Withdraw(uint256 amountWei, uint256 timestamp);\r\n    event RefundEnabled(address initiatorAddress);\r\n\r\n    /**\r\n     * @dev Fund constructor\r\n     * @param _teamWallet Withdraw functions transfers ether to this address\r\n     * @param _referralTokenWallet Referral wallet address\r\n     * @param _companyTokenWallet Company wallet address\r\n     * @param _reserveTokenWallet Reserve wallet address\r\n     * @param _bountyTokenWallet Bounty wallet address\r\n     * @param _advisorTokenWallet Advisor wallet address\r\n     * @param _owners Contract owners\r\n     */\r\n    function Fund(\r\n        address _teamWallet,\r\n        address _referralTokenWallet,\r\n        address _foundationTokenWallet,\r\n        address _companyTokenWallet,\r\n        address _reserveTokenWallet,\r\n        address _bountyTokenWallet,\r\n        address _advisorTokenWallet,\r\n        address _refundManager,\r\n        address[] _owners\r\n    ) public\r\n    {\r\n        teamWallet = _teamWallet;\r\n        referralTokenWallet = _referralTokenWallet;\r\n        foundationTokenWallet = _foundationTokenWallet;\r\n        companyTokenWallet = _companyTokenWallet;\r\n        reserveTokenWallet = _reserveTokenWallet;\r\n        bountyTokenWallet = _bountyTokenWallet;\r\n        advisorTokenWallet = _advisorTokenWallet;\r\n        refundManager = _refundManager;\r\n        _setOwners(_owners);\r\n    }\r\n\r\n    modifier withdrawEnabled() {\r\n        require(canWithdraw());\r\n        _;\r\n    }\r\n\r\n    modifier onlyCrowdsale() {\r\n        require(msg.sender == crowdsaleAddress);\r\n        _;\r\n    }\r\n\r\n    function canWithdraw() public returns(bool);\r\n\r\n    function setCrowdsaleAddress(address _crowdsaleAddress) public onlyOwner {\r\n        require(crowdsaleAddress == address(0));\r\n        crowdsaleAddress = _crowdsaleAddress;\r\n    }\r\n\r\n    function setTokenAddress(address _tokenAddress) public onlyOwner {\r\n        require(address(token) == address(0));\r\n        token = ManagedToken(_tokenAddress);\r\n    }\r\n\r\n    function setLockedTokenAddress(address _lockedTokenAddress) public onlyOwner {\r\n        require(address(lockedTokenAddress) == address(0));\r\n        lockedTokenAddress = _lockedTokenAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Process crowdsale contribution\r\n     */\r\n    function processContribution(address contributor) external payable onlyCrowdsale {\r\n        require(state == FundState.Crowdsale);\r\n        uint256 totalContribution = safeAdd(contributions[contributor], msg.value);\r\n        contributions[contributor] = totalContribution;\r\n    }\r\n\r\n    /**\r\n     * @dev Callback is called after crowdsale finalization if soft cap is reached\r\n     */\r\n    function onCrowdsaleEnd() external onlyCrowdsale {\r\n        state = FundState.TeamWithdraw;\r\n        ISimpleCrowdsale crowdsale = ISimpleCrowdsale(crowdsaleAddress);\r\n        firstWithdrawAmount = safeDiv(crowdsale.getSoftCap(), 2);\r\n        lastWithdrawTime = now;\r\n        tap = INITIAL_TAP;\r\n        crowdsaleEndDate = now;\r\n    }\r\n\r\n    /**\r\n     * @dev Callback is called after crowdsale finalization if soft cap is not reached\r\n     */\r\n    function enableCrowdsaleRefund() external onlyCrowdsale {\r\n        require(state == FundState.Crowdsale);\r\n        state = FundState.CrowdsaleRefund;\r\n    }\r\n\r\n    /**\r\n    * @dev Function is called by contributor to refund payments if crowdsale failed to reach soft cap\r\n    */\r\n    function refundCrowdsaleContributor() external {\r\n        require(state == FundState.CrowdsaleRefund);\r\n        require(contributions[msg.sender] > 0);\r\n\r\n        uint256 refundAmount = contributions[msg.sender];\r\n        contributions[msg.sender] = 0;\r\n        token.destroy(msg.sender, token.balanceOf(msg.sender));\r\n        msg.sender.transfer(refundAmount);\r\n        RefundContributor(msg.sender, refundAmount, now);\r\n    }\r\n\r\n    /**\r\n    * @dev Function is called by owner to refund payments if crowdsale failed to reach soft cap\r\n    */\r\n    function autoRefundCrowdsaleContributor(address contributorAddress) external {\r\n        require(ownerByAddress[msg.sender] == true || msg.sender == refundManager);\r\n        require(state == FundState.CrowdsaleRefund);\r\n        require(contributions[contributorAddress] > 0);\r\n\r\n        uint256 refundAmount = contributions[contributorAddress];\r\n        contributions[contributorAddress] = 0;\r\n        token.destroy(contributorAddress, token.balanceOf(contributorAddress));\r\n        contributorAddress.transfer(refundAmount);\r\n        RefundContributor(contributorAddress, refundAmount, now);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease tap amount\r\n     * @param _tap New tap value\r\n     */\r\n    function decTap(uint256 _tap) external onlyOwner {\r\n        require(state == FundState.TeamWithdraw);\r\n        require(_tap < tap);\r\n        tap = _tap;\r\n    }\r\n\r\n    function getCurrentTapAmount() public constant returns(uint256) {\r\n        if(state != FundState.TeamWithdraw) {\r\n            return 0;\r\n        }\r\n        return calcTapAmount();\r\n    }\r\n\r\n    function calcTapAmount() internal view returns(uint256) {\r\n        uint256 amount = safeMul(safeSub(now, lastWithdrawTime), tap);\r\n        if(address(this).balance < amount) {\r\n            amount = address(this).balance;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function firstWithdraw() public onlyOwner withdrawEnabled {\r\n        require(firstWithdrawAmount > 0);\r\n        uint256 amount = firstWithdrawAmount;\r\n        firstWithdrawAmount = 0;\r\n        teamWallet.transfer(amount);\r\n        Withdraw(amount, now);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw tap amount\r\n     */\r\n    function withdraw() public onlyOwner withdrawEnabled {\r\n        require(state == FundState.TeamWithdraw);\r\n        uint256 amount = calcTapAmount();\r\n        lastWithdrawTime = now;\r\n        teamWallet.transfer(amount);\r\n        Withdraw(amount, now);\r\n    }\r\n\r\n    // Refund\r\n    /**\r\n     * @dev Called to start refunding\r\n     */\r\n    function enableRefund() internal {\r\n        require(state == FundState.TeamWithdraw);\r\n        state = FundState.Refund;\r\n        token.destroy(lockedTokenAddress, token.balanceOf(lockedTokenAddress));\r\n        token.destroy(companyTokenWallet, token.balanceOf(companyTokenWallet));\r\n        token.destroy(reserveTokenWallet, token.balanceOf(reserveTokenWallet));\r\n        token.destroy(foundationTokenWallet, token.balanceOf(foundationTokenWallet));\r\n        token.destroy(bountyTokenWallet, token.balanceOf(bountyTokenWallet));\r\n        token.destroy(referralTokenWallet, token.balanceOf(referralTokenWallet));\r\n        token.destroy(advisorTokenWallet, token.balanceOf(advisorTokenWallet));\r\n        RefundEnabled(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Function is called by contributor to refund\r\n    * Buy user tokens for refundTokenPrice and destroy them\r\n    */\r\n    function refundTokenHolder() public {\r\n        require(state == FundState.Refund);\r\n\r\n        uint256 tokenBalance = token.balanceOf(msg.sender);\r\n        require(tokenBalance > 0);\r\n        uint256 refundAmount = safeDiv(safeMul(tokenBalance, address(this).balance), token.totalSupply());\r\n        require(refundAmount > 0);\r\n\r\n        token.destroy(msg.sender, tokenBalance);\r\n        msg.sender.transfer(refundAmount);\r\n\r\n        RefundHolder(msg.sender, refundAmount, tokenBalance, now);\r\n    }\r\n}\r\n\r\n// File: contracts/fund/IPollManagedFund.sol\r\n\r\n/**\r\n * @title IPollManagedFund\r\n * @dev Fund callbacks used by polling contracts\r\n */\r\ninterface IPollManagedFund {\r\n    /**\r\n     * @dev TapPoll callback\r\n     * @param agree True if new tap value is accepted by majority of contributors\r\n     * @param _tap New tap value\r\n     */\r\n    function onTapPollFinish(bool agree, uint256 _tap) external;\r\n\r\n    /**\r\n     * @dev RefundPoll callback\r\n     * @param agree True if contributors decided to allow refunding\r\n     */\r\n    function onRefundPollFinish(bool agree) external;\r\n}\r\n\r\n// File: contracts/poll/BasePoll.sol\r\n\r\n/**\r\n * @title BasePoll\r\n * @dev Abstract base class for polling contracts\r\n */\r\ncontract BasePoll is SafeMath {\r\n    struct Vote {\r\n        uint256 time;\r\n        uint256 weight;\r\n        bool agree;\r\n    }\r\n\r\n    uint256 public constant MAX_TOKENS_WEIGHT_DENOM = 1000;\r\n\r\n    IERC20Token public token;\r\n    address public fundAddress;\r\n\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n    bool checkTransfersAfterEnd;\r\n\r\n    uint256 public yesCounter = 0;\r\n    uint256 public noCounter = 0;\r\n    uint256 public totalVoted = 0;\r\n\r\n    bool public finalized;\r\n    mapping(address => Vote) public votesByAddress;\r\n\r\n    modifier checkTime() {\r\n        require(now >= startTime && now <= endTime);\r\n        _;\r\n    }\r\n\r\n    modifier notFinalized() {\r\n        require(!finalized);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev BasePoll constructor\r\n     * @param _tokenAddress ERC20 compatible token contract address\r\n     * @param _fundAddress Fund contract address\r\n     * @param _startTime Poll start time\r\n     * @param _endTime Poll end time\r\n     */\r\n    function BasePoll(address _tokenAddress, address _fundAddress, uint256 _startTime, uint256 _endTime, bool _checkTransfersAfterEnd) public {\r\n        require(_tokenAddress != address(0));\r\n        require(_startTime >= now && _endTime > _startTime);\r\n\r\n        token = IERC20Token(_tokenAddress);\r\n        fundAddress = _fundAddress;\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        finalized = false;\r\n        checkTransfersAfterEnd = _checkTransfersAfterEnd;\r\n    }\r\n\r\n    /**\r\n     * @dev Process user`s vote\r\n     * @param agree True if user endorses the proposal else False\r\n     */\r\n    function vote(bool agree) public checkTime {\r\n        require(votesByAddress[msg.sender].time == 0);\r\n\r\n        uint256 voiceWeight = token.balanceOf(msg.sender);\r\n        uint256 maxVoiceWeight = safeDiv(token.totalSupply(), MAX_TOKENS_WEIGHT_DENOM);\r\n        voiceWeight =  voiceWeight <= maxVoiceWeight ? voiceWeight : maxVoiceWeight;\r\n\r\n        if(agree) {\r\n            yesCounter = safeAdd(yesCounter, voiceWeight);\r\n        } else {\r\n            noCounter = safeAdd(noCounter, voiceWeight);\r\n\r\n        }\r\n\r\n        votesByAddress[msg.sender].time = now;\r\n        votesByAddress[msg.sender].weight = voiceWeight;\r\n        votesByAddress[msg.sender].agree = agree;\r\n\r\n        totalVoted = safeAdd(totalVoted, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Revoke user`s vote\r\n     */\r\n    function revokeVote() public checkTime {\r\n        require(votesByAddress[msg.sender].time > 0);\r\n\r\n        uint256 voiceWeight = votesByAddress[msg.sender].weight;\r\n        bool agree = votesByAddress[msg.sender].agree;\r\n\r\n        votesByAddress[msg.sender].time = 0;\r\n        votesByAddress[msg.sender].weight = 0;\r\n        votesByAddress[msg.sender].agree = false;\r\n\r\n        totalVoted = safeSub(totalVoted, 1);\r\n        if(agree) {\r\n            yesCounter = safeSub(yesCounter, voiceWeight);\r\n        } else {\r\n            noCounter = safeSub(noCounter, voiceWeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function is called after token transfer from user`s wallet to check and correct user`s vote\r\n     *\r\n     */\r\n    function onTokenTransfer(address tokenHolder, uint256 amount) public {\r\n        require(msg.sender == fundAddress);\r\n        if(votesByAddress[tokenHolder].time == 0) {\r\n            return;\r\n        }\r\n        if(!checkTransfersAfterEnd) {\r\n             if(finalized || (now < startTime || now > endTime)) {\r\n                 return;\r\n             }\r\n        }\r\n\r\n        if(token.balanceOf(tokenHolder) >= votesByAddress[tokenHolder].weight) {\r\n            return;\r\n        }\r\n        uint256 voiceWeight = amount;\r\n        if(amount > votesByAddress[tokenHolder].weight) {\r\n            voiceWeight = votesByAddress[tokenHolder].weight;\r\n        }\r\n\r\n        if(votesByAddress[tokenHolder].agree) {\r\n            yesCounter = safeSub(yesCounter, voiceWeight);\r\n        } else {\r\n            noCounter = safeSub(noCounter, voiceWeight);\r\n        }\r\n        votesByAddress[tokenHolder].weight = safeSub(votesByAddress[tokenHolder].weight, voiceWeight);\r\n    }\r\n\r\n    /**\r\n     * Finalize poll and call onPollFinish callback with result\r\n     */\r\n    function tryToFinalize() public notFinalized returns(bool) {\r\n        if(now < endTime) {\r\n            return false;\r\n        }\r\n        finalized = true;\r\n        onPollFinish(isSubjectApproved());\r\n        return true;\r\n    }\r\n\r\n    function isNowApproved() public view returns(bool) {\r\n        return isSubjectApproved();\r\n    }\r\n\r\n    function isSubjectApproved() internal view returns(bool) {\r\n        return yesCounter > noCounter;\r\n    }\r\n\r\n    /**\r\n     * @dev callback called after poll finalization\r\n     */\r\n    function onPollFinish(bool agree) internal;\r\n}\r\n\r\n// File: contracts/RefundPoll.sol\r\n\r\n/**\r\n * @title RefundPoll\r\n * @dev Enables fund refund mode\r\n */\r\ncontract RefundPoll is BasePoll {\r\n    uint256 public holdEndTime = 0;\r\n\r\n    /**\r\n     * RefundPoll constructor\r\n     * @param _tokenAddress ERC20 compatible token contract address\r\n     * @param _fundAddress Fund contract address\r\n     * @param _startTime Poll start time\r\n     * @param _endTime Poll end time\r\n     */\r\n    function RefundPoll(\r\n        address _tokenAddress,\r\n        address _fundAddress,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        uint256 _holdEndTime,\r\n        bool _checkTransfersAfterEnd\r\n    ) public\r\n        BasePoll(_tokenAddress, _fundAddress, _startTime, _endTime, _checkTransfersAfterEnd)\r\n    {\r\n        holdEndTime = _holdEndTime;\r\n    }\r\n\r\n    function tryToFinalize() public returns(bool) {\r\n        if(holdEndTime > 0 && holdEndTime > endTime) {\r\n            require(now >= holdEndTime);\r\n        } else {\r\n            require(now >= endTime);\r\n        }\r\n\r\n        finalized = true;\r\n        onPollFinish(isSubjectApproved());\r\n        return true;\r\n    }\r\n\r\n    function isSubjectApproved() internal view returns(bool) {\r\n        return yesCounter > noCounter && yesCounter >= safeDiv(token.totalSupply(), 3);\r\n    }\r\n\r\n    function onPollFinish(bool agree) internal {\r\n        IPollManagedFund fund = IPollManagedFund(fundAddress);\r\n        fund.onRefundPollFinish(agree);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/TapPoll.sol\r\n\r\n/**\r\n * @title TapPoll\r\n * @dev Poll to increase tap amount\r\n */\r\ncontract TapPoll is BasePoll {\r\n    uint256 public tap;\r\n    uint256 public minTokensPerc = 0;\r\n\r\n    /**\r\n     * TapPoll constructor\r\n     * @param _tap New tap value\r\n     * @param _tokenAddress ERC20 compatible token contract address\r\n     * @param _fundAddress Fund contract address\r\n     * @param _startTime Poll start time\r\n     * @param _endTime Poll end time\r\n     * @param _minTokensPerc - Min percent of tokens from totalSupply where poll is considered to be fulfilled\r\n     */\r\n    function TapPoll(\r\n        uint256 _tap,\r\n        address _tokenAddress,\r\n        address _fundAddress,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        uint256 _minTokensPerc\r\n    ) public\r\n        BasePoll(_tokenAddress, _fundAddress, _startTime, _endTime, false)\r\n    {\r\n        tap = _tap;\r\n        minTokensPerc = _minTokensPerc;\r\n    }\r\n\r\n    function onPollFinish(bool agree) internal {\r\n        IPollManagedFund fund = IPollManagedFund(fundAddress);\r\n        fund.onTapPollFinish(agree, tap);\r\n    }\r\n\r\n    function getVotedTokensPerc() public view returns(uint256) {\r\n        return safeDiv(safeMul(safeAdd(yesCounter, noCounter), 100), token.totalSupply());\r\n    }\r\n\r\n    function isSubjectApproved() internal view returns(bool) {\r\n        return yesCounter > noCounter && getVotedTokensPerc() >= minTokensPerc;\r\n    }\r\n}\r\n\r\n// File: contracts/PollManagedFund.sol\r\n\r\n/**\r\n * @title PollManagedFund\r\n * @dev Fund controlled by users\r\n */\r\ncontract PollManagedFund is Fund, DateTime, ITokenEventListener {\r\n    uint256 public constant TAP_POLL_DURATION = 3 days;\r\n    uint256 public constant REFUND_POLL_DURATION = 7 days;\r\n    uint256 public constant MAX_VOTED_TOKEN_PERC = 10;\r\n\r\n    TapPoll public tapPoll;\r\n    RefundPoll public refundPoll;\r\n\r\n    uint256 public minVotedTokensPerc = 0;\r\n    uint256 public secondRefundPollDate = 0;\r\n    bool public isWithdrawEnabled = true;\r\n\r\n    uint256[] public refundPollDates = [\r\n        1530403200, // 01.07.2018\r\n        1538352000, // 01.10.2018\r\n        1546300800, // 01.01.2019\r\n        1554076800, // 01.04.2019\r\n        1561939200, // 01.07.2019\r\n        1569888000, // 01.10.2019\r\n        1577836800, // 01.01.2020\r\n        1585699200  // 01.04.2020\r\n    ];\r\n\r\n    modifier onlyTokenHolder() {\r\n        require(token.balanceOf(msg.sender) > 0);\r\n        _;\r\n    }\r\n\r\n    event TapPollCreated();\r\n    event TapPollFinished(bool approved, uint256 _tap);\r\n    event RefundPollCreated();\r\n    event RefundPollFinished(bool approved);\r\n\r\n    /**\r\n     * @dev PollManagedFund constructor\r\n     * params - see Fund constructor\r\n     */\r\n    function PollManagedFund(\r\n        address _teamWallet,\r\n        address _referralTokenWallet,\r\n        address _foundationTokenWallet,\r\n        address _companyTokenWallet,\r\n        address _reserveTokenWallet,\r\n        address _bountyTokenWallet,\r\n        address _advisorTokenWallet,\r\n        address _refundManager,\r\n        address[] _owners\r\n        ) public\r\n    Fund(_teamWallet, _referralTokenWallet, _foundationTokenWallet, _companyTokenWallet, _reserveTokenWallet, _bountyTokenWallet, _advisorTokenWallet, _refundManager, _owners)\r\n    {\r\n    }\r\n\r\n    function canWithdraw() public returns(bool) {\r\n        if(\r\n            address(refundPoll) != address(0) &&\r\n            !refundPoll.finalized() &&\r\n            refundPoll.holdEndTime() > 0 &&\r\n            now >= refundPoll.holdEndTime() &&\r\n            refundPoll.isNowApproved()\r\n        ) {\r\n            return false;\r\n        }\r\n        return isWithdrawEnabled;\r\n    }\r\n\r\n    /**\r\n     * @dev ITokenEventListener implementation. Notify active poll contracts about token transfers\r\n     */\r\n    function onTokenTransfer(address _from, address /*_to*/, uint256 _value) external {\r\n        require(msg.sender == address(token));\r\n        if(address(tapPoll) != address(0) && !tapPoll.finalized()) {\r\n            tapPoll.onTokenTransfer(_from, _value);\r\n        }\r\n         if(address(refundPoll) != address(0) && !refundPoll.finalized()) {\r\n            refundPoll.onTokenTransfer(_from, _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update minVotedTokensPerc value after tap poll.\r\n     * Set new value == 50% from current voted tokens amount\r\n     */\r\n    function updateMinVotedTokens(uint256 _minVotedTokensPerc) internal {\r\n        uint256 newPerc = safeDiv(_minVotedTokensPerc, 2);\r\n        if(newPerc > MAX_VOTED_TOKEN_PERC) {\r\n            minVotedTokensPerc = MAX_VOTED_TOKEN_PERC;\r\n            return;\r\n        }\r\n        minVotedTokensPerc = newPerc;\r\n    }\r\n\r\n    // Tap poll\r\n    function createTapPoll(uint8 tapIncPerc) public onlyOwner {\r\n        require(state == FundState.TeamWithdraw);\r\n        require(tapPoll == address(0));\r\n        require(getDay(now) == 10);\r\n        require(tapIncPerc <= 50);\r\n        uint256 _tap = safeAdd(tap, safeDiv(safeMul(tap, tapIncPerc), 100));\r\n        uint256 startTime = now;\r\n        uint256 endTime = startTime + TAP_POLL_DURATION;\r\n        tapPoll = new TapPoll(_tap, token, this, startTime, endTime, minVotedTokensPerc);\r\n        TapPollCreated();\r\n    }\r\n\r\n    function onTapPollFinish(bool agree, uint256 _tap) external {\r\n        require(msg.sender == address(tapPoll) && tapPoll.finalized());\r\n        if(agree) {\r\n            tap = _tap;\r\n        }\r\n        updateMinVotedTokens(tapPoll.getVotedTokensPerc());\r\n        TapPollFinished(agree, _tap);\r\n        delete tapPoll;\r\n    }\r\n\r\n    // Refund poll\r\n    function checkRefundPollDate() internal view returns(bool) {\r\n        if(secondRefundPollDate > 0 && now >= secondRefundPollDate && now <= safeAdd(secondRefundPollDate, 1 days)) {\r\n            return true;\r\n        }\r\n\r\n        for(uint i; i < refundPollDates.length; i++) {\r\n            if(now >= refundPollDates[i] && now <= safeAdd(refundPollDates[i], 1 days)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function createRefundPoll() public onlyTokenHolder {\r\n        require(state == FundState.TeamWithdraw);\r\n        require(address(refundPoll) == address(0));\r\n        require(checkRefundPollDate());\r\n\r\n        if(secondRefundPollDate > 0 && now > safeAdd(secondRefundPollDate, 1 days)) {\r\n            secondRefundPollDate = 0;\r\n        }\r\n\r\n        uint256 startTime = now;\r\n        uint256 endTime = startTime + REFUND_POLL_DURATION;\r\n        bool isFirstRefund = secondRefundPollDate == 0;\r\n        uint256 holdEndTime = 0;\r\n\r\n        if(isFirstRefund) {\r\n            holdEndTime = toTimestamp(\r\n                getYear(startTime),\r\n                getMonth(startTime) + 1,\r\n                1\r\n            );\r\n        }\r\n        refundPoll = new RefundPoll(token, this, startTime, endTime, holdEndTime, isFirstRefund);\r\n        RefundPollCreated();\r\n    }\r\n\r\n    function onRefundPollFinish(bool agree) external {\r\n        require(msg.sender == address(refundPoll) && refundPoll.finalized());\r\n        if(agree) {\r\n            if(secondRefundPollDate > 0) {\r\n                enableRefund();\r\n            } else {\r\n                uint256 startTime = refundPoll.startTime();\r\n                secondRefundPollDate = toTimestamp(\r\n                    getYear(startTime),\r\n                    getMonth(startTime) + 2,\r\n                    1\r\n                );\r\n                isWithdrawEnabled = false;\r\n            }\r\n        } else {\r\n            secondRefundPollDate = 0;\r\n            isWithdrawEnabled = true;\r\n        }\r\n        RefundPollFinished(agree);\r\n\r\n        delete refundPoll;\r\n    }\r\n\r\n    function forceRefund() public {\r\n        require(msg.sender == refundManager);\r\n        enableRefund();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tapIncPerc\",\"type\":\"uint8\"}],\"name\":\"createTapPoll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TAP_POLL_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFUND_POLL_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"name\":\"setCrowdsaleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstWithdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agree\",\"type\":\"bool\"},{\"name\":\"_tap\",\"type\":\"uint256\"}],\"name\":\"onTapPollFinish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tap\",\"type\":\"uint256\"}],\"name\":\"decTap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableCrowdsaleRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getHour\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createRefundPoll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getWeekday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refundPollDates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"onCrowdsaleEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"},{\"name\":\"minute\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTapAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockedTokenAddress\",\"type\":\"address\"}],\"name\":\"setLockedTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minVotedTokensPerc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWithdrawEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agree\",\"type\":\"bool\"}],\"name\":\"onRefundPollFinish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getSecond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundationTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_TAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"},{\"name\":\"minute\",\"type\":\"uint8\"},{\"name\":\"second\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_VOTED_TOKEN_PERC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"isLeapYear\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"processContribution\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastWithdrawTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint256\"}],\"name\":\"leapYearsBefore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"getDaysInMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondRefundPollDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"canWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forceRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tapPoll\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundPoll\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributorAddress\",\"type\":\"address\"}],\"name\":\"autoRefundCrowdsaleContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"firstWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"}],\"name\":\"setOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundTokenHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundCrowdsaleContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_teamWallet\",\"type\":\"address\"},{\"name\":\"_referralTokenWallet\",\"type\":\"address\"},{\"name\":\"_foundationTokenWallet\",\"type\":\"address\"},{\"name\":\"_companyTokenWallet\",\"type\":\"address\"},{\"name\":\"_reserveTokenWallet\",\"type\":\"address\"},{\"name\":\"_bountyTokenWallet\",\"type\":\"address\"},{\"name\":\"_advisorTokenWallet\",\"type\":\"address\"},{\"name\":\"_refundManager\",\"type\":\"address\"},{\"name\":\"_owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TapPollCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_tap\",\"type\":\"uint256\"}],\"name\":\"TapPollFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RefundPollCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"RefundPollFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RefundContributor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RefundHolder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amountWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"initiatorAddress\",\"type\":\"address\"}],\"name\":\"RefundEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owners\",\"type\":\"address[]\"}],\"name\":\"SetOwners\",\"type\":\"event\"}]","ContractName":"PollManagedFund","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e45f9c10f3e4647ac922b0128e688e8e1f220f5f000000000000000000000000f759cae90459c72bb3668fcd8e674f9e1eb9c2c30000000000000000000000009496dbbb9bc9fd78d4735b954569a54fe2a0d9f30000000000000000000000005686508abbff20db6a582643280601ef53b58ddf000000000000000000000000a1568c501e650c83337f8119b6276c0de4aabb0f00000000000000000000000073c2d67e4181ad1926b4b47b56d3d2c198b8760400000000000000000000000011f21536f888def8c7d2c4785f3f70b3ddbca1b90000000000000000000000002d2edbfa6c22c276263dacf1252eb0611bde751d000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000010000000000000000000000005eaf0a37346ff992199fbc4480c9ccc4137d9c1f","Library":"","SwarmSource":"bzzr://933a469c477da45183c7ccef2cc51e8cce1c9f6715277e653a22eb77386679c7"}]}