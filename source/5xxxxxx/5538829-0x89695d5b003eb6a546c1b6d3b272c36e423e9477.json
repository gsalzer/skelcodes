{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\n// Make setPrivate payout any pending payouts\r\n\r\n// ERC20 Token Interface\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// ERC20 Token Implementation\r\ncontract StandardToken is Token {\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\n/*\r\n    PXLProperty is the ERC20 Cryptocurrency & Cryptocollectable\r\n    * It is a StandardToken ERC20 token and inherits all of that\r\n    * It has the Property structure and holds the Properties\r\n    * It governs the regulators (moderators, admins, root, Property DApps and PixelProperty)\r\n    * It has getters and setts for all data storage\r\n    * It selectively allows access to PXL and Properties based on caller access\r\n    \r\n    Moderation is handled inside PXLProperty, not by external DApps. It's up to other apps to respect the flags, however\r\n*/\r\ncontract PXLProperty is StandardToken {\r\n    /* Access Level Constants */\r\n    uint8 constant LEVEL_1_MODERATOR = 1;    // 1: Level 1 Moderator - nsfw-flagging power\r\n    uint8 constant LEVEL_2_MODERATOR = 2;    // 2: Level 2 Moderator - ban power + [1]\r\n    uint8 constant LEVEL_1_ADMIN = 3;        // 3: Level 1 Admin - Can manage moderator levels + [1,2]\r\n    uint8 constant LEVEL_2_ADMIN = 4;        // 4: Level 2 Admin - Can manage admin level 1 levels + [1-3]\r\n    uint8 constant LEVEL_1_ROOT = 5;         // 5: Level 1 Root - Can set property DApps level [1-4]\r\n    uint8 constant LEVEL_2_ROOT = 6;         // 6: Level 2 Root - Can set pixelPropertyContract level [1-5]\r\n    uint8 constant LEVEL_3_ROOT = 7;         // 7: Level 3 Root - Can demote/remove root, transfer root, [1-6]\r\n    uint8 constant LEVEL_PROPERTY_DAPPS = 8; // 8: Property DApps - Power over manipulating Property data\r\n    uint8 constant LEVEL_PIXEL_PROPERTY = 9; // 9: PixelProperty - Power over PXL generation & Property ownership\r\n    /* Flags Constants */\r\n    uint8 constant FLAG_NSFW = 1;\r\n    uint8 constant FLAG_BAN = 2;\r\n    \r\n    /* Accesser Addresses & Levels */\r\n    address pixelPropertyContract; // Only contract that has control over PXL creation and Property ownership\r\n    mapping (address => uint8) public regulators; // Mapping of users/contracts to their control levels\r\n    \r\n    // Mapping of PropertyID to Property\r\n    mapping (uint16 => Property) public properties;\r\n    // Property Owner's website\r\n    mapping (address => uint256[2]) public ownerWebsite;\r\n    // Property Owner's hover text\r\n    mapping (address => uint256[2]) public ownerHoverText;\r\n    \r\n    /* ### Ownable Property Structure ### */\r\n    struct Property {\r\n        uint8 flag;\r\n        bool isInPrivateMode; //Whether in private mode for owner-only use or free-use mode to be shared\r\n        address owner; //Who owns the Property. If its zero (0), then no owner and known as a \"system-Property\"\r\n        address lastUpdater; //Who last changed the color of the Property\r\n        uint256[5] colors; //10x10 rgb pixel colors per property. colors[0] is the top row, colors[9] is the bottom row\r\n        uint256 salePrice; //PXL price the owner has the Property on sale for. If zero, then its not for sale.\r\n        uint256 lastUpdate; //Timestamp of when it had its color last updated\r\n        uint256 becomePublic; //Timestamp on when to become public\r\n        uint256 earnUntil; //Timestamp on when Property token generation will stop\r\n    }\r\n    \r\n    /* ### Regulation Access Modifiers ### */\r\n    modifier regulatorAccess(uint8 accessLevel) {\r\n        require(accessLevel <= LEVEL_3_ROOT); // Only request moderator, admin or root levels forr regulatorAccess\r\n        require(regulators[msg.sender] >= accessLevel); // Users must meet requirement\r\n        if (accessLevel >= LEVEL_1_ADMIN) { //\r\n            require(regulators[msg.sender] <= LEVEL_3_ROOT); //DApps can't do Admin/Root stuff, but can set nsfw/ban flags\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier propertyDAppAccess() {\r\n        require(regulators[msg.sender] == LEVEL_PROPERTY_DAPPS || regulators[msg.sender] == LEVEL_PIXEL_PROPERTY );\r\n        _;\r\n    }\r\n    \r\n    modifier pixelPropertyAccess() {\r\n        require(regulators[msg.sender] == LEVEL_PIXEL_PROPERTY);\r\n        _;\r\n    }\r\n    \r\n    /* ### Constructor ### */\r\n    function PXLProperty() public {\r\n        regulators[msg.sender] = LEVEL_3_ROOT; // Creator set to Level 3 Root\r\n    }\r\n    \r\n    /* ### Moderator, Admin & Root Functions ### */\r\n    // Moderator Flags\r\n    function setPropertyFlag(uint16 propertyID, uint8 flag) public regulatorAccess(flag == FLAG_NSFW ? LEVEL_1_MODERATOR : LEVEL_2_MODERATOR) {\r\n        properties[propertyID].flag = flag;\r\n        if (flag == FLAG_BAN) {\r\n            require(properties[propertyID].isInPrivateMode); //Can't ban an owner's property if a public user caused the NSFW content\r\n            properties[propertyID].colors = [0, 0, 0, 0, 0];\r\n        }\r\n    }\r\n    \r\n    // Setting moderator/admin/root access\r\n    function setRegulatorAccessLevel(address user, uint8 accessLevel) public regulatorAccess(LEVEL_1_ADMIN) {\r\n        if (msg.sender != user) {\r\n            require(regulators[msg.sender] > regulators[user]); // You have to be a higher rank than the user you are changing\r\n        }\r\n        require(regulators[msg.sender] > accessLevel); // You have to be a higher rank than the role you are setting\r\n        regulators[user] = accessLevel;\r\n    }\r\n    \r\n    function setPixelPropertyContract(address newPixelPropertyContract) public regulatorAccess(LEVEL_2_ROOT) {\r\n        require(newPixelPropertyContract != 0);\r\n        if (pixelPropertyContract != 0) {\r\n            regulators[pixelPropertyContract] = 0; //If we already have a pixelPropertyContract, revoke its ownership\r\n        }\r\n        \r\n        pixelPropertyContract = newPixelPropertyContract;\r\n        regulators[newPixelPropertyContract] = LEVEL_PIXEL_PROPERTY;\r\n    }\r\n    \r\n    function setPropertyDAppContract(address propertyDAppContract, bool giveAccess) public regulatorAccess(LEVEL_1_ROOT) {\r\n        require(propertyDAppContract != 0);\r\n        regulators[propertyDAppContract] = giveAccess ? LEVEL_PROPERTY_DAPPS : 0;\r\n    }\r\n    \r\n    /* ### PropertyDapp Functions ### */\r\n    function setPropertyColors(uint16 propertyID, uint256[5] colors) public propertyDAppAccess() {\r\n        for(uint256 i = 0; i < 5; i++) {\r\n            if (properties[propertyID].colors[i] != colors[i]) {\r\n                properties[propertyID].colors[i] = colors[i];\r\n            }\r\n        }\r\n    }\r\n    \r\n    function setPropertyRowColor(uint16 propertyID, uint8 row, uint256 rowColor) public propertyDAppAccess() {\r\n        if (properties[propertyID].colors[row] != rowColor) {\r\n            properties[propertyID].colors[row] = rowColor;\r\n        }\r\n    }\r\n    \r\n    function setOwnerHoverText(address textOwner, uint256[2] hoverText) public propertyDAppAccess() {\r\n        require (textOwner != 0);\r\n        ownerHoverText[textOwner] = hoverText;\r\n    }\r\n    \r\n    function setOwnerLink(address websiteOwner, uint256[2] website) public propertyDAppAccess() {\r\n        require (websiteOwner != 0);\r\n        ownerWebsite[websiteOwner] = website;\r\n    }\r\n    \r\n    /* ### PixelProperty Property Functions ### */\r\n    function setPropertyPrivateMode(uint16 propertyID, bool isInPrivateMode) public pixelPropertyAccess() {\r\n        if (properties[propertyID].isInPrivateMode != isInPrivateMode) {\r\n            properties[propertyID].isInPrivateMode = isInPrivateMode;\r\n        }\r\n    }\r\n    \r\n    function setPropertyOwner(uint16 propertyID, address propertyOwner) public pixelPropertyAccess() {\r\n        if (properties[propertyID].owner != propertyOwner) {\r\n            properties[propertyID].owner = propertyOwner;\r\n        }\r\n    }\r\n    \r\n    function setPropertyLastUpdater(uint16 propertyID, address lastUpdater) public pixelPropertyAccess() {\r\n        if (properties[propertyID].lastUpdater != lastUpdater) {\r\n            properties[propertyID].lastUpdater = lastUpdater;\r\n        }\r\n    }\r\n    \r\n    function setPropertySalePrice(uint16 propertyID, uint256 salePrice) public pixelPropertyAccess() {\r\n        if (properties[propertyID].salePrice != salePrice) {\r\n            properties[propertyID].salePrice = salePrice;\r\n        }\r\n    }\r\n    \r\n    function setPropertyLastUpdate(uint16 propertyID, uint256 lastUpdate) public pixelPropertyAccess() {\r\n        properties[propertyID].lastUpdate = lastUpdate;\r\n    }\r\n    \r\n    function setPropertyBecomePublic(uint16 propertyID, uint256 becomePublic) public pixelPropertyAccess() {\r\n        properties[propertyID].becomePublic = becomePublic;\r\n    }\r\n    \r\n    function setPropertyEarnUntil(uint16 propertyID, uint256 earnUntil) public pixelPropertyAccess() {\r\n        properties[propertyID].earnUntil = earnUntil;\r\n    }\r\n    \r\n    function setPropertyPrivateModeEarnUntilLastUpdateBecomePublic(uint16 propertyID, bool privateMode, uint256 earnUntil, uint256 lastUpdate, uint256 becomePublic) public pixelPropertyAccess() {\r\n        if (properties[propertyID].isInPrivateMode != privateMode) {\r\n            properties[propertyID].isInPrivateMode = privateMode;\r\n        }\r\n        properties[propertyID].earnUntil = earnUntil;\r\n        properties[propertyID].lastUpdate = lastUpdate;\r\n        properties[propertyID].becomePublic = becomePublic;\r\n    }\r\n    \r\n    function setPropertyLastUpdaterLastUpdate(uint16 propertyID, address lastUpdater, uint256 lastUpdate) public pixelPropertyAccess() {\r\n        if (properties[propertyID].lastUpdater != lastUpdater) {\r\n            properties[propertyID].lastUpdater = lastUpdater;\r\n        }\r\n        properties[propertyID].lastUpdate = lastUpdate;\r\n    }\r\n    \r\n    function setPropertyBecomePublicEarnUntil(uint16 propertyID, uint256 becomePublic, uint256 earnUntil) public pixelPropertyAccess() {\r\n        properties[propertyID].becomePublic = becomePublic;\r\n        properties[propertyID].earnUntil = earnUntil;\r\n    }\r\n    \r\n    function setPropertyOwnerSalePricePrivateModeFlag(uint16 propertyID, address owner, uint256 salePrice, bool privateMode, uint8 flag) public pixelPropertyAccess() {\r\n        if (properties[propertyID].owner != owner) {\r\n            properties[propertyID].owner = owner;\r\n        }\r\n        if (properties[propertyID].salePrice != salePrice) {\r\n            properties[propertyID].salePrice = salePrice;\r\n        }\r\n        if (properties[propertyID].isInPrivateMode != privateMode) {\r\n            properties[propertyID].isInPrivateMode = privateMode;\r\n        }\r\n        if (properties[propertyID].flag != flag) {\r\n            properties[propertyID].flag = flag;\r\n        }\r\n    }\r\n    \r\n    function setPropertyOwnerSalePrice(uint16 propertyID, address owner, uint256 salePrice) public pixelPropertyAccess() {\r\n        if (properties[propertyID].owner != owner) {\r\n            properties[propertyID].owner = owner;\r\n        }\r\n        if (properties[propertyID].salePrice != salePrice) {\r\n            properties[propertyID].salePrice = salePrice;\r\n        }\r\n    }\r\n    \r\n    /* ### PixelProperty PXL Functions ### */\r\n    function rewardPXL(address rewardedUser, uint256 amount) public pixelPropertyAccess() {\r\n        require(rewardedUser != 0);\r\n        balances[rewardedUser] += amount;\r\n        totalSupply += amount;\r\n    }\r\n    \r\n    function burnPXL(address burningUser, uint256 amount) public pixelPropertyAccess() {\r\n        require(burningUser != 0);\r\n        require(balances[burningUser] >= amount);\r\n        balances[burningUser] -= amount;\r\n        totalSupply -= amount;\r\n    }\r\n    \r\n    function burnPXLRewardPXL(address burner, uint256 toBurn, address rewarder, uint256 toReward) public pixelPropertyAccess() {\r\n        require(balances[burner] >= toBurn);\r\n        if (toBurn > 0) {\r\n            balances[burner] -= toBurn;\r\n            totalSupply -= toBurn;\r\n        }\r\n        if (rewarder != 0) {\r\n            balances[rewarder] += toReward;\r\n            totalSupply += toReward;\r\n        }\r\n    } \r\n    \r\n    function burnPXLRewardPXLx2(address burner, uint256 toBurn, address rewarder1, uint256 toReward1, address rewarder2, uint256 toReward2) public pixelPropertyAccess() {\r\n        require(balances[burner] >= toBurn);\r\n        if (toBurn > 0) {\r\n            balances[burner] -= toBurn;\r\n            totalSupply -= toBurn;\r\n        }\r\n        if (rewarder1 != 0) {\r\n            balances[rewarder1] += toReward1;\r\n            totalSupply += toReward1;\r\n        }\r\n        if (rewarder2 != 0) {\r\n            balances[rewarder2] += toReward2;\r\n            totalSupply += toReward2;\r\n        }\r\n    } \r\n    \r\n    /* ### All Getters/Views ### */\r\n    function getOwnerHoverText(address user) public view returns(uint256[2]) {\r\n        return ownerHoverText[user];\r\n    }\r\n    \r\n    function getOwnerLink(address user) public view returns(uint256[2]) {\r\n        return ownerWebsite[user];\r\n    }\r\n    \r\n    function getPropertyFlag(uint16 propertyID) public view returns(uint8) {\r\n        return properties[propertyID].flag;\r\n    }\r\n    \r\n    function getPropertyPrivateMode(uint16 propertyID) public view returns(bool) {\r\n        return properties[propertyID].isInPrivateMode;\r\n    }\r\n    \r\n    function getPropertyOwner(uint16 propertyID) public view returns(address) {\r\n        return properties[propertyID].owner;\r\n    }\r\n    \r\n    function getPropertyLastUpdater(uint16 propertyID) public view returns(address) {\r\n        return properties[propertyID].lastUpdater;\r\n    }\r\n    \r\n    function getPropertyColors(uint16 propertyID) public view returns(uint256[5]) {\r\n        return properties[propertyID].colors;\r\n    }\r\n\r\n    function getPropertyColorsOfRow(uint16 propertyID, uint8 rowIndex) public view returns(uint256) {\r\n        require(rowIndex <= 9);\r\n        return properties[propertyID].colors[rowIndex];\r\n    }\r\n    \r\n    function getPropertySalePrice(uint16 propertyID) public view returns(uint256) {\r\n        return properties[propertyID].salePrice;\r\n    }\r\n    \r\n    function getPropertyLastUpdate(uint16 propertyID) public view returns(uint256) {\r\n        return properties[propertyID].lastUpdate;\r\n    }\r\n    \r\n    function getPropertyBecomePublic(uint16 propertyID) public view returns(uint256) {\r\n        return properties[propertyID].becomePublic;\r\n    }\r\n    \r\n    function getPropertyEarnUntil(uint16 propertyID) public view returns(uint256) {\r\n        return properties[propertyID].earnUntil;\r\n    }\r\n    \r\n    function getRegulatorLevel(address user) public view returns(uint8) {\r\n        return regulators[user];\r\n    }\r\n    \r\n    // Gets the (owners address, Ethereum sale price, PXL sale price, last update timestamp, whether its in private mode or not, when it becomes public timestamp, flag) for a Property\r\n    function getPropertyData(uint16 propertyID, uint256 systemSalePriceETH, uint256 systemSalePricePXL) public view returns(address, uint256, uint256, uint256, bool, uint256, uint8) {\r\n        Property memory property = properties[propertyID];\r\n        bool isInPrivateMode = property.isInPrivateMode;\r\n        //If it's in private, but it has expired and should be public, set our bool to be public\r\n        if (isInPrivateMode && property.becomePublic <= now) { \r\n            isInPrivateMode = false;\r\n        }\r\n        if (properties[propertyID].owner == 0) {\r\n            return (0, systemSalePriceETH, systemSalePricePXL, property.lastUpdate, isInPrivateMode, property.becomePublic, property.flag);\r\n        } else {\r\n            return (property.owner, 0, property.salePrice, property.lastUpdate, isInPrivateMode, property.becomePublic, property.flag);\r\n        }\r\n    }\r\n    \r\n    function getPropertyPrivateModeBecomePublic(uint16 propertyID) public view returns (bool, uint256) {\r\n        return (properties[propertyID].isInPrivateMode, properties[propertyID].becomePublic);\r\n    }\r\n    \r\n    function getPropertyLastUpdaterBecomePublic(uint16 propertyID) public view returns (address, uint256) {\r\n        return (properties[propertyID].lastUpdater, properties[propertyID].becomePublic);\r\n    }\r\n    \r\n    function getPropertyOwnerSalePrice(uint16 propertyID) public view returns (address, uint256) {\r\n        return (properties[propertyID].owner, properties[propertyID].salePrice);\r\n    }\r\n    \r\n    function getPropertyPrivateModeLastUpdateEarnUntil(uint16 propertyID) public view returns (bool, uint256, uint256) {\r\n        return (properties[propertyID].isInPrivateMode, properties[propertyID].lastUpdate, properties[propertyID].earnUntil);\r\n    }\r\n}\r\n\r\n// PixelProperty\r\ncontract VirtualRealEstate {\r\n    /* ### Variables ### */\r\n    // Contract owner\r\n    address owner;\r\n    PXLProperty pxlProperty;\r\n    \r\n    bool initialPropertiesReserved;\r\n    \r\n    mapping (uint16 => bool) hasBeenSet;\r\n    \r\n    // The amount in % for which a user is paid\r\n    uint8 constant USER_BUY_CUT_PERCENT = 98;\r\n    // Maximum amount of generated PXL a property can give away per minute\r\n    uint8 constant PROPERTY_GENERATES_PER_MINUTE = 1;\r\n    // The point in time when the initial grace period is over, and users get the default values based on coins burned\r\n    uint256 GRACE_PERIOD_END_TIMESTAMP;\r\n    // The amount of time required for a Property to generate tokens for payouts\r\n    uint256 constant PROPERTY_GENERATION_PAYOUT_INTERVAL = (1 minutes); //Generation amount\r\n    \r\n    uint256 ownerEth = 0; // Amount of ETH the contract owner is entitled to withdraw (only Root account can do withdraws)\r\n    \r\n    // The current system prices of ETH and PXL, for which unsold Properties are listed for sale at\r\n    uint256 systemSalePriceETH;\r\n    uint256 systemSalePricePXL;\r\n    uint8 systemPixelIncreasePercent;\r\n    uint8 systemPriceIncreaseStep;\r\n    uint16 systemETHStepTally;\r\n    uint16 systemPXLStepTally;\r\n    uint16 systemETHStepCount;\r\n    uint16 systemPXLStepCount;\r\n\r\n    /* ### Events ### */\r\n    event PropertyColorUpdate(uint16 indexed property, uint256[5] colors, uint256 lastUpdate, address indexed lastUpdaterPayee, uint256 becomePublic, uint256 indexed rewardedCoins);\r\n    event PropertyBought(uint16 indexed property, address indexed newOwner, uint256 ethAmount, uint256 PXLAmount, uint256 timestamp, address indexed oldOwner);\r\n    event SetUserHoverText(address indexed user, uint256[2] newHoverText);\r\n    event SetUserSetLink(address indexed user, uint256[2] newLink);\r\n    event PropertySetForSale(uint16 indexed property, uint256 forSalePrice);\r\n    event DelistProperty(uint16 indexed property);\r\n    event SetPropertyPublic(uint16 indexed property);\r\n    event SetPropertyPrivate(uint16 indexed property, uint32 numMinutesPrivate, address indexed rewardedUser, uint256 indexed rewardedCoins);\r\n    event Bid(uint16 indexed property, uint256 bid, uint256 timestamp);\r\n    \r\n    /* ### MODIFIERS ### */\r\n\r\n    // Only the contract owner can call these methods\r\n    modifier ownerOnly() {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    // Can only be called on Properties referecing a valid PropertyID\r\n    modifier validPropertyID(uint16 propertyID) {\r\n        if (propertyID < 10000) {\r\n            _;\r\n        }\r\n    }\r\n    \r\n    /* ### PUBLICALLY INVOKABLE FUNCTIONS ### */\r\n    \r\n    /* CONSTRUCTOR */\r\n    function VirtualRealEstate() public {\r\n        owner = msg.sender; // Default the owner to be whichever Ethereum account created the contract\r\n        systemSalePricePXL = 1000; //Initial PXL system price\r\n        systemSalePriceETH = 19500000000000000; //Initial ETH system price\r\n        systemPriceIncreaseStep = 10;\r\n        systemPixelIncreasePercent = 5;\r\n        systemETHStepTally = 0;\r\n        systemPXLStepTally = 0;\r\n        systemETHStepCount = 1;\r\n        systemPXLStepCount = 1;\r\n        initialPropertiesReserved = false;\r\n    }\r\n    \r\n    function setPXLPropertyContract(address pxlPropertyContract) public ownerOnly() {\r\n        pxlProperty = PXLProperty(pxlPropertyContract);\r\n        if (!initialPropertiesReserved) {\r\n            uint16 xReserved = 45;\r\n            uint16 yReserved = 0;\r\n            for(uint16 x = 0; x < 10; ++x) {\r\n                uint16 propertyID = (yReserved) * 100 + (xReserved + x);\r\n                _transferProperty(propertyID, owner, 0, 0, 0, 0);\r\n            }\r\n            initialPropertiesReserved = true;\r\n            GRACE_PERIOD_END_TIMESTAMP = now + 3 days; // Extends the three \r\n        }\r\n    }\r\n\r\n    function getSaleInformation() public view ownerOnly() returns(uint8, uint8, uint16, uint16, uint16, uint16) {\r\n        return (systemPixelIncreasePercent, systemPriceIncreaseStep, systemETHStepTally, systemPXLStepTally, systemETHStepCount, systemPXLStepCount);\r\n    }\r\n    \r\n    /* USER FUNCTIONS */\r\n    \r\n    // Property owners can change their hoverText for when a user mouses over their Properties\r\n    function setHoverText(uint256[2] text) public {\r\n        pxlProperty.setOwnerHoverText(msg.sender, text);\r\n        SetUserHoverText(msg.sender, text);\r\n    }\r\n    \r\n    // Property owners can change the clickable link for when a user clicks on their Properties\r\n    function setLink(uint256[2] website) public {\r\n        pxlProperty.setOwnerLink(msg.sender, website);\r\n        SetUserSetLink(msg.sender, website);\r\n    }\r\n    \r\n    // If a Property is private which has expired, make it public\r\n    function tryForcePublic(uint16 propertyID) public validPropertyID(propertyID) { \r\n        var (isInPrivateMode, becomePublic) = pxlProperty.getPropertyPrivateModeBecomePublic(propertyID);\r\n        if (isInPrivateMode && becomePublic < now) {\r\n            pxlProperty.setPropertyPrivateMode(propertyID, false);\r\n        }\r\n    }\r\n    \r\n    // Update the 10x10 image data for a Property, triggering potential payouts if it succeeds\r\n    function setColors(uint16 propertyID, uint256[5] newColors, uint256 PXLToSpend) public validPropertyID(propertyID) returns(bool) {\r\n        uint256 projectedPayout = getProjectedPayout(propertyID);\r\n        if (_tryTriggerPayout(propertyID, PXLToSpend)) {\r\n            pxlProperty.setPropertyColors(propertyID, newColors);\r\n            var (lastUpdater, becomePublic) = pxlProperty.getPropertyLastUpdaterBecomePublic(propertyID);\r\n            PropertyColorUpdate(propertyID, newColors, now, lastUpdater, becomePublic, projectedPayout);\r\n            // The first user to set a Properties color ever is awarded extra PXL due to eating the extra GAS cost of creating the uint256[5]\r\n            if (!hasBeenSet[propertyID]) {\r\n                pxlProperty.rewardPXL(msg.sender, 25);\r\n                hasBeenSet[propertyID] = true;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //Wrapper to call setColors 4 times in one call. Reduces overhead, however still duplicate work everywhere to ensure\r\n    function setColorsX4(uint16[4] propertyIDs, uint256[20] newColors, uint256 PXLToSpendEach) public returns(bool[4]) {\r\n        bool[4] results;\r\n        for(uint256 i = 0; i < 4; i++) {\r\n            require(propertyIDs[i] < 10000);\r\n            results[i] = setColors(propertyIDs[i], [newColors[i * 5], newColors[i * 5 + 1], newColors[i * 5 + 2], newColors[i * 5 + 3], newColors[i * 5 + 4]], PXLToSpendEach);\r\n        }\r\n        return results;\r\n    }\r\n\r\n    //Wrapper to call setColors 8 times in one call. Reduces overhead, however still duplicate work everywhere to ensure\r\n    function setColorsX8(uint16[8] propertyIDs, uint256[40] newColors, uint256 PXLToSpendEach) public returns(bool[8]) {\r\n        bool[8] results;\r\n        for(uint256 i = 0; i < 8; i++) {\r\n            require(propertyIDs[i] < 10000);\r\n            results[i] = setColors(propertyIDs[i], [newColors[i * 5], newColors[i * 5 + 1], newColors[i * 5 + 2], newColors[i * 5 + 3], newColors[i * 5 + 4]], PXLToSpendEach);\r\n        }\r\n        return results;\r\n    }\r\n    \r\n    // Update a row of image data for a Property, triggering potential payouts if it succeeds\r\n    function setRowColors(uint16 propertyID, uint8 row, uint256 newColorData, uint256 PXLToSpend) public validPropertyID(propertyID) returns(bool) {\r\n        require(row < 10);\r\n        uint256 projectedPayout = getProjectedPayout(propertyID);\r\n        if (_tryTriggerPayout(propertyID, PXLToSpend)) {\r\n            pxlProperty.setPropertyRowColor(propertyID, row, newColorData);\r\n            var (lastUpdater, becomePublic) = pxlProperty.getPropertyLastUpdaterBecomePublic(propertyID);\r\n            PropertyColorUpdate(propertyID, pxlProperty.getPropertyColors(propertyID), now, lastUpdater, becomePublic, projectedPayout);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // Property owners can toggle their Properties between private mode and free-use mode\r\n    function setPropertyMode(uint16 propertyID, bool setPrivateMode, uint32 numMinutesPrivate) public validPropertyID(propertyID) {\r\n        var (propertyFlag, propertyIsInPrivateMode, propertyOwner, propertyLastUpdater, propertySalePrice, propertyLastUpdate, propertyBecomePublic, propertyEarnUntil) = pxlProperty.properties(propertyID);\r\n        \r\n        require(msg.sender == propertyOwner);\r\n        uint256 whenToBecomePublic = 0;\r\n        uint256 rewardedAmount = 0;\r\n        \r\n        if (setPrivateMode) {\r\n            //If inprivate, we can extend the duration, otherwise if becomePublic > now it means a free-use user locked it\r\n            require(propertyIsInPrivateMode || propertyBecomePublic <= now || propertyLastUpdater == msg.sender ); \r\n            require(numMinutesPrivate > 0);\r\n            require(pxlProperty.balanceOf(msg.sender) >= numMinutesPrivate);\r\n            // Determines when the Property becomes public, one payout interval per coin burned\r\n            whenToBecomePublic = (now < propertyBecomePublic ? propertyBecomePublic : now) + PROPERTY_GENERATION_PAYOUT_INTERVAL * numMinutesPrivate;\r\n\r\n            rewardedAmount = getProjectedPayout(propertyIsInPrivateMode, propertyLastUpdate, propertyEarnUntil);\r\n            if (rewardedAmount > 0 && propertyLastUpdater != 0) {\r\n                pxlProperty.burnPXLRewardPXLx2(msg.sender, numMinutesPrivate, propertyLastUpdater, rewardedAmount, msg.sender, rewardedAmount);\r\n            } else {\r\n                pxlProperty.burnPXL(msg.sender, numMinutesPrivate);\r\n            }\r\n\r\n        } else {\r\n            // If its in private mode and still has time left, reimburse them for N-1 minutes tokens back\r\n            if (propertyIsInPrivateMode && propertyBecomePublic > now) {\r\n                pxlProperty.rewardPXL(msg.sender, ((propertyBecomePublic - now) / PROPERTY_GENERATION_PAYOUT_INTERVAL) - 1);\r\n            }\r\n        }\r\n        \r\n        pxlProperty.setPropertyPrivateModeEarnUntilLastUpdateBecomePublic(propertyID, setPrivateMode, 0, 0, whenToBecomePublic);\r\n        \r\n        if (setPrivateMode) {\r\n            SetPropertyPrivate(propertyID, numMinutesPrivate, propertyLastUpdater, rewardedAmount);\r\n        } else {\r\n            SetPropertyPublic(propertyID);\r\n        }\r\n    }\r\n    // Transfer Property ownership between accounts. This has no cost, no cut and does not change flag status\r\n    function transferProperty(uint16 propertyID, address newOwner) public validPropertyID(propertyID) returns(bool) {\r\n        require(pxlProperty.getPropertyOwner(propertyID) == msg.sender);\r\n        _transferProperty(propertyID, newOwner, 0, 0, pxlProperty.getPropertyFlag(propertyID), msg.sender);\r\n        return true;\r\n    }\r\n    // Purchase a unowned system-Property in a combination of PXL and ETH\r\n    function buyProperty(uint16 propertyID, uint256 pxlValue) public validPropertyID(propertyID) payable returns(bool) {\r\n        //Must be the first purchase, otherwise do it with PXL from another user\r\n        require(pxlProperty.getPropertyOwner(propertyID) == 0);\r\n        // Must be able to afford the given PXL\r\n        require(pxlProperty.balanceOf(msg.sender) >= pxlValue);\r\n        require(pxlValue != 0);\r\n        \r\n        // Protect against underflow\r\n        require(pxlValue <= systemSalePricePXL);\r\n        uint256 pxlLeft = systemSalePricePXL - pxlValue;\r\n        uint256 ethLeft = systemSalePriceETH / systemSalePricePXL * pxlLeft;\r\n        \r\n        // Must have spent enough ETH to cover the ETH left after PXL price was subtracted\r\n        require(msg.value >= ethLeft);\r\n        \r\n        pxlProperty.burnPXLRewardPXL(msg.sender, pxlValue, owner, pxlValue);\r\n        \r\n        systemPXLStepTally += uint16(100 * pxlValue / systemSalePricePXL);\r\n        if (systemPXLStepTally >= 1000) {\r\n             systemPXLStepCount++;\r\n            systemSalePricePXL += systemSalePricePXL * 9 / systemPXLStepCount / 10;\r\n            systemPXLStepTally -= 1000;\r\n        }\r\n        \r\n        ownerEth += msg.value;\r\n\r\n        systemETHStepTally += uint16(100 * pxlLeft / systemSalePricePXL);\r\n        if (systemETHStepTally >= 1000) {\r\n            systemETHStepCount++;\r\n            systemSalePriceETH += systemSalePriceETH * 9 / systemETHStepCount / 10;\r\n            systemETHStepTally -= 1000;\r\n        }\r\n\r\n        _transferProperty(propertyID, msg.sender, msg.value, pxlValue, 0, 0);\r\n        \r\n        return true;\r\n    }\r\n    // Purchase a listed user-owner Property in PXL\r\n    function buyPropertyInPXL(uint16 propertyID, uint256 PXLValue) public validPropertyID(propertyID) {\r\n        // If Property is system-owned\r\n        var (propertyOwner, propertySalePrice) = pxlProperty.getPropertyOwnerSalePrice(propertyID);\r\n        address originalOwner = propertyOwner;\r\n        if (propertyOwner == 0) {\r\n            // Turn it into a user-owned at system price with contract owner as owner\r\n            pxlProperty.setPropertyOwnerSalePrice(propertyID, owner, systemSalePricePXL);\r\n            propertyOwner = owner;\r\n            propertySalePrice = systemSalePricePXL;\r\n            // Increase system PXL price\r\n            systemPXLStepTally += 100;\r\n            if (systemPXLStepTally >= 1000) {\r\n                systemPXLStepCount++;\r\n                systemSalePricePXL += systemSalePricePXL * 9 / systemPXLStepCount / 10;\r\n                systemPXLStepTally -= 1000;\r\n            }\r\n        }\r\n        require(propertySalePrice <= PXLValue);\r\n        uint256 amountTransfered = propertySalePrice * USER_BUY_CUT_PERCENT / 100;\r\n        pxlProperty.burnPXLRewardPXLx2(msg.sender, propertySalePrice, propertyOwner, amountTransfered, owner, (propertySalePrice - amountTransfered));        \r\n        _transferProperty(propertyID, msg.sender, 0, propertySalePrice, 0, originalOwner);\r\n    }\r\n\r\n    // Purchase a system-Property in pure ETH\r\n    function buyPropertyInETH(uint16 propertyID) public validPropertyID(propertyID) payable returns(bool) {\r\n        require(pxlProperty.getPropertyOwner(propertyID) == 0);\r\n        require(msg.value >= systemSalePriceETH);\r\n        \r\n        ownerEth += msg.value;\r\n        systemETHStepTally += 100;\r\n        if (systemETHStepTally >= 1000) {\r\n            systemETHStepCount++;\r\n            systemSalePriceETH += systemSalePriceETH * 9 / systemETHStepCount / 10;\r\n            systemETHStepTally -= 1000;\r\n        }\r\n        _transferProperty(propertyID, msg.sender, msg.value, 0, 0, 0);\r\n        return true;\r\n    }\r\n    \r\n    // Property owner lists their Property for sale at their preferred price\r\n    function listForSale(uint16 propertyID, uint256 price) public validPropertyID(propertyID) returns(bool) {\r\n        require(price != 0);\r\n        require(msg.sender == pxlProperty.getPropertyOwner(propertyID));\r\n        pxlProperty.setPropertySalePrice(propertyID, price);\r\n        PropertySetForSale(propertyID, price);\r\n        return true;\r\n    }\r\n    \r\n    // Property owner delists their Property from being for sale\r\n    function delist(uint16 propertyID) public validPropertyID(propertyID) returns(bool) {\r\n        require(msg.sender == pxlProperty.getPropertyOwner(propertyID));\r\n        pxlProperty.setPropertySalePrice(propertyID, 0);\r\n        DelistProperty(propertyID);\r\n        return true;\r\n    }\r\n\r\n    // Make a public bid and notify a Property owner of your bid. Burn 1 coin\r\n    function makeBid(uint16 propertyID, uint256 bidAmount) public validPropertyID(propertyID) {\r\n        require(bidAmount > 0);\r\n        require(pxlProperty.balanceOf(msg.sender) >= 1 + bidAmount);\r\n        Bid(propertyID, bidAmount, now);\r\n        pxlProperty.burnPXL(msg.sender, 1);\r\n    }\r\n    \r\n    /* CONTRACT OWNER FUNCTIONS */\r\n    \r\n    // Contract owner can withdraw up to ownerEth amount\r\n    function withdraw(uint256 amount) public ownerOnly() {\r\n        if (amount <= ownerEth) {\r\n            owner.transfer(amount);\r\n            ownerEth -= amount;\r\n        }\r\n    }\r\n    \r\n    // Contract owner can withdraw ownerEth amount\r\n    function withdrawAll() public ownerOnly() {\r\n        owner.transfer(ownerEth);\r\n        ownerEth = 0;\r\n    }\r\n    \r\n    // Contract owner can change who is the contract owner\r\n    function changeOwners(address newOwner) public ownerOnly() {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /* ## PRIVATE FUNCTIONS ## */\r\n    \r\n    // Function which wraps payouts for setColors\r\n    function _tryTriggerPayout(uint16 propertyID, uint256 pxlToSpend) private returns(bool) {\r\n        var (propertyFlag, propertyIsInPrivateMode, propertyOwner, propertyLastUpdater, propertySalePrice, propertyLastUpdate, propertyBecomePublic, propertyEarnUntil) = pxlProperty.properties(propertyID);\r\n        //If the Property is in private mode and expired, make it public\r\n        if (propertyIsInPrivateMode && propertyBecomePublic <= now) {\r\n            pxlProperty.setPropertyPrivateMode(propertyID, false);\r\n            propertyIsInPrivateMode = false;\r\n        }\r\n        //If its in private mode, only the owner can interact with it\r\n        if (propertyIsInPrivateMode) {\r\n            require(msg.sender == propertyOwner);\r\n            require(propertyFlag != 2);\r\n        //If if its in free-use mode\r\n        } else if (propertyBecomePublic <= now || propertyLastUpdater == msg.sender) {\r\n            uint256 pxlSpent = pxlToSpend + 1; //All pxlSpent math uses N+1, so built in for convenience\r\n            if (isInGracePeriod() && pxlToSpend < 2) { //If first 3 days and we spent <2 coins, treat it as if we spent 2\r\n                pxlSpent = 3; //We're treating it like 2, but it's N+1 in the math using this\r\n            }\r\n            \r\n            uint256 projectedAmount = getProjectedPayout(propertyIsInPrivateMode, propertyLastUpdate, propertyEarnUntil);\r\n            pxlProperty.burnPXLRewardPXLx2(msg.sender, pxlToSpend, propertyLastUpdater, projectedAmount, propertyOwner, projectedAmount);\r\n            \r\n            //BecomePublic = (N+1)/2 minutes of user-private mode\r\n            //EarnUntil = (N+1)*5 coins earned max/minutes we can earn from\r\n            pxlProperty.setPropertyBecomePublicEarnUntil(propertyID, now + (pxlSpent * PROPERTY_GENERATION_PAYOUT_INTERVAL / 2), now + (pxlSpent * 5 * PROPERTY_GENERATION_PAYOUT_INTERVAL));\r\n        } else {\r\n            return false;\r\n        }\r\n        pxlProperty.setPropertyLastUpdaterLastUpdate(propertyID, msg.sender, now);\r\n        return true;\r\n    }\r\n    // Transfer ownership of a Property and reset their info\r\n    function _transferProperty(uint16 propertyID, address newOwner, uint256 ethAmount, uint256 PXLAmount, uint8 flag, address oldOwner) private {\r\n        require(newOwner != 0);\r\n        pxlProperty.setPropertyOwnerSalePricePrivateModeFlag(propertyID, newOwner, 0, false, flag);\r\n        PropertyBought(propertyID, newOwner, ethAmount, PXLAmount, now, oldOwner);\r\n    }\r\n    \r\n    // Gets the (owners address, Ethereum sale price, PXL sale price, last update timestamp, whether its in private mode or not, when it becomes public timestamp, flag) for a Property\r\n    function getPropertyData(uint16 propertyID) public validPropertyID(propertyID) view returns(address, uint256, uint256, uint256, bool, uint256, uint32) {\r\n        return pxlProperty.getPropertyData(propertyID, systemSalePriceETH, systemSalePricePXL);\r\n    }\r\n    \r\n    // Gets the system ETH and PXL prices\r\n    function getSystemSalePrices() public view returns(uint256, uint256) {\r\n        return (systemSalePriceETH, systemSalePricePXL);\r\n    }\r\n    \r\n    // Gets the sale prices of any Property in ETH and PXL\r\n    function getForSalePrices(uint16 propertyID) public validPropertyID(propertyID) view returns(uint256, uint256) {\r\n        if (pxlProperty.getPropertyOwner(propertyID) == 0) {\r\n            return getSystemSalePrices();\r\n        } else {\r\n            return (0, pxlProperty.getPropertySalePrice(propertyID));\r\n        }\r\n    }\r\n    \r\n    // Gets the projected sale price for a property should it be triggered at this very moment\r\n    function getProjectedPayout(uint16 propertyID) public view returns(uint256) {\r\n        var (propertyIsInPrivateMode, propertyLastUpdate, propertyEarnUntil) = pxlProperty.getPropertyPrivateModeLastUpdateEarnUntil(propertyID);\r\n        return getProjectedPayout(propertyIsInPrivateMode, propertyLastUpdate, propertyEarnUntil);\r\n    }\r\n    \r\n    function getProjectedPayout(bool propertyIsInPrivateMode, uint256 propertyLastUpdate, uint256 propertyEarnUntil) public view returns(uint256) {\r\n        if (!propertyIsInPrivateMode && propertyLastUpdate != 0) {\r\n            uint256 earnedUntil = (now < propertyEarnUntil) ? now : propertyEarnUntil;\r\n            uint256 minutesSinceLastColourChange = (earnedUntil - propertyLastUpdate) / PROPERTY_GENERATION_PAYOUT_INTERVAL;\r\n            return minutesSinceLastColourChange * PROPERTY_GENERATES_PER_MINUTE;\r\n            //return (((now < propertyEarnUntil) ? now : propertyEarnUntil - propertyLastUpdate) / PROPERTY_GENERATION_PAYOUT_INTERVAL) * PROPERTY_GENERATES_PER_MINUTE; //Gave too high number wtf?\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    // Gets whether the contract is still in the intial grace period where we give extra features to color setters\r\n    function isInGracePeriod() public view returns(bool) {\r\n        return now <= GRACE_PERIOD_END_TIMESTAMP;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"}],\"name\":\"getPropertyData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"}],\"name\":\"buyPropertyInETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"},{\"name\":\"row\",\"type\":\"uint8\"},{\"name\":\"newColorData\",\"type\":\"uint256\"},{\"name\":\"PXLToSpend\",\"type\":\"uint256\"}],\"name\":\"setRowColors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"}],\"name\":\"getProjectedPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferProperty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"}],\"name\":\"tryForcePublic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"},{\"name\":\"PXLValue\",\"type\":\"uint256\"}],\"name\":\"buyPropertyInPXL\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"},{\"name\":\"newColors\",\"type\":\"uint256[5]\"},{\"name\":\"PXLToSpend\",\"type\":\"uint256\"}],\"name\":\"setColors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyIDs\",\"type\":\"uint16[8]\"},{\"name\":\"newColors\",\"type\":\"uint256[40]\"},{\"name\":\"PXLToSpendEach\",\"type\":\"uint256\"}],\"name\":\"setColorsX8\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[8]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pxlPropertyContract\",\"type\":\"address\"}],\"name\":\"setPXLPropertyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"propertyIsInPrivateMode\",\"type\":\"bool\"},{\"name\":\"propertyLastUpdate\",\"type\":\"uint256\"},{\"name\":\"propertyEarnUntil\",\"type\":\"uint256\"}],\"name\":\"getProjectedPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyIDs\",\"type\":\"uint16[4]\"},{\"name\":\"newColors\",\"type\":\"uint256[20]\"},{\"name\":\"PXLToSpendEach\",\"type\":\"uint256\"}],\"name\":\"setColorsX4\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[4]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"},{\"name\":\"setPrivateMode\",\"type\":\"bool\"},{\"name\":\"numMinutesPrivate\",\"type\":\"uint32\"}],\"name\":\"setPropertyMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSystemSalePrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"text\",\"type\":\"uint256[2]\"}],\"name\":\"setHoverText\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"},{\"name\":\"bidAmount\",\"type\":\"uint256\"}],\"name\":\"makeBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"listForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"}],\"name\":\"getForSalePrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"}],\"name\":\"delist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInGracePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"website\",\"type\":\"uint256[2]\"}],\"name\":\"setLink\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"propertyID\",\"type\":\"uint16\"},{\"name\":\"pxlValue\",\"type\":\"uint256\"}],\"name\":\"buyProperty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleInformation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"property\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"colors\",\"type\":\"uint256[5]\"},{\"indexed\":false,\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"lastUpdaterPayee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"becomePublic\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rewardedCoins\",\"type\":\"uint256\"}],\"name\":\"PropertyColorUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"property\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"PXLAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"PropertyBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newHoverText\",\"type\":\"uint256[2]\"}],\"name\":\"SetUserHoverText\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newLink\",\"type\":\"uint256[2]\"}],\"name\":\"SetUserSetLink\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"property\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"forSalePrice\",\"type\":\"uint256\"}],\"name\":\"PropertySetForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"property\",\"type\":\"uint16\"}],\"name\":\"DelistProperty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"property\",\"type\":\"uint16\"}],\"name\":\"SetPropertyPublic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"property\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"numMinutesPrivate\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"rewardedUser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"rewardedCoins\",\"type\":\"uint256\"}],\"name\":\"SetPropertyPrivate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"property\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"bid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"}]","ContractName":"VirtualRealEstate","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://51780a0fec2be618ff8d179637064c67aeb511d23c4110dad02503ce7673387c"}]}