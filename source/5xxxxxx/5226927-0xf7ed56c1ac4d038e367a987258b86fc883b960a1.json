{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    \r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title EjectableOwnable\r\n * @dev The EjectableOwnable contract provides the function to remove the ownership of the contract.\r\n */\r\ncontract EjectableOwnable is Ownable {\r\n    \r\n    /**\r\n     * @dev Remove the ownership by setting the owner address to null, \r\n     * after calling this function, all onlyOwner function will be be able to be called by anyone anymore, \r\n     * the contract will achieve truly decentralisation.\r\n    */\r\n    function removeOwnership() onlyOwner public {\r\n        owner = 0x0;\r\n    }\r\n    \r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    \r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n  \r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n}\r\n\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments. Inherit from this\r\n * contract and use asyncSend instead of send.\r\n */\r\ncontract PullPayment {\r\n    \r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public payments;\r\n  uint256 public totalPayments;\r\n\r\n  /**\r\n   * @dev withdraw accumulated balance, called by payee.\r\n   */\r\n  function withdrawPayments() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n\r\n    require(payment != 0);\r\n    require(this.balance >= payment);\r\n\r\n    totalPayments = totalPayments.sub(payment);\r\n    payments[payee] = 0;\r\n\r\n    assert(payee.send(payment));\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n   * @param dest The destination address of the funds.\r\n   * @param amount The amount to transfer.\r\n   */\r\n  function asyncSend(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n    totalPayments = totalPayments.add(amount);\r\n  }\r\n  \r\n}\r\n\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n  \r\n}\r\n\r\n\r\ncontract EDStructs {\r\n    \r\n    /**\r\n     * @dev The main Dungeon struct. Every dungeon in the game is represented by this structure.\r\n     * A dungeon is consists of an unlimited number of floors for your heroes to challenge, \r\n     * the power level of a dungeon is encoded in the floorGenes. Some dungeons are in fact more \"challenging\" than others,\r\n     * the secret formula for that is left for user to find out.\r\n     * \r\n     * Each dungeon also has a \"training area\", heroes can perform trainings and upgrade their stat,\r\n     * and some dungeons are more effective in the training, which is also a secret formula!\r\n     * \r\n     * When player challenge or do training in a dungeon, the fee will be collected as the dungeon rewards,\r\n     * which will be rewarded to the player who successfully challenged the current floor.\r\n     * \r\n     * Each dungeon fits in fits into three 256-bit words.\r\n     */\r\n    struct Dungeon {\r\n        \r\n        // Each dungeon has an ID which is the index in the storage array.\r\n\r\n        // The timestamp of the block when this dungeon is created.\r\n        uint32 creationTime;\r\n        \r\n        // The status of the dungeon, each dungeon can have 5 status, namely:\r\n        // 0: Active | 1: Transport Only | 2: Challenge Only | 3: Train Only | 4: InActive\r\n        uint8 status;\r\n        \r\n        // The dungeon's difficulty, the higher the difficulty, \r\n        // normally, the \"rarer\" the seedGenes, the higher the diffculty,\r\n        // and the higher the contribution fee it is to challenge, train, and transport to the dungeon,\r\n        // the formula for the contribution fee is in DungeonChallenge and DungeonTraining contracts.\r\n        // A dungeon's difficulty never change.\r\n        uint8 difficulty;\r\n        \r\n        // The dungeon's capacity, maximum number of players allowed to stay on this dungeon.\r\n        // The capacity of the newbie dungeon (Holyland) is set at 0 (which is infinity).\r\n        // Using 16-bit unsigned integers can have a maximum of 65535 in capacity.\r\n        // A dungeon's capacity never change.\r\n        uint16 capacity;\r\n        \r\n        // The current floor number, a dungeon is consists of an umlimited number of floors,\r\n        // when there is heroes successfully challenged a floor, the next floor will be\r\n        // automatically generated. Using 32-bit unsigned integer can have a maximum of 4 billion floors.\r\n        uint32 floorNumber;\r\n        \r\n        // The timestamp of the block when the current floor is generated.\r\n        uint32 floorCreationTime;\r\n        \r\n        // Current accumulated rewards, successful challenger will get a large proportion of it.\r\n        uint128 rewards;\r\n        \r\n        // The seed genes of the dungeon, it is used as the base gene for first floor, \r\n        // some dungeons are rarer and some are more common, the exact details are, \r\n        // of course, top secret of the game! \r\n        // A dungeon's seedGenes never change.\r\n        uint seedGenes;\r\n        \r\n        // The genes for current floor, it encodes the difficulty level of the current floor.\r\n        // We considered whether to store the entire array of genes for all floors, but\r\n        // in order to save some precious gas we're willing to sacrifice some functionalities with that.\r\n        uint floorGenes;\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @dev The main Hero struct. Every hero in the game is represented by this structure.\r\n     */\r\n    struct Hero {\r\n\r\n        // Each hero has an ID which is the index in the storage array.\r\n        \r\n        // The timestamp of the block when this dungeon is created.\r\n        uint64 creationTime;\r\n        \r\n        // The timestamp of the block where a challenge is performed, used to calculate when a hero is allowed to engage in another challenge.\r\n        uint64 cooldownStartTime;\r\n        \r\n        // Every time a hero challenge a dungeon, its cooldown index will be incremented by one.\r\n        uint32 cooldownIndex;\r\n        \r\n        // The seed of the hero, the gene encodes the power level of the hero.\r\n        // This is another top secret of the game! Hero's gene can be upgraded via\r\n        // training in a dungeon.\r\n        uint genes;\r\n        \r\n    }\r\n    \r\n}\r\n\r\n\r\n/**\r\n * @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens.\r\n */\r\ncontract ERC721 {\r\n    \r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint indexed tokenId);\r\n    \r\n    // ERC20 compatible functions.\r\n    // function name() public constant returns (string);\r\n    // function symbol() public constant returns (string);\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address _owner) public view returns (uint);\r\n    \r\n    // Functions that define ownership.\r\n    function ownerOf(uint _tokenId) external view returns (address);\r\n    function transfer(address _to, uint _tokenId) external;\r\n    \r\n    // Approval related functions, mainly used in auction contracts.\r\n    function approve(address _to, uint _tokenId) external;\r\n    function approvedFor(uint _tokenId) external view returns (address);\r\n    function transferFrom(address _from, address _to, uint _tokenId) external;\r\n    \r\n    /**\r\n     * @dev Each non-fungible token owner can own more than one token at one time. \r\n     * Because each token is referenced by its unique ID, however, \r\n     * it can get difficult to keep track of the individual tokens that a user may own. \r\n     * To do this, the contract keeps a record of the IDs of each token that each user owns.\r\n     */\r\n    mapping(address => uint[]) public ownerTokens;\r\n\r\n}\r\n\r\n\r\ncontract DungeonTokenInterface is ERC721, EDStructs {\r\n\r\n    /**\r\n     * @notice Limits the number of dungeons the contract owner can ever create.\r\n     */\r\n    uint public constant DUNGEON_CREATION_LIMIT = 1024;\r\n    \r\n    /**\r\n     * @dev Name of token.\r\n     */\r\n    string public constant name = \"Dungeon\";\r\n    \r\n    /**\r\n     * @dev Symbol of token.\r\n     */\r\n    string public constant symbol = \"DUNG\";\r\n    \r\n    /**\r\n     * @dev An array containing the Dungeon struct, which contains all the dungeons in existance.\r\n     *  The ID for each dungeon is the index of this array.\r\n     */ \r\n    Dungeon[] public dungeons;\r\n\r\n    /**\r\n     * @dev The external function that creates a new dungeon and stores it, only contract owners\r\n     *  can create new token, and will be restricted by the DUNGEON_CREATION_LIMIT.\r\n     *  Will generate a Mint event, a  NewDungeonFloor event, and a Transfer event.\r\n     */ \r\n    function createDungeon(uint _difficulty, uint _capacity, uint _floorNumber, uint _seedGenes, uint _floorGenes, address _owner) external returns (uint);\r\n    \r\n    /**\r\n     * @dev The external function to set dungeon status by its ID, \r\n     *  refer to DungeonStructs for more information about dungeon status.\r\n     *  Only contract owners can alter dungeon state.\r\n     */ \r\n    function setDungeonStatus(uint _id, uint _newStatus) external;\r\n    \r\n    /**\r\n     * @dev The external function to add additional dungeon rewards by its ID, \r\n     *  only contract owners can alter dungeon state.\r\n     */ \r\n    function addDungeonRewards(uint _id, uint _additinalRewards) external;\r\n    \r\n    /**\r\n     * @dev The external function to add another dungeon floor by its ID, \r\n     *  only contract owners can alter dungeon state.\r\n     */ \r\n    function addDungeonNewFloor(uint _id, uint _newRewards, uint _newFloorGenes) external;\r\n    \r\n}\r\n\r\n\r\ncontract HeroTokenInterface is ERC721, EDStructs {\r\n    \r\n    /**\r\n     * @dev Name of token.\r\n     */\r\n    string public constant name = \"Hero\";\r\n    \r\n    /**\r\n     * @dev Symbol of token.\r\n     */\r\n    string public constant symbol = \"HERO\";\r\n\r\n    /**\r\n     * @dev An array containing the Hero struct, which contains all the heroes in existance.\r\n     *  The ID for each hero is the index of this array.\r\n     */ \r\n    Hero[] public heroes;\r\n\r\n    /**\r\n     * @dev An external function that creates a new hero and stores it,\r\n     *  only contract owners can create new token.\r\n     *  method doesn't do any checking and should only be called when the\r\n     *  input data is known to be valid.\r\n     * @param _genes The gene of the new hero.\r\n     * @param _owner The inital owner of this hero.\r\n     * @return The hero ID of the new hero.\r\n     */\r\n    function createHero(uint _genes, address _owner) external returns (uint);\r\n    \r\n    /**\r\n     * @dev The external function to set the hero genes by its ID, \r\n     *  only contract owners can alter hero state.\r\n     */ \r\n    function setHeroGenes(uint _id, uint _newGenes) external;\r\n\r\n    /**\r\n     * @dev Set the cooldownStartTime for the given hero. Also increments the cooldownIndex.\r\n     */\r\n    function triggerCooldown(uint _id) external;\r\n    \r\n}\r\n\r\n\r\n/**\r\n * SECRET\r\n */\r\ncontract ChallengeFormulaInterface {\r\n    \r\n    /**\r\n     * @dev given genes of current floor and dungeon seed, return a genetic combination - may have a random factor.\r\n     * @param _floorGenes Genes of floor.\r\n     * @param _seedGenes Seed genes of dungeon.\r\n     * @return The resulting genes.\r\n     */\r\n    function calculateResult(uint _floorGenes, uint _seedGenes) external returns (uint);\r\n    \r\n}\r\n\r\n\r\n/**\r\n * SECRET\r\n */\r\ncontract TrainingFormulaInterface {\r\n    \r\n    /**\r\n     * @dev given genes of hero and current floor, return a genetic combination - may have a random factor.\r\n     * @param _heroGenes Genes of hero.\r\n     * @param _floorGenes Genes of current floor.\r\n     * @param _equipmentId Equipment index to train for, 0 is train all attributes.\r\n     * @return The resulting genes.\r\n     */\r\n    function calculateResult(uint _heroGenes, uint _floorGenes, uint _equipmentId) external returns (uint);\r\n    \r\n}\r\n\r\n\r\n/**\r\n * @title EDBase\r\n * @dev Base contract for Ether Dungeon. It implements all necessary sub-classes,\r\n *  holds all the contracts, constants, game settings, storage variables, events, and some commonly used functions.\r\n */\r\ncontract EDBase is EjectableOwnable, Pausable, PullPayment, EDStructs {\r\n    \r\n    /* ======== CONTRACTS ======== */\r\n    \r\n    /// @dev The address of the ERC721 token contract managing all Dungeon tokens.\r\n    DungeonTokenInterface public dungeonTokenContract;\r\n    \r\n    /// @dev The address of the ERC721 token contract managing all Hero tokens.\r\n    HeroTokenInterface public heroTokenContract;\r\n    \r\n    /// @dev The address of the ChallengeFormula contract that handles the floor generation mechanics after challenge success.\r\n    ChallengeFormulaInterface challengeFormulaContract;\r\n    \r\n    /// @dev The address of the TrainingFormula contract that handles the hero training mechanics.\r\n    TrainingFormulaInterface trainingFormulaContract;\r\n    \r\n    \r\n    /* ======== CONSTANTS / GAME SETTINGS (all variables are set to constant in order to save gas) ======== */\r\n    \r\n    // 1 finney = 0.001 ether\r\n    // 1 szabo = 0.001 finney\r\n    \r\n    /// @dev Super Hero (full set of same-themed Rare Equipments, there are 8 in total)\r\n    uint public constant SUPER_HERO_MULTIPLIER = 32;\r\n    \r\n    /// @dev Ultra Hero (full set of same-themed Epic Equipments, there are 4 in total)\r\n    uint public constant ULTRA_HERO_MULTIPLIER = 64;\r\n    \r\n    /**\r\n     * @dev Mega Hero (full set of same-themed Legendary Equipments, there are 2 in total)\r\n     *  There are also 2 Ultimate Hero/Demon, Pangu and Chaos, which will use the MEGA_HERO_MULTIPLIER.\r\n     */\r\n    uint public constant MEGA_HERO_MULTIPLIER = 96;\r\n    \r\n    /// @dev The fee for recruiting a hero. The payment is accumulated to the rewards of the origin dungeon.\r\n    uint public recruitHeroFee = 2 finney;\r\n    \r\n    /**\r\n     * @dev The actual fee contribution required to call transport() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty of destination dungeon. The payment is accumulated to the rewards of the origin dungeon,\r\n     *  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n     */\r\n    uint public transportationFeeMultiplier = 250 szabo;\r\n    \r\n    ///@dev All hero starts in the novice dungeon, also hero can only be recruited in novice dungoen.\r\n    uint public noviceDungeonId = 31; // < dungeon ID 31 = Abyss\r\n    \r\n    /// @dev Amount of faith required to claim a portion of the grandConsolationRewards.\r\n    uint public consolationRewardsRequiredFaith = 100;\r\n    \r\n    /// @dev The percentage for which when a player can get from the grandConsolationRewards when meeting the faith requirement.\r\n    uint public consolationRewardsClaimPercent = 50;\r\n    \r\n    /**\r\n     * @dev The actual fee contribution required to call challenge() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty. The payment is accumulated to the dungeon rewards, \r\n     *  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n     */\r\n    uint public constant challengeFeeMultiplier = 1 finney;\r\n    \r\n    /**\r\n     * @dev The percentage for which successful challenger be rewarded of the dungeons' accumulated rewards.\r\n     *  The remaining rewards subtract dungeon master rewards and consolation rewards will be used as the base rewards for new floor.\r\n     */\r\n    uint public constant challengeRewardsPercent = 45;\r\n    \r\n    /**\r\n     * @dev The developer fee for dungeon master (owner of the dungeon token).\r\n     *  Note that when Ether Dungeon becomes truly decentralised, contract ownership will be ejected,\r\n     *  and the master rewards will be rewarded to the dungeon owner (Dungeon Masters).\r\n     */\r\n    uint public constant masterRewardsPercent = 8;\r\n    \r\n    /// @dev The percentage for which the challenge rewards is added to the grandConsolationRewards.\r\n    uint public consolationRewardsPercent = 2;\r\n    \r\n    /// @dev The preparation time period where a new dungeon is created, before it can be challenged.\r\n    uint public dungeonPreparationTime = 60 minutes;\r\n    \r\n    /// @dev The challenge rewards percentage used right after the preparation period.\r\n    uint public constant rushTimeChallengeRewardsPercent = 22;\r\n    \r\n    /// @dev The number of floor in which the rushTimeChallengeRewardsPercent be applied.\r\n    uint public constant rushTimeFloorCount = 30;\r\n    \r\n    /**\r\n     * @dev The actual fee contribution required to call trainX() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty, times training times. The payment is accumulated to the dungeon rewards, \r\n     *  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n     */\r\n    uint public trainingFeeMultiplier = 2 finney;\r\n    \r\n    /**\r\n     * @dev The actual fee contribution required to call trainEquipment() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty. The payment is accumulated to the dungeon rewards.\r\n     *  (No preparation period discount on equipment training.)\r\n     */\r\n    uint public equipmentTrainingFeeMultiplier = 8 finney;\r\n    \r\n    /// @dev The discounted training fee multiplier to be used during preparation period.\r\n    uint public constant preparationPeriodTrainingFeeMultiplier = 1600 szabo;\r\n    \r\n    /// @dev The discounted equipment training fee multiplier to be used during preparation period.\r\n    uint public constant preparationPeriodEquipmentTrainingFeeMultiplier = 6400 szabo;\r\n    \r\n    \r\n    /* ======== STATE VARIABLES ======== */\r\n    \r\n    /**\r\n     * @dev After each successful training, do not update Hero immediately to avoid exploit.\r\n     *  The hero power will be auto updated during next challenge/training for any player.\r\n     *  Or calling the setTempHeroPower() public function directly.\r\n     */\r\n    mapping(address => uint) playerToLastActionBlockNumber;\r\n    uint tempSuccessTrainingHeroId;\r\n    uint tempSuccessTrainingNewHeroGenes = 1; // value 1 is used as no pending update\r\n    \r\n    /// @dev The total accumulated consolidation jackpot / rewards amount.\r\n    uint public grandConsolationRewards = 168203010964693559; // < migrated from previous contract\r\n    \r\n    /// @dev A mapping from token IDs to the address that owns them, the value can get by getPlayerDetails.\r\n    mapping(address => uint) playerToDungeonID;\r\n    \r\n    /// @dev A mapping from player address to the player's faith value, the value can get by getPlayerDetails.\r\n    mapping(address => uint) playerToFaith;\r\n\r\n    /**\r\n     * @dev A mapping from owner address to a boolean flag of whether the player recruited the first hero.\r\n     *  Note that transferring a hero from other address do not count, the value can get by getPlayerDetails.\r\n     */\r\n    mapping(address => bool) playerToFirstHeroRecruited;\r\n\r\n    /// @dev A mapping from owner address to count of tokens that address owns, the value can get by getDungeonDetails.\r\n    mapping(uint => uint) dungeonIdToPlayerCount;\r\n    \r\n    \r\n    /* ======== EVENTS ======== */\r\n    \r\n    /// @dev The PlayerTransported event is fired when user transported to another dungeon.\r\n    event PlayerTransported(uint timestamp, address indexed playerAddress, uint indexed originDungeonId, uint indexed destinationDungeonId);\r\n    \r\n    /// @dev The DungeonChallenged event is fired when user finished a dungeon challenge.\r\n    event DungeonChallenged(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint indexed heroId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newFloorGenes, uint successRewards, uint masterRewards);\r\n  \r\n    /// @dev The DungeonChallenged event is fired when user finished a dungeon challenge.\r\n    event ConsolationRewardsClaimed(uint timestamp, address indexed playerAddress, uint consolationRewards);\r\n  \r\n    /// @dev The HeroTrained event is fired when user finished a training.\r\n    event HeroTrained(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint indexed heroId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newHeroGenes);\r\n    \r\n    \r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n    \r\n    /**\r\n     * @dev Get the attributes (equipments + stats) of a hero from its gene.\r\n     */\r\n    function getHeroAttributes(uint _genes) public pure returns (uint[]) {\r\n        uint[] memory attributes = new uint[](12);\r\n        \r\n        for (uint i = 0; i < 12; i++) {\r\n            attributes[11 - i] = _genes % 32;\r\n            _genes /= 32 ** 4;\r\n        }\r\n        \r\n        return attributes;\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate the power of a hero from its gene,\r\n     *  it calculates the equipment power, stats power, and super hero boost.\r\n     */\r\n    function getHeroPower(uint _genes, uint _dungeonDifficulty) public pure returns (\r\n        uint totalPower, \r\n        uint equipmentPower, \r\n        uint statsPower, \r\n        bool isSuper, \r\n        uint superRank,\r\n        uint superBoost\r\n    ) {\r\n        // Individual power of each equipment.\r\n        // DUPLICATE CODE with _getDungeonPower: Constant array variable is not yet implemented,\r\n        // so need to put it here in order to save gas.\r\n        uint16[32] memory EQUIPMENT_POWERS = [\r\n            1, 2, 4, 5, 16, 17, 32, 33, // [Holy] Normal Equipments\r\n            8, 16, 16, 32, 32, 48, 64, 96, // [Myth] Normal Equipments\r\n            \r\n            4, 16, 32, 64, // [Holy] Rare Equipments\r\n            32, 48, 80, 128, // [Myth] Rare Equipments\r\n            \r\n            32, 96, // [Holy] Epic Equipments\r\n            80, 192, // [Myth] Epic Equipments\r\n            \r\n            192, // [Holy] Legendary Equipments\r\n            288, // [Myth] Legendary Equipments\r\n            \r\n            // Pangu / Chaos Legendary Equipments are reserved for far future use.\r\n            // Their existence is still a mystery.\r\n            384, // [Pangu] Legendary Equipments\r\n            512 // [Chaos] Legendary Equipments\r\n        ];\r\n        \r\n        uint[] memory attributes = getHeroAttributes(_genes);\r\n        \r\n        // Calculate total equipment power.\r\n        superRank = attributes[0];\r\n        \r\n        for (uint i = 0; i < 8; i++) {\r\n            uint equipment = attributes[i];\r\n            equipmentPower += EQUIPMENT_POWERS[equipment];\r\n            \r\n            // If any equipment is of difference index, set superRank to 0.\r\n            if (superRank != equipment) {\r\n                superRank = 0;\r\n            }\r\n        }\r\n        \r\n        // Calculate total stats power.\r\n        for (uint j = 8; j < 12; j++) {\r\n            // Stat power is gene number + 1.\r\n            statsPower += attributes[j] + 1;\r\n        }\r\n        \r\n        // Calculate Super/Ultra/Mega Power Boost.\r\n        isSuper = superRank >= 16;\r\n        \r\n        if (superRank >= 28) { // Mega Hero\r\n            superBoost = (_dungeonDifficulty - 1) * MEGA_HERO_MULTIPLIER;\r\n        } else if (superRank >= 24) { // Ultra Hero\r\n            superBoost = (_dungeonDifficulty - 1) * ULTRA_HERO_MULTIPLIER;\r\n        } else if (superRank >= 16) { // Super Hero\r\n            superBoost = (_dungeonDifficulty - 1) * SUPER_HERO_MULTIPLIER;\r\n        }\r\n        \r\n        totalPower = statsPower + equipmentPower + superBoost;\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate the power of a dungeon floor.\r\n     */\r\n    function getDungeonPower(uint _genes) public pure returns (uint) {\r\n        // Individual power of each equipment.\r\n        // DUPLICATE CODE with getHeroPower\r\n        uint16[32] memory EQUIPMENT_POWERS = [\r\n            1, 2, 4, 5, 16, 17, 32, 33, // [Holy] Normal Equipments\r\n            8, 16, 16, 32, 32, 48, 64, 96, // [Myth] Normal Equipments\r\n            \r\n            4, 16, 32, 64, // [Holy] Rare Equipments\r\n            32, 48, 80, 128, // [Myth] Rare Equipments\r\n            \r\n            32, 96, // [Holy] Epic Equipments\r\n            80, 192, // [Myth] Epic Equipments\r\n            \r\n            192, // [Holy] Legendary Equipments\r\n            288, // [Myth] Legendary Equipments\r\n            \r\n            // Pangu / Chaos Legendary Equipments are reserved for far future use.\r\n            // Their existence is still a mystery.\r\n            384, // [Pangu] Legendary Equipments\r\n            512 // [Chaos] Legendary Equipments\r\n        ];\r\n        \r\n        // Calculate total dungeon power.\r\n        uint dungeonPower;\r\n        \r\n        for (uint j = 0; j < 12; j++) {\r\n            dungeonPower += EQUIPMENT_POWERS[_genes % 32];\r\n            _genes /= 32 ** 4;\r\n        }\r\n        \r\n        return dungeonPower;\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate the sum of top 5 heroes power a player owns.\r\n     *  The gas usage increased with the number of heroes a player owned, roughly 500 x hero count.\r\n     *  This is used in transport function only to calculate the required tranport fee.\r\n     */\r\n    function calculateTop5HeroesPower(address _address, uint _dungeonId) public view returns (uint) {\r\n        uint heroCount = heroTokenContract.balanceOf(_address);\r\n        \r\n        if (heroCount == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        // Get the dungeon difficulty to factor in the super power boost when calculating hero power.\r\n        uint difficulty;\r\n        (,, difficulty,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\r\n        \r\n        // Compute all hero powers for further calculation.\r\n        uint[] memory heroPowers = new uint[](heroCount);\r\n        \r\n        for (uint i = 0; i < heroCount; i++) {\r\n            uint heroId = heroTokenContract.ownerTokens(_address, i);\r\n            uint genes;\r\n            (,,, genes) = heroTokenContract.heroes(heroId);\r\n            (heroPowers[i],,,,,) = getHeroPower(genes, difficulty);\r\n        }\r\n        \r\n        // Calculate the top 5 heroes power.\r\n        uint result;\r\n        uint curMax;\r\n        uint curMaxIndex;\r\n        \r\n        for (uint j; j < 5; j++) {\r\n            for (uint k = 0; k < heroPowers.length; k++) {\r\n                if (heroPowers[k] > curMax) {\r\n                    curMax = heroPowers[k];\r\n                    curMaxIndex = k;\r\n                }\r\n            }\r\n            \r\n            result += curMax;\r\n            heroPowers[curMaxIndex] = 0;\r\n            curMax = 0;\r\n            curMaxIndex = 0;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /// @dev Set the previously temp stored upgraded hero genes. Can only be called by contract owner.\r\n    function setTempHeroPower() onlyOwner public {\r\n       _setTempHeroPower();\r\n    }\r\n    \r\n    \r\n    /* ======== SETTER FUNCTIONS ======== */\r\n    \r\n    /// @dev Set the address of the dungeon token contract.\r\n    function setDungeonTokenContract(address _newDungeonTokenContract) onlyOwner external {\r\n        dungeonTokenContract = DungeonTokenInterface(_newDungeonTokenContract);\r\n    }\r\n    \r\n    /// @dev Set the address of the hero token contract.\r\n    function setHeroTokenContract(address _newHeroTokenContract) onlyOwner external {\r\n        heroTokenContract = HeroTokenInterface(_newHeroTokenContract);\r\n    }\r\n    \r\n    /// @dev Set the address of the secret dungeon challenge formula contract.\r\n    function setChallengeFormulaContract(address _newChallengeFormulaAddress) onlyOwner external {\r\n        challengeFormulaContract = ChallengeFormulaInterface(_newChallengeFormulaAddress);\r\n    }\r\n    \r\n    /// @dev Set the address of the secret hero training formula contract.\r\n    function setTrainingFormulaContract(address _newTrainingFormulaAddress) onlyOwner external {\r\n        trainingFormulaContract = TrainingFormulaInterface(_newTrainingFormulaAddress);\r\n    }\r\n    \r\n    /// @dev Updates the fee for calling recruitHero().\r\n    function setRecruitHeroFee(uint _newRecruitHeroFee) onlyOwner external {\r\n        recruitHeroFee = _newRecruitHeroFee;\r\n    }\r\n    \r\n    /// @dev Updates the fee contribution multiplier required for calling transport().\r\n    function setTransportationFeeMultiplier(uint _newTransportationFeeMultiplier) onlyOwner external {\r\n        transportationFeeMultiplier = _newTransportationFeeMultiplier;\r\n    }\r\n    \r\n    /// @dev Updates the novice dungeon ID.\r\n    function setNoviceDungeonId(uint _newNoviceDungeonId) onlyOwner external {\r\n        noviceDungeonId = _newNoviceDungeonId;\r\n    }\r\n    \r\n    /// @dev Updates the required amount of faith to get a portion of the consolation rewards.\r\n    function setConsolationRewardsRequiredFaith(uint _newConsolationRewardsRequiredFaith) onlyOwner external {\r\n        consolationRewardsRequiredFaith = _newConsolationRewardsRequiredFaith;\r\n    }\r\n    \r\n    /// @dev Updates the percentage portion of consolation rewards a player get when meeting the faith requirement.\r\n    function setConsolationRewardsClaimPercent(uint _newConsolationRewardsClaimPercent) onlyOwner external {\r\n        consolationRewardsClaimPercent = _newConsolationRewardsClaimPercent;\r\n    }\r\n    \r\n    /// @dev Updates the consolation rewards percentage.\r\n    function setConsolationRewardsPercent(uint _newConsolationRewardsPercent) onlyOwner external {\r\n        consolationRewardsPercent = _newConsolationRewardsPercent;\r\n    }\r\n    \r\n    /// @dev Updates the challenge cooldown time.\r\n    function setDungeonPreparationTime(uint _newDungeonPreparationTime) onlyOwner external {\r\n        dungeonPreparationTime = _newDungeonPreparationTime;\r\n    }\r\n    \r\n    /// @dev Updates the fee contribution multiplier required for calling trainX().\r\n    function setTrainingFeeMultiplier(uint _newTrainingFeeMultiplier) onlyOwner external {\r\n        trainingFeeMultiplier = _newTrainingFeeMultiplier;\r\n    }\r\n\r\n    /// @dev Updates the fee contribution multiplier required for calling trainEquipment().\r\n    function setEquipmentTrainingFeeMultiplier(uint _newEquipmentTrainingFeeMultiplier) onlyOwner external {\r\n        equipmentTrainingFeeMultiplier = _newEquipmentTrainingFeeMultiplier;\r\n    }\r\n    \r\n    \r\n    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\r\n    \r\n    /**\r\n     * @dev Internal function to set the previously temp stored upgraded hero genes. \r\n     * Every challenge/training will first call this function.\r\n     */\r\n    function _setTempHeroPower() internal {\r\n        // Genes of 1 is used as no pending update.\r\n        if (tempSuccessTrainingNewHeroGenes != 1) {\r\n            // ** STORAGE UPDATE **\r\n            heroTokenContract.setHeroGenes(tempSuccessTrainingHeroId, tempSuccessTrainingNewHeroGenes);\r\n            \r\n            // Reset the variables to indicate no pending update.\r\n            tempSuccessTrainingNewHeroGenes = 1;\r\n        }\r\n    }\r\n    \r\n    \r\n    /* ======== MODIFIERS ======== */\r\n    \r\n    /**\r\n     * @dev Throws if _dungeonId is not created yet.\r\n     */\r\n    modifier dungeonExists(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract EDTransportation is EDBase {\r\n\r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n    \r\n    /// @dev Recruit a new novice hero with no attributes (gene = 0).\r\n    function recruitHero() whenNotPaused external payable returns (uint) {\r\n        // Only allow recruiting hero in the novice dungeon, or first time recruiting hero.\r\n        require(playerToDungeonID[msg.sender] == noviceDungeonId || !playerToFirstHeroRecruited[msg.sender]);\r\n        \r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        require(msg.value >= recruitHeroFee);\r\n        \r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon, \r\n        // since player can only recruit hero in the novice dungeon, rewards is added there.\r\n        dungeonTokenContract.addDungeonRewards(noviceDungeonId, recruitHeroFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - recruitHeroFee);\r\n        \r\n        // If it is the first time recruiting a hero, set the player's location to the novice dungeon.\r\n        if (!playerToFirstHeroRecruited[msg.sender]) {\r\n            // ** STORAGE UPDATE **\r\n            dungeonIdToPlayerCount[noviceDungeonId]++;\r\n            playerToDungeonID[msg.sender] = noviceDungeonId;\r\n            playerToFirstHeroRecruited[msg.sender] = true;\r\n        }\r\n        \r\n        return heroTokenContract.createHero(0, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev The main external function to call when a player transport to another dungeon.\r\n     *  Will generate a PlayerTransported event.\r\n     *  Player must have at least one hero in order to perform\r\n     */\r\n    function transport(uint _destinationDungeonId) whenNotPaused dungeonCanTransport(_destinationDungeonId) playerAllowedToTransport() external payable {\r\n        uint originDungeonId = playerToDungeonID[msg.sender];\r\n        \r\n        // Disallow transport to the same dungeon.\r\n        require(_destinationDungeonId != originDungeonId);\r\n        \r\n        // Get the dungeon details from the token contract.\r\n        uint difficulty;\r\n        (,, difficulty,,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);\r\n        \r\n        // Disallow weaker user to transport to \"difficult\" dungeon.\r\n        uint top5HeroesPower = calculateTop5HeroesPower(msg.sender, _destinationDungeonId);\r\n        require(top5HeroesPower >= difficulty * 12);\r\n        \r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        // The transportation fee is calculated by a base fee from transportationFeeMultiplier,\r\n        // plus an additional fee increased with the total power of top 5 heroes owned.\r\n        uint baseFee = difficulty * transportationFeeMultiplier;\r\n        uint additionalFee = top5HeroesPower / 64 * transportationFeeMultiplier;\r\n        uint requiredFee = baseFee + additionalFee;\r\n        require(msg.value >= requiredFee);\r\n        \r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon.\r\n        dungeonTokenContract.addDungeonRewards(originDungeonId, requiredFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - requiredFee);\r\n\r\n        _transport(originDungeonId, _destinationDungeonId);\r\n    }\r\n    \r\n    \r\n    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\r\n    \r\n    /// @dev Internal function to assigns location of a player.\r\n    function _transport(uint _originDungeonId, uint _destinationDungeonId) internal {\r\n        // ** STORAGE UPDATE **\r\n        // Update the dungeons' player count.\r\n        // Normally the player count of original dungeon will already be > 0,\r\n        // perform checking to avoid unexpected overflow\r\n        if (dungeonIdToPlayerCount[_originDungeonId] > 0) {\r\n            dungeonIdToPlayerCount[_originDungeonId]--;\r\n        }\r\n        \r\n        dungeonIdToPlayerCount[_destinationDungeonId]++;\r\n        \r\n        // ** STORAGE UPDATE **\r\n        // Update player location.\r\n        playerToDungeonID[msg.sender] = _destinationDungeonId;\r\n            \r\n        // Emit the DungeonChallenged event.\r\n        PlayerTransported(now, msg.sender, _originDungeonId, _destinationDungeonId);\r\n    }\r\n    \r\n    \r\n    /* ======== MODIFIERS ======== */\r\n    \r\n    /**\r\n     * @dev Throws if dungeon status do not allow transportation, also check for dungeon existence.\r\n     *  Also check if the capacity of the destination dungeon is reached.\r\n     */\r\n    modifier dungeonCanTransport(uint _destinationDungeonId) {\r\n        require(_destinationDungeonId < dungeonTokenContract.totalSupply());\r\n        \r\n        uint status;\r\n        uint capacity;\r\n        (, status,, capacity,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);\r\n        require(status == 0 || status == 1);\r\n        \r\n        // Check if the capacity of the destination dungeon is reached.\r\n        // Capacity 0 = Infinity\r\n        require(capacity == 0 || dungeonIdToPlayerCount[_destinationDungeonId] < capacity);\r\n        _;\r\n    }\r\n    \r\n    /// @dev Throws if player did recruit first hero yet.\r\n    modifier playerAllowedToTransport() {\r\n        // Note that we check playerToFirstHeroRecruited instead of heroTokenContract.balanceOf\r\n        // in order to prevent \"capacity attack\".\r\n        require(playerToFirstHeroRecruited[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract EDChallenge is EDTransportation {\r\n    \r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n    \r\n    /**\r\n     * @dev The main external function to call when a player challenge a dungeon,\r\n     *  it determines whether if the player successfully challenged the current floor.\r\n     *  Will generate a DungeonChallenged event.\r\n     */\r\n    function challenge(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanChallenge(_dungeonId) heroAllowedToChallenge(_heroId) external payable {\r\n        // Set the last action block number, disallow player to perform another train or challenge in the same block.\r\n        playerToLastActionBlockNumber[msg.sender] = block.number;\r\n        \r\n        // Set the previously temp stored upgraded hero genes.\r\n        _setTempHeroPower();\r\n        \r\n        // Get the dungeon details from the token contract.\r\n        uint difficulty;\r\n        uint seedGenes;\r\n        (,, difficulty,,,,, seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);\r\n        \r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        uint requiredFee = difficulty * challengeFeeMultiplier;\r\n        require(msg.value >= requiredFee);\r\n        \r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon.\r\n        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - requiredFee);\r\n        \r\n        // Split the challenge function into multiple parts because of stack too deep error.\r\n        _challengePart2(_dungeonId, difficulty, _heroId);\r\n    }\r\n    \r\n    \r\n    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\r\n    \r\n    /// @dev Compute the remaining time for which the hero can perform a challenge again.\r\n    function _computeCooldownRemainingTime(uint _heroId) internal view returns (uint) {\r\n        uint cooldownStartTime;\r\n        uint cooldownIndex;\r\n        (, cooldownStartTime, cooldownIndex,) = heroTokenContract.heroes(_heroId);\r\n        \r\n        // Cooldown period is FLOOR(challenge count / 2) ^ 2 minutes\r\n        uint cooldownPeriod = (cooldownIndex / 2) ** 2 * 1 minutes;\r\n        \r\n        if (cooldownPeriod > 100 minutes) {\r\n            cooldownPeriod = 100 minutes;\r\n        }\r\n        \r\n        uint cooldownEndTime = cooldownStartTime + cooldownPeriod;\r\n        \r\n        if (cooldownEndTime <= now) {\r\n            return 0;\r\n        } else {\r\n            return cooldownEndTime - now;\r\n        }\r\n    }\r\n    \r\n    /// @dev Split the challenge function into multiple parts because of stack too deep error.\r\n    function _challengePart2(uint _dungeonId, uint _dungeonDifficulty, uint _heroId) private {\r\n        uint floorNumber;\r\n        uint rewards;\r\n        uint floorGenes;\r\n        (,,,, floorNumber,, rewards,, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n        \r\n        // Get the hero gene.\r\n        uint heroGenes;\r\n        (,,, heroGenes) = heroTokenContract.heroes(_heroId);\r\n        \r\n        bool success = _getChallengeSuccess(heroGenes, _dungeonDifficulty, floorGenes);\r\n        \r\n        uint newFloorGenes;\r\n        uint masterRewards;\r\n        uint consolationRewards;\r\n        uint successRewards;\r\n        uint newRewards;\r\n        \r\n        // Whether a challenge is success or not is determined by a simple comparison between hero power and floor power.\r\n        if (success) {\r\n            newFloorGenes = _getNewFloorGene(_dungeonId);\r\n            \r\n            masterRewards = rewards * masterRewardsPercent / 100;\r\n            \r\n            consolationRewards = rewards * consolationRewardsPercent / 100;\r\n            \r\n            if (floorNumber < rushTimeFloorCount) { // rush time right after prepration period\r\n                successRewards = rewards * rushTimeChallengeRewardsPercent / 100;\r\n                \r\n                // The dungeon rewards for new floor as total rewards - challenge rewards - devleoper fee.\r\n                newRewards = rewards * (100 - rushTimeChallengeRewardsPercent - masterRewardsPercent - consolationRewardsPercent) / 100;\r\n            } else {\r\n                successRewards = rewards * challengeRewardsPercent / 100;\r\n                newRewards = rewards * (100 - challengeRewardsPercent - masterRewardsPercent - consolationRewardsPercent) / 100;\r\n            }\r\n            \r\n            // TRIPLE CONFIRM sanity check.\r\n            require(successRewards + masterRewards + consolationRewards + newRewards <= rewards);\r\n            \r\n            // ** STORAGE UPDATE **\r\n            // Add the consolation rewards to grandConsolationRewards.\r\n            grandConsolationRewards += consolationRewards;\r\n            \r\n            // Add new floor with the new floor genes and new rewards.\r\n            dungeonTokenContract.addDungeonNewFloor(_dungeonId, newRewards, newFloorGenes);\r\n            \r\n            // Mark the challenge rewards available to be withdrawed by the player.\r\n            asyncSend(msg.sender, successRewards);\r\n            \r\n            // Mark the master rewards available to be withdrawed by the dungeon master.\r\n            asyncSend(dungeonTokenContract.ownerOf(_dungeonId), masterRewards);\r\n        }\r\n        \r\n        // ** STORAGE UPDATE **\r\n        // Trigger the cooldown for the hero.\r\n        heroTokenContract.triggerCooldown(_heroId);\r\n            \r\n        // Emit the DungeonChallenged event.\r\n        DungeonChallenged(now, msg.sender, _dungeonId, _heroId, heroGenes, floorNumber, floorGenes, success, newFloorGenes, successRewards, masterRewards);\r\n    }\r\n    \r\n    /// @dev Split the challenge function into multiple parts because of stack too deep error.\r\n    function _getChallengeSuccess(uint _heroGenes, uint _dungeonDifficulty, uint _floorGenes) private pure returns (bool) {\r\n        // Determine if the player challenge successfuly the dungeon or not.\r\n        uint heroPower;\r\n        (heroPower,,,,,) = getHeroPower(_heroGenes, _dungeonDifficulty);\r\n        \r\n        uint floorPower = getDungeonPower(_floorGenes);\r\n        \r\n        return heroPower > floorPower;\r\n    }\r\n    \r\n    /// @dev Split the challenge function into multiple parts because of stack too deep error.\r\n    function _getNewFloorGene(uint _dungeonId) private returns (uint) {\r\n        uint seedGenes;\r\n        uint floorGenes;\r\n        (,,,,,, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n        \r\n        // Calculate the new floor gene.\r\n        uint floorPower = getDungeonPower(floorGenes);\r\n        \r\n        // Call the external closed source secret function that determines the resulting floor \"genes\".\r\n        uint newFloorGenes = challengeFormulaContract.calculateResult(floorGenes, seedGenes);\r\n        uint newFloorPower = getDungeonPower(newFloorGenes);\r\n        \r\n        // If the power decreased, rollback to the current floor genes.\r\n        if (newFloorPower < floorPower) {\r\n            newFloorGenes = floorGenes;\r\n        }\r\n        \r\n        return newFloorGenes;\r\n    }\r\n    \r\n    \r\n    /* ======== MODIFIERS ======== */\r\n    \r\n    /**\r\n     * @dev Throws if dungeon status do not allow challenge, also check for dungeon existence.\r\n     *  Also check if the user is in the dungeon.\r\n     *  Also check if the dungeon is not in preparation period.\r\n     */\r\n    modifier dungeonCanChallenge(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        \r\n        uint creationTime;\r\n        uint status;\r\n        (creationTime, status,,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\r\n        require(status == 0 || status == 2);\r\n        \r\n        // Check if the user is in the dungeon.\r\n        require(playerToDungeonID[msg.sender] == _dungeonId);\r\n        \r\n        // Check if the dungeon is not in preparation period.\r\n        require(creationTime + dungeonPreparationTime <= now);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Throws if player does not own the hero, or the hero is still in cooldown period,\r\n     *  and no pending power update.\r\n     */\r\n    modifier heroAllowedToChallenge(uint _heroId) {\r\n        // You can only challenge with your own hero.\r\n        require(heroTokenContract.ownerOf(_heroId) == msg.sender);\r\n        \r\n        // Hero must not be in cooldown period\r\n        uint cooldownRemainingTime = _computeCooldownRemainingTime(_heroId);\r\n        require(cooldownRemainingTime == 0);\r\n        \r\n        // Prevent player to perform training and challenge in the same block to avoid bot exploit.\r\n        require(block.number > playerToLastActionBlockNumber[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract EDTraining is EDChallenge {\r\n    \r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n    \r\n    /**\r\n     * @dev The external function to call when a hero train with a dungeon,\r\n     *  it determines whether whether a training is successfully, and the resulting genes.\r\n     *  Will generate a DungeonChallenged event.\r\n     */\r\n    function train1(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\r\n        _train(_dungeonId, _heroId, 0, 1);\r\n    }\r\n    \r\n    function train2(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\r\n        _train(_dungeonId, _heroId, 0, 2);\r\n    }\r\n    \r\n    function train3(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\r\n        _train(_dungeonId, _heroId, 0, 3);\r\n    }\r\n    \r\n    /**\r\n     * @dev The external function to call when a hero train a particular equipment with a dungeon,\r\n     *  it determines whether whether a training is successfully, and the resulting genes.\r\n     *  Will generate a DungeonChallenged event.\r\n     *  _equipmentIndex is the index of equipment: 0 is train all attributes, including equipments and stats.\r\n     *  1: weapon | 2: shield | 3: armor | 4: shoe | 5: helmet | 6: gloves | 7: belt | 8: shawl\r\n     */\r\n    function trainEquipment(uint _dungeonId, uint _heroId, uint _equipmentIndex) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\r\n        require(_equipmentIndex <= 8);\r\n        \r\n        _train(_dungeonId, _heroId, _equipmentIndex, 1);\r\n    }\r\n    \r\n    \r\n    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\r\n    \r\n    /**\r\n     * @dev An internal function of a hero train with dungeon,\r\n     *  it determines whether whether a training is successfully, and the resulting genes.\r\n     *  Will generate a DungeonChallenged event.\r\n     */\r\n    function _train(uint _dungeonId, uint _heroId, uint _equipmentIndex, uint _trainingTimes) private {\r\n        // Set the last action block number, disallow player to perform another train or challenge in the same block.\r\n        playerToLastActionBlockNumber[msg.sender] = block.number;\r\n        \r\n        // Set the previously temp stored upgraded hero genes.\r\n        _setTempHeroPower();\r\n        \r\n        // Get the dungeon details from the token contract.\r\n        uint creationTime;\r\n        uint difficulty;\r\n        uint floorNumber;\r\n        uint rewards;\r\n        uint seedGenes;\r\n        uint floorGenes;\r\n        (creationTime,, difficulty,, floorNumber,, rewards, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n        \r\n        // Check for _trainingTimes abnormality, we probably won't have any feature that train a hero 10 times with a single call.\r\n        require(_trainingTimes < 10);\r\n        \r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        uint requiredFee;\r\n        \r\n        // Calculate the required training fee.\r\n        if (now < creationTime + dungeonPreparationTime) {\r\n            // Apply preparation period discount. \r\n            if (_equipmentIndex > 0) { // train specific equipments\r\n                requiredFee = difficulty * preparationPeriodEquipmentTrainingFeeMultiplier * _trainingTimes;\r\n            } else { // train all attributes\r\n                requiredFee = difficulty * preparationPeriodTrainingFeeMultiplier * _trainingTimes;\r\n            }\r\n        } else {\r\n            if (_equipmentIndex > 0) { // train specific equipments\r\n                requiredFee = difficulty * equipmentTrainingFeeMultiplier * _trainingTimes;\r\n            } else { // train all attributes\r\n                requiredFee = difficulty * trainingFeeMultiplier * _trainingTimes;\r\n            }\r\n        }\r\n        \r\n        require(msg.value >= requiredFee);\r\n        \r\n        // Get the hero gene.\r\n        uint heroGenes;\r\n        (,,, heroGenes) = heroTokenContract.heroes(_heroId);\r\n        \r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon.\r\n        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - requiredFee);\r\n        \r\n        // Split the _train function into multiple parts because of stack too deep error.\r\n        _trainPart2(_dungeonId, _heroId, _equipmentIndex, _trainingTimes, difficulty, floorNumber, floorGenes, heroGenes);\r\n    }\r\n    \r\n    /// @dev Split the _train function into multiple parts because of Stack Too Deep error.\r\n    function _trainPart2(\r\n        uint _dungeonId,\r\n        uint _heroId,\r\n        uint _equipmentIndex,\r\n        uint _trainingTimes,\r\n        uint _dungeonDifficulty,\r\n        uint _floorNumber,\r\n        uint _floorGenes,\r\n        uint _heroGenes\r\n    ) private {\r\n        // Determine if the hero training is successful or not, and the resulting genes.\r\n        uint heroPower;\r\n        bool isSuper;\r\n        (heroPower,,, isSuper,,) = getHeroPower(_heroGenes, _dungeonDifficulty);\r\n        \r\n        uint newHeroGenes;\r\n        uint newHeroPower;\r\n        (newHeroGenes, newHeroPower) = _calculateNewHeroPower(_dungeonDifficulty, _heroGenes, _equipmentIndex, _trainingTimes, heroPower, isSuper, _floorGenes);\r\n\r\n        // Set the new hero genes if updated (sometimes there is no power increase during equipment forging).\r\n        if (newHeroGenes != _heroGenes) {\r\n            if (newHeroPower >= 256) {\r\n                // Do not update immediately to prevent deterministic training exploit.\r\n                tempSuccessTrainingHeroId = _heroId;\r\n                tempSuccessTrainingNewHeroGenes = newHeroGenes;\r\n            } else {\r\n                // Immediately update the genes for small power hero.\r\n                // ** STORAGE UPDATE **\r\n                heroTokenContract.setHeroGenes(_heroId, newHeroGenes);\r\n            }\r\n        }\r\n        \r\n        // Training is successful only when power increase, changing another equipment with same power is considered failure\r\n        // and faith will be given accordingly.\r\n        bool success = newHeroPower > heroPower;\r\n        \r\n        if (!success) {\r\n            // Handle training failure - consolation rewards mechanics.\r\n            _handleTrainingFailure(_equipmentIndex, _trainingTimes, _dungeonDifficulty);\r\n        }\r\n        \r\n        // Emit the HeroTrained event.\r\n        HeroTrained(now, msg.sender, _dungeonId, _heroId, _heroGenes, _floorNumber, _floorGenes, success, newHeroGenes);\r\n    }\r\n    \r\n    /// @dev Determine if the hero training is successful or not, and the resulting genes and power.\r\n    function _calculateNewHeroPower(\r\n        uint _dungeonDifficulty, \r\n        uint _heroGenes, \r\n        uint _equipmentIndex, \r\n        uint _trainingTimes, \r\n        uint _heroPower, \r\n        bool _isSuper, \r\n        uint _floorGenes\r\n    ) private returns (uint newHeroGenes, uint newHeroPower) {\r\n        newHeroGenes = _heroGenes;\r\n        newHeroPower = _heroPower;\r\n        bool newIsSuper = _isSuper;\r\n        \r\n        // Train the hero multiple times according to _trainingTimes, \r\n        // each time if the resulting power is larger, update new hero power.\r\n        for (uint i = 0; i < _trainingTimes; i++) {\r\n            // Call the external closed source secret function that determines the resulting hero \"genes\".\r\n            uint tmpHeroGenes = trainingFormulaContract.calculateResult(newHeroGenes, _floorGenes, _equipmentIndex);\r\n            \r\n            uint tmpHeroPower;\r\n            bool tmpIsSuper;\r\n            (tmpHeroPower,,, tmpIsSuper,,) = getHeroPower(tmpHeroGenes, _dungeonDifficulty);\r\n            \r\n            if (tmpHeroPower > newHeroPower) {\r\n                // Prevent Super Hero downgrade.\r\n                if (!(newIsSuper && !tmpIsSuper)) {\r\n                    newHeroGenes = tmpHeroGenes;\r\n                    newHeroPower = tmpHeroPower;\r\n                }\r\n            } else if (_equipmentIndex > 0 && tmpHeroPower == newHeroPower && tmpHeroGenes != newHeroGenes) {\r\n                // Allow Equipment Forging to replace current requipemnt with a same power equipment.\r\n                // The training is considered failed (faith will be given, but the equipment will change).\r\n                newHeroGenes = tmpHeroGenes;\r\n                newHeroPower = tmpHeroPower;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// @dev Calculate and assign the appropriate faith value to the player.\r\n    function _handleTrainingFailure(uint _equipmentIndex, uint _trainingTimes, uint _dungeonDifficulty) private {\r\n        // Failed training in a dungeon will add to player's faith value.\r\n        uint faith = playerToFaith[msg.sender];\r\n        uint faithEarned;\r\n        \r\n        if (_equipmentIndex == 0) { // Hero Training\r\n            // The faith earned is proportional to the training fee, i.e. _difficulty * _trainingTimes.\r\n            faithEarned = _dungeonDifficulty * _trainingTimes;\r\n        } else { // Equipment Forging\r\n            // Equipment Forging faith earned is only 2 times normal training, not proportional to forging fee.\r\n            faithEarned = _dungeonDifficulty * _trainingTimes * 2;\r\n        }\r\n        \r\n        uint newFaith = faith + faithEarned;\r\n        \r\n        // Hitting the required amount in faith will get a proportion of grandConsolationRewards\r\n        if (newFaith >= consolationRewardsRequiredFaith) {\r\n            uint consolationRewards = grandConsolationRewards * consolationRewardsClaimPercent / 100;\r\n            \r\n            // ** STORAGE UPDATE **\r\n            grandConsolationRewards -= consolationRewards;\r\n            \r\n            // Mark the consolation rewards available to be withdrawed by the player.\r\n            asyncSend(msg.sender, consolationRewards);\r\n            \r\n            // Reset the faith value.\r\n            newFaith -= consolationRewardsRequiredFaith;\r\n            \r\n            ConsolationRewardsClaimed(now, msg.sender, consolationRewards);\r\n        }\r\n        \r\n        // ** STORAGE UPDATE **\r\n        playerToFaith[msg.sender] = newFaith;\r\n    }\r\n    \r\n    \r\n    /* ======== MODIFIERS ======== */\r\n    \r\n    /**\r\n     * @dev Throws if dungeon status do not allow training, also check for dungeon existence.\r\n     *  Also check if the user is in the dungeon.\r\n     */\r\n    modifier dungeonCanTrain(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        uint status;\r\n        (,status,,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\r\n        require(status == 0 || status == 3);\r\n        \r\n        // Also check if the user is in the dungeon.\r\n        require(playerToDungeonID[msg.sender] == _dungeonId);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Throws if player does not own the hero, and no pending power update.\r\n     */\r\n    modifier heroAllowedToTrain(uint _heroId) {\r\n        require(heroTokenContract.ownerOf(_heroId) == msg.sender);\r\n        \r\n        // Prevent player to perform training and challenge in the same block to avoid bot exploit.\r\n        require(block.number > playerToLastActionBlockNumber[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\n\r\n/**\r\n * @title EDCoreVersion1\r\n * @dev Core Contract of Ether Dungeon.\r\n *  When Version 2 launches, EDCoreVersion2 contract will be deployed and EDCoreVersion1 will be destroyed.\r\n *  Since all dungeons and heroes are stored as tokens in external contracts, they remains immutable.\r\n */\r\ncontract EDCoreVersion1 is Destructible, EDTraining {\r\n    \r\n    /**\r\n     * Initialize the EDCore contract with all the required contract addresses.\r\n     */\r\n    function EDCoreVersion1(\r\n        address _dungeonTokenAddress,\r\n        address _heroTokenAddress,\r\n        address _challengeFormulaAddress, \r\n        address _trainingFormulaAddress\r\n    ) public payable {\r\n        dungeonTokenContract = DungeonTokenInterface(_dungeonTokenAddress);\r\n        heroTokenContract = HeroTokenInterface(_heroTokenAddress);\r\n        challengeFormulaContract = ChallengeFormulaInterface(_challengeFormulaAddress);\r\n        trainingFormulaContract = TrainingFormulaInterface(_trainingFormulaAddress);\r\n    }\r\n\r\n    \r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n    \r\n    /// @dev The external function to get all the game settings in one call.\r\n    function getGameSettings() external view returns (\r\n        uint _recruitHeroFee,\r\n        uint _transportationFeeMultiplier,\r\n        uint _noviceDungeonId,\r\n        uint _consolationRewardsRequiredFaith,\r\n        uint _challengeFeeMultiplier,\r\n        uint _dungeonPreparationTime,\r\n        uint _trainingFeeMultiplier,\r\n        uint _equipmentTrainingFeeMultiplier,\r\n        uint _preparationPeriodTrainingFeeMultiplier,\r\n        uint _preparationPeriodEquipmentTrainingFeeMultiplier\r\n    ) {\r\n        _recruitHeroFee = recruitHeroFee;\r\n        _transportationFeeMultiplier = transportationFeeMultiplier;\r\n        _noviceDungeonId = noviceDungeonId;\r\n        _consolationRewardsRequiredFaith = consolationRewardsRequiredFaith;\r\n        _challengeFeeMultiplier = challengeFeeMultiplier;\r\n        _dungeonPreparationTime = dungeonPreparationTime;\r\n        _trainingFeeMultiplier = trainingFeeMultiplier;\r\n        _equipmentTrainingFeeMultiplier = equipmentTrainingFeeMultiplier;\r\n        _preparationPeriodTrainingFeeMultiplier = preparationPeriodTrainingFeeMultiplier;\r\n        _preparationPeriodEquipmentTrainingFeeMultiplier = preparationPeriodEquipmentTrainingFeeMultiplier;\r\n    }\r\n    \r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific player by its address.\r\n     * @param _address The address of the player.\r\n     */\r\n    function getPlayerDetails(address _address) external view returns (\r\n        uint dungeonId, \r\n        uint payment, \r\n        uint dungeonCount, \r\n        uint heroCount, \r\n        uint faith,\r\n        bool firstHeroRecruited\r\n    ) {\r\n        payment = payments[_address];\r\n        dungeonCount = dungeonTokenContract.balanceOf(_address);\r\n        heroCount = heroTokenContract.balanceOf(_address);\r\n        faith = playerToFaith[_address];\r\n        firstHeroRecruited = playerToFirstHeroRecruited[_address];\r\n        \r\n        // If a player didn't recruit any hero yet, consider the player is in novice dungeon\r\n        if (firstHeroRecruited) {\r\n            dungeonId = playerToDungeonID[_address];\r\n        } else {\r\n            dungeonId = noviceDungeonId;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific dungeon by its ID.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonDetails(uint _id) external view returns (\r\n        uint creationTime, \r\n        uint status, \r\n        uint difficulty, \r\n        uint capacity, \r\n        address owner, \r\n        bool isReady, \r\n        uint playerCount\r\n    ) {\r\n        require(_id < dungeonTokenContract.totalSupply());\r\n        \r\n        // Didn't get the \"floorCreationTime\" because of Stack Too Deep error.\r\n        (creationTime, status, difficulty, capacity,,,,,) = dungeonTokenContract.dungeons(_id);\r\n        \r\n        // Dungeon is ready to be challenged (not in preparation mode).\r\n        owner = dungeonTokenContract.ownerOf(_id);\r\n        isReady = creationTime + dungeonPreparationTime <= now;\r\n        playerCount = dungeonIdToPlayerCount[_id];\r\n    }\r\n    \r\n    /**\r\n     * @dev Split floor related details out of getDungeonDetails, just to avoid Stack Too Deep error.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonFloorDetails(uint _id) external view returns (\r\n        uint floorNumber, \r\n        uint floorCreationTime, \r\n        uint rewards, \r\n        uint seedGenes, \r\n        uint floorGenes\r\n    ) {\r\n        require(_id < dungeonTokenContract.totalSupply());\r\n        \r\n        // Didn't get the \"floorCreationTime\" because of Stack Too Deep error.\r\n        (,,,, floorNumber, floorCreationTime, rewards, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_id);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific hero by its ID.\r\n     * @param _id The ID of the hero.\r\n     */\r\n    function getHeroDetails(uint _id) external view returns (\r\n        uint creationTime, \r\n        uint cooldownStartTime, \r\n        uint cooldownIndex, \r\n        uint genes, \r\n        address owner, \r\n        bool isReady, \r\n        uint cooldownRemainingTime\r\n    ) {\r\n        require(_id < heroTokenContract.totalSupply());\r\n\r\n        (creationTime, cooldownStartTime, cooldownIndex, genes) = heroTokenContract.heroes(_id);\r\n        \r\n        // Hero is ready to challenge (not in cooldown mode).\r\n        owner = heroTokenContract.ownerOf(_id);\r\n        cooldownRemainingTime = _computeCooldownRemainingTime(_id);\r\n        isReady = cooldownRemainingTime == 0;\r\n    }\r\n    \r\n    \r\n    /* ======== MIGRATION FUNCTIONS ======== */\r\n    \r\n    /**\r\n     * @dev Since the DungeonToken contract is re-deployed due to optimization.\r\n     *  We need to migrate all dungeons from Beta token contract to Version 1.\r\n     */\r\n    function migrateDungeon(uint _id, uint _playerCount) external {\r\n        // Migration will be finished before maintenance period ends, tx.origin is used within a short period only.\r\n        require(now < 1520694000 && tx.origin == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);\r\n        \r\n        dungeonIdToPlayerCount[_id] = _playerCount;\r\n    }\r\n    \r\n    /**\r\n     * @dev We need to migrate all player location from Beta token contract to Version 1.\r\n     */\r\n    function migratePlayer(address _address, uint _ownerDungeonId, uint _payment, uint _faith) external {\r\n        // Migration will be finished before maintenance period ends, tx.origin is used within a short period only.\r\n        require(now < 1520694000 && tx.origin == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);\r\n        \r\n        playerToDungeonID[_address] = _ownerDungeonId;\r\n        \r\n        if (_payment > 0) {\r\n            asyncSend(_address, _payment);\r\n        }\r\n        \r\n        if (_faith > 0) {\r\n            playerToFaith[_address] = _faith;\r\n        }\r\n        \r\n        playerToFirstHeroRecruited[_address] = true;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUPER_HERO_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRecruitHeroFee\",\"type\":\"uint256\"}],\"name\":\"setRecruitHeroFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dungeonTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rushTimeFloorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTrainingFormulaAddress\",\"type\":\"address\"}],\"name\":\"setTrainingFormulaContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDungeonDetails\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint256\"},{\"name\":\"difficulty\",\"type\":\"uint256\"},{\"name\":\"capacity\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"isReady\",\"type\":\"bool\"},{\"name\":\"playerCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_ownerDungeonId\",\"type\":\"uint256\"},{\"name\":\"_payment\",\"type\":\"uint256\"},{\"name\":\"_faith\",\"type\":\"uint256\"}],\"name\":\"migratePlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"challenge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDungeonPreparationTime\",\"type\":\"uint256\"}],\"name\":\"setDungeonPreparationTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTrainingFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setTrainingFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grandConsolationRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"train1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heroTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setTempHeroPower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTransportationFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setTransportationFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transportationFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newHeroTokenContract\",\"type\":\"address\"}],\"name\":\"setHeroTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_dungeonId\",\"type\":\"uint256\"}],\"name\":\"calculateTop5HeroesPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newConsolationRewardsRequiredFaith\",\"type\":\"uint256\"}],\"name\":\"setConsolationRewardsRequiredFaith\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameSettings\",\"outputs\":[{\"name\":\"_recruitHeroFee\",\"type\":\"uint256\"},{\"name\":\"_transportationFeeMultiplier\",\"type\":\"uint256\"},{\"name\":\"_noviceDungeonId\",\"type\":\"uint256\"},{\"name\":\"_consolationRewardsRequiredFaith\",\"type\":\"uint256\"},{\"name\":\"_challengeFeeMultiplier\",\"type\":\"uint256\"},{\"name\":\"_dungeonPreparationTime\",\"type\":\"uint256\"},{\"name\":\"_trainingFeeMultiplier\",\"type\":\"uint256\"},{\"name\":\"_equipmentTrainingFeeMultiplier\",\"type\":\"uint256\"},{\"name\":\"_preparationPeriodTrainingFeeMultiplier\",\"type\":\"uint256\"},{\"name\":\"_preparationPeriodEquipmentTrainingFeeMultiplier\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDungeonTokenContract\",\"type\":\"address\"}],\"name\":\"setDungeonTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEquipmentTrainingFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setEquipmentTrainingFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDungeonFloorDetails\",\"outputs\":[{\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"name\":\"floorCreationTime\",\"type\":\"uint256\"},{\"name\":\"rewards\",\"type\":\"uint256\"},{\"name\":\"seedGenes\",\"type\":\"uint256\"},{\"name\":\"floorGenes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noviceDungeonId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"consolationRewardsClaimPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"},{\"name\":\"_dungeonDifficulty\",\"type\":\"uint256\"}],\"name\":\"getHeroPower\",\"outputs\":[{\"name\":\"totalPower\",\"type\":\"uint256\"},{\"name\":\"equipmentPower\",\"type\":\"uint256\"},{\"name\":\"statsPower\",\"type\":\"uint256\"},{\"name\":\"isSuper\",\"type\":\"bool\"},{\"name\":\"superRank\",\"type\":\"uint256\"},{\"name\":\"superBoost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MEGA_HERO_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getHeroDetails\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"cooldownStartTime\",\"type\":\"uint256\"},{\"name\":\"cooldownIndex\",\"type\":\"uint256\"},{\"name\":\"genes\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"isReady\",\"type\":\"bool\"},{\"name\":\"cooldownRemainingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"train3\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newConsolationRewardsClaimPercent\",\"type\":\"uint256\"}],\"name\":\"setConsolationRewardsClaimPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"getDungeonPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preparationPeriodTrainingFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recruitHero\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destinationDungeonId\",\"type\":\"uint256\"}],\"name\":\"transport\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ULTRA_HERO_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"},{\"name\":\"_equipmentIndex\",\"type\":\"uint256\"}],\"name\":\"trainEquipment\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"train2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rushTimeChallengeRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trainingFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preparationPeriodEquipmentTrainingFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_playerCount\",\"type\":\"uint256\"}],\"name\":\"migrateDungeon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"consolationRewardsRequiredFaith\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"getHeroAttributes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dungeonPreparationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newNoviceDungeonId\",\"type\":\"uint256\"}],\"name\":\"setNoviceDungeonId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPlayerDetails\",\"outputs\":[{\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"name\":\"payment\",\"type\":\"uint256\"},{\"name\":\"dungeonCount\",\"type\":\"uint256\"},{\"name\":\"heroCount\",\"type\":\"uint256\"},{\"name\":\"faith\",\"type\":\"uint256\"},{\"name\":\"firstHeroRecruited\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newConsolationRewardsPercent\",\"type\":\"uint256\"}],\"name\":\"setConsolationRewardsPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeFormulaAddress\",\"type\":\"address\"}],\"name\":\"setChallengeFormulaContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"consolationRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"equipmentTrainingFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recruitHeroFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dungeonTokenAddress\",\"type\":\"address\"},{\"name\":\"_heroTokenAddress\",\"type\":\"address\"},{\"name\":\"_challengeFormulaAddress\",\"type\":\"address\"},{\"name\":\"_trainingFormulaAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"originDungeonId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"destinationDungeonId\",\"type\":\"uint256\"}],\"name\":\"PlayerTransported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"heroGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"newFloorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"successRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"masterRewards\",\"type\":\"uint256\"}],\"name\":\"DungeonChallenged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"consolationRewards\",\"type\":\"uint256\"}],\"name\":\"ConsolationRewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"heroGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"newHeroGenes\",\"type\":\"uint256\"}],\"name\":\"HeroTrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EDCoreVersion1","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c99f359f73626e475ee86caab459a4b34ae93fea000000000000000000000000ed023b117953fcfaa92150d3ebe3e987d19563ce0000000000000000000000002d022d4b57ae5dc6c278370d049d83fad93fff1c000000000000000000000000f857f8c2fd6bdd82148165eb82172cbe6dd894e6","Library":"","SwarmSource":"bzzr://4851119d6225d39fce4f1130c60b3b583e02951f3eb85c2007008504855a0a48"}]}