{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\ncontract J8TTokenConfig {\r\n    // The J8T decimals\r\n    uint8 public constant TOKEN_DECIMALS = 8;\r\n\r\n    // The J8T decimal factor to obtain luckys\r\n    uint256 public constant J8T_DECIMALS_FACTOR = 10**uint256(TOKEN_DECIMALS);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is StandardToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// @title J8T Token                                                 //\r\n// @dev ERC20 J8T Token                                             //\r\n//                                                                  //\r\n// J8T Tokens are divisible by 1e8 (100,000,000) base               //\r\n//                                                                  //\r\n// J8T are displayed using 8 decimal places of precision.           //\r\n//                                                                  //\r\n// 1 J8T is equivalent to 100000000 luckys:                         //\r\n//   100000000 == 1 * 10**8 == 1e8 == One Hundred Million luckys    //\r\n//                                                                  //\r\n// 1,5 Billion J8T (total supply) is equivalent to:                 //\r\n//   150000000000000000 == 1500000000 * 10**8 == 1,5e17 luckys      //\r\n//                                                                  //\r\n//////////////////////////////////////////////////////////////////////\r\n\r\ncontract J8TToken is J8TTokenConfig, BurnableToken, Ownable {\r\n    string public constant name            = \"J8T Token\";\r\n    string public constant symbol          = \"J8T\";\r\n    uint256 public constant decimals       = TOKEN_DECIMALS;\r\n    uint256 public constant INITIAL_SUPPLY = 1500000000 * (10 ** uint256(decimals));\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    function J8TToken() {\r\n        totalSupply = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n\r\n        //https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\r\n        //EIP 20: A token contract which creates new tokens SHOULD trigger a\r\n        //Transfer event with the _from address set to 0x0\r\n        //when tokens are created.\r\n        Transfer(0x0, msg.sender, INITIAL_SUPPLY);\r\n     }\r\n}\r\n\r\n\r\ncontract ACLManaged is Ownable {\r\n    \r\n    ///////////////////////////\r\n    // ACLManaged PROPERTIES //\r\n    ///////////////////////////\r\n\r\n    // The operational acl address\r\n    address public opsAddress;\r\n\r\n    // The admin acl address\r\n    address public adminAddress;\r\n\r\n    ////////////////////////////////////////\r\n    // ACLManaged FUNCTIONS and MODIFIERS //\r\n    ////////////////////////////////////////\r\n\r\n    function ACLManaged() public Ownable() {}\r\n\r\n    // Updates the opsAddress propety with the new _opsAddress value\r\n    function setOpsAddress(address _opsAddress) external onlyOwner returns (bool) {\r\n        require(_opsAddress != address(0));\r\n        require(_opsAddress != address(this));\r\n\r\n        opsAddress = _opsAddress;\r\n        return true;\r\n    }\r\n\r\n    // Updates the adminAddress propety with the new _adminAddress value\r\n    function setAdminAddress(address _adminAddress) external onlyOwner returns (bool) {\r\n        require(_adminAddress != address(0));\r\n        require(_adminAddress != address(this));\r\n\r\n        adminAddress = _adminAddress;\r\n        return true;\r\n    }\r\n\r\n    //Checks if an address is owner\r\n    function isOwner(address _address) public view returns (bool) {\r\n        bool result = (_address == owner);\r\n        return result;\r\n    }\r\n\r\n    //Checks if an address is operator\r\n    function isOps(address _address) public view returns (bool) {\r\n        bool result = (_address == opsAddress);\r\n        return result;\r\n    }\r\n\r\n    //Checks if an address is ops or admin\r\n    function isOpsOrAdmin(address _address) public view returns (bool) {\r\n        bool result = (_address == opsAddress || _address == adminAddress);\r\n        return result;\r\n    }\r\n\r\n    //Checks if an address is ops,owner or admin\r\n    function isOwnerOrOpsOrAdmin(address _address) public view returns (bool) {\r\n        bool result = (_address == opsAddress || _address == adminAddress || _address == owner);\r\n        return result;\r\n    }\r\n\r\n    //Checks whether the msg.sender address is equal to the adminAddress property or not\r\n    modifier onlyAdmin() {\r\n        //Needs to be set. Default constructor will set 0x0;\r\n        address _address = msg.sender;\r\n        require(_address != address(0));\r\n        require(_address == adminAddress);\r\n        _;\r\n    }\r\n\r\n    // Checks whether the msg.sender address is equal to the opsAddress property or not\r\n    modifier onlyOps() {\r\n        //Needs to be set. Default constructor will set 0x0;\r\n        address _address = msg.sender;\r\n        require(_address != address(0));\r\n        require(_address == opsAddress);\r\n        _;\r\n    }\r\n\r\n    // Checks whether the msg.sender address is equal to the opsAddress or adminAddress property\r\n    modifier onlyAdminAndOps() {\r\n        //Needs to be set. Default constructor will set 0x0;\r\n        address _address = msg.sender;\r\n        require(_address != address(0));\r\n        require(_address == opsAddress || _address == adminAddress);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract CrowdsaleConfig is J8TTokenConfig {\r\n    using SafeMath for uint256;\r\n\r\n    // Default start token sale date is 28th February 15:00 SGP 2018\r\n    uint256 public constant START_TIMESTAMP = 1519801200;\r\n\r\n    // Default end token sale date is 14th March 15:00 SGP 2018\r\n    uint256 public constant END_TIMESTAMP   = 1521010800;\r\n\r\n    // The ETH decimal factor to obtain weis\r\n    uint256 public constant ETH_DECIMALS_FACTOR = 10**uint256(18);\r\n\r\n    // The token sale supply \r\n    uint256 public constant TOKEN_SALE_SUPPLY = 450000000 * J8T_DECIMALS_FACTOR;\r\n\r\n    // The minimum contribution amount in weis\r\n    uint256 public constant MIN_CONTRIBUTION_WEIS = 0.1 ether;\r\n\r\n    // The maximum contribution amount in weis\r\n    uint256 public constant MAX_CONTRIBUTION_WEIS = 10 ether;\r\n\r\n    //@WARNING: WORKING WITH KILO-MULTIPLES TO AVOID IMPOSSIBLE DIVISIONS OF FLOATING POINTS.\r\n    uint256 constant dollar_per_kilo_token = 100; //0.1 dollar per token\r\n    uint256 public constant dollars_per_kilo_ether = 900000; //900$ per ether\r\n    //TOKENS_PER_ETHER = dollars_per_ether / dollar_per_token\r\n    uint256 public constant INITIAL_TOKENS_PER_ETHER = dollars_per_kilo_ether.div(dollar_per_kilo_token);\r\n}\r\n\r\ncontract Ledger is ACLManaged {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    ///////////////////////\r\n    // Ledger PROPERTIES //\r\n    ///////////////////////\r\n\r\n    // The Allocation struct represents a token sale purchase\r\n    // amountGranted is the amount of tokens purchased\r\n    // hasClaimedBonusTokens whether the allocation has been alredy claimed\r\n    struct Allocation {\r\n        uint256 amountGranted;\r\n        uint256 amountBonusGranted;\r\n        bool hasClaimedBonusTokens;\r\n    }\r\n\r\n    // ContributionPhase enum cases are\r\n    // PreSaleContribution, the contribution has been made in the presale phase\r\n    // PartnerContribution, the contribution has been made in the private phase\r\n    enum ContributionPhase {\r\n        PreSaleContribution, PartnerContribution\r\n    }\r\n\r\n    // Map of adresses that purchased tokens on the presale phase\r\n    mapping(address => Allocation) public presaleAllocations;\r\n\r\n    // Map of adresses that purchased tokens on the private phase\r\n    mapping(address => Allocation) public partnerAllocations;\r\n\r\n    // Reference to the J8TToken contract\r\n    J8TToken public tokenContract;\r\n\r\n    // Reference to the Crowdsale contract\r\n    Crowdsale public crowdsaleContract;\r\n\r\n    // Total private allocation, counting the amount of tokens from the\r\n    // partner and the presale phase\r\n    uint256 public totalPrivateAllocation;\r\n\r\n    // Whether the token allocations can be claimed on the partner sale phase\r\n    bool public canClaimPartnerTokens;\r\n\r\n    // Whether the token allocations can be claimed on the presale sale phase\r\n    bool public canClaimPresaleTokens;\r\n\r\n    // Whether the bonus token allocations can be claimed\r\n    bool public canClaimPresaleBonusTokensPhase1;\r\n    bool public canClaimPresaleBonusTokensPhase2;\r\n\r\n    // Whether the bonus token allocations can be claimed\r\n    bool public canClaimPartnerBonusTokensPhase1;\r\n    bool public canClaimPartnerBonusTokensPhase2;\r\n\r\n    ///////////////////\r\n    // Ledger EVENTS //\r\n    ///////////////////\r\n\r\n    // Triggered when an allocation has been granted\r\n    event AllocationGranted(address _contributor, uint256 _amount, uint8 _phase);\r\n\r\n    // Triggered when an allocation has been revoked\r\n    event AllocationRevoked(address _contributor, uint256 _amount, uint8 _phase);\r\n\r\n    // Triggered when an allocation has been claimed\r\n    event AllocationClaimed(address _contributor, uint256 _amount);\r\n\r\n    // Triggered when a bonus allocation has been claimed\r\n    event AllocationBonusClaimed(address _contributor, uint256 _amount);\r\n\r\n    // Triggered when crowdsale contract updated\r\n    event CrowdsaleContractUpdated(address _who, address _old_address, address _new_address);\r\n\r\n    //Triggered when any can claim token boolean is updated. _type param indicates which is updated.\r\n    event CanClaimTokensUpdated(address _who, string _type, bool _oldCanClaim, bool _newCanClaim);\r\n\r\n    //////////////////////\r\n    // Ledger FUNCTIONS //\r\n    //////////////////////\r\n\r\n    // Ledger constructor\r\n    // Sets default values for canClaimPresaleTokens and canClaimPartnerTokens properties\r\n    function Ledger(J8TToken _tokenContract) public {\r\n        require(address(_tokenContract) != address(0));\r\n        tokenContract = _tokenContract;\r\n        canClaimPresaleTokens = false;\r\n        canClaimPartnerTokens = false;\r\n        canClaimPresaleBonusTokensPhase1 = false;\r\n        canClaimPresaleBonusTokensPhase2 = false;\r\n        canClaimPartnerBonusTokensPhase1 = false;\r\n        canClaimPartnerBonusTokensPhase2 = false;\r\n    }\r\n\r\n    function () external payable {\r\n        claimTokens();\r\n    }\r\n\r\n    // Revokes an allocation from the contributor with address _contributor\r\n    // Deletes the allocation from the corresponding mapping property and transfers\r\n    // the total amount of tokens of the allocation back to the Crowdsale contract\r\n    function revokeAllocation(address _contributor, uint8 _phase) public onlyAdminAndOps payable returns (uint256) {\r\n        require(_contributor != address(0));\r\n        require(_contributor != address(this));\r\n\r\n        // Can't revoke  an allocation if the contribution phase is not in the ContributionPhase enum\r\n        ContributionPhase _contributionPhase = ContributionPhase(_phase);\r\n        require(_contributionPhase == ContributionPhase.PreSaleContribution ||\r\n                _contributionPhase == ContributionPhase.PartnerContribution);\r\n\r\n        uint256 grantedAllocation = 0;\r\n\r\n        // Deletes the allocation from the respective mapping\r\n        if (_contributionPhase == ContributionPhase.PreSaleContribution) {\r\n            grantedAllocation = presaleAllocations[_contributor].amountGranted.add(presaleAllocations[_contributor].amountBonusGranted);\r\n            delete presaleAllocations[_contributor];\r\n        } else if (_contributionPhase == ContributionPhase.PartnerContribution) {\r\n            grantedAllocation = partnerAllocations[_contributor].amountGranted.add(partnerAllocations[_contributor].amountBonusGranted);\r\n            delete partnerAllocations[_contributor];\r\n        }\r\n\r\n        // The granted amount allocation must be less that the current token supply on the contract\r\n        uint256 currentSupply = tokenContract.balanceOf(address(this));\r\n        require(grantedAllocation <= currentSupply);\r\n\r\n        // Updates the total private allocation substracting the amount of tokens that has been revoked\r\n        require(grantedAllocation <= totalPrivateAllocation);\r\n        totalPrivateAllocation = totalPrivateAllocation.sub(grantedAllocation);\r\n        \r\n        // We sent back the amount of tokens that has been revoked to the corwdsale contract\r\n        require(tokenContract.transfer(address(crowdsaleContract), grantedAllocation));\r\n\r\n        AllocationRevoked(_contributor, grantedAllocation, _phase);\r\n\r\n        return grantedAllocation;\r\n\r\n    }\r\n\r\n    // Adds a new allocation for the contributor with address _contributor\r\n    function addAllocation(address _contributor, uint256 _amount, uint256 _bonus, uint8 _phase) public onlyAdminAndOps returns (bool) {\r\n        require(_contributor != address(0));\r\n        require(_contributor != address(this));\r\n\r\n        // Can't create or update an allocation if the amount of tokens to be allocated is not greater than zero\r\n        require(_amount > 0);\r\n\r\n        // Can't create an allocation if the contribution phase is not in the ContributionPhase enum\r\n        ContributionPhase _contributionPhase = ContributionPhase(_phase);\r\n        require(_contributionPhase == ContributionPhase.PreSaleContribution ||\r\n                _contributionPhase == ContributionPhase.PartnerContribution);\r\n\r\n\r\n        uint256 totalAmount = _amount.add(_bonus);\r\n        uint256 totalGrantedAllocation = 0;\r\n        uint256 totalGrantedBonusAllocation = 0;\r\n\r\n        // Fetch the allocation from the respective mapping and updates the granted amount of tokens\r\n        if (_contributionPhase == ContributionPhase.PreSaleContribution) {\r\n            totalGrantedAllocation = presaleAllocations[_contributor].amountGranted.add(_amount);\r\n            totalGrantedBonusAllocation = presaleAllocations[_contributor].amountBonusGranted.add(_bonus);\r\n            presaleAllocations[_contributor] = Allocation(totalGrantedAllocation, totalGrantedBonusAllocation, false);\r\n        } else if (_contributionPhase == ContributionPhase.PartnerContribution) {\r\n            totalGrantedAllocation = partnerAllocations[_contributor].amountGranted.add(_amount);\r\n            totalGrantedBonusAllocation = partnerAllocations[_contributor].amountBonusGranted.add(_bonus);\r\n            partnerAllocations[_contributor] = Allocation(totalGrantedAllocation, totalGrantedBonusAllocation, false);\r\n        }\r\n\r\n        // Updates the contract data\r\n        totalPrivateAllocation = totalPrivateAllocation.add(totalAmount);\r\n\r\n        AllocationGranted(_contributor, totalAmount, _phase);\r\n\r\n        return true;\r\n    }\r\n\r\n    // The claimTokens() function handles the contribution token claim.\r\n    // Tokens can only be claimed after we open this phase.\r\n    // The lockouts periods are defined by the foundation.\r\n    // There are 2 different lockouts:\r\n    //      Presale lockout\r\n    //      Partner lockout\r\n    //\r\n    // A contributor that has contributed in all the phases can claim\r\n    // all its tokens, but only the ones that are accesible to claim\r\n    // be transfered.\r\n    // \r\n    // A contributor can claim its tokens after each phase has been opened\r\n    function claimTokens() public payable returns (bool) {\r\n        require(msg.sender != address(0));\r\n        require(msg.sender != address(this));\r\n\r\n        uint256 amountToTransfer = 0;\r\n\r\n        // We need to check if the contributor has made a contribution on each\r\n        // phase, presale and partner\r\n        Allocation storage presaleA = presaleAllocations[msg.sender];\r\n        if (presaleA.amountGranted > 0 && canClaimPresaleTokens) {\r\n            amountToTransfer = amountToTransfer.add(presaleA.amountGranted);\r\n            presaleA.amountGranted = 0;\r\n        }\r\n\r\n        Allocation storage partnerA = partnerAllocations[msg.sender];\r\n        if (partnerA.amountGranted > 0 && canClaimPartnerTokens) {\r\n            amountToTransfer = amountToTransfer.add(partnerA.amountGranted);\r\n            partnerA.amountGranted = 0;\r\n        }\r\n\r\n        // The amount to transfer must greater than zero\r\n        require(amountToTransfer > 0);\r\n\r\n        // The amount to transfer must be less or equal to the current supply\r\n        uint256 currentSupply = tokenContract.balanceOf(address(this));\r\n        require(amountToTransfer <= currentSupply);\r\n        \r\n        // Transfer the token allocation to contributor\r\n        require(tokenContract.transfer(msg.sender, amountToTransfer));\r\n        AllocationClaimed(msg.sender, amountToTransfer);\r\n    \r\n        return true;\r\n    }\r\n\r\n    function claimBonus() external payable returns (bool) {\r\n        require(msg.sender != address(0));\r\n        require(msg.sender != address(this));\r\n\r\n        uint256 amountToTransfer = 0;\r\n\r\n        // BONUS PHASE 1\r\n        Allocation storage presale = presaleAllocations[msg.sender];\r\n        if (presale.amountBonusGranted > 0 && !presale.hasClaimedBonusTokens && canClaimPresaleBonusTokensPhase1) {\r\n            uint256 amountPresale = presale.amountBonusGranted.div(2);\r\n            amountToTransfer = amountPresale;\r\n            presale.amountBonusGranted = amountPresale;\r\n            presale.hasClaimedBonusTokens = true;\r\n        }\r\n\r\n        Allocation storage partner = partnerAllocations[msg.sender];\r\n        if (partner.amountBonusGranted > 0 && !partner.hasClaimedBonusTokens && canClaimPartnerBonusTokensPhase1) {\r\n            uint256 amountPartner = partner.amountBonusGranted.div(2);\r\n            amountToTransfer = amountToTransfer.add(amountPartner);\r\n            partner.amountBonusGranted = amountPartner;\r\n            partner.hasClaimedBonusTokens = true;\r\n        }\r\n\r\n        // BONUS PHASE 2\r\n        if (presale.amountBonusGranted > 0 && canClaimPresaleBonusTokensPhase2) {\r\n            amountToTransfer = amountToTransfer.add(presale.amountBonusGranted);\r\n            presale.amountBonusGranted = 0;\r\n        }\r\n\r\n        if (partner.amountBonusGranted > 0 && canClaimPartnerBonusTokensPhase2) {\r\n            amountToTransfer = amountToTransfer.add(partner.amountBonusGranted);\r\n            partner.amountBonusGranted = 0;\r\n        }\r\n\r\n        // The amount to transfer must greater than zero\r\n        require(amountToTransfer > 0);\r\n\r\n        // The amount to transfer must be less or equal to the current supply\r\n        uint256 currentSupply = tokenContract.balanceOf(address(this));\r\n        require(amountToTransfer <= currentSupply);\r\n        \r\n        // Transfer the token allocation to contributor\r\n        require(tokenContract.transfer(msg.sender, amountToTransfer));\r\n        AllocationBonusClaimed(msg.sender, amountToTransfer);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Updates the canClaimPresaleTokens propety with the new _canClaimTokens value\r\n    function setCanClaimPresaleTokens(bool _canClaimTokens) external onlyAdmin returns (bool) {\r\n        bool _oldCanClaim = canClaimPresaleTokens;\r\n        canClaimPresaleTokens = _canClaimTokens;\r\n        CanClaimTokensUpdated(msg.sender, 'canClaimPresaleTokens', _oldCanClaim, _canClaimTokens);\r\n        return true;\r\n    }\r\n\r\n    // Updates the canClaimPartnerTokens property with the new _canClaimTokens value\r\n    function setCanClaimPartnerTokens(bool _canClaimTokens) external onlyAdmin returns (bool) {\r\n        bool _oldCanClaim = canClaimPartnerTokens;\r\n        canClaimPartnerTokens = _canClaimTokens;\r\n        CanClaimTokensUpdated(msg.sender, 'canClaimPartnerTokens', _oldCanClaim, _canClaimTokens);\r\n        return true;\r\n    }\r\n\r\n    // Updates the canClaimBonusTokens property with the new _canClaimTokens value\r\n    function setCanClaimPresaleBonusTokensPhase1(bool _canClaimTokens) external onlyAdmin returns (bool) {\r\n        bool _oldCanClaim = canClaimPresaleBonusTokensPhase1;\r\n        canClaimPresaleBonusTokensPhase1 = _canClaimTokens;\r\n        CanClaimTokensUpdated(msg.sender, 'canClaimPresaleBonusTokensPhase1', _oldCanClaim, _canClaimTokens);\r\n        return true;\r\n    }\r\n\r\n    // Updates the canClaimBonusTokens property with the new _canClaimTokens value\r\n    function setCanClaimPresaleBonusTokensPhase2(bool _canClaimTokens) external onlyAdmin returns (bool) {\r\n        bool _oldCanClaim = canClaimPresaleBonusTokensPhase2;\r\n        canClaimPresaleBonusTokensPhase2 = _canClaimTokens;\r\n        CanClaimTokensUpdated(msg.sender, 'canClaimPresaleBonusTokensPhase2', _oldCanClaim, _canClaimTokens);\r\n        return true;\r\n    }\r\n\r\n    // Updates the canClaimBonusTokens property with the new _canClaimTokens value\r\n    function setCanClaimPartnerBonusTokensPhase1(bool _canClaimTokens) external onlyAdmin returns (bool) {\r\n        bool _oldCanClaim = canClaimPartnerBonusTokensPhase1;\r\n        canClaimPartnerBonusTokensPhase1 = _canClaimTokens;\r\n        CanClaimTokensUpdated(msg.sender, 'canClaimPartnerBonusTokensPhase1', _oldCanClaim, _canClaimTokens);\r\n        return true;\r\n    }\r\n\r\n    // Updates the canClaimBonusTokens property with the new _canClaimTokens value\r\n    function setCanClaimPartnerBonusTokensPhase2(bool _canClaimTokens) external onlyAdmin returns (bool) {\r\n        bool _oldCanClaim = canClaimPartnerBonusTokensPhase2;\r\n        canClaimPartnerBonusTokensPhase2 = _canClaimTokens;\r\n        CanClaimTokensUpdated(msg.sender, 'canClaimPartnerBonusTokensPhase2', _oldCanClaim, _canClaimTokens);\r\n        return true;\r\n    }\r\n\r\n    // Updates the crowdsale contract property with the new _crowdsaleContract value\r\n    function setCrowdsaleContract(Crowdsale _crowdsaleContract) public onlyOwner returns (bool) {\r\n        address old_crowdsale_address = crowdsaleContract;\r\n\r\n        crowdsaleContract = _crowdsaleContract;\r\n\r\n        CrowdsaleContractUpdated(msg.sender, old_crowdsale_address, crowdsaleContract);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Crowdsale is ACLManaged, CrowdsaleConfig {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    //////////////////////////\r\n    // Crowdsale PROPERTIES //\r\n    //////////////////////////\r\n\r\n    // The J8TToken smart contract reference\r\n    J8TToken public tokenContract;\r\n\r\n    // The Ledger smart contract reference\r\n    Ledger public ledgerContract;\r\n\r\n    // The start token sale date represented as a timestamp\r\n    uint256 public startTimestamp;\r\n\r\n    // The end token sale date represented as a timestamp\r\n    uint256 public endTimestamp;\r\n\r\n    // Ratio of J8T tokens to per ether\r\n    uint256 public tokensPerEther;\r\n\r\n    // The total amount of wei raised in the token sale\r\n    // Including presales (in eth) and public sale\r\n    uint256 public weiRaised;\r\n\r\n    // The current total amount of tokens sold in the token sale\r\n    uint256 public totalTokensSold;\r\n\r\n    // The minimum and maximum eth contribution accepted in the token sale\r\n    uint256 public minContribution;\r\n    uint256 public maxContribution;\r\n\r\n    // The wallet address where the token sale sends all eth contributions\r\n    address public wallet;\r\n\r\n    // Controls whether the token sale has finished or not\r\n    bool public isFinalized = false;\r\n\r\n    // Map of adresses that requested to purchase tokens\r\n    // Contributors of the token sale are segmented as:\r\n    //  CannotContribute: Cannot contribute in any phase (uint8  - 0)\r\n    //  PreSaleContributor: Can contribute on both pre-sale and pubic sale phases (uint8  - 1)\r\n    //  PublicSaleContributor: Can contribute on he public sale phase (uint8  - 2)\r\n    mapping(address => WhitelistPermission) public whitelist;\r\n\r\n    // Map of addresses that has already contributed on the token sale\r\n    mapping(address => bool) public hasContributed;\r\n\r\n    enum WhitelistPermission {\r\n        CannotContribute, PreSaleContributor, PublicSaleContributor \r\n    }\r\n\r\n    //////////////////////\r\n    // Crowdsale EVENTS //\r\n    //////////////////////\r\n\r\n    // Triggered when a contribution in the public sale has been processed correctly\r\n    event TokensPurchased(address _contributor, uint256 _amount);\r\n\r\n    // Triggered when the whitelist has been updated\r\n    event WhiteListUpdated(address _who, address _account, WhitelistPermission _phase);\r\n\r\n    // Triggered when the Crowdsale has been created\r\n    event ContractCreated();\r\n\r\n    // Triggered when a presale has been added\r\n    // The phase parameter can be a strategic partner contribution or a presale contribution\r\n    event PresaleAdded(address _contributor, uint256 _amount, uint8 _phase);\r\n\r\n    // Triggered when the tokensPerEther property has been updated\r\n    event TokensPerEtherUpdated(address _who, uint256 _oldValue, uint256 _newValue);\r\n\r\n    // Triggered when the startTimestamp property has been updated\r\n    event StartTimestampUpdated(address _who, uint256 _oldValue, uint256 _newValue);\r\n\r\n    // Triggered when the endTimestamp property has been updated\r\n    event EndTimestampUpdated(address _who, uint256 _oldValue, uint256 _newValue);\r\n\r\n    // Triggered when the wallet property has been updated\r\n    event WalletUpdated(address _who, address _oldWallet, address _newWallet);\r\n\r\n    // Triggered when the minContribution property has been updated\r\n    event MinContributionUpdated(address _who, uint256 _oldValue, uint256 _newValue);\r\n\r\n    // Triggered when the maxContribution property has been updated\r\n    event MaxContributionUpdated(address _who, uint256 _oldValue, uint256 _newValue);\r\n\r\n    // Triggered when the token sale has finalized\r\n    event Finalized(address _who, uint256 _timestamp);\r\n\r\n    // Triggered when the token sale has finalized and there where still token to sale\r\n    // When the token are not sold, we burn them\r\n    event Burned(address _who, uint256 _amount, uint256 _timestamp);\r\n\r\n    /////////////////////////\r\n    // Crowdsale FUNCTIONS //\r\n    /////////////////////////\r\n    \r\n\r\n    // Crowdsale constructor\r\n    // Takes default values from the CrowdsaleConfig smart contract\r\n    function Crowdsale(\r\n        J8TToken _tokenContract,\r\n        Ledger _ledgerContract,\r\n        address _wallet\r\n    ) public\r\n    {\r\n        uint256 _start            = START_TIMESTAMP;\r\n        uint256 _end              = END_TIMESTAMP;\r\n        uint256 _supply           = TOKEN_SALE_SUPPLY;\r\n        uint256 _min_contribution = MIN_CONTRIBUTION_WEIS;\r\n        uint256 _max_contribution = MAX_CONTRIBUTION_WEIS;\r\n        uint256 _tokensPerEther   = INITIAL_TOKENS_PER_ETHER;\r\n\r\n        require(_start > currentTime());\r\n        require(_end > _start);\r\n        require(_tokensPerEther > 0);\r\n        require(address(_tokenContract) != address(0));\r\n        require(address(_ledgerContract) != address(0));\r\n        require(_wallet != address(0));\r\n\r\n        ledgerContract   = _ledgerContract;\r\n        tokenContract    = _tokenContract;\r\n        startTimestamp   = _start;\r\n        endTimestamp     = _end;\r\n        tokensPerEther   = _tokensPerEther;\r\n        minContribution = _min_contribution;\r\n        maxContribution = _max_contribution;\r\n        wallet           = _wallet;\r\n        totalTokensSold  = 0;\r\n        weiRaised        = 0;\r\n        isFinalized      = false;  \r\n\r\n        ContractCreated();\r\n    }\r\n\r\n    // Updates the tokenPerEther propety with the new _tokensPerEther value\r\n    function setTokensPerEther(uint256 _tokensPerEther) external onlyAdmin onlyBeforeSale returns (bool) {\r\n        require(_tokensPerEther > 0);\r\n\r\n        uint256 _oldValue = tokensPerEther;\r\n        tokensPerEther = _tokensPerEther;\r\n\r\n        TokensPerEtherUpdated(msg.sender, _oldValue, tokensPerEther);\r\n        return true;\r\n    }\r\n\r\n    // Updates the startTimestamp propety with the new _start value\r\n    function setStartTimestamp(uint256 _start) external onlyAdmin returns (bool) {\r\n        require(_start < endTimestamp);\r\n        require(_start > currentTime());\r\n\r\n        uint256 _oldValue = startTimestamp;\r\n        startTimestamp = _start;\r\n\r\n        StartTimestampUpdated(msg.sender, _oldValue, startTimestamp);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Updates the endTimestamp propety with the new _end value\r\n    function setEndTimestamp(uint256 _end) external onlyAdmin returns (bool) {\r\n        require(_end > startTimestamp);\r\n\r\n        uint256 _oldValue = endTimestamp;\r\n        endTimestamp = _end;\r\n\r\n        EndTimestampUpdated(msg.sender, _oldValue, endTimestamp);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Updates the wallet propety with the new _newWallet value\r\n    function updateWallet(address _newWallet) external onlyAdmin returns (bool) {\r\n        require(_newWallet != address(0));\r\n        \r\n        address _oldValue = wallet;\r\n        wallet = _newWallet;\r\n        \r\n        WalletUpdated(msg.sender, _oldValue, wallet);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Updates the minContribution propety with the new _newMinControbution value\r\n    function setMinContribution(uint256 _newMinContribution) external onlyAdmin returns (bool) {\r\n        require(_newMinContribution <= maxContribution);\r\n\r\n        uint256 _oldValue = minContribution;\r\n        minContribution = _newMinContribution;\r\n        \r\n        MinContributionUpdated(msg.sender, _oldValue, minContribution);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Updates the maxContribution propety with the new _newMaxContribution value\r\n    function setMaxContribution(uint256 _newMaxContribution) external onlyAdmin returns (bool) {\r\n        require(_newMaxContribution > minContribution);\r\n\r\n        uint256 _oldValue = maxContribution;\r\n        maxContribution = _newMaxContribution;\r\n        \r\n        MaxContributionUpdated(msg.sender, _oldValue, maxContribution);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Main public function.\r\n    function () external payable {\r\n        purchaseTokens();\r\n    }\r\n\r\n    // Revokes a presale allocation from the contributor with address _contributor\r\n    // Updates the totalTokensSold property substracting the amount of tokens that where previously allocated\r\n    function revokePresale(address _contributor, uint8 _contributorPhase) external onlyAdmin returns (bool) {\r\n        require(_contributor != address(0));\r\n\r\n        // We can only revoke allocations from pre sale or strategic partners\r\n        // ContributionPhase.PreSaleContribution == 0,  ContributionPhase.PartnerContribution == 1\r\n        require(_contributorPhase == 0 || _contributorPhase == 1);\r\n\r\n        uint256 luckys = ledgerContract.revokeAllocation(_contributor, _contributorPhase);\r\n        \r\n        require(luckys > 0);\r\n        require(luckys <= totalTokensSold);\r\n        \r\n        totalTokensSold = totalTokensSold.sub(luckys);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Adds a new presale allocation for the contributor with address _contributor\r\n    // We can only allocate presale before the token sale has been initialized\r\n    function addPresale(address _contributor, uint256 _tokens, uint256 _bonus, uint8 _contributorPhase) external onlyAdminAndOps onlyBeforeSale returns (bool) {\r\n        require(_tokens > 0);\r\n        require(_bonus > 0);\r\n\r\n        // Converts the amount of tokens to our smallest J8T value, lucky\r\n        uint256 luckys = _tokens.mul(J8T_DECIMALS_FACTOR);\r\n        uint256 bonusLuckys = _bonus.mul(J8T_DECIMALS_FACTOR);\r\n        uint256 totalTokens = luckys.add(bonusLuckys);\r\n\r\n        uint256 availableTokensToPurchase = tokenContract.balanceOf(address(this));\r\n        \r\n        require(totalTokens <= availableTokensToPurchase);\r\n\r\n        // Insert the new allocation to the Ledger\r\n        require(ledgerContract.addAllocation(_contributor, luckys, bonusLuckys, _contributorPhase));\r\n        // Transfers the tokens form the Crowdsale contract to the Ledger contract\r\n        require(tokenContract.transfer(address(ledgerContract), totalTokens));\r\n\r\n        // Updates totalTokensSold property\r\n        totalTokensSold = totalTokensSold.add(totalTokens);\r\n\r\n        // If we reach the total amount of tokens to sell we finilize the token sale\r\n        availableTokensToPurchase = tokenContract.balanceOf(address(this));\r\n        if (availableTokensToPurchase == 0) {\r\n            finalization();\r\n        }\r\n\r\n        // Trigger PresaleAdded event\r\n        PresaleAdded(_contributor, totalTokens, _contributorPhase);\r\n    }\r\n\r\n    // The purchaseTokens function handles the token purchase flow\r\n    function purchaseTokens() public payable onlyDuringSale returns (bool) {\r\n        address contributor = msg.sender;\r\n        uint256 weiAmount = msg.value;\r\n\r\n        // A contributor can only contribute once on the public sale\r\n        require(hasContributed[contributor] == false);\r\n        // The contributor address must be whitelisted in order to be able to purchase tokens\r\n        require(contributorCanContribute(contributor));\r\n        // The weiAmount must be greater or equal than minContribution\r\n        require(weiAmount >= minContribution);\r\n        // The weiAmount cannot be greater than maxContribution\r\n        require(weiAmount <= maxContribution);\r\n        // The availableTokensToPurchase must be greater than 0\r\n        require(totalTokensSold < TOKEN_SALE_SUPPLY);\r\n        uint256 availableTokensToPurchase = TOKEN_SALE_SUPPLY.sub(totalTokensSold);\r\n\r\n        // We need to convert the tokensPerEther to luckys (10**8)\r\n        uint256 luckyPerEther = tokensPerEther.mul(J8T_DECIMALS_FACTOR);\r\n\r\n        // In order to calculate the tokens amount to be allocated to the contrbutor\r\n        // we need to multiply the amount of wei sent by luckyPerEther and divide the\r\n        // result for the ether decimal factor (10**18)\r\n        uint256 tokensAmount = weiAmount.mul(luckyPerEther).div(ETH_DECIMALS_FACTOR);\r\n        \r\n\r\n        uint256 refund = 0;\r\n        uint256 tokensToPurchase = tokensAmount;\r\n        \r\n        // If the token purchase amount is bigger than the remaining token allocation\r\n        // we can only sell the remainging tokens and refund the unused amount of eth\r\n        if (availableTokensToPurchase < tokensAmount) {\r\n            tokensToPurchase = availableTokensToPurchase;\r\n            weiAmount = tokensToPurchase.mul(ETH_DECIMALS_FACTOR).div(luckyPerEther);\r\n            refund = msg.value.sub(weiAmount);\r\n        }\r\n\r\n        // We update the token sale contract data\r\n        totalTokensSold = totalTokensSold.add(tokensToPurchase);\r\n        uint256 weiToPurchase = tokensToPurchase.div(tokensPerEther);\r\n        weiRaised = weiRaised.add(weiToPurchase);\r\n\r\n        // Transfers the tokens form the Crowdsale contract to contriutors wallet\r\n        require(tokenContract.transfer(contributor, tokensToPurchase));\r\n\r\n        // Issue a refund for any unused ether \r\n        if (refund > 0) {\r\n            contributor.transfer(refund);\r\n        }\r\n\r\n        // Transfer ether contribution to the wallet\r\n        wallet.transfer(weiAmount);\r\n\r\n        // Update hasContributed mapping\r\n        hasContributed[contributor] = true;\r\n\r\n        TokensPurchased(contributor, tokensToPurchase);\r\n\r\n        // If we reach the total amount of tokens to sell we finilize the token sale\r\n        if (totalTokensSold == TOKEN_SALE_SUPPLY) {\r\n            finalization();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Updates the whitelist\r\n    function updateWhitelist(address _account, WhitelistPermission _permission) external onlyAdminAndOps returns (bool) {\r\n        require(_account != address(0));\r\n        require(_permission == WhitelistPermission.PreSaleContributor || _permission == WhitelistPermission.PublicSaleContributor || _permission == WhitelistPermission.CannotContribute);\r\n        require(!saleHasFinished());\r\n\r\n        whitelist[_account] = _permission;\r\n\r\n        address _who = msg.sender;\r\n        WhiteListUpdated(_who, _account, _permission);\r\n\r\n        return true;\r\n    }\r\n\r\n    function updateWhitelist_batch(address[] _accounts, WhitelistPermission _permission) external onlyAdminAndOps returns (bool) {\r\n        require(_permission == WhitelistPermission.PreSaleContributor || _permission == WhitelistPermission.PublicSaleContributor || _permission == WhitelistPermission.CannotContribute);\r\n        require(!saleHasFinished());\r\n\r\n        for(uint i = 0; i < _accounts.length; ++i) {\r\n            require(_accounts[i] != address(0));\r\n            whitelist[_accounts[i]] = _permission;\r\n            WhiteListUpdated(msg.sender, _accounts[i], _permission);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Checks that the status of an address account\r\n    // Contributors of the token sale are segmented as:\r\n    //  PreSaleContributor: Can contribute on both pre-sale and pubic sale phases\r\n    //  PublicSaleContributor: Can contribute on he public sale phase\r\n    //  CannotContribute: Cannot contribute in any phase\r\n    function contributorCanContribute(address _contributorAddress) private view returns (bool) {\r\n        WhitelistPermission _contributorPhase = whitelist[_contributorAddress];\r\n\r\n        if (_contributorPhase == WhitelistPermission.CannotContribute) {\r\n            return false;\r\n        }\r\n\r\n        if (_contributorPhase == WhitelistPermission.PreSaleContributor || \r\n            _contributorPhase == WhitelistPermission.PublicSaleContributor) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Returns the current time\r\n    function currentTime() public view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    // Checks if the sale has finished\r\n    function saleHasFinished() public view returns (bool) {\r\n        if (isFinalized) {\r\n            return true;\r\n        }\r\n\r\n        if (endTimestamp < currentTime()) {\r\n            return true;\r\n        }\r\n\r\n        if (totalTokensSold == TOKEN_SALE_SUPPLY) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    modifier onlyBeforeSale() {\r\n        require(currentTime() < startTimestamp);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDuringSale() {\r\n        uint256 _currentTime = currentTime();\r\n        require(startTimestamp < _currentTime);\r\n        require(_currentTime < endTimestamp);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPostSale() {\r\n        require(endTimestamp < currentTime());\r\n        _;\r\n    }\r\n\r\n    ///////////////////////\r\n    // PRIVATE FUNCTIONS //\r\n    ///////////////////////\r\n\r\n    // This method is for to be called only for the owner. This way we protect for anyone who wanna finalize the ICO.\r\n    function finalize() external onlyAdmin returns (bool) {\r\n        return finalization();\r\n    }\r\n\r\n    // Only used by finalize and setFinalized.\r\n    // Overloaded logic for two uses.\r\n    // NOTE: In case finalize is called by an user and not from addPresale()/purchaseToken()\r\n    // will diff total supply with sold supply to burn token.\r\n    function finalization() private returns (bool) {\r\n        require(!isFinalized);\r\n\r\n        isFinalized = true;\r\n\r\n        \r\n        if (totalTokensSold < TOKEN_SALE_SUPPLY) {\r\n            uint256 toBurn = TOKEN_SALE_SUPPLY.sub(totalTokensSold);\r\n            tokenContract.burn(toBurn);\r\n            Burned(msg.sender, toBurn, currentTime());\r\n        }\r\n\r\n        Finalized(msg.sender, currentTime());\r\n\r\n        return true;\r\n    }\r\n\r\n    function saleSupply() public view returns (uint256) {\r\n        return tokenContract.balanceOf(address(this));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ledgerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMaxContribution\",\"type\":\"uint256\"}],\"name\":\"setMaxContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_TOKENS_PER_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"setAdminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwnerOrOpsOrAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinContribution\",\"type\":\"uint256\"}],\"name\":\"setMinContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"J8T_DECIMALS_FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_permission\",\"type\":\"uint8\"}],\"name\":\"updateWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_SALE_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_opsAddress\",\"type\":\"address\"}],\"name\":\"setOpsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleHasFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accounts\",\"type\":\"address[]\"},{\"name\":\"_permission\",\"type\":\"uint8\"}],\"name\":\"updateWhitelist_batch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_TIMESTAMP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"setEndTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"updateWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokensPerEther\",\"type\":\"uint256\"}],\"name\":\"setTokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_CONTRIBUTION_WEIS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CONTRIBUTION_WEIS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_TIMESTAMP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dollars_per_kilo_ether\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"setStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_bonus\",\"type\":\"uint256\"},{\"name\":\"_contributorPhase\",\"type\":\"uint8\"}],\"name\":\"addPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_DECIMALS_FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOpsOrAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOps\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"},{\"name\":\"_contributorPhase\",\"type\":\"uint8\"}],\"name\":\"revokePresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_ledgerContract\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"WhiteListUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_phase\",\"type\":\"uint8\"}],\"name\":\"PresaleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"TokensPerEtherUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"StartTimestampUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"EndTimestampUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"WalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"MinContributionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"MaxContributionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000d262e5dc4a06a0f1c90ce79c7a60c09dfc884e4000000000000000000000000784b96cd15ffa57e91b495d5c5b4f2b195fe3b3b000000000000000000000000aec1e80c1b32d8129e34d8180204c9dbbc52df04","Library":"","SwarmSource":"bzzr://8ea21b3f395e336b88d7d2aa561d5e9994ca2032511309440b06f6028e4f9a85"}]}