{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title Token\r\n * @dev Token interface necessary for working with tokens within the exchange contract.\r\n */\r\ncontract IToken {\r\n    /// @return total amount of tokens\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    uint public decimals;\r\n    string public name;\r\n}\r\n\r\npragma solidity ^0.4.17;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary LSafeMath {\r\n\r\n    uint256 constant WAD = 1 ether;\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        if (c / a == b)\r\n            return c;\r\n        revert();\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b > 0) { \r\n            uint256 c = a / b;\r\n            return c;\r\n        }\r\n        revert();\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b <= a)\r\n            return a - b;\r\n        revert();\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        if (c >= a) \r\n            return c;\r\n        revert();\r\n    }\r\n\r\n    function wmul(uint a, uint b) internal pure returns (uint256) {\r\n        return add(mul(a, b), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint a, uint b) internal pure returns (uint256) {\r\n        return add(mul(a, WAD), b / 2) / b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Coinchangex\r\n * @dev This is the main contract for the Coinchangex exchange.\r\n */\r\ncontract Coinchangex {\r\n  \r\n  using LSafeMath for uint;\r\n  \r\n  struct SpecialTokenBalanceFeeTake {\r\n      bool exist;\r\n      address token;\r\n      uint256 balance;\r\n      uint256 feeTake;\r\n  }\r\n  \r\n  uint constant private MAX_SPECIALS = 10;\r\n\r\n  /// Variables\r\n  address public admin; // the admin address\r\n  address public feeAccount; // the account that will receive fees\r\n  uint public feeTake; // percentage times (1 ether)\r\n  bool private depositingTokenFlag; // True when Token.transferFrom is being called from depositToken\r\n  mapping (address => mapping (address => uint)) public tokens; // mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n  SpecialTokenBalanceFeeTake[] public specialFees;\r\n  \r\n\r\n  /// Logging Events\r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n  /// This is a modifier for functions to check if the sending user address is the same as the admin user address.\r\n  modifier isAdmin() {\r\n      require(msg.sender == admin);\r\n      _;\r\n  }\r\n\r\n  /// Constructor function. This is only called on contract creation.\r\n  function Coinchangex(address admin_, address feeAccount_, uint feeTake_) public {\r\n    admin = admin_;\r\n    feeAccount = feeAccount_;\r\n    feeTake = feeTake_;\r\n    depositingTokenFlag = false;\r\n  }\r\n\r\n  /// The fallback function. Ether transfered into the contract is not accepted.\r\n  function() public {\r\n    revert();\r\n  }\r\n\r\n  /// Changes the official admin user address. Accepts Ethereum address.\r\n  function changeAdmin(address admin_) public isAdmin {\r\n    require(admin_ != address(0));\r\n    admin = admin_;\r\n  }\r\n\r\n  /// Changes the account address that receives trading fees. Accepts Ethereum address.\r\n  function changeFeeAccount(address feeAccount_) public isAdmin {\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  /// Changes the fee on takes. Can only be changed to a value less than it is currently set at.\r\n  function changeFeeTake(uint feeTake_) public isAdmin {\r\n    // require(feeTake_ <= feeTake);\r\n    feeTake = feeTake_;\r\n  }\r\n  \r\n  // add special promotion fee\r\n  function addSpecialFeeTake(address token, uint256 balance, uint256 feeTake) public isAdmin {\r\n      uint id = specialFees.push(SpecialTokenBalanceFeeTake(\r\n          true,\r\n          token,\r\n          balance,\r\n          feeTake\r\n      ));\r\n  }\r\n  \r\n  // chnage special promotion fee\r\n  function chnageSpecialFeeTake(uint id, address token, uint256 balance, uint256 feeTake) public isAdmin {\r\n      require(id < specialFees.length);\r\n      specialFees[id] = SpecialTokenBalanceFeeTake(\r\n          true,\r\n          token,\r\n          balance,\r\n          feeTake\r\n      );\r\n  }\r\n  \r\n    // remove special promotion fee\r\n   function removeSpecialFeeTake(uint id) public isAdmin {\r\n       if (id >= specialFees.length) revert();\r\n\r\n        uint last = specialFees.length-1;\r\n        for (uint i = id; i<last; i++){\r\n            specialFees[i] = specialFees[i+1];\r\n        }\r\n        \r\n        delete specialFees[last];\r\n        specialFees.length--;\r\n  } \r\n  \r\n  //return total count promotion fees\r\n  function TotalSpecialFeeTakes() public constant returns(uint)  {\r\n      return specialFees.length;\r\n  }\r\n  \r\n  \r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Deposits, Withdrawals, Balances\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n  * This function handles deposits of Ether into the contract.\r\n  * Emits a Deposit event.\r\n  * Note: With the payable modifier, this function accepts Ether.\r\n  */\r\n  function deposit() public payable {\r\n    tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * This function handles withdrawals of Ether from the contract.\r\n  * Verifies that the user has enough funds to cover the withdrawal.\r\n  * Emits a Withdraw event.\r\n  * @param amount uint of the amount of Ether the user wishes to withdraw\r\n  */\r\n  function withdraw(uint amount) public {\r\n    require(tokens[0][msg.sender] >= amount);\r\n    tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\r\n    msg.sender.transfer(amount);\r\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * This function handles deposits of Ethereum based tokens to the contract.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Emits a Deposit event.\r\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param amount uint of the amount of the token the user wishes to deposit\r\n  */\r\n  function depositToken(address token, uint amount) public {\r\n    require(token != 0);\r\n    depositingTokenFlag = true;\r\n    require(IToken(token).transferFrom(msg.sender, this, amount));\r\n    depositingTokenFlag = false;\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n }\r\n\r\n  /**\r\n  * This function provides a fallback solution as outlined in ERC223.\r\n  * If tokens are deposited through depositToken(), the transaction will continue.\r\n  * If tokens are sent directly to this contract, the transaction is reverted.\r\n  * @param sender Ethereum address of the sender of the token\r\n  * @param amount amount of the incoming tokens\r\n  * @param data attached data similar to msg.data of Ether transactions\r\n  */\r\n  function tokenFallback( address sender, uint amount, bytes data) public returns (bool ok) {\r\n      if (depositingTokenFlag) {\r\n        // Transfer was initiated from depositToken(). User token balance will be updated there.\r\n        return true;\r\n      } else {\r\n        // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent\r\n        // with direct transfers of ECR20 and ETH.\r\n        revert();\r\n      }\r\n  }\r\n  \r\n  /**\r\n  * This function handles withdrawals of Ethereum based tokens from the contract.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Emits a Withdraw event.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param amount uint of the amount of the token the user wishes to withdraw\r\n  */\r\n  function withdrawToken(address token, uint amount) public {\r\n    require(token != 0);\r\n    require(tokens[token][msg.sender] >= amount);\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n    require(IToken(token).transfer(msg.sender, amount));\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * Retrieves the balance of a token based on a user address and token address.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param user Ethereum address of the user\r\n  * @return the amount of tokens on the exchange for a given user address\r\n  */\r\n  function balanceOf(address token, address user) public constant returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Trading\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n  * Facilitates a trade from one user to another.\r\n  * Requires that the transaction is signed properly, the trade isn't past its expiration, and all funds are present to fill the trade.\r\n  * Calls tradeBalances().\r\n  * Updates orderFills with the amount traded.\r\n  * Emits a Trade event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  */\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    require((\r\n      (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) &&\r\n      block.number <= expires &&\r\n      orderFills[user][hash].add(amount) <= amountGet\r\n    ));\r\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n    orderFills[user][hash] = orderFills[user][hash].add(amount);\r\n    Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender);\r\n  }\r\n\r\n  /**\r\n  * This is a private function and is only being called from trade().\r\n  * Handles the movement of funds when a trade occurs.\r\n  * Takes fees.\r\n  * Updates token balances for both buyer and seller.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  */\r\n  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\r\n    \r\n    uint256 feeTakeXfer = calculateFee(amount);\r\n    \r\n    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount.add(feeTakeXfer));\r\n    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount);\r\n    tokens[tokenGet][feeAccount] = tokens[tokenGet][feeAccount].add(feeTakeXfer);\r\n    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\r\n    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\r\n  }\r\n  \r\n  //calculate fee including special promotions\r\n  function calculateFee(uint amount) private constant returns(uint256)  {\r\n    uint256 feeTakeXfer = 0;\r\n    \r\n    uint length = specialFees.length;\r\n    bool applied = false;\r\n    for(uint i = 0; length > 0 && i < length; i++) {\r\n        SpecialTokenBalanceFeeTake memory special = specialFees[i];\r\n        if(special.exist && special.balance <= tokens[special.token][msg.sender]) {\r\n            applied = true;\r\n            feeTakeXfer = amount.mul(special.feeTake).div(1 ether);\r\n            break;\r\n        }\r\n        if(i >= MAX_SPECIALS)\r\n            break;\r\n    }\r\n    \r\n    if(!applied)\r\n        feeTakeXfer = amount.mul(feeTake).div(1 ether);\r\n    \r\n    \r\n    return feeTakeXfer;\r\n  }\r\n\r\n  /**\r\n  * This function is to test if a trade would go through.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  * @param sender Ethereum address of the user taking the order\r\n  * @return bool: true if the trade would be successful, false otherwise\r\n  */\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\r\n    if (!(\r\n      tokens[tokenGet][sender] >= amount &&\r\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\r\n      )) { \r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This function checks the available volume for a given order.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\r\n  */\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) &&\r\n      block.number <= expires\r\n      )) {\r\n      return 0;\r\n    }\r\n    uint[2] memory available;\r\n    available[0] = amountGet.sub(orderFills[user][hash]);\r\n    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;\r\n    if (available[0] < available[1]) {\r\n      return available[0];\r\n    } else {\r\n      return available[1];\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This function checks the amount of an order that has already been filled.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n  */\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    return orderFills[user][hash];\r\n  }\r\n\r\n  /**\r\n  * This function cancels a given order by editing its fill data to the full amount.\r\n  * Requires that the transaction is signed properly.\r\n  * Updates orderFills to the full amountGet\r\n  * Emits a Cancel event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n  */\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    require ((ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == msg.sender));\r\n    orderFills[msg.sender][hash] = amountGet;\r\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n  }\r\n\r\n  \r\n  /**\r\n  * This function handles deposits of Ether into the contract, but allows specification of a user.\r\n  * Note: This is generally used in migration of funds.\r\n  * Note: With the payable modifier, this function accepts Ether.\r\n  */\r\n  function depositForUser(address user) public payable {\r\n    require(user != address(0));\r\n    require(msg.value > 0);\r\n    tokens[0][user] = tokens[0][user].add(msg.value);\r\n  }\r\n  \r\n  /**\r\n  * This function handles deposits of Ethereum based tokens into the contract, but allows specification of a user.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Note: This is generally used in migration of funds.\r\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n  * @param token Ethereum contract address of the token\r\n  * @param amount uint of the amount of the token the user wishes to deposit\r\n  */\r\n  function depositTokenForUser(address token, uint amount, address user) public {\r\n    require(token != address(0));\r\n    require(user != address(0));\r\n    require(amount > 0);\r\n    depositingTokenFlag = true;\r\n    require(IToken(token).transferFrom(msg.sender, this, amount));\r\n    depositingTokenFlag = false;\r\n    tokens[token][user] = tokens[token][user].add(amount);\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalSpecialFeeTakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositTokenForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"amountFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"removeSpecialFeeTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositForUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"testTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeTake_\",\"type\":\"uint256\"}],\"name\":\"changeFeeTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"specialFees\",\"outputs\":[{\"name\":\"exist\",\"type\":\"bool\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"feeTake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"feeTake\",\"type\":\"uint256\"}],\"name\":\"addSpecialFeeTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"availableVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"feeTake\",\"type\":\"uint256\"}],\"name\":\"chnageSpecialFeeTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"},{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"feeTake_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"get\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"give\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"Coinchangex","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b2d2e17addbf654f7a9e4d65975ab715d3022355000000000000000000000000b2d2e17addbf654f7a9e4d65975ab715d30223550000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://872c5e1b2f7c754220377902cbd06f0cfc037d030add88748b2e33f1eea444fb"}]}