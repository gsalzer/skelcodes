{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\ncontract Random {\r\n\r\n    uint public ticketsNum = 0;\r\n    \r\n    mapping(uint => address) internal tickets;\r\n    mapping(uint => bool) internal payed_back;\r\n    \r\n    uint32 public random_num = 0;\r\n \r\n    uint public liveBlocksNumber = 5760;\r\n    uint public startBlockNumber = 0;\r\n    uint public endBlockNumber = 0;\r\n    \r\n    string public constant name = \"Random Daily Lottery\";\r\n    string public constant symbol = \"RND\";\r\n    uint   public constant decimals = 0;\r\n\r\n    uint public constant onePotWei = 10000000000000000; // 1 ticket cost is 0.01 ETH\r\n\r\n    address public inv_contract = 0x1d9Ed8e4c1591384A4b2fbd005ccCBDc58501cc0; // investing contract\r\n    address public rtm_contract = 0x67e5e779bfc7a93374f273dcaefce0db8b3559c2; // team contract\r\n    \r\n    address manager; \r\n    \r\n    uint public winners_count = 0; \r\n    uint public last_winner = 0; \r\n    uint public others_prize = 0;\r\n    \r\n    uint public fee_balance = 0; \r\n    bool public autopayfee = true;\r\n\r\n    // Events\r\n    // This generates a publics event on the blockchain that will notify clients\r\n    \r\n    event Buy(address indexed sender, uint eth); \r\n    event Withdraw(address indexed sender, address to, uint eth); \r\n    event Transfer(address indexed from, address indexed to, uint value); \r\n    event TransferError(address indexed to, uint value); // event (error): sending ETH from the contract was failed\r\n    event PayFee(address _to, uint value);\r\n    \r\n    \r\n    \r\n\r\n    // methods with following modifier can only be called by the manager\r\n    modifier onlyManager() {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n    \r\n\r\n    // constructor\r\n    constructor() public {\r\n        manager = msg.sender;\r\n        startBlockNumber = block.number - 1;\r\n        endBlockNumber = startBlockNumber + liveBlocksNumber;\r\n    }\r\n\r\n\r\n    /// function for straight tickets purchase (sending ETH to the contract address)\r\n\r\n    function() public payable {\r\n        emit Transfer(msg.sender, 0, 0);\r\n        require(block.number < endBlockNumber || msg.value < 1000000000000000000);  \r\n        if (msg.value > 0 && last_winner == 0) { \r\n            uint val =  msg.value / onePotWei;  \r\n            uint i = 0;\r\n            for(i; i < val; i++) { tickets[ticketsNum+i] = msg.sender; }  \r\n            ticketsNum += val;                                    \r\n            emit Buy(msg.sender, msg.value);                      \r\n        }\r\n        if (block.number >= endBlockNumber) { \r\n            EndLottery(); \r\n        }\r\n    }\r\n    \r\n    /// function for ticket sending from owner's address to designated address\r\n    function transfer(address _to, uint _ticketNum) public {    \r\n        require(msg.sender == tickets[_ticketNum] && _to != address(0));\r\n        tickets[_ticketNum] = _to;\r\n        emit Transfer(msg.sender, _to, _ticketNum);\r\n    }\r\n\r\n\r\n    /// manager's opportunity to write off ETH from the contract, in a case of unforseen contract blocking (possible in only case of more than 24 hours from the moment of lottery ending had passed and a new one has not started)\r\n    function manager_withdraw() onlyManager public {\r\n        require(block.number >= endBlockNumber + liveBlocksNumber);\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    /// lottery ending  \r\n    function EndLottery() public payable returns (bool success) {\r\n        require(block.number >= endBlockNumber); \r\n        uint tn = ticketsNum;\r\n        if(tn < 3) { \r\n            tn = 0;\r\n            if(msg.value > 0) { msg.sender.transfer(msg.value); }  \r\n            startNewDraw(0);\r\n            return false;\r\n        }\r\n        uint pf = prizeFund(); \r\n        uint jp1 = percent(pf, 10);\r\n        uint jp2 = percent(pf, 4);\r\n        uint jp3 = percent(pf, 1);\r\n        uint lastbet_prize = onePotWei*10;  \r\n\r\n        if(tn < 100) { lastbet_prize = onePotWei; }\r\n        \r\n        if(last_winner == 0) { \r\n            \r\n            winners_count = percent(tn, 4) + 3; \r\n\r\n            uint prizes = jp1 + jp2 + jp3 + lastbet_prize*2; \r\n            \r\n            uint full_prizes = jp1 + jp2 + jp3 + ( lastbet_prize * (winners_count+1)/10 );\r\n            \r\n            if(winners_count < 10) {\r\n                if(prizes > pf) {\r\n                    others_prize = 0;\r\n                } else {\r\n                    others_prize = pf - prizes;    \r\n                }\r\n            } else {\r\n                if(full_prizes > pf) {\r\n                    others_prize = 0;\r\n                } else {\r\n                    others_prize = pf - full_prizes;    \r\n                }\r\n            }\r\n            sendEth(tickets[getWinningNumber(1)], jp1);\r\n            sendEth(tickets[getWinningNumber(2)], jp2);\r\n            sendEth(tickets[getWinningNumber(3)], jp3);\r\n            last_winner += 3;\r\n            \r\n            sendEth(msg.sender, lastbet_prize + msg.value);\r\n            return true;\r\n        } \r\n        \r\n        if(last_winner < winners_count && others_prize > 0) {\r\n            \r\n            uint val = others_prize / winners_count;\r\n            uint i;\r\n            uint8 cnt = 0;\r\n            for(i = last_winner; i < winners_count; i++) {\r\n                sendEth(tickets[getWinningNumber(i+3)], val);\r\n                cnt++;\r\n                if(cnt >= 9) {\r\n                    last_winner = i;\r\n                    return true;\r\n                }\r\n            }\r\n            last_winner = i;\r\n            if(cnt < 9) { \r\n                startNewDraw(lastbet_prize + msg.value); \r\n            } else {\r\n                sendEth(msg.sender, lastbet_prize + msg.value);\r\n            }\r\n            return true;\r\n            \r\n        } else {\r\n\r\n            startNewDraw(lastbet_prize + msg.value);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// new draw start\r\n    function startNewDraw(uint _msg_value) internal { \r\n        ticketsNum = 0;\r\n        startBlockNumber = block.number - 1;\r\n        endBlockNumber = startBlockNumber + liveBlocksNumber;\r\n        random_num += 1;\r\n        winners_count = 0;\r\n        last_winner = 0;\r\n        \r\n        fee_balance = subZero(address(this).balance, _msg_value); \r\n        if(msg.value > 0) { sendEth(msg.sender, _msg_value); }\r\n        // fee_balance = address(this).balance;\r\n        \r\n        if(autopayfee) { _payfee(); }\r\n    }\r\n    \r\n    /// sending rewards to the investing, team and marketing contracts \r\n    function payfee() public {   \r\n        require(fee_balance > 0);\r\n        uint val = fee_balance;\r\n        \r\n        RNDInvestor rinv = RNDInvestor(inv_contract);\r\n        rinv.takeEther.value( percent(val, 25) )();\r\n        rtm_contract.transfer( percent(val, 74) );\r\n        fee_balance = 0;\r\n        \r\n        emit PayFee(inv_contract, percent(val, 25) );\r\n        emit PayFee(rtm_contract, percent(val, 74) );\r\n    }\r\n    \r\n    function _payfee() internal {\r\n        if(fee_balance <= 0) { return; }\r\n        uint val = fee_balance;\r\n        \r\n        RNDInvestor rinv = RNDInvestor(inv_contract);\r\n        rinv.takeEther.value( percent(val, 25) )();\r\n        rtm_contract.transfer( percent(val, 74) );\r\n        fee_balance = 0;\r\n        \r\n        emit PayFee(inv_contract, percent(val, 25) );\r\n        emit PayFee(rtm_contract, percent(val, 74) );\r\n    }\r\n    \r\n    /// function for sending ETH with balance check (does not interrupt the program if balance is not sufficient)\r\n    function sendEth(address _to, uint _val) internal returns(bool) {\r\n        if(address(this).balance < _val) {\r\n            emit TransferError(_to, _val);\r\n            return false;\r\n        }\r\n        _to.transfer(_val);\r\n        emit Withdraw(address(this), _to, _val);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /// get winning ticket number basing on block hasg (block number is being calculated basing on specified displacement)\r\n    function getWinningNumber(uint _blockshift) internal constant returns (uint) {\r\n        return uint(blockhash(endBlockNumber - _blockshift)) % ticketsNum + 1;  \r\n    }\r\n    \r\n\r\n    /// current amount of jack pot 1\r\n    function jackPotA() public view returns (uint) {  \r\n        return percent(prizeFund(), 10);\r\n    }\r\n    \r\n    /// current amount of jack pot 2\r\n    function jackPotB() public view returns (uint) {\r\n        return percent(prizeFund(), 4);\r\n    }\r\n    \r\n\r\n    /// current amount of jack pot 3\r\n    function jackPotC() public view returns (uint) {\r\n        return percent(prizeFund(), 1);\r\n    }\r\n\r\n    /// current amount of prize fund\r\n    function prizeFund() public view returns (uint) {\r\n        return ( (ticketsNum * onePotWei) / 100 ) * 90;\r\n    }\r\n\r\n    /// function for calculating definite percent of a number\r\n    function percent(uint _val, uint _percent) public pure returns (uint) {\r\n        return ( _val * _percent ) / 100;\r\n    }\r\n\r\n\r\n    /// returns owner address using ticket number\r\n    function getTicketOwner(uint _num) public view returns (address) { \r\n        if(ticketsNum == 0) {\r\n            return 0;\r\n        }\r\n        return tickets[_num];\r\n    }\r\n\r\n    /// returns amount of tickets for the current draw in the possession of specified address\r\n    function getTicketsCount(address _addr) public view returns (uint) {\r\n        if(ticketsNum == 0) {\r\n            return 0;\r\n        }\r\n        uint num = 0;\r\n        for(uint i = 0; i < ticketsNum; i++) {\r\n            if(tickets[i] == _addr) {\r\n                num++;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n    \r\n    /// returns amount of tickets for the current draw in the possession of specified address\r\n    function balanceOf(address _addr) public view returns (uint) {\r\n        if(ticketsNum == 0) {\r\n            return 0;\r\n        }\r\n        uint num = 0;\r\n        for(uint i = 0; i < ticketsNum; i++) {\r\n            if(tickets[i] == _addr) {\r\n                num++;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n    \r\n    /// returns tickets numbers for the current draw in the possession of specified address\r\n    function getTicketsAtAdress(address _address) public view returns(uint[]) {\r\n        uint[] memory result = new uint[](getTicketsCount(_address)); \r\n        uint num = 0;\r\n        for(uint i = 0; i < ticketsNum; i++) {\r\n            if(tickets[i] == _address) {\r\n                result[num] = i;\r\n                num++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    /// returns amount of paid rewards for the current draw\r\n    function getLastWinner() public view returns(uint) {\r\n        return last_winner+1;\r\n    }\r\n\r\n\r\n    // /// investing contract address change\r\n    // function setInvContract(address _addr) onlyManager public {\r\n    //     inv_contract = _addr;\r\n    // }\r\n\r\n    /// team contract address change\r\n    function setRtmContract(address _addr) onlyManager public {\r\n        rtm_contract = _addr;\r\n    }\r\n    \r\n    function setAutoPayFee(bool _auto) onlyManager public {\r\n        autopayfee = _auto;\r\n    }\r\n\r\n   \r\n    function contractBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    function blockLeft() public view returns (uint256) {\r\n        if(endBlockNumber > block.number) {\r\n            return endBlockNumber - block.number;    \r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /// method for direct contract replenishment with ETH\r\n    function deposit() public payable {\r\n        require(msg.value > 0);\r\n    }\r\n\r\n\r\n\r\n    ///Math functions\r\n\r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function subZero(uint a, uint b) internal pure returns (uint) {\r\n        if(a < b) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c>=a && c>=b);\r\n        return c;\r\n    }\r\n    \r\n    \r\n    function destroy() public onlyManager {\r\n        selfdestruct(manager);\r\n    }\r\n    \r\n\r\n}\r\n\r\n\r\n/**\r\n* @title Random Investor Contract\r\n* @dev The Investor token contract\r\n*/\r\n\r\ncontract RNDInvestor {\r\n   \r\n    address public owner; // Token owner address\r\n    mapping (address => uint256) public balances; // balanceOf\r\n    address[] public addresses;\r\n\r\n    mapping (address => uint256) public debited;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    string public standard = 'Random 1.1';\r\n    string public constant name = \"Random Investor Token\";\r\n    string public constant symbol = \"RINVEST\";\r\n    uint   public constant decimals = 0;\r\n    uint   public constant totalSupply = 2500;\r\n    uint   public raised = 0;\r\n\r\n    uint public ownerPrice = 1 ether;\r\n    uint public soldAmount = 0; // current sold amount (for current state)\r\n    bool public buyAllowed = true;\r\n    bool public transferAllowed = false;\r\n    \r\n    State public current_state; // current token state\r\n    \r\n    // States\r\n    enum State {\r\n        Presale,\r\n        ICO,\r\n        Public\r\n    }\r\n\r\n    //\r\n    // Events\r\n    // This generates a publics event on the blockchain that will notify clients\r\n    \r\n    event Sent(address from, address to, uint amount);\r\n    event Buy(address indexed sender, uint eth, uint fbt);\r\n    event Withdraw(address indexed sender, address to, uint eth);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Raised(uint _value);\r\n    event StateSwitch(State newState);\r\n    \r\n    //\r\n    // Modifiers\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfAllowed() {\r\n        if(!transferAllowed) { require(msg.sender == owner); }\r\n        _;\r\n    }\r\n\r\n    //\r\n    // Functions\r\n    // \r\n\r\n    // Constructor\r\n    function RNDInvestor() public {\r\n        owner = msg.sender;\r\n        balances[owner] = totalSupply;\r\n    }\r\n\r\n    // fallback function\r\n    function() payable public {\r\n        if(current_state == State.Public) {\r\n            takeEther();\r\n            return;\r\n        }\r\n        \r\n        require(buyAllowed);\r\n        require(msg.value >= ownerPrice);\r\n        require(msg.sender != owner);\r\n        \r\n        uint wei_value = msg.value;\r\n\r\n        // uint tokens = safeMul(wei_value, ownerPrice);\r\n        uint tokens = wei_value / ownerPrice;\r\n        uint cost = tokens * ownerPrice;\r\n        \r\n        if(current_state == State.Presale) {\r\n            tokens = tokens * 2;\r\n        }\r\n        \r\n        uint currentSoldAmount = safeAdd(tokens, soldAmount);\r\n\r\n        if (current_state == State.Presale) {\r\n            require(currentSoldAmount <= 1000);\r\n        }\r\n        \r\n        require(balances[owner] >= tokens);\r\n        \r\n        balances[owner] = safeSub(balances[owner], tokens);\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);\r\n        soldAmount = safeAdd(soldAmount, tokens);\r\n        \r\n        uint extra_ether = safeSub(msg.value, cost); \r\n        if(extra_ether > 0) {\r\n            msg.sender.transfer(extra_ether);\r\n        }\r\n    }\r\n    \r\n    \r\n    function takeEther() payable public {\r\n        if(msg.value > 0) {\r\n            raised += msg.value;\r\n            emit Raised(msg.value);\r\n        } else {\r\n            withdraw();\r\n        }\r\n    }\r\n    \r\n    function setOwnerPrice(uint _newPrice) public\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        ownerPrice = _newPrice;\r\n        return true;\r\n    }\r\n    \r\n    function setTokenState(State _nextState) public\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        bool canSwitchState\r\n            =  (current_state == State.Presale && _nextState == State.ICO)\r\n            || (current_state == State.Presale && _nextState == State.Public)\r\n            || (current_state == State.ICO && _nextState == State.Public) ;\r\n\r\n        require(canSwitchState);\r\n        \r\n        current_state = _nextState;\r\n\r\n        emit StateSwitch(_nextState);\r\n\r\n        return true;\r\n    }\r\n    \r\n    function setBuyAllowed(bool _allowed) public\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        buyAllowed = _allowed;\r\n        return true;\r\n    }\r\n    \r\n    function allowTransfer() public\r\n        onlyOwner\r\n        returns (bool success)\r\n    {\r\n        transferAllowed = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      if (newOwner != address(0)) {\r\n        owner = newOwner;\r\n      }\r\n    }\r\n\r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function withdraw() public returns (bool success) {\r\n        uint val = ethBalanceOf(msg.sender);\r\n        if(val > 0) {\r\n            msg.sender.transfer(val);\r\n            debited[msg.sender] += val;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n\r\n    function ethBalanceOf(address _investor) public view returns (uint256 balance) {\r\n        uint val = (raised / totalSupply) * balances[_investor];\r\n        if(val >= debited[_investor]) {\r\n            return val - debited[_investor];\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\n    function manager_withdraw() onlyOwner public {\r\n        uint summ = 0;\r\n        for(uint i = 0; i < addresses.length; i++) {\r\n            summ += ethBalanceOf(addresses[i]);\r\n        }\r\n        require(summ < address(this).balance);\r\n        msg.sender.transfer(address(this).balance - summ);\r\n    }\r\n\r\n    \r\n    function manual_withdraw() public {\r\n        for(uint i = 0; i < addresses.length; i++) {\r\n            addresses[i].transfer( ethBalanceOf(addresses[i]) );\r\n        }\r\n    }\r\n\r\n\r\n    function checkAddress(address _addr) public\r\n        returns (bool have_addr)\r\n    {\r\n        for(uint i=0; i<addresses.length; i++) {\r\n            if(addresses[i] == _addr) {\r\n                return true;\r\n            }\r\n        }\r\n        addresses.push(_addr);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function destroy() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n\r\n    /**\r\n     * ERC 20 token functions\r\n     *\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     */\r\n    \r\n    function transfer(address _to, uint256 _value) public\r\n        onlyIfAllowed\r\n        returns (bool success) \r\n    {\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            checkAddress(_to);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public\r\n        onlyIfAllowed\r\n        returns (bool success)\r\n    {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            checkAddress(_to);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public\r\n        constant returns (uint256 remaining)\r\n    {\r\n      return allowed[_owner][_spender];\r\n    }\r\n    \r\n    \r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"jackPotB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rtm_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackPotA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"},{\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"percent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTicketsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liveBlocksNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setRtmContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"others_prize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onePotWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inv_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_winner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autopayfee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_ticketNum\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"getTicketOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackPotC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"EndLottery\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manager_withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketsNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payfee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"random_num\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auto\",\"type\":\"bool\"}],\"name\":\"setAutoPayFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTicketsAtAdress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winners_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PayFee\",\"type\":\"event\"}]","ContractName":"Random","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://125a3f374f4e18c1fe41e568178109814d2e6a11996004f3e51344d52681835b"}]}