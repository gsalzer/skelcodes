{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * How addresses of non ERC20 coins were defined:\r\n * address(web3.sha3(coin_symbol_in_upper_case))\r\n * \r\n * Example for BTC:\r\n * web3.sha3('BTC') = 0xe98e2830be1a7e4156d656a7505e65d08c67660dc618072422e9c78053c261e9\r\n * address(0xe98e2830be1a7e4156d656a7505e65d08c67660dc618072422e9c78053c261e9) = 0x505e65d08c67660dc618072422e9c78053c261e9\r\n */\r\ncontract CoinLib {\r\n    \r\n    // Bitcoin and forks:\r\n    address public constant btc = address(0xe98e2830be1a7e4156d656a7505e65d08c67660dc618072422e9c78053c261e9);\r\n    address public constant bch = address(0xc157673705e9a7d6253fb36c51e0b2c9193b9b560fd6d145bd19ecdf6b3a873b);\r\n    address public constant btg = address(0x4e5f418e667aa2b937135735d3deb218f913284dd429fa56a60a2a8c2d913f6c);\r\n    \r\n    // Ethereum and forks:\r\n    address public constant eth = address(0xaaaebeba3810b1e6b70781f14b2d72c1cb89c0b2b320c43bb67ff79f562f5ff4);\r\n    address public constant etc = address(0x49b019f3320b92b2244c14d064de7e7b09dbc4c649e8650e7aa17e5ce7253294);\r\n    \r\n    // Bitcoin relatives:\r\n    address public constant ltc = address(0xfdd18b7aa4e2107a72f3310e2403b9bd7ace4a9f01431002607b3b01430ce75d);\r\n    address public constant doge = address(0x9a3f52b1b31ae58da40209f38379e78c3a0756495a0f585d0b3c84a9e9718f9d);\r\n    \r\n    // Anons/privacy coins: \r\n    address public constant dash = address(0x279c8d120dfdb1ac051dfcfe9d373ee1d16624187fd2ed07d8817b7f9da2f07b);\r\n    address public constant xmr = address(0x8f7631e03f6499d6370dbfd69bc9be2ac2a84e20aa74818087413a5c8e085688);\r\n    address public constant zec = address(0x85118a02446a6ea7372cee71b5fc8420a3f90277281c88f5c237f3edb46419a6);\r\n    address public constant bcn = address(0x333433c3d35b6491924a29fbd93a9852a3c64d3d5b9229c073a047045d57cbe4);\r\n    address public constant pivx = address(0xa8b003381bf1e14049ab83186dd79e07408b0884618bc260f4e76ccd730638c7);\r\n    \r\n    // Smart contracts:\r\n    address public constant ada = address(0x4e1e6d8aa1ff8f43f933718e113229b0ec6b091b699f7a8671bcbd606da36eea);\r\n    address public constant xem = address(0x5f83a7d8f46444571fbbd0ea2d2613ab294391cb1873401ac6090df731d949e5);\r\n    address public constant neo = address(0x6dc5790d7c4bfaaa2e4f8e2cd517bacd4a3831f85c0964e56f2743cbb847bc46);\r\n    address public constant eos = 0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0; // Address of ERC20 token.\r\n    \r\n    address[] internal oldSchool = [btc, ltc, eth, dash];\r\n    address[] internal btcForks = [btc, bch, btg];\r\n    address[] internal smart = [eth, ada, eos, xem];\r\n    address[] internal anons = [dash, xmr, zec, bcn];\r\n    \r\n    function getBtcForkCoins() public view returns (address[]) {\r\n        return btcForks;\r\n    }\r\n    \r\n    function getOldSchoolCoins() public view returns (address[]) {\r\n        return oldSchool;\r\n    }\r\n    \r\n    function getPrivacyCoins() public view returns (address[]) {\r\n        return anons;\r\n    }\r\n    \r\n    function getSmartCoins() public view returns (address[]) {\r\n        return smart;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract SuperOwners {\r\n\r\n    address public owner1;\r\n    address public pendingOwner1;\r\n    \r\n    address public owner2;\r\n    address public pendingOwner2;\r\n\r\n    function SuperOwners(address _owner1, address _owner2) internal {\r\n        require(_owner1 != address(0));\r\n        owner1 = _owner1;\r\n        \r\n        require(_owner2 != address(0));\r\n        owner2 = _owner2;\r\n    }\r\n\r\n    modifier onlySuperOwner1() {\r\n        require(msg.sender == owner1);\r\n        _;\r\n    }\r\n    \r\n    modifier onlySuperOwner2() {\r\n        require(msg.sender == owner2);\r\n        _;\r\n    }\r\n    \r\n    /** Any of the owners can execute this. */\r\n    modifier onlySuperOwner() {\r\n        require(isSuperOwner(msg.sender));\r\n        _;\r\n    }\r\n    \r\n    /** Is msg.sender any of the owners. */\r\n    function isSuperOwner(address _addr) public view returns (bool) {\r\n        return _addr == owner1 || _addr == owner2;\r\n    }\r\n\r\n    /** \r\n     * Safe transfer of ownership in 2 steps. Once called, a newOwner needs \r\n     * to call claimOwnership() to prove ownership.\r\n     */\r\n    function transferOwnership1(address _newOwner1) onlySuperOwner1 public {\r\n        pendingOwner1 = _newOwner1;\r\n    }\r\n    \r\n    function transferOwnership2(address _newOwner2) onlySuperOwner2 public {\r\n        pendingOwner2 = _newOwner2;\r\n    }\r\n\r\n    function claimOwnership1() public {\r\n        require(msg.sender == pendingOwner1);\r\n        owner1 = pendingOwner1;\r\n        pendingOwner1 = address(0);\r\n    }\r\n    \r\n    function claimOwnership2() public {\r\n        require(msg.sender == pendingOwner2);\r\n        owner2 = pendingOwner2;\r\n        pendingOwner2 = address(0);\r\n    }\r\n}\r\n\r\ncontract MultiOwnable is SuperOwners {\r\n\r\n    mapping (address => bool) public ownerMap;\r\n    address[] public ownerHistory;\r\n\r\n    event OwnerAddedEvent(address indexed _newOwner);\r\n    event OwnerRemovedEvent(address indexed _oldOwner);\r\n\r\n    function MultiOwnable(address _owner1, address _owner2) \r\n        SuperOwners(_owner1, _owner2) internal {}\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isOwner(address owner) public view returns (bool) {\r\n        return isSuperOwner(owner) || ownerMap[owner];\r\n    }\r\n    \r\n    function ownerHistoryCount() public view returns (uint) {\r\n        return ownerHistory.length;\r\n    }\r\n\r\n    // Add extra owner\r\n    function addOwner(address owner) onlySuperOwner public {\r\n        require(owner != address(0));\r\n        require(!ownerMap[owner]);\r\n        ownerMap[owner] = true;\r\n        ownerHistory.push(owner);\r\n        OwnerAddedEvent(owner);\r\n    }\r\n\r\n    // Remove extra owner\r\n    function removeOwner(address owner) onlySuperOwner public {\r\n        require(ownerMap[owner]);\r\n        ownerMap[owner] = false;\r\n        OwnerRemovedEvent(owner);\r\n    }\r\n}\r\n\r\ncontract Pausable is MultiOwnable {\r\n\r\n    bool public paused;\r\n\r\n    modifier ifNotPaused {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier ifPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    // Called by the owner on emergency, triggers paused state\r\n    function pause() external onlySuperOwner {\r\n        paused = true;\r\n    }\r\n\r\n    // Called by the owner on end of emergency, returns to normal state\r\n    function resume() external onlySuperOwner ifPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    \r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract StandardToken is ERC20 {\r\n    \r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint256) balances;\r\n    \r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n        \r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        \r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns number of allowed tokens for given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract CommonToken is StandardToken, MultiOwnable {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals = 18;\r\n    string public version = 'v0.1';\r\n\r\n    address public seller;     // The main account that holds all tokens at the beginning and during tokensale.\r\n\r\n    uint256 public saleLimit;  // (e18) How many tokens can be sold in total through all tiers or tokensales.\r\n    uint256 public tokensSold; // (e18) Number of tokens sold through all tiers or tokensales.\r\n    uint256 public totalSales; // Total number of sales (including external sales) made through all tiers or tokensales.\r\n\r\n    // Lock the transfer functions during tokensales to prevent price speculations.\r\n    bool public locked = true;\r\n    \r\n    event SellEvent(address indexed _seller, address indexed _buyer, uint256 _value);\r\n    event ChangeSellerEvent(address indexed _oldSeller, address indexed _newSeller);\r\n    event Burn(address indexed _burner, uint256 _value);\r\n    event Unlock();\r\n\r\n    function CommonToken(\r\n        address _owner1,\r\n        address _owner2,\r\n        address _seller,\r\n        string _name,\r\n        string _symbol,\r\n        uint256 _totalSupplyNoDecimals,\r\n        uint256 _saleLimitNoDecimals\r\n    ) MultiOwnable(_owner1, _owner2) public {\r\n\r\n        require(_seller != address(0));\r\n        require(_totalSupplyNoDecimals > 0);\r\n        require(_saleLimitNoDecimals > 0);\r\n\r\n        seller = _seller;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _totalSupplyNoDecimals * 1e18;\r\n        saleLimit = _saleLimitNoDecimals * 1e18;\r\n        balances[seller] = totalSupply;\r\n\r\n        Transfer(0x0, seller, totalSupply);\r\n    }\r\n    \r\n    modifier ifUnlocked(address _from, address _to) {\r\n        require(!locked || isOwner(_from) || isOwner(_to));\r\n        _;\r\n    }\r\n    \r\n    /** Can be called once by super owner. */\r\n    function unlock() onlySuperOwner public {\r\n        require(locked);\r\n        locked = false;\r\n        Unlock();\r\n    }\r\n\r\n    function changeSeller(address newSeller) onlySuperOwner public returns (bool) {\r\n        require(newSeller != address(0));\r\n        require(seller != newSeller);\r\n\r\n        address oldSeller = seller;\r\n        uint256 unsoldTokens = balances[oldSeller];\r\n        balances[oldSeller] = 0;\r\n        balances[newSeller] = balances[newSeller].add(unsoldTokens);\r\n        Transfer(oldSeller, newSeller, unsoldTokens);\r\n\r\n        seller = newSeller;\r\n        ChangeSellerEvent(oldSeller, newSeller);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function sellNoDecimals(address _to, uint256 _value) public returns (bool) {\r\n        return sell(_to, _value * 1e18);\r\n    }\r\n\r\n    function sell(address _to, uint256 _value) onlyOwner public returns (bool) {\r\n\r\n        // Check that we are not out of limit and still can sell tokens:\r\n        require(tokensSold.add(_value) <= saleLimit);\r\n\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(_value <= balances[seller]);\r\n\r\n        balances[seller] = balances[seller].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(seller, _to, _value);\r\n\r\n        totalSales++;\r\n        tokensSold = tokensSold.add(_value);\r\n        SellEvent(seller, _to, _value);\r\n\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Until all tokens are sold, tokens can be transfered to/from owner's accounts.\r\n     */\r\n    function transfer(address _to, uint256 _value) ifUnlocked(msg.sender, _to) public returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * Until all tokens are sold, tokens can be transfered to/from owner's accounts.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) ifUnlocked(_from, _to) public returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool) {\r\n        require(_value > 0);\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value) ;\r\n        totalSupply = totalSupply.sub(_value);\r\n        Transfer(msg.sender, 0x0, _value);\r\n        Burn(msg.sender, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract RaceToken is CommonToken {\r\n    \r\n    function RaceToken() CommonToken(\r\n        0x229B9Ef80D25A7e7648b17e2c598805d042f9e56, // __OWNER1__\r\n        0xcd7cF1D613D5974876AfBfd612ED6AFd94093ce7, // __OWNER2__\r\n        0x2821e1486D604566842FF27F626aF133FddD5f89, // __SELLER__\r\n        'Coin Race',\r\n        'RACE',\r\n        100 * 1e6, // 100m tokens in total.\r\n        70 * 1e6   // 70m tokens for sale.\r\n    ) public {}\r\n}\r\n\r\nlibrary RaceCalc {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    // Calc a stake of a driver based on his current time.\r\n    // We use linear regression, so the more time passed since \r\n    // the start of the race, the less stake of a final reward he will receive.\r\n    function calcStake(\r\n        uint _currentTime, // Example: 1513533600 - 2017-12-17 18:00:00 UTC\r\n        uint _finishTime   // Example: 1513537200 - 2017-12-17 19:00:00 UTC\r\n    ) public pure returns (uint) {\r\n        \r\n        require(_currentTime > 0);\r\n        require(_currentTime < _finishTime);\r\n        \r\n        return _finishTime.sub(_currentTime);\r\n    }\r\n    \r\n    // Calc gain of car at the finish of a race.\r\n    // Result can be negative.\r\n    // 100% is represented as 10^8 to be more precious.\r\n    function calcGainE8(\r\n        uint _startRateToUsdE8, // Example: 345\r\n        uint _finishRateToUsdE8 // Example: 456\r\n    ) public pure returns (int) {\r\n        \r\n        require(_startRateToUsdE8 > 0);\r\n        require(_finishRateToUsdE8 > 0);\r\n        \r\n        int diff = int(_finishRateToUsdE8) - int(_startRateToUsdE8);\r\n        return (diff * 1e8) / int(_startRateToUsdE8);\r\n    }\r\n    \r\n    function calcPrizeTokensE18(\r\n        uint totalTokens, \r\n        uint winningStake, \r\n        uint driverStake\r\n    ) public pure returns (uint) {\r\n        \r\n        if (totalTokens == 0) return 0;\r\n        if (winningStake == 0) return 0;\r\n        if (driverStake == 0) return 0;\r\n        if (winningStake == driverStake) return totalTokens;\r\n        \r\n        require(winningStake > driverStake);\r\n        uint share = driverStake.mul(1e8).div(winningStake);\r\n        return totalTokens.mul(share).div(1e8);\r\n    }\r\n}\r\n\r\n/** \r\n * Here we implement all token methods that require msg.sender to be albe \r\n * to perform operations on behalf of GameWallet from other CoinRace contracts \r\n * like a particular contract of RaceGame.\r\n */\r\ncontract CommonWallet is MultiOwnable {\r\n    \r\n    RaceToken public token;\r\n    \r\n    event ChangeTokenEvent(address indexed _oldAddress, address indexed _newAddress);\r\n    \r\n    function CommonWallet(address _owner1, address _owner2) \r\n        MultiOwnable(_owner1, _owner2) public {}\r\n    \r\n    function setToken(address _token) public onlySuperOwner {\r\n        require(_token != 0);\r\n        require(_token != address(token));\r\n        \r\n        ChangeTokenEvent(token, _token);\r\n        token = RaceToken(_token);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) onlyOwner public returns (bool) {\r\n        return token.transfer(_to, _value);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool) {\r\n        return token.transferFrom(_from, _to, _value);\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) onlyOwner public returns (bool) {\r\n        return token.approve(_spender, _value);\r\n    }\r\n    \r\n    function burn(uint256 _value) onlySuperOwner public returns (bool) {\r\n        return token.burn(_value);\r\n    }\r\n    \r\n    /** Amount of tokens that players of CoinRace bet during the games and haven't claimed yet. */\r\n    function balance() public view returns (uint256) {\r\n        return token.balanceOf(this);\r\n    }\r\n    \r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return token.balanceOf(_owner);\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return token.allowance(_owner, _spender);\r\n    }\r\n}\r\n\r\ncontract GameWallet is CommonWallet {\r\n    \r\n    function GameWallet() CommonWallet(\r\n        0x229B9Ef80D25A7e7648b17e2c598805d042f9e56, // __OWNER1__\r\n        0xcd7cF1D613D5974876AfBfd612ED6AFd94093ce7  // __OWNER2__\r\n    ) public {}\r\n}\r\n\r\nlibrary RaceLib {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    function makeBet(\r\n        Race storage _race, \r\n        address _driver, \r\n        address _car, \r\n        uint _tokensE18\r\n    ) public {\r\n        require(!isFinished(_race));\r\n        \r\n        var bet = Bet({\r\n            driver: _driver,\r\n            car: _car,\r\n            tokens: _tokensE18,\r\n            time: now\r\n        });\r\n\r\n        _race.betsByDriver[_driver].push(bet);\r\n        _race.betsByCar[_car].push(bet);\r\n            \r\n        if (_race.tokensByCarAndDriver[_car][_driver] == 0) {\r\n            _race.driverCountByCar[_car] = _race.driverCountByCar[_car] + 1;\r\n        }\r\n        \r\n        _race.tokensByCar[_car] = _race.tokensByCar[_car].add(_tokensE18);\r\n        _race.tokensByCarAndDriver[_car][_driver] = \r\n            _race.tokensByCarAndDriver[_car][_driver].add(_tokensE18);\r\n        \r\n        uint stakeTime = bet.time;\r\n        if (bet.time < _race.leftGraceTime && _race.leftGraceTime > 0) stakeTime = _race.leftGraceTime;\r\n        if (bet.time > _race.rightGraceTime && _race.rightGraceTime > 0) stakeTime = _race.rightGraceTime;\r\n        uint stake = RaceCalc.calcStake(stakeTime, _race.finishTime);\r\n        _race.stakeByCar[_car] = _race.stakeByCar[_car].add(stake);\r\n        _race.stakeByCarAndDriver[_car][_driver] = \r\n            _race.stakeByCarAndDriver[_car][_driver].add(stake);\r\n        \r\n        _race.totalTokens = _race.totalTokens.add(_tokensE18);\r\n    }\r\n    \r\n    function hasDriverJoined(\r\n        Race storage _race, \r\n        address _driver\r\n    ) public view returns (bool) {\r\n        return betCountByDriver(_race, _driver) > 0;\r\n    }\r\n    \r\n    function betCountByDriver(\r\n        Race storage _race, \r\n        address _driver\r\n    ) public view returns (uint) {\r\n        return _race.betsByDriver[_driver].length;\r\n    }\r\n    \r\n    function betCountByCar(\r\n        Race storage _race, \r\n        address _car\r\n    ) public view returns (uint) {\r\n        return _race.betsByCar[_car].length;\r\n    }\r\n    \r\n    function startCar(\r\n        Race storage _race, \r\n        address _car,\r\n        uint _rateToUsdE8\r\n    ) public {\r\n        require(_rateToUsdE8 > 0);\r\n        require(_race.carRates[_car].startRateToUsdE8 == 0);\r\n        _race.carRates[_car].startRateToUsdE8 = _rateToUsdE8;\r\n    }\r\n    \r\n    function finish(\r\n        Race storage _race\r\n    ) public {\r\n        require(!_race.finished);\r\n        require(now >= _race.finishTime);\r\n        _race.finished = true;\r\n    }\r\n    \r\n    function isFinished(\r\n        Race storage _race\r\n    ) public view returns (bool) {\r\n        return _race.finished;\r\n    }\r\n    \r\n    struct Race {\r\n        \r\n        uint id;\r\n        \r\n        uint leftGraceTime;\r\n        \r\n        uint rightGraceTime;\r\n        \r\n        uint startTime;\r\n        \r\n        uint finishTime;\r\n        \r\n        bool finished;\r\n        \r\n        uint finishedCarCount;\r\n        \r\n        // 0 - if race is not finished yet.\r\n        address firstCar;\r\n        \r\n        // Total amount of tokens tha thave been bet on all cars during the race: \r\n        uint totalTokens;\r\n        \r\n        uint driverCount;\r\n        \r\n        // num of driver => driver's address.\r\n        mapping (uint => address) drivers;\r\n        \r\n        // car_address => total_drivers_that_made_bet_on_this_car\r\n        mapping (address => uint) driverCountByCar;\r\n        \r\n        // driver_address => bets by driver\r\n        mapping (address => Bet[]) betsByDriver;\r\n        \r\n        // car_address => bets on this car.\r\n        mapping (address => Bet[]) betsByCar;\r\n        \r\n        // car_address => total_tokens_bet_on_this_car\r\n        mapping (address => uint) tokensByCar;\r\n        \r\n        // car_address => driver_address => total_tokens_bet_on_this_car_by_this_driver\r\n        mapping (address => mapping (address => uint)) tokensByCarAndDriver;\r\n\r\n        // car_address => stake_by_all_drivers\r\n        mapping (address => uint) stakeByCar;\r\n\r\n        // car_address => driver_address => stake\r\n        mapping (address => mapping (address => uint)) stakeByCarAndDriver;\r\n\r\n        // car_address => its rates to USD.\r\n        mapping (address => CarRates) carRates;\r\n\r\n        // int because it can be negative value if finish rate is lower.\r\n        mapping (address => int) gainByCar;\r\n        \r\n        mapping (address => bool) isFinishedCar;\r\n        \r\n        // driver_address => amount of tokens (e18) that have been claimed by driver.\r\n        mapping (address => uint) tokensClaimedByDriver;\r\n    }\r\n    \r\n    struct Bet {\r\n        address driver;\r\n        address car;\r\n        uint tokens;\r\n        uint time;\r\n    }\r\n    \r\n    struct CarRates {\r\n        uint startRateToUsdE8;\r\n        uint finishRateToUsdE8;\r\n    }\r\n}\r\n\r\ncontract CommonRace is MultiOwnable {\r\n    \r\n    using SafeMath for uint;\r\n    using RaceLib for RaceLib.Race;\r\n    \r\n    GameWallet public wallet;\r\n    \r\n    // The name of the game.\r\n    string public name;\r\n    \r\n    address[] public cars;\r\n    \r\n    mapping (address => bool) public isKnownCar;\r\n    \r\n    RaceLib.Race[] public races;\r\n    \r\n    address[] public drivers;\r\n\r\n    mapping (address => bool) public isKnownDriver;\r\n    \r\n    modifier ifWalletDefined() {\r\n        require(address(wallet) != address(0));\r\n        _;\r\n    }\r\n    \r\n    function CommonRace(\r\n        address _owner1,\r\n        address _owner2,\r\n        address[] _cars,\r\n        string _name\r\n    ) MultiOwnable(_owner1, _owner2) public {\r\n        require(_cars.length > 0);\r\n\r\n        name = _name;\r\n        cars = _cars;\r\n        \r\n        for (uint16 i = 0; i < _cars.length; i++) {\r\n            isKnownCar[_cars[i]] = true;\r\n        }\r\n    }\r\n    \r\n    function getNow() public view returns (uint) {\r\n        return now;\r\n    }\r\n    \r\n    function raceCount() public view returns (uint) {\r\n        return races.length;\r\n    }\r\n    \r\n    function carCount() public view returns (uint) {\r\n        return cars.length;\r\n    }\r\n    \r\n    function driverCount() public view returns (uint) {\r\n        return drivers.length;\r\n    }\r\n    \r\n    function setWallet(address _newWallet) onlySuperOwner public {\r\n        require(wallet != _newWallet);\r\n        require(_newWallet != 0);\r\n        \r\n        GameWallet newWallet = GameWallet(_newWallet);\r\n        wallet = newWallet;\r\n    }\r\n\r\n    function lastLapId() public view returns (uint) {\r\n        require(races.length > 0);\r\n        return races.length - 1;\r\n    }\r\n\r\n    function nextLapId() public view returns (uint) {\r\n        return races.length;\r\n    }\r\n    \r\n    function getRace(uint _lapId) internal view returns (RaceLib.Race storage race) {\r\n        race = races[_lapId];\r\n        require(race.startTime > 0); // if startTime is > 0 then race is real.\r\n    }\r\n    \r\n    /**\r\n     * _durationSecs - A duration of race in seconds.\r\n     * \r\n     * Structure of _carsAndRates:\r\n     *   N-th elem is a car addr.\r\n     *   (N+1)-th elem is car rate.\r\n     */\r\n    function startNewRace(\r\n        uint _newLapId, \r\n        uint[] _carsAndRates,\r\n        uint _durationSecs,\r\n        uint _leftGraceSecs, // How many seconds from the start we should not apply penalty for stake of bet?\r\n        uint _rightGraceSecs // How many seconds before the finish we should not apply penalty for stake of bet?\r\n    ) onlyOwner public {\r\n        require(_newLapId == nextLapId());\r\n        require(_carsAndRates.length == (cars.length * 2));\r\n        require(_durationSecs > 0);\r\n        \r\n        if (_leftGraceSecs > 0) require(_leftGraceSecs <= _durationSecs);\r\n        if (_rightGraceSecs > 0) require(_rightGraceSecs <= _durationSecs);\r\n        \r\n        uint finishTime = now.add(_durationSecs);\r\n        \r\n        races.push(RaceLib.Race({\r\n            id: _newLapId,\r\n            leftGraceTime: now + _leftGraceSecs,\r\n            rightGraceTime: finishTime - _rightGraceSecs,\r\n            startTime: now,\r\n            finishTime: finishTime,\r\n            finished: false,\r\n            finishedCarCount: 0,\r\n            firstCar: 0,\r\n            totalTokens: 0,\r\n            driverCount: 0\r\n        }));\r\n        RaceLib.Race storage race = races[_newLapId];\r\n\r\n        uint8 j = 0;\r\n        for (uint8 i = 0; i < _carsAndRates.length; i += 2) {\r\n            address car = address(_carsAndRates[j++]);\r\n            uint startRateToUsdE8 = _carsAndRates[j++];\r\n            require(isKnownCar[car]);\r\n            race.startCar(car, startRateToUsdE8);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Structure of _carsAndRates:\r\n     *   N-th elem is a car addr.\r\n     *   (N+1)-th elem is car rate.\r\n     */\r\n    function finishRace(\r\n        uint _lapId, \r\n        uint[] _carsAndRates\r\n    ) onlyOwner public {\r\n        require(_carsAndRates.length == (cars.length * 2));\r\n        \r\n        RaceLib.Race storage race = getRace(_lapId);\r\n        race.finish();\r\n        \r\n        int maxGain = 0;\r\n        address firstCar; // The first finished car.\r\n        \r\n        uint8 j = 0;\r\n        for (uint8 i = 0; i < _carsAndRates.length; i += 2) {\r\n            address car = address(_carsAndRates[j++]);\r\n            uint finishRateToUsdE8 = _carsAndRates[j++];\r\n            require(!isCarFinished(_lapId, car));\r\n            \r\n            // Mark car as finished:\r\n            RaceLib.CarRates storage rates = race.carRates[car];\r\n            rates.finishRateToUsdE8 = finishRateToUsdE8;\r\n            race.isFinishedCar[car] = true;\r\n            race.finishedCarCount++;\r\n            \r\n            // Calc gain of car:\r\n            int gain = RaceCalc.calcGainE8(rates.startRateToUsdE8, finishRateToUsdE8);\r\n            race.gainByCar[car] = gain;\r\n            if (i == 0 || gain > maxGain) {\r\n                maxGain = gain;\r\n                firstCar = car;\r\n            }\r\n        }\r\n        \r\n        // The first finished car should be found.\r\n        require(firstCar != 0);\r\n        race.firstCar = firstCar;\r\n    }\r\n    \r\n    function finishRaceThenStartNext(\r\n        uint _lapId, \r\n        uint[] _carsAndRates,\r\n        uint _durationSecs,\r\n        uint _leftGraceSecs, // How many seconds from the start we should not apply penalty for stake of bet?\r\n        uint _rightGraceSecs // How many seconds before the finish we should not apply penalty for stake of bet?\r\n    ) onlyOwner public {\r\n        finishRace(_lapId, _carsAndRates);\r\n        startNewRace(_lapId + 1, _carsAndRates, _durationSecs, _leftGraceSecs, _rightGraceSecs);\r\n    }\r\n    \r\n    function isLastRaceFinsihed() public view returns (bool) {\r\n        return isLapFinished(lastLapId());\r\n    }\r\n    \r\n    function isLapFinished(\r\n        uint _lapId\r\n    ) public view returns (bool) {\r\n        return getRace(_lapId).isFinished();\r\n    }\r\n    \r\n    // Unused func.\r\n    // function shouldFinishLap(\r\n    //     uint _lapId\r\n    // ) public view returns (bool) {\r\n    //     RaceLib.Race storage lap = getRace(_lapId);\r\n    //     // 'now' will not work for Ganache\r\n    //     return !lap.isFinished() && now >= lap.finishTime;\r\n    // }\r\n    \r\n    function lapStartTime(\r\n        uint _lapId\r\n    ) public view returns (uint) {\r\n        return getRace(_lapId).startTime;\r\n    }\r\n    \r\n    function lapFinishTime(\r\n        uint _lapId\r\n    ) public view returns (uint) {\r\n        return getRace(_lapId).finishTime;\r\n    }\r\n    \r\n    function isCarFinished(\r\n        uint _lapId,\r\n        address _car\r\n    ) public view returns (bool) {\r\n        require(isKnownCar[_car]);\r\n        return getRace(_lapId).isFinishedCar[_car];\r\n    }\r\n    \r\n    function allCarsFinished(\r\n        uint _lapId\r\n    ) public view returns (bool) {\r\n        return finishedCarCount(_lapId) == cars.length;\r\n    }\r\n    \r\n    function finishedCarCount(\r\n        uint _lapId\r\n    ) public view returns (uint) {\r\n        return getRace(_lapId).finishedCarCount;\r\n    }\r\n    \r\n    function firstCar(\r\n        uint _lapId\r\n    ) public view returns (address) {\r\n        return getRace(_lapId).firstCar;\r\n    }\r\n    \r\n    function isWinningDriver(\r\n        uint _lapId, \r\n        address _driver\r\n    ) public view returns (bool) {\r\n        RaceLib.Race storage race = getRace(_lapId);\r\n        return race.tokensByCarAndDriver[race.firstCar][_driver] > 0;\r\n    }\r\n    \r\n    /**\r\n     * This is helper function usefull when debugging contract or checking state on Etherscan.\r\n     */\r\n    function myUnclaimedTokens(\r\n        uint _lapId\r\n    ) public view returns (uint) {\r\n        return unclaimedTokens(_lapId, msg.sender);\r\n    }\r\n    \r\n    /** \r\n     * Calculate how much tokens a winning driver can claim once race is over.\r\n     * Claimed tokens will be added back to driver's token balance.\r\n     * Formula = share of all tokens based on bets made on winning car.\r\n     * Tokens in format e18.\r\n     */\r\n    function unclaimedTokens(\r\n        uint _lapId,\r\n        address _driver\r\n    ) public view returns (uint) {\r\n        RaceLib.Race storage race = getRace(_lapId);\r\n        \r\n        // if driver has claimed his tokens already.\r\n        if (race.tokensClaimedByDriver[_driver] > 0) return 0;\r\n        \r\n        if (!race.isFinished()) return 0;\r\n        if (race.firstCar == 0) return 0;\r\n        if (race.totalTokens == 0) return 0;\r\n        if (race.stakeByCar[race.firstCar] == 0) return 0;\r\n        \r\n        // Size of driver's stake on the first finished car.\r\n        uint driverStake = race.stakeByCarAndDriver[race.firstCar][_driver];\r\n        if (driverStake == 0) return 0;\r\n\r\n        return RaceCalc.calcPrizeTokensE18(\r\n            race.totalTokens, \r\n            race.stakeByCar[race.firstCar],\r\n            driverStake\r\n        );\r\n    }\r\n\r\n    function claimTokens(\r\n        uint _lapId\r\n    ) public ifWalletDefined {\r\n        address driver = msg.sender;\r\n        uint tokens = unclaimedTokens(_lapId, driver);\r\n        require(tokens > 0);\r\n        // Transfer prize tokens from game wallet to driver's address:\r\n        require(wallet.transfer(driver, tokens));\r\n        getRace(_lapId).tokensClaimedByDriver[driver] = tokens;\r\n    }\r\n    \r\n    function makeBet(\r\n        uint _lapId,\r\n        address _car, \r\n        uint _tokensE18\r\n    ) public ifWalletDefined {\r\n        address driver = msg.sender;\r\n        require(isKnownCar[_car]);\r\n        \r\n        // NOTE: Remember that driver needs to call Token(address).approve(wallet, tokens) \r\n        // or this contract will not be able to do the transfer on your behalf.\r\n        \r\n        // Transfer tokens from driver to game wallet:\r\n        require(wallet.transferFrom(msg.sender, wallet, _tokensE18));\r\n        getRace(_lapId).makeBet(driver, _car, _tokensE18);\r\n        \r\n        if (!isKnownDriver[driver]) {\r\n            isKnownDriver[driver] = true;\r\n            drivers.push(driver);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Result array format:\r\n     * [\r\n     * N+0: COIN_ADDRESS (ex: 0x0000000000000000000000000000000000012301)\r\n     * N+1: MY_BET_TOKENS_E18\r\n     * ... repeat ...\r\n     * ]\r\n     */\r\n    function myBetsInLap(\r\n        uint _lapId\r\n    ) public view returns (uint[] memory totals) {\r\n        RaceLib.Race storage race = getRace(_lapId);\r\n        totals = new uint[](cars.length * 2);\r\n        uint8 j = 0;\r\n        address car;\r\n        for (uint8 i = 0; i < cars.length; i++) {\r\n            car = cars[i];\r\n            totals[j++] = uint(car);\r\n            totals[j++] = race.tokensByCarAndDriver[car][msg.sender];\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Result array format:\r\n     * [\r\n     * 0: START_DATE_UNIX_TS\r\n     * 1: DURATION_SEC\r\n     * 2: FIRST_CAR_ID\r\n     * 3: !!! NEW !!! MY_UNCLAIMED_TOKENS\r\n     * \r\n     * N+0: COIN_ADDRESS (ex: 0x0000000000000000000000000000000000012301)\r\n     * N+1: START_RATE_E8\r\n     * N+2: END_RATE_E8\r\n     * N+3: DRIVER_COUNT\r\n     * N+4: TOTAL_BET_TOKENS_E18\r\n     * N+5: MY_BET_TOKENS_E18\r\n     * N+6: !!! NEW !!! GAIN_E8\r\n     * ... repeat for each car...\r\n     * ]\r\n     */\r\n    function lapTotals(\r\n        uint _lapId\r\n    ) public view returns (int[] memory totals) {\r\n        RaceLib.Race storage race = getRace(_lapId);\r\n        totals = new int[](5 + cars.length * 7);\r\n        \r\n        uint _myUnclaimedTokens = 0;\r\n        if (isLapFinished(_lapId)) {\r\n            _myUnclaimedTokens = unclaimedTokens(_lapId, msg.sender);\r\n        }\r\n        \r\n        address car;\r\n        uint8 j = 0;\r\n        totals[j++] = int(now);\r\n        totals[j++] = int(race.startTime);\r\n        totals[j++] = int(race.finishTime - race.startTime);\r\n        totals[j++] = int(race.firstCar);\r\n        totals[j++] = int(_myUnclaimedTokens);\r\n        \r\n        for (uint8 i = 0; i < cars.length; i++) {\r\n            car = cars[i];\r\n            totals[j++] = int(car);\r\n            totals[j++] = int(race.carRates[car].startRateToUsdE8);\r\n            totals[j++] = int(race.carRates[car].finishRateToUsdE8);\r\n            totals[j++] = int(race.driverCountByCar[car]);\r\n            totals[j++] = int(race.tokensByCar[car]);\r\n            totals[j++] = int(race.tokensByCarAndDriver[car][msg.sender]);\r\n            totals[j++] = race.gainByCar[car];\r\n        }\r\n    }\r\n}\r\n\r\ncontract RaceOldSchool4h is CommonRace, CoinLib {\r\n    \r\n    function RaceOldSchool4h() CommonRace(\r\n        0x229B9Ef80D25A7e7648b17e2c598805d042f9e56, // __OWNER1__\r\n        0xcd7cF1D613D5974876AfBfd612ED6AFd94093ce7, // __OWNER2__\r\n        oldSchool,\r\n        'Old School'\r\n    ) public {}\r\n}\r\n\r\ncontract RaceBtcForks4h is CommonRace, CoinLib {\r\n    \r\n    function RaceBtcForks4h() CommonRace(\r\n        0x229B9Ef80D25A7e7648b17e2c598805d042f9e56, // __OWNER1__\r\n        0xcd7cF1D613D5974876AfBfd612ED6AFd94093ce7, // __OWNER2__\r\n        btcForks,\r\n        'Bitcoin Forks'\r\n    ) public {}\r\n}\r\n\r\ncontract RaceSmart4h is CommonRace, CoinLib {\r\n    \r\n    function RaceSmart4h() CommonRace(\r\n        0x229B9Ef80D25A7e7648b17e2c598805d042f9e56, // __OWNER1__\r\n        0xcd7cF1D613D5974876AfBfd612ED6AFd94093ce7, // __OWNER2__\r\n        smart,\r\n        'Smart Coins'\r\n    ) public {}\r\n}\r\n\r\ncontract RaceAnons4h is CommonRace, CoinLib {\r\n    \r\n    function RaceAnons4h() CommonRace(\r\n        0x229B9Ef80D25A7e7648b17e2c598805d042f9e56, // __OWNER1__\r\n        0xcd7cF1D613D5974876AfBfd612ED6AFd94093ce7, // __OWNER2__\r\n        anons,\r\n        'Anonymouses'\r\n    ) public {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"myBetsInLap\",\"outputs\":[{\"name\":\"totals\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pivx\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isSuperOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xem\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"isLapFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"lapStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"carCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"},{\"name\":\"_driver\",\"type\":\"address\"}],\"name\":\"isWinningDriver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKnownCar\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBtcForkCoins\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"},{\"name\":\"_driver\",\"type\":\"address\"}],\"name\":\"unclaimedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"doge\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerHistoryCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"lapTotals\",\"outputs\":[{\"name\":\"totals\",\"type\":\"int256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"neo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"},{\"name\":\"_carsAndRates\",\"type\":\"uint256[]\"},{\"name\":\"_durationSecs\",\"type\":\"uint256\"},{\"name\":\"_leftGraceSecs\",\"type\":\"uint256\"},{\"name\":\"_rightGraceSecs\",\"type\":\"uint256\"}],\"name\":\"finishRaceThenStartNext\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"},{\"name\":\"_car\",\"type\":\"address\"},{\"name\":\"_tokensE18\",\"type\":\"uint256\"}],\"name\":\"makeBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ltc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"lapFinishTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dash\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"firstCar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"finishedCarCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"myUnclaimedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrivacyCoins\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLapId\",\"type\":\"uint256\"},{\"name\":\"_carsAndRates\",\"type\":\"uint256[]\"},{\"name\":\"_durationSecs\",\"type\":\"uint256\"},{\"name\":\"_leftGraceSecs\",\"type\":\"uint256\"},{\"name\":\"_rightGraceSecs\",\"type\":\"uint256\"}],\"name\":\"startNewRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"races\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"leftGraceTime\",\"type\":\"uint256\"},{\"name\":\"rightGraceTime\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"finishTime\",\"type\":\"uint256\"},{\"name\":\"finished\",\"type\":\"bool\"},{\"name\":\"finishedCarCount\",\"type\":\"uint256\"},{\"name\":\"firstCar\",\"type\":\"address\"},{\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"name\":\"driverCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"},{\"name\":\"_carsAndRates\",\"type\":\"uint256[]\"}],\"name\":\"finishRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKnownDriver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raceCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eos\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zec\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastLapId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOldSchoolCoins\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"},{\"name\":\"_car\",\"type\":\"address\"}],\"name\":\"isCarFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLastRaceFinsihed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSmartCoins\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bcn\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xmr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner2\",\"type\":\"address\"}],\"name\":\"transferOwnership2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner1\",\"type\":\"address\"}],\"name\":\"transferOwnership1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driverCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cars\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"drivers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextLapId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lapId\",\"type\":\"uint256\"}],\"name\":\"allCarsFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ada\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btg\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAddedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemovedEvent\",\"type\":\"event\"}]","ContractName":"RaceAnons4h","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":":RaceLib:6f4AB47BcbcDEb1767c2323543A85fb3AEaFb4E8;:RaceCalc:15E4f21f9EA93B4723973EBeB8362ae9Aecd9BEA","SwarmSource":"bzzr://cd6aabb06e266f3eac7197d922d104af3ed7e9b7bda4093eff77ca87d308c3eb"}]}