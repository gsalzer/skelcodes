{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n// copyright contact@Etheremon.com\r\n\r\ncontract SafeMath {\r\n\r\n    /* function assert(bool assertion) internal { */\r\n    /*   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract BasicAccessControl {\r\n    address public owner;\r\n    // address[] public moderators;\r\n    uint16 public totalModerators = 0;\r\n    mapping (address => bool) public moderators;\r\n    bool public isMaintaining = false;\r\n\r\n    function BasicAccessControl() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address _newOwner) onlyOwner public {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n\r\n    function AddModerator(address _newModerator) onlyOwner public {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }\r\n    \r\n    function RemoveModerator(address _oldModerator) onlyOwner public {\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }\r\n\r\n    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\r\n        isMaintaining = _isMaintaining;\r\n    }\r\n}\r\n\r\ncontract EtheremonEnum {\r\n\r\n    enum ResultCode {\r\n        SUCCESS,\r\n        ERROR_CLASS_NOT_FOUND,\r\n        ERROR_LOW_BALANCE,\r\n        ERROR_SEND_FAIL,\r\n        ERROR_NOT_TRAINER,\r\n        ERROR_NOT_ENOUGH_MONEY,\r\n        ERROR_INVALID_AMOUNT,\r\n        ERROR_OBJ_NOT_FOUND,\r\n        ERROR_OBJ_INVALID_OWNERSHIP\r\n    }\r\n    \r\n    enum ArrayType {\r\n        CLASS_TYPE,\r\n        STAT_STEP,\r\n        STAT_START,\r\n        STAT_BASE,\r\n        OBJ_SKILL\r\n    }\r\n    \r\n    enum PropertyType {\r\n        ANCESTOR,\r\n        XFACTOR\r\n    }\r\n}\r\n\r\ncontract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {\r\n    \r\n    uint64 public totalMonster;\r\n    uint32 public totalClass;\r\n    \r\n    // write\r\n    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\r\n    function removeElementOfArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\r\n    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);\r\n    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);\r\n    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;\r\n    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\r\n    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\r\n    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\r\n    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\r\n    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);\r\n    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);\r\n    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);\r\n    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\r\n    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\r\n    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;\r\n    \r\n    // read\r\n    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);\r\n    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);\r\n    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\r\n    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\r\n    function getMonsterName(uint64 _objId) constant public returns(string name);\r\n    function getExtraBalance(address _trainer) constant public returns(uint256);\r\n    function getMonsterDexSize(address _trainer) constant public returns(uint);\r\n    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);\r\n    function getExpectedBalance(address _trainer) constant public returns(uint256);\r\n    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);\r\n}\r\n\r\ncontract EtheremonTransformData {\r\n    uint64 public totalEgg = 0;\r\n    function getHatchingEggId(address _trainer) constant external returns(uint64);\r\n    function getHatchingEggData(address _trainer) constant external returns(uint64, uint64, uint32, address, uint, uint64);\r\n    function getTranformedId(uint64 _objId) constant external returns(uint64);\r\n    function countEgg(uint64 _objId) constant external returns(uint);\r\n    \r\n    function setHatchTime(uint64 _eggId, uint _hatchTime) external;\r\n    function setHatchedEgg(uint64 _eggId, uint64 _newObjId) external;\r\n    function addEgg(uint64 _objId, uint32 _classId, address _trainer, uint _hatchTime) external returns(uint64);\r\n    function setTranformed(uint64 _objId, uint64 _newObjId) external;\r\n}\r\n\r\ncontract EtheremonWorld is EtheremonEnum {\r\n    \r\n    function getGen0COnfig(uint32 _classId) constant public returns(uint32, uint256, uint32);\r\n    function getTrainerEarn(address _trainer) constant public returns(uint256);\r\n    function getReturnFromMonster(uint64 _objId) constant public returns(uint256 current, uint256 total);\r\n    function getClassPropertyValue(uint32 _classId, PropertyType _type, uint index) constant external returns(uint32);\r\n    function getClassPropertySize(uint32 _classId, PropertyType _type) constant external returns(uint);\r\n}\r\n\r\ninterface EtheremonBattle {\r\n    function isOnBattle(uint64 _objId) constant external returns(bool);\r\n    function getMonsterLevel(uint64 _objId) constant public returns(uint8);\r\n}\r\n\r\ninterface EtheremonTradeInterface {\r\n    function isOnTrading(uint64 _objId) constant external returns(bool);\r\n}\r\n\r\ncontract EtheremonTransform is EtheremonEnum, BasicAccessControl, SafeMath {\r\n    uint8 constant public STAT_COUNT = 6;\r\n    uint8 constant public STAT_MAX = 32;\r\n    uint8 constant public GEN0_NO = 24;\r\n    \r\n    struct MonsterClassAcc {\r\n        uint32 classId;\r\n        uint256 price;\r\n        uint256 returnPrice;\r\n        uint32 total;\r\n        bool catchable;\r\n    }\r\n\r\n    struct MonsterObjAcc {\r\n        uint64 monsterId;\r\n        uint32 classId;\r\n        address trainer;\r\n        string name;\r\n        uint32 exp;\r\n        uint32 createIndex;\r\n        uint32 lastClaimIndex;\r\n        uint createTime;\r\n    }\r\n    \r\n    struct MonsterEgg {\r\n        uint64 eggId;\r\n        uint64 objId;\r\n        uint32 classId;\r\n        address trainer;\r\n        uint hatchTime;\r\n        uint64 newObjId;\r\n    }\r\n    \r\n    struct BasicObjInfo {\r\n        uint32 classId;\r\n        address owner;\r\n        uint8 level;\r\n    }\r\n    \r\n    // Gen0 has return price & no longer can be caught when this contract is deployed\r\n    struct Gen0Config {\r\n        uint32 classId;\r\n        uint256 originalPrice;\r\n        uint256 returnPrice;\r\n        uint32 total; // total caught (not count those from eggs)\r\n    }\r\n    \r\n    // hatching range\r\n    uint16 public hatchStartTime = 2; // hour\r\n    uint16 public hatchMaxTime = 46; // hour\r\n    uint public removeHatchingTimeFee = 0.05 ether; // ETH\r\n    uint public buyEggFee = 0.06 ether; // ETH\r\n    \r\n    uint32[] public randomClassIds;\r\n    mapping(uint32 => uint8) public layingEggLevels;\r\n    mapping(uint32 => uint8) public layingEggDeductions;\r\n    mapping(uint32 => uint8) public transformLevels;\r\n    mapping(uint32 => uint32) public transformClasses;\r\n\r\n    mapping(uint8 => uint32) public levelExps;\r\n    address private lastHatchingAddress;\r\n    \r\n    mapping(uint32 => Gen0Config) public gen0Config;\r\n    \r\n    // linked smart contract\r\n    address public dataContract;\r\n    address public worldContract;\r\n    address public transformDataContract;\r\n    address public battleContract;\r\n    address public tradeContract;\r\n    \r\n    // events\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event EventLayEgg(address indexed trainer, uint64 objId, uint64 eggId);\r\n    \r\n    // modifier\r\n    \r\n    modifier requireDataContract {\r\n        require(dataContract != address(0));\r\n        _;\r\n    }\r\n    \r\n    modifier requireTransformDataContract {\r\n        require(transformDataContract != address(0));\r\n        _;\r\n    }\r\n    \r\n    modifier requireBattleContract {\r\n        require(battleContract != address(0));\r\n        _;\r\n    }\r\n    \r\n    modifier requireTradeContract {\r\n        require(tradeContract != address(0));\r\n        _;        \r\n    }\r\n    \r\n    \r\n    // constructor\r\n    function EtheremonTransform(address _dataContract, address _worldContract, address _transformDataContract, address _battleContract, address _tradeContract) public {\r\n        dataContract = _dataContract;\r\n        worldContract = _worldContract;\r\n        transformDataContract = _transformDataContract;\r\n        battleContract = _battleContract;\r\n        tradeContract = _tradeContract;\r\n    }\r\n    \r\n    // helper\r\n    function getRandom(uint16 maxRan, uint8 index, address priAddress) constant public returns(uint8) {\r\n        uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(priAddress);\r\n        for (uint8 i = 0; i < index && i < 6; i ++) {\r\n            genNum /= 256;\r\n        }\r\n        return uint8(genNum % maxRan);\r\n    }\r\n    \r\n    function addNewObj(address _trainer, uint32 _classId) private returns(uint64) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        uint64 objId = data.addMonsterObj(_classId, _trainer, \"..name me...\");\r\n        for (uint i=0; i < STAT_COUNT; i+= 1) {\r\n            uint8 value = getRandom(STAT_MAX, uint8(i), lastHatchingAddress) + data.getElementInArrayType(ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(ArrayType.STAT_BASE, objId, value);\r\n        }\r\n        return objId;\r\n    }\r\n    \r\n    // admin & moderators\r\n    function setContract(address _dataContract, address _worldContract, address _transformDataContract, address _battleContract, address _tradeContract) onlyModerators external {\r\n        dataContract = _dataContract;\r\n        worldContract = _worldContract;\r\n        transformDataContract = _transformDataContract;\r\n        battleContract = _battleContract;\r\n        tradeContract = _tradeContract;\r\n    }\r\n\r\n    function setOriginalPriceGen0() onlyModerators external {\r\n        gen0Config[1] = Gen0Config(1, 0.3 ether, 0.003 ether, 374);\r\n        gen0Config[2] = Gen0Config(2, 0.3 ether, 0.003 ether, 408);\r\n        gen0Config[3] = Gen0Config(3, 0.3 ether, 0.003 ether, 373);\r\n        gen0Config[4] = Gen0Config(4, 0.2 ether, 0.002 ether, 437);\r\n        gen0Config[5] = Gen0Config(5, 0.1 ether, 0.001 ether, 497);\r\n        gen0Config[6] = Gen0Config(6, 0.3 ether, 0.003 ether, 380); \r\n        gen0Config[7] = Gen0Config(7, 0.2 ether, 0.002 ether, 345);\r\n        gen0Config[8] = Gen0Config(8, 0.1 ether, 0.001 ether, 518); \r\n        gen0Config[9] = Gen0Config(9, 0.1 ether, 0.001 ether, 447);\r\n        gen0Config[10] = Gen0Config(10, 0.2 ether, 0.002 ether, 380); \r\n        gen0Config[11] = Gen0Config(11, 0.2 ether, 0.002 ether, 354);\r\n        gen0Config[12] = Gen0Config(12, 0.2 ether, 0.002 ether, 346);\r\n        gen0Config[13] = Gen0Config(13, 0.2 ether, 0.002 ether, 351); \r\n        gen0Config[14] = Gen0Config(14, 0.2 ether, 0.002 ether, 338);\r\n        gen0Config[15] = Gen0Config(15, 0.2 ether, 0.002 ether, 341);\r\n        gen0Config[16] = Gen0Config(16, 0.35 ether, 0.0035 ether, 384);\r\n        gen0Config[17] = Gen0Config(17, 1 ether, 0.01 ether, 305); \r\n        gen0Config[18] = Gen0Config(18, 0.1 ether, 0.001 ether, 427);\r\n        gen0Config[19] = Gen0Config(19, 1 ether, 0.01 ether, 304);\r\n        gen0Config[20] = Gen0Config(20, 0.4 ether, 0.05 ether, 82);\r\n        gen0Config[21] = Gen0Config(21, 1, 1, 123);\r\n        gen0Config[22] = Gen0Config(22, 0.2 ether, 0.001 ether, 468);\r\n        gen0Config[23] = Gen0Config(23, 0.5 ether, 0.0025 ether, 302);\r\n        gen0Config[24] = Gen0Config(24, 1 ether, 0.005 ether, 195);\r\n    }    \r\n\r\n    function updateHatchingRange(uint16 _start, uint16 _max) onlyModerators external {\r\n        hatchStartTime = _start;\r\n        hatchMaxTime = _max;\r\n    }\r\n\r\n    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\r\n        // no user money is kept in this contract, only trasaction fee\r\n        if (_amount > this.balance) {\r\n            revert();\r\n        }\r\n        _sendTo.transfer(_amount);\r\n    }\r\n\r\n    function setConfigClass(uint32 _classId, uint8 _layingLevel, uint8 _layingCost, uint8 _transformLevel, uint32 _tranformClass) onlyModerators external {\r\n        layingEggLevels[_classId] = _layingLevel;\r\n        layingEggDeductions[_classId] = _layingCost;\r\n        transformLevels[_classId] = _transformLevel;\r\n        transformClasses[_classId] = _tranformClass;\r\n    }\r\n    \r\n    function setConfig(uint _removeHatchingTimeFee, uint _buyEggFee) onlyModerators external {\r\n        removeHatchingTimeFee = _removeHatchingTimeFee;\r\n        buyEggFee = _buyEggFee;\r\n    }\r\n\r\n    function genLevelExp() onlyModerators external {\r\n        uint8 level = 1;\r\n        uint32 requirement = 100;\r\n        uint32 sum = requirement;\r\n        while(level <= 100) {\r\n            levelExps[level] = sum;\r\n            level += 1;\r\n            requirement = (requirement * 11) / 10 + 5;\r\n            sum += requirement;\r\n        }\r\n    }\r\n    \r\n    function addRandomClass(uint32 _newClassId) onlyModerators public {\r\n        if (_newClassId > 0) {\r\n            for (uint index = 0; index < randomClassIds.length; index++) {\r\n                if (randomClassIds[index] == _newClassId) {\r\n                    return;\r\n                }\r\n            }\r\n            randomClassIds.push(_newClassId);\r\n        }\r\n    }\r\n    \r\n    function removeRandomClass(uint32 _oldClassId) onlyModerators public {\r\n        uint foundIndex = 0;\r\n        for (; foundIndex < randomClassIds.length; foundIndex++) {\r\n            if (randomClassIds[foundIndex] == _oldClassId) {\r\n                break;\r\n            }\r\n        }\r\n        if (foundIndex < randomClassIds.length) {\r\n            randomClassIds[foundIndex] = randomClassIds[randomClassIds.length-1];\r\n            delete randomClassIds[randomClassIds.length-1];\r\n            randomClassIds.length--;\r\n        }\r\n    }\r\n    \r\n    function removeHatchingTimeWithToken(address _trainer) isActive onlyModerators requireDataContract requireTransformDataContract external {\r\n        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n        MonsterEgg memory egg;\r\n        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(_trainer);\r\n        // not hatching any egg\r\n        if (egg.eggId == 0 || egg.trainer != _trainer || egg.newObjId > 0)\r\n            revert();\r\n        \r\n        transformData.setHatchTime(egg.eggId, 0);\r\n    }    \r\n    \r\n    function buyEggWithToken(address _trainer) isActive onlyModerators requireDataContract requireTransformDataContract external {\r\n        if (randomClassIds.length == 0) {\r\n            revert();\r\n        }\r\n        \r\n        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n        // make sure no hatching egg at the same time\r\n        if (transformData.getHatchingEggId(_trainer) > 0) {\r\n            revert();\r\n        }\r\n\r\n        // add random egg\r\n        uint8 classIndex = getRandom(uint16(randomClassIds.length), 1, lastHatchingAddress);\r\n        uint64 eggId = transformData.addEgg(0, randomClassIds[classIndex], _trainer, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\r\n        // deduct exp\r\n        EventLayEgg(msg.sender, 0, eggId);\r\n    }\r\n    \r\n    // public\r\n\r\n    function ceil(uint a, uint m) pure public returns (uint) {\r\n        return ((a + m - 1) / m) * m;\r\n    }\r\n\r\n    function getLevel(uint32 exp) view public returns (uint8) {\r\n        uint8 minIndex = 1;\r\n        uint8 maxIndex = 100;\r\n        uint8 currentIndex;\r\n     \r\n        while (minIndex < maxIndex) {\r\n            currentIndex = (minIndex + maxIndex) / 2;\r\n            if (exp < levelExps[currentIndex])\r\n                maxIndex = currentIndex;\r\n            else\r\n                minIndex = currentIndex + 1;\r\n        }\r\n\r\n        return minIndex;\r\n    }\r\n\r\n    function getGen0ObjInfo(uint64 _objId) constant public returns(uint32, uint32, uint256) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        \r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\r\n        \r\n        Gen0Config memory gen0 = gen0Config[obj.classId];\r\n        if (gen0.classId != obj.classId) {\r\n            return (gen0.classId, obj.createIndex, 0);\r\n        }\r\n        \r\n        uint32 totalGap = 0;\r\n        if (obj.createIndex < gen0.total)\r\n            totalGap = gen0.total - obj.createIndex;\r\n        \r\n        return (obj.classId, obj.createIndex, safeMult(totalGap, gen0.returnPrice));\r\n    }\r\n    \r\n    function getObjClassId(uint64 _objId) requireDataContract constant public returns(uint32, address, uint8) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        uint32 _ = 0;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\r\n        return (obj.classId, obj.trainer, getLevel(obj.exp));\r\n    }\r\n    \r\n    function getClassCheckOwner(uint64 _objId, address _trainer) requireDataContract constant public returns(uint32) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        uint32 _ = 0;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\r\n        if (_trainer != obj.trainer)\r\n            return 0;\r\n        return obj.classId;\r\n    }\r\n\r\n    function calculateMaxEggG0(uint64 _objId) constant public returns(uint) {\r\n        uint32 classId;\r\n        uint32 createIndex; \r\n        uint256 totalEarn;\r\n        (classId, createIndex, totalEarn) = getGen0ObjInfo(_objId);\r\n        if (classId > GEN0_NO || classId == 20 || classId == 21)\r\n            return 0;\r\n        \r\n        Gen0Config memory config = gen0Config[classId];\r\n        // the one from egg can not lay\r\n        if (createIndex > config.total)\r\n            return 0;\r\n\r\n        // calculate agv price\r\n        uint256 avgPrice = config.originalPrice;\r\n        uint rate = config.originalPrice/config.returnPrice;\r\n        if (config.total > rate) {\r\n            uint k = config.total - rate;\r\n            avgPrice = (config.total * config.originalPrice + config.returnPrice * k * (k+1) / 2) / config.total;\r\n        }\r\n        uint256 catchPrice = config.originalPrice;            \r\n        if (createIndex > rate) {\r\n            catchPrice += config.returnPrice * safeSubtract(createIndex, rate);\r\n        }\r\n        if (totalEarn >= catchPrice) {\r\n            return 0;\r\n        }\r\n        return ceil((catchPrice - totalEarn)*15*1000/avgPrice, 10000)/10000;\r\n    }\r\n    \r\n    function canLayEgg(uint64 _objId, uint32 _classId, uint32 _level) constant public returns(bool) {\r\n        if (_classId <= GEN0_NO) {\r\n            EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n            // legends\r\n            if (transformData.countEgg(_objId) >= calculateMaxEggG0(_objId))\r\n                return false;\r\n            return true;\r\n        } else {\r\n            if (layingEggLevels[_classId] == 0 || _level < layingEggLevels[_classId])\r\n                return false;\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function layEgg(uint64 _objId) isActive requireDataContract requireTransformDataContract external {\r\n        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n        // make sure no hatching egg at the same time\r\n        if (transformData.getHatchingEggId(msg.sender) > 0) {\r\n            revert();\r\n        }\r\n        \r\n        // can not lay egg when trading\r\n        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\r\n        if (trade.isOnTrading(_objId))\r\n            revert();\r\n        \r\n        // check obj \r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        uint32 _ = 0;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, _, _, obj.createTime) = data.getMonsterObj(_objId);\r\n        if (obj.monsterId != _objId || obj.trainer != msg.sender) {\r\n            revert();\r\n        }\r\n        \r\n        // check lay egg condition\r\n        uint8 currentLevel = getLevel(obj.exp);\r\n        uint8 afterLevel = 0;\r\n        if (!canLayEgg(_objId, obj.classId, currentLevel))\r\n            revert();\r\n        if (layingEggDeductions[obj.classId] >= currentLevel)\r\n            revert();\r\n        afterLevel = currentLevel - layingEggDeductions[obj.classId];\r\n\r\n        // add egg \r\n        uint64 eggId = transformData.addEgg(obj.monsterId, obj.classId, msg.sender, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\r\n        \r\n        // deduct exp \r\n        if (afterLevel < currentLevel)\r\n            data.decreaseMonsterExp(_objId, obj.exp - levelExps[afterLevel-1]);\r\n        EventLayEgg(msg.sender, _objId, eggId);\r\n    }\r\n    \r\n    function hatchEgg() isActive requireDataContract requireTransformDataContract external {\r\n        // use as a seed for random\r\n        lastHatchingAddress = msg.sender;\r\n        \r\n        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n        MonsterEgg memory egg;\r\n        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\r\n        // not hatching any egg\r\n        if (egg.eggId == 0 || egg.trainer != msg.sender)\r\n            revert();\r\n        // need more time\r\n        if (egg.newObjId > 0 || egg.hatchTime > block.timestamp) {\r\n            revert();\r\n        }\r\n        \r\n        uint64 objId = addNewObj(msg.sender, egg.classId);\r\n        transformData.setHatchedEgg(egg.eggId, objId);\r\n        \r\n        Transfer(address(0), msg.sender, objId);\r\n    }\r\n    \r\n    function removeHatchingTime() isActive requireDataContract requireTransformDataContract external payable  {\r\n        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n        MonsterEgg memory egg;\r\n        (egg.eggId, egg.objId, egg.classId, egg.trainer, egg.hatchTime, egg.newObjId) = transformData.getHatchingEggData(msg.sender);\r\n        // not hatching any egg\r\n        if (egg.eggId == 0 || egg.trainer != msg.sender || egg.newObjId > 0)\r\n            revert();\r\n        \r\n        if (msg.value != removeHatchingTimeFee) {\r\n            revert();\r\n        }\r\n        transformData.setHatchTime(egg.eggId, 0);\r\n    }\r\n\r\n    \r\n    function checkAncestors(uint32 _classId, address _trainer, uint64 _a1, uint64 _a2, uint64 _a3) constant public returns(bool) {\r\n        EtheremonWorld world = EtheremonWorld(worldContract);\r\n        uint index = 0;\r\n        uint32 temp = 0;\r\n        // check ancestor\r\n        uint32[3] memory ancestors;\r\n        uint32[3] memory requestAncestors;\r\n        index = world.getClassPropertySize(_classId, PropertyType.ANCESTOR);\r\n        while (index > 0) {\r\n            index -= 1;\r\n            ancestors[index] = world.getClassPropertyValue(_classId, PropertyType.ANCESTOR, index);\r\n        }\r\n            \r\n        if (_a1 > 0) {\r\n            temp = getClassCheckOwner(_a1, _trainer);\r\n            if (temp == 0)\r\n                return false;\r\n            requestAncestors[0] = temp;\r\n        }\r\n        if (_a2 > 0) {\r\n            temp = getClassCheckOwner(_a2, _trainer);\r\n            if (temp == 0)\r\n                return false;\r\n            requestAncestors[1] = temp;\r\n        }\r\n        if (_a3 > 0) {\r\n            temp = getClassCheckOwner(_a3, _trainer);\r\n            if (temp == 0)\r\n                return false;\r\n            requestAncestors[2] = temp;\r\n        }\r\n            \r\n        if (requestAncestors[0] > 0 && (requestAncestors[0] == requestAncestors[1] || requestAncestors[0] == requestAncestors[2]))\r\n            return false;\r\n        if (requestAncestors[1] > 0 && (requestAncestors[1] == requestAncestors[2]))\r\n            return false;\r\n                \r\n        for (index = 0; index < ancestors.length; index++) {\r\n            temp = ancestors[index];\r\n            if (temp > 0 && temp != requestAncestors[0]  && temp != requestAncestors[1] && temp != requestAncestors[2])\r\n                return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function transform(uint64 _objId, uint64 _a1, uint64 _a2, uint64 _a3) isActive requireDataContract requireTransformDataContract external payable {\r\n        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n        if (transformData.getTranformedId(_objId) > 0)\r\n            revert();\r\n        \r\n        EtheremonBattle battle = EtheremonBattle(battleContract);\r\n        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\r\n        if (battle.isOnBattle(_objId) || trade.isOnTrading(_objId))\r\n            revert();\r\n        \r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        \r\n        BasicObjInfo memory objInfo;\r\n        (objInfo.classId, objInfo.owner, objInfo.level) = getObjClassId(_objId);\r\n        uint32 transformClass = transformClasses[objInfo.classId];\r\n        if (objInfo.classId == 0 || objInfo.owner != msg.sender)\r\n            revert();\r\n        if (transformLevels[objInfo.classId] == 0 || objInfo.level < transformLevels[objInfo.classId])\r\n            revert();\r\n        if (transformClass == 0)\r\n            revert();\r\n        \r\n        \r\n        // gen0 - can not transform if it has bonus egg \r\n        if (objInfo.classId <= GEN0_NO) {\r\n            // legends\r\n            if (getBonusEgg(_objId) > 0)\r\n                revert();\r\n        } else {\r\n            if (!checkAncestors(objInfo.classId, msg.sender, _a1, _a2, _a3))\r\n                revert();\r\n        }\r\n        \r\n        uint64 newObjId = addNewObj(msg.sender, transformClass);\r\n        // remove old one\r\n        data.removeMonsterIdMapping(msg.sender, _objId);\r\n        transformData.setTranformed(_objId, newObjId);\r\n        \r\n        Transfer(msg.sender, address(0), _objId);\r\n        Transfer(address(0), msg.sender, newObjId);\r\n    }\r\n    \r\n    function buyEgg() isActive requireDataContract requireTransformDataContract external payable {\r\n        if (msg.value != buyEggFee) {\r\n            revert();\r\n        }\r\n        \r\n        if (randomClassIds.length == 0) {\r\n            revert();\r\n        }\r\n        \r\n        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n        // make sure no hatching egg at the same time\r\n        if (transformData.getHatchingEggId(msg.sender) > 0) {\r\n            revert();\r\n        }\r\n\r\n        // add random egg\r\n        uint8 classIndex = getRandom(uint16(randomClassIds.length), 1, lastHatchingAddress);\r\n        uint64 eggId = transformData.addEgg(0, randomClassIds[classIndex], msg.sender, block.timestamp + (hatchStartTime + getRandom(hatchMaxTime, 0, lastHatchingAddress)) * 3600);\r\n        // deduct exp\r\n        EventLayEgg(msg.sender, 0, eggId);\r\n    }\r\n    \r\n    // read\r\n    function getBonusEgg(uint64 _objId) constant public returns(uint) {\r\n        EtheremonTransformData transformData = EtheremonTransformData(transformDataContract);\r\n        uint totalBonusEgg = calculateMaxEggG0(_objId);\r\n        if (totalBonusEgg > 0) {\r\n            return (totalBonusEgg - transformData.countEgg(_objId));\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_objId\",\"type\":\"uint64\"},{\"name\":\"_a1\",\"type\":\"uint64\"},{\"name\":\"_a2\",\"type\":\"uint64\"},{\"name\":\"_a3\",\"type\":\"uint64\"}],\"name\":\"transform\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"gen0Config\",\"outputs\":[{\"name\":\"classId\",\"type\":\"uint32\"},{\"name\":\"originalPrice\",\"type\":\"uint256\"},{\"name\":\"returnPrice\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"moderators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"worldContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyEggFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_removeHatchingTimeFee\",\"type\":\"uint256\"},{\"name\":\"_buyEggFee\",\"type\":\"uint256\"}],\"name\":\"setConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataContract\",\"type\":\"address\"},{\"name\":\"_worldContract\",\"type\":\"address\"},{\"name\":\"_transformDataContract\",\"type\":\"address\"},{\"name\":\"_battleContract\",\"type\":\"address\"},{\"name\":\"_tradeContract\",\"type\":\"address\"}],\"name\":\"setContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hatchMaxTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_objId\",\"type\":\"uint64\"}],\"name\":\"calculateMaxEggG0\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"genLevelExp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint16\"},{\"name\":\"_max\",\"type\":\"uint16\"}],\"name\":\"updateHatchingRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"battleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isMaintaining\",\"type\":\"bool\"}],\"name\":\"UpdateMaintaining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAT_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalModerators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sendTo\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"transformLevels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trainer\",\"type\":\"address\"}],\"name\":\"buyEggWithToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setOriginalPriceGen0\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_layingLevel\",\"type\":\"uint8\"},{\"name\":\"_layingCost\",\"type\":\"uint8\"},{\"name\":\"_transformLevel\",\"type\":\"uint8\"},{\"name\":\"_tranformClass\",\"type\":\"uint32\"}],\"name\":\"setConfigClass\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newModerator\",\"type\":\"address\"}],\"name\":\"AddModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GEN0_NO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelExps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyEgg\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"ceil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_objId\",\"type\":\"uint64\"}],\"name\":\"getObjClassId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hatchStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transformDataContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"layingEggDeductions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"layingEggLevels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_trainer\",\"type\":\"address\"},{\"name\":\"_a1\",\"type\":\"uint64\"},{\"name\":\"_a2\",\"type\":\"uint64\"},{\"name\":\"_a3\",\"type\":\"uint64\"}],\"name\":\"checkAncestors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newClassId\",\"type\":\"uint32\"}],\"name\":\"addRandomClass\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeHatchingTime\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trainer\",\"type\":\"address\"}],\"name\":\"removeHatchingTimeWithToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"removeHatchingTimeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_objId\",\"type\":\"uint64\"}],\"name\":\"getBonusEgg\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exp\",\"type\":\"uint32\"}],\"name\":\"getLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_objId\",\"type\":\"uint64\"},{\"name\":\"_classId\",\"type\":\"uint32\"},{\"name\":\"_level\",\"type\":\"uint32\"}],\"name\":\"canLayEgg\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldModerator\",\"type\":\"address\"}],\"name\":\"RemoveModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldClassId\",\"type\":\"uint32\"}],\"name\":\"removeRandomClass\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maxRan\",\"type\":\"uint16\"},{\"name\":\"index\",\"type\":\"uint8\"},{\"name\":\"priAddress\",\"type\":\"address\"}],\"name\":\"getRandom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomClassIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"hatchEgg\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"transformClasses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_objId\",\"type\":\"uint64\"}],\"name\":\"getGen0ObjInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAT_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_objId\",\"type\":\"uint64\"},{\"name\":\"_trainer\",\"type\":\"address\"}],\"name\":\"getClassCheckOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_objId\",\"type\":\"uint64\"}],\"name\":\"layEgg\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMaintaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dataContract\",\"type\":\"address\"},{\"name\":\"_worldContract\",\"type\":\"address\"},{\"name\":\"_transformDataContract\",\"type\":\"address\"},{\"name\":\"_battleContract\",\"type\":\"address\"},{\"name\":\"_tradeContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trainer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"objId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"eggId\",\"type\":\"uint64\"}],\"name\":\"EventLayEgg\",\"type\":\"event\"}]","ContractName":"EtheremonTransform","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000abc1c404424bdf24c19a5cc5ef8f47781d18eb3e0000000000000000000000001fc7bd85293f3982f40d52698df8d26be89360d6000000000000000000000000fdf4411669fc6e8951a6ae987307d7582fda7a05000000000000000000000000df6164efd12678bf6a7d5a1ddf73c831493f65740000000000000000000000004ba72f0f8dad13709ee28a992869e79d0fe47030","Library":"","SwarmSource":"bzzr://a5bd0e91965e71deb67672c5c0250521648f17074576a29588ea0b91577a767e"}]}