{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\ncontract theCyberInterface {\r\n  // The contract may call a few methods on theCyber once it is itself a member.\r\n  function newMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public;\r\n  function getMembershipStatus(address _memberAddress) public view returns (bool member, uint8 memberId);\r\n  function getMemberInformation(uint8 _memberId) public view returns (bytes32 memberName, string memberKey, uint64 memberSince, uint64 inactiveSince, address memberAddress);\r\n}\r\n\r\n\r\ncontract theCyberGatekeeperTwoInterface {\r\n  // The contract may read the entrants from theCyberGatekeeperTwo.\r\n  function entrants(uint256 i) public view returns (address);\r\n  function totalEntrants() public view returns (uint8);\r\n}\r\n\r\n\r\ncontract theCyberAssigner {\r\n  // This contract supplements the second gatekeeper contract at the address\r\n  // 0xbB902569a997D657e8D10B82Ce0ec5A5983C8c7C. Once enough members have been\r\n  // registered with the gatekeeper, the assignAll() method may be called,\r\n  // which (assuming theCyberAssigner is itself a member of theCyber), will\r\n  // try to assign a membership to each of the submitted addresses.\r\n\r\n  // The assigner will interact with theCyber contract at the given address.\r\n  address private constant THECYBERADDRESS_ = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;\r\n\r\n  // the assigner will read the entrants from the second gatekeeper contract.\r\n  address private constant THECYBERGATEKEEPERADDRESS_ = 0xbB902569a997D657e8D10B82Ce0ec5A5983C8c7C;\r\n\r\n  // There can only be 128 entrant submissions.\r\n  uint8 private constant MAXENTRANTS_ = 128;\r\n\r\n  // The contract remains active until all entrants have been assigned.\r\n  bool private active_ = true;\r\n\r\n  // Entrants are assigned memberships based on an incrementing member id.\r\n  uint8 private nextAssigneeIndex_;\r\n\r\n  function assignAll() public returns (bool) {\r\n    // The contract must still be active in order to assign new members.\r\n    require(active_);\r\n\r\n    // Require a large transaction so that members are added in bulk.\r\n    require(msg.gas > 6000000);\r\n\r\n    // All entrants must be registered in order to assign new members.\r\n    uint8 totalEntrants = theCyberGatekeeperTwoInterface(THECYBERGATEKEEPERADDRESS_).totalEntrants();\r\n    require(totalEntrants >= MAXENTRANTS_);\r\n\r\n    // Initialize variables for checking membership statuses.\r\n    bool member;\r\n    address memberAddress;\r\n\r\n    // The contract must be a member of theCyber in order to assign new members.\r\n    (member,) = theCyberInterface(THECYBERADDRESS_).getMembershipStatus(this);\r\n    require(member);\r\n    \r\n    // Pick up where the function last left off in assigning new members.\r\n    uint8 i = nextAssigneeIndex_;\r\n\r\n    // Loop through entrants as long as sufficient gas remains.\r\n    while (i < MAXENTRANTS_ && msg.gas > 200000) {\r\n      // Find the entrant at the given index.\r\n      address entrant = theCyberGatekeeperTwoInterface(THECYBERGATEKEEPERADDRESS_).entrants(i);\r\n\r\n      // Determine whether the entrant is already a member of theCyber.\r\n      (member,) = theCyberInterface(THECYBERADDRESS_).getMembershipStatus(entrant);\r\n\r\n      // Determine whether the target membership is already owned.\r\n      (,,,,memberAddress) = theCyberInterface(THECYBERADDRESS_).getMemberInformation(i + 1);\r\n      \r\n      // Ensure that there was no member found with the given id / address.\r\n      if ((entrant != address(0)) && (!member) && (memberAddress == address(0))) {\r\n        // Add the entrant as a new member of theCyber.\r\n        theCyberInterface(THECYBERADDRESS_).newMember(i + 1, bytes32(\"\"), entrant);\r\n      }\r\n\r\n      // Move on to the next entrant / member id.\r\n      i++;\r\n    }\r\n\r\n    // Set the index where the function left off; set as inactive if finished.\r\n    nextAssigneeIndex_ = i;\r\n    if (nextAssigneeIndex_ >= MAXENTRANTS_) {\r\n      active_ = false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function nextAssigneeIndex() public view returns(uint8) {\r\n    // Return the current assignee index.\r\n    return nextAssigneeIndex_;\r\n  }\r\n\r\n  function maxEntrants() public pure returns(uint8) {\r\n    // Return the total number of entrants allowed by the gatekeeper.\r\n    return MAXENTRANTS_;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"nextAssigneeIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxEntrants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"assignAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"theCyberAssigner","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://377418bfe2e47984ecc182d7d1e702854fb909a987e50dcd24f289800eb43268"}]}