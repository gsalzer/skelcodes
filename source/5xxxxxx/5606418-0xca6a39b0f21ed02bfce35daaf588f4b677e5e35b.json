{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n     return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\taddress public owner;\r\n\taddress public newOwner;\r\n\r\n\tevent OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n\tconstructor() public {\r\n\t\towner = msg.sender;\r\n\t\tnewOwner = address(0);\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner, \"msg.sender == owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address _newOwner) public onlyOwner {\r\n\t\trequire(address(0) != _newOwner, \"address(0) != _newOwner\");\r\n\t\tnewOwner = _newOwner;\r\n\t}\r\n\r\n\tfunction acceptOwnership() public {\r\n\t\trequire(msg.sender == newOwner, \"msg.sender == newOwner\");\r\n\t\temit OwnershipTransferred(owner, msg.sender);\r\n\t\towner = msg.sender;\r\n\t\tnewOwner = address(0);\r\n\t}\r\n}\r\n\r\ncontract tokenInterface {\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\r\n\tfunction burn(uint256 _value) public returns(bool);\r\n\tuint256 public totalSupply;\r\n\tuint256 public decimals;\r\n}\r\n\r\ncontract rateInterface {\r\n    function readRate(string _currency) public view returns (uint256 oneEtherValue);\r\n}\r\n\r\ncontract RC {\r\n    using SafeMath for uint256;\r\n    DaicoCoinCrowd tokenSaleContract;\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n    \r\n    uint256 public etherMinimum;\r\n    uint256 public soldTokens;\r\n    uint256 public remainingTokens;\r\n    \r\n    uint256 public oneTokenInFiatWei;\r\n\r\n    constructor(address _tokenSaleContract, uint256 _oneTokenInFiatWei, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime) public {\r\n        require ( _tokenSaleContract != 0, \"Token Sale Contract can not be 0\" );\r\n        require ( _oneTokenInFiatWei != 0, \"Token price can no be 0\" );\r\n        require( _remainingTokens != 0, \"Remaining tokens can no be 0\");\r\n       \r\n        \r\n        \r\n        tokenSaleContract = DaicoCoinCrowd(_tokenSaleContract);\r\n        \r\n        soldTokens = 0;\r\n        remainingTokens = _remainingTokens;\r\n        oneTokenInFiatWei = _oneTokenInFiatWei;\r\n        etherMinimum = _etherMinimum;\r\n        \r\n        setTimeRC( _startTime, _endTime );\r\n    }\r\n    \r\n    function setTimeRC(uint256 _startTime, uint256 _endTime ) internal {\r\n        if( _startTime == 0 ) {\r\n            startTime = tokenSaleContract.startTime();\r\n        } else {\r\n            startTime = _startTime;\r\n        }\r\n        if( _endTime == 0 ) {\r\n            endTime = tokenSaleContract.endTime();\r\n        } else {\r\n            endTime = _endTime;\r\n        }\r\n    }\r\n    \r\n    modifier onlyTokenSaleOwner() {\r\n        require(msg.sender == tokenSaleContract.owner(), \"msg.sender == tokenSaleContract.owner()\" );\r\n        _;\r\n    }\r\n    \r\n    function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner {\r\n        if ( _newStart != 0 ) startTime = _newStart;\r\n        if ( _newEnd != 0 ) endTime = _newEnd;\r\n    }\r\n    \r\n    function changeMinimum(uint256 _newEtherMinimum) public onlyTokenSaleOwner {\r\n        etherMinimum = _newEtherMinimum;\r\n    }\r\n    \r\n    function started() public view returns(bool) {\r\n        return now > startTime || remainingTokens == 0;\r\n    }\r\n    \r\n    function ended() public view returns(bool) {\r\n        return now > endTime || remainingTokens == 0;\r\n    }\r\n    \r\n    function startTime() public view returns(uint) {\r\n        return startTime;\r\n    }\r\n    \r\n    function endTime() public view returns(uint) {\r\n        return endTime;\r\n    }\r\n    \r\n    function totalTokens() public view returns(uint) {\r\n        return remainingTokens.add(soldTokens);\r\n    }\r\n    \r\n    function remainingTokens() public view returns(uint) {\r\n        return remainingTokens;\r\n    }\r\n    \r\n    function price() public view returns(uint) {\r\n        uint256 oneEther = 1 ether;\r\n        return oneEther.mul(10**18).div( tokenSaleContract.tokenValueInEther(oneTokenInFiatWei) );\r\n    }\r\n    \r\n    event BuyRC(address indexed buyer, bytes trackID, uint256 value, uint256 soldToken, uint256 valueTokenInUsdWei );\r\n\t\r\n    function () public payable {\r\n        require( now > startTime, \"now > startTime\" );\r\n        require( now < endTime, \"now < endTime\" );\r\n        require( msg.value >= etherMinimum, \"msg.value >= etherMinimum\"); \r\n        require( remainingTokens > 0, \"remainingTokens > 0\" );\r\n        \r\n        uint256 tokenAmount = tokenSaleContract.buyFromRC.value(msg.value)(msg.sender, oneTokenInFiatWei, remainingTokens);\r\n        \r\n        remainingTokens = remainingTokens.sub(tokenAmount);\r\n        soldTokens = soldTokens.add(tokenAmount);\r\n        \r\n        emit BuyRC( msg.sender, msg.data, msg.value, tokenAmount, oneTokenInFiatWei );\r\n    }\r\n}\r\n\r\ncontract DaicoCoinCrowd is Ownable {\r\n    using SafeMath for uint256;\r\n    tokenInterface public tokenContract;\r\n    rateInterface public rateContract;\r\n    \r\n    address public wallet;\r\n    \r\n\tuint256 public decimals;\r\n    \r\n    uint256 public endTime;  // seconds from 1970-01-01T00:00:00Z\r\n    uint256 public startTime;  // seconds from 1970-01-01T00:00:00Z\r\n    \r\n    uint256 public oneTokenInEur;\r\n\r\n    mapping(address => bool) public rc;\r\n\r\n    constructor(address _tokenAddress, address _rateAddress, uint256 _startTime, uint256 _endTime, uint256[] _time, uint256[] _funds, uint256 _oneTokenInEur, uint256 _activeSupply) public {\r\n        tokenContract = tokenInterface(_tokenAddress);\r\n        rateContract = rateInterface(_rateAddress);\r\n        setTime(_startTime, _endTime); \r\n        decimals = tokenContract.decimals();\r\n        oneTokenInEur = _oneTokenInEur;\r\n        wallet = new MilestoneSystem(_tokenAddress, _time, _funds, _oneTokenInEur, _activeSupply);\r\n    }\r\n    \r\n    function tokenValueInEther(uint256 _oneTokenInFiatWei) public view returns(uint256 tknValue) {\r\n        uint256 oneEtherPrice = rateContract.readRate(\"eur\");\r\n        tknValue = _oneTokenInFiatWei.mul(10 ** uint256(decimals)).div(oneEtherPrice);\r\n        return tknValue;\r\n    } \r\n    \r\n    modifier isBuyable() {\r\n        require( wallet != address(0), \"wallet != address(0)\" );\r\n        require( now > startTime, \"now > startTime\" ); // check if started\r\n        require( now < endTime, \"now < endTime\"); // check if ended\r\n        require( msg.value > 0, \"msg.value > 0\" );\r\n\t\t\r\n\t\tuint256 remainingTokens = tokenContract.balanceOf(this);\r\n        require( remainingTokens > 0, \"remainingTokens > 0\" ); // Check if there are any remaining tokens \r\n        _;\r\n    }\r\n    \r\n    event Buy(address buyer, uint256 value, address indexed ambassador);\r\n    \r\n    modifier onlyRC() {\r\n        require( rc[msg.sender], \"rc[msg.sender]\" ); //check if is an authorized rcContract\r\n        _;\r\n    }\r\n    \r\n    function buyFromRC(address _buyer, uint256 _rcTokenValue, uint256 _remainingTokens) onlyRC isBuyable public payable returns(uint256) {\r\n        uint256 oneToken = 10 ** uint256(decimals);\r\n        uint256 tokenValue = tokenValueInEther(_rcTokenValue);\r\n        uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);\r\n        address _ambassador = msg.sender;\r\n        \r\n        uint256 remainingTokens = tokenContract.balanceOf(this);\r\n        if ( _remainingTokens < remainingTokens ) {\r\n            remainingTokens = _remainingTokens;\r\n        }\r\n        \r\n        if ( remainingTokens < tokenAmount ) {\r\n            uint256 refund = tokenAmount.sub(remainingTokens).mul(tokenValue).div(oneToken);\r\n            tokenAmount = remainingTokens;\r\n            forward(msg.value.sub(refund));\r\n\t\t\tremainingTokens = 0; // set remaining token to 0\r\n             _buyer.transfer(refund);\r\n        } else {\r\n\t\t\tremainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus\r\n            forward(msg.value);\r\n        }\r\n        \r\n        tokenContract.transfer(_buyer, tokenAmount);\r\n        emit Buy(_buyer, tokenAmount, _ambassador);\r\n\t\t\r\n        return tokenAmount; \r\n    }\r\n    \r\n    function forward(uint256 _amount) internal {\r\n        wallet.transfer(_amount);\r\n    }\r\n\r\n    event NewRC(address contr);\r\n    \r\n    function addRC(address _rc) onlyOwner public {\r\n        rc[ _rc ]  = true;\r\n        emit NewRC(_rc);\r\n    }\r\n    \r\n    function setTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {\r\n        if ( _newStart != 0 ) startTime = _newStart;\r\n        if ( _newEnd != 0 ) endTime = _newEnd;\r\n    }\r\n    \r\n    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {\r\n        return tokenContract.transfer(to, value);\r\n    }\r\n    \r\n    function setTokenContract(address _tokenContract) public onlyOwner {\r\n        tokenContract = tokenInterface(_tokenContract);\r\n    }\r\n    \r\n    function setRateContract(address _rateAddress) public onlyOwner {\r\n        rateContract = rateInterface(_rateAddress);\r\n    }\r\n\t\r\n\tfunction claim(address _buyer, uint256 _amount) onlyRC public returns(bool) {\r\n        return tokenContract.transfer(_buyer, _amount);\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}\r\n\r\ncontract MilestoneSystem {\r\n    using SafeMath for uint256;\r\n    tokenInterface public tokenContract;\r\n    DaicoCoinCrowd public tokenSaleContract;\r\n    \r\n    uint256[] public time;\r\n    uint256[] public funds;\r\n    \r\n    bool public locked = false; \r\n    uint256 public endTimeToReturnTokens; \r\n    \r\n    uint8 public step = 0;\r\n    \r\n    uint256 public constant timeframeMilestone = 3 days; \r\n    uint256 public constant timeframeDeath = 30 days; \r\n    \r\n    uint256 public activeSupply;\r\n    \r\n    uint256 public oneTokenInEur;\r\n    \r\n    mapping(address => mapping(uint8 => uint256) ) public balance;\r\n    mapping(uint8 => uint256) public tokenDistrusted;\r\n    \r\n    constructor(address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _oneTokenInEur, uint256 _activeSupply) public {\r\n        require( _time.length != 0, \"_time.length != 0\" );\r\n        require( _time.length == _funds.length, \"_time.length == _funds.length\" );\r\n        \r\n        tokenContract = tokenInterface(_tokenAddress);\r\n        tokenSaleContract = DaicoCoinCrowd(msg.sender);\r\n        \r\n        time = _time;\r\n        funds = _funds;\r\n        \r\n        activeSupply = _activeSupply;\r\n        oneTokenInEur = _oneTokenInEur;\r\n    }\r\n    \r\n    modifier onlyTokenSaleOwner() {\r\n        require(msg.sender == tokenSaleContract.owner(), \"msg.sender == tokenSaleContract.owner()\" );\r\n        _;\r\n    }\r\n    \r\n    event Distrust(address sender, uint256 amount);\r\n    event Locked();\r\n    \r\n    function distrust(address _from, uint _value, bytes _data) public {\r\n        require(msg.sender == address(tokenContract), \"msg.sender == address(tokenContract)\");\r\n        \r\n        if ( !locked ) {\r\n            \r\n            uint256 startTimeMilestone = time[step].sub(timeframeMilestone);\r\n            uint256 endTimeMilestone = time[step];\r\n            uint256 startTimeProjectDeath = time[step].add(timeframeDeath);\r\n            bool unclaimedFunds = funds[step] > 0;\r\n            \r\n            require( \r\n                ( now > startTimeMilestone && now < endTimeMilestone ) || \r\n                ( now > startTimeProjectDeath && unclaimedFunds ), \r\n                \"( now > startTimeMilestone && now < endTimeMilestone ) || ( now > startTimeProjectDeath && unclaimedFunds )\" \r\n            );\r\n        } else {\r\n            require( locked && now < endTimeToReturnTokens ); //a timeframePost to deposit all tokens and then claim the refundMe method\r\n        }\r\n        \r\n        balance[_from][step] = balance[_from][step].add(_value);\r\n        tokenDistrusted[step] = tokenDistrusted[step].add(_value);\r\n        \r\n        emit Distrust(msg.sender, _value);\r\n        \r\n        if( tokenDistrusted[step] > activeSupply && !locked ) {\r\n            locked = true;\r\n            endTimeToReturnTokens = now.add(timeframeDeath);\r\n            emit Locked();\r\n        }\r\n    }\r\n    \r\n    function tokenFallback(address _from, uint _value, bytes _data) public {\r\n        distrust( _from, _value, _data);\r\n    }\r\n\t\r\n\tfunction receiveApproval( address _from, uint _value, bytes _data) public {\r\n\t    require(msg.sender == address(tokenContract), \"msg.sender == address(tokenContract)\");\r\n\t\trequire(msg.sender.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, this, _value));\r\n        distrust( _from, _value, _data);\r\n    }\r\n    \r\n    event Trust(address sender, uint256 amount);\r\n    event Unlocked();\r\n    \r\n    function trust(uint8 _step) public {\r\n        require( balance[msg.sender][_step] > 0 , \"balance[msg.sender] > 0\");\r\n        \r\n        uint256 amount = balance[msg.sender][_step];\r\n        balance[msg.sender][_step] = 0;\r\n        \r\n        tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount);\r\n        tokenContract.transfer(msg.sender, amount);\r\n        \r\n        emit Trust(msg.sender, amount);\r\n        \r\n        if( tokenDistrusted[step] <= activeSupply && locked ) {\r\n            locked = false;\r\n            endTimeToReturnTokens = 0;\r\n            emit Unlocked();\r\n        }\r\n    }\r\n    \r\n    event Refund(address sender, uint256 money);\r\n    \r\n    function refundMe() public {\r\n        require(locked, \"locked\");\r\n        require( now > endTimeToReturnTokens, \"now > endTimeToReturnTokens\" );\r\n        \r\n        uint256 ethTot = address(this).balance;\r\n        require( ethTot > 0 , \"ethTot > 0\");\r\n        \r\n        uint256 tknAmount = balance[msg.sender][step];\r\n        require( tknAmount > 0 , \"tknAmount > 0\");\r\n        \r\n        balance[msg.sender][step] = 0;\r\n        \r\n        tokenContract.burn(tknAmount);\r\n        \r\n        uint256 tknTot = tokenDistrusted[step];\r\n        uint256 rate = tknAmount.mul(1 ether).div(tknTot);\r\n        uint256 money = ethTot.mul(rate).div(1 ether);\r\n        \r\n        uint256 moneyMax = tknAmount.mul( tokenSaleContract.tokenValueInEther( oneTokenInEur )).div(1 ether) ;\r\n        \r\n        if ( money > moneyMax) { //This protects the project from the overvaluation of ether\r\n            money = moneyMax;\r\n        }\r\n        \r\n        if( money > address(this).balance ) {\r\n\t\t    money = address(this).balance;\r\n\t\t}\r\n        msg.sender.transfer(money);\r\n        \r\n        emit Refund(msg.sender, money);\r\n    }\r\n    \r\n    function OwnerWithdraw() public onlyTokenSaleOwner {\r\n        require(!locked, \"!locked\");\r\n        \r\n        require(now > time[step], \"now > time[step]\");\r\n        require(funds[step] > 0, \"funds[step] > 0\");\r\n        \r\n        uint256 amountApplied = funds[step];\r\n        funds[step] = 0;\r\n\t\tstep = step+1;\r\n\t\t\r\n\t\tuint256 value;\r\n\t\tif( amountApplied > address(this).balance || time.length == step+1)\r\n\t\t    value = address(this).balance;\r\n\t\telse {\r\n\t\t    value = amountApplied;\r\n\t\t}\r\n\t\t\r\n        msg.sender.transfer(value);\r\n    }\r\n    \r\n    function OwnerWithdrawTokens(address _tokenContract, address to, uint256 value) public onlyTokenSaleOwner returns (bool) { //for airdrop reason to distribute to CoinCrowd Token Holder\r\n        require( _tokenContract != address(tokenContract), \"_tokenContract != address(tokenContract)\"); // the owner can withdraw tokens except CoinCrowd Tokens\r\n        return tokenInterface(_tokenContract).transfer(to, value);\r\n    }\r\n    \r\n    function () public payable {\r\n        require(msg.sender == address(tokenSaleContract), \"msg.sender == address(tokenSaleContract)\");\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_rcTokenValue\",\"type\":\"uint256\"},{\"name\":\"_remainingTokens\",\"type\":\"uint256\"}],\"name\":\"buyFromRC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rc\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rateAddress\",\"type\":\"address\"}],\"name\":\"setRateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_oneTokenInFiatWei\",\"type\":\"uint256\"}],\"name\":\"tokenValueInEther\",\"outputs\":[{\"name\":\"tknValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rc\",\"type\":\"address\"}],\"name\":\"addRC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oneTokenInEur\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStart\",\"type\":\"uint256\"},{\"name\":\"_newEnd\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_rateAddress\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256[]\"},{\"name\":\"_funds\",\"type\":\"uint256[]\"},{\"name\":\"_oneTokenInEur\",\"type\":\"uint256\"},{\"name\":\"_activeSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ambassador\",\"type\":\"address\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contr\",\"type\":\"address\"}],\"name\":\"NewRC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DaicoCoinCrowd","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004d829f8c92a6691c56300d020c9e0db984cfe2ba000000000000000000000000af0e27602eaa73fdf4849806d75bdfc77fb95217000000000000000000000000000000000000000000000000000000005af480f6000000000000000000000000000000000000000000000000000000005b36abe00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000005f7aab8c56b00000000000000000000000000000000000000000000001581b6d300d0225a0000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000005b37fd60000000000000000000000000000000000000000000000000000000005bda33f0000000000000000000000000000000000000000000000000000000005c537df000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000001b1ae4d6e2ef50000000000000000000000000000000000000000000000000001b1ae4d6e2ef50000000000000000000000000000000000000000000000000001b1ae4d6e2ef5000000","Library":"","SwarmSource":"bzzr://65ab7ef2fdb7652e09405cb1538dddd661e5d4c9b8102fd2f5da0ded9b939eb7"}]}