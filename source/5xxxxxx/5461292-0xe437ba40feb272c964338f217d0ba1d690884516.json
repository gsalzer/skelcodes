{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity^0.4.21;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(s));\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n\r\n    function totalSupply() public constant returns (uint);\r\n\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n \r\n}\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    function DSTokenBase(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) public view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped;\r\n\r\n    modifier stoppable {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract DSToken is DSTokenBase(0), DSStop {\r\n\r\n    string  public  symbol;\r\n    uint256  public  decimals = 18; // standard token precision. override to customize\r\n\r\n    function DSToken(string symbol_) public {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n\r\n    function approve(address guy) public stoppable returns (bool) {\r\n        return super.approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        return super.approve(guy, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function push(address dst, uint wad) public {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function pull(address src, uint wad) public {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) public {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    function mint(uint wad) public {\r\n        mint(msg.sender, wad);\r\n    }\r\n    function burn(uint wad) public {\r\n        burn(msg.sender, wad);\r\n    }\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        _balances[guy] = add(_balances[guy], wad);\r\n        _supply = add(_supply, wad);\r\n        Mint(guy, wad);\r\n    }\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\r\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\r\n        }\r\n\r\n        _balances[guy] = sub(_balances[guy], wad);\r\n        _supply = sub(_supply, wad);\r\n        Burn(guy, wad);\r\n    }\r\n\r\n    // Optional token name\r\n    string  name = \"\";\r\n\r\n    function setName(string name_) public auth {\r\n        name = name_;\r\n    }\r\n}\r\n\r\ncontract DSProxy is DSAuth, DSNote {\r\n    DSProxyCache public cache;  // global cache for contracts\r\n\r\n    function DSProxy(address _cacheAddr) public {\r\n        require(setCache(_cacheAddr));\r\n    }\r\n\r\n    function() public payable {\r\n    }\r\n\r\n    // use the proxy to execute calldata _data on contract _code\r\n    function execute(bytes _code, bytes _data)\r\n        public\r\n        payable\r\n        returns (address target, bytes32 response)\r\n    {\r\n        target = cache.read(_code);\r\n        if (target == 0x0) {\r\n            // deploy contract & store its address in cache\r\n            target = cache.write(_code);\r\n        }\r\n\r\n        response = execute(target, _data);\r\n    }\r\n\r\n    function execute(address _target, bytes _data)\r\n        public\r\n        auth\r\n        note\r\n        payable\r\n        returns (bytes32 response)\r\n    {\r\n        require(_target != 0x0);\r\n\r\n        // call contract in current context\r\n        assembly {\r\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 32)\r\n            response := mload(0)      // load delegatecall output\r\n            switch iszero(succeeded)\r\n            case 1 {\r\n                // throw if delegatecall failed\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    //set new cache\r\n    function setCache(address _cacheAddr)\r\n        public\r\n        auth\r\n        note\r\n        returns (bool)\r\n    {\r\n        require(_cacheAddr != 0x0);        // invalid cache address\r\n        cache = DSProxyCache(_cacheAddr);  // overwrite cache\r\n        return true;\r\n    }\r\n}\r\n\r\n// DSProxyFactory\r\n// This factory deploys new proxy instances through build()\r\n// Deployed proxy addresses are logged\r\ncontract DSProxyFactory {\r\n    event Created(address indexed sender, address proxy, address cache);\r\n    mapping(address=>bool) public isProxy;\r\n    DSProxyCache public cache = new DSProxyCache();\r\n\r\n    // deploys a new proxy instance\r\n    // sets owner of proxy to caller\r\n    function build() public returns (DSProxy proxy) {\r\n        proxy = build(msg.sender);\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets custom owner of proxy\r\n    function build(address owner) public returns (DSProxy proxy) {\r\n        proxy = new DSProxy(cache);\r\n        Created(owner, address(proxy), address(cache));\r\n        proxy.setOwner(owner);\r\n        isProxy[proxy] = true;\r\n    }\r\n}\r\n\r\n// DSProxyCache\r\n// This global cache stores addresses of contracts previously deployed\r\n// by a proxy. This saves gas from repeat deployment of the same\r\n// contracts and eliminates blockchain bloat.\r\n\r\n// By default, all proxies deployed from the same factory store\r\n// contracts in the same cache. The cache a proxy instance uses can be\r\n// changed.  The cache uses the sha3 hash of a contract's bytecode to\r\n// lookup the address\r\ncontract DSProxyCache {\r\n    mapping(bytes32 => address) cache;\r\n\r\n    function read(bytes _code) public view returns (address) {\r\n        bytes32 hash = keccak256(_code);\r\n        return cache[hash];\r\n    }\r\n\r\n    function write(bytes _code) public returns (address target) {\r\n        assembly {\r\n            target := create(0, add(_code, 0x20), mload(_code))\r\n            switch iszero(extcodesize(target))\r\n            case 1 {\r\n                // throw if contract failed to deploy\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        bytes32 hash = keccak256(_code);\r\n        cache[hash] = target;\r\n    }\r\n}\r\n\r\ninterface DSValue {\r\n    function peek() external constant returns (bytes32, bool);\r\n    function read() external constant returns (bytes32);\r\n}\r\n\r\ncontract TubInterface {\r\n\r\n    function mat() public view returns(uint);\r\n\r\n    // function cups(bytes32 cup) public view returns(Cup);\r\n\r\n    function ink(bytes32 cup) public view returns (uint);\r\n    function tab(bytes32 cup) public returns (uint);\r\n    function rap(bytes32 cup) public returns (uint);\r\n\r\n    //--Collateral-wrapper----------------------------------------------\r\n    // Wrapper ratio (gem per skr)\r\n    function per() public view returns (uint ray);\r\n    // Join price (gem per skr)\r\n    function ask(uint wad) public view returns (uint);\r\n    // Exit price (gem per skr)\r\n    function bid(uint wad) public view returns (uint);\r\n    function join(uint wad) public;\r\n    function exit(uint wad) public;\r\n\r\n    //--CDP-risk-indicator----------------------------------------------\r\n    // Abstracted collateral price (ref per skr)\r\n    function tag() public view returns (uint wad);\r\n    // Returns true if cup is well-collateralized\r\n    function safe(bytes32 cup) public returns (bool);\r\n\r\n    //--CDP-operations--------------------------------------------------\r\n    function open() public returns (bytes32 cup);\r\n    function give(bytes32 cup, address guy) public;\r\n    function lock(bytes32 cup, uint wad) public;\r\n    function free(bytes32 cup, uint wad) public;\r\n    function draw(bytes32 cup, uint wad) public;\r\n    function wipe(bytes32 cup, uint wad) public;\r\n    function shut(bytes32 cup) public;\r\n    function bite(bytes32 cup) public;\r\n}\r\n\r\ninterface OtcInterface {\r\n    function sellAllAmount(address, uint, address, uint) public returns (uint);\r\n    function buyAllAmount(address, uint, address, uint) public returns (uint);\r\n    function getPayAmount(address, address, uint) public constant returns (uint);\r\n}\r\n\r\ninterface ProxyCreationAndExecute {\r\n    \r\n    function createAndSellAllAmount(\r\n        DSProxyFactory factory, \r\n        OtcInterface otc, \r\n        ERC20 payToken, \r\n        uint payAmt, \r\n        ERC20 buyToken,\r\n        uint minBuyAmt) public \r\n        returns (DSProxy proxy, uint buyAmt);\r\n\r\n    function createAndSellAllAmountPayEth(\r\n        DSProxyFactory factory, \r\n        OtcInterface otc, \r\n        ERC20 buyToken, \r\n        uint minBuyAmt) public payable returns (DSProxy proxy, uint buyAmt);\r\n\r\n    function createAndSellAllAmountBuyEth(\r\n        DSProxyFactory factory, \r\n        OtcInterface otc, \r\n        ERC20 payToken, \r\n        uint payAmt, \r\n        uint minBuyAmt) public returns (DSProxy proxy, uint wethAmt);\r\n\r\n    function createAndBuyAllAmount(\r\n        DSProxyFactory factory, \r\n        OtcInterface otc, \r\n        ERC20 buyToken, \r\n        uint buyAmt, \r\n        ERC20 payToken, \r\n        uint maxPayAmt) public returns (DSProxy proxy, uint payAmt);\r\n\r\n    function createAndBuyAllAmountPayEth(\r\n        DSProxyFactory factory, \r\n        OtcInterface otc, \r\n        ERC20 buyToken, \r\n        uint buyAmt) public payable returns (DSProxy proxy, uint wethAmt);\r\n\r\n    function createAndBuyAllAmountBuyEth(\r\n        DSProxyFactory factory, \r\n        OtcInterface otc, \r\n        uint wethAmt, \r\n        ERC20 payToken, \r\n        uint maxPayAmt) public returns (DSProxy proxy, uint payAmt);\r\n} \r\n\r\ninterface OasisDirectInterface {\r\n    \r\n    function sellAllAmount(\r\n        OtcInterface otc, \r\n        ERC20 payToken, \r\n        uint payAmt, \r\n        ERC20 buyToken,\r\n        uint minBuyAmt) public \r\n        returns (uint buyAmt);\r\n\r\n    function sellAllAmountPayEth(\r\n        OtcInterface otc, \r\n        ERC20 buyToken, \r\n        uint minBuyAmt) public payable returns (uint buyAmt);\r\n\r\n    function sellAllAmountBuyEth(\r\n        OtcInterface otc, \r\n        ERC20 payToken, \r\n        uint payAmt, \r\n        uint minBuyAmt) public returns (uint wethAmt);\r\n\r\n    function buyAllAmount(\r\n        OtcInterface otc, \r\n        ERC20 buyToken, \r\n        uint buyAmt, \r\n        ERC20 payToken, \r\n        uint maxPayAmt) public returns (uint payAmt);\r\n\r\n    function buyAllAmountPayEth(\r\n        OtcInterface otc, \r\n        ERC20 buyToken, \r\n        uint buyAmt) public payable returns (uint wethAmt);\r\n\r\n    function buyAllAmountBuyEth(\r\n        OtcInterface otc, \r\n        uint wethAmt, \r\n        ERC20 payToken, \r\n        uint maxPayAmt) public returns (uint payAmt);\r\n}\r\n\r\ncontract WETH is ERC20 {\r\n    function deposit() public payable;\r\n    function withdraw(uint wad) public;\r\n}\r\n\r\n/**\r\n    A contract to help creating creating CDPs in MakerDAO's system\r\n    The motivation for this is simply to save time and automate some steps for people who\r\n    want to create CDPs often\r\n*/\r\ncontract CDPer is DSStop, DSMath {\r\n\r\n    ///Main Net\\\\\\\r\n    uint public slippage = WAD / 50;//2%\r\n    TubInterface public tub = TubInterface(0x448a5065aeBB8E423F0896E6c5D525C040f59af3);\r\n    DSToken public dai = DSToken(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);  // Stablecoin\r\n    DSToken public skr = DSToken(0xf53AD2c6851052A81B42133467480961B2321C09);  // Abstracted collateral - PETH\r\n    WETH public gem = WETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);  // Underlying collateral - WETH\r\n    DSToken public gov = DSToken(0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2);  // MKR Token\r\n    DSValue public feed = DSValue(0x729D19f657BD0614b4985Cf1D82531c67569197B);  // Price feed\r\n    OtcInterface public otc = OtcInterface(0x14FBCA95be7e99C15Cc2996c6C9d841e54B79425);\r\n\r\n    ///Kovan test net\\\\\\\r\n    ///This is the acceptable price difference when exchanging at the otc. 0.01 * 10^18 == 1% acceptable slippage \r\n    // uint public slippage = 99*10**16;//99%\r\n    // TubInterface public tub = TubInterface(0xa71937147b55Deb8a530C7229C442Fd3F31b7db2);\r\n    // DSToken public dai = DSToken(0xC4375B7De8af5a38a93548eb8453a498222C4fF2);  // Stablecoin\r\n    // DSToken public skr = DSToken(0xf4d791139cE033Ad35DB2B2201435fAd668B1b64);  // Abstracted collateral - PETH\r\n    // DSToken public gov = DSToken(0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD);  // MKR Token\r\n    // WETH public gem = WETH(0xd0A1E359811322d97991E03f863a0C30C2cF029C);  // Underlying collateral - WETH\r\n    // DSValue public feed = DSValue(0xA944bd4b25C9F186A846fd5668941AA3d3B8425F);  // Price feed\r\n    // OtcInterface public otc = OtcInterface(0x8cf1Cab422A0b6b554077A361f8419cDf122a9F9);\r\n\r\n    ///You won't be able to create a CDP or trade less than these values\r\n    uint public minETH = WAD / 20; //0.05 ETH\r\n    uint public minDai = WAD * 50; //50 Dai\r\n\r\n    //if you recursively want to invest your CDP, this will be the target liquidation price\r\n    uint public liquidationPriceWad = 320 * WAD;\r\n\r\n    /// liquidation ratio from Maker tub (can be updated manually)\r\n    uint ratio;\r\n\r\n    function CDPer() public {\r\n\r\n    }\r\n\r\n    /**\r\n     @notice Sets all allowances and updates tub liquidation ratio\r\n     */\r\n    function init() public auth {\r\n        gem.approve(tub, uint(-1));\r\n        skr.approve(tub, uint(-1));\r\n        dai.approve(tub, uint(-1));\r\n        gov.approve(tub, uint(-1));\r\n        \r\n        gem.approve(owner, uint(-1));\r\n        skr.approve(owner, uint(-1));\r\n        dai.approve(owner, uint(-1));\r\n        gov.approve(owner, uint(-1));\r\n\r\n        dai.approve(otc, uint(-1));\r\n        gem.approve(otc, uint(-1));\r\n\r\n        tubParamUpdate();\r\n    }\r\n\r\n    /**\r\n     @notice updates tub liquidation ratio\r\n     */\r\n    function tubParamUpdate() public auth {\r\n        ratio = tub.mat() / 10**9; //liquidation ratio\r\n    }\r\n\r\n     /**\r\n     @notice create a CDP and join with the ETH sent to this function\r\n     @dev This function wraps ETH, converts to PETH, creates a CDP, joins with the PETH created and gives the CDP to the sender. Will revert if there's not enough WETH to buy with the acceptable slippage\r\n     */\r\n    function createAndJoinCDP() public stoppable payable returns(bytes32 id) {\r\n\r\n        require(msg.value >= minETH);\r\n\r\n        gem.deposit.value(msg.value)();\r\n        \r\n        id = _openAndJoinCDPWETH(msg.value);\r\n\r\n        tub.give(id, msg.sender);\r\n    }\r\n\r\n    /**\r\n     @notice create a CDP from all the Dai in the sender's balance - needs Dai transfer approval\r\n     @dev this function will sell the Dai at otc for weth and then do the same as create and JoinCDP.  Will revert if there's not enough WETH to buy with the acceptable slippage\r\n     */\r\n    function createAndJoinCDPAllDai() public returns(bytes32 id) {\r\n        return createAndJoinCDPDai(dai.balanceOf(msg.sender));\r\n    }\r\n\r\n    /**\r\n     @notice create a CDP from the given amount of Dai in the sender's balance - needs Dai transfer approval\r\n     @dev this function will sell the Dai at otc for weth and then do the same as create and JoinCDP.  Will revert if there's not enough WETH to buy with the acceptable slippage\r\n     @param amount - dai to transfer from the sender's balance (needs approval)\r\n     */\r\n    function createAndJoinCDPDai(uint amount) public auth stoppable returns(bytes32 id) {\r\n        require(amount >= minDai);\r\n\r\n        uint price = uint(feed.read());\r\n\r\n        require(dai.transferFrom(msg.sender, this, amount));\r\n\r\n        uint bought = otc.sellAllAmount(dai, amount,\r\n            gem, wmul(WAD - slippage, wdiv(amount, price)));\r\n        \r\n        id = _openAndJoinCDPWETH(bought);\r\n        \r\n        tub.give(id, msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     @notice create a CDP from the ETH sent, and then create Dai and reinvest it in the CDP until the target liquidation price is reached (or the minimum investment amount)\r\n     @dev same as openAndJoinCDP, but then draw and reinvest dai. Will revert if trades are not possible.\r\n     */\r\n    function createCDPLeveraged() public auth stoppable payable returns(bytes32 id) {\r\n        require(msg.value >= minETH);\r\n\r\n        uint price = uint(feed.read());\r\n\r\n        gem.deposit.value(msg.value)();\r\n\r\n        id = _openAndJoinCDPWETH(msg.value);\r\n\r\n        while(_reinvest(id, price)) {}\r\n\r\n        tub.give(id, msg.sender);\r\n    }\r\n\r\n    /**\r\n     @notice create a CDP all the Dai in the sender's balance (needs approval), and then create Dai and reinvest it in the CDP until the target liquidation price is reached (or the minimum investment amount)\r\n     @dev same as openAndJoinCDPDai, but then draw and reinvest dai. Will revert if trades are not possible.\r\n     */\r\n    function createCDPLeveragedAllDai() public returns(bytes32 id) {\r\n        return createCDPLeveragedDai(dai.balanceOf(msg.sender)); \r\n    }\r\n    \r\n    /**\r\n     @notice create a CDP the given amount of Dai in the sender's balance (needs approval), and then create Dai and reinvest it in the CDP until the target liquidation price is reached (or the minimum investment amount)\r\n     @dev same as openAndJoinCDPDai, but then draw and reinvest dai. Will revert if trades are not possible.\r\n     */\r\n    function createCDPLeveragedDai(uint amount) public auth stoppable returns(bytes32 id) {\r\n\r\n        require(amount >= minDai);\r\n\r\n        uint price = uint(feed.read());\r\n\r\n        require(dai.transferFrom(msg.sender, this, amount));\r\n        uint bought = otc.sellAllAmount(dai, amount,\r\n            gem, wmul(WAD - slippage, wdiv(amount, price)));\r\n\r\n        id = _openAndJoinCDPWETH(bought);\r\n\r\n        while(_reinvest(id, price)) {}\r\n\r\n        tub.give(id, msg.sender);\r\n    }\r\n\r\n    /**\r\n     @notice Shuts a CDP and returns the value in the form of ETH. You need to give permission for the amount of debt in Dai, so that the contract will draw it from your account. You need to give the CDP to this contract before using this function. You also need to send a small amount of MKR to this contract so that the fee can be paid.\r\n     @dev this function pays all debt(from the sender's account) and fees(there must be enough MKR present on this account), then it converts PETH to WETH, and then WETH to ETH, finally it sends the balance to the sender\r\n     @param _id id of the CDP to shut - it must be given to this contract\r\n     */\r\n    function shutForETH(uint _id) public auth stoppable {\r\n        bytes32 id = bytes32(_id);\r\n        uint debt = tub.tab(id);\r\n        if (debt > 0) {\r\n            require(dai.transferFrom(msg.sender, this, debt));\r\n        }\r\n        uint ink = tub.ink(id);// locked collateral\r\n        tub.shut(id);\r\n        uint gemBalance = tub.bid(ink);\r\n        tub.exit(ink);\r\n\r\n        gem.withdraw(min(gemBalance, gem.balanceOf(this)));\r\n        \r\n        msg.sender.transfer(min(gemBalance, address(this).balance));\r\n    }\r\n\r\n    /**\r\n     @notice shuts the CDP and returns all the value in the form of Dai. You need to give permission for the amount of debt in Dai, so that the contract will draw it from your account. You need to give the CDP to this contract before using this function. You also need to send a small amount of MKR to this contract so that the fee can be paid.\r\n     @dev this function pays all debt(from the sender's account) and fees(there must be enough MKR present on this account), then it converts PETH to WETH, then trades WETH for Dai, and sends it to the sender\r\n     @param _id id of the CDP to shut - it must be given to this contract\r\n     */\r\n    function shutForDai(uint _id) public auth stoppable {\r\n        bytes32 id = bytes32(_id);\r\n        uint debt = tub.tab(id);\r\n        if (debt > 0) {\r\n            require(dai.transferFrom(msg.sender, this, debt));\r\n        }\r\n        uint ink = tub.ink(id);// locked collateral\r\n        tub.shut(id);\r\n        uint gemBalance = tub.bid(ink);\r\n        tub.exit(ink);\r\n\r\n        uint price = uint(feed.read());\r\n\r\n        uint bought = otc.sellAllAmount(gem, min(gemBalance, gem.balanceOf(this)), \r\n            dai, wmul(WAD - slippage, wmul(gemBalance, price)));\r\n        \r\n        require(dai.transfer(msg.sender, bought));\r\n    }\r\n\r\n    /**\r\n     @notice give ownership of a CDP back to the sender\r\n     @param id id of the CDP owned by this contract\r\n     */\r\n    function giveMeCDP(uint id) public auth {\r\n        tub.give(bytes32(id), msg.sender);\r\n    }\r\n\r\n    /**\r\n     @notice transfer any token from this contract to the sender\r\n     @param token : token contract address\r\n     */\r\n    function giveMeToken(DSToken token) public auth {\r\n        token.transfer(msg.sender, token.balanceOf(this));\r\n    }\r\n\r\n    /**\r\n     @notice transfer all ETH balance from this contract to the sender\r\n     */\r\n    function giveMeETH() public auth {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     @notice transfer all ETH balance from this contract to the sender and destroy the contract. Must be stopped\r\n     */\r\n    function destroy() public auth {\r\n        require(stopped);\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    /**\r\n     @notice set the acceptable price slippage for trades.\r\n     @param slip E.g: 0.01 * 10^18 == 1% acceptable slippage \r\n     */\r\n    function setSlippage(uint slip) public auth {\r\n        require(slip < WAD);\r\n        slippage = slip;\r\n    }\r\n\r\n    /**\r\n     @notice set the target liquidation price for leveraged CDPs created \r\n     @param wad E.g. 300 * 10^18 == 300 USD target liquidation price\r\n     */\r\n    function setLiqPrice(uint wad) public auth {        \r\n        liquidationPriceWad = wad;\r\n    }\r\n\r\n    /**\r\n     @notice set the minimal ETH for trades (depends on otc)\r\n     @param wad minimal ETH to trade\r\n     */\r\n    function setMinETH(uint wad) public auth {\r\n        minETH = wad;\r\n    }\r\n\r\n    /**\r\n     @notice set the minimal Dai for trades (depends on otc)\r\n     @param wad minimal Dai to trade\r\n     */\r\n    function setMinDai(uint wad) public auth {\r\n        minDai = wad;\r\n    }\r\n\r\n    function setTub(TubInterface _tub) public auth {\r\n        tub = _tub;\r\n    }\r\n\r\n    function setDai(DSToken _dai) public auth {\r\n        dai = _dai;\r\n    }\r\n\r\n    function setSkr(DSToken _skr) public auth {\r\n        skr = _skr;\r\n    }\r\n    function setGov(DSToken _gov) public auth {\r\n        gov = _gov;\r\n    }\r\n    function setGem(WETH _gem) public auth {\r\n        gem = _gem;\r\n    }\r\n    function setFeed(DSValue _feed) public auth {\r\n        feed = _feed;\r\n    }\r\n    function setOTC(OtcInterface _otc) public auth {\r\n        otc = _otc;\r\n    }\r\n\r\n    function _openAndJoinCDPWETH(uint amount) internal returns(bytes32 id) {\r\n        id = tub.open();\r\n\r\n        _joinCDP(id, amount);\r\n    }\r\n\r\n    function _joinCDP(bytes32 id, uint amount) internal {\r\n\r\n        uint skRate = tub.ask(WAD);\r\n        \r\n        uint valueSkr = wdiv(amount, skRate);\r\n\r\n        tub.join(valueSkr); \r\n\r\n        tub.lock(id, min(valueSkr, skr.balanceOf(this)));\r\n    }\r\n\r\n    function _reinvest(bytes32 id, uint latestPrice) internal returns(bool ok) {\r\n        \r\n        // Cup memory cup = tab.cups(id);\r\n        uint debt = tub.tab(id);\r\n        uint ink = tub.ink(id);// locked collateral\r\n        \r\n        uint maxInvest = wdiv(wmul(liquidationPriceWad, ink), ratio);\r\n        \r\n        if(debt >= maxInvest) {\r\n            return false;\r\n        }\r\n        \r\n        uint leftOver = sub(maxInvest, debt);\r\n        \r\n        if(leftOver >= minDai) {\r\n            tub.draw(id, leftOver);\r\n\r\n            uint bought = otc.sellAllAmount(dai, min(leftOver, dai.balanceOf(this)),\r\n                gem, wmul(WAD - slippage, wdiv(leftOver, latestPrice)));\r\n            \r\n            _joinCDP(id, bought);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract CDPerFactory {\r\n    event Created(address indexed sender, address cdper);\r\n    mapping(address=>bool) public isCDPer;\r\n\r\n    // deploys a new CDPer instance\r\n    // sets owner of CDPer to caller\r\n    function build() public returns (CDPer cdper) {\r\n        cdper = build(msg.sender);\r\n    }\r\n\r\n    // deploys a new CDPer instance\r\n    // sets custom owner of CDPer\r\n    function build(address owner) public returns (CDPer cdper) {\r\n        cdper = new CDPer();\r\n        emit Created(owner, address(cdper));\r\n        cdper.setOwner(owner);\r\n        isCDPer[cdper] = true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"shutForETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"setLiqPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"skr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"shutForDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_skr\",\"type\":\"address\"}],\"name\":\"setSkr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tub\",\"type\":\"address\"}],\"name\":\"setTub\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"giveMeETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tub\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"otc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feed\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slippage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_otc\",\"type\":\"address\"}],\"name\":\"setOTC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"setMinETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feed\",\"type\":\"address\"}],\"name\":\"setFeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createAndJoinCDPAllDai\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createCDPLeveragedDai\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gem\",\"type\":\"address\"}],\"name\":\"setGem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"setMinDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dai\",\"type\":\"address\"}],\"name\":\"setDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gem\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"giveMeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationPriceWad\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createAndJoinCDPDai\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tubParamUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"setGov\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createCDPLeveragedAllDai\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createAndJoinCDP\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createCDPLeveraged\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slip\",\"type\":\"uint256\"}],\"name\":\"setSlippage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"giveMeCDP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"}]","ContractName":"CDPer","CompilerVersion":"v0.4.22+commit.4cb486ee","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://739f7b049164253873393072d890fde98649ed83aaa2d0e16cf4cb8212a719a5"}]}