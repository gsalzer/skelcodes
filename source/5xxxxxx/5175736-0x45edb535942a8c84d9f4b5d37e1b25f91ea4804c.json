{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /** \r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner. \r\n   */\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      revert();\r\n    }\r\n    _;\r\n }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to. \r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n      owner = newOwner;\r\n  }\r\n \r\n}\r\n  \r\ncontract ERC20 {\r\n\r\n    function totalSupply() public constant returns (uint256);\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public;\r\n    function transferFrom(address from, address to, uint256 value) public;\r\n    function approve(address spender, uint256 value) public;\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\ncontract RAOToken is Ownable, ERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Token properties\r\n    string public name = \"RadioYo Coin\";\r\n    string public symbol = \"RAO\";\r\n    uint256 public decimals = 18;\r\n    uint256 public numberDecimal18 = 1000000000000000000;\r\n\r\n    uint256 public initialPrice = 3000e18;\r\n    uint256 public _totalSupply = 33000000e18;\r\n    uint256 public _icoSupply = 33000000e18;\r\n    uint256 public _softcap = 165000e18;\r\n\r\n    // Balances for each account\r\n    mapping (address => uint256) balances;\r\n\r\n    // whitelisting users\r\n    mapping (address => bool) whitelist;\r\n\r\n    // time seal for upper management\r\n    mapping (address => uint256) vault;\r\n    \r\n    \r\n    //Balances for waiting KYC approving\r\n    mapping (address => uint256) balancesWaitingKYC;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping (address => mapping(address => uint256)) allowed;\r\n    \r\n    // start and end timestamps where investments are allowed (both inclusive)\r\n    uint256 public startTime; \r\n    uint256 public endTime; \r\n    uint256 public sealdate;\r\n\r\n    // Wallet Address of Token\r\n    address public multisig;\r\n\r\n    // how many token units a buyer get in base unit \r\n    uint256 public RATE;\r\n\r\n    uint256 public kycLevel = 15 ether;\r\n\r\n\r\n    uint256 public hardCap = 200000000e18;\r\n    \r\n    //number of total tokens sold \r\n    uint256 public totalNumberTokenSold=0;\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    bool public tradable = true;\r\n\r\n    bool public active = true;\r\n\r\n    event MintFinished();\r\n    event StartTradable();\r\n    event PauseTradable();\r\n    event HaltTokenAllOperation();\r\n    event ResumeTokenAllOperation();\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    modifier canTradable() {\r\n        require(tradable);\r\n        _;\r\n    }\r\n\r\n    modifier isActive() {\r\n        require(active);\r\n        _;\r\n    }\r\n    \r\n    modifier saleIsOpen(){\r\n        require(startTime <= getNow() && getNow() <= endTime);\r\n        _;\r\n    }\r\n\r\n    // Constructor\r\n    // @notice RAOToken Contract\r\n    // @return the transaction address\r\n    function RAOToken(address _multisig) public {\r\n        require(_multisig != 0x0);\r\n        multisig = _multisig;\r\n        RATE = initialPrice;\r\n        startTime = now;\r\n\r\n        // the balances will be sealed for 6 months\r\n        sealdate = startTime + 180 days;\r\n\r\n        // for now the token sale will run for 30 days\r\n        endTime = startTime + 60 days;\r\n        balances[multisig] = _totalSupply;\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Payable method\r\n    // @notice Anyone can buy the tokens on tokensale by paying ether\r\n    function () external payable {\r\n        \r\n        if (!validPurchase()) {\r\n            refundFunds(msg.sender);\r\n        }\r\n        \r\n        tokensale(msg.sender);\r\n    }\r\n\r\n    function whitelisted(address user) public constant returns (bool) {\r\n        return whitelist[user];\r\n    }\r\n\r\n    // @notice tokensale\r\n    // @param recipient The address of the recipient\r\n    // @return the transaction address and send the event as Transfer\r\n    function tokensale(address recipient) internal canMint isActive saleIsOpen {\r\n        require(recipient != 0x0);\r\n        require(whitelisted(recipient));\r\n        \r\n        uint256 weiAmount = msg.value;\r\n        uint256 numberRaoToken = weiAmount.mul(RATE).div(1 ether);\r\n        \r\n        require(_icoSupply >= numberRaoToken);   \r\n                \r\n        totalNumberTokenSold = totalNumberTokenSold.add(numberRaoToken);\r\n\r\n        _icoSupply = _icoSupply.sub(numberRaoToken);\r\n\r\n        TokenPurchase(msg.sender, recipient, weiAmount, numberRaoToken);\r\n\r\n         if (weiAmount < kycLevel) {\r\n            updateBalances(recipient, numberRaoToken);\r\n         } else {\r\n            balancesWaitingKYC[recipient] = balancesWaitingKYC[recipient].add(numberRaoToken); \r\n         }\r\n        forwardFunds();\r\n        // a sender can only buy once per white list entry\r\n        setWhitelistStatus(recipient, false);\r\n         \r\n    }\r\n    \r\n    function updateBalances(address receiver, uint256 tokens) internal {\r\n        balances[multisig] = balances[multisig].sub(tokens);\r\n        balances[receiver] = balances[receiver].add(tokens);\r\n    }\r\n    \r\n    //refund back if not KYC approved\r\n     function refundFunds(address origin) internal {\r\n        origin.transfer(msg.value);\r\n    }\r\n\r\n    // send ether to the fund collection wallet\r\n    // override to create custom fund forwarding mechanisms\r\n    function forwardFunds() internal {\r\n        multisig.transfer(msg.value);\r\n    }\r\n\r\n    function setWhitelistStatus(address user,bool status) public returns (bool) {\r\n        if (status == true) {\r\n            //only owner can set whitelist\r\n            require(msg.sender == owner);\r\n            whitelist[user] = true;        \r\n        } else {\r\n            // owner and the user themselves can remove them selves from whitelist\r\n            require(msg.sender == owner || msg.sender == user);\r\n            whitelist[user] = false;\r\n        }\r\n        return whitelist[user];\r\n    }\r\n    \r\n    function setWhitelistForBulk(address[] listAddresses, bool status) public onlyOwner {\r\n        for (uint256 i = 0; i < listAddresses.length; i++) {\r\n            whitelist[listAddresses[i]] = status;\r\n        }\r\n    }\r\n    \r\n    // @return true if the transaction can buy tokens\r\n    function validPurchase() internal constant returns (bool) {\r\n        bool withinPeriod = getNow() >= startTime && getNow() <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        bool notReachedHardCap = hardCap >= totalNumberTokenSold;\r\n        return withinPeriod && nonZeroPurchase && notReachedHardCap;\r\n    }\r\n\r\n    // @return true if crowdsale current lot event has ended\r\n    function hasEnded() public constant returns (bool) {\r\n        return getNow() > endTime;\r\n    }\r\n\r\n    function getNow() public constant returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    // Set/change Multi-signature wallet address\r\n    function changeMultiSignatureWallet (address _multisig) public onlyOwner isActive {\r\n        multisig = _multisig;\r\n    }\r\n\r\n    // Change ETH/Token exchange rate\r\n    function changeTokenRate(uint _tokenPrice) public onlyOwner isActive {\r\n        RATE = _tokenPrice;\r\n    }\r\n\r\n    // Set Finish Minting.\r\n    function finishMinting() public onlyOwner isActive {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n    }\r\n\r\n\r\n\r\n    // Start or pause tradable to Transfer token\r\n    function startTradable(bool _tradable) public onlyOwner isActive {\r\n        tradable = _tradable;\r\n        if (tradable)\r\n            StartTradable();\r\n        else\r\n            PauseTradable();\r\n    }\r\n\r\n    //UpdateICODateTime(uint256 _startTime,)\r\n    function updateICODate(uint256 _startTime, uint256 _endTime) public onlyOwner {\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n    \r\n    //Change startTime to start ICO manually\r\n    function changeStartTime(uint256 _startTime) public onlyOwner {\r\n        startTime = _startTime;\r\n    }\r\n\r\n    //Change endTime to end ICO manually\r\n    function changeEndTime(uint256 _endTime) public onlyOwner {\r\n        endTime = _endTime;\r\n    }\r\n\r\n    // @return total tokens supplied\r\n    function totalSupply() public constant returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    // @return total tokens supplied\r\n    function totalNumberTokenSold() public constant returns (uint256) {\r\n        return totalNumberTokenSold;\r\n    }\r\n\r\n\r\n    //Change total supply\r\n    function changeTotalSupply(uint256 newSupply) public onlyOwner {\r\n        _totalSupply = newSupply;\r\n    }\r\n\r\n\r\n    // What is the balance of a particular account?\r\n    // @param who The address of the particular account\r\n    // @return the balance the particular account\r\n    function balanceOf(address who) public constant returns (uint256) {\r\n        return balances[who];\r\n    }\r\n\r\n\r\n    function vaultBalanceOf(address who) public constant returns (uint256) {\r\n        return vault[who];\r\n    }\r\n\r\n    function transferToVault(address recipient, uint256 amount) public onlyOwner isActive {\r\n        require (\r\n            balances[multisig] >= amount && amount > 0\r\n        );\r\n\r\n        balances[multisig] = balances[multisig].sub(amount);\r\n        // sending tokens to vault is not part of ICO, its a decision made by the owner\r\n        // _icoSupply = _icoSupply.sub(amount);\r\n        vault[recipient] = vault[recipient].add(amount);\r\n\r\n    }\r\n\r\n    // What is the balance of a particular account?\r\n    // @param who The address of the particular account\r\n    // @return the balance of KYC waiting to be approved\r\n    function balanceOfKyCToBeApproved(address who) public constant returns (uint256) {\r\n        return balancesWaitingKYC[who];\r\n    }\r\n    \r\n\r\n    function approveBalancesWaitingKYC(address[] listAddresses) public onlyOwner {\r\n         for (uint256 i = 0; i < listAddresses.length; i++) {\r\n             address client = listAddresses[i];\r\n             balances[multisig] = balances[multisig].sub(balancesWaitingKYC[client]);\r\n             balances[client] = balances[client].add(balancesWaitingKYC[client]);\r\n             balancesWaitingKYC[client] = 0;\r\n        }\r\n    }\r\n\r\n    function remit() public {\r\n        require(vault[msg.sender] > 0 && now >= sealdate);\r\n        balances[msg.sender] = balances[msg.sender].add(vault[msg.sender]);\r\n        vault[msg.sender] = 0;\r\n    }\r\n\r\n    function remitFor(address person) public onlyOwner {\r\n        require(vault[person] > 0 && now >= sealdate);\r\n        balances[person] = balances[person].add(vault[person]);\r\n        vault[person] = 0;\r\n    }\r\n\r\n    function addTimeToSeal(uint256 time) public onlyOwner {\r\n        sealdate = sealdate.add(time);\r\n    }\r\n\r\n    function setSealDate(uint256 _sealdate) public onlyOwner {\r\n        sealdate = _sealdate;\r\n    } \r\n\r\n    function resetTimeSeal() public onlyOwner {\r\n        sealdate = now;\r\n    }\r\n\r\n    function getSealDate() public constant returns (uint256) {\r\n        return sealdate;\r\n    }\r\n\r\n    \r\n    function modifyCurrentHardCap(uint256 _hardCap) public onlyOwner isActive {\r\n        hardCap = _hardCap;\r\n    }\r\n\r\n\r\n    function burn(uint256 _value) public {\r\n        require(_value <= balances[multisig]);\r\n        balances[multisig] = balances[multisig].sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);\r\n        Burn(multisig, _value);\r\n        \r\n    }\r\n\r\n\r\n    // @notice send `value` token to `to` from `msg.sender`\r\n    // @param to The address of the recipient\r\n    // @param value The amount of token to be transferred\r\n    // @return the transaction address and send the event as Transfer\r\n    function transfer(address to, uint256 value) public canTradable isActive {\r\n        require (\r\n            balances[msg.sender] >= value && value > 0\r\n        );\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        Transfer(msg.sender, to, value);\r\n    }\r\n    \r\n    function transferToAll(address[] tos, uint256[] values) public onlyOwner canTradable isActive {\r\n        require(\r\n            tos.length == values.length\r\n            );\r\n        \r\n        for(uint256 i = 0; i < tos.length; i++){\r\n        require(_icoSupply >= values[i]);   \r\n        totalNumberTokenSold = totalNumberTokenSold.add(values[i]);\r\n        _icoSupply = _icoSupply.sub(values[i]);\r\n        updateBalances(tos[i],values[i]);\r\n        }\r\n    }\r\n\r\n    // @notice send `value` token to `to` from `from`\r\n    // @param from The address of the sender\r\n    // @param to The address of the recipient\r\n    // @param value The amount of token to be transferred\r\n    // @return the transaction address and send the event as Transfer\r\n    function transferFrom(address from, address to, uint256 value) public canTradable isActive {\r\n        require (\r\n            allowed[from][msg.sender] >= value && balances[from] >= value && value > 0\r\n        );\r\n        balances[from] = balances[from].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\r\n        Transfer(from, to, value);\r\n    }\r\n\r\n    // Allow spender to withdraw from your account, multiple times, up to the value amount.\r\n    // If this function is called again it overwrites the current allowance with value.\r\n    // @param spender The address of the sender\r\n    // @param value The amount to be approved\r\n    // @return the transaction address and send the event as Approval\r\n    function approve(address spender, uint256 value) public isActive {\r\n        require (\r\n            balances[msg.sender] >= value && value > 0\r\n        );\r\n        allowed[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n    }\r\n\r\n    // Check the allowed value for the spender to withdraw from owner\r\n    // @param owner The address of the owner\r\n    // @param spender The address of the spender\r\n    // @return the amount which spender is still allowed to withdraw from owner\r\n    function allowance(address _owner, address spender) public constant returns (uint256) {\r\n        return allowed[_owner][spender];\r\n    }\r\n\r\n    // Get current price of a Token\r\n    // @return the price or token value for a ether\r\n    function getRate() public constant returns (uint256 result) {\r\n      return RATE;\r\n    }\r\n    \r\n    function getTokenDetail() public constant returns (string, string, uint256, uint256, uint256, uint256, uint256) {\r\n        return (name, symbol, startTime, endTime, _totalSupply, _icoSupply, totalNumberTokenSold);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setWhitelistStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"person\",\"type\":\"address\"}],\"name\":\"remitFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"updateICODate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNumberTokenSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenDetail\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"changeEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"vaultBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_icoSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listAddresses\",\"type\":\"address[]\"}],\"name\":\"approveBalancesWaitingKYC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sealdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"name\":\"changeTokenRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSupply\",\"type\":\"uint256\"}],\"name\":\"changeTotalSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listAddresses\",\"type\":\"address[]\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setWhitelistForBulk\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hardCap\",\"type\":\"uint256\"}],\"name\":\"modifyCurrentHardCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sealdate\",\"type\":\"uint256\"}],\"name\":\"setSealDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"}],\"name\":\"changeMultiSignatureWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"remit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"changeStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOfKyCToBeApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradable\",\"type\":\"bool\"}],\"name\":\"startTradable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kycLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSealDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"addTimeToSeal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tos\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"transferToAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberDecimal18\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetTimeSeal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_softcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StartTradable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseTradable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HaltTokenAllOperation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ResumeTokenAllOperation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RAOToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f21778fde6fe2baeccaf478f517e646ab9f6f465","Library":"","SwarmSource":"bzzr://9d83c9b0e5b68284e9a182dc22f3b922d0cccc8e9f74c0fc8f5ff840d6614eba"}]}