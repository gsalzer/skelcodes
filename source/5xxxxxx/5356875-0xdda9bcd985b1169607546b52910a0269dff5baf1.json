{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// GOO - Crypto Idle Game\r\n// https://ethergoo.io\r\n\r\ncontract Goo is ERC20 {\r\n    \r\n    string public constant name  = \"IdleEth\";\r\n    string public constant symbol = \"Goo\";\r\n    uint8 public constant decimals = 0;\r\n    uint256 private roughSupply;\r\n    uint256 public totalGooProduction;\r\n    address public owner; // Minor management of game\r\n    bool public gameStarted;\r\n    \r\n    uint256 public totalEtherGooResearchPool; // Eth dividends to be split between players' goo production\r\n    uint256[] public totalGooProductionSnapshots; // The total goo production for each prior day past\r\n    uint256[] public allocatedGooResearchSnapshots; // The research eth allocated to each prior day past\r\n    uint256 public nextSnapshotTime;\r\n    \r\n    uint256 private MAX_PRODUCTION_UNITS = 999; // Per type (makes balancing slightly easier)\r\n    uint256 private constant RAFFLE_TICKET_BASE_GOO_PRICE = 1000;\r\n    \r\n    // Balances for each player\r\n    mapping(address => uint256) private ethBalance;\r\n    mapping(address => uint256) private gooBalance;\r\n    mapping(address => mapping(uint256 => uint256)) private gooProductionSnapshots; // Store player's goo production for given day (snapshot)\r\n    mapping(address => mapping(uint256 => bool)) private gooProductionZeroedSnapshots; // This isn't great but we need know difference between 0 production and an unused/inactive day.\r\n    \r\n    mapping(address => uint256) private lastGooSaveTime; // Seconds (last time player claimed their produced goo)\r\n    mapping(address => uint256) public lastGooProductionUpdate; // Days (last snapshot player updated their production)\r\n    mapping(address => uint256) private lastGooResearchFundClaim; // Days (snapshot number)\r\n    mapping(address => uint256) private battleCooldown; // If user attacks they cannot attack again for short time\r\n    \r\n    // Stuff owned by each player\r\n    mapping(address => mapping(uint256 => uint256)) private unitsOwned;\r\n    mapping(address => mapping(uint256 => bool)) private upgradesOwned;\r\n    mapping(uint256 => address) private rareItemOwner;\r\n    mapping(uint256 => uint256) private rareItemPrice;\r\n    \r\n    // Rares & Upgrades (Increase unit's production / attack etc.)\r\n    mapping(address => mapping(uint256 => uint256)) private unitGooProductionIncreases; // Adds to the goo per second\r\n    mapping(address => mapping(uint256 => uint256)) private unitGooProductionMultiplier; // Multiplies the goo per second\r\n    mapping(address => mapping(uint256 => uint256)) private unitAttackIncreases;\r\n    mapping(address => mapping(uint256 => uint256)) private unitAttackMultiplier;\r\n    mapping(address => mapping(uint256 => uint256)) private unitDefenseIncreases;\r\n    mapping(address => mapping(uint256 => uint256)) private unitDefenseMultiplier;\r\n    mapping(address => mapping(uint256 => uint256)) private unitGooStealingIncreases;\r\n    mapping(address => mapping(uint256 => uint256)) private unitGooStealingMultiplier;\r\n    \r\n    // Mapping of approved ERC20 transfers (by player)\r\n    mapping(address => mapping(address => uint256)) private allowed;\r\n    mapping(address => bool) private protectedAddresses; // For npc exchanges (requires 0 goo production)\r\n    \r\n    // Raffle structures\r\n    struct TicketPurchases {\r\n        TicketPurchase[] ticketsBought;\r\n        uint256 numPurchases; // Allows us to reset without clearing TicketPurchase[] (avoids potential for gas limit)\r\n        uint256 raffleRareId;\r\n    }\r\n    \r\n    // Allows us to query winner without looping (avoiding potential for gas limit)\r\n    struct TicketPurchase {\r\n        uint256 startId;\r\n        uint256 endId;\r\n    }\r\n    \r\n    // Raffle tickets\r\n    mapping(address => TicketPurchases) private ticketsBoughtByPlayer;\r\n    mapping(uint256 => address[]) private rafflePlayers; // Keeping a seperate list for each raffle has it's benefits.\r\n\r\n    // Current raffle info\r\n    uint256 private raffleEndTime;\r\n    uint256 private raffleRareId;\r\n    uint256 private raffleTicketsBought;\r\n    address private raffleWinner; // Address of winner\r\n    bool private raffleWinningTicketSelected;\r\n    uint256 private raffleTicketThatWon;\r\n    \r\n    // Minor game events\r\n    event UnitBought(address player, uint256 unitId, uint256 amount);\r\n    event UnitSold(address player, uint256 unitId, uint256 amount);\r\n    event PlayerAttacked(address attacker, address target, bool success, uint256 gooStolen);\r\n    \r\n    GooGameConfig schema;\r\n    \r\n    // Constructor\r\n    function Goo() public payable {\r\n        owner = msg.sender;\r\n        schema = GooGameConfig(0x21912e81d7eff8bff895302b45da76f7f070e3b9);\r\n    }\r\n    \r\n    function() payable { }\r\n    \r\n    function beginGame(uint256 firstDivsTime) external payable {\r\n        require(msg.sender == owner);\r\n        require(!gameStarted);\r\n        \r\n        gameStarted = true; // GO-OOOO!\r\n        nextSnapshotTime = firstDivsTime;\r\n        totalEtherGooResearchPool = msg.value; // Seed pot\r\n    }\r\n    \r\n    function totalSupply() public constant returns(uint256) {\r\n        return roughSupply; // Stored goo (rough supply as it ignores earned/unclaimed goo)\r\n    }\r\n    \r\n    function balanceOf(address player) public constant returns(uint256) {\r\n        return gooBalance[player] + balanceOfUnclaimedGoo(player);\r\n    }\r\n    \r\n    function balanceOfUnclaimedGoo(address player) internal constant returns (uint256) {\r\n        if (lastGooSaveTime[player] > 0 && lastGooSaveTime[player] < block.timestamp) {\r\n            return (getGooProduction(player) * (block.timestamp - lastGooSaveTime[player]));\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    function etherBalanceOf(address player) public constant returns(uint256) {\r\n        return ethBalance[player];\r\n    }\r\n    \r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        updatePlayersGoo(msg.sender);\r\n        require(amount <= gooBalance[msg.sender]);\r\n        \r\n        gooBalance[msg.sender] -= amount;\r\n        gooBalance[recipient] += amount;\r\n        \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\r\n        updatePlayersGoo(player);\r\n        require(amount <= allowed[player][msg.sender] && amount <= gooBalance[msg.sender]);\r\n        \r\n        gooBalance[player] -= amount;\r\n        gooBalance[recipient] += amount;\r\n        allowed[player][msg.sender] -= amount;\r\n        \r\n        emit Transfer(player, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address approvee, uint256 amount) public returns (bool){\r\n        allowed[msg.sender][approvee] = amount;\r\n        emit Approval(msg.sender, approvee, amount);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address player, address approvee) public constant returns(uint256){\r\n        return allowed[player][approvee];\r\n    }\r\n    \r\n    function getGooProduction(address player) public constant returns (uint256){\r\n        return gooProductionSnapshots[player][lastGooProductionUpdate[player]];\r\n    }\r\n    \r\n    function updatePlayersGoo(address player) internal {\r\n        uint256 gooGain = balanceOfUnclaimedGoo(player);\r\n        lastGooSaveTime[player] = block.timestamp;\r\n        roughSupply += gooGain;\r\n        gooBalance[player] += gooGain;\r\n    }\r\n    \r\n    function updatePlayersGooFromPurchase(address player, uint256 purchaseCost) internal {\r\n        uint256 unclaimedGoo = balanceOfUnclaimedGoo(player);\r\n        \r\n        if (purchaseCost > unclaimedGoo) {\r\n            uint256 gooDecrease = purchaseCost - unclaimedGoo;\r\n            roughSupply -= gooDecrease;\r\n            gooBalance[player] -= gooDecrease;\r\n        } else {\r\n            uint256 gooGain = unclaimedGoo - purchaseCost;\r\n            roughSupply += gooGain;\r\n            gooBalance[player] += gooGain;\r\n        }\r\n        \r\n        lastGooSaveTime[player] = block.timestamp;\r\n    }\r\n    \r\n    function increasePlayersGooProduction(uint256 increase) internal {\r\n        gooProductionSnapshots[msg.sender][allocatedGooResearchSnapshots.length] = getGooProduction(msg.sender) + increase;\r\n        lastGooProductionUpdate[msg.sender] = allocatedGooResearchSnapshots.length;\r\n        totalGooProduction += increase;\r\n    }\r\n    \r\n    function reducePlayersGooProduction(address player, uint256 decrease) internal {\r\n        uint256 previousProduction = getGooProduction(player);\r\n        uint256 newProduction = SafeMath.sub(previousProduction, decrease);\r\n        \r\n        if (newProduction == 0) { // Special case which tangles with \"inactive day\" snapshots (claiming divs)\r\n            gooProductionZeroedSnapshots[player][allocatedGooResearchSnapshots.length] = true;\r\n            delete gooProductionSnapshots[player][allocatedGooResearchSnapshots.length]; // 0\r\n        } else {\r\n            gooProductionSnapshots[player][allocatedGooResearchSnapshots.length] = newProduction;\r\n        }\r\n        \r\n        lastGooProductionUpdate[player] = allocatedGooResearchSnapshots.length;\r\n        totalGooProduction -= decrease;\r\n    }\r\n    \r\n    function buyBasicUnit(uint256 unitId, uint256 amount) external {\r\n        require(gameStarted);\r\n        require(schema.validUnitId(unitId));\r\n        require(unitsOwned[msg.sender][unitId] + amount <= MAX_PRODUCTION_UNITS);\r\n        \r\n        uint256 unitCost = schema.getGooCostForUnit(unitId, unitsOwned[msg.sender][unitId], amount);\r\n        require(balanceOf(msg.sender) >= unitCost);\r\n        require(schema.unitEthCost(unitId) == 0); // Free unit\r\n        \r\n        // Update players goo\r\n        updatePlayersGooFromPurchase(msg.sender, unitCost);\r\n        \r\n        if (schema.unitGooProduction(unitId) > 0) {\r\n            increasePlayersGooProduction(getUnitsProduction(msg.sender, unitId, amount));\r\n        }\r\n        \r\n        unitsOwned[msg.sender][unitId] += amount;\r\n        emit UnitBought(msg.sender, unitId, amount);\r\n    }\r\n    \r\n    function buyEthUnit(uint256 unitId, uint256 amount) external payable {\r\n        require(gameStarted);\r\n        require(schema.validUnitId(unitId));\r\n        require(unitsOwned[msg.sender][unitId] + amount <= MAX_PRODUCTION_UNITS);\r\n        \r\n        uint256 unitCost = schema.getGooCostForUnit(unitId, unitsOwned[msg.sender][unitId], amount);\r\n        uint256 ethCost = SafeMath.mul(schema.unitEthCost(unitId), amount);\r\n        \r\n        require(balanceOf(msg.sender) >= unitCost);\r\n        require(ethBalance[msg.sender] + msg.value >= ethCost);\r\n        \r\n        // Update players goo\r\n        updatePlayersGooFromPurchase(msg.sender, unitCost);\r\n\r\n        if (ethCost > msg.value) {\r\n            ethBalance[msg.sender] -= (ethCost - msg.value);\r\n        }\r\n        \r\n        uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\r\n        uint256 dividends = (ethCost - devFund) / 4; // 25% goes to pool (75% retained for sale value)\r\n        totalEtherGooResearchPool += dividends;\r\n        ethBalance[owner] += devFund;\r\n        \r\n        if (schema.unitGooProduction(unitId) > 0) {\r\n            increasePlayersGooProduction(getUnitsProduction(msg.sender, unitId, amount));\r\n        }\r\n        \r\n        unitsOwned[msg.sender][unitId] += amount;\r\n        emit UnitBought(msg.sender, unitId, amount);\r\n    }\r\n    \r\n    function sellUnit(uint256 unitId, uint256 amount) external {\r\n        require(unitsOwned[msg.sender][unitId] >= amount);\r\n        unitsOwned[msg.sender][unitId] -= amount;\r\n        \r\n        uint256 unitSalePrice = (schema.getGooCostForUnit(unitId, unitsOwned[msg.sender][unitId], amount) * 3) / 4; // 75%\r\n        uint256 gooChange = balanceOfUnclaimedGoo(msg.sender) + unitSalePrice; // Claim unsaved goo whilst here\r\n        lastGooSaveTime[msg.sender] = block.timestamp;\r\n        roughSupply += gooChange;\r\n        gooBalance[msg.sender] += gooChange;\r\n        \r\n        if (schema.unitGooProduction(unitId) > 0) {\r\n            reducePlayersGooProduction(msg.sender, getUnitsProduction(msg.sender, unitId, amount));\r\n        }\r\n        \r\n        if (schema.unitEthCost(unitId) > 0) { // Premium units sell for 75% of buy cost\r\n            ethBalance[msg.sender] += ((schema.unitEthCost(unitId) * amount) * 3) / 4;\r\n        }\r\n        emit UnitSold(msg.sender, unitId, amount);\r\n    }\r\n    \r\n    function buyUpgrade(uint256 upgradeId) external payable {\r\n        require(gameStarted);\r\n        require(schema.validUpgradeId(upgradeId)); // Valid upgrade\r\n        require(!upgradesOwned[msg.sender][upgradeId]); // Haven't already purchased\r\n        \r\n        uint256 gooCost;\r\n        uint256 ethCost;\r\n        uint256 upgradeClass;\r\n        uint256 unitId;\r\n        uint256 upgradeValue;\r\n        (gooCost, ethCost, upgradeClass, unitId, upgradeValue) = schema.getUpgradeInfo(upgradeId);\r\n        \r\n        require(balanceOf(msg.sender) >= gooCost);\r\n        \r\n        if (ethCost > 0) {\r\n            require(ethBalance[msg.sender] + msg.value >= ethCost);\r\n             if (ethCost > msg.value) { // They can use their balance instead\r\n                ethBalance[msg.sender] -= (ethCost - msg.value);\r\n            }\r\n        \r\n            uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\r\n            totalEtherGooResearchPool += (ethCost - devFund); // Rest goes to div pool (Can't sell upgrades)\r\n            ethBalance[owner] += devFund;\r\n        }\r\n        \r\n        // Update players goo\r\n        updatePlayersGooFromPurchase(msg.sender, gooCost);\r\n\r\n        upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue);\r\n        upgradesOwned[msg.sender][upgradeId] = true;\r\n    }\r\n    \r\n    function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\r\n        uint256 productionGain;\r\n        if (upgradeClass == 0) {\r\n            unitGooProductionIncreases[player][unitId] += upgradeValue;\r\n            productionGain = (unitsOwned[player][unitId] * upgradeValue * (10 + unitGooProductionMultiplier[player][unitId])) / 10;\r\n            increasePlayersGooProduction(productionGain);\r\n        } else if (upgradeClass == 1) {\r\n            unitGooProductionMultiplier[player][unitId] += upgradeValue;\r\n            productionGain = (unitsOwned[player][unitId] * upgradeValue * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId])) / 10;\r\n            increasePlayersGooProduction(productionGain);\r\n        } else if (upgradeClass == 2) {\r\n            unitAttackIncreases[player][unitId] += upgradeValue;\r\n        } else if (upgradeClass == 3) {\r\n            unitAttackMultiplier[player][unitId] += upgradeValue;\r\n        } else if (upgradeClass == 4) {\r\n            unitDefenseIncreases[player][unitId] += upgradeValue;\r\n        } else if (upgradeClass == 5) {\r\n            unitDefenseMultiplier[player][unitId] += upgradeValue;\r\n        } else if (upgradeClass == 6) {\r\n            unitGooStealingIncreases[player][unitId] += upgradeValue;\r\n        } else if (upgradeClass == 7) {\r\n            unitGooStealingMultiplier[player][unitId] += upgradeValue;\r\n        }\r\n    }\r\n    \r\n    function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\r\n        uint256 productionLoss;\r\n        if (upgradeClass == 0) {\r\n            unitGooProductionIncreases[player][unitId] -= upgradeValue;\r\n            productionLoss = (unitsOwned[player][unitId] * upgradeValue * (10 + unitGooProductionMultiplier[player][unitId])) / 10;\r\n            reducePlayersGooProduction(player, productionLoss);\r\n        } else if (upgradeClass == 1) {\r\n            unitGooProductionMultiplier[player][unitId] -= upgradeValue;\r\n            productionLoss = (unitsOwned[player][unitId] * upgradeValue * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId])) / 10;\r\n            reducePlayersGooProduction(player, productionLoss);\r\n        } else if (upgradeClass == 2) {\r\n            unitAttackIncreases[player][unitId] -= upgradeValue;\r\n        } else if (upgradeClass == 3) {\r\n            unitAttackMultiplier[player][unitId] -= upgradeValue;\r\n        } else if (upgradeClass == 4) {\r\n            unitDefenseIncreases[player][unitId] -= upgradeValue;\r\n        } else if (upgradeClass == 5) {\r\n            unitDefenseMultiplier[player][unitId] -= upgradeValue;\r\n        } else if (upgradeClass == 6) {\r\n            unitGooStealingIncreases[player][unitId] -= upgradeValue;\r\n        } else if (upgradeClass == 7) {\r\n            unitGooStealingMultiplier[player][unitId] -= upgradeValue;\r\n        }\r\n    }\r\n    \r\n    function buyRareItem(uint256 rareId) external payable {\r\n        require(schema.validRareId(rareId));\r\n        \r\n        address previousOwner = rareItemOwner[rareId];\r\n        require(previousOwner != 0);\r\n\r\n        uint256 ethCost = rareItemPrice[rareId];\r\n        require(ethBalance[msg.sender] + msg.value >= ethCost);\r\n        \r\n        // We have to claim buyer's goo before updating their production values\r\n        updatePlayersGoo(msg.sender);\r\n        \r\n        uint256 upgradeClass;\r\n        uint256 unitId;\r\n        uint256 upgradeValue;\r\n        (upgradeClass, unitId, upgradeValue) = schema.getRareInfo(rareId);\r\n        upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue);\r\n        \r\n        // We have to claim seller's goo before reducing their production values\r\n        updatePlayersGoo(previousOwner);\r\n        removeUnitMultipliers(previousOwner, upgradeClass, unitId, upgradeValue);\r\n        \r\n        // Splitbid/Overbid\r\n        if (ethCost > msg.value) {\r\n            // Earlier require() said they can still afford it (so use their ingame balance)\r\n            ethBalance[msg.sender] -= (ethCost - msg.value);\r\n        } else if (msg.value > ethCost) {\r\n            // Store overbid in their balance\r\n            ethBalance[msg.sender] += msg.value - ethCost;\r\n        }\r\n        \r\n        // Distribute ethCost\r\n        uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\r\n        uint256 dividends = ethCost / 20; // 5% goes to pool (~93% goes to player)\r\n        totalEtherGooResearchPool += dividends;\r\n        ethBalance[owner] += devFund;\r\n        \r\n        // Transfer / update rare item\r\n        rareItemOwner[rareId] = msg.sender;\r\n        rareItemPrice[rareId] = (ethCost * 5) / 4; // 25% price flip increase\r\n        ethBalance[previousOwner] += ethCost - (dividends + devFund);\r\n    }\r\n    \r\n    function withdrawEther(uint256 amount) external {\r\n        require(amount <= ethBalance[msg.sender]);\r\n        ethBalance[msg.sender] -= amount;\r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    function claimResearchDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\r\n        require(startSnapshot <= endSnapShot);\r\n        require(startSnapshot >= lastGooResearchFundClaim[msg.sender]);\r\n        require(endSnapShot < allocatedGooResearchSnapshots.length);\r\n        \r\n        uint256 researchShare;\r\n        uint256 previousProduction = gooProductionSnapshots[msg.sender][lastGooResearchFundClaim[msg.sender] - 1]; // Underflow won't be a problem as gooProductionSnapshots[][0xffffffffff] = 0;\r\n        for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\r\n            \r\n            // Slightly complex things by accounting for days/snapshots when user made no tx's\r\n            uint256 productionDuringSnapshot = gooProductionSnapshots[msg.sender][i];\r\n            bool soldAllProduction = gooProductionZeroedSnapshots[msg.sender][i];\r\n            if (productionDuringSnapshot == 0 && !soldAllProduction) {\r\n                productionDuringSnapshot = previousProduction;\r\n            } else {\r\n               previousProduction = productionDuringSnapshot;\r\n            }\r\n            \r\n            researchShare += (allocatedGooResearchSnapshots[i] * productionDuringSnapshot) / totalGooProductionSnapshots[i];\r\n        }\r\n        \r\n        \r\n        if (gooProductionSnapshots[msg.sender][endSnapShot] == 0 && !gooProductionZeroedSnapshots[msg.sender][i] && previousProduction > 0) {\r\n            gooProductionSnapshots[msg.sender][endSnapShot] = previousProduction; // Checkpoint for next claim\r\n        }\r\n        \r\n        lastGooResearchFundClaim[msg.sender] = endSnapShot + 1;\r\n        \r\n        uint256 referalDivs;\r\n        if (referer != address(0) && referer != msg.sender) {\r\n            referalDivs = researchShare / 100; // 1%\r\n            ethBalance[referer] += referalDivs;\r\n        }\r\n        \r\n        ethBalance[msg.sender] += researchShare - referalDivs;\r\n    }\r\n    \r\n    // Allocate divs for the day (cron job)\r\n    function snapshotDailyGooResearchFunding() external {\r\n        require(msg.sender == owner);\r\n        //require(block.timestamp >= (nextSnapshotTime - 30 minutes)); // Small bit of leeway for cron / network\r\n        \r\n        uint256 todaysEtherResearchFund = (totalEtherGooResearchPool / 10); // 10% of pool daily\r\n        totalEtherGooResearchPool -= todaysEtherResearchFund;\r\n        \r\n        totalGooProductionSnapshots.push(totalGooProduction);\r\n        allocatedGooResearchSnapshots.push(todaysEtherResearchFund);\r\n        nextSnapshotTime = block.timestamp + 24 hours;\r\n    }\r\n    \r\n    \r\n    \r\n    // Raffle for rare items\r\n    function buyRaffleTicket(uint256 amount) external {\r\n        require(raffleEndTime >= block.timestamp);\r\n        require(amount > 0);\r\n        \r\n        uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount);\r\n        require(balanceOf(msg.sender) >= ticketsCost);\r\n        \r\n        // Update players goo\r\n        updatePlayersGooFromPurchase(msg.sender, ticketsCost);\r\n        \r\n        // Handle new tickets\r\n        TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\r\n        \r\n        // If we need to reset tickets from a previous raffle\r\n        if (purchases.raffleRareId != raffleRareId) {\r\n            purchases.numPurchases = 0;\r\n            purchases.raffleRareId = raffleRareId;\r\n            rafflePlayers[raffleRareId].push(msg.sender); // Add user to raffle\r\n        }\r\n        \r\n        // Store new ticket purchase \r\n        if (purchases.numPurchases == purchases.ticketsBought.length) {\r\n            purchases.ticketsBought.length += 1;\r\n        }\r\n        purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1)); // (eg: buy 10, get id's 0-9)\r\n        \r\n        // Finally update ticket total\r\n        raffleTicketsBought += amount;\r\n    }\r\n    \r\n    function startRareRaffle(uint256 endTime, uint256 rareId) external {\r\n        require(msg.sender == owner);\r\n        require(schema.validRareId(rareId));\r\n        require(rareItemOwner[rareId] == 0);\r\n        \r\n        // Reset previous raffle info\r\n        raffleWinningTicketSelected = false;\r\n        raffleTicketThatWon = 0;\r\n        raffleWinner = 0;\r\n        raffleTicketsBought = 0;\r\n        \r\n        // Set current raffle info\r\n        raffleEndTime = endTime;\r\n        raffleRareId = rareId;\r\n    }\r\n    \r\n    function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\r\n        require(raffleEndTime < block.timestamp);\r\n        require(raffleWinner == 0);\r\n        require(rareItemOwner[raffleRareId] == 0);\r\n        \r\n        if (!raffleWinningTicketSelected) {\r\n            drawRandomWinner(); // Ideally do it in one call (gas limit cautious)\r\n        }\r\n        \r\n        // Reduce gas by (optionally) offering an address to _check_ for winner\r\n        if (checkWinner != 0) {\r\n            TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\r\n            if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId) {\r\n                TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\r\n                if (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\r\n                    assignRafflePrize(checkWinner); // WINNER!\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Otherwise just naively try to find the winner (will work until mass amounts of players)\r\n        for (uint256 i = 0; i < rafflePlayers[raffleRareId].length; i++) {\r\n            address player = rafflePlayers[raffleRareId][i];\r\n            TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\r\n            \r\n            uint256 endIndex = playersTickets.numPurchases - 1;\r\n            // Minor optimization to avoid checking every single player\r\n            if (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\r\n                for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\r\n                    TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\r\n                    if (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\r\n                        assignRafflePrize(player); // WINNER!\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function assignRafflePrize(address winner) internal {\r\n        raffleWinner = winner;\r\n        rareItemOwner[raffleRareId] = winner;\r\n        rareItemPrice[raffleRareId] = (schema.rareStartPrice(raffleRareId) * 21) / 20; // Buy price slightly higher (Div pool cut)\r\n        \r\n        updatePlayersGoo(winner);\r\n        uint256 upgradeClass;\r\n        uint256 unitId;\r\n        uint256 upgradeValue;\r\n        (upgradeClass, unitId, upgradeValue) = schema.getRareInfo(raffleRareId);\r\n        upgradeUnitMultipliers(winner, upgradeClass, unitId, upgradeValue);\r\n    }\r\n    \r\n    // Random enough for small contests (Owner only to prevent trial & error execution)\r\n    function drawRandomWinner() public {\r\n        require(msg.sender == owner);\r\n        require(raffleEndTime < block.timestamp);\r\n        require(!raffleWinningTicketSelected);\r\n        \r\n        uint256 seed = raffleTicketsBought + block.timestamp;\r\n        raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\r\n        raffleWinningTicketSelected = true;\r\n    }\r\n    \r\n    \r\n    \r\n    function protectAddress(address exchange, bool isProtected) external {\r\n        require(msg.sender == owner);\r\n        require(getGooProduction(exchange) == 0); // Can't protect actual players\r\n        protectedAddresses[exchange] = isProtected;\r\n    }\r\n    \r\n    function attackPlayer(address target) external {\r\n        require(battleCooldown[msg.sender] < block.timestamp);\r\n        require(target != msg.sender);\r\n        require(!protectedAddresses[target]); //target not whitelisted (i.e. exchange wallets)\r\n        \r\n        uint256 attackingPower;\r\n        uint256 defendingPower;\r\n        uint256 stealingPower;\r\n        (attackingPower, defendingPower, stealingPower) = getPlayersBattlePower(msg.sender, target);\r\n        \r\n        if (battleCooldown[target] > block.timestamp) { // When on battle cooldown you're vulnerable (starting value is 50% normal power)\r\n            defendingPower = schema.getWeakenedDefensePower(defendingPower);\r\n        }\r\n        \r\n        if (attackingPower > defendingPower) {\r\n            battleCooldown[msg.sender] = block.timestamp + 30 minutes;\r\n            if (balanceOf(target) > stealingPower) {\r\n                // Save all their unclaimed goo, then steal attacker's max capacity (at same time)\r\n                uint256 unclaimedGoo = balanceOfUnclaimedGoo(target);\r\n                if (stealingPower > unclaimedGoo) {\r\n                    uint256 gooDecrease = stealingPower - unclaimedGoo;\r\n                    gooBalance[target] -= gooDecrease;\r\n                } else {\r\n                    uint256 gooGain = unclaimedGoo - stealingPower;\r\n                    gooBalance[target] += gooGain;\r\n                }\r\n                gooBalance[msg.sender] += stealingPower;\r\n                emit PlayerAttacked(msg.sender, target, true, stealingPower);\r\n            } else {\r\n                emit PlayerAttacked(msg.sender, target, true, balanceOf(target));\r\n                gooBalance[msg.sender] += balanceOf(target);\r\n                gooBalance[target] = 0;\r\n            }\r\n            \r\n            lastGooSaveTime[target] = block.timestamp; \r\n            // We don't need to claim/save msg.sender's goo (as production delta is unchanged)\r\n        } else {\r\n            battleCooldown[msg.sender] = block.timestamp + 10 minutes;\r\n            emit PlayerAttacked(msg.sender, target, false, 0);\r\n        }\r\n    }\r\n    \r\n    function getPlayersBattlePower(address attacker, address defender) internal constant returns (uint256, uint256, uint256) {\r\n        uint256 startId;\r\n        uint256 endId;\r\n        (startId, endId) = schema.battleUnitIdRange();\r\n        \r\n        uint256 attackingPower;\r\n        uint256 defendingPower;\r\n        uint256 stealingPower;\r\n\r\n        // Not ideal but will only be a small number of units (and saves gas when buying units)\r\n        while (startId <= endId) {\r\n            attackingPower += getUnitsAttack(attacker, startId, unitsOwned[attacker][startId]);\r\n            stealingPower += getUnitsStealingCapacity(attacker, startId, unitsOwned[attacker][startId]);\r\n            \r\n            defendingPower += getUnitsDefense(defender, startId, unitsOwned[defender][startId]);\r\n            startId++;\r\n        }\r\n        return (attackingPower, defendingPower, stealingPower);\r\n    }\r\n    \r\n    function getPlayersBattleStats(address player) external constant returns (uint256, uint256, uint256) {\r\n        uint256 startId;\r\n        uint256 endId;\r\n        (startId, endId) = schema.battleUnitIdRange();\r\n        \r\n        uint256 attackingPower;\r\n        uint256 defendingPower;\r\n        uint256 stealingPower;\r\n\r\n        // Not ideal but will only be a small number of units (and saves gas when buying units)\r\n        while (startId <= endId) {\r\n            attackingPower += getUnitsAttack(player, startId, unitsOwned[player][startId]);\r\n            stealingPower += getUnitsStealingCapacity(player, startId, unitsOwned[player][startId]);\r\n            defendingPower += getUnitsDefense(player, startId, unitsOwned[player][startId]);\r\n            startId++;\r\n        }\r\n        return (attackingPower, defendingPower, stealingPower);\r\n    }\r\n    \r\n    function getUnitsProduction(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\r\n        return (amount * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId]) * (10 + unitGooProductionMultiplier[player][unitId])) / 10;\r\n    }\r\n    \r\n    function getUnitsAttack(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\r\n        return (amount * (schema.unitAttack(unitId) + unitAttackIncreases[player][unitId]) * (10 + unitAttackMultiplier[player][unitId])) / 10;\r\n    }\r\n    \r\n    function getUnitsDefense(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\r\n        return (amount * (schema.unitDefense(unitId) + unitDefenseIncreases[player][unitId]) * (10 + unitDefenseMultiplier[player][unitId])) / 10;\r\n    }\r\n    \r\n    function getUnitsStealingCapacity(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\r\n        return (amount * (schema.unitStealingCapacity(unitId) + unitGooStealingIncreases[player][unitId]) * (10 + unitGooStealingMultiplier[player][unitId])) / 10;\r\n    }\r\n    \r\n    \r\n    // To display on website\r\n    function getGameInfo() external constant returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256[], bool[]){\r\n        uint256[] memory units = new uint256[](schema.currentNumberOfUnits());\r\n        bool[] memory upgrades = new bool[](schema.currentNumberOfUpgrades());\r\n        \r\n        uint256 startId;\r\n        uint256 endId;\r\n        (startId, endId) = schema.productionUnitIdRange();\r\n        \r\n        uint256 i;\r\n        while (startId <= endId) {\r\n            units[i] = unitsOwned[msg.sender][startId];\r\n            i++;\r\n            startId++;\r\n        }\r\n        \r\n        (startId, endId) = schema.battleUnitIdRange();\r\n        while (startId <= endId) {\r\n            units[i] = unitsOwned[msg.sender][startId];\r\n            i++;\r\n            startId++;\r\n        }\r\n        \r\n        // Reset for upgrades\r\n        i = 0;\r\n        (startId, endId) = schema.upgradeIdRange();\r\n        while (startId <= endId) {\r\n            upgrades[i] = upgradesOwned[msg.sender][startId];\r\n            i++;\r\n            startId++;\r\n        }\r\n        \r\n        return (block.timestamp, totalEtherGooResearchPool, totalGooProduction, nextSnapshotTime, balanceOf(msg.sender), ethBalance[msg.sender], getGooProduction(msg.sender), units, upgrades);\r\n    }\r\n    \r\n    // To display on website\r\n    function getRareItemInfo() external constant returns (address[], uint256[]) {\r\n        address[] memory itemOwners = new address[](schema.currentNumberOfRares());\r\n        uint256[] memory itemPrices = new uint256[](schema.currentNumberOfRares());\r\n        \r\n        uint256 startId;\r\n        uint256 endId;\r\n        (startId, endId) = schema.rareIdRange();\r\n        \r\n        uint256 i;\r\n        while (startId <= endId) {\r\n            itemOwners[i] = rareItemOwner[startId];\r\n            itemPrices[i] = rareItemPrice[startId];\r\n            \r\n            i++;\r\n            startId++;\r\n        }\r\n        \r\n        return (itemOwners, itemPrices);\r\n    }\r\n    \r\n    // To display on website\r\n     function viewUnclaimedResearchDividends() external constant returns (uint256, uint256, uint256) {\r\n        uint256 startSnapshot = lastGooResearchFundClaim[msg.sender];\r\n        uint256 latestSnapshot = allocatedGooResearchSnapshots.length - 1; // No snapshots to begin with\r\n        \r\n        uint256 researchShare;\r\n        uint256 previousProduction = gooProductionSnapshots[msg.sender][lastGooResearchFundClaim[msg.sender] - 1]; // Underflow won't be a problem as gooProductionSnapshots[][0xfffffffffffff] = 0;\r\n        for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\r\n            \r\n            // Slightly complex things by accounting for days/snapshots when user made no tx's\r\n            uint256 productionDuringSnapshot = gooProductionSnapshots[msg.sender][i];\r\n            bool soldAllProduction = gooProductionZeroedSnapshots[msg.sender][i];\r\n            if (productionDuringSnapshot == 0 && !soldAllProduction) {\r\n                productionDuringSnapshot = previousProduction;\r\n            } else {\r\n               previousProduction = productionDuringSnapshot;\r\n            }\r\n            \r\n            researchShare += (allocatedGooResearchSnapshots[i] * productionDuringSnapshot) / totalGooProductionSnapshots[i];\r\n        }\r\n        return (researchShare, startSnapshot, latestSnapshot);\r\n    }\r\n    \r\n    \r\n    // To allow clients to verify contestants\r\n    function getRafflePlayers(uint256 raffleId) external constant returns (address[]) {\r\n        return (rafflePlayers[raffleId]);\r\n    }\r\n    \r\n    // To allow clients to verify contestants\r\n    function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) {\r\n        TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\r\n        \r\n        if (playersTickets.raffleRareId == raffleRareId) {\r\n            uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\r\n            uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\r\n            \r\n            for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\r\n                startIds[i] = playersTickets.ticketsBought[i].startId;\r\n                endIds[i] = playersTickets.ticketsBought[i].endId;\r\n            }\r\n        }\r\n        \r\n        return (startIds, endIds);\r\n    }\r\n    \r\n    // To display on website\r\n    function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\r\n        return (raffleEndTime, raffleRareId, raffleTicketsBought, raffleWinner, raffleTicketThatWon);\r\n    }\r\n    \r\n    \r\n    // New units may be added in future, but check it matches existing schema so no-one can abuse selling.\r\n    function updateGooConfig(address newSchemaAddress) external {\r\n        require(msg.sender == owner);\r\n        \r\n        GooGameConfig newSchema = GooGameConfig(newSchemaAddress);\r\n        requireExistingUnitsSame(newSchema);\r\n        requireExistingUpgradesSame(newSchema);\r\n        \r\n        // Finally update config\r\n        schema = GooGameConfig(newSchema);\r\n    }\r\n    \r\n    function requireExistingUnitsSame(GooGameConfig newSchema) internal constant {\r\n        // Requires units eth costs match up or fail execution\r\n        \r\n        uint256 startId;\r\n        uint256 endId;\r\n        (startId, endId) = schema.productionUnitIdRange();\r\n        while (startId <= endId) {\r\n            require(schema.unitEthCost(startId) == newSchema.unitEthCost(startId));\r\n            require(schema.unitGooProduction(startId) == newSchema.unitGooProduction(startId));\r\n            startId++;\r\n        }\r\n        \r\n        (startId, endId) = schema.battleUnitIdRange();\r\n        while (startId <= endId) {\r\n            require(schema.unitEthCost(startId) == newSchema.unitEthCost(startId));\r\n            require(schema.unitAttack(startId) == newSchema.unitAttack(startId));\r\n            require(schema.unitDefense(startId) == newSchema.unitDefense(startId));\r\n            require(schema.unitStealingCapacity(startId) == newSchema.unitStealingCapacity(startId));\r\n            startId++;\r\n        }\r\n    }\r\n    \r\n    function requireExistingUpgradesSame(GooGameConfig newSchema) internal constant {\r\n        uint256 startId;\r\n        uint256 endId;\r\n        \r\n        uint256 oldClass;\r\n        uint256 oldUnitId;\r\n        uint256 oldValue;\r\n        \r\n        uint256 newClass;\r\n        uint256 newUnitId;\r\n        uint256 newValue;\r\n        \r\n        // Requires ALL upgrade stats match up or fail execution\r\n        (startId, endId) = schema.rareIdRange();\r\n        while (startId <= endId) {\r\n            uint256 oldGooCost;\r\n            uint256 oldEthCost;\r\n            (oldGooCost, oldEthCost, oldClass, oldUnitId, oldValue) = schema.getUpgradeInfo(startId);\r\n            \r\n            uint256 newGooCost;\r\n            uint256 newEthCost;\r\n            (newGooCost, newEthCost, newClass, newUnitId, newValue) = newSchema.getUpgradeInfo(startId);\r\n            \r\n            require(oldGooCost == newGooCost);\r\n            require(oldEthCost == oldEthCost);\r\n            require(oldClass == oldClass);\r\n            require(oldUnitId == newUnitId);\r\n            require(oldValue == newValue);\r\n            startId++;\r\n        }\r\n        \r\n        // Requires ALL rare stats match up or fail execution\r\n        (startId, endId) = schema.rareIdRange();\r\n        while (startId <= endId) {\r\n            (oldClass, oldUnitId, oldValue) = schema.getRareInfo(startId);\r\n            (newClass, newUnitId, newValue) = newSchema.getRareInfo(startId);\r\n            \r\n            require(oldClass == newClass);\r\n            require(oldUnitId == newUnitId);\r\n            require(oldValue == newValue);\r\n            startId++;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract GooGameConfig {\r\n    \r\n    mapping(uint256 => Unit) private unitInfo;\r\n    mapping(uint256 => Upgrade) private upgradeInfo;\r\n    mapping(uint256 => Rare) private rareInfo;\r\n    \r\n    uint256 public constant currentNumberOfUnits = 14;\r\n    uint256 public constant currentNumberOfUpgrades = 42;\r\n    uint256 public constant currentNumberOfRares = 2;\r\n    \r\n    struct Unit {\r\n        uint256 unitId;\r\n        uint256 baseGooCost;\r\n        uint256 gooCostIncreaseHalf; // Halfed to make maths slightly less (cancels a 2 out)\r\n        uint256 ethCost;\r\n        uint256 baseGooProduction;\r\n        \r\n        uint256 attackValue;\r\n        uint256 defenseValue;\r\n        uint256 gooStealingCapacity;\r\n    }\r\n    \r\n    struct Upgrade {\r\n        uint256 upgradeId;\r\n        uint256 gooCost;\r\n        uint256 ethCost;\r\n        uint256 upgradeClass;\r\n        uint256 unitId;\r\n        uint256 upgradeValue;\r\n    }\r\n    \r\n     struct Rare {\r\n        uint256 rareId;\r\n        uint256 ethCost;\r\n        uint256 rareClass;\r\n        uint256 unitId;\r\n        uint256 rareValue;\r\n    }\r\n    \r\n    // Constructor\r\n    function GooGameConfig() public {\r\n        \r\n        unitInfo[1] = Unit(1, 0, 10, 0, 1, 0, 0, 0);\r\n        unitInfo[2] = Unit(2, 100, 50, 0, 2, 0, 0, 0);\r\n        unitInfo[3] = Unit(3, 0, 0, 0.01 ether, 12, 0, 0, 0);\r\n        unitInfo[4] = Unit(4, 500, 250, 0, 4, 0, 0, 0);\r\n        unitInfo[5] = Unit(5, 2500, 1250, 0, 6, 0, 0, 0);\r\n        unitInfo[6] = Unit(6, 10000, 5000, 0, 8, 0, 0, 0);\r\n        unitInfo[7] = Unit(7, 0, 1000, 0.05 ether, 60, 0, 0, 0);\r\n        unitInfo[8] = Unit(8, 25000, 12500, 0, 10, 0, 0, 0);\r\n        \r\n        unitInfo[40] = Unit(40, 100, 50, 0, 0, 10, 10, 20);\r\n        unitInfo[41] = Unit(41, 250, 125, 0, 0, 1, 25, 1);\r\n        unitInfo[42] = Unit(42, 0, 50, 0.01 ether, 0, 100, 10, 5);\r\n        unitInfo[43] = Unit(43, 1000, 500, 0, 0, 25, 1, 50);\r\n        unitInfo[44] = Unit(44, 2500, 1250, 0, 0, 20, 40, 100);\r\n        unitInfo[45] = Unit(45, 0, 500, 0.02 ether, 0, 0, 0, 1000);\r\n        \r\n        upgradeInfo[1] = Upgrade(1, 500, 0, 0, 1, 1); // +1\r\n        upgradeInfo[2] = Upgrade(2, 0, 0.1 ether, 1, 1, 10); // 10 = +100%\r\n        upgradeInfo[3] = Upgrade(3, 10000, 0, 1, 1, 5); // 5 = +50%\r\n        \r\n        upgradeInfo[4] = Upgrade(4, 0, 0.1 ether, 0, 2, 2); // +1\r\n        upgradeInfo[5] = Upgrade(5, 2000, 0, 1, 2, 5); // 10 = +50%\r\n        upgradeInfo[6] = Upgrade(6, 0, 0.2 ether, 0, 2, 2); // +2\r\n        \r\n        upgradeInfo[7] = Upgrade(7, 2500, 0, 0, 3, 2); // +2\r\n        upgradeInfo[8] = Upgrade(8, 0, 0.5 ether, 1, 3, 10); // 10 = +100%\r\n        upgradeInfo[9] = Upgrade(9, 25000, 0, 1, 3, 5); // 5 = +50%\r\n        \r\n        upgradeInfo[10] = Upgrade(10, 0, 0.1 ether, 0, 4, 1); // +1\r\n        upgradeInfo[11] = Upgrade(11, 5000, 0, 1, 4, 5); // 10 = +50%\r\n        upgradeInfo[12] = Upgrade(12, 0, 0.2 ether, 0, 4, 2); // +2\r\n        \r\n        upgradeInfo[13] = Upgrade(13, 10000, 0, 0, 5, 2); // +2\r\n        upgradeInfo[14] = Upgrade(14, 0, 0.5 ether, 1, 5, 10); // 10 = +100%\r\n        upgradeInfo[15] = Upgrade(15, 25000, 0, 1, 5, 5); // 5 = +50%\r\n        \r\n        upgradeInfo[16] = Upgrade(16, 0, 0.1 ether, 0, 6, 1); // +1\r\n        upgradeInfo[17] = Upgrade(17, 25000, 0, 1, 6, 5); // 10 = +50%\r\n        upgradeInfo[18] = Upgrade(18, 0, 0.2 ether, 0, 6, 2); // +2\r\n        \r\n        upgradeInfo[19] = Upgrade(13, 50000, 0, 0, 7, 2); // +2\r\n        upgradeInfo[20] = Upgrade(20, 0, 0.2 ether, 1, 7, 5); // 5 = +50%\r\n        upgradeInfo[21] = Upgrade(21, 100000, 0, 1, 7, 5); // 5 = +50%\r\n        \r\n        upgradeInfo[22] = Upgrade(22, 0, 0.1 ether, 0, 8, 2); // +1\r\n        upgradeInfo[23] = Upgrade(23, 25000, 0, 1, 8, 5); // 10 = +50%\r\n        upgradeInfo[24] = Upgrade(24, 0, 0.2 ether, 0, 8, 4); // +2\r\n        \r\n        \r\n        \r\n        upgradeInfo[25] = Upgrade(25, 500, 0, 2, 40, 10); // +10\r\n        upgradeInfo[26] = Upgrade(26, 0, 0.1 ether, 4, 40, 10); // +10\r\n        upgradeInfo[27] = Upgrade(27, 10000, 0, 6, 40, 10); // +10\r\n        \r\n        upgradeInfo[28] = Upgrade(28, 0, 0.2 ether, 3, 41, 5); // +50 %\r\n        upgradeInfo[29] = Upgrade(29, 5000, 0, 4, 41, 10); // +10\r\n        upgradeInfo[30] = Upgrade(30, 0, 0.5 ether, 6, 41, 4); // +4\r\n        \r\n        upgradeInfo[31] = Upgrade(31, 2500, 0, 5, 42, 5); // +50 %\r\n        upgradeInfo[32] = Upgrade(32, 0, 0.2 ether, 6, 42, 10); // +10\r\n        upgradeInfo[33] = Upgrade(33, 20000, 0, 7, 42, 5); // +50 %\r\n        \r\n        upgradeInfo[34] = Upgrade(34, 0, 0.1 ether, 2, 43, 5); // +5\r\n        upgradeInfo[35] = Upgrade(35, 10000, 0, 4, 43, 5); // +5\r\n        upgradeInfo[36] = Upgrade(36, 0, 0.2 ether, 5, 43, 5); // +50%\r\n        \r\n        upgradeInfo[37] = Upgrade(37, 0, 0.1 ether, 2, 44, 15); // +15\r\n        upgradeInfo[38] = Upgrade(38, 25000, 0, 3, 44, 5); // +50%\r\n        upgradeInfo[39] = Upgrade(39, 0, 0.2 ether, 4, 44, 15); // +15\r\n        \r\n        upgradeInfo[40] = Upgrade(40, 50000, 0, 6, 45, 500); // +500\r\n        upgradeInfo[41] = Upgrade(41, 0, 0.5 ether, 7, 45, 10); // +100 %\r\n        upgradeInfo[42] = Upgrade(42, 250000, 0, 7, 45, 5); // +50 %\r\n    \r\n        \r\n        rareInfo[1] = Rare(1, 0.5 ether, 1, 1, 30); // 30 = +300%\r\n        rareInfo[2] = Rare(2, 0.5 ether, 0, 2, 4); // +4\r\n    }\r\n    \r\n    function getGooCostForUnit(uint256 unitId, uint256 existing, uint256 amount) public constant returns (uint256) {\r\n        if (amount == 1) { // 1\r\n            if (existing == 0) {\r\n                return unitInfo[unitId].baseGooCost;\r\n            } else {\r\n                return unitInfo[unitId].baseGooCost + (existing * unitInfo[unitId].gooCostIncreaseHalf * 2);\r\n            }\r\n        } else if (amount > 1) {\r\n            uint256 existingCost;\r\n            if (existing > 0) {\r\n                existingCost = (unitInfo[unitId].baseGooCost * existing) + (existing * (existing - 1) * unitInfo[unitId].gooCostIncreaseHalf);\r\n            }\r\n            \r\n            existing += amount;\r\n            uint256 newCost = SafeMath.add(SafeMath.mul(unitInfo[unitId].baseGooCost, existing), SafeMath.mul(SafeMath.mul(existing, (existing - 1)), unitInfo[unitId].gooCostIncreaseHalf));\r\n            return newCost - existingCost;\r\n        }\r\n    }\r\n    \r\n    function getWeakenedDefensePower(uint256 defendingPower) external constant returns (uint256) {\r\n        return defendingPower / 2;\r\n    }\r\n    \r\n    function validUnitId(uint256 unitId) external constant returns (bool) {\r\n        return ((unitId > 0 && unitId < 9) || (unitId > 39 && unitId < 46));\r\n    }\r\n    \r\n    function validUpgradeId(uint256 upgradeId) external constant returns (bool) {\r\n        return (upgradeId > 0 && upgradeId < 43);\r\n    }\r\n    \r\n    function validRareId(uint256 rareId) external constant returns (bool) {\r\n        return (rareId > 0 && rareId < 3);\r\n    }\r\n    \r\n    function unitEthCost(uint256 unitId) external constant returns (uint256) {\r\n        return unitInfo[unitId].ethCost;\r\n    }\r\n    \r\n    function unitGooProduction(uint256 unitId) external constant returns (uint256) {\r\n        return unitInfo[unitId].baseGooProduction;\r\n    }\r\n    \r\n    function unitAttack(uint256 unitId) external constant returns (uint256) {\r\n        return unitInfo[unitId].attackValue;\r\n    }\r\n    \r\n    function unitDefense(uint256 unitId) external constant returns (uint256) {\r\n        return unitInfo[unitId].defenseValue;\r\n    }\r\n    \r\n    function unitStealingCapacity(uint256 unitId) external constant returns (uint256) {\r\n        return unitInfo[unitId].gooStealingCapacity;\r\n    }\r\n    \r\n    function rareStartPrice(uint256 rareId) external constant returns (uint256) {\r\n        return rareInfo[rareId].ethCost;\r\n    }\r\n    \r\n    function productionUnitIdRange() external constant returns (uint256, uint256) {\r\n        return (1, 8);\r\n    }\r\n    \r\n    function battleUnitIdRange() external constant returns (uint256, uint256) {\r\n        return (40, 45);\r\n    }\r\n    \r\n    function upgradeIdRange() external constant returns (uint256, uint256) {\r\n        return (1, 42);\r\n    }\r\n    \r\n    function rareIdRange() external constant returns (uint256, uint256) {\r\n        return (1, 2);\r\n    }\r\n    \r\n    function getUpgradeInfo(uint256 upgradeId) external constant returns (uint256, uint256, uint256, uint256, uint256) {\r\n        return (upgradeInfo[upgradeId].gooCost, upgradeInfo[upgradeId].ethCost, upgradeInfo[upgradeId].upgradeClass,\r\n        upgradeInfo[upgradeId].unitId, upgradeInfo[upgradeId].upgradeValue);\r\n    }\r\n    \r\n    function getRareInfo(uint256 rareId) external constant returns (uint256, uint256, uint256) {\r\n        return (rareInfo[rareId].rareClass, rareInfo[rareId].unitId, rareInfo[rareId].rareValue);\r\n    }\r\n    \r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvee\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalGooProductionSnapshots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"etherBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getGooProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"firstDivsTime\",\"type\":\"uint256\"}],\"name\":\"beginGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayersTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyBasicUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastGooProductionUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherGooResearchPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLatestRaffleInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"checkWinner\",\"type\":\"address\"},{\"name\":\"checkIndex\",\"type\":\"uint256\"}],\"name\":\"awardRafflePrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewUnclaimedResearchDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"attackPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allocatedGooResearchSnapshots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange\",\"type\":\"address\"},{\"name\":\"isProtected\",\"type\":\"bool\"}],\"name\":\"protectAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getRafflePlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSchemaAddress\",\"type\":\"address\"}],\"name\":\"updateGooConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGooProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayersBattleStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referer\",\"type\":\"address\"},{\"name\":\"startSnapshot\",\"type\":\"uint256\"},{\"name\":\"endSnapShot\",\"type\":\"uint256\"}],\"name\":\"claimResearchDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rareId\",\"type\":\"uint256\"}],\"name\":\"buyRareItem\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"upgradeId\",\"type\":\"uint256\"}],\"name\":\"buyUpgrade\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSnapshotTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRareItemInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyRaffleTicket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drawRandomWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"snapshotDailyGooResearchFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyEthUnit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"rareId\",\"type\":\"uint256\"}],\"name\":\"startRareRaffle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"approvee\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnitBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnitSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"attacker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"gooStolen\",\"type\":\"uint256\"}],\"name\":\"PlayerAttacked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Goo","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ae34a2e0cd26a642ebf0feb477e2acbd6179b8a4cc4ee64d8b8a0c232cd8af48"}]}