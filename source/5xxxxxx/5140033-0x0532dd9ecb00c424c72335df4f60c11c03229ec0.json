{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract token {\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function setStartTime(uint _startTime) external;\r\n}\r\n\r\n/**\r\n * @title Obirum Crowdsale\r\n */\r\ncontract ObirumCrowdsale{\r\n    using SafeMath for uint256;\r\n\r\n    /** Constants\r\n    * ----------\r\n    * kRate - Ether to Obirum rate. 1 ether is 20000 tokens.\r\n    * kMinStake - Min amount of Ether that can be contributed.\r\n    * kMaxStake - Max amount of Ether that can be contributed.\r\n    */\r\n    uint256 public constant kRate = 20000;\r\n    uint256 public constant kMinStake = 0.1 ether;\r\n    uint256 public constant kMaxStake = 200 ether;\r\n\r\n    uint256[9] internal stageLimits = [\r\n        100 ether,\r\n        300 ether,\r\n        1050 ether,\r\n        3050 ether,\r\n        8050 ether,\r\n        18050 ether,\r\n        28050 ether,\r\n        38050 ether,\r\n        48050 ether\r\n    ];\r\n    uint128[9] internal stageDiscounts = [\r\n        300,\r\n        250,\r\n        200,\r\n        150,\r\n        135,\r\n        125,\r\n        115,\r\n        110,\r\n        105\r\n    ];\r\n\r\n    // Investor contributions\r\n    mapping(address => uint256) balances;\r\n\r\n    uint256 public weiRaised;\r\n    uint8 public currentStage = 0;\r\n\r\n    // The token being sold\r\n    token public reward;\r\n\r\n    // Owner of the token\r\n    address public owner;\r\n\r\n    // Start and end timestamps\r\n    uint public startTime;\r\n    uint public endTime;\r\n\r\n    // Address where funds are collected\r\n    address public wallet;\r\n\r\n    // Amount of tokens that were sold\r\n    uint256 public tokensSold;\r\n\r\n    // Soft cap in OBR tokens\r\n    uint256 constant public softCap = 106000000 * (10**18);\r\n\r\n    // Hard cap in OBR tokens\r\n    uint256 constant public hardCap = 1151000000 * (10**18);\r\n\r\n    // Switched to true once token contract is notified of when to enable token transfers\r\n    bool private isStartTimeSet = false;\r\n\r\n    /**\r\n     * @dev Event for token purchase logging\r\n     * @param purchaser Address that paid for the tokens\r\n     * @param beneficiary Address that got the tokens\r\n     * @param value The amount that was paid (in wei)\r\n     * @param amount The amount of tokens that were bought\r\n     */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    /**\r\n     * @dev Event for refund logging\r\n     * @param receiver The address that received the refund\r\n     * @param amount The amount that is being refunded (in wei)\r\n     */\r\n    event Refund(address indexed receiver, uint256 amount);\r\n\r\n    /**\r\n     * @param _startTime Unix timestamp for the start of the token sale\r\n     * @param _endTime Unix timestamp for the end of the token sale\r\n     * @param _wallet Ethereum address to which the invested funds are forwarded\r\n     * @param _token Address of the token that will be rewarded for the investors\r\n     * @param _owner Address of the owner of the smart contract who can execute restricted functions\r\n     */\r\n    function ObirumCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _owner)  public {\r\n        require(_startTime >= now);\r\n        require(_endTime >= _startTime);\r\n        require(_wallet != address(0));\r\n        require(_token != address(0));\r\n        require(_owner != address(0));\r\n\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        wallet = _wallet;\r\n        owner = _owner;\r\n        reward = token(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that can be used to buy tokens. Or in case of the owner, return ether to allow refunds.\r\n     */\r\n    function () external payable {\r\n        if(msg.sender == wallet) {\r\n            require(hasEnded() && tokensSold < softCap);\r\n        } else {\r\n            buyTokens(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function for buying tokens\r\n     * @param beneficiary The address that should receive bought tokens\r\n     */\r\n    function buyTokens(address beneficiary) public payable {\r\n        require(beneficiary != address(0));\r\n        require(validPurchase());\r\n        require(currentStage < getStageCount());\r\n        \r\n        uint256 value = msg.value;\r\n        weiRaised = weiRaised.add(value);\r\n        uint256 limit = getStageLimit(currentStage);\r\n        uint256 dif = 0;\r\n        uint256 returnToSender = 0;\r\n    \r\n        if(weiRaised > limit){\r\n            dif = weiRaised.sub(limit);\r\n            value = value.sub(dif);\r\n            \r\n            if(currentStage == getStageCount() - 1){\r\n                returnToSender = dif;\r\n                weiRaised = weiRaised.sub(dif);\r\n                dif = 0;\r\n            }\r\n        }\r\n        \r\n        mintTokens(value, beneficiary);\r\n        \r\n        if(dif > 0){\r\n            currentStage = currentStage + 1;\r\n            mintTokens(dif, beneficiary);\r\n        }\r\n\r\n        // Allow transfers 2 weeks after hard cap is reached\r\n        if(tokensSold == hardCap) {\r\n            reward.setStartTime(now + 2 weeks);\r\n        }\r\n\r\n        // // Return funds that are over hard cap\r\n        if(returnToSender > 0) {\r\n            msg.sender.transfer(returnToSender);\r\n        }\r\n    }\r\n    \r\n    function mintTokens(uint256 value, address sender) private{\r\n        uint256 tokens = value.mul(kRate).mul(getStageDiscount(currentStage)).div(100);\r\n        \r\n        // update state\r\n        tokensSold = tokensSold.add(tokens);\r\n        \r\n        // update balance\r\n        balances[sender] = balances[sender].add(value);\r\n        reward.transferFrom(owner, sender, tokens);\r\n        \r\n        TokenPurchase(msg.sender, sender, value, tokens);\r\n        \r\n        // Forward funds\r\n        wallet.transfer(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that is used to check if the incoming purchase should be accepted.\r\n     * @return True if the transaction can buy tokens\r\n     */\r\n    function validPurchase() internal constant returns (bool) {\r\n        bool withinPeriod = now >= startTime && now <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0 && msg.value >= kMinStake && msg.value <= kMaxStake;\r\n        bool hardCapNotReached = tokensSold < hardCap;\r\n        return withinPeriod && nonZeroPurchase && hardCapNotReached;\r\n    }\r\n\r\n    /**\r\n     * @return True if crowdsale event has ended\r\n     */\r\n    function hasEnded() public constant returns (bool) {\r\n        return now > endTime || tokensSold >= hardCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns ether to token holders in case soft cap is not reached.\r\n     */\r\n    function claimRefund() external {\r\n        require(hasEnded());\r\n        require(tokensSold < softCap);\r\n\r\n        uint256 amount = balances[msg.sender];\r\n\r\n        if(address(this).balance >= amount) {\r\n            balances[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                msg.sender.transfer(amount);\r\n                Refund(msg.sender, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) external constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function getStageLimit(uint8 _stage) public view returns (uint256) {\r\n        return stageLimits[_stage];\r\n    }\r\n\r\n    function getStageDiscount(uint8 _stage) public view returns (uint128) {\r\n        return stageDiscounts[_stage];\r\n    }\r\n\r\n    function getStageCount() public view returns (uint8) {\r\n        return uint8(stageLimits.length);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getStageCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"getStageLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kMinStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"getStageDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kMaxStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"ObirumCrowdsale","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a9e3c70000000000000000000000000000000000000000000000000000000005aed56700000000000000000000000004b8264e1b2bb835976738a70c687c8d2a7b96dda00000000000000000000000069a605d3f74bb709a7e9f6f7b5e3337445fc93cc000000000000000000000000341f968a686791f1d6b056bb93140acaa72b970c","Library":"","SwarmSource":"bzzr://2b81d2389702c456bb3e5c0e7754106b3041b4feb03bf501cc77fe72d1f7dcbc"}]}