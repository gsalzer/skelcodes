{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract TokenRecipient {\r\n    event ReceivedEther(address indexed sender, uint amount);\r\n    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\r\n\r\n    /**\r\n     * @dev Receive tokens and generate a log event\r\n     * @param from Address from which to transfer tokens\r\n     * @param value Amount of tokens to transfer\r\n     * @param token Address of token\r\n     * @param extraData Additional data to log\r\n     */\r\n    function receiveApproval(address from, uint256 value, address token, bytes extraData) public {\r\n        ERC20 t = ERC20(token);\r\n        require(t.transferFrom(from, this, value));\r\n        ReceivedTokens(from, value, token, extraData);\r\n    }\r\n\r\n    /**\r\n     * @dev Receive Ether and generate a log event\r\n     */\r\n    function () payable public {\r\n        ReceivedEther(msg.sender, msg.value);\r\n    }\r\n}\r\n\r\ncontract AuthenticatedProxy is TokenRecipient {\r\n\r\n    /* Address which owns this proxy. */\r\n    address public user;\r\n\r\n    /* Associated registry with contract authentication information. */\r\n    ProxyRegistry public registry;\r\n\r\n    /* Whether access has been revoked. */\r\n    bool public revoked;\r\n\r\n    /* Delegate call could be used to atomically transfer multiple assets owned by the proxy contract with one order. */\r\n    enum HowToCall { Call, DelegateCall }\r\n\r\n    /* Event fired when the proxy access is revoked or unrevoked. */\r\n    event Revoked(bool revoked);\r\n\r\n    /**\r\n     * Create an AuthenticatedProxy\r\n     *\r\n     * @param addrUser Address of user on whose behalf this proxy will act\r\n     * @param addrRegistry Address of ProxyRegistry contract which will manage this proxy\r\n     */\r\n    function AuthenticatedProxy(address addrUser, ProxyRegistry addrRegistry) public {\r\n        user = addrUser;\r\n        registry = addrRegistry;\r\n    }\r\n\r\n    /**\r\n     * Set the revoked flag (allows a user to revoke ProxyRegistry access)\r\n     *\r\n     * @dev Can be called by the user only\r\n     * @param revoke Whether or not to revoke access\r\n     */\r\n    function setRevoke(bool revoke)\r\n        public\r\n    {\r\n        require(msg.sender == user);\r\n        revoked = revoke;\r\n        Revoked(revoke);\r\n    }\r\n\r\n    /**\r\n     * Execute a message call from the proxy contract\r\n     *\r\n     * @dev Can be called by the user, or by a contract authorized by the registry as long as the user has not revoked access\r\n     * @param dest Address to which the call will be sent\r\n     * @param howToCall Which kind of call to make\r\n     * @param calldata Calldata to send\r\n     * @return Result of the call (success or failure)\r\n     */\r\n    function proxy(address dest, HowToCall howToCall, bytes calldata)\r\n        public\r\n        returns (bool result)\r\n    {\r\n        require(msg.sender == user || (!revoked && registry.contracts(msg.sender)));\r\n        if (howToCall == HowToCall.Call) {\r\n            result = dest.call(calldata);\r\n        } else if (howToCall == HowToCall.DelegateCall) {\r\n            result = dest.delegatecall(calldata);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Execute a message call and assert success\r\n     * \r\n     * @dev Same functionality as `proxy`, just asserts the return value\r\n     * @param dest Address to which the call will be sent\r\n     * @param howToCall What kind of call to make\r\n     * @param calldata Calldata to send\r\n     */\r\n    function proxyAssert(address dest, HowToCall howToCall, bytes calldata)\r\n        public\r\n    {\r\n        require(proxy(dest, howToCall, calldata));\r\n    }\r\n\r\n}\r\n\r\ncontract ProxyRegistry is Ownable {\r\n\r\n    /* Authenticated proxies by user. */\r\n    mapping(address => AuthenticatedProxy) public proxies;\r\n\r\n    /* Contracts pending access. */\r\n    mapping(address => uint) public pending;\r\n\r\n    /* Contracts allowed to call those proxies. */\r\n    mapping(address => bool) public contracts;\r\n\r\n    /* Delay period for adding an authenticated contract.\r\n       This mitigates a particular class of potential attack on the Wyvern DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the WYV supply (votes in the DAO),\r\n       a malicious but rational attacker could buy half the Wyvern and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given two weeks, if that happened, users would have\r\n       plenty of time to notice and transfer their assets.\r\n    */\r\n    uint public DELAY_PERIOD = 2 weeks;\r\n\r\n    /**\r\n     * Start the process to enable access for specified contract. Subject to delay period.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address to which to grant permissions\r\n     */\r\n    function startGrantAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(!contracts[addr] && pending[addr] == 0);\r\n        pending[addr] = now;\r\n    }\r\n\r\n    /**\r\n     * End the process to nable access for specified contract after delay period has passed.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address to which to grant permissions\r\n     */\r\n    function endGrantAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < now));\r\n        pending[addr] = 0;\r\n        contracts[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * Revoke access for specified contract. Can be done instantly.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address of which to revoke permissions\r\n     */    \r\n    function revokeAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        contracts[addr] = false;\r\n    }\r\n\r\n    /**\r\n     * Register a proxy contract with this registry\r\n     *\r\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\r\n     * @return New AuthenticatedProxy contract\r\n     */\r\n    function registerProxy()\r\n        public\r\n        returns (AuthenticatedProxy proxy)\r\n    {\r\n        require(proxies[msg.sender] == address(0));\r\n        proxy = new AuthenticatedProxy(msg.sender, this);\r\n        proxies[msg.sender] = proxy;\r\n        return proxy;\r\n    }\r\n\r\n}\r\n\r\ncontract TokenTransferProxy {\r\n\r\n    /* Authentication registry. */\r\n    ProxyRegistry public registry;\r\n\r\n    /**\r\n     * Call ERC20 `transferFrom`\r\n     *\r\n     * @dev Authenticated contract only\r\n     * @param token ERC20 token address\r\n     * @param from From address\r\n     * @param to To address\r\n     * @param amount Transfer amount\r\n     */\r\n    function transferFrom(address token, address from, address to, uint amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(registry.contracts(msg.sender));\r\n        return ERC20(token).transferFrom(from, to, amount);\r\n    }\r\n\r\n}\r\n\r\ncontract WyvernTokenTransferProxy is TokenTransferProxy {\r\n\r\n    function WyvernTokenTransferProxy (ProxyRegistry registryAddr)\r\n        public\r\n    {\r\n        registry = registryAddr;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"registryAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"WyvernTokenTransferProxy","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a4306692b00795f97010ec7237980141d08c6d56","Library":"","SwarmSource":"bzzr://5cdf24de1f26bdc2bef861e0d5510daa40f7af1c140ca4cc97da29c2aebf1e2d"}]}