{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract BCFBase {\r\n\r\n    address public owner;\r\n    address public editor;\r\n\r\n    bool public paused = false;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyEditor() {\r\n        require(msg.sender == editor);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setEditor(address newEditor) public onlyOwner {\r\n        require(newEditor != address(0));\r\n        editor = newEditor;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n    \r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n    \r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n    }\r\n    \r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract ERC721 {\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    // Required\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint _tokenId) public view returns (address approved);\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function transfer(address _to, uint256 _tokenId) public;\r\n    function implementsERC721() public pure returns (bool);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\r\n}\r\n\r\ncontract BCFData is BCFBase, ERC721 {\r\n\r\n    // MetaData\r\n    string public constant NAME = \"BlockchainFootball\";\r\n    string public constant SYMBOL = \"BCF\";\r\n\r\n    struct Player {\r\n\r\n        // Attribute ratings\r\n        uint8 overall;\r\n        uint8 pace;\r\n        uint8 shooting;\r\n        uint8 passing;\r\n        uint8 dribbling;\r\n        uint8 defending;\r\n        uint8 physical;\r\n        uint8 form; // No plans to use this atm but offers useful dynamic attribute -- NOT used in v1 of match engine\r\n\r\n        // Level could be stored as an enum but plain ol' uint gives us more flexibility to introduce new levels in future\r\n        uint8 level; // 1 = Superstar, 2 = Legend, 3 = Gold, 4 = Silver\r\n        bytes position; // Shortcode - GK, LB, CB, RB, RW, RM, LW, LM, CM, CDM, CAM, ST\r\n        string name; // First and last - arbitrary-length, hence string over bytes32\r\n    }\r\n    \r\n    struct PlayerCard {\r\n        uint playerId; // References the index of a player, i.e players[playerId] -- playerId = 0 invalid (non-existant)\r\n        address owner;\r\n        address approvedForTransfer;\r\n        bool isFirstGeneration;\r\n    }\r\n    \r\n    // Player + PlayerCards Database\r\n    Player[] public players; // Central DB of player attributes\r\n    PlayerCard[] public playerCards;\r\n\r\n    // Utility mappings to make trading players and checking ownership gas-efficient\r\n    mapping(address => uint[]) internal ownerToCardsOwned;\r\n    mapping(uint => uint) internal cardIdToOwnerArrayIndex;\r\n\r\n    // Extended attributes -- for now these are just an indexed list of values. Metadata will describe what each index represents.\r\n    mapping(uint => uint8[]) public playerIdToExtendedAttributes; // Each index a single unique value > 0 and < 100\r\n\r\n    // ERC721\r\n    // Note: The standard is still in draft mode, so these are best efforts implementation based\r\n    // on currently direction of the community and existing contracts which reside in the \"wild\"\r\n    function implementsERC721() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return playerCards.length;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return ownerToCardsOwned[_owner].length;\r\n    }\r\n\r\n    function getApproved(uint _tokenId) public view returns (address approved) {\r\n        approved = playerCards[_tokenId].approvedForTransfer;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\r\n        _owner = playerCards[_tokenId].owner;\r\n        require(_owner != address(0));\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) public whenNotPaused {\r\n        require(ownsPlayerCard(msg.sender, _tokenId));\r\n        approveForTransferTo(_to, _tokenId);\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(ownsPlayerCard(_from, _tokenId));\r\n        require(isApprovedForTransferTo(_to, _tokenId));\r\n        \r\n        // As we've validate we can now call the universal transfer method\r\n        transferUnconditionally(_from, _to, _tokenId);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokenId) public whenNotPaused {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(ownsPlayerCard(msg.sender, _tokenId));\r\n    \r\n        // As we've validate we can now call the universal transfer method\r\n        transferUnconditionally(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function name() public pure returns (string) {\r\n        return NAME;\r\n    }\r\n\r\n    function symbol() public pure returns (string) {\r\n        return SYMBOL;\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds) {\r\n        return ownerToCardsOwned[_owner];\r\n    }\r\n\r\n    function addCardToOwnersList(address _owner, uint _cardId) internal {\r\n        ownerToCardsOwned[_owner].push(_cardId);\r\n        cardIdToOwnerArrayIndex[_cardId] = ownerToCardsOwned[_owner].length - 1;\r\n    }\r\n\r\n    function removeCardFromOwnersList(address _owner, uint _cardId) internal {\r\n        uint length = ownerToCardsOwned[_owner].length;\r\n        uint index = cardIdToOwnerArrayIndex[_cardId];\r\n        uint swapCard = ownerToCardsOwned[_owner][length - 1];\r\n\r\n        ownerToCardsOwned[_owner][index] = swapCard;\r\n        cardIdToOwnerArrayIndex[swapCard] = index;\r\n\r\n        delete ownerToCardsOwned[_owner][length - 1];\r\n        ownerToCardsOwned[_owner].length--;\r\n    }\r\n\r\n    // Internal function to transfer without prior validation, requires callers to perform due-diligence\r\n    function transferUnconditionally(address _from, address _to, uint _cardId) internal {\r\n        \r\n        if (_from != address(0)) {\r\n            // Remove from current owner list first, otherwise we'll end up with invalid indexes\r\n            playerCards[_cardId].approvedForTransfer = address(0);\r\n            removeCardFromOwnersList(_from, _cardId);\r\n        }\r\n        \r\n        playerCards[_cardId].owner = _to;\r\n        addCardToOwnersList(_to, _cardId);\r\n\r\n        Transfer(_from, _to, _cardId);\r\n    }\r\n\r\n    function isApprovedForTransferTo(address _approved, uint _cardId) internal view returns (bool) {\r\n        return playerCards[_cardId].approvedForTransfer == _approved;\r\n    }\r\n\r\n    function approveForTransferTo(address _approved, uint _cardId) internal {\r\n        playerCards[_cardId].approvedForTransfer = _approved;\r\n    }\r\n\r\n    function ownsPlayerCard(address _cardOwner, uint _cardId) internal view returns (bool) {\r\n        return playerCards[_cardId].owner == _cardOwner;\r\n    }\r\n\r\n    function setPlayerForm(uint _playerId, uint8 _form) external whenNotPaused onlyEditor {\r\n        require(players[_playerId].form > 0); // Check the player and form exist\r\n        require(_form > 0 && _form <= 200); // Max value is players can double their form\r\n        players[_playerId].form = _form;\r\n    }\r\n\r\n    function createPlayerCard(uint _playerId, address _newOwner, bool isFirstOfKind) internal returns (uint) {\r\n        require(_playerId > 0); // disallow player cards for the first card - Thiago Messi\r\n        Player storage _player = players[_playerId];\r\n        require(_player.overall > 0); // Make sure the player exists\r\n\r\n        PlayerCard memory _cardInstance = PlayerCard({\r\n             playerId: _playerId,\r\n             owner: _newOwner,\r\n             approvedForTransfer: address(0),\r\n             isFirstGeneration: isFirstOfKind\r\n        });\r\n\r\n        uint cardId = playerCards.push(_cardInstance) - 1;\r\n\r\n        // We send it with 0x0 FROM address so we don't reduce the total number of cards associated with this address \r\n        transferUnconditionally(0, _newOwner, cardId);\r\n\r\n        return cardId;\r\n    }\r\n\r\n    // Public Functions - Non ERC721 specific\r\n    function totalPlayerCount() public view returns(uint) {\r\n        return players.length;\r\n    }\r\n    \r\n    function getPlayerForCard(uint _cardId) \r\n        external\r\n        view\r\n        returns (\r\n        uint8 _overall,\r\n        uint8 _pace,\r\n        uint8 _shooting,\r\n        uint8 _passing,\r\n        uint8 _dribbling,\r\n        uint8 _defending,\r\n        uint8 _physical,\r\n        uint8 _level,\r\n        bytes _position,\r\n        string _fullName,\r\n        uint8 _form\r\n    ) {\r\n        // Fetch the card first\r\n        PlayerCard storage _playerCard = playerCards[_cardId];\r\n        \r\n        // Return the player returned here\r\n        // NOTE: if an invalid card is specified this may return index 0 result (Thiago Messi)\r\n        Player storage player = players[_playerCard.playerId];\r\n        _overall = player.overall;\r\n        _pace = player.pace;\r\n        _shooting = player.shooting;\r\n        _passing = player.passing;\r\n        _dribbling = player.dribbling;\r\n        _defending = player.defending;\r\n        _physical = player.physical;\r\n        _level = player.level;\r\n        _position = player.position;\r\n        _fullName = player.name;\r\n        _form = player.form;\r\n    }\r\n\r\n    function isOwnerOfAllPlayerCards(uint256[] _cardIds, address owner) public view returns (bool) {\r\n        require(owner != address(0));\r\n\r\n        // This function will return early if it finds any instance of a cardId not owned\r\n        for (uint i = 0; i < _cardIds.length; i++) {\r\n            if (!ownsPlayerCard(owner, _cardIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Get's here, must own all cardIds\r\n        return true;\r\n    }\r\n\r\n    // Extended attributes\r\n    function setExtendedPlayerAttributesForPlayer(uint playerId, uint8[] attributes) external whenNotPaused onlyEditor {\r\n        require(playerId > 0);\r\n        playerIdToExtendedAttributes[playerId] = attributes;\r\n    }\r\n\r\n    function getExtendedAttributesForPlayer(uint playerId) public view returns (uint8[]) {\r\n        require(playerId > 0);\r\n        return playerIdToExtendedAttributes[playerId];\r\n    }\r\n}\r\n\r\ncontract BCFBuyMarket is BCFData {\r\n\r\n    address public buyingEscrowAddress;\r\n    bool public isBCFBuyMarket = true;\r\n\r\n    function setBuyingEscrowAddress(address _address) external onlyOwner {\r\n        buyingEscrowAddress = _address;\r\n    }\r\n    \r\n    function createCardForAcquiredPlayer(uint playerId, address newOwner) public whenNotPaused returns (uint) {\r\n        require(buyingEscrowAddress != address(0));\r\n        require(newOwner != address(0));\r\n        require(buyingEscrowAddress == msg.sender);\r\n        \r\n        uint cardId = createPlayerCard(playerId, newOwner, false);\r\n\r\n        return cardId;\r\n    }\r\n\r\n    function createCardForAcquiredPlayers(uint[] playerIds, address newOwner) public whenNotPaused returns (uint[]) {\r\n        require(buyingEscrowAddress != address(0));\r\n        require(newOwner != address(0));\r\n        require(buyingEscrowAddress == msg.sender);\r\n\r\n        uint[] memory cardIds = new uint[](playerIds.length);\r\n\r\n        // Create the players and store an array of their Ids\r\n        for (uint i = 0; i < playerIds.length; i++) {\r\n            uint cardId = createPlayerCard(playerIds[i], newOwner, false);\r\n            cardIds[i] = cardId;\r\n        }\r\n\r\n        return cardIds;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @dev modifier to allow actions only when the contract IS paused\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to allow actions only when the contract IS NOT paused\r\n    */\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public returns (bool) {\r\n        paused = true;\r\n        Pause();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public returns (bool) {\r\n        paused = false;\r\n        Unpause();\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract BCFAuction is Pausable {\r\n\r\n    struct CardAuction {\r\n        address seller;\r\n        uint128 startPrice; // in wei\r\n        uint128 endPrice;\r\n        uint64 duration;\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // To lookup owners \r\n    ERC721 public dataStore;\r\n    uint256 public auctioneerCut;\r\n\r\n    mapping (uint256 => CardAuction) playerCardIdToAuction;\r\n\r\n    event AuctionCreated(uint256 cardId, uint256 startPrice, uint256 endPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 cardId, uint256 finalPrice, address winner);\r\n    event AuctionCancelled(uint256 cardId);\r\n\r\n    function BCFAuction(address dataStoreAddress, uint cutValue) public {\r\n        require(cutValue <= 10000); // 100% == 10,000\r\n        auctioneerCut = cutValue;\r\n\r\n        ERC721 candidateDataStoreContract = ERC721(dataStoreAddress);\r\n        require(candidateDataStoreContract.implementsERC721());\r\n        dataStore = candidateDataStoreContract;\r\n    }\r\n\r\n    function withdrawBalance() external {\r\n        address storageAddress = address(dataStore);\r\n        require(msg.sender == owner || msg.sender == storageAddress);\r\n        storageAddress.transfer(this.balance);\r\n    }\r\n\r\n    function createAuction(\r\n        uint256 cardId, \r\n        uint256 startPrice, \r\n        uint256 endPrice, \r\n        uint256 duration, \r\n        address seller\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(startPrice == uint256(uint128(startPrice)));\r\n        require(endPrice == uint256(uint128(endPrice)));\r\n        require(duration == uint256(uint64(duration)));\r\n        require(seller != address(0));\r\n        require(address(dataStore) != address(0));\r\n        require(msg.sender == address(dataStore));\r\n\r\n        _escrow(seller, cardId);\r\n        CardAuction memory auction = CardAuction(\r\n            seller,\r\n            uint128(startPrice),\r\n            uint128(endPrice),\r\n            uint64(duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(cardId, auction);\r\n    }\r\n\r\n    function bid(uint256 cardId) external payable whenNotPaused {\r\n        _bid(cardId, msg.value); // This function handles validation and throws\r\n        _transfer(msg.sender, cardId);\r\n    }\r\n\r\n    function cancelAuction(uint256 cardId) external {\r\n        CardAuction storage auction = playerCardIdToAuction[cardId];\r\n        require(isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(cardId, seller);\r\n    }\r\n\r\n    function getAuction(uint256 cardId) external view returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        CardAuction storage auction = playerCardIdToAuction[cardId];\r\n        require(isOnAuction(auction));\r\n        return (auction.seller, auction.startPrice, auction.endPrice, auction.duration, auction.startedAt);\r\n    }\r\n\r\n    function getCurrentPrice(uint256 cardId) external view returns (uint256) {\r\n        CardAuction storage auction = playerCardIdToAuction[cardId];\r\n        require(isOnAuction(auction));\r\n        return currentPrice(auction);\r\n    }\r\n\r\n    // Internal utility functions\r\n    function ownsPlayerCard(address cardOwner, uint256 cardId) internal view returns (bool) {\r\n        return (dataStore.ownerOf(cardId) == cardOwner);\r\n    }\r\n\r\n    function _escrow(address owner, uint256 cardId) internal {\r\n        dataStore.transferFrom(owner, this, cardId);\r\n    }\r\n\r\n    function _transfer(address receiver, uint256 cardId) internal {\r\n        dataStore.transfer(receiver, cardId);\r\n    }\r\n\r\n    function _addAuction(uint256 cardId, CardAuction auction) internal {\r\n        require(auction.duration >= 1 minutes && auction.duration <= 14 days);\r\n        playerCardIdToAuction[cardId] = auction;\r\n        AuctionCreated(cardId, auction.startPrice, auction.endPrice, auction.duration);\r\n    }\r\n\r\n    function _removeAuction(uint256 cardId) internal {\r\n        delete playerCardIdToAuction[cardId];\r\n    }\r\n\r\n    function _cancelAuction(uint256 cardId, address seller) internal {\r\n        _removeAuction(cardId);\r\n        _transfer(seller, cardId);\r\n        AuctionCancelled(cardId);\r\n    }\r\n\r\n    function isOnAuction(CardAuction storage auction) internal view returns (bool) {\r\n        return (auction.startedAt > 0);\r\n    }\r\n\r\n    function _bid(uint256 cardId, uint256 bidAmount) internal returns (uint256) {\r\n        CardAuction storage auction = playerCardIdToAuction[cardId];\r\n        require(isOnAuction(auction));\r\n\r\n        uint256 price = currentPrice(auction);\r\n        require(bidAmount >= price);\r\n\r\n        address seller = auction.seller;\r\n        _removeAuction(cardId);\r\n\r\n        if (price > 0) {\r\n            uint256 handlerCut = calculateAuctioneerCut(price);\r\n            uint256 sellerProceeds = price - handlerCut;\r\n            seller.transfer(sellerProceeds);\r\n        } \r\n\r\n        uint256 bidExcess = bidAmount - price;\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        AuctionSuccessful(cardId, price, msg.sender); // Emit event/log\r\n\r\n        return price;\r\n    }\r\n\r\n    function currentPrice(CardAuction storage auction) internal view returns (uint256) {\r\n        uint256 secondsPassed = 0;\r\n        if (now > auction.startedAt) {\r\n            secondsPassed = now - auction.startedAt;\r\n        }\r\n\r\n        return calculateCurrentPrice(auction.startPrice, auction.endPrice, auction.duration, secondsPassed);\r\n    }\r\n\r\n    function calculateCurrentPrice(uint256 startPrice, uint256 endPrice, uint256 duration, uint256 secondsElapsed)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (secondsElapsed >= duration) {\r\n            return endPrice;\r\n        } \r\n\r\n        int256 totalPriceChange = int256(endPrice) - int256(startPrice);\r\n        int256 currentPriceChange = totalPriceChange * int256(secondsElapsed) / int256(duration);\r\n        int256 _currentPrice = int256(startPrice) + currentPriceChange;\r\n\r\n        return uint256(_currentPrice);\r\n    }\r\n\r\n    function calculateAuctioneerCut(uint256 sellPrice) internal view returns (uint256) {\r\n        // 10,000 = 100%, ownerCut required'd <= 10,000 in the constructor so no requirement to validate here\r\n        uint finalCut = sellPrice * auctioneerCut / 10000;\r\n        return finalCut;\r\n    }    \r\n}\r\n\r\ncontract BCFTransferMarket is BCFBuyMarket {\r\n\r\n    BCFAuction public auctionAddress;\r\n\r\n    function setAuctionAddress(address newAddress) public onlyOwner {\r\n        require(newAddress != address(0));\r\n        BCFAuction candidateContract = BCFAuction(newAddress);\r\n        auctionAddress = candidateContract;\r\n    }\r\n\r\n    function createTransferAuction(\r\n        uint playerCardId,\r\n        uint startPrice,\r\n        uint endPrice,\r\n        uint duration\r\n    )\r\n        public\r\n        whenNotPaused\r\n    {\r\n        require(auctionAddress != address(0));\r\n        require(ownsPlayerCard(msg.sender, playerCardId));\r\n        approveForTransferTo(auctionAddress, playerCardId);\r\n        auctionAddress.createAuction(\r\n            playerCardId,\r\n            startPrice,\r\n            endPrice,\r\n            duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function withdrawAuctionBalance() external onlyOwner {\r\n        auctionAddress.withdrawBalance();\r\n    }\r\n}\r\n\r\ncontract BCFSeeding is BCFTransferMarket {\r\n\r\n    function createPlayer(\r\n        uint8 _overall,\r\n        uint8 _pace,\r\n        uint8 _shooting,\r\n        uint8 _passing,\r\n        uint8 _dribbling,\r\n        uint8 _defending,\r\n        uint8 _physical,\r\n        uint8 _level,\r\n        bytes _position,\r\n        string _fullName\r\n    ) \r\n        internal \r\n        returns (uint) \r\n    {\r\n        require(_overall > 0 && _overall < 100);\r\n        require(_pace > 0 && _pace < 100);\r\n        require(_shooting > 0 && _shooting < 100);\r\n        require(_passing > 0 && _passing < 100);\r\n        require(_dribbling > 0 && _dribbling < 100);\r\n        require(_defending > 0 && _defending < 100);\r\n        require(_physical > 0 && _physical < 100);\r\n        require(_level > 0 && _level < 100);\r\n        require(_position.length > 0);\r\n        require(bytes(_fullName).length > 0);\r\n        \r\n        Player memory _playerInstance = Player({\r\n            overall: _overall,\r\n            pace: _pace,\r\n            shooting: _shooting,\r\n            passing: _passing,\r\n            dribbling: _dribbling,\r\n            defending: _defending,\r\n            physical: _physical,\r\n            form: 100,\r\n            level: _level,\r\n            position: _position,\r\n            name: _fullName\r\n        });\r\n\r\n        return players.push(_playerInstance) - 1;\r\n    }\r\n\r\n    function createPlayerOnAuction(\r\n        uint8 _overall,\r\n        uint8 _pace,\r\n        uint8 _shooting,\r\n        uint8 _passing,\r\n        uint8 _dribbling,\r\n        uint8 _defending,\r\n        uint8 _physical,\r\n        uint8 _level,\r\n        bytes _position,\r\n        string _fullName,\r\n        uint _startPrice\r\n    ) \r\n        public whenNotPaused onlyEditor\r\n        returns(uint)\r\n    {\r\n        uint playerId = createPlayer(\r\n            _overall, \r\n            _pace, \r\n            _shooting, \r\n            _passing, \r\n            _dribbling,\r\n            _defending,\r\n            _physical,\r\n            _level,\r\n            _position,\r\n            _fullName);\r\n\r\n        uint cardId = createPlayerCard(playerId, address(this), true);\r\n        approveForTransferTo(auctionAddress, cardId);\r\n\r\n        auctionAddress.createAuction(\r\n            cardId, // id\r\n            _startPrice, // start price\r\n            1 finney, // end price\r\n            7 days, // duration\r\n            address(this) // seller\r\n        );\r\n\r\n        return cardId;\r\n    }\r\n    \r\n    function createPlayerAndAssign(\r\n        uint8 _overall,\r\n        uint8 _pace,\r\n        uint8 _shooting,\r\n        uint8 _passing,\r\n        uint8 _dribbling,\r\n        uint8 _defending,\r\n        uint8 _physical,\r\n        uint8 _level,\r\n        bytes _position,\r\n        string _fullName,\r\n        address assignee\r\n    ) \r\n        public whenNotPaused onlyEditor\r\n        returns(uint) \r\n    {\r\n        require(assignee != address(0));\r\n        \r\n        uint playerId = createPlayer(\r\n            _overall, \r\n            _pace, \r\n            _shooting, \r\n            _passing, \r\n            _dribbling,\r\n            _defending,\r\n            _physical,\r\n            _level,\r\n            _position,\r\n            _fullName);\r\n\r\n        uint cardId = createPlayerCard(playerId, assignee, true);\r\n\r\n        return cardId;\r\n    }\r\n}\r\n\r\ncontract BCFMain is BCFSeeding {\r\n\r\n    function BCFMain() public {\r\n        owner = msg.sender;\r\n        editor = msg.sender;\r\n        paused = true;\r\n\r\n        // We need to create an unacquirable index 0 player so we can use playerId > 0 check for valid playerCard structs\r\n        createPlayer(1, 4, 4, 2, 3, 5, 2, 11, \"CAM\", \"Thiago Messi\");\r\n    }\r\n\r\n    function() external payable {\r\n        require(msg.sender == address(auctionAddress) || msg.sender == owner || msg.sender == buyingEscrowAddress);\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner {\r\n        owner.transfer(this.balance);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"approved\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPlayerCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerCardId\",\"type\":\"uint256\"},{\"name\":\"startPrice\",\"type\":\"uint256\"},{\"name\":\"endPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"createTransferAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cardIds\",\"type\":\"uint256[]\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isOwnerOfAllPlayerCards\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerCards\",\"outputs\":[{\"name\":\"playerId\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"approvedForTransfer\",\"type\":\"address\"},{\"name\":\"isFirstGeneration\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setBuyingEscrowAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBCFBuyMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_playerId\",\"type\":\"uint256\"},{\"name\":\"_form\",\"type\":\"uint8\"}],\"name\":\"setPlayerForm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerId\",\"type\":\"uint256\"},{\"name\":\"attributes\",\"type\":\"uint8[]\"}],\"name\":\"setExtendedPlayerAttributesForPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cardId\",\"type\":\"uint256\"}],\"name\":\"getPlayerForCard\",\"outputs\":[{\"name\":\"_overall\",\"type\":\"uint8\"},{\"name\":\"_pace\",\"type\":\"uint8\"},{\"name\":\"_shooting\",\"type\":\"uint8\"},{\"name\":\"_passing\",\"type\":\"uint8\"},{\"name\":\"_dribbling\",\"type\":\"uint8\"},{\"name\":\"_defending\",\"type\":\"uint8\"},{\"name\":\"_physical\",\"type\":\"uint8\"},{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_position\",\"type\":\"bytes\"},{\"name\":\"_fullName\",\"type\":\"string\"},{\"name\":\"_form\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newEditor\",\"type\":\"address\"}],\"name\":\"setEditor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerIdToExtendedAttributes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setAuctionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_overall\",\"type\":\"uint8\"},{\"name\":\"_pace\",\"type\":\"uint8\"},{\"name\":\"_shooting\",\"type\":\"uint8\"},{\"name\":\"_passing\",\"type\":\"uint8\"},{\"name\":\"_dribbling\",\"type\":\"uint8\"},{\"name\":\"_defending\",\"type\":\"uint8\"},{\"name\":\"_physical\",\"type\":\"uint8\"},{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_position\",\"type\":\"bytes\"},{\"name\":\"_fullName\",\"type\":\"string\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"}],\"name\":\"createPlayerOnAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyingEscrowAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerIds\",\"type\":\"uint256[]\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"createCardForAcquiredPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"editor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerId\",\"type\":\"uint256\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"createCardForAcquiredPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"playerId\",\"type\":\"uint256\"}],\"name\":\"getExtendedAttributesForPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAuctionBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_overall\",\"type\":\"uint8\"},{\"name\":\"_pace\",\"type\":\"uint8\"},{\"name\":\"_shooting\",\"type\":\"uint8\"},{\"name\":\"_passing\",\"type\":\"uint8\"},{\"name\":\"_dribbling\",\"type\":\"uint8\"},{\"name\":\"_defending\",\"type\":\"uint8\"},{\"name\":\"_physical\",\"type\":\"uint8\"},{\"name\":\"_level\",\"type\":\"uint8\"},{\"name\":\"_position\",\"type\":\"bytes\"},{\"name\":\"_fullName\",\"type\":\"string\"},{\"name\":\"assignee\",\"type\":\"address\"}],\"name\":\"createPlayerAndAssign\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"overall\",\"type\":\"uint8\"},{\"name\":\"pace\",\"type\":\"uint8\"},{\"name\":\"shooting\",\"type\":\"uint8\"},{\"name\":\"passing\",\"type\":\"uint8\"},{\"name\":\"dribbling\",\"type\":\"uint8\"},{\"name\":\"defending\",\"type\":\"uint8\"},{\"name\":\"physical\",\"type\":\"uint8\"},{\"name\":\"form\",\"type\":\"uint8\"},{\"name\":\"level\",\"type\":\"uint8\"},{\"name\":\"position\",\"type\":\"bytes\"},{\"name\":\"name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BCFMain","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1b27ae0b6bd6551795d5b3c42521f58c84112a6dab7690b69f44d2535cb84009"}]}