{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * CollateralMonitor\r\n *\r\n * This contract reports aggregated issuance\r\n * and collateralisation statistics for the \r\n * Havven stablecoin system.\r\n * \r\n * Author: Anton Jurisevic\r\n * Date: 14/06/2018\r\n * Version: nUSDa 1.0\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Havven {\r\n    uint public price;\r\n    uint public issuanceRatio;\r\n    mapping(address => uint) public nominsIssued;\r\n    function balanceOf(address account) public view returns (uint);\r\n    function totalSupply() public view returns (uint);\r\n    function availableHavvens(address account) public view returns (uint);\r\n}\r\n\r\ncontract Nomin {\r\n    function totalSupply() public view returns (uint);\r\n}\r\n\r\ncontract HavvenEscrow {\r\n    function balanceOf(address account) public view returns (uint);\r\n}\r\n\r\n/**\r\n * @title Safely manipulate unsigned fixed-point decimals at a given precision level.\r\n * @dev Functions accepting uints in this contract and derived contracts\r\n * are taken to be such fixed point decimals (including fiat, ether, and nomin quantities).\r\n */\r\ncontract SafeDecimalMath {\r\n\r\n    /* Number of decimal places in the representation. */\r\n    uint8 public constant decimals = 18;\r\n\r\n    /* The number representing 1.0. */\r\n    uint public constant UNIT = 10 ** uint(decimals);\r\n\r\n    /**\r\n     * @return True iff adding x and y will not overflow.\r\n     */\r\n    function addIsSafe(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return x + y >= y;\r\n    }\r\n\r\n    /**\r\n     * @return The result of adding x and y, throwing an exception in case of overflow.\r\n     */\r\n    function safeAdd(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        require(x + y >= y);\r\n        return x + y;\r\n    }\r\n\r\n    /**\r\n     * @return True iff subtracting y from x will not overflow in the negative direction.\r\n     */\r\n    function subIsSafe(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return y <= x;\r\n    }\r\n\r\n    /**\r\n     * @return The result of subtracting y from x, throwing an exception in case of overflow.\r\n     */\r\n    function safeSub(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        require(y <= x);\r\n        return x - y;\r\n    }\r\n\r\n    /**\r\n     * @return True iff multiplying x and y would not overflow.\r\n     */\r\n    function mulIsSafe(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (x == 0) {\r\n            return true;\r\n        }\r\n        return (x * y) / x == y;\r\n    }\r\n\r\n    /**\r\n     * @return The result of multiplying x and y, throwing an exception in case of overflow.\r\n     */\r\n    function safeMul(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n        uint p = x * y;\r\n        require(p / x == y);\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\r\n     * decimals. Throws an exception in case of overflow.\r\n     * \r\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\r\n     * so that product must be less than 2**256.\r\n     * Incidentally, the internal division always rounds down: one could have rounded to the nearest integer,\r\n     * but then one would be spending a significant fraction of a cent (of order a microether\r\n     * at present gas prices) in order to save less than one part in 0.5 * 10^18 per operation, if the operands\r\n     * contain small enough fractional components. It would also marginally diminish the \r\n     * domain this function is defined upon. \r\n     */\r\n    function safeMul_dec(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\r\n        return safeMul(x, y) / UNIT;\r\n\r\n    }\r\n\r\n    /**\r\n     * @return True iff the denominator of x/y is nonzero.\r\n     */\r\n    function divIsSafe(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return y != 0;\r\n    }\r\n\r\n    /**\r\n     * @return The result of dividing x by y, throwing an exception if the divisor is zero.\r\n     */\r\n    function safeDiv(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        /* Although a 0 denominator already throws an exception,\r\n         * it is equivalent to a THROW operation, which consumes all gas.\r\n         * A require statement emits REVERT instead, which remits remaining gas. */\r\n        require(y != 0);\r\n        return x / y;\r\n    }\r\n\r\n    /**\r\n     * @return The result of dividing x by y, interpreting the operands as fixed point decimal numbers.\r\n     * @dev Throws an exception in case of overflow or zero divisor; x must be less than 2^256 / UNIT.\r\n     * Internal rounding is downward: a similar caveat holds as with safeDecMul().\r\n     */\r\n    function safeDiv_dec(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        /* Reintroduce the UNIT factor that will be divided out by y. */\r\n        return safeDiv(safeMul(x, UNIT), y);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert an unsigned integer to a unsigned fixed-point decimal.\r\n     * Throw an exception if the result would be out of range.\r\n     */\r\n    function intToDec(uint i)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        return safeMul(i, UNIT);\r\n    }\r\n\r\n    function min(uint a, uint b) \r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint a, uint b) \r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title A contract with an owner.\r\n * @notice Contract ownership can be transferred by first nominating the new owner,\r\n * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\r\n */\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    /**\r\n     * @dev Owned Constructor\r\n     */\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        require(_owner != address(0));\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Nominate a new owner of this contract.\r\n     * @dev Only the current owner may nominate a new owner.\r\n     */\r\n    function nominateNewOwner(address _owner)\r\n        external\r\n        onlyOwner\r\n    {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Accept the nomination to be owner.\r\n     */\r\n    function acceptOwnership()\r\n        external\r\n        onlyNominatedOwner\r\n    {\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n    }\r\n\r\n    modifier onlyOwner\r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyNominatedOwner\r\n    {\r\n        require(msg.sender == nominatedOwner);\r\n        _;\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\n/*\r\n * The CollateralMonitor queries and reports information\r\n * about collateralisation levels of the network.\r\n */\r\ncontract CollateralMonitor is Owned, SafeDecimalMath {\r\n    \r\n    Havven havven;\r\n    Nomin nomin;\r\n    HavvenEscrow escrow;\r\n\r\n    address[] issuers;\r\n    uint maxIssuers = 10;\r\n\r\n    constructor(Havven _havven, Nomin _nomin, HavvenEscrow _escrow)\r\n        Owned(msg.sender)\r\n        public\r\n    {\r\n        havven = _havven;\r\n        nomin = _nomin;\r\n        escrow = _escrow;\r\n    }\r\n\r\n    function setHavven(Havven _havven)\r\n        onlyOwner\r\n        external\r\n    {\r\n        havven = _havven;\r\n    }\r\n\r\n    function setNomin(Nomin _nomin)\r\n         onlyOwner\r\n         external\r\n    {\r\n        nomin = _nomin;\r\n    }\r\n\r\n    function setEscrow(HavvenEscrow _escrow)\r\n        onlyOwner\r\n        external\r\n    {\r\n        escrow = _escrow;\r\n    }\r\n\r\n    function setMaxIssuers(uint newMax)\r\n        onlyOwner\r\n        external\r\n    {\r\n        maxIssuers = newMax;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyNominatedOwner {\r\n        require(msg.sender == nominatedOwner);\r\n        _;\r\n    }\r\n\r\n    function pushIssuer(address issuer)\r\n        onlyOwner\r\n        public\r\n    {\r\n        for (uint i = 0; i < issuers.length; i++) {\r\n            require(issuers[i] != issuer);\r\n        }\r\n        issuers.push(issuer);\r\n    }\r\n\r\n    function pushIssuers(address[] newIssuers)\r\n        onlyOwner\r\n        external\r\n    {\r\n        for (uint i = 0; i < issuers.length; i++) {\r\n            pushIssuer(newIssuers[i]);\r\n        }\r\n    }\r\n\r\n    function deleteIssuer(uint index)\r\n        onlyOwner\r\n        external\r\n    {\r\n        uint length = issuers.length;\r\n        require(index < length);\r\n        issuers[index] = issuers[length - 1];\r\n        delete issuers[length - 1];\r\n    }\r\n\r\n    function resizeIssuersArray(uint size)\r\n        onlyOwner\r\n        external\r\n    {\r\n        issuers.length = size;\r\n    }\r\n\r\n\r\n    /**********************************\\\r\n      collateral()\r\n\r\n      Reports the collateral available \r\n      for issuance of a given issuer.\r\n    \\**********************************/\r\n\r\n    function collateral(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return safeAdd(havven.balanceOf(account), escrow.balanceOf(account));\r\n    }\r\n\r\n\r\n    /**********************************\\\r\n      totalIssuingCollateral()\r\n\r\n      Reports the collateral available \r\n      for issuance of all issuers.\r\n    \\**********************************/\r\n\r\n    function _limitedTotalIssuingCollateral(uint sumLimit)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint sum;\r\n        uint limit = min(sumLimit, issuers.length);\r\n        for (uint i = 0; i < limit; i++) {\r\n            sum += collateral(issuers[i]);\r\n        } \r\n        return sum;\r\n    }\r\n\r\n    function totalIssuingCollateral()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return _limitedTotalIssuingCollateral(issuers.length);\r\n    }\r\n\r\n    function totalIssuingCollateral_limitedSum()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return _limitedTotalIssuingCollateral(maxIssuers);\r\n    } \r\n\r\n\r\n\r\n    /********************************\\\r\n      collateralisation()\r\n    \r\n      Reports the collateralisation\r\n      ratio of one account, assuming\r\n      a nomin price of one dollar.\r\n    \\********************************/\r\n\r\n    function collateralisation(address account)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        safeDiv_dec(safeMul_dec(collateral(account), havven.price()), \r\n                    havven.nominsIssued(account));\r\n    }\r\n\r\n\r\n    /********************************\\\r\n      totalIssuerCollateralisation()\r\n    \r\n      Reports the collateralisation\r\n      ratio of all issuers, assuming\r\n      a nomin price of one dollar.\r\n    \\********************************/\r\n\r\n    function totalIssuerCollateralisation()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        safeDiv_dec(safeMul_dec(totalIssuingCollateral(), havven.price()),\r\n                    nomin.totalSupply());\r\n    }\r\n\r\n\r\n    /********************************\\\r\n      totalNetworkCollateralisation()\r\n    \r\n      Reports the collateralisation\r\n      ratio of the entire network,\r\n      assuming a nomin price of one\r\n      dollar, and that havvens can\r\n      flow from non-issuer to issuer\r\n      accounts.\r\n    \\********************************/\r\n\r\n    function totalNetworkCollateralisation()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        safeDiv_dec(safeMul_dec(havven.totalSupply(), havven.price()),\r\n                    nomin.totalSupply());\r\n    }\r\n\r\n\r\n    /**************************************\\\r\n      totalIssuanceDebt()\r\n\r\n      Reports the the (unbounded) number\r\n      of havvens that would be locked by\r\n      all issued nomins, if the collateral\r\n      backing them was unlimited.\r\n    \\**************************************/\r\n\r\n    function totalIssuanceDebt()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return safeDiv_dec(nomin.totalSupply(),\r\n                           safeMul_dec(havven.issuanceRatio(), havven.price()));\r\n    }\r\n\r\n    function totalIssuanceDebt_limitedSum()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint sum;\r\n        uint limit = min(maxIssuers, issuers.length);\r\n        for (uint i = 0; i < limit; i++) {\r\n            sum += havven.nominsIssued(issuers[i]);\r\n        }\r\n        return safeDiv_dec(sum,\r\n                           safeMul_dec(havven.issuanceRatio(), havven.price()));\r\n    }\r\n\r\n\r\n    /*************************************\\\r\n      totalLockedHavvens()\r\n\r\n      Reports the the number of havvens\r\n      locked by all issued nomins.\r\n      This is capped by the actual number\r\n      of havvens in circulation.\r\n    \\*************************************/\r\n\r\n    function totalLockedHavvens()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return min(totalIssuanceDebt(), totalIssuingCollateral());\r\n    }\r\n\r\n    function totalLockedHavvens_limitedSum()\r\n        public\r\n        view\r\n        returns (uint)\r\n    { \r\n        return min(totalIssuanceDebt_limitedSum(), totalIssuingCollateral());\r\n    }\r\n\r\n\r\n    /****************************************************\\\r\n      totalLockedHavvens_byAvailableHavvens_limitedSum()\r\n      \r\n      Should be equivalent to\r\n      totalLockedHavvens_limitedSum() but it uses an\r\n      alternate computation method.\r\n    \\****************************************************/\r\n\r\n    function totalLockedHavvens_byAvailableHavvens_limitedSum()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint sum;\r\n        uint limit = min(maxIssuers, issuers.length);\r\n        for (uint i = 0; i < limit; i++) {\r\n            address issuer = issuers[i];\r\n            sum += safeSub(collateral(issuer), havven.availableHavvens(issuer));\r\n        }\r\n        return sum;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"pushIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newIssuers\",\"type\":\"address[]\"}],\"name\":\"pushIssuers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaxIssuers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"resizeIssuersArray\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuanceDebt_limitedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLockedHavvens_byAvailableHavvens_limitedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_havven\",\"type\":\"address\"}],\"name\":\"setHavven\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNetworkCollateralisation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLockedHavvens_limitedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nomin\",\"type\":\"address\"}],\"name\":\"setNomin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuanceDebt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuingCollateral_limitedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalLockedHavvens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"deleteIssuer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"collateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuingCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_escrow\",\"type\":\"address\"}],\"name\":\"setEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalIssuerCollateralisation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"collateralisation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_havven\",\"type\":\"address\"},{\"name\":\"_nomin\",\"type\":\"address\"},{\"name\":\"_escrow\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"CollateralMonitor","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c011a72400e58ecd99ee497cf89e3775d4bd732f00000000000000000000000057ab1e02fee23774580c119740129eac7081e9d3000000000000000000000000971e78e0c92392a4e39099835cf7e6ab535b2227","Library":"","SwarmSource":"bzzr://5cc452b13fa9ffb16eff776d42640f35cb9f2c12aac5e3e4d805c1b4a03a69b1"}]}