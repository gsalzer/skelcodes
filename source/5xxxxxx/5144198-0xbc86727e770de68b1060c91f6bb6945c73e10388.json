{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/InkMediator.sol\r\n\r\ninterface InkMediator {\r\n  function mediationExpiry() external returns (uint32);\r\n  function requestMediator(uint256 _transactionId, uint256 _transactionAmount, address _transactionOwner) external returns (bool);\r\n  function confirmTransactionFee(uint256 _transactionAmount) external returns (uint256);\r\n  function confirmTransactionAfterExpiryFee(uint256 _transactionAmount) external returns (uint256);\r\n  function confirmTransactionAfterDisputeFee(uint256 _transactionAmount) external returns (uint256);\r\n  function confirmTransactionByMediatorFee(uint256 _transactionAmount) external returns (uint256);\r\n  function refundTransactionFee(uint256 _transactionAmount) external returns (uint256);\r\n  function refundTransactionAfterExpiryFee(uint256 _transactionAmount) external returns (uint256);\r\n  function refundTransactionAfterDisputeFee(uint256 _transactionAmount) external returns (uint256);\r\n  function refundTransactionByMediatorFee(uint256 _transactionAmount) external returns (uint256);\r\n  function settleTransactionByMediatorFee(uint256 _buyerAmount, uint256 _sellerAmount) external returns (uint256, uint256);\r\n}\r\n\r\n// File: contracts/InkOwner.sol\r\n\r\ninterface InkOwner {\r\n  function authorizeTransaction(uint256 _id, address _buyer) external returns (bool);\r\n}\r\n\r\n// File: contracts/InkProtocolInterface.sol\r\n\r\ninterface InkProtocolInterface {\r\n  // Event emitted when a transaction is initiated.\r\n  event TransactionInitiated(\r\n    uint256 indexed id,\r\n    address owner,\r\n    address indexed buyer,\r\n    address indexed seller,\r\n    address policy,\r\n    address mediator,\r\n    uint256 amount,\r\n    // A hash string representing the metadata for the transaction. This is\r\n    // somewhat arbitrary for the transaction. Only the transaction owner\r\n    // will really know the original contents of the metadata and may choose\r\n    // to share it at their discretion.\r\n    bytes32 metadata\r\n  );\r\n\r\n  // Event emitted when a transaction has been accepted by the seller.\r\n  event TransactionAccepted(\r\n    uint256 indexed id\r\n  );\r\n\r\n  // Event emitted when a transaction has been disputed by the buyer.\r\n  event TransactionDisputed(\r\n    uint256 indexed id\r\n  );\r\n\r\n  // Event emitted when a transaction is escalated to the mediator by the\r\n  // seller.\r\n  event TransactionEscalated(\r\n    uint256 indexed id\r\n  );\r\n\r\n  // Event emitted when a transaction is revoked by the seller.\r\n  event TransactionRevoked(\r\n    uint256 indexed id\r\n  );\r\n\r\n  // Event emitted when a transaction is revoked by the seller.\r\n  event TransactionRefundedByMediator(\r\n    uint256 indexed id,\r\n    uint256 mediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is settled by the mediator.\r\n  event TransactionSettledByMediator(\r\n    uint256 indexed id,\r\n    uint256 buyerAmount,\r\n    uint256 sellerAmount,\r\n    uint256 buyerMediatorFee,\r\n    uint256 sellerMediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is confirmed by the mediator.\r\n  event TransactionConfirmedByMediator(\r\n    uint256 indexed id,\r\n    uint256 mediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is confirmed by the buyer.\r\n  event TransactionConfirmed(\r\n    uint256 indexed id,\r\n    uint256 mediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is refunded by the seller.\r\n  event TransactionRefunded(\r\n    uint256 indexed id,\r\n    uint256 mediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is confirmed by the seller after the\r\n  // transaction expiry.\r\n  event TransactionConfirmedAfterExpiry(\r\n    uint256 indexed id,\r\n    uint256 mediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is confirmed by the buyer after it was\r\n  // disputed.\r\n  event TransactionConfirmedAfterDispute(\r\n    uint256 indexed id,\r\n    uint256 mediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is refunded by the seller after it was\r\n  // disputed.\r\n  event TransactionRefundedAfterDispute(\r\n    uint256 indexed id,\r\n    uint256 mediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is refunded by the buyer after the\r\n  // escalation expiry.\r\n  event TransactionRefundedAfterExpiry(\r\n    uint256 indexed id,\r\n    uint256 mediatorFee\r\n  );\r\n\r\n  // Event emitted when a transaction is confirmed by the buyer after the\r\n  // mediation expiry.\r\n  event TransactionConfirmedAfterEscalation(\r\n    uint256 indexed id\r\n  );\r\n\r\n  // Event emitted when a transaction is refunded by the seller after the\r\n  // mediation expiry.\r\n  event TransactionRefundedAfterEscalation(\r\n    uint256 indexed id\r\n  );\r\n\r\n  // Event emitted when a transaction is settled by either the buyer or the\r\n  // seller after the mediation expiry.\r\n  event TransactionSettled(\r\n    uint256 indexed id,\r\n    uint256 buyerAmount,\r\n    uint256 sellerAmount\r\n  );\r\n\r\n  // Event emitted when a transaction's feedback is updated by the buyer.\r\n  event FeedbackUpdated(\r\n    uint256 indexed transactionId,\r\n    uint8 rating,\r\n    bytes32 comment\r\n  );\r\n\r\n  // Event emitted an account is (unidirectionally) linked to another account.\r\n  // For two accounts to be acknowledged as linked, the linkage must be\r\n  // bidirectional.\r\n  event AccountLinked(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n\r\n  /* Protocol */\r\n  function link(address _to) external;\r\n  function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator) external returns (uint256);\r\n  function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator, address _owner) external returns (uint256);\r\n  function revokeTransaction(uint256 _id) external;\r\n  function acceptTransaction(uint256 _id) external;\r\n  function confirmTransaction(uint256 _id) external;\r\n  function confirmTransactionAfterExpiry(uint256 _id) external;\r\n  function refundTransaction(uint256 _id) external;\r\n  function refundTransactionAfterExpiry(uint256 _id) external;\r\n  function disputeTransaction(uint256 _id) external;\r\n  function escalateDisputeToMediator(uint256 _id) external;\r\n  function settleTransaction(uint256 _id) external;\r\n  function refundTransactionByMediator(uint256 _id) external;\r\n  function confirmTransactionByMediator(uint256 _id) external;\r\n  function settleTransactionByMediator(uint256 _id, uint256 _buyerAmount, uint256 _sellerAmount) external;\r\n  function provideTransactionFeedback(uint256 _id, uint8 _rating, bytes32 _comment) external;\r\n\r\n  /* ERC20 */\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function increaseApproval(address spender, uint addedValue) public returns (bool);\r\n  function decreaseApproval(address spender, uint subtractedValue) public returns (bool);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/InkProtocolCore.sol\r\n\r\n/// @title Ink Protocol: Decentralized reputation and payments for peer-to-peer marketplaces.\r\ncontract InkProtocolCore is InkProtocolInterface, StandardToken {\r\n  string public constant name = \"Ink Protocol\";\r\n  string public constant symbol = \"XNK\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  uint256 private constant gasLimitForExpiryCall = 1000000;\r\n  uint256 private constant gasLimitForMediatorCall = 4000000;\r\n\r\n  enum Expiry {\r\n    Transaction, // 0\r\n    Fulfillment, // 1\r\n    Escalation,  // 2\r\n    Mediation    // 3\r\n  }\r\n\r\n  enum TransactionState {\r\n    // This is an internal state to represent an uninitialized transaction.\r\n    Null,                     // 0\r\n\r\n    Initiated,                // 1\r\n    Accepted,                 // 2\r\n    Disputed,                 // 3\r\n    Escalated,                // 4\r\n    Revoked,                  // 5\r\n    RefundedByMediator,       // 6\r\n    SettledByMediator,        // 7\r\n    ConfirmedByMediator,      // 8\r\n    Confirmed,                // 9\r\n    Refunded,                 // 10\r\n    ConfirmedAfterExpiry,     // 11\r\n    ConfirmedAfterDispute,    // 12\r\n    RefundedAfterDispute,     // 13\r\n    RefundedAfterExpiry,      // 14\r\n    ConfirmedAfterEscalation, // 15\r\n    RefundedAfterEscalation,  // 16\r\n    Settled                   // 17\r\n  }\r\n\r\n  // The running ID counter for all Ink Transactions.\r\n  uint256 private globalTransactionId = 0;\r\n\r\n  // Mapping of all transactions by ID (globalTransactionId).\r\n  mapping(uint256 => Transaction) internal transactions;\r\n\r\n  // The struct definition for an Ink Transaction.\r\n  struct Transaction {\r\n    // The address of the buyer on the transaction.\r\n    address buyer;\r\n    // The address of the seller on the transaction.\r\n    address seller;\r\n    // The address of the policy contract for the transaction.\r\n    address policy;\r\n    // The address of the mediator contract for the transaction.\r\n    address mediator;\r\n    // The state of the transaction.\r\n    TransactionState state;\r\n    // The (block) time that the transaction transitioned to its current state.\r\n    // This value is only set for the states that need it to be set (states\r\n    // with an expiry involved).\r\n    uint256 stateTime;\r\n    // The XNK amount of the transaction.\r\n    uint256 amount;\r\n  }\r\n\r\n\r\n  /*\r\n    Constructor\r\n  */\r\n\r\n  function InkProtocolCore() internal {\r\n    // Start with a total supply of 500,000,000 Ink Tokens (XNK).\r\n    totalSupply_ = 500000000000000000000000000;\r\n  }\r\n\r\n\r\n  /*\r\n    ERC20 override functions\r\n  */\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n   // Don't allow token transfers to the Ink contract.\r\n   require(_to != address(this));\r\n\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n   // Don't allow token transfers to the Ink contract.\r\n   require(_to != address(this));\r\n\r\n   return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n\r\n  /*\r\n    Account linking functions\r\n\r\n    Functions used by users and agents to declare a unidirectionally account\r\n    linking.\r\n  */\r\n\r\n  // Called by a user who wishes to link with another _account.\r\n  function link(address _to) external {\r\n    require(_to != address(0));\r\n    require(_to != msg.sender);\r\n\r\n    AccountLinked({\r\n      from: msg.sender,\r\n      to: _to\r\n    });\r\n  }\r\n\r\n\r\n  /*\r\n    Transaction functions\r\n  */\r\n\r\n  function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator) external returns (uint256) {\r\n    return _createTransaction(_seller, _amount, _metadata, _policy, _mediator, address(0));\r\n  }\r\n\r\n  function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator, address _owner) external returns (uint256) {\r\n    return _createTransaction(_seller, _amount, _metadata, _policy, _mediator, _owner);\r\n  }\r\n\r\n  function revokeTransaction(uint256 _id) external {\r\n    _revokeTransaction(_id, _findTransactionForBuyer(_id));\r\n  }\r\n\r\n  function acceptTransaction(uint256 _id) external {\r\n    _acceptTransaction(_id, _findTransactionForSeller(_id));\r\n  }\r\n\r\n  function confirmTransaction(uint256 _id) external {\r\n    _confirmTransaction(_id, _findTransactionForBuyer(_id));\r\n  }\r\n\r\n  function confirmTransactionAfterExpiry(uint256 _id) external {\r\n    _confirmTransactionAfterExpiry(_id, _findTransactionForSeller(_id));\r\n  }\r\n\r\n  function refundTransaction(uint256 _id) external {\r\n    _refundTransaction(_id, _findTransactionForSeller(_id));\r\n  }\r\n\r\n  function refundTransactionAfterExpiry(uint256 _id) external {\r\n    _refundTransactionAfterExpiry(_id, _findTransactionForBuyer(_id));\r\n  }\r\n\r\n  function disputeTransaction(uint256 _id) external {\r\n    _disputeTransaction(_id, _findTransactionForBuyer(_id));\r\n  }\r\n\r\n  function escalateDisputeToMediator(uint256 _id) external {\r\n    _escalateDisputeToMediator(_id, _findTransactionForSeller(_id));\r\n  }\r\n\r\n  function settleTransaction(uint256 _id) external {\r\n    _settleTransaction(_id, _findTransactionForParty(_id));\r\n  }\r\n\r\n  function refundTransactionByMediator(uint256 _id) external {\r\n    _refundTransactionByMediator(_id, _findTransactionForMediator(_id));\r\n  }\r\n\r\n  function confirmTransactionByMediator(uint256 _id) external {\r\n    _confirmTransactionByMediator(_id, _findTransactionForMediator(_id));\r\n  }\r\n\r\n  function settleTransactionByMediator(uint256 _id, uint256 _buyerAmount, uint256 _sellerAmount) external {\r\n    _settleTransactionByMediator(_id, _findTransactionForMediator(_id), _buyerAmount, _sellerAmount);\r\n  }\r\n\r\n  function provideTransactionFeedback(uint256 _id, uint8 _rating, bytes32 _comment) external {\r\n    _provideTransactionFeedback(_id, _findTransactionForBuyer(_id), _rating, _comment);\r\n  }\r\n\r\n\r\n  /*\r\n    Private functions\r\n  */\r\n\r\n  function _createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator, address _owner) private returns (uint256) {\r\n    require(_seller != address(0) && _seller != msg.sender);\r\n    require(_owner != msg.sender && _owner != _seller);\r\n    require(_amount > 0);\r\n\r\n    // Per specifications, if a mediator is involved then a policy is required.\r\n    // Otherwise, policy must be a zero address.\r\n    if (_mediator == address(0)) {\r\n      require(_policy == address(0));\r\n    } else {\r\n      require(_policy != address(0));\r\n    }\r\n\r\n    // Increment the transaction.\r\n    uint256 id = globalTransactionId++;\r\n\r\n    // Create the transaction.\r\n    Transaction storage transaction = transactions[id];\r\n    transaction.buyer = msg.sender;\r\n    transaction.seller = _seller;\r\n    transaction.state = TransactionState.Initiated;\r\n    transaction.amount = _amount;\r\n    transaction.policy = _policy;\r\n\r\n    _resolveMediator(id, transaction, _mediator, _owner);\r\n    _resolveOwner(id, _owner);\r\n\r\n    // Emit the event.\r\n    TransactionInitiated({\r\n      id: id,\r\n      owner: _owner,\r\n      buyer: msg.sender,\r\n      seller: _seller,\r\n      policy: _policy,\r\n      mediator: _mediator,\r\n      amount: _amount,\r\n      metadata: _metadata\r\n    });\r\n\r\n    // Place the buyer's tokens in escrow (ie. this contract).\r\n    _transferFrom(msg.sender, this, _amount);\r\n\r\n    // Return the newly created transaction's id.\r\n    return id;\r\n  }\r\n\r\n  function _revokeTransaction(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Initiated);\r\n\r\n    TransactionRevoked({ id: _id });\r\n\r\n    _transferFromEscrow(_transaction.buyer, _transaction.amount);\r\n\r\n    _cleanupTransaction(_id, _transaction, false);\r\n  }\r\n\r\n  function _acceptTransaction(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Initiated);\r\n\r\n    if (_transaction.mediator != address(0)) {\r\n      _updateTransactionState(_transaction, TransactionState.Accepted);\r\n    }\r\n\r\n    TransactionAccepted({ id: _id });\r\n\r\n    if (_transaction.mediator == address(0)) {\r\n      // If there is no mediator involved, the transaction is immediately confirmed.\r\n      _completeTransaction(_id, _transaction, TransactionState.Confirmed, _transaction.seller);\r\n    }\r\n  }\r\n\r\n  function _confirmTransaction(uint256 _id, Transaction storage _transaction) private {\r\n    TransactionState finalState;\r\n\r\n    if (_transaction.state == TransactionState.Accepted) {\r\n      finalState = TransactionState.Confirmed;\r\n    } else if (_transaction.state == TransactionState.Disputed) {\r\n      finalState = TransactionState.ConfirmedAfterDispute;\r\n    } else if (_transaction.state == TransactionState.Escalated) {\r\n      require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Mediation)));\r\n      finalState = TransactionState.ConfirmedAfterEscalation;\r\n    } else {\r\n      revert();\r\n    }\r\n\r\n    _completeTransaction(_id, _transaction, finalState, _transaction.seller);\r\n  }\r\n\r\n  function _confirmTransactionAfterExpiry(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Accepted);\r\n    require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Transaction)));\r\n\r\n    _completeTransaction(_id, _transaction, TransactionState.ConfirmedAfterExpiry, _transaction.seller);\r\n  }\r\n\r\n  function _refundTransaction(uint256 _id, Transaction storage _transaction) private {\r\n    TransactionState finalState;\r\n\r\n    if (_transaction.state == TransactionState.Accepted) {\r\n      finalState = TransactionState.Refunded;\r\n    } else if (_transaction.state == TransactionState.Disputed) {\r\n      finalState = TransactionState.RefundedAfterDispute;\r\n    } else if (_transaction.state == TransactionState.Escalated) {\r\n      require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Mediation)));\r\n      finalState = TransactionState.RefundedAfterEscalation;\r\n    } else {\r\n      revert();\r\n    }\r\n\r\n    _completeTransaction(_id, _transaction, finalState, _transaction.buyer);\r\n  }\r\n\r\n  function _refundTransactionAfterExpiry(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Disputed);\r\n    require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Escalation)));\r\n\r\n    _completeTransaction(_id, _transaction, TransactionState.RefundedAfterExpiry, _transaction.buyer);\r\n  }\r\n\r\n  function _disputeTransaction(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Accepted);\r\n    require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Fulfillment)));\r\n\r\n    _updateTransactionState(_transaction, TransactionState.Disputed);\r\n\r\n    TransactionDisputed({ id: _id });\r\n  }\r\n\r\n  function _escalateDisputeToMediator(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Disputed);\r\n\r\n    _updateTransactionState(_transaction, TransactionState.Escalated);\r\n\r\n    TransactionEscalated({ id: _id });\r\n  }\r\n\r\n  function _settleTransaction(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Escalated);\r\n    require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Mediation)));\r\n\r\n    // Divide the escrow amount in half and give it to the buyer. There's\r\n    // a possibility that one account will get slightly more than the other.\r\n    // We have decided to give the lesser amount to the buyer (arbitrarily).\r\n    uint256 buyerAmount = _transaction.amount.div(2);\r\n    // The remaining amount is given to the seller.\r\n    uint256 sellerAmount = _transaction.amount.sub(buyerAmount);\r\n\r\n    TransactionSettled({\r\n      id: _id,\r\n      buyerAmount: buyerAmount,\r\n      sellerAmount: sellerAmount\r\n    });\r\n\r\n    _transferFromEscrow(_transaction.buyer, buyerAmount);\r\n    _transferFromEscrow(_transaction.seller, sellerAmount);\r\n\r\n    _cleanupTransaction(_id, _transaction, true);\r\n  }\r\n\r\n  function _refundTransactionByMediator(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Escalated);\r\n\r\n    _completeTransaction(_id, _transaction, TransactionState.RefundedByMediator, _transaction.buyer);\r\n  }\r\n\r\n  function _confirmTransactionByMediator(uint256 _id, Transaction storage _transaction) private {\r\n    require(_transaction.state == TransactionState.Escalated);\r\n\r\n    _completeTransaction(_id, _transaction, TransactionState.ConfirmedByMediator, _transaction.seller);\r\n  }\r\n\r\n  function _settleTransactionByMediator(uint256 _id, Transaction storage _transaction, uint256 _buyerAmount, uint256 _sellerAmount) private {\r\n    require(_transaction.state == TransactionState.Escalated);\r\n    require(_buyerAmount.add(_sellerAmount) == _transaction.amount);\r\n\r\n    uint256 buyerMediatorFee;\r\n    uint256 sellerMediatorFee;\r\n\r\n    (buyerMediatorFee, sellerMediatorFee) = InkMediator(_transaction.mediator).settleTransactionByMediatorFee(_buyerAmount, _sellerAmount);\r\n\r\n    // Require that the sum of the fees be no more than the transaction's amount.\r\n    require(buyerMediatorFee <= _buyerAmount && sellerMediatorFee <= _sellerAmount);\r\n\r\n    TransactionSettledByMediator({\r\n      id: _id,\r\n      buyerAmount: _buyerAmount,\r\n      sellerAmount: _sellerAmount,\r\n      buyerMediatorFee: buyerMediatorFee,\r\n      sellerMediatorFee: sellerMediatorFee\r\n    });\r\n\r\n    _transferFromEscrow(_transaction.buyer, _buyerAmount.sub(buyerMediatorFee));\r\n    _transferFromEscrow(_transaction.seller, _sellerAmount.sub(sellerMediatorFee));\r\n    _transferFromEscrow(_transaction.mediator, buyerMediatorFee.add(sellerMediatorFee));\r\n\r\n    _cleanupTransaction(_id, _transaction, true);\r\n  }\r\n\r\n  function _provideTransactionFeedback(uint256 _id, Transaction storage _transaction, uint8 _rating, bytes32 _comment) private {\r\n    // The transaction must be completed (Null state with a buyer) to allow\r\n    // feedback.\r\n    require(_transaction.state == TransactionState.Null);\r\n\r\n    // As per functional specifications, ratings must be an integer between\r\n    // 1 and 5, inclusive.\r\n    require(_rating >= 1 && _rating <= 5);\r\n\r\n    FeedbackUpdated({\r\n      transactionId: _id,\r\n      rating: _rating,\r\n      comment: _comment\r\n    });\r\n  }\r\n\r\n  function _completeTransaction(uint256 _id, Transaction storage _transaction, TransactionState _finalState, address _transferTo) private {\r\n    uint256 mediatorFee = _fetchMediatorFee(_transaction, _finalState);\r\n\r\n    if (_finalState == TransactionState.Confirmed) {\r\n      TransactionConfirmed({ id: _id, mediatorFee: mediatorFee });\r\n    } else if (_finalState == TransactionState.ConfirmedAfterDispute) {\r\n      TransactionConfirmedAfterDispute({ id: _id, mediatorFee: mediatorFee });\r\n    } else if (_finalState == TransactionState.ConfirmedAfterEscalation) {\r\n      TransactionConfirmedAfterEscalation({ id: _id });\r\n    } else if (_finalState == TransactionState.ConfirmedAfterExpiry) {\r\n      TransactionConfirmedAfterExpiry({ id: _id, mediatorFee: mediatorFee });\r\n    } else if (_finalState == TransactionState.Refunded) {\r\n      TransactionRefunded({ id: _id, mediatorFee: mediatorFee });\r\n    } else if (_finalState == TransactionState.RefundedAfterDispute) {\r\n      TransactionRefundedAfterDispute({ id: _id, mediatorFee: mediatorFee });\r\n    } else if (_finalState == TransactionState.RefundedAfterEscalation) {\r\n      TransactionRefundedAfterEscalation({ id: _id });\r\n    } else if (_finalState == TransactionState.RefundedAfterExpiry) {\r\n      TransactionRefundedAfterExpiry({ id: _id, mediatorFee: mediatorFee });\r\n    } else if (_finalState == TransactionState.RefundedByMediator) {\r\n      TransactionRefundedByMediator({ id: _id, mediatorFee: mediatorFee });\r\n    } else if (_finalState == TransactionState.ConfirmedByMediator) {\r\n      TransactionConfirmedByMediator({ id: _id, mediatorFee: mediatorFee });\r\n    }\r\n\r\n    _transferFromEscrow(_transferTo, _transaction.amount.sub(mediatorFee));\r\n    _transferFromEscrow(_transaction.mediator, mediatorFee);\r\n\r\n    _cleanupTransaction(_id, _transaction, true);\r\n  }\r\n\r\n  function _fetchExpiry(Transaction storage _transaction, Expiry _expiryType) private returns (uint32) {\r\n    uint32 expiry;\r\n    bool success;\r\n\r\n    if (_expiryType == Expiry.Transaction) {\r\n      success = _transaction.policy.call.gas(gasLimitForExpiryCall)(bytes4(keccak256(\"transactionExpiry()\")));\r\n    } else if (_expiryType == Expiry.Fulfillment) {\r\n      success = _transaction.policy.call.gas(gasLimitForExpiryCall)(bytes4(keccak256(\"fulfillmentExpiry()\")));\r\n    } else if (_expiryType == Expiry.Escalation) {\r\n      success = _transaction.policy.call.gas(gasLimitForExpiryCall)(bytes4(keccak256(\"escalationExpiry()\")));\r\n    } else if (_expiryType == Expiry.Mediation) {\r\n      success = _transaction.mediator.call.gas(gasLimitForExpiryCall)(bytes4(keccak256(\"mediationExpiry()\")));\r\n    }\r\n\r\n    if (success) {\r\n      assembly {\r\n        if eq(returndatasize(), 0x20) {\r\n          let _freeMemPointer := mload(0x40)\r\n          returndatacopy(_freeMemPointer, 0, 0x20)\r\n          expiry := mload(_freeMemPointer)\r\n        }\r\n      }\r\n    }\r\n\r\n    return expiry;\r\n  }\r\n\r\n  function _fetchMediatorFee(Transaction storage _transaction, TransactionState _finalState) private returns (uint256) {\r\n    if (_transaction.mediator == address(0)) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 mediatorFee;\r\n    bool success;\r\n\r\n    if (_finalState == TransactionState.Confirmed) {\r\n      success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"confirmTransactionFee(uint256)\")), _transaction.amount);\r\n    } else if (_finalState == TransactionState.ConfirmedAfterExpiry) {\r\n      success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"confirmTransactionAfterExpiryFee(uint256)\")), _transaction.amount);\r\n    } else if (_finalState == TransactionState.ConfirmedAfterDispute) {\r\n      success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"confirmTransactionAfterDisputeFee(uint256)\")), _transaction.amount);\r\n    } else if (_finalState == TransactionState.ConfirmedByMediator) {\r\n      mediatorFee = InkMediator(_transaction.mediator).confirmTransactionByMediatorFee(_transaction.amount);\r\n    } else if (_finalState == TransactionState.Refunded) {\r\n      success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"refundTransactionFee(uint256)\")), _transaction.amount);\r\n    } else if (_finalState == TransactionState.RefundedAfterExpiry) {\r\n      success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"refundTransactionAfterExpiryFee(uint256)\")), _transaction.amount);\r\n    } else if (_finalState == TransactionState.RefundedAfterDispute) {\r\n      success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"refundTransactionAfterDisputeFee(uint256)\")), _transaction.amount);\r\n    } else if (_finalState == TransactionState.RefundedByMediator) {\r\n      mediatorFee = InkMediator(_transaction.mediator).refundTransactionByMediatorFee(_transaction.amount);\r\n    }\r\n\r\n    if (success) {\r\n      assembly {\r\n        if eq(returndatasize(), 0x20) {\r\n          let _freeMemPointer := mload(0x40)\r\n          returndatacopy(_freeMemPointer, 0, 0x20)\r\n          mediatorFee := mload(_freeMemPointer)\r\n        }\r\n      }\r\n\r\n      // The mediator's fee cannot be more than transaction's amount.\r\n      if (mediatorFee > _transaction.amount) {\r\n        mediatorFee = 0;\r\n      }\r\n    } else {\r\n      require(mediatorFee <= _transaction.amount);\r\n    }\r\n\r\n    return mediatorFee;\r\n  }\r\n\r\n  function _resolveOwner(uint256 _transactionId, address _owner) private {\r\n    if (_owner != address(0)) {\r\n      // If an owner is specified, it must authorize the transaction.\r\n      require(InkOwner(_owner).authorizeTransaction(\r\n        _transactionId,\r\n        msg.sender\r\n      ));\r\n    }\r\n  }\r\n\r\n  function _resolveMediator(uint256 _transactionId, Transaction storage _transaction, address _mediator, address _owner) private {\r\n    if (_mediator != address(0)) {\r\n      // The mediator must accept the transaction otherwise we abort.\r\n      require(InkMediator(_mediator).requestMediator(_transactionId, _transaction.amount, _owner));\r\n\r\n      // Assign the mediator to the transaction.\r\n      _transaction.mediator = _mediator;\r\n    }\r\n  }\r\n\r\n  function _afterExpiry(Transaction storage _transaction, uint32 _expiry) private view returns (bool) {\r\n    return now.sub(_transaction.stateTime) >= _expiry;\r\n  }\r\n\r\n  function _findTransactionForBuyer(uint256 _id) private view returns (Transaction storage transaction) {\r\n    transaction = _findTransaction(_id);\r\n    require(msg.sender == transaction.buyer);\r\n  }\r\n\r\n  function _findTransactionForSeller(uint256 _id) private view returns (Transaction storage transaction) {\r\n    transaction = _findTransaction(_id);\r\n    require(msg.sender == transaction.seller);\r\n  }\r\n\r\n  function _findTransactionForParty(uint256 _id) private view returns (Transaction storage transaction) {\r\n    transaction = _findTransaction(_id);\r\n    require(msg.sender == transaction.buyer || msg.sender == transaction.seller);\r\n  }\r\n\r\n  function _findTransactionForMediator(uint256 _id) private view returns (Transaction storage transaction) {\r\n    transaction = _findTransaction(_id);\r\n    require(msg.sender == transaction.mediator);\r\n  }\r\n\r\n  function _findTransaction(uint256 _id) private view returns (Transaction storage transaction) {\r\n    transaction = transactions[_id];\r\n    require(_id < globalTransactionId);\r\n  }\r\n\r\n  function _transferFrom(address _from, address _to, uint256 _value) private returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(_from, _to, _value);\r\n\r\n    return true;\r\n  }\r\n\r\n  function _transferFromEscrow(address _to, uint256 _value) private returns (bool) {\r\n    if (_value > 0) {\r\n      return _transferFrom(this, _to, _value);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function _updateTransactionState(Transaction storage _transaction, TransactionState _state) private {\r\n    _transaction.state = _state;\r\n    _transaction.stateTime = now;\r\n  }\r\n\r\n  function _cleanupTransaction(uint256 _id, Transaction storage _transaction, bool _completed) private {\r\n    // Remove data that is no longer needed on the contract.\r\n\r\n    if (_completed) {\r\n      delete _transaction.state;\r\n      delete _transaction.seller;\r\n      delete _transaction.policy;\r\n      delete _transaction.mediator;\r\n      delete _transaction.stateTime;\r\n      delete _transaction.amount;\r\n    } else {\r\n      delete transactions[_id];\r\n    }\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/TokenVesting.sol\r\n\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  event Released(uint256 amount);\r\n  event Revoked();\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  uint256 public cliff;\r\n  uint256 public start;\r\n  uint256 public duration;\r\n\r\n  bool public revocable;\r\n\r\n  mapping (address => uint256) public released;\r\n  mapping (address => bool) public revoked;\r\n\r\n  /**\r\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n   * of the balance will have vested.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @param _revocable whether the vesting is revocable or not\r\n   */\r\n  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\r\n    require(_beneficiary != address(0));\r\n    require(_cliff <= _duration);\r\n\r\n    beneficiary = _beneficiary;\r\n    revocable = _revocable;\r\n    duration = _duration;\r\n    cliff = _start.add(_cliff);\r\n    start = _start;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers vested tokens to beneficiary.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function release(ERC20Basic token) public {\r\n    uint256 unreleased = releasableAmount(token);\r\n\r\n    require(unreleased > 0);\r\n\r\n    released[token] = released[token].add(unreleased);\r\n\r\n    token.safeTransfer(beneficiary, unreleased);\r\n\r\n    Released(unreleased);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n   * remain in the contract, the rest are returned to the owner.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function revoke(ERC20Basic token) public onlyOwner {\r\n    require(revocable);\r\n    require(!revoked[token]);\r\n\r\n    uint256 balance = token.balanceOf(this);\r\n\r\n    uint256 unreleased = releasableAmount(token);\r\n    uint256 refund = balance.sub(unreleased);\r\n\r\n    revoked[token] = true;\r\n\r\n    token.safeTransfer(owner, refund);\r\n\r\n    Revoked();\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function releasableAmount(ERC20Basic token) public view returns (uint256) {\r\n    return vestedAmount(token).sub(released[token]);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function vestedAmount(ERC20Basic token) public view returns (uint256) {\r\n    uint256 currentBalance = token.balanceOf(this);\r\n    uint256 totalBalance = currentBalance.add(released[token]);\r\n\r\n    if (now < cliff) {\r\n      return 0;\r\n    } else if (now >= start.add(duration) || revoked[token]) {\r\n      return totalBalance;\r\n    } else {\r\n      return totalBalance.mul(now.sub(start)).div(duration);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/InkProtocol.sol\r\n\r\n/// @title Ink Protocol: Decentralized reputation and payments for peer-to-peer marketplaces.\r\ncontract InkProtocol is InkProtocolCore {\r\n  // Allocation addresses.\r\n  address public constant __address0__ = 0xA13febeEde2B2924Ce8b27c1512874D3576fEC16;\r\n  address public constant __address1__ = 0xc5bA7157b5B69B0fAe9332F30719Eecd79649486;\r\n  address public constant __address2__ = 0x29a4b44364A8Bcb6e4d9dd60c222cCaca286ebf2;\r\n  address public constant __address3__ = 0xc1DC1e5C3970E22201C5DAB0841abB2DD6499D3F;\r\n  address public constant __address4__ = 0x0746d0b67BED258d94D06b15859df8dbd990eC3D;\r\n\r\n  /*\r\n    Constructor for Mainnet.\r\n  */\r\n\r\n  function InkProtocol() public {\r\n    // Unsold tokens due to token sale hard cap.\r\n    balances[__address0__] = 19625973697895500000000000;\r\n    Transfer(address(0), __address0__, balanceOf(__address0__));\r\n\r\n    // Allocate 32% to contract for distribution.\r\n    // Vesting starts Feb 28, 2018 @ 00:00:00 GMT\r\n    TokenVesting vesting1 = new TokenVesting(__address1__, 1519776000, 0, 3 years, false);\r\n    balances[vesting1] = 160000000000000000000000000;\r\n    Transfer(address(0), vesting1, balanceOf(vesting1));\r\n\r\n    // Allocate 32% to contract for Listia Inc.\r\n    // Vesting starts Feb 28, 2018 @ 00:00:00 GMT\r\n    TokenVesting vesting2 = new TokenVesting(__address2__, 1519776000, 0, 3 years, false);\r\n    balances[vesting2] = 160000000000000000000000000;\r\n    Transfer(address(0), vesting2, balanceOf(vesting2));\r\n\r\n    // Allocate 6% to wallet for Listia Marketplace credit conversion.\r\n    balances[__address3__] = 30000000000000000000000000;\r\n    Transfer(address(0), __address3__, balanceOf(__address3__));\r\n\r\n    // Allocate to wallet for token sale distribution.\r\n    balances[__address4__] = 130374026302104500000000000;\r\n    Transfer(address(0), __address4__, balanceOf(__address4__));\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__address2__\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"settleTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"confirmTransactionAfterExpiry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"disputeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_rating\",\"type\":\"uint8\"},{\"name\":\"_comment\",\"type\":\"bytes32\"}],\"name\":\"provideTransactionFeedback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__address0__\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"refundTransactionByMediator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"escalateDisputeToMediator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"revokeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__address4__\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"link\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_buyerAmount\",\"type\":\"uint256\"},{\"name\":\"_sellerAmount\",\"type\":\"uint256\"}],\"name\":\"settleTransactionByMediator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"acceptTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"refundTransactionAfterExpiry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_metadata\",\"type\":\"bytes32\"},{\"name\":\"_policy\",\"type\":\"address\"},{\"name\":\"_mediator\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"refundTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__address1__\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__address3__\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"confirmTransactionByMediator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_metadata\",\"type\":\"bytes32\"},{\"name\":\"_policy\",\"type\":\"address\"},{\"name\":\"_mediator\",\"type\":\"address\"}],\"name\":\"createTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"policy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"mediator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metadata\",\"type\":\"bytes32\"}],\"name\":\"TransactionInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TransactionAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TransactionDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TransactionEscalated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TransactionRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionRefundedByMediator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyerMediatorFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellerMediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionSettledByMediator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionConfirmedByMediator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionConfirmedAfterExpiry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionConfirmedAfterDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionRefundedAfterDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mediatorFee\",\"type\":\"uint256\"}],\"name\":\"TransactionRefundedAfterExpiry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TransactionConfirmedAfterEscalation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TransactionRefundedAfterEscalation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellerAmount\",\"type\":\"uint256\"}],\"name\":\"TransactionSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rating\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"bytes32\"}],\"name\":\"FeedbackUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"AccountLinked\",\"type\":\"event\"}]","ContractName":"InkProtocol","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d80d05cde61dcac67cef2bd7684cec9915f465aae4b1d6c28086339f85176af8"}]}