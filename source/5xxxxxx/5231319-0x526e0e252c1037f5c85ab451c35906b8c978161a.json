{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n\r\n/*\r\n * https://github.com/OpenZeppelin/zeppelin-solidity\r\n *\r\n * The MIT License (MIT)\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * https://github.com/OpenZeppelin/zeppelin-solidity\r\n *\r\n * The MIT License (MIT)\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Token interface compatible with ICO Crowdsale\r\n * @author Jakub Stefanski (https://github.com/jstefanski)\r\n * @author Wojciech Harzowski (https://github.com/harzo)\r\n * @author Dominik Kroliczek (https://github.com/kruligh)\r\n *\r\n * https://github.com/OnLivePlatform/onlive-contracts\r\n *\r\n * The BSD 3-Clause Clear License\r\n * Copyright (c) 2018 OnLive LTD\r\n */\r\ncontract IcoToken {\r\n    uint256 public decimals;\r\n\r\n    function transfer(address to, uint256 amount) public;\r\n    function mint(address to, uint256 amount) public;\r\n    function burn(uint256 amount) public;\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ICO Crowdsale with multiple price tiers and limited supply\r\n * @author Jakub Stefanski (https://github.com/jstefanski)\r\n * @author Wojciech Harzowski (https://github.com/harzo)\r\n * @author Dominik Kroliczek (https://github.com/kruligh)\r\n *\r\n * https://github.com/OnLivePlatform/onlive-contracts\r\n *\r\n * The BSD 3-Clause Clear License\r\n * Copyright (c) 2018 OnLive LTD\r\n */\r\ncontract IcoCrowdsale is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Structure representing price tier\r\n     */\r\n    struct Tier {\r\n        /**\r\n        * @dev The first block of the tier (inclusive)\r\n        */\r\n        uint256 startBlock;\r\n        /**\r\n        * @dev Price of token in Wei\r\n        */\r\n        uint256 price;\r\n    }\r\n\r\n    /**\r\n     * @dev Address of contribution wallet\r\n     */\r\n    address public wallet;\r\n\r\n    /**\r\n     * @dev Address of compatible token instance\r\n     */\r\n    IcoToken public token;\r\n\r\n    /**\r\n     * @dev Minimum ETH value sent as contribution\r\n     */\r\n    uint256 public minValue;\r\n\r\n    /**\r\n     * @dev Indicates whether contribution identified by bytes32 id is already registered\r\n     */\r\n    mapping (bytes32 => bool) public isContributionRegistered;\r\n\r\n    /**\r\n     * @dev Stores price tiers in chronological order\r\n     */\r\n    Tier[] private tiers;\r\n\r\n    /**\r\n    * @dev The last block of crowdsale (inclusive)\r\n    */\r\n    uint256 public endBlock;\r\n\r\n    modifier onlySufficientValue(uint256 value) {\r\n        require(value >= minValue);\r\n        _;\r\n    }\r\n\r\n    modifier onlyUniqueContribution(bytes32 id) {\r\n        require(!isContributionRegistered[id]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyActive() {\r\n        require(isActive());\r\n        _;\r\n    }\r\n\r\n    modifier onlyFinished() {\r\n        require(isFinished());\r\n        _;\r\n    }\r\n\r\n    modifier onlyScheduledTiers() {\r\n        require(tiers.length > 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotFinalized() {\r\n        require(!isFinalized());\r\n        _;\r\n    }\r\n\r\n    modifier onlySubsequentBlock(uint256 startBlock) {\r\n        if (tiers.length > 0) {\r\n            require(startBlock > tiers[tiers.length - 1].startBlock);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotZero(uint256 value) {\r\n        require(value != 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyValid(address addr) {\r\n        require(addr != address(0));\r\n        _;\r\n    }\r\n\r\n    function IcoCrowdsale(\r\n        address _wallet,\r\n        IcoToken _token,\r\n        uint256 _minValue\r\n    )\r\n        public\r\n        onlyValid(_wallet)\r\n        onlyValid(_token)\r\n    {\r\n        wallet = _wallet;\r\n        token = _token;\r\n        minValue = _minValue;\r\n    }\r\n\r\n    /**\r\n     * @dev Contribution is accepted\r\n     * @param contributor address The recipient of the tokens\r\n     * @param value uint256 The amount of contributed ETH\r\n     * @param amount uint256 The amount of tokens\r\n     */\r\n    event ContributionAccepted(address indexed contributor, uint256 value, uint256 amount);\r\n\r\n    /**\r\n     * @dev Off-chain contribution registered\r\n     * @param id bytes32 A unique contribution id\r\n     * @param contributor address The recipient of the tokens\r\n     * @param amount uint256 The amount of tokens\r\n     */\r\n    event ContributionRegistered(bytes32 indexed id, address indexed contributor, uint256 amount);\r\n\r\n    /**\r\n     * @dev Tier scheduled with given start block and price\r\n     * @param startBlock uint256 The first block of tier activation (inclusive)\r\n     * @param price uint256 The price active during tier\r\n     */\r\n    event TierScheduled(uint256 startBlock, uint256 price);\r\n\r\n    /**\r\n     * @dev Crowdsale end block scheduled\r\n     * @param availableAmount uint256 The amount of tokens available in crowdsale\r\n     * @param endBlock uint256 The last block of crowdsale (inclusive)\r\n     */\r\n    event Finalized(uint256 endBlock, uint256 availableAmount);\r\n\r\n    /**\r\n     * @dev Unsold tokens burned\r\n     */\r\n    event RemainsBurned(uint256 burnedAmount);\r\n\r\n    /**\r\n     * @dev Accept ETH transfers as contributions\r\n     */\r\n    function () public payable {\r\n        acceptContribution(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Contribute ETH in exchange for tokens\r\n     * @param contributor address The address that receives tokens\r\n     * @return uint256 Amount of received ONL tokens\r\n     */\r\n    function contribute(address contributor) public payable returns (uint256) {\r\n        return acceptContribution(contributor, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Register contribution with given id\r\n     * @param id bytes32 A unique contribution id\r\n     * @param contributor address The recipient of the tokens\r\n     * @param amount uint256 The amount of tokens\r\n     */\r\n    function registerContribution(bytes32 id, address contributor, uint256 amount)\r\n        public\r\n        onlyOwner\r\n        onlyActive\r\n        onlyValid(contributor)\r\n        onlyNotZero(amount)\r\n        onlyUniqueContribution(id)\r\n    {\r\n        isContributionRegistered[id] = true;\r\n\r\n        token.transfer(contributor, amount);\r\n\r\n        ContributionRegistered(id, contributor, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Schedule price tier\r\n     * @param _startBlock uint256 Block when the tier activates, inclusive\r\n     * @param _price uint256 The price of the tier\r\n     */\r\n    function scheduleTier(uint256 _startBlock, uint256 _price)\r\n        public\r\n        onlyOwner\r\n        onlyNotFinalized\r\n        onlySubsequentBlock(_startBlock)\r\n        onlyNotZero(_startBlock)\r\n        onlyNotZero(_price)\r\n    {\r\n        tiers.push(\r\n            Tier({\r\n                startBlock: _startBlock,\r\n                price: _price\r\n            })\r\n        );\r\n\r\n        TierScheduled(_startBlock, _price);\r\n    }\r\n\r\n    /**\r\n     * @dev Schedule crowdsale end\r\n     * @param _endBlock uint256 The last block end of crowdsale (inclusive)\r\n     * @param _availableAmount uint256 Amount of tokens available in crowdsale\r\n     */\r\n    function finalize(uint256 _endBlock, uint256 _availableAmount)\r\n        public\r\n        onlyOwner\r\n        onlyNotFinalized\r\n        onlyScheduledTiers\r\n        onlySubsequentBlock(_endBlock)\r\n        onlyNotZero(_availableAmount)\r\n    {\r\n        endBlock = _endBlock;\r\n\r\n        token.mint(this, _availableAmount);\r\n\r\n        Finalized(_endBlock, _availableAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns all tokens which have not been sold\r\n     */\r\n    function burnRemains()\r\n        public\r\n        onlyOwner\r\n        onlyFinished\r\n    {\r\n        uint256 amount = availableAmount();\r\n\r\n        token.burn(amount);\r\n\r\n        RemainsBurned(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate amount of ONL tokens received for given ETH value\r\n     * @param value uint256 Contribution value in wei\r\n     * @return uint256 Amount of received ONL tokens if contract active, otherwise 0\r\n     */\r\n    function calculateContribution(uint256 value) public view returns (uint256) {\r\n        uint256 price = currentPrice();\r\n        if (price > 0) {\r\n            return value.mul(10 ** token.decimals()).div(price);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Find closest tier id to given block\r\n     * @return uint256 Tier containing the block or zero if before start or last if after finished\r\n     */\r\n    function getTierId(uint256 blockNumber) public view returns (uint256) {\r\n        for (uint256 i = tiers.length - 1; i >= 0; i--) {\r\n            if (blockNumber >= tiers[i].startBlock) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Get price of the current tier\r\n     * @return uint256 Current price if tiers defined, otherwise 0\r\n     */\r\n    function currentPrice() public view returns (uint256) {\r\n        if (tiers.length > 0) {\r\n            uint256 id = getTierId(block.number);\r\n            return tiers[id].price;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Get current tier id\r\n     * @return uint256 Tier containing the block or zero if before start or last if after finished\r\n     */\r\n    function currentTierId() public view returns (uint256) {\r\n        return getTierId(block.number);\r\n    }\r\n\r\n    /**\r\n     * @dev Get available amount of tokens\r\n     * @return uint256 Amount of unsold tokens\r\n     */\r\n    function availableAmount() public view returns (uint256) {\r\n        return token.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n     * @dev Get specification of all tiers\r\n     */\r\n    function listTiers()\r\n        public\r\n        view\r\n        returns (uint256[] startBlocks, uint256[] endBlocks, uint256[] prices)\r\n    {\r\n        startBlocks = new uint256[](tiers.length);\r\n        endBlocks = new uint256[](tiers.length);\r\n        prices = new uint256[](tiers.length);\r\n\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            startBlocks[i] = tiers[i].startBlock;\r\n            prices[i] = tiers[i].price;\r\n\r\n            if (i + 1 < tiers.length) {\r\n                endBlocks[i] = tiers[i + 1].startBlock - 1;\r\n            } else {\r\n                endBlocks[i] = endBlock;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check whether crowdsale is currently active\r\n     * @return boolean True if current block number is within tier ranges, otherwise False\r\n     */\r\n    function isActive() public view returns (bool) {\r\n        return\r\n            tiers.length > 0 &&\r\n            block.number >= tiers[0].startBlock &&\r\n            block.number <= endBlock;\r\n    }\r\n\r\n    /**\r\n     * @dev Check whether sale end is scheduled\r\n     * @return boolean True if end block is defined, otherwise False\r\n     */\r\n    function isFinalized() public view returns (bool) {\r\n        return endBlock > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Check whether crowdsale has finished\r\n     * @return boolean True if end block passed, otherwise False\r\n     */\r\n    function isFinished() public view returns (bool) {\r\n        return endBlock > 0 && block.number > endBlock;\r\n    }\r\n\r\n    function acceptContribution(address contributor, uint256 value)\r\n        private\r\n        onlyActive\r\n        onlyValid(contributor)\r\n        onlySufficientValue(value)\r\n        returns (uint256)\r\n    {\r\n        uint256 amount = calculateContribution(value);\r\n        token.transfer(contributor, amount);\r\n\r\n        wallet.transfer(value);\r\n\r\n        ContributionAccepted(contributor, value, amount);\r\n\r\n        return amount;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"burnRemains\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTierId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getTierId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isContributionRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"scheduleTier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"contribute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listTiers\",\"outputs\":[{\"name\":\"startBlocks\",\"type\":\"uint256[]\"},{\"name\":\"endBlocks\",\"type\":\"uint256[]\"},{\"name\":\"prices\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_availableAmount\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calculateContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"registerContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_minValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContributionAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContributionRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"TierScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"availableAmount\",\"type\":\"uint256\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"burnedAmount\",\"type\":\"uint256\"}],\"name\":\"RemainsBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"IcoCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d0078f5c7e33bad8767c602d3aaee6e38481c9a10000000000000000000000006863be0e7cf7ce860a574760e9020d519a8bdc47000000000000000000000000000000000000000000000000016345785d8a0000","Library":"","SwarmSource":"bzzr://fd8f0217f45feb73023d02425655c5165de8eb038c3143181598b02989e2e96e"}]}