{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\nlibrary BWUtility {\r\n    \r\n    // -------- UTILITY FUNCTIONS ----------\r\n\r\n\r\n    // Return next higher even _multiple for _amount parameter (e.g used to round up to even finneys).\r\n    function ceil(uint _amount, uint _multiple) pure public returns (uint) {\r\n        return ((_amount + _multiple - 1) / _multiple) * _multiple;\r\n    }\r\n\r\n    // Checks if two coordinates are adjacent:\r\n    // xxx\r\n    // xox\r\n    // xxx\r\n    // All x (_x2, _xy2) are adjacent to o (_x1, _y1) in this ascii image. \r\n    // Adjacency does not wrapp around map edges so if y2 = 255 and y1 = 0 then they are not ajacent\r\n    function isAdjacent(uint8 _x1, uint8 _y1, uint8 _x2, uint8 _y2) pure public returns (bool) {\r\n        return ((_x1 == _x2 &&      (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Same column\r\n               ((_y1 == _y2 &&      (_x2 - _x1 == 1 || _x1 - _x2 == 1))) ||      // Same row\r\n               ((_x2 - _x1 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Right upper or lower diagonal\r\n               ((_x1 - _x2 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1)));        // Left upper or lower diagonal\r\n    }\r\n\r\n    // Converts (x, y) to tileId xy\r\n    function toTileId(uint8 _x, uint8 _y) pure public returns (uint16) {\r\n        return uint16(_x) << 8 | uint16(_y);\r\n    }\r\n\r\n    // Converts _tileId to (x, y)\r\n    function fromTileId(uint16 _tileId) pure public returns (uint8, uint8) {\r\n        uint8 y = uint8(_tileId);\r\n        uint8 x = uint8(_tileId >> 8);\r\n        return (x, y);\r\n    }\r\n    \r\n    function getBoostFromTile(address _claimer, address _attacker, address _defender, uint _blockValue) pure public returns (uint, uint) {\r\n        if (_claimer == _attacker) {\r\n            return (_blockValue, 0);\r\n        } else if (_claimer == _defender) {\r\n            return (0, _blockValue);\r\n        }\r\n    }\r\n}\r\n\r\ncontract BWData {\r\n    address public owner;\r\n    address private bwService;\r\n    address private bw;\r\n    address private bwMarket;\r\n\r\n    uint private blockValueBalance = 0;\r\n    uint private feeBalance = 0;\r\n    uint private BASE_TILE_PRICE_WEI = 1 finney; // 1 milli-ETH.\r\n    \r\n    mapping (address => User) private users; // user address -> user information\r\n    mapping (uint16 => Tile) private tiles; // tileId -> list of TileClaims for that particular tile\r\n    \r\n    // Info about the users = those who have purchased tiles.\r\n    struct User {\r\n        uint creationTime;\r\n        bool censored;\r\n        uint battleValue;\r\n    }\r\n\r\n    // Info about a tile ownership\r\n    struct Tile {\r\n        address claimer;\r\n        uint blockValue;\r\n        uint creationTime;\r\n        uint sellPrice;    // If 0 -> not on marketplace. If > 0 -> on marketplace.\r\n    }\r\n\r\n    struct Boost {\r\n        uint8 numAttackBoosts;\r\n        uint8 numDefendBoosts;\r\n        uint attackBoost;\r\n        uint defendBoost;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Can't send funds straight to this contract. Avoid people sending by mistake.\r\n    function () payable public {\r\n        revert();\r\n    }\r\n\r\n    function kill() public isOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    modifier isValidCaller {\r\n        if (msg.sender != bwService && msg.sender != bw && msg.sender != bwMarket) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier isOwner {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n    \r\n    function setBwServiceValidCaller(address _bwService) public isOwner {\r\n        bwService = _bwService;\r\n    }\r\n\r\n    function setBwValidCaller(address _bw) public isOwner {\r\n        bw = _bw;\r\n    }\r\n\r\n    function setBwMarketValidCaller(address _bwMarket) public isOwner {\r\n        bwMarket = _bwMarket;\r\n    }    \r\n    \r\n    // ----------USER-RELATED GETTER FUNCTIONS------------\r\n    \r\n    //function getUser(address _user) view public returns (bytes32) {\r\n        //BWUtility.User memory user = users[_user];\r\n        //require(user.creationTime != 0);\r\n        //return (user.creationTime, user.imageUrl, user.tag, user.email, user.homeUrl, user.creationTime, user.censored, user.battleValue);\r\n    //}\r\n    \r\n    function addUser(address _msgSender) public isValidCaller {\r\n        User storage user = users[_msgSender];\r\n        require(user.creationTime == 0);\r\n        user.creationTime = block.timestamp;\r\n    }\r\n\r\n    function hasUser(address _user) view public isValidCaller returns (bool) {\r\n        return users[_user].creationTime != 0;\r\n    }\r\n    \r\n\r\n    // ----------TILE-RELATED GETTER FUNCTIONS------------\r\n\r\n    function getTile(uint16 _tileId) view public isValidCaller returns (address, uint, uint, uint) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        return (currentTile.claimer, currentTile.blockValue, currentTile.creationTime, currentTile.sellPrice);\r\n    }\r\n    \r\n    function getTileClaimerAndBlockValue(uint16 _tileId) view public isValidCaller returns (address, uint) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        return (currentTile.claimer, currentTile.blockValue);\r\n    }\r\n    \r\n    function isNewTile(uint16 _tileId) view public isValidCaller returns (bool) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        return currentTile.creationTime == 0;\r\n    }\r\n    \r\n    function storeClaim(uint16 _tileId, address _claimer, uint _blockValue) public isValidCaller {\r\n        tiles[_tileId] = Tile(_claimer, _blockValue, block.timestamp, 0);\r\n    }\r\n\r\n    function updateTileBlockValue(uint16 _tileId, uint _blockValue) public isValidCaller {\r\n        tiles[_tileId].blockValue = _blockValue;\r\n    }\r\n\r\n    function setClaimerForTile(uint16 _tileId, address _claimer) public isValidCaller {\r\n        tiles[_tileId].claimer = _claimer;\r\n    }\r\n\r\n    function updateTileTimeStamp(uint16 _tileId) public isValidCaller {\r\n        tiles[_tileId].creationTime = block.timestamp;\r\n    }\r\n    \r\n    function getCurrentClaimerForTile(uint16 _tileId) view public isValidCaller returns (address) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        if (currentTile.creationTime == 0) {\r\n            return 0;\r\n        }\r\n        return currentTile.claimer;\r\n    }\r\n\r\n    function getCurrentBlockValueAndSellPriceForTile(uint16 _tileId) view public isValidCaller returns (uint, uint) {\r\n        Tile storage currentTile = tiles[_tileId];\r\n        if (currentTile.creationTime == 0) {\r\n            return (0, 0);\r\n        }\r\n        return (currentTile.blockValue, currentTile.sellPrice);\r\n    }\r\n    \r\n    function getBlockValueBalance() view public isValidCaller returns (uint){\r\n        return blockValueBalance;\r\n    }\r\n\r\n    function setBlockValueBalance(uint _blockValueBalance) public isValidCaller {\r\n        blockValueBalance = _blockValueBalance;\r\n    }\r\n\r\n    function getFeeBalance() view public isValidCaller returns (uint) {\r\n        return feeBalance;\r\n    }\r\n\r\n    function setFeeBalance(uint _feeBalance) public isValidCaller {\r\n        feeBalance = _feeBalance;\r\n    }\r\n    \r\n    function getUserBattleValue(address _userId) view public isValidCaller returns (uint) {\r\n        return users[_userId].battleValue;\r\n    }\r\n    \r\n    function setUserBattleValue(address _userId, uint _battleValue) public  isValidCaller {\r\n        users[_userId].battleValue = _battleValue;\r\n    }\r\n    \r\n    function verifyAmount(address _msgSender, uint _msgValue, uint _amount, bool _useBattleValue) view public isValidCaller {\r\n        User storage user = users[_msgSender];\r\n        require(user.creationTime != 0);\r\n\r\n        if (_useBattleValue) {\r\n            require(_msgValue == 0);\r\n            require(user.battleValue >= _amount);\r\n        } else {\r\n            require(_amount == _msgValue);\r\n        }\r\n    }\r\n    \r\n    function addBoostFromTile(Tile _tile, address _attacker, address _defender, Boost memory _boost) pure private {\r\n        if (_tile.claimer == _attacker) {\r\n            require(_boost.attackBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\r\n            _boost.attackBoost += _tile.blockValue;\r\n            _boost.numAttackBoosts += 1;\r\n        } else if (_tile.claimer == _defender) {\r\n            require(_boost.defendBoost + _tile.blockValue >= _tile.blockValue); // prevent overflow\r\n            _boost.defendBoost += _tile.blockValue;\r\n            _boost.numDefendBoosts += 1;\r\n        }\r\n    }\r\n\r\n    function calculateBattleBoost(uint16 _tileId, address _attacker, address _defender) view public isValidCaller returns (uint, uint) {\r\n        uint8 x;\r\n        uint8 y;\r\n\r\n        (x, y) = BWUtility.fromTileId(_tileId);\r\n\r\n        Boost memory boost = Boost(0, 0, 0, 0);\r\n        // We overflow x, y on purpose here if x or y is 0 or 255 - the map overflows and so should adjacency.\r\n        // Go through all adjacent tiles to (x, y).\r\n        if (y != 255) {\r\n            if (x != 255) {\r\n                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y+1)], _attacker, _defender, boost);\r\n            }\r\n            \r\n            addBoostFromTile(tiles[BWUtility.toTileId(x, y+1)], _attacker, _defender, boost);\r\n\r\n            if (x != 0) {\r\n                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y+1)], _attacker, _defender, boost);\r\n            }\r\n        }\r\n\r\n        if (x != 255) {\r\n            addBoostFromTile(tiles[BWUtility.toTileId(x+1, y)], _attacker, _defender, boost);\r\n        }\r\n\r\n        if (x != 0) {\r\n            addBoostFromTile(tiles[BWUtility.toTileId(x-1, y)], _attacker, _defender, boost);\r\n        }\r\n\r\n        if (y != 0) {\r\n            if(x != 255) {\r\n                addBoostFromTile(tiles[BWUtility.toTileId(x+1, y-1)], _attacker, _defender, boost);\r\n            }\r\n\r\n            addBoostFromTile(tiles[BWUtility.toTileId(x, y-1)], _attacker, _defender, boost);\r\n\r\n            if(x != 0) {\r\n                addBoostFromTile(tiles[BWUtility.toTileId(x-1, y-1)], _attacker, _defender, boost);\r\n            }\r\n        }\r\n        // The benefit of boosts is multiplicative (quadratic):\r\n        // - More boost tiles gives a higher total blockValue (the sum of the adjacent tiles)\r\n        // - More boost tiles give a higher multiple of that total blockValue that can be used (10% per adjacent tie)\r\n        // Example:\r\n        //   A) I boost attack with 1 single tile worth 10 finney\r\n        //      -> Total boost is 10 * 1 / 10 = 1 finney\r\n        //   B) I boost attack with 3 tiles worth 1 finney each\r\n        //      -> Total boost is (1+1+1) * 3 / 10 = 0.9 finney\r\n        //   C) I boost attack with 8 tiles worth 2 finney each\r\n        //      -> Total boost is (2+2+2+2+2+2+2+2) * 8 / 10 = 14.4 finney\r\n        //   D) I boost attack with 3 tiles of 1, 5 and 10 finney respectively\r\n        //      -> Total boost is (ss1+5+10) * 3 / 10 = 4.8 finney\r\n        // This division by 10 can't create fractions since our uint is wei, and we can't have overflow from the multiplication\r\n        // We do allow fractions of finney here since the boosted values aren't stored anywhere, only used for attack rolls and sent in events\r\n        boost.attackBoost = (boost.attackBoost / 10 * boost.numAttackBoosts);\r\n        boost.defendBoost = (boost.defendBoost / 10 * boost.numDefendBoosts);\r\n\r\n        return (boost.attackBoost, boost.defendBoost);\r\n    }\r\n    \r\n    function censorUser(address _userAddress, bool _censored) public isValidCaller {\r\n        User storage user = users[_userAddress];\r\n        require(user.creationTime != 0);\r\n        user.censored = _censored;\r\n    }\r\n    \r\n    function deleteTile(uint16 _tileId) public isValidCaller {\r\n        delete tiles[_tileId];\r\n    }\r\n    \r\n    function setSellPrice(uint16 _tileId, uint _sellPrice) public isValidCaller {\r\n        tiles[_tileId].sellPrice = _sellPrice;  //testrpc cannot estimate gas when delete is used.\r\n    }\r\n\r\n    function deleteOffer(uint16 _tileId) public isValidCaller {\r\n        tiles[_tileId].sellPrice = 0;  //testrpc cannot estimate gas when delete is used.\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"},{\"name\":\"_sellPrice\",\"type\":\"uint256\"}],\"name\":\"setSellPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"},{\"name\":\"_claimer\",\"type\":\"address\"},{\"name\":\"_blockValue\",\"type\":\"uint256\"}],\"name\":\"storeClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"},{\"name\":\"_claimer\",\"type\":\"address\"}],\"name\":\"setClaimerForTile\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"},{\"name\":\"_msgValue\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_useBattleValue\",\"type\":\"bool\"}],\"name\":\"verifyAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_msgSender\",\"type\":\"address\"}],\"name\":\"addUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bwService\",\"type\":\"address\"}],\"name\":\"setBwServiceValidCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"getTileClaimerAndBlockValue\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bw\",\"type\":\"address\"}],\"name\":\"setBwValidCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockValueBalance\",\"type\":\"uint256\"}],\"name\":\"setBlockValueBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userId\",\"type\":\"address\"}],\"name\":\"getUserBattleValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeBalance\",\"type\":\"uint256\"}],\"name\":\"setFeeBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userId\",\"type\":\"address\"},{\"name\":\"_battleValue\",\"type\":\"uint256\"}],\"name\":\"setUserBattleValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"},{\"name\":\"_blockValue\",\"type\":\"uint256\"}],\"name\":\"updateTileBlockValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"isNewTile\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"hasUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"getCurrentClaimerForTile\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"getCurrentBlockValueAndSellPriceForTile\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"getTile\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockValueBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"deleteOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"},{\"name\":\"_censored\",\"type\":\"bool\"}],\"name\":\"censorUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"},{\"name\":\"_attacker\",\"type\":\"address\"},{\"name\":\"_defender\",\"type\":\"address\"}],\"name\":\"calculateBattleBoost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"updateTileTimeStamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bwMarket\",\"type\":\"address\"}],\"name\":\"setBwMarketValidCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tileId\",\"type\":\"uint16\"}],\"name\":\"deleteTile\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"BWData","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"BWUtility:402cc14a55f355883df5549c0434877a68b7d089","SwarmSource":"bzzr://46b05a80a553cc1801cdae045a75b1c8c1db67b33f46e6fbac7e0dd9963daf25"}]}