{"status":"1","message":"OK","result":[{"SourceCode":"// From OpenZepplin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Shareable.sol\r\n/*\r\n * Shareable\r\n * \r\n * Effectively our multisig contract\r\n *\r\n * Based on https://github.com/ethereum/dapp-bin/blob/master/wallet/wallet.sol\r\n *\r\n * inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a single, or, crucially, each of a number of, designated owners.\r\n *\r\n * usage:\r\n * use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by some number (specified in constructor) of the set of owners (specified in the constructor) before the interior is executed.\r\n */\r\ncontract Shareable {\r\n  // TYPES\r\n\r\n  // struct for the status of a pending operation.\r\n  struct PendingState {\r\n    uint yetNeeded;\r\n    uint ownersDone;\r\n    uint index;\r\n  }\r\n\r\n\r\n  // FIELDS\r\n\r\n  // the number of owners that must confirm the same operation before it is run.\r\n  uint public required;\r\n\r\n  // list of owners\r\n  address[256] owners;\r\n  uint constant c_maxOwners = 250;\r\n  // index on the list of owners to allow reverse lookup\r\n  mapping(address => uint) ownerIndex;\r\n  // the ongoing operations.\r\n  mapping(bytes32 => PendingState) pendings;\r\n  bytes32[] pendingsIndex;\r\n\r\n\r\n  // EVENTS\r\n\r\n  // this contract only has six types of events: it can accept a confirmation, in which case\r\n  // we record owner and operation (hash) alongside it.\r\n  event Confirmation(address owner, bytes32 operation);\r\n  event Revoke(address owner, bytes32 operation);\r\n\r\n\r\n  // MODIFIERS\r\n\r\n  address thisContract = this;\r\n\r\n  // simple single-sig function modifier.\r\n  modifier onlyOwner {\r\n    if (isOwner(msg.sender))\r\n      _;\r\n  }\r\n\r\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\r\n  // that later attempts can be realised as the same underlying operation and\r\n  // thus count as confirmations.\r\n  modifier onlyManyOwners(bytes32 _operation) {\r\n    if (confirmAndCheck(_operation))\r\n      _;\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n  // as well as the selection of addresses capable of confirming them.\r\n  function Shareable(address[] _owners, uint _required) {\r\n    owners[1] = msg.sender;\r\n    ownerIndex[msg.sender] = 1;\r\n    for (uint i = 0; i < _owners.length; ++i) {\r\n      owners[2 + i] = _owners[i];\r\n      ownerIndex[_owners[i]] = 2 + i;\r\n    }\r\n    if (required > owners.length) throw;\r\n    required = _required;\r\n  }\r\n\r\n\r\n  // new multisig is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n  // as well as the selection of addresses capable of confirming them.\r\n  // take all new owners as an array\r\n  function changeShareable(address[] _owners, uint _required) onlyManyOwners(sha3(msg.data)) {\r\n    for (uint i = 0; i < _owners.length; ++i) {\r\n      owners[1 + i] = _owners[i];\r\n      ownerIndex[_owners[i]] = 1 + i;\r\n    }\r\n    if (required > owners.length) throw;\r\n    required = _required;\r\n  }\r\n\r\n  // METHODS\r\n\r\n  // Revokes a prior confirmation of the given operation\r\n  function revoke(bytes32 _operation) external {\r\n    uint index = ownerIndex[msg.sender];\r\n    // make sure they're an owner\r\n    if (index == 0) return;\r\n    uint ownerIndexBit = 2**index;\r\n    var pending = pendings[_operation];\r\n    if (pending.ownersDone & ownerIndexBit > 0) {\r\n      pending.yetNeeded++;\r\n      pending.ownersDone -= ownerIndexBit;\r\n      Revoke(msg.sender, _operation);\r\n    }\r\n  }\r\n\r\n  // Gets an owner by 0-indexed position (using numOwners as the count)\r\n  function getOwner(uint ownerIndex) external constant returns (address) {\r\n    return address(owners[ownerIndex + 1]);\r\n  }\r\n\r\n  function isOwner(address _addr) constant returns (bool) {\r\n    return ownerIndex[_addr] > 0;\r\n  }\r\n\r\n  function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n    var pending = pendings[_operation];\r\n    uint index = ownerIndex[_owner];\r\n\r\n    // make sure they're an owner\r\n    if (index == 0) return false;\r\n\r\n    // determine the bit to set for this owner.\r\n    uint ownerIndexBit = 2**index;\r\n    return !(pending.ownersDone & ownerIndexBit == 0);\r\n  }\r\n\r\n  // INTERNAL METHODS\r\n\r\n  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n    // determine what index the present sender is:\r\n    uint index = ownerIndex[msg.sender];\r\n    // make sure they're an owner\r\n    if (index == 0) return;\r\n\r\n    var pending = pendings[_operation];\r\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\r\n    if (pending.yetNeeded == 0) {\r\n      // reset count of confirmations needed.\r\n      pending.yetNeeded = required;\r\n      // reset which owners have confirmed (none) - set our bitmap to 0.\r\n      pending.ownersDone = 0;\r\n      pending.index = pendingsIndex.length++;\r\n      pendingsIndex[pending.index] = _operation;\r\n    }\r\n    // determine the bit to set for this owner.\r\n    uint ownerIndexBit = 2**index;\r\n    // make sure we (the message sender) haven't confirmed this operation previously.\r\n    if (pending.ownersDone & ownerIndexBit == 0) {\r\n      Confirmation(msg.sender, _operation);\r\n      // ok - check if count is enough to go ahead.\r\n      if (pending.yetNeeded <= 1) {\r\n        // enough confirmations: reset and run interior.\r\n        delete pendingsIndex[pendings[_operation].index];\r\n        delete pendings[_operation];\r\n        return true;\r\n      }\r\n      else\r\n        {\r\n          // not enough: record that this owner in particular confirmed.\r\n          pending.yetNeeded--;\r\n          pending.ownersDone |= ownerIndexBit;\r\n        }\r\n    }\r\n  }\r\n\r\n  function clearPending() internal {\r\n    uint length = pendingsIndex.length;\r\n    for (uint i = 0; i < length; ++i)\r\n    if (pendingsIndex[i] != 0)\r\n      delete pendings[pendingsIndex[i]];\r\n    delete pendingsIndex;\r\n  }\r\n}\r\n\r\n// From OpenZepplin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/lifecycle/Pausable.sol\r\n/*\r\n * Stoppable\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism.\r\n */\r\ncontract StoppableShareable is Shareable {\r\n  bool public stopped;\r\n  bool public stoppable = true;\r\n\r\n  modifier stopInEmergency { if (!stopped) _; }\r\n  modifier onlyInEmergency { if (stopped) _; }\r\n\r\n  function StoppableShareable(address[] _owners, uint _required) Shareable(_owners, _required) {\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function emergencyStop() external onlyOwner {\r\n    assert(stoppable);\r\n    stopped = true;\r\n  }\r\n\r\n  // called by the owners on end of emergency, returns to normal state\r\n  function release() external onlyManyOwners(sha3(msg.data)) {\r\n    assert(stoppable);\r\n    stopped = false;\r\n  }\r\n\r\n  // called by the owners to disable ability to begin or end an emergency stop\r\n  function disableStopping() external onlyManyOwners(sha3(msg.data)) {\r\n    stoppable = false;\r\n  }\r\n}\r\n\r\ncontract Safe {\r\n    // Check if it is safe to add two numbers\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n\r\n    // Check if it is safe to subtract two numbers\r\n    function safeSubtract(uint a, uint b) internal returns (uint) {\r\n        uint c = a - b;\r\n        assert(b <= a && c <= a);\r\n        return c;\r\n    }\r\n\r\n    function safeMultiply(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || (c / a) == b);\r\n        return c;\r\n    }\r\n\r\n    function shrink128(uint a) internal returns (uint128) {\r\n        assert(a < 0x100000000000000000000000000000000);\r\n        return uint128(a);\r\n    }\r\n\r\n    // mitigate short address attack\r\n    modifier onlyPayloadSize(uint numWords) {\r\n        assert(msg.data.length == numWords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n    // allow ether to be received\r\n    function () payable { }\r\n\r\n}\r\n\r\n// Class variables used both in NumeraireBackend and NumeraireDelegate\r\n\r\ncontract NumeraireShared is Safe {\r\n\r\n    address public numerai = this;\r\n\r\n    // Cap the total supply and the weekly supply\r\n    uint256 public supply_cap = 21000000e18; // 21 million\r\n    uint256 public weekly_disbursement = 96153846153846153846153;\r\n\r\n    uint256 public initial_disbursement;\r\n    uint256 public deploy_time;\r\n\r\n    uint256 public total_minted;\r\n\r\n    // ERC20 requires totalSupply, balanceOf, and allowance\r\n    uint256 public totalSupply;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    mapping (uint => Tournament) public tournaments;  // tournamentID\r\n\r\n    struct Tournament {\r\n        uint256 creationTime;\r\n        uint256[] roundIDs;\r\n        mapping (uint256 => Round) rounds;  // roundID\r\n    } \r\n\r\n    struct Round {\r\n        uint256 creationTime;\r\n        uint256 endTime;\r\n        uint256 resolutionTime;\r\n        mapping (address => mapping (bytes32 => Stake)) stakes;  // address of staker\r\n    }\r\n\r\n    // The order is important here because of its packing characteristics.\r\n    // Particularly, `amount` and `confidence` are in the *same* word, so\r\n    // Solidity can update both at the same time (if the optimizer can figure\r\n    // out that you're updating both).  This makes `stake()` cheap.\r\n    struct Stake {\r\n        uint128 amount; // Once the stake is resolved, this becomes 0\r\n        uint128 confidence;\r\n        bool successful;\r\n        bool resolved;\r\n    }\r\n\r\n    // Generates a public event on the blockchain to notify clients\r\n    event Mint(uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Staked(address indexed staker, bytes32 tag, uint256 totalAmountStaked, uint256 confidence, uint256 indexed tournamentID, uint256 indexed roundID);\r\n    event RoundCreated(uint256 indexed tournamentID, uint256 indexed roundID, uint256 endTime, uint256 resolutionTime);\r\n    event TournamentCreated(uint256 indexed tournamentID);\r\n    event StakeDestroyed(uint256 indexed tournamentID, uint256 indexed roundID, address indexed stakerAddress, bytes32 tag);\r\n    event StakeReleased(uint256 indexed tournamentID, uint256 indexed roundID, address indexed stakerAddress, bytes32 tag, uint256 etherReward);\r\n\r\n    // Calculate allowable disbursement\r\n    function getMintable() constant returns (uint256) {\r\n        return\r\n            safeSubtract(\r\n                safeAdd(initial_disbursement,\r\n                    safeMultiply(weekly_disbursement,\r\n                        safeSubtract(block.timestamp, deploy_time))\r\n                    / 1 weeks),\r\n                total_minted);\r\n    }\r\n}\r\n\r\n// Whoever creates the contract has the power to stop it, this person can be changed via transferOwnership(_new_address)\r\ncontract NumeraireDelegate is StoppableShareable, NumeraireShared {\r\n\r\n    function NumeraireDelegate(address[] _owners, uint256 _num_required) StoppableShareable(_owners, _num_required) {\r\n    }\r\n\r\n    // All minted NMR are initially sent to Numerai, obeying both weekly and total supply caps\r\n    function mint(uint256 _value) onlyOwner returns (bool ok) {\r\n        // Prevent minting more than the supply cap.\r\n        require(safeAdd(total_minted, _value) <= supply_cap);\r\n\r\n        // Prevent minting more than the disbursement.\r\n        require(_value <= getMintable());\r\n\r\n        balanceOf[numerai] = safeAdd(balanceOf[numerai], _value);\r\n        totalSupply = safeAdd(totalSupply, _value);\r\n        total_minted = safeAdd(total_minted, _value);\r\n\r\n        // Notify anyone listening.\r\n        Mint(_value);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Numerai calls this function to release staked tokens when the staked predictions were successful\r\n    function releaseStake(address _staker, bytes32 _tag, uint256 _etherValue, uint256 _tournamentID, uint256 _roundID, bool _successful) onlyOwner stopInEmergency returns (bool ok) {\r\n        var round = tournaments[_tournamentID].rounds[_roundID];\r\n        var stake = round.stakes[_staker][_tag];\r\n        var originalStakeAmount = stake.amount;\r\n\r\n        require(stake.amount > 0);\r\n        require(!stake.resolved);\r\n        require(round.resolutionTime <= block.timestamp);\r\n\r\n        stake.amount = 0;\r\n        balanceOf[_staker] = safeAdd(balanceOf[_staker], originalStakeAmount);\r\n        stake.resolved = true;\r\n        stake.successful = _successful;\r\n\r\n        if (_etherValue > 0) {\r\n            if (!_staker.send(_etherValue)) {\r\n                stake.amount = originalStakeAmount;\r\n                balanceOf[_staker] -= originalStakeAmount; // safe because we just added it\r\n                stake.resolved = false;\r\n                stake.successful = false;\r\n                return false;\r\n            }\r\n        }\r\n\r\n        StakeReleased(_tournamentID, _roundID, _staker, _tag, _etherValue);\r\n        return true;\r\n    }\r\n\r\n    // Destroy staked tokens if the predictions were not successful\r\n    function destroyStake(address _staker, bytes32 _tag, uint256 _tournamentID, uint256 _roundID) onlyOwner stopInEmergency returns (bool ok) {\r\n        var round = tournaments[_tournamentID].rounds[_roundID];\r\n        var stake = round.stakes[_staker][_tag];\r\n        var originalStakeAmount = stake.amount;\r\n\r\n        require(stake.amount > 0);\r\n        require(!stake.resolved);\r\n        require(round.resolutionTime <= block.timestamp);\r\n\r\n        stake.amount = 0;\r\n        totalSupply = safeSubtract(totalSupply, originalStakeAmount);\r\n        stake.resolved = true;\r\n        stake.successful = false;\r\n\r\n        StakeDestroyed(_tournamentID, _roundID, _staker, _tag);\r\n        return true;\r\n    }\r\n\r\n    // Anyone but Numerai can stake on themselves\r\n    function stake(uint256 _value, bytes32 _tag, uint256 _tournamentID, uint256 _roundID, uint256 _confidence) stopInEmergency returns (bool ok) {\r\n        return _stake(msg.sender, _value, _tag, _tournamentID, _roundID, _confidence);\r\n    }\r\n\r\n    // Only Numerai can stake on behalf of other accounts. _stake_owner will always be Numerai's hot wallet\r\n    function stakeOnBehalf(address _staker, uint256 _value, bytes32 _tag, uint256 _tournamentID, uint256 _roundID, uint256 _confidence) onlyOwner stopInEmergency returns (bool ok) {\r\n        var max_deposit_address = 1000000;\r\n        require(_staker <= max_deposit_address);\r\n        return _stake(_staker, _value, _tag, _tournamentID, _roundID, _confidence);\r\n    }\r\n\r\n    function _stake(address _staker, uint256 _value, bytes32 _tag, uint256 _tournamentID, uint256 _roundID, uint256 _confidence) stopInEmergency internal returns (bool ok) {\r\n        var tournament = tournaments[_tournamentID];\r\n        var round = tournament.rounds[_roundID];\r\n        var stake = round.stakes[_staker][_tag];\r\n\r\n        require(!isOwner(_staker) && _staker != numerai); // Numerai cannot stake on itself\r\n        require(balanceOf[_staker] >= _value); // Check for sufficient funds\r\n        require(tournament.creationTime > 0); // This tournament must be initialized\r\n        require(round.creationTime > 0); // This round must be initialized\r\n        require(round.endTime > block.timestamp); // Can't stake after round ends\r\n        require(_value > 0 || stake.amount > 0); // Can't stake zero NMR\r\n\r\n        require(stake.confidence == 0 || stake.confidence <= _confidence);\r\n\r\n        // Keep these two lines together so that the Solidity optimizer can\r\n        // merge them into a single SSTORE.\r\n        stake.amount = shrink128(safeAdd(stake.amount, _value));\r\n        stake.confidence = shrink128(_confidence);\r\n\r\n        balanceOf[_staker] = safeSubtract(balanceOf[_staker], _value);\r\n\r\n        // Notify anyone listening.\r\n        Staked(_staker, _tag, stake.amount, stake.confidence, _tournamentID, _roundID);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Transfer NMR from Numerai account using multisig\r\n    function numeraiTransfer(address _to, uint256 _value) onlyManyOwners(sha3(msg.data)) returns (bool ok) {\r\n        // If _value is a special number, clear the _to address from owner index\r\n        // We need this because changeShareable does not clear previous owners correctly\r\n        if (_value == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\r\n          if(address(owners[ownerIndex[_to]]) != _to) {\r\n            ownerIndex[_to] = 0;\r\n          }\r\n          return true;\r\n        }\r\n\r\n        // Check for sufficient funds.\r\n        require(balanceOf[numerai] >= _value);\r\n\r\n        balanceOf[numerai] = safeSubtract(balanceOf[numerai], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n\r\n        // Notify anyone listening.\r\n        Transfer(numerai, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Allows Numerai to withdraw on behalf of a data scientist some NMR that they've deposited into a pre-assigned address\r\n    // Numerai will assign these addresses on its website\r\n    function withdraw(address _from, address _to, uint256 _value) onlyOwner returns(bool ok) {\r\n        address max_deposit_address = 1000000;\r\n        require(_from <= max_deposit_address);\r\n\r\n        // Identical to transfer(), except msg.sender => _from\r\n        require(balanceOf[_from] >= _value);\r\n\r\n        balanceOf[_from] = safeSubtract(balanceOf[_from], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function createTournament(uint256 _tournamentID) onlyOwner returns (bool ok) {\r\n        var tournament = tournaments[_tournamentID];\r\n        require(tournament.creationTime == 0); // Already created\r\n        tournament.creationTime = block.timestamp;\r\n        TournamentCreated(_tournamentID);\r\n        return true;\r\n    }\r\n\r\n    function createRound(uint256 _tournamentID, uint256 _roundID, uint256 _endTime, uint256 _resolutionTime) onlyOwner returns (bool ok) {\r\n        var tournament = tournaments[_tournamentID];\r\n        var round = tournament.rounds[_roundID];\r\n        require(_endTime <= _resolutionTime);\r\n        require(tournament.creationTime > 0);\r\n        require(round.creationTime == 0);\r\n        tournament.roundIDs.push(_roundID);\r\n        round.creationTime = block.timestamp;\r\n        round.endTime = _endTime;\r\n        round.resolutionTime = _resolutionTime;\r\n        RoundCreated(_tournamentID, _roundID, round.endTime, round.resolutionTime);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numerai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tournamentID\",\"type\":\"uint256\"},{\"name\":\"_roundID\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_resolutionTime\",\"type\":\"uint256\"}],\"name\":\"createRound\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"},{\"name\":\"_tag\",\"type\":\"bytes32\"},{\"name\":\"_etherValue\",\"type\":\"uint256\"},{\"name\":\"_tournamentID\",\"type\":\"uint256\"},{\"name\":\"_roundID\",\"type\":\"uint256\"},{\"name\":\"_successful\",\"type\":\"bool\"}],\"name\":\"releaseStake\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_tag\",\"type\":\"bytes32\"},{\"name\":\"_tournamentID\",\"type\":\"uint256\"},{\"name\":\"_roundID\",\"type\":\"uint256\"},{\"name\":\"_confidence\",\"type\":\"uint256\"}],\"name\":\"stakeOnBehalf\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tournaments\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeShareable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"numeraiTransfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initial_disbursement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_tag\",\"type\":\"bytes32\"},{\"name\":\"_tournamentID\",\"type\":\"uint256\"},{\"name\":\"_roundID\",\"type\":\"uint256\"},{\"name\":\"_confidence\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weekly_disbursement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"},{\"name\":\"_tag\",\"type\":\"bytes32\"},{\"name\":\"_tournamentID\",\"type\":\"uint256\"},{\"name\":\"_roundID\",\"type\":\"uint256\"}],\"name\":\"destroyStake\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deploy_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stoppable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_minted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operation\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ownerIndex\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableStopping\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tournamentID\",\"type\":\"uint256\"}],\"name\":\"createTournament\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply_cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMintable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_num_required\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tag\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"totalAmountStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"confidence\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"resolutionTime\",\"type\":\"uint256\"}],\"name\":\"RoundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"}],\"name\":\"TournamentCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tag\",\"type\":\"bytes32\"}],\"name\":\"StakeDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tag\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"etherReward\",\"type\":\"uint256\"}],\"name\":\"StakeReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"Revoke\",\"type\":\"event\"}]","ContractName":"NumeraireDelegate","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004000000000000000000000000dc6997b078c709327649443d0765bcaa8e37aa6c00000000000000000000000070153f8f89f6869037fba270233409844f1f2e2e000000000000000000000000ae0338fefd533129694345659da36c4fe144e350000000000000000000000000444ab8ad5c74f82fada4765f4a4e595109903f11","Library":"","SwarmSource":"bzzr://66574048a4177433f0a27b3363faca03af8064e2af8131ee4342ad4c307b3841"}]}