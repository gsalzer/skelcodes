{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ninterface ConflictResolutionInterface {\r\n    function minHouseStake(uint activeGames) public pure returns(uint);\r\n\r\n    function maxBalance() public pure returns(int);\r\n\r\n    function isValidBet(uint8 _gameType, uint _betNum, uint _betValue) public pure returns(bool);\r\n\r\n    function endGameConflict(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        bytes32 _serverSeed,\r\n        bytes32 _playerSeed\r\n    )\r\n        public\r\n        view\r\n        returns(int);\r\n\r\n    function serverForceGameEnd(\r\n        uint8 gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        public\r\n        view\r\n        returns(int);\r\n\r\n    function playerForceGameEnd(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        public\r\n        view\r\n        returns(int);\r\n}\r\n\r\ncontract ConflictResolution is ConflictResolutionInterface {\r\n    uint public constant DICE_RANGE = 100;\r\n    uint public constant HOUSE_EDGE = 150;\r\n    uint public constant HOUSE_EDGE_DIVISOR = 10000;\r\n\r\n    uint public constant SERVER_TIMEOUT = 2 days;\r\n    uint public constant PLAYER_TIMEOUT = 1 days;\r\n\r\n    uint8 public constant GAME_TYPE_DICE = 1;\r\n    uint public constant MAX_BET_VALUE = 1e16; /// max 0.01 ether bet\r\n    uint public constant MIN_BET_VALUE = 1e13; /// min 0.00001 ether bet\r\n\r\n    int public constant NOT_ENDED_FINE = 1e15; /// 0.001 ether\r\n\r\n    int public constant MAX_BALANCE = int(MAX_BET_VALUE) * 100 * 5;\r\n\r\n    modifier onlyValidBet(uint8 _gameType, uint _betNum, uint _betValue) {\r\n        require(isValidBet(_gameType, _betNum, _betValue));\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidBalance(int _balance, uint _gameStake) {\r\n        // safe to cast gameStake as range is fixed\r\n        require(-int(_gameStake) <= _balance && _balance < MAX_BALANCE);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if bet is valid.\r\n     * @param _gameType Game type.\r\n     * @param _betNum Number of bet.\r\n     * @param _betValue Value of bet.\r\n     * @return True if bet is valid false otherwise.\r\n     */\r\n    function isValidBet(uint8 _gameType, uint _betNum, uint _betValue) public pure returns(bool) {\r\n        return (\r\n            (_gameType == GAME_TYPE_DICE) &&\r\n            (_betNum > 0 && _betNum < DICE_RANGE) &&\r\n            (MIN_BET_VALUE <= _betValue && _betValue <= MAX_BET_VALUE)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @return Max balance.\r\n     */\r\n    function maxBalance() public pure returns(int) {\r\n        return MAX_BALANCE;\r\n    }\r\n\r\n    /**\r\n     * Calculate minimum needed house stake.\r\n     */\r\n    function minHouseStake(uint activeGames) public pure returns(uint) {\r\n        return  MathUtil.min(activeGames, 1) * MAX_BET_VALUE * 400;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates game result and returns new balance.\r\n     * @param _gameType Type of game.\r\n     * @param _betNum Bet number.\r\n     * @param _betValue Value of bet.\r\n     * @param _balance Current balance.\r\n     * @param _serverSeed Server's seed of current round.\r\n     * @param _playerSeed Player's seed of current round.\r\n     * @return New game session balance.\r\n     */\r\n    function endGameConflict(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        bytes32 _serverSeed,\r\n        bytes32 _playerSeed\r\n    )\r\n        public\r\n        view\r\n        onlyValidBet(_gameType, _betNum, _betValue)\r\n        onlyValidBalance(_balance, _stake)\r\n        returns(int)\r\n    {\r\n        assert(_serverSeed != 0 && _playerSeed != 0);\r\n\r\n        int newBalance =  processDiceBet(_betNum, _betValue, _balance, _serverSeed, _playerSeed);\r\n\r\n        // do not allow balance below player stake\r\n        int stake = int(_stake);\r\n        if (newBalance < -stake) {\r\n            newBalance = -stake;\r\n        }\r\n\r\n        return newBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Force end of game if player does not respond. Only possible after a time period.\r\n     * to give the player a chance to respond.\r\n     * @param _gameType Game type.\r\n     * @param _betNum Bet number.\r\n     * @param _betValue Bet value.\r\n     * @param _balance Current balance.\r\n     * @param _stake Player stake.\r\n     * @param _endInitiatedTime Time server initiated end.\r\n     * @return New game session balance.\r\n     */\r\n    function serverForceGameEnd(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        public\r\n        view\r\n        onlyValidBalance(_balance, _stake)\r\n        returns(int)\r\n    {\r\n        require(_endInitiatedTime + SERVER_TIMEOUT <= block.timestamp);\r\n        require(isValidBet(_gameType, _betNum, _betValue)\r\n                || (_gameType == 0 && _betNum == 0 && _betValue == 0 && _balance == 0));\r\n\r\n\r\n        // following casts and calculations are safe as ranges are fixed\r\n        // assume player has lost\r\n        int newBalance = _balance - int(_betValue);\r\n\r\n        // penalize player as he didn't end game\r\n        newBalance -= NOT_ENDED_FINE;\r\n\r\n        // do not allow balance below player stake\r\n        int stake = int(_stake);\r\n        if (newBalance < -stake) {\r\n            newBalance = -stake;\r\n        }\r\n\r\n        return newBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Force end of game if server does not respond. Only possible after a time period\r\n     * to give the server a chance to respond.\r\n     * @param _gameType Game type.\r\n     * @param _betNum Bet number.\r\n     * @param _betValue Value of bet.\r\n     * @param _balance Current balance.\r\n     * @param _endInitiatedTime Time server initiated end.\r\n     * @return New game session balance.\r\n     */\r\n    function playerForceGameEnd(\r\n        uint8 _gameType,\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        uint  _stake,\r\n        uint _endInitiatedTime\r\n    )\r\n        public\r\n        view\r\n        onlyValidBalance(_balance, _stake)\r\n        returns(int)\r\n    {\r\n        require(_endInitiatedTime + PLAYER_TIMEOUT <= block.timestamp);\r\n        require(isValidBet(_gameType, _betNum, _betValue) ||\r\n                (_gameType == 0 && _betNum == 0 && _betValue == 0 && _balance == 0));\r\n\r\n        int profit = 0;\r\n        if (_gameType == 0 && _betNum == 0 && _betValue == 0 && _balance == 0) {\r\n            // player cancelled game without playing\r\n            profit = 0;\r\n        } else {\r\n            profit = calculateDiceProfit(_betNum, _betValue);\r\n        }\r\n\r\n        // penalize server as it didn't end game\r\n        profit += NOT_ENDED_FINE;\r\n\r\n        return _balance + profit;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate new balance after executing bet.\r\n     * @param _serverSeed Server's seed\r\n     * @param _playerSeed Player's seed\r\n     * @param _betNum Bet Number.\r\n     * @param _betValue Value of bet.\r\n     * @param _balance Current balance.\r\n     */\r\n    function processDiceBet(\r\n        uint _betNum,\r\n        uint _betValue,\r\n        int _balance,\r\n        bytes32 _serverSeed,\r\n        bytes32 _playerSeed\r\n    )\r\n        private\r\n        pure\r\n        returns (int)\r\n    {\r\n        assert(_betNum > 0 && _betNum < DICE_RANGE);\r\n\r\n        // check who has won\r\n        bool playerWon = calculateDiceWinner(_serverSeed, _playerSeed, _betNum);\r\n\r\n        if (playerWon) {\r\n            int profit = calculateDiceProfit(_betNum, _betValue);\r\n            return _balance + profit;\r\n        } else {\r\n            return _balance - int(_betValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate player profit if player has won.\r\n     * @param _betNum Bet number of player.\r\n     * @param _betValue Value of bet.safe\r\n     * @return Players' profit.\r\n     */\r\n    function calculateDiceProfit(uint _betNum, uint _betValue) private pure returns(int) {\r\n        assert(_betNum > 0 && _betNum < DICE_RANGE);\r\n\r\n        // convert to gwei as we use gwei as lowest unit\r\n        uint betValue = _betValue / 1e9;\r\n\r\n        // safe without safe math as ranges are fixed\r\n        uint totalWon = betValue * DICE_RANGE / _betNum;\r\n        uint houseEdgeValue = totalWon * HOUSE_EDGE / HOUSE_EDGE_DIVISOR;\r\n        int profit = int(totalWon) - int(houseEdgeValue) - int(betValue);\r\n\r\n        // convert back to wei and return\r\n        return profit * 1e9;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate winner of dice game.\r\n     * @param _serverSeed Server seed of bet.\r\n     * @param _playerSeed Player seed of bet.\r\n     * @param _betNum Bet number.\r\n     * @return True if player has won false if he lost.\r\n     */\r\n    function calculateDiceWinner(\r\n        bytes32 _serverSeed,\r\n        bytes32 _playerSeed,\r\n        uint _betNum\r\n    )\r\n        private\r\n        pure\r\n        returns(bool)\r\n    {\r\n        assert(_betNum > 0 && _betNum < DICE_RANGE);\r\n\r\n        bytes32 combinedHash = keccak256(_serverSeed, _playerSeed);\r\n        uint randomNumber = uint(combinedHash) % DICE_RANGE; // bias is negligible\r\n        return randomNumber < _betNum;\r\n    }\r\n}\r\n\r\nlibrary MathUtil {\r\n    /**\r\n     * @dev Returns the absolute value of _val.\r\n     * @param _val value\r\n     * @return The absolute value of _val.\r\n     */\r\n    function abs(int _val) internal pure returns(uint) {\r\n        if (_val < 0) {\r\n            return uint(-_val);\r\n        } else {\r\n            return uint(_val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate maximum.\r\n     */\r\n    function max(uint _val1, uint _val2) internal pure returns(uint) {\r\n        return _val1 >= _val2 ? _val1 : _val2;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate minimum.\r\n     */\r\n    function min(uint _val1, uint _val2) internal pure returns(uint) {\r\n        return _val1 <= _val2 ? _val1 : _val2;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"}],\"name\":\"isValidBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_stake\",\"type\":\"uint256\"},{\"name\":\"_serverSeed\",\"type\":\"bytes32\"},{\"name\":\"_playerSeed\",\"type\":\"bytes32\"}],\"name\":\"endGameConflict\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BET_VALUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BET_VALUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DICE_RANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"activeGames\",\"type\":\"uint256\"}],\"name\":\"minHouseStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAME_TYPE_DICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_stake\",\"type\":\"uint256\"},{\"name\":\"_endInitiatedTime\",\"type\":\"uint256\"}],\"name\":\"serverForceGameEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NOT_ENDED_FINE\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PLAYER_TIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SERVER_TIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameType\",\"type\":\"uint8\"},{\"name\":\"_betNum\",\"type\":\"uint256\"},{\"name\":\"_betValue\",\"type\":\"uint256\"},{\"name\":\"_balance\",\"type\":\"int256\"},{\"name\":\"_stake\",\"type\":\"uint256\"},{\"name\":\"_endInitiatedTime\",\"type\":\"uint256\"}],\"name\":\"playerForceGameEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BALANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HOUSE_EDGE_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConflictResolution","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e7bb81c17f5bdf2ee91aae6bccecec016fc6ab78a148d009cda348b4a28277e0"}]}