{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.17;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) pure internal returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) pure internal returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) pure internal returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) \r\n            owner = newOwner;\r\n    }\r\n\r\n    function kill() public {\r\n        if (msg.sender == owner) \r\n            selfdestruct(owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender == owner)\r\n            _;\r\n    }\r\n}\r\n\r\n\r\ncontract Pausable is Ownable {\r\n    bool public stopped;\r\n\r\n    modifier stopInEmergency {\r\n        if (stopped) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyInEmergency {\r\n        if (!stopped) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    // Called by the owner in emergency, triggers stopped state\r\n    function emergencyStop() external onlyOwner() {\r\n        stopped = true;\r\n    }\r\n\r\n    // Called by the owner to end of emergency, returns to normal state\r\n    function release() external onlyOwner() onlyInEmergency {\r\n        stopped = false;\r\n    }\r\n}\r\n\r\ncontract WhiteList is Ownable {\r\n\r\n    function isWhiteListedAndAffiliate(address _user) external view returns (bool, address);\r\n}\r\n\r\n// Crowdsale Smart Contract\r\n// This smart contract collects ETH and in return sends tokens to contributors\r\ncontract Crowdsale is Pausable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Backer {\r\n        uint weiReceived; // amount of ETH contributed\r\n        uint tokensToSend; // amount of tokens  sent  \r\n        bool claimed;\r\n        bool refunded; // true if user has been refunded       \r\n    }\r\n\r\n    Token public token; // Token contract reference   \r\n    address public multisig; // Multisig contract that will receive the ETH    \r\n    address public team; // Address at which the team tokens will be sent   \r\n    uint public teamTokens; // tokens for the team.     \r\n    uint public ethReceivedPresale; // Number of ETH received in presale\r\n    uint public ethReceivedMain; // Number of ETH received in public sale\r\n    uint public totalTokensSent; // Number of tokens sent to ETH contributors\r\n    uint public totalAffiliateTokensSent;\r\n    uint public startBlock; // Crowdsale start block\r\n    uint public endBlock; // Crowdsale end block\r\n    uint public maxCap; // Maximum number of tokens to sell\r\n    uint public minCap; // Minimum number of ETH to raise\r\n    uint public minInvestETH; // Minimum amount to invest   \r\n    bool public crowdsaleClosed; // Is crowdsale still in progress\r\n    Step public currentStep;  // to allow for controled steps of the campaign \r\n    uint public refundCount;  // number of refunds\r\n    uint public totalRefunded; // total amount of refunds    \r\n    uint public tokenPriceWei;  // price of token in wei\r\n    WhiteList public whiteList; // white list address\r\n    uint public numOfBlocksInMinute;// number of blocks in one minute * 100. eg. \r\n    uint public claimCount; // number of claims\r\n    uint public totalClaimed; // Total number of tokens claimed\r\n    \r\n\r\n    mapping(address => Backer) public backers; //backer list\r\n    mapping(address => uint) public affiliates; // affiliates list\r\n    address[] public backersIndex; // to be able to itarate through backers for verification.  \r\n    mapping(address => uint) public claimed;  // Tokens claimed by contibutors\r\n\r\n    \r\n    // @notice to verify if action is not performed out of the campaing range\r\n    modifier respectTimeFrame() {\r\n        if ((block.number < startBlock) || (block.number > endBlock)) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // @notice to set and determine steps of crowdsale\r\n    enum Step {\r\n        Unknown,\r\n        FundingPreSale,     // presale mode\r\n        FundingPublicSale,  // public mode\r\n        Refunding,  // in case campaign failed during this step contributors will be able to receive refunds\r\n        Claiming    // set this step to enable claiming of tokens. \r\n    }\r\n\r\n    // Events\r\n    event ReceivedETH(address indexed backer, address indexed affiliate, uint amount, uint tokenAmount, uint affiliateTokenAmount);\r\n    event RefundETH(address backer, uint amount);\r\n    event TokensClaimed(address backer, uint count);\r\n\r\n\r\n    // Crowdsale  {constructor}\r\n    // @notice fired when contract is crated. Initilizes all constnat and initial values.\r\n    function Crowdsale(WhiteList _whiteListAddress) public {\r\n        multisig = 0x49447Ea549CCfFDEF2E9a9290709d6114346df88; \r\n        team = 0x49447Ea549CCfFDEF2E9a9290709d6114346df88;                                         \r\n        startBlock = 0; // Should wait for the call of the function start\r\n        endBlock = 0; // Should wait for the call of the function start                  \r\n        tokenPriceWei = 108110000000000;\r\n        maxCap = 210000000e18;         \r\n        minCap = 21800000e18;        \r\n        totalTokensSent = 0;  //TODO: add tokens sold in private sale\r\n        setStep(Step.FundingPreSale);\r\n        numOfBlocksInMinute = 416;    \r\n        whiteList = WhiteList(_whiteListAddress);    \r\n        teamTokens = 45000000e18;\r\n    }\r\n\r\n    // @notice to populate website with status of the sale \r\n    function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint, Step, bool, bool) {            \r\n    \r\n        return (startBlock, endBlock, backersIndex.length, ethReceivedPresale.add(ethReceivedMain), maxCap, minCap, totalTokensSent, tokenPriceWei, currentStep, stopped, crowdsaleClosed);\r\n    }\r\n\r\n    // @notice Specify address of token contract\r\n    // @param _tokenAddress {address} address of token contract\r\n    // @return res {bool}\r\n    function updateTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\r\n        token = _tokenAddress;\r\n        return true;\r\n    }\r\n\r\n    // @notice set the step of the campaign \r\n    // @param _step {Step}\r\n    function setStep(Step _step) public onlyOwner() {\r\n        currentStep = _step;\r\n        \r\n        if (currentStep == Step.FundingPreSale) {  // for presale \r\n          \r\n            minInvestETH = 1 ether/5;                             \r\n        }else if (currentStep == Step.FundingPublicSale) { // for public sale           \r\n            minInvestETH = 1 ether/10;               \r\n        }      \r\n    }\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handels allocation of Ether and calculates tokens.\r\n    function () external payable {           \r\n        contribute(msg.sender);\r\n    }\r\n\r\n    // @notice It will be called by owner to start the sale    \r\n    function start(uint _block) external onlyOwner() {   \r\n\r\n        require(_block < 335462);  // 4.16*60*24*56 days = 335462     \r\n        startBlock = block.number;\r\n        endBlock = startBlock.add(_block); \r\n    }\r\n\r\n    // @notice Due to changing average of block time\r\n    // this function will allow on adjusting duration of campaign closer to the end \r\n    function adjustDuration(uint _block) external onlyOwner() {\r\n\r\n        require(_block < 389376);  // 4.16*60*24*65 days = 389376     \r\n        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\r\n        endBlock = startBlock.add(_block); \r\n    }\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _backer {address} address contributor\r\n    // @return res {bool} true if transaction was successful\r\n    function contribute(address _backer) internal stopInEmergency respectTimeFrame returns(bool res) {\r\n\r\n        uint affiliateTokens;\r\n\r\n        var(isWhiteListed, affiliate) = whiteList.isWhiteListedAndAffiliate(_backer);\r\n\r\n        require(isWhiteListed);      // ensure that user is whitelisted\r\n    \r\n        require(currentStep == Step.FundingPreSale || currentStep == Step.FundingPublicSale); // ensure that this is correct step\r\n        require(msg.value >= minInvestETH);   // ensure that min contributions amount is met\r\n          \r\n        uint tokensToSend = determinePurchase();\r\n\r\n        if (affiliate != address(0)) {\r\n            affiliateTokens = (tokensToSend * 5) / 100; // give 5% of tokens to affiliate\r\n            affiliates[affiliate] += affiliateTokens;\r\n            Backer storage referrer = backers[affiliate];\r\n            referrer.tokensToSend = referrer.tokensToSend.add(affiliateTokens);\r\n        }\r\n        \r\n        require(totalTokensSent.add(tokensToSend.add(affiliateTokens)) < maxCap); // Ensure that max cap hasn't been reached  \r\n            \r\n        Backer storage backer = backers[_backer];\r\n    \r\n        if (backer.tokensToSend == 0)      \r\n            backersIndex.push(_backer);\r\n           \r\n        backer.tokensToSend = backer.tokensToSend.add(tokensToSend); // save contributors tokens to be sent\r\n        backer.weiReceived = backer.weiReceived.add(msg.value);  // save how much was the contribution\r\n        totalTokensSent += tokensToSend + affiliateTokens;     // update the total amount of tokens sent\r\n        totalAffiliateTokensSent += affiliateTokens;\r\n    \r\n        if (Step.FundingPublicSale == currentStep)  // Update the total Ether recived\r\n            ethReceivedMain = ethReceivedMain.add(msg.value);\r\n        else\r\n            ethReceivedPresale = ethReceivedPresale.add(msg.value);     \r\n       \r\n        multisig.transfer(this.balance);   // transfer funds to multisignature wallet             \r\n    \r\n        ReceivedETH(_backer, affiliate, msg.value, tokensToSend, affiliateTokens); // Register event\r\n        return true;\r\n    }\r\n\r\n    // @notice determine if purchase is valid and return proper number of tokens\r\n    // @return tokensToSend {uint} proper number of tokens based on the timline     \r\n    function determinePurchase() internal view  returns (uint) {\r\n       \r\n        require(msg.value >= minInvestETH);                        // ensure that min contributions amount is met  \r\n        uint tokenAmount = msg.value.mul(1e18) / tokenPriceWei;    // calculate amount of tokens\r\n\r\n        uint tokensToSend;  \r\n\r\n        if (currentStep == Step.FundingPreSale)\r\n            tokensToSend = calculateNoOfTokensToSend(tokenAmount); \r\n        else\r\n            tokensToSend = tokenAmount;\r\n                                                                                                       \r\n        return tokensToSend;\r\n    }\r\n\r\n    // @notice This function will return number of tokens based on time intervals in the campaign\r\n    // @param _tokenAmount {uint} amount of tokens to allocate for the contribution\r\n    function calculateNoOfTokensToSend(uint _tokenAmount) internal view  returns (uint) {\r\n              \r\n        if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24 * 14) / 100)        // less equal then/equal 14 days\r\n            return  _tokenAmount + (_tokenAmount * 40) / 100;  // 40% bonus\r\n        else if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24 * 28) / 100)   // less equal  28 days\r\n            return  _tokenAmount + (_tokenAmount * 30) / 100; // 30% bonus\r\n        else\r\n            return  _tokenAmount + (_tokenAmount * 20) / 100;   // remainder of the campaign 20% bonus\r\n          \r\n    }\r\n\r\n    // @notice erase contribution from the database and do manual refund for disapproved users\r\n    // @param _backer {address} address of user to be erased\r\n    function eraseContribution(address _backer) external onlyOwner() {\r\n\r\n        Backer storage backer = backers[_backer];        \r\n        backer.refunded = true;\r\n        totalTokensSent = totalTokensSent.sub(backer.tokensToSend);        \r\n    }\r\n\r\n    // @notice allow on manual addition of contributors\r\n    // @param _backer {address} of contributor to be added\r\n    // @parm _amountTokens {uint} tokens to be added\r\n    function addManualContributor(address _backer, uint _amountTokens) external onlyOwner() {\r\n\r\n        Backer storage backer = backers[_backer];        \r\n        backer.tokensToSend = backer.tokensToSend.add(_amountTokens);\r\n        if (backer.tokensToSend == 0)      \r\n            backersIndex.push(_backer);\r\n        totalTokensSent = totalTokensSent.add(_amountTokens);\r\n    }\r\n\r\n\r\n    // @notice contributors can claim tokens after public ICO is finished\r\n    // tokens are only claimable when token address is available and lock-up period reached. \r\n    function claimTokens() external {\r\n        claimTokensForUser(msg.sender);\r\n    }\r\n\r\n    // @notice this function can be called by admin to claim user's token in case of difficulties\r\n    // @param _backer {address} user address to claim tokens for\r\n    function adminClaimTokenForUser(address _backer) external onlyOwner() {\r\n        claimTokensForUser(_backer);\r\n    }\r\n\r\n    // @notice in case refunds are needed, money can be returned to the contract\r\n    // and contract switched to mode refunding\r\n    function prepareRefund() public payable onlyOwner() {\r\n        \r\n        require(msg.value == ethReceivedMain + ethReceivedPresale); // make sure that proper amount of ether is sent\r\n        currentStep == Step.Refunding;\r\n    }\r\n\r\n    // @notice return number of contributors\r\n    // @return  {uint} number of contributors   \r\n    function numberOfBackers() public view returns(uint) {\r\n        return backersIndex.length;\r\n    }\r\n \r\n    // @notice called to send tokens to contributors after ICO and lockup period. \r\n    // @param _backer {address} address of beneficiary\r\n    // @return true if successful\r\n    function claimTokensForUser(address _backer) internal returns(bool) {       \r\n\r\n        require(currentStep == Step.Claiming);\r\n                  \r\n        Backer storage backer = backers[_backer];\r\n\r\n        require(!backer.refunded);      // if refunded, don't allow for another refund           \r\n        require(!backer.claimed);       // if tokens claimed, don't allow refunding            \r\n        require(backer.tokensToSend != 0);   // only continue if there are any tokens to send           \r\n\r\n        claimCount++;\r\n        claimed[_backer] = backer.tokensToSend;  // save claimed tokens\r\n        backer.claimed = true;\r\n        totalClaimed += backer.tokensToSend;\r\n        \r\n        if (!token.transfer(_backer, backer.tokensToSend)) \r\n            revert(); // send claimed tokens to contributor account\r\n\r\n        TokensClaimed(_backer, backer.tokensToSend);  \r\n    }\r\n\r\n\r\n    // @notice This function will finalize the sale.\r\n    // It will only execute if predetermined sale time passed or all tokens are sold.\r\n    // it will fail if minimum cap is not reached\r\n    function finalize() external onlyOwner() {\r\n\r\n        require(!crowdsaleClosed);        \r\n        // purchasing precise number of tokens might be impractical, thus subtract 1000 tokens so finalizition is possible\r\n        // near the end \r\n        require(block.number >= endBlock || totalTokensSent >= maxCap.sub(1000));                 \r\n        require(totalTokensSent >= minCap);  // ensure that minimum was reached\r\n\r\n        crowdsaleClosed = true;  \r\n        \r\n        if (!token.transfer(team, teamTokens)) // transfer all remaing tokens to team address\r\n            revert();\r\n\r\n        if (!token.burn(this, maxCap - totalTokensSent)) // burn all unsold tokens\r\n            revert();  \r\n        token.unlock();                      \r\n    }\r\n\r\n    // @notice Failsafe drain\r\n    function drain() external onlyOwner() {\r\n        multisig.transfer(this.balance);               \r\n    }\r\n\r\n    // @notice Failsafe token transfer\r\n    function tokenDrian() external onlyOwner() {\r\n        if (block.number > endBlock) {\r\n            if (!token.transfer(team, token.balanceOf(this))) \r\n                revert();\r\n        }\r\n    }\r\n    \r\n    // @notice it will allow contributors to get refund in case campaign failed\r\n    function refund() external stopInEmergency returns (bool) {\r\n\r\n        require(currentStep == Step.Refunding);         \r\n       \r\n        require(this.balance > 0);  // contract will hold 0 ether at the end of campaign.                                  \r\n                                    // contract needs to be funded through fundContract() \r\n\r\n        Backer storage backer = backers[msg.sender];\r\n\r\n        require(backer.weiReceived > 0);  // esnure that user has sent contribution\r\n        require(!backer.refunded);         // ensure that user hasn't been refunded yet\r\n        require(!backer.claimed);       // if tokens claimed, don't allow refunding   \r\n       \r\n        backer.refunded = true;  // save refund status to true\r\n    \r\n        refundCount++;\r\n        totalRefunded = totalRefunded.add(backer.weiReceived);\r\n        msg.sender.transfer(backer.weiReceived);  // send back the contribution \r\n        RefundETH(msg.sender, backer.weiReceived);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n   \r\n    function transfer(address to, uint value) public returns(bool ok);  \r\n}\r\n\r\n\r\n// The token\r\ncontract Token is ERC20, Ownable {\r\n\r\n    function returnTokens(address _member, uint256 _value) public returns(bool);\r\n    function unlock() public;\r\n    function balanceOf(address _owner) public view returns(uint balance);\r\n    function burn( address _member, uint256 _value) public returns(bool);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnWebsiteData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backer\",\"type\":\"address\"}],\"name\":\"eraseContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backer\",\"type\":\"address\"},{\"name\":\"_amountTokens\",\"type\":\"uint256\"}],\"name\":\"addManualContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"prepareRefund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"updateTokenAddress\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backer\",\"type\":\"address\"}],\"name\":\"adminClaimTokenForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"adjustDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfBlocksInMinute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"backers\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"tokensToSend\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"bool\"},{\"name\":\"refunded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAffiliateTokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenDrian\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_step\",\"type\":\"uint8\"}],\"name\":\"setStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backersIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_whiteListAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"affiliate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateTokenAmount\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005e8642916d350811614b88b8cfa6f935c36c6ff5","Library":"","SwarmSource":"bzzr://8b4a69969f411c2d79c432d929d987191c8ecb4fb42f89f594093755fd9bd0ca"}]}