{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n    /**\r\n    * @dev constructor\r\n    */\r\n    function SafeMath() public {\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/token/IERC20Token.sol\r\n\r\n/**\r\n * @title IERC20Token - ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20Token {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value)  public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\r\n    function approve(address _spender, uint256 _value)  public returns (bool success);\r\n    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// File: contracts/token/LockedTokens.sol\r\n\r\n/**\r\n * @title LockedTokens\r\n * @dev Lock tokens for certain period of time\r\n */\r\ncontract LockedTokens is SafeMath {\r\n    struct Tokens {\r\n        uint256 amount;\r\n        uint256 lockEndTime;\r\n        bool released;\r\n    }\r\n\r\n    event TokensUnlocked(address _to, uint256 _value);\r\n\r\n    IERC20Token public token;\r\n    address public crowdsaleAddress;\r\n    mapping(address => Tokens[]) public walletTokens;\r\n\r\n    /**\r\n     * @dev LockedTokens constructor\r\n     * @param _token ERC20 compatible token contract\r\n     * @param _crowdsaleAddress Crowdsale contract address\r\n     */\r\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\r\n        token = _token;\r\n        crowdsaleAddress = _crowdsaleAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Functions locks tokens\r\n     * @param _to Wallet address to transfer tokens after _lockEndTime\r\n     * @param _amount Amount of tokens to lock\r\n     * @param _lockEndTime End of lock period\r\n     */\r\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\r\n        require(msg.sender == crowdsaleAddress);\r\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\r\n    }\r\n\r\n    /**\r\n     * @dev Called by owner of locked tokens to release them\r\n     */\r\n    function releaseTokens() public {\r\n        require(walletTokens[msg.sender].length > 0);\r\n\r\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\r\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\r\n                walletTokens[msg.sender][i].released = true;\r\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\r\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"walletTokens\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"lockEndTime\",\"type\":\"uint256\"},{\"name\":\"released\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_lockEndTime\",\"type\":\"uint256\"}],\"name\":\"addTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokensUnlocked\",\"type\":\"event\"}]","ContractName":"LockedTokens","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006a546617fd8c74555a2cb63b7b064331de82f68d000000000000000000000000770b05bec95bbfdd90a9e46c48fcb101e70ebf9b","Library":"","SwarmSource":"bzzr://ac3041b85c9f75c4e1ed1a4d49fb4b9c44790b956ed3371d86c330f293554322"}]}