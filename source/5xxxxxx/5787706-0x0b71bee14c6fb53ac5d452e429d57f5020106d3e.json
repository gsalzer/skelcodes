{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n\r\nETHEREUM WORLD CUP : 14th June - 15th July 2018 [Russia]\r\n    - designed and implemented by Norsefire.\r\n    - thanks to Etherguy and oguzhanox for debugging and front-end respectively.\r\n\r\nRules are as follows:\r\n    * Entry to the game costs 0.2018 Ether. Use the register function when sending this.\r\n        - Any larger or smaller amount of Ether, will be rejected.\r\n    * 90% of the entry fee will go towards the prize fund, with 10% forming a fee.\r\n        Of this fee, half goes to the developer, and half goes directly to Giveth (giveth.io/donate).\r\n        The entry fee is the only Ether you will need to send for the duration of the\r\n        tournament, barring the gas you spend for placing predictions.\r\n    * Buying an entry allows the sender to place predictions on each game in the World Cup,\r\n        barring those which have already kicked off prior to the time a participant enters.\r\n    * Predictions can be made (or changed!) at any point up until the indicated kick-off time.\r\n    * Selecting the correct result for any given game awards the player one point.\r\n        In the first stage, a participant can also select a draw. This is not available from the RO16 onwards.\r\n    * If a participant reaches a streak of three or more correct predictions in a row, they receive two points\r\n        for every correct prediction from the third game until the streak is broken.\r\n    * If a participant reaches a streak of *five* or more correct predictions in a row, they receive four points\r\n        for every correct prediction from the fifth game until the streak is broken.\r\n    * In the event of a tie, the following algorithm is used to decide rankings:\r\n        - Compare the sum totals of the scores over the last 32 games.\r\n        - If this produces a draw as well, compare results of the last 16 games.\r\n        - This repeats until comparing the results of the final.\r\n        - If it's a dead heat throughout, a coin-flip (or some equivalent method) will be used to determine the winner.\r\n\r\nPrizes:\r\n    FIRST  PLACE: 40% of Ether contained within the pot.\r\n    SECOND PLACE: 30% of Ether contained within the pot.\r\n    THIRD  PLACE: 20% of Ether contained within the pot.\r\n    FOURTH PLACE: 10% of Ether contained within the pot.\r\n\r\nParticipant Teams and Groups:\r\n\r\n[Group D] AR - Argentina\r\n[Group C] AU - Australia\r\n[Group G] BE - Belgium\r\n[Group E] BR - Brazil\r\n[Group E] CH - Switzerland\r\n[Group H] CO - Colombia\r\n[Group E] CR - Costa Rica\r\n[Group E] CS - Serbia\r\n[Group F] DE - Germany\r\n[Group C] DK - Denmark\r\n[Group A] EG - Egypt\r\n[Group G] EN - England\r\n[Group B] ES - Spain\r\n[Group C] FR - France\r\n[Group D] HR - Croatia\r\n[Group B] IR - Iran\r\n[Group D] IS - Iceland\r\n[Group H] JP - Japan\r\n[Group F] KR - Republic of Korea\r\n[Group B] MA - Morocco\r\n[Group F] MX - Mexico\r\n[Group D] NG - Nigeria\r\n[Group G] PA - Panama\r\n[Group C] PE - Peru\r\n[Group H] PL - Poland\r\n[Group B] PT - Portugal\r\n[Group A] RU - Russia\r\n[Group A] SA - Saudi Arabia\r\n[Group F] SE - Sweden\r\n[Group H] SN - Senegal\r\n[Group G] TN - Tunisia\r\n[Group A] UY - Uruguay\r\n\r\n*/\r\n\r\ncontract ZeroBTCInterface {\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n}\r\n\r\ncontract ZeroBTCWorldCup {\r\n    using SafeMath for uint;\r\n\r\n    /* CONSTANTS */\r\n\r\n    address internal constant administrator = 0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae;\r\n    address internal constant givethAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;\r\n    address internal constant BTCTKNADDR    = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31;\r\n    ZeroBTCInterface public BTCTKN;\r\n\r\n    string name   = \"EtherWorldCup\";\r\n    string symbol = \"EWC\";\r\n    uint    internal constant entryFee      = 2018e15;\r\n    uint    internal constant ninetyPercent = 18162e14;\r\n    uint    internal constant fivePercent   = 1009e14;\r\n    uint    internal constant tenPercent    = 2018e14;\r\n\r\n    /* VARIABLES */\r\n\r\n    mapping (string =>  int8)                     worldCupGameID;\r\n    mapping (int8   =>  bool)                     gameFinished;\r\n    // Is a game no longer available for predictions to be made?\r\n    mapping (int8   =>  uint)                     gameLocked;\r\n    // A result is either the two digit code of a country, or the word \"DRAW\".\r\n    // Country codes are listed above.\r\n    mapping (int8   =>  string)                   gameResult;\r\n    int8 internal                                 latestGameFinished;\r\n    uint internal                                 prizePool;\r\n    uint internal                                 givethPool;\r\n    uint internal                                 adminPool;\r\n    int                                           registeredPlayers;\r\n\r\n    mapping (address => bool)                     playerRegistered;\r\n    mapping (address => mapping (int8 => bool))   playerMadePrediction;\r\n    mapping (address => mapping (int8 => string)) playerPredictions;\r\n    mapping (address => int8[64])                 playerPointArray;\r\n    mapping (address => int8)                     playerGamesScored;\r\n    mapping (address => uint)                     playerStreak;\r\n    address[]                                     playerList;\r\n\r\n    /* DEBUG EVENTS */\r\n\r\n    event Registration(\r\n        address _player\r\n    );\r\n\r\n    event PlayerLoggedPrediction(\r\n        address _player,\r\n        int     _gameID,\r\n        string  _prediction\r\n    );\r\n\r\n    event PlayerUpdatedScore(\r\n        address _player,\r\n        int     _lastGamePlayed\r\n    );\r\n\r\n    event Comparison(\r\n        address _player,\r\n        uint    _gameID,\r\n        string  _myGuess,\r\n        string  _result,\r\n        bool    _correct\r\n    );\r\n\r\n    event StartAutoScoring(\r\n        address _player\r\n    );\r\n\r\n    event StartScoring(\r\n        address _player,\r\n        uint    _gameID\r\n    );\r\n\r\n    event DidNotPredict(\r\n        address _player,\r\n        uint    _gameID\r\n    );\r\n\r\n    event RipcordRefund(\r\n        address _player\r\n    );\r\n\r\n    /* CONSTRUCTOR */\r\n\r\n    constructor ()\r\n        public\r\n    {\r\n        // First stage games: these are known in advance.\r\n\r\n        // Thursday 14th June, 2018\r\n        worldCupGameID[\"RU-SA\"] = 1;   // Russia       vs Saudi Arabia\r\n        gameLocked[1]           = 1528988400;\r\n\r\n        // Friday 15th June, 2018\r\n        worldCupGameID[\"EG-UY\"] = 2;   // Egypt        vs Uruguay\r\n        worldCupGameID[\"MA-IR\"] = 3;   // Morocco      vs Iran\r\n        worldCupGameID[\"PT-ES\"] = 4;   // Portugal     vs Spain\r\n        gameLocked[2]           = 1529064000;\r\n        gameLocked[3]           = 1529074800;\r\n        gameLocked[4]           = 1529085600;\r\n\r\n        // Saturday 16th June, 2018\r\n        worldCupGameID[\"FR-AU\"] = 5;   // France       vs Australia\r\n        worldCupGameID[\"AR-IS\"] = 6;   // Argentina    vs Iceland\r\n        worldCupGameID[\"PE-DK\"] = 7;   // Peru         vs Denmark\r\n        worldCupGameID[\"HR-NG\"] = 8;   // Croatia      vs Nigeria\r\n        gameLocked[5]           = 1529143200;\r\n        gameLocked[6]           = 1529154000;\r\n        gameLocked[7]           = 1529164800;\r\n        gameLocked[8]           = 1529175600;\r\n\r\n        // Sunday 17th June, 2018\r\n        worldCupGameID[\"CR-CS\"] = 9;   // Costa Rica   vs Serbia\r\n        worldCupGameID[\"DE-MX\"] = 10;  // Germany      vs Mexico\r\n        worldCupGameID[\"BR-CH\"] = 11;  // Brazil       vs Switzerland\r\n        gameLocked[9]           = 1529236800;\r\n        gameLocked[10]          = 1529247600;\r\n        gameLocked[11]          = 1529258400;\r\n\r\n        // Monday 18th June, 2018\r\n        worldCupGameID[\"SE-KR\"] = 12;  // Sweden       vs Korea\r\n        worldCupGameID[\"BE-PA\"] = 13;  // Belgium      vs Panama\r\n        worldCupGameID[\"TN-EN\"] = 14;  // Tunisia      vs England\r\n        gameLocked[12]          = 1529323200;\r\n        gameLocked[13]          = 1529334000;\r\n        gameLocked[14]          = 1529344800;\r\n\r\n        // Tuesday 19th June, 2018\r\n        worldCupGameID[\"CO-JP\"] = 15;  // Colombia     vs Japan\r\n        worldCupGameID[\"PL-SN\"] = 16;  // Poland       vs Senegal\r\n        worldCupGameID[\"RU-EG\"] = 17;  // Russia       vs Egypt\r\n        gameLocked[15]          = 1529409600;\r\n        gameLocked[16]          = 1529420400;\r\n        gameLocked[17]          = 1529431200;\r\n\r\n        // Wednesday 20th June, 2018\r\n        worldCupGameID[\"PT-MA\"] = 18;  // Portugal     vs Morocco\r\n        worldCupGameID[\"UR-SA\"] = 19;  // Uruguay      vs Saudi Arabia\r\n        worldCupGameID[\"IR-ES\"] = 20;  // Iran         vs Spain\r\n        gameLocked[18]          = 1529496000;\r\n        gameLocked[19]          = 1529506800;\r\n        gameLocked[20]          = 1529517600;\r\n\r\n        // Thursday 21st June, 2018\r\n        worldCupGameID[\"DK-AU\"] = 21;  // Denmark      vs Australia\r\n        worldCupGameID[\"FR-PE\"] = 22;  // France       vs Peru\r\n        worldCupGameID[\"AR-HR\"] = 23;  // Argentina    vs Croatia\r\n        gameLocked[21]          = 1529582400;\r\n        gameLocked[22]          = 1529593200;\r\n        gameLocked[23]          = 1529604000;\r\n\r\n        // Friday 22nd June, 2018\r\n        worldCupGameID[\"BR-CR\"] = 24;  // Brazil       vs Costa Rica\r\n        worldCupGameID[\"NG-IS\"] = 25;  // Nigeria      vs Iceland\r\n        worldCupGameID[\"CS-CH\"] = 26;  // Serbia       vs Switzerland\r\n        gameLocked[24]          = 1529668800;\r\n        gameLocked[25]          = 1529679600;\r\n        gameLocked[26]          = 1529690400;\r\n\r\n        // Saturday 23rd June, 2018\r\n        worldCupGameID[\"BE-TN\"] = 27;  // Belgium      vs Tunisia\r\n        worldCupGameID[\"KR-MX\"] = 28;  // Korea        vs Mexico\r\n        worldCupGameID[\"DE-SE\"] = 29;  // Germany      vs Sweden\r\n        gameLocked[27]          = 1529755200;\r\n        gameLocked[28]          = 1529766000;\r\n        gameLocked[29]          = 1529776800;\r\n\r\n        // Sunday 24th June, 2018\r\n        worldCupGameID[\"EN-PA\"] = 30;  // England      vs Panama\r\n        worldCupGameID[\"JP-SN\"] = 31;  // Japan        vs Senegal\r\n        worldCupGameID[\"PL-CO\"] = 32;  // Poland       vs Colombia\r\n        gameLocked[30]          = 1529841600;\r\n        gameLocked[31]          = 1529852400;\r\n        gameLocked[32]          = 1529863200;\r\n\r\n        // Monday 25th June, 2018\r\n        worldCupGameID[\"UR-RU\"] = 33;  // Uruguay      vs Russia\r\n        worldCupGameID[\"SA-EG\"] = 34;  // Saudi Arabia vs Egypt\r\n        worldCupGameID[\"ES-MA\"] = 35;  // Spain        vs Morocco\r\n        worldCupGameID[\"IR-PT\"] = 36;  // Iran         vs Portugal\r\n        gameLocked[33]          = 1529935200;\r\n        gameLocked[34]          = 1529935200;\r\n        gameLocked[35]          = 1529949600;\r\n        gameLocked[36]          = 1529949600;\r\n\r\n        // Tuesday 26th June, 2018\r\n        worldCupGameID[\"AU-PE\"] = 37;  // Australia    vs Peru\r\n        worldCupGameID[\"DK-FR\"] = 38;  // Denmark      vs France\r\n        worldCupGameID[\"NG-AR\"] = 39;  // Nigeria      vs Argentina\r\n        worldCupGameID[\"IS-HR\"] = 40;  // Iceland      vs Croatia\r\n        gameLocked[37]          = 1530021600;\r\n        gameLocked[38]          = 1530021600;\r\n        gameLocked[39]          = 1530036000;\r\n        gameLocked[40]          = 1530036000;\r\n\r\n        // Wednesday 27th June, 2018\r\n        worldCupGameID[\"KR-DE\"] = 41;  // Korea        vs Germany\r\n        worldCupGameID[\"MX-SE\"] = 42;  // Mexico       vs Sweden\r\n        worldCupGameID[\"CS-BR\"] = 43;  // Serbia       vs Brazil\r\n        worldCupGameID[\"CH-CR\"] = 44;  // Switzerland  vs Costa Rica\r\n        gameLocked[41]          = 1530108000;\r\n        gameLocked[42]          = 1530108000;\r\n        gameLocked[43]          = 1530122400;\r\n        gameLocked[44]          = 1530122400;\r\n\r\n        // Thursday 28th June, 2018\r\n        worldCupGameID[\"JP-PL\"] = 45;  // Japan        vs Poland\r\n        worldCupGameID[\"SN-CO\"] = 46;  // Senegal      vs Colombia\r\n        worldCupGameID[\"PA-TN\"] = 47;  // Panama       vs Tunisia\r\n        worldCupGameID[\"EN-BE\"] = 48;  // England      vs Belgium\r\n        gameLocked[45]          = 1530194400;\r\n        gameLocked[46]          = 1530194400;\r\n        gameLocked[47]          = 1530208800;\r\n        gameLocked[48]          = 1530208800;\r\n\r\n        // Second stage games and onwards. The string values for these will be overwritten\r\n        //   as the tournament progresses. This is the order that will be followed for the\r\n        //   purposes of calculating winning streaks, as per the World Cup website.\r\n\r\n        // Round of 16\r\n        // Saturday 30th June, 2018\r\n        worldCupGameID[\"1C-2D\"]   = 49;  // 1C         vs 2D\r\n        worldCupGameID[\"1A-2B\"]   = 50;  // 1A         vs 2B\r\n        gameLocked[49]            = 1530367200;\r\n        gameLocked[50]            = 1530381600;\r\n\r\n        // Sunday 1st July, 2018\r\n        worldCupGameID[\"1B-2A\"]   = 51;  // 1B         vs 2A\r\n        worldCupGameID[\"1D-2C\"]   = 52;  // 1D         vs 2C\r\n        gameLocked[51]            = 1530453600;\r\n        gameLocked[52]            = 1530468000;\r\n\r\n        // Monday 2nd July, 2018\r\n        worldCupGameID[\"1E-2F\"]   = 53;  // 1E         vs 2F\r\n        worldCupGameID[\"1G-2H\"]   = 54;  // 1G         vs 2H\r\n        gameLocked[53]            = 1530540000;\r\n        gameLocked[54]            = 1530554400;\r\n\r\n        // Tuesday 3rd July, 2018\r\n        worldCupGameID[\"1F-2E\"]   = 55;  // 1F         vs 2E\r\n        worldCupGameID[\"1H-2G\"]   = 56;  // 1H         vs 2G\r\n        gameLocked[55]            = 1530626400;\r\n        gameLocked[56]            = 1530640800;\r\n\r\n        // Quarter Finals\r\n        // Friday 6th July, 2018\r\n        worldCupGameID[\"W49-W50\"] = 57; // W49         vs W50\r\n        worldCupGameID[\"W53-W54\"] = 58; // W53         vs W54\r\n        gameLocked[57]            = 1530885600;\r\n        gameLocked[58]            = 1530900000;\r\n\r\n        // Saturday 7th July, 2018\r\n        worldCupGameID[\"W55-W56\"] = 59; // W55         vs W56\r\n        worldCupGameID[\"W51-W52\"] = 60; // W51         vs W52\r\n        gameLocked[59]            = 1530972000;\r\n        gameLocked[60]            = 1530986400;\r\n\r\n        // Semi Finals\r\n        // Tuesday 10th July, 2018\r\n        worldCupGameID[\"W57-W58\"] = 61; // W57         vs W58\r\n        gameLocked[61]            = 1531245600;\r\n\r\n        // Wednesday 11th July, 2018\r\n        worldCupGameID[\"W59-W60\"] = 62; // W59         vs W60\r\n        gameLocked[62]            = 1531332000;\r\n\r\n        // Third Place Playoff\r\n        // Saturday 14th July, 2018\r\n        worldCupGameID[\"L61-L62\"] = 63; // L61         vs L62\r\n        gameLocked[63]            = 1531576800;\r\n\r\n        // Grand Final\r\n        // Sunday 15th July, 2018\r\n        worldCupGameID[\"W61-W62\"] = 64; // W61         vs W62\r\n        gameLocked[64]            = 1531666800;\r\n\r\n        // Set initial variables.\r\n        latestGameFinished = 0;\r\n\r\n    }\r\n\r\n    /* PUBLIC-FACING COMPETITION INTERACTIONS */\r\n    \r\n    // Register to participate in the competition. Apart from gas costs from\r\n    //   making predictions and updating your score if necessary, this is the\r\n    //   only Ether you will need to spend throughout the tournament.\r\n    function register()\r\n        public\r\n        payable\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(    !playerRegistered[_customerAddress]\r\n                  && tx.origin == _customerAddress);\r\n        // Receive the entry fee tokens.\r\n        require(BTCTKN.transferFrom(_customerAddress, address(this), entryFee));\r\n        \r\n        registeredPlayers = SafeMath.addint256(registeredPlayers, 1);\r\n        playerRegistered[_customerAddress] = true;\r\n        playerGamesScored[_customerAddress] = 0;\r\n        playerList.push(_customerAddress);\r\n        require(playerRegistered[_customerAddress]);\r\n        prizePool  = prizePool.add(ninetyPercent);\r\n        givethPool = givethPool.add(fivePercent);\r\n        adminPool  = adminPool.add(fivePercent);\r\n        emit Registration(_customerAddress);\r\n    }\r\n\r\n    // Make a prediction for a game. An example would be makePrediction(1, \"DRAW\")\r\n    //   if you anticipate a draw in the game between Russia and Saudi Arabia,\r\n    //   or makePrediction(2, \"UY\") if you expect Uruguay to beat Egypt.\r\n    // The \"DRAW\" option becomes invalid after the group stage games have been played.\r\n    function makePrediction(int8 _gameID, string _prediction)\r\n        public {\r\n        address _customerAddress             = msg.sender;\r\n        uint    predictionTime               = now;\r\n        require(playerRegistered[_customerAddress]\r\n                && !gameFinished[_gameID]\r\n                && predictionTime < gameLocked[_gameID]);\r\n        // No draws allowed after the qualification stage.\r\n        if (_gameID > 48 && equalStrings(_prediction, \"DRAW\")) {\r\n            revert();\r\n        } else {\r\n            playerPredictions[_customerAddress][_gameID]    = _prediction;\r\n            playerMadePrediction[_customerAddress][_gameID] = true;\r\n            emit PlayerLoggedPrediction(_customerAddress, _gameID, _prediction);\r\n        }\r\n    }\r\n\r\n    // What is the current score of a given tournament participant?\r\n    function showPlayerScores(address _participant)\r\n        view\r\n        public\r\n        returns (int8[64])\r\n    {\r\n        return playerPointArray[_participant];\r\n    }\r\n\r\n    function seekApproval()\r\n        public\r\n        returns (bool)\r\n    {\r\n        BTCTKN.approve(address(this), entryFee);\r\n    }\r\n    \r\n    // What was the last game ID that has had an official score registered for it?\r\n    function gameResultsLogged()\r\n        view\r\n        public\r\n        returns (int)\r\n    {\r\n        return latestGameFinished;\r\n    }\r\n\r\n    // Sum up the individual scores throughout the tournament and produce a final result.\r\n    function calculateScore(address _participant)\r\n        view\r\n        public\r\n        returns (int16)\r\n    {\r\n        int16 finalScore = 0;\r\n        for (int8 i = 0; i < latestGameFinished; i++) {\r\n            uint j = uint(i);\r\n            int16 gameScore = playerPointArray[_participant][j];\r\n            finalScore = SafeMath.addint16(finalScore, gameScore);\r\n        }\r\n        return finalScore;\r\n    }\r\n\r\n    // How many people are taking part in the tournament?\r\n    function countParticipants()\r\n        public\r\n        view\r\n        returns (int)\r\n    {\r\n        return registeredPlayers;\r\n    }\r\n\r\n    // Keeping this open for anyone to update anyone else so that at the end of\r\n    // the tournament we can force a score update for everyone using a script.\r\n    function updateScore(address _participant)\r\n        public\r\n    {\r\n        int8                     lastPlayed     = latestGameFinished;\r\n        require(lastPlayed > 0);\r\n        // Most recent game scored for this participant.\r\n        int8                     lastScored     = playerGamesScored[_participant];\r\n        // Most recent game played in the tournament (sets bounds for scoring iteration).\r\n        mapping (int8 => bool)   madePrediction = playerMadePrediction[_participant];\r\n        mapping (int8 => string) playerGuesses  = playerPredictions[_participant];\r\n        for (int8 i = lastScored; i < lastPlayed; i++) {\r\n            uint j = uint(i);\r\n            uint k = j.add(1);\r\n            uint streak = playerStreak[_participant];\r\n            emit StartScoring(_participant, k);\r\n            if (!madePrediction[int8(k)]) {\r\n                playerPointArray[_participant][j] = 0;\r\n                playerStreak[_participant]        = 0;\r\n                emit DidNotPredict(_participant, k);\r\n            } else {\r\n                string storage playerResult = playerGuesses[int8(k)];\r\n                string storage actualResult = gameResult[int8(k)];\r\n                bool correctGuess = equalStrings(playerResult, actualResult);\r\n                emit Comparison(_participant, k, playerResult, actualResult, correctGuess);\r\n                 if (!correctGuess) {\r\n                     // The guess was wrong.\r\n                     playerPointArray[_participant][j] = 0;\r\n                     playerStreak[_participant]        = 0;\r\n                 } else {\r\n                     // The guess was right.\r\n                     streak = streak.add(1);\r\n                     playerStreak[_participant] = streak;\r\n                     if (streak >= 5) {\r\n                         // On a long streak - four points.\r\n                        playerPointArray[_participant][j] = 4;\r\n                     } else {\r\n                         if (streak >= 3) {\r\n                            // On a short streak - two points.\r\n                            playerPointArray[_participant][j] = 2;\r\n              }\r\n                         // Not yet at a streak - standard one point.\r\n                         else { playerPointArray[_participant][j] = 1; }\r\n                     }\r\n                 }\r\n            }\r\n        }\r\n        playerGamesScored[_participant] = lastPlayed;\r\n    }\r\n\r\n    // Invoke this function to get *everyone* up to date score-wise.\r\n    // This is probably best used at the end of the tournament, to ensure\r\n    // that prizes are awarded to the correct addresses.\r\n    // Note: this is going to be VERY gas-intensive. Use it if you're desperate\r\n    //         to see how you square up against everyone else if they're slow to\r\n    //         update their own scores. Alternatively, if there's just one or two\r\n    //         stragglers, you can just call updateScore for them alone.\r\n    function updateAllScores()\r\n        public\r\n    {\r\n        uint allPlayers = playerList.length;\r\n        for (uint i = 0; i < allPlayers; i++) {\r\n            address _toScore = playerList[i];\r\n            emit StartAutoScoring(_toScore);\r\n            updateScore(_toScore);\r\n        }\r\n    }\r\n\r\n    // Which game ID has a player last computed their score up to\r\n    //   using the updateScore function?\r\n    function playerLastScoredGame(address _player)\r\n        public\r\n        view\r\n        returns (int8)\r\n    {\r\n        return playerGamesScored[_player];\r\n    }\r\n\r\n    // Is a player registered?\r\n    function playerIsRegistered(address _player)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return playerRegistered[_player];\r\n    }\r\n\r\n    // What was the official result of a game?\r\n    function correctResult(int8 _gameID)\r\n        public\r\n        view\r\n        returns (string)\r\n    {\r\n        return gameResult[_gameID];\r\n    }\r\n\r\n    // What was the caller's prediction for a given game?\r\n    function playerGuess(int8 _gameID)\r\n        public\r\n        view\r\n        returns (string)\r\n    {\r\n        return playerPredictions[msg.sender][_gameID];\r\n    }\r\n\r\n    // Lets us calculate what a participants score would be if they ran updateScore.\r\n    // Does NOT perform any state update.\r\n    function viewScore(address _participant)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        int8                     lastPlayed     = latestGameFinished;\r\n        // Most recent game played in the tournament (sets bounds for scoring iteration).\r\n        mapping (int8 => bool)   madePrediction = playerMadePrediction[_participant];\r\n        mapping (int8 => string) playerGuesses  = playerPredictions[_participant];\r\n        uint internalResult = 0;\r\n        uint internalStreak = 0;\r\n        for (int8 i = 0; i < lastPlayed; i++) {\r\n            uint j = uint(i);\r\n            uint k = j.add(1);\r\n            uint streak = internalStreak;\r\n\r\n            if (!madePrediction[int8(k)]) {\r\n                internalStreak = 0;\r\n            } else {\r\n                string storage playerResult = playerGuesses[int8(k)];\r\n                string storage actualResult = gameResult[int8(k)];\r\n                bool correctGuess = equalStrings(playerResult, actualResult);\r\n                 if (!correctGuess) {\r\n                    internalStreak = 0;\r\n                 } else {\r\n                     // The guess was right.\r\n                     internalStreak++;\r\n                     streak++;\r\n                     if (streak >= 5) {\r\n                         // On a long streak - four points.\r\n                        internalResult += 4;\r\n                     } else {\r\n                         if (streak >= 3) {\r\n                            // On a short streak - two points.\r\n                            internalResult += 2;\r\n              }\r\n                         // Not yet at a streak - standard one point.\r\n                         else { internalResult += 1; }\r\n                     }\r\n                 }\r\n            }\r\n        }\r\n        return internalResult;\r\n    }\r\n\r\n    /* ADMINISTRATOR FUNCTIONS FOR COMPETITION MAINTENANCE */\r\n\r\n    modifier isAdministrator() {\r\n        address _sender = msg.sender;\r\n        if (_sender == administrator) {\r\n            _;\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function _btcToken(address _tokenContract) private pure returns (bool) {\r\n        return _tokenContract == BTCTKNADDR; // Returns \"true\" if this is the 0xBTC Token Contract\r\n    }\r\n    \r\n    // As new fixtures become known through progression or elimination, they're added here.\r\n    function addNewGame(string _opponents, int8 _gameID)\r\n        isAdministrator\r\n        public {\r\n            worldCupGameID[_opponents] = _gameID;\r\n    }\r\n\r\n    // When the result of a game is known, enter the result.\r\n    function logResult(int8 _gameID, string _winner)\r\n        isAdministrator\r\n        public {\r\n        require((int8(0) < _gameID) && (_gameID <= 64)\r\n             && _gameID == latestGameFinished + 1);\r\n        // No draws allowed after the qualification stage.\r\n        if (_gameID > 48 && equalStrings(_winner, \"DRAW\")) {\r\n            revert();\r\n        } else {\r\n            require(!gameFinished[_gameID]);\r\n            gameFinished [_gameID] = true;\r\n            gameResult   [_gameID] = _winner;\r\n            latestGameFinished     = _gameID;\r\n            assert(gameFinished[_gameID]);\r\n        }\r\n    }\r\n\r\n    // Concludes the tournament and issues the prizes, then self-destructs.\r\n    function concludeTournament(address _first   // 40% Ether.\r\n                              , address _second  // 30% Ether.\r\n                              , address _third   // 20% Ether.\r\n                              , address _fourth) // 10% Ether.\r\n        isAdministrator\r\n        public\r\n    {\r\n        // Don't hand out prizes until the final's... actually been played.\r\n        require(gameFinished[64]\r\n             && playerIsRegistered(_first)\r\n             && playerIsRegistered(_second)\r\n             && playerIsRegistered(_third)\r\n             && playerIsRegistered(_fourth));\r\n        // Determine 10% of the prize pool to distribute to winners.\r\n        uint tenth       = prizePool.div(10);\r\n        // Determine the prize allocations.\r\n        uint firstPrize  = tenth.mul(4);\r\n        uint secondPrize = tenth.mul(3);\r\n        uint thirdPrize  = tenth.mul(2);\r\n        // Send the first three prizes.\r\n        BTCTKN.approve(_first, firstPrize);\r\n        BTCTKN.transferFrom(address(this), _first, firstPrize);\r\n        BTCTKN.approve(_second, secondPrize);\r\n        BTCTKN.transferFrom(address(this), _second, secondPrize);\r\n        BTCTKN.approve(_third, thirdPrize);\r\n        BTCTKN.transferFrom(address(this), _third, thirdPrize);\r\n        // Send the tokens raised to Giveth.\r\n        BTCTKN.approve(givethAddress, givethPool);\r\n        BTCTKN.transferFrom(address(this), givethAddress, givethPool);\r\n        // Send the tokens assigned to developer.\r\n        BTCTKN.approve(administrator, adminPool);\r\n        BTCTKN.transferFrom(address(this), administrator, adminPool);\r\n        // Since there might be rounding errors, fourth place gets everything else.\r\n        uint fourthPrize = ((prizePool.sub(firstPrize)).sub(secondPrize)).sub(thirdPrize);\r\n        BTCTKN.approve(_fourth, fourthPrize);\r\n        BTCTKN.transferFrom(address(this), _fourth, fourthPrize);\r\n        selfdestruct(administrator);\r\n    }\r\n\r\n    // The emergency escape hatch in case something has gone wrong.\r\n    // Given the small amount of individual coins per participant, it would\r\n    // be far more expensive in gas than what's sent back if required.\r\n    // You're going to have to take it on trust that I (the dev, duh), will\r\n    // sort out refunds. Let's pray to Suarez it doesn't need pulling.\r\n    function pullRipCord()\r\n        isAdministrator\r\n        public\r\n    {\r\n        uint totalPool = (prizePool.add(givethPool)).add(adminPool);\r\n        BTCTKN.approve(administrator, totalPool);\r\n        BTCTKN.transferFrom(address(this), administrator, totalPool);\r\n        selfdestruct(administrator);\r\n    }\r\n\r\n   /* INTERNAL FUNCTIONS */\r\n\r\n    // Gateway check - did you send exactly the right amount?\r\n    function _isCorrectBuyin(uint _buyin)\r\n        private\r\n        pure\r\n        returns (bool) {\r\n        return _buyin == entryFee;\r\n    }\r\n\r\n    // Internal comparison between strings, returning 0 if equal, 1 otherwise.\r\n    function compare(string _a, string _b)\r\n        private\r\n        pure\r\n        returns (int)\r\n    {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    /// Compares two strings and returns true if and only if they are equal.\r\n    function equalStrings(string _a, string _b) pure private returns (bool) {\r\n        return compare(_a, _b) == 0;\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function addint16(int16 a, int16 b) internal pure returns (int16) {\r\n        int16 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function addint256(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"int8\"},{\"name\":\"_winner\",\"type\":\"string\"}],\"name\":\"logResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"calculateScore\",\"outputs\":[{\"name\":\"\",\"type\":\"int16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameResultsLogged\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAllScores\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"int8\"}],\"name\":\"correctResult\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"int8\"}],\"name\":\"playerGuess\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTCTKN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pullRipCord\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"showPlayerScores\",\"outputs\":[{\"name\":\"\",\"type\":\"int8[64]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_first\",\"type\":\"address\"},{\"name\":\"_second\",\"type\":\"address\"},{\"name\":\"_third\",\"type\":\"address\"},{\"name\":\"_fourth\",\"type\":\"address\"}],\"name\":\"concludeTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"seekApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"playerIsRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"viewScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"int8\"},{\"name\":\"_prediction\",\"type\":\"string\"}],\"name\":\"makePrediction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"updateScore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"playerLastScoredGame\",\"outputs\":[{\"name\":\"\",\"type\":\"int8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_opponents\",\"type\":\"string\"},{\"name\":\"_gameID\",\"type\":\"int8\"}],\"name\":\"addNewGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_gameID\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"_prediction\",\"type\":\"string\"}],\"name\":\"PlayerLoggedPrediction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_lastGamePlayed\",\"type\":\"int256\"}],\"name\":\"PlayerUpdatedScore\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_gameID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_myGuess\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_result\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_correct\",\"type\":\"bool\"}],\"name\":\"Comparison\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"StartAutoScoring\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"StartScoring\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"DidNotPredict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"RipcordRefund\",\"type\":\"event\"}]","ContractName":"ZeroBTCWorldCup","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://29dc6d800ada03b8b942bc78fe37033ecc54baffc4c13bee2753e52296d9b31b"}]}