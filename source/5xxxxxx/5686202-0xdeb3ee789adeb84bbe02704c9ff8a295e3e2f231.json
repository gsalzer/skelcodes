{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n\r\n * This is BreezeCoin contract\r\n\r\n */\r\n\r\n \r\n\r\n/**\r\n\r\n * Defining basic ERC20 interface. Standard ERC20 interface functions.\r\n\r\n * Please check https://github.com/ethereum/EIPs/issues/179\r\n\r\n */\r\n\r\ncontract ERC20Basic {\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n}\r\n\r\n/**\r\n\r\n * Defining ERC20 interface. This functions are standard for every token.\r\n\r\n * Please check https://github.com/ethereum/EIPs/issues/20\r\n\r\n */\r\n\r\ncontract ERC20 is ERC20Basic {\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\n/**\r\n\r\n *OpenZeppelin SafeMath library to make the contract secure.\r\n\r\n */\r\n\r\nlibrary SafeMath {\r\n\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n\r\n            return 0;\r\n\r\n        }\r\n\r\n        uint256 c = a * b;\r\n\r\n        assert(c / a == b);\r\n\r\n        return c;\r\n\r\n    }\r\n\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n\r\n    }\r\n\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n\r\n    }\r\n\r\n\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        uint256 c = a + b;\r\n\r\n        assert(c >= a);\r\n\r\n        return c;\r\n\r\n    }\r\n\r\n}\r\n\r\n/**\r\n\r\n * Defining BasicToken with\r\n\r\n * fucntions of check total supply of the token, token transfer and check balance\r\n\r\n * of the input address. These functions are standard for every basic token.\r\n\r\n */\r\n\r\ncontract BasicToken is ERC20Basic {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n\r\n\r\n    uint256 totalSupply_;\r\n\r\n\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n\r\n        return totalSupply_;\r\n\r\n    }\r\n\r\n\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n\r\n        require(_to != address(0));\r\n\r\n        require(_value <= balances[msg.sender]);\r\n\r\n\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n\r\n        return balances[_owner];\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n/**\r\n\r\n * Defining StandardToken with\r\n\r\n * approval function. These functions are standard for every token.\r\n\r\n * Please check https://github.com/ethereum/EIPs/issues/20\r\n\r\n */\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\r\n        require(_to != address(0));\r\n\r\n        require(_value <= balances[_from]);\r\n\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n\r\n        return allowed[_owner][_spender];\r\n\r\n    }\r\n\r\n\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n\r\n        if (_subtractedValue > oldValue) {\r\n\r\n            allowed[msg.sender][_spender] = 0;\r\n\r\n        } else {\r\n\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n\r\n * Defining ownershipTransfer\r\n\r\n * function. Function takes the new address and transfer the ownership.\r\n\r\n *\r\n\r\n */\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n\r\n\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n\r\n\r\n\r\n    function Ownable() public {\r\n\r\n        owner = msg.sender;\r\n\r\n    }\r\n\r\n\r\n\r\n    modifier onlyOwner() {\r\n\r\n        require(msg.sender == owner);\r\n\r\n        _;\r\n\r\n    }\r\n\r\n\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n\r\n        require(newOwner != address(0));\r\n\r\n        emit OwnershipTransferred(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n/**\r\n\r\n * Creating BreezeCoin.\r\n\r\n * BreezeCoin calls the contracts StandardToken and ownable.\r\n\r\n */\r\n\r\ncontract BreezeCoin is StandardToken, Ownable {\r\n\r\n\r\n\r\n    string public constant name = \"BreezeCoin\";\r\n\r\n\r\n\r\n    string public constant symbol = \"BRZC\";\r\n\r\n\r\n\r\n    uint256 public constant decimals = 18;\r\n\r\n\r\n\r\n    bool public released = false;\r\n\r\n    event Release();\r\n\r\n    address public holder;\r\n\r\n    address private wallet1;\r\n    address private wallet2;\r\n    address private team_tips;\r\n    address private Reserve;\r\n/** \r\n * This modifier allows only owner of the token and holder of the token call a function.\r\n */\r\n    modifier isReleased () {\r\n\r\n        require(released || msg.sender == holder || msg.sender == owner);\r\n\r\n        _;\r\n\r\n    }\r\n\r\n\r\n\r\n    function BreezeCoin() public {\r\n\r\n        owner = 0xE601Bb5Ef5Ca433e6B467a5fc8453dcACE3974De;\r\n\r\n        wallet1 = 0x5a86671071Ad67f2DF02c821e587BCe5B8e26C38; //early investors\r\n\r\n        wallet2 = 0x25b25f5dE7C81b14DEf6db5B65107853687702EC; //manager\r\n\r\n        team_tips =  0x6FcF24c918631Bb385DeeDC6d01e8f68293E2641; //team tips\r\n\r\n        Reserve =  0x3d4Bd578291737fAED39bA3F20F32DF25111D724; //Reserve\r\n\r\n        holder = 0x2bb3a4f80bFb939716E6d85799116feB1906748B; //ico coins holder\r\n\r\n        totalSupply_ = 200000000 * (10 ** decimals); // our total supply is 200 million\r\n\r\n        balances[holder] = 30000000* (10 ** decimals); //ico wallet holds 30 million\r\n\r\n        balances[wallet1] = 10000000* (10 ** decimals);\r\n        balances[wallet2] = 1250000* (10 ** decimals);\r\n        balances[team_tips] = 8750000* (10 ** decimals);\r\n        balances[Reserve] = 150000000* (10 ** decimals);\r\n\r\n\r\n        emit Transfer(0x0, holder, 30000000* (10 ** decimals)); // creating token out of thin air to ICO holder account address.\r\n        emit Transfer(0x0, wallet1, 10000000* (10 ** decimals)); // creating token out of thin air to team wallet1 account address.\r\n        emit Transfer(0x0, team_tips, 8750000* (10 ** decimals)); // creating token out of thin air to team tips account address.\r\n        emit Transfer(0x0, wallet2, 1250000* (10 ** decimals)); // creating token out of thin air to wallet2 account address.\r\n        emit Transfer(0x0, Reserve, 150000000* (10 ** decimals)); // creating token out of thin air to reserve account address.\r\n\r\n\r\n\r\n        \r\n\r\n    }\r\n\r\n/** \r\n * Tokens are first not released. This function can be called only by owner. This function releases the tokens and allow token transfers.\r\n */\r\n\r\n    function release() onlyOwner public returns (bool) {\r\n\r\n        require(!released);\r\n\r\n        released = true;\r\n\r\n        emit Release();\r\n\r\n\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    function getOwner() public view returns (address) {\r\n\r\n        return owner;\r\n\r\n    }\r\n\r\n\r\n/** \r\n * These functions allow users to use transfer and approve functions if the token is released.\r\n */\r\n    function transfer(address _to, uint256 _value) public isReleased returns (bool) {\r\n\r\n        return super.transfer(_to, _value);\r\n\r\n    }\r\n\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public isReleased returns (bool) {\r\n\r\n        return super.transferFrom(_from, _to, _value);\r\n\r\n    }\r\n\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public isReleased returns (bool) {\r\n\r\n        return super.approve(_spender, _value);\r\n\r\n    }\r\n\r\n\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public isReleased returns (bool success) {\r\n\r\n        return super.increaseApproval(_spender, _addedValue);\r\n\r\n    }\r\n\r\n\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public isReleased returns (bool success) {\r\n\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n\r\n    }\r\n\r\n\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n\r\n        address oldOwner = owner;\r\n\r\n        super.transferOwnership(newOwner);\r\n\r\n\r\n\r\n        if (oldOwner != holder) {\r\n\r\n            allowed[holder][oldOwner] = 0;\r\n\r\n            emit Approval(holder, oldOwner, 0);\r\n\r\n        }\r\n\r\n\r\n\r\n        if (owner != holder) {\r\n\r\n            allowed[holder][owner] = balances[holder];\r\n\r\n            emit Approval(holder, owner, balances[holder]);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n/** Creating ICO contract\r\n * It starts on 01.06.2018 and ends on 20.06.2018 \r\n * The hard cap of the ICO is 30 million coin.\r\n */\r\n\r\ncontract BreezeCoinICO is Ownable {\r\n    uint public constant SALES_START = 1527800400; //we are defining the starting time of ICO\r\n    uint public constant SALES_END = 1529528399; //we are defining the ending time of ICO\r\n    \r\n    address public constant return_owner =0xE601Bb5Ef5Ca433e6B467a5fc8453dcACE3974De; //after ICO ends, ownership will return to creator\r\n    address public constant ICO_WALLET = 0x2bb3a4f80bFb939716E6d85799116feB1906748B; //defining ICO wallet address\r\n    address public constant COMPANY_WALLET = 0x2bb3a4f80bFb939716E6d85799116feB1906748B; //defining company wallet address\r\n    address public constant TOKEN_ADDRESS = 0xe12128D653B62F08fbED56BdeB65dB729B6691C3; //defining BreezeCoin address\r\n\r\n    uint public constant SMALLEST_TOKEN = 1* (10 ** 18); // defining the decimal \r\n    uint public constant TOKEN_PRICE = 0.001423964 ether; // BreezeCoin prize.\r\n\r\n\r\n    uint public constant SALE_MAX_CAP = 30000000 * SMALLEST_TOKEN; // defining the hardcap\r\n\r\n\r\n    uint public saleContributions; //total ETH contributed\r\n    uint public tokensPurchased; //total BreezeCoin purchased.\r\n\r\n    address public whitelistSupplier;\r\n    address public second_whitelistSupplier;\r\n    address public third_whitelistSupplier;\r\n    address public fourth_whitelistSupplier;\r\n    mapping(address => bool) public whitelistPublic;\r\n    mapping (address => uint256) public investedAmountOf;\r\n\r\n\r\n    event Contributed(address receiver, uint contribution, uint reward); // this event store address of the contributor, the amount of the contribution and token will be send.\r\n    event PublicWhitelistUpdated(address participant, bool isWhitelisted); // this event store the address of the participant and boolean value of that address. \r\n\r\n    function BreezeCoinICO() public {\r\n        whitelistSupplier = msg.sender;\r\n        second_whitelistSupplier = 0xC578FFd5629B0e89F4384b27227C2AE66Dbee843;\r\n\tthird_whitelistSupplier = 0x2bb3a4f80bFb939716E6d85799116feB1906748B;\r\n\tfourth_whitelistSupplier = 0x8aFC72dA31185182605E5b51053e96D3f48ea6ea;\r\n        owner = return_owner;\r\n    }\r\n/** \r\n * This modifier allows only whitelist suppliers call a function.\r\n */\r\n\r\n    modifier onlyWhitelistSupplier() {\r\n        require(msg.sender == whitelistSupplier || msg.sender == owner || msg.sender == second_whitelistSupplier || msg.sender == third_whitelistSupplier || msg.sender == fourth_whitelistSupplier);\r\n        _;\r\n    }\r\n\r\n    function contribute() public payable returns(bool) {\r\n        return contributeFor(msg.sender);\r\n    }\r\n/** \r\n * Main ICO function, it requires time is smaller than the ending time of ICO and bigger than starting time of ICO.\r\n * function takes participant address and the amount of the sender. And send the amount of the ETH to company wallet.\r\n * send BreezeCoin to participant from ICO wallet.\r\n */\r\n    function contributeFor(address _participant) public payable returns(bool) {\r\n        require(now < SALES_END);\r\n\t    require(now >= SALES_START);\r\n\t    if (now >= SALES_START) {\r\n            require(whitelistPublic[_participant]);\r\n        }\r\n        \r\n        uint tokensAmount = (msg.value * SMALLEST_TOKEN) / TOKEN_PRICE;\r\n        require(tokensAmount > 0);\r\n        uint totalTokens = tokensAmount;\r\n        \r\n        COMPANY_WALLET.transfer(msg.value);\r\n        tokensPurchased += totalTokens;\r\n        require(tokensPurchased <= SALE_MAX_CAP);\r\n        require(BreezeCoin(TOKEN_ADDRESS).transferFrom(ICO_WALLET, _participant, totalTokens));\r\n        saleContributions += msg.value;\r\n\t    investedAmountOf[_participant] = investedAmountOf[_participant]+msg.value;\r\n        emit Contributed(_participant, msg.value, totalTokens);\r\n        return true;\r\n    }\r\n/** \r\n * These two function can be called by only whitelist suppliers.\r\n * First function take participants wallet address and add to whitelist.\r\n * Second function take participants wallet address and remove from whitelist.\r\n */\r\n\r\n    function addToPublicWhitelist(address _participant) onlyWhitelistSupplier() public returns(bool) {\r\n        if (whitelistPublic[_participant]) {\r\n            return true;\r\n        }\r\n        whitelistPublic[_participant] = true;\r\n        emit PublicWhitelistUpdated(_participant, true);\r\n        return true;\r\n    }\r\n\r\n    function removeFromPublicWhitelist(address _participant) onlyWhitelistSupplier() public returns(bool) {\r\n        if (!whitelistPublic[_participant]) {\r\n            return true;\r\n        }\r\n        whitelistPublic[_participant] = false;\r\n        emit PublicWhitelistUpdated(_participant, false);\r\n        return true;\r\n    }\r\n/** \r\n * With this function, the token ownership will be transferred to token creator.\r\n */\r\n    function getTokenOwner() public view returns (address) {\r\n        return BreezeCoin(TOKEN_ADDRESS).getOwner();\r\n    }\r\n\r\n    function restoreTokenOwnership() public onlyOwner {\r\n        BreezeCoin(TOKEN_ADDRESS).transferOwnership(return_owner);\r\n    }\r\n\r\n    function () public payable {\r\n        contribute();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"fourth_whitelistSupplier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"contributeFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"third_whitelistSupplier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistSupplier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"removeFromPublicWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"return_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_MAX_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPANY_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALES_END\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"second_whitelistSupplier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restoreTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"addToPublicWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPurchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SMALLEST_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistPublic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALES_START\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contribution\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Contributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"PublicWhitelistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BreezeCoinICO","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ea0e7f026eda7e67ab1ad80747a80a90aef90c97d0889c9e247246ebf48a1f01"}]}