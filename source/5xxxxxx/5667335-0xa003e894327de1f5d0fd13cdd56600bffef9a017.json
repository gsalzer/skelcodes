{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\ncontract ERC20Interface {\r\n\r\n    function totalSupply() public constant returns (uint);\r\n\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n}\r\n\r\ncontract AirSwapExchangeI {\r\n    function fill(address makerAddress, uint makerAmount, address makerToken,\r\n                  address takerAddress, uint takerAmount, address takerToken,\r\n                  uint256 expiration, uint256 nonce, uint8 v, bytes32 r, bytes32 s) payable;\r\n}\r\n\r\ncontract KyberNetworkI {\r\n    function trade(\r\n        address src,\r\n        uint srcAmount,\r\n        address dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns(uint);\r\n}\r\n\r\ncontract EtherDelta {\r\n    function deposit() payable;\r\n    function withdraw(uint amount);\r\n    function depositToken(address token, uint amount);\r\n    function withdrawToken(address token, uint amount);\r\n    function balanceOf(address token, address user) constant returns (uint);\r\n    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount);\r\n    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\r\n}\r\n\r\ncontract BancorConverterI {\r\n    function quickConvert(address[] _path, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        payable\r\n        returns (uint256);\r\n}\r\n\r\n/*\r\n * Dexter connects up EtherDelta, Kyber, Airswap, Bancor so trades can be proxied and a fee levied.\r\n * The purpose of this is to backfill the sell side of order books so there is always some form of liqudity available.\r\n *\r\n * This contract was written by Arctek, for Bamboo Relay.\r\n */\r\ncontract Dexter {\r\n    address public owner;\r\n    uint256 public takerFee;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function () public payable {\r\n        // need this for ED withdrawals\r\n    }\r\n\r\n    function kill() public {\r\n        require(msg.sender == owner);\r\n\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    function setFee(uint256 _takerFee) public returns (bool success) {\r\n        require(owner == msg.sender);\r\n        require(takerFee != _takerFee);\r\n\r\n        takerFee = _takerFee;\r\n\r\n        return true;\r\n    }\r\n\r\n    function setOwner(address _owner) public returns (bool success) {\r\n        require(owner == msg.sender);\r\n        require(owner != _owner);\r\n\r\n        owner = _owner;\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdraw() public returns (bool success) {\r\n        require(owner == msg.sender);\r\n        require(address(this).balance > 0);\r\n\r\n        msg.sender.transfer(address(this).balance);\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdrawTokens(ERC20Interface erc20) public returns (bool success) {\r\n        require(owner == msg.sender);\r\n        \r\n        uint256 balance = erc20.balanceOf(this);\r\n\r\n        // Sanity check in case the contract does not do this\r\n        require(balance > 0);\r\n\r\n        require(erc20.transfer(msg.sender, balance));\r\n\r\n        return true;\r\n    }\r\n\r\n    // In case it needs to proxy later in the future\r\n    function approve(ERC20Interface erc20, address spender, uint tokens) public returns (bool success) {\r\n        require(owner == msg.sender);\r\n\r\n        require(erc20.approve(spender, tokens));\r\n\r\n        return true;\r\n    }\r\n\r\n    function tradeAirswap(\r\n        address makerAddress, \r\n        uint makerAmount, \r\n        address makerToken,\r\n        uint256 expirationFinalAmount, \r\n        uint256 nonceFee, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) \r\n        payable\r\n        returns (bool success)\r\n    {\r\n        // Fill the order, always ETH, since we can't withdraw from the user unless authorized\r\n        AirSwapExchangeI(0x8fd3121013A07C57f0D69646E86E7a4880b467b7).fill.value(msg.value)(\r\n            makerAddress, \r\n            makerAmount, \r\n            makerToken, \r\n            0x28b7d7B7608296E0Ee3d77C242F1F3ac571723E7, \r\n            msg.value, \r\n            address(0),\r\n            expirationFinalAmount, \r\n            nonceFee, \r\n            v, \r\n            r, \r\n            s\r\n        );\r\n\r\n        if (takerFee > 0) {\r\n            nonceFee = (makerAmount * takerFee) / (1 ether);\r\n\r\n            expirationFinalAmount = makerAmount - nonceFee;//;\r\n        }\r\n        else {\r\n            expirationFinalAmount = makerAmount;\r\n        }\r\n\r\n        require(ERC20Interface(makerToken).transferFrom(0x28b7d7B7608296E0Ee3d77C242F1F3ac571723E7, msg.sender, expirationFinalAmount));\r\n\r\n        return true;\r\n    }\r\n\r\n    function tradeKyber(\r\n        address dest,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns (bool success)\r\n    {\r\n        uint256 actualDestAmount = KyberNetworkI(0x964F35fAe36d75B1e72770e244F6595B68508CF5).trade.value(msg.value)(\r\n            0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee, // eth token in kyber\r\n            msg.value,\r\n            dest, \r\n            this,\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            walletId\r\n        );\r\n\r\n        uint256 transferAmount;\r\n\r\n        if (takerFee > 0) {\r\n            uint256 fee = (actualDestAmount * takerFee) / (1 ether);\r\n\r\n            transferAmount = actualDestAmount - fee;\r\n        }\r\n        else {\r\n            transferAmount = actualDestAmount;\r\n        }\r\n\r\n        require(ERC20Interface(dest).transfer(msg.sender, transferAmount));\r\n\r\n        return true;\r\n    }\r\n\r\n    function widthdrawEtherDelta(uint256 amount) public returns (bool success) {\r\n        // withdraw dust\r\n        EtherDelta etherDelta = EtherDelta(0x8d12A197cB00D4747a1fe03395095ce2A5CC6819);\r\n\r\n        etherDelta.withdraw(amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    //ed trade\r\n    function tradeEtherDelta(\r\n        address tokenGet, \r\n        uint256 amountGetFee,\r\n        address tokenGive,\r\n        uint256 amountGive, \r\n        uint256 expiresFinalAmount, \r\n        uint256 nonce, \r\n        address user, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s, \r\n        uint256 amount,\r\n        uint256 withdrawAmount\r\n    )\r\n        public\r\n        payable\r\n        returns (bool success)\r\n    {\r\n        EtherDelta etherDelta = EtherDelta(0x8d12A197cB00D4747a1fe03395095ce2A5CC6819);\r\n\r\n        // deposit\r\n        etherDelta.deposit.value(msg.value)();\r\n\r\n        // trade throws if it can't match\r\n        etherDelta.trade(\r\n            tokenGet, \r\n            amountGetFee, \r\n            tokenGive, \r\n            amountGive,\r\n            expiresFinalAmount, \r\n            nonce, \r\n            user,\r\n            v, \r\n            r, \r\n            s, \r\n            amount\r\n        );\r\n\r\n        etherDelta.withdrawToken(tokenGive, withdrawAmount);\r\n\r\n        if (takerFee > 0) {\r\n            // amountGetFee\r\n            amountGetFee = (withdrawAmount * takerFee) / (1 ether);\r\n\r\n            expiresFinalAmount = withdrawAmount - amountGetFee;\r\n        }\r\n        else {\r\n            expiresFinalAmount = withdrawAmount;\r\n        }\r\n\r\n        require(ERC20Interface(tokenGive).transfer(msg.sender, expiresFinalAmount) != false);\r\n\r\n        return true;\r\n    }\r\n\r\n    function tradeBancor(address[] _path, uint256 _amount, uint256 _minReturn, address _token)\r\n        public\r\n        payable\r\n        returns (bool success)\r\n    {\r\n        uint256 actualAmount = BancorConverterI(0xc6725aE749677f21E4d8f85F41cFB6DE49b9Db29).quickConvert.value(msg.value)(\r\n            _path,\r\n            _amount,\r\n            _minReturn\r\n        );\r\n\r\n        uint256 transferAmount;\r\n\r\n        if (takerFee > 0) {\r\n            uint256 fee = (actualAmount * takerFee) / (1 ether);\r\n\r\n            transferAmount = actualAmount - fee;\r\n        }\r\n        else {\r\n            transferAmount = actualAmount;\r\n        }\r\n\r\n        require(ERC20Interface(_token).transfer(msg.sender, transferAmount));\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"widthdrawEtherDelta\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"expirationFinalAmount\",\"type\":\"uint256\"},{\"name\":\"nonceFee\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"tradeAirswap\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGetFee\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expiresFinalAmount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"tradeEtherDelta\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"tradeBancor\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_takerFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"maxDestAmount\",\"type\":\"uint256\"},{\"name\":\"minConversionRate\",\"type\":\"uint256\"},{\"name\":\"walletId\",\"type\":\"address\"}],\"name\":\"tradeKyber\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"erc20\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Dexter","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://867d9ee0f4a1db4b5837040390cd312c5086561ce45c9fb11350ae6369750ee2"}]}