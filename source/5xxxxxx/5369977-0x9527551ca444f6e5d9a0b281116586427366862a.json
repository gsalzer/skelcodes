{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'Digitize Coin Presale' contract: https://digitizecoin.com \r\n//\r\n// Digitize Coin - DTZ: 0x664e6db4044f23c95de63ec299aaa9b39c59328d\r\n// SoftCap: 600 ether\r\n// HardCap: 4000 ether - 26668000 tokens\r\n// Tokens per 1 ether: 6667\r\n// KYC: PICOPS https://picops.parity.io\r\n//\r\n// (c) Radek Ostrowski / http://startonchain.com - The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));\r\n    owner = _newOwner;\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// RefundVault for 'Digitize Coin' project imported from:\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/crowdsale/distribution/utils/RefundVault.sol\r\n//\r\n// Radek Ostrowski / http://startonchain.com / https://digitizecoin.com \r\n// ----------------------------------------------------------------------------\r\n\r\n/**\r\n * @title RefundVault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\n * and forwarding it to destination wallet if crowdsale is successful.\r\n */\r\ncontract RefundVault is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  enum State { Active, Refunding, Closed }\r\n\r\n  mapping (address => uint256) public deposited;\r\n  address public wallet;\r\n  State public state;\r\n\r\n  event Closed();\r\n  event RefundsEnabled();\r\n  event Refunded(address indexed _beneficiary, uint256 _weiAmount);\r\n\r\n  /**\r\n   * @param _wallet Final vault address\r\n   */\r\n  function RefundVault(address _wallet) public {\r\n    require(_wallet != address(0));\r\n    wallet = _wallet;\r\n    state = State.Active;\r\n  }\r\n\r\n  /**\r\n   * @param _contributor Contributor address\r\n   */\r\n  function deposit(address _contributor) onlyOwner public payable {\r\n    require(state == State.Active);\r\n    deposited[_contributor] = deposited[_contributor].add(msg.value); \r\n  }\r\n\r\n  function close() onlyOwner public {\r\n    require(state == State.Active);\r\n    state = State.Closed;\r\n    emit Closed();\r\n    wallet.transfer(address(this).balance);\r\n  }\r\n\r\n  function enableRefunds() onlyOwner public {\r\n    require(state == State.Active);\r\n    state = State.Refunding;\r\n    emit RefundsEnabled();\r\n  }\r\n\r\n  /**\r\n   * @param _contributor Contributor address\r\n   */\r\n  function refund(address _contributor) public {\r\n    require(state == State.Refunding);\r\n    uint256 depositedValue = deposited[_contributor];\r\n    require(depositedValue > 0);\r\n    deposited[_contributor] = 0;\r\n    _contributor.transfer(depositedValue);\r\n    emit Refunded(_contributor, depositedValue);\r\n  }\r\n}\r\n\r\n/**\r\n * @title CutdownToken\r\n * @dev Some ERC20 interface methods used in this contract\r\n */\r\ncontract CutdownToken {\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title Parity PICOPS Whitelist\r\n */\r\ncontract PICOPSCertifier {\r\n    function certified(address) public constant returns (bool);\r\n}\r\n\r\n/**\r\n * @title DigitizeCoinPresale\r\n * @dev Desired amount of DigitizeCoin tokens for this sale must be allocated \r\n * to this contract address prior to the sale start\r\n */\r\ncontract DigitizeCoinPresale is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  // token being sold\r\n  CutdownToken public token;\r\n  // KYC\r\n  PICOPSCertifier public picopsCertifier;\r\n  // refund vault used to hold funds while crowdsale is running\r\n  RefundVault public vault;\r\n\r\n  // start and end timestamps where contributions are allowed (both inclusive)\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  uint256 public softCap;\r\n  bool public hardCapReached;\r\n\r\n  mapping(address => bool) public whitelist;\r\n\r\n  // how many token units a buyer gets per wei\r\n  uint256 public constant rate = 6667;\r\n\r\n  // amount of raised money in wei\r\n  uint256 public weiRaised;\r\n\r\n  // amount of total contribution for each address\r\n  mapping(address => uint256) public contributed;\r\n\r\n  // minimum amount of ether allowed, inclusive\r\n  uint256 public constant minContribution = 0.1 ether;\r\n\r\n  // maximum contribution without KYC, exclusive\r\n  uint256 public constant maxAnonymousContribution = 5 ether;\r\n\r\n  /**\r\n   * Custom events\r\n   */\r\n  event TokenPurchase(address indexed _purchaser, uint256 _value, uint256 _tokens);\r\n  event PicopsCertifierUpdated(address indexed _oldCertifier, address indexed _newCertifier);\r\n  event AddedToWhitelist(address indexed _who);\r\n  event RemovedFromWhitelist(address indexed _who);\r\n  event WithdrawnERC20Tokens(address indexed _tokenContract, address indexed _owner, uint256 _balance);\r\n  event WithdrawnEther(address indexed _owner, uint256 _balance);\r\n\r\n  // constructor\r\n  function DigitizeCoinPresale(uint256 _startTime, uint256 _durationInDays, \r\n    uint256 _softCap, address _wallet, CutdownToken _token, address _picops) public {\r\n    bool validTimes = _startTime >= now && _durationInDays > 0;\r\n    bool validAddresses = _wallet != address(0) && _token != address(0) && _picops != address(0);\r\n    require(validTimes && validAddresses);\r\n\r\n    owner = msg.sender;\r\n    startTime = _startTime;\r\n    endTime = _startTime + (_durationInDays * 1 days);\r\n    softCap = _softCap;\r\n    token = _token;\r\n    vault = new RefundVault(_wallet);\r\n    picopsCertifier = PICOPSCertifier(_picops);\r\n  }\r\n\r\n  // fallback function used to buy tokens\r\n  function () external payable {\r\n    require(validPurchase());\r\n\r\n    address purchaser = msg.sender;\r\n    uint256 weiAmount = msg.value;\r\n    uint256 chargedWeiAmount = weiAmount;\r\n    uint256 tokensAmount = weiAmount.mul(rate);\r\n    uint256 tokensDue = tokensAmount;\r\n    uint256 tokensLeft = token.balanceOf(address(this));\r\n\r\n    // if sending more then available, allocate all tokens and refund the rest of ether\r\n    if(tokensAmount > tokensLeft) {\r\n      chargedWeiAmount = tokensLeft.div(rate);\r\n      tokensDue = tokensLeft;\r\n      hardCapReached = true;\r\n    } else if(tokensAmount == tokensLeft) {\r\n      hardCapReached = true;\r\n    }\r\n\r\n    weiRaised = weiRaised.add(chargedWeiAmount);\r\n    contributed[purchaser] = contributed[purchaser].add(chargedWeiAmount);\r\n    token.transfer(purchaser, tokensDue);\r\n\r\n    // refund if appropriate\r\n    if(chargedWeiAmount < weiAmount) {\r\n      purchaser.transfer(weiAmount - chargedWeiAmount);\r\n    }\r\n    emit TokenPurchase(purchaser, chargedWeiAmount, tokensDue);\r\n\r\n    // forward funds to vault\r\n    vault.deposit.value(chargedWeiAmount)(purchaser);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether funding soft cap was reached. \r\n   * @return Whether funding soft cap was reached\r\n   */\r\n  function softCapReached() public view returns (bool) {\r\n    return weiRaised >= softCap;\r\n  }\r\n\r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public view returns (bool) {\r\n    return now > endTime || hardCapReached;\r\n  }\r\n\r\n  function hasStarted() public view returns (bool) {\r\n    return now >= startTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Contributors can claim refunds here if crowdsale is unsuccessful\r\n   */\r\n  function claimRefund() public {\r\n    require(hasEnded() && !softCapReached());\r\n\r\n    vault.refund(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev vault finalization task, called when owner calls finalize()\r\n   */\r\n  function finalize() public onlyOwner {\r\n    require(hasEnded());\r\n\r\n    if (softCapReached()) {\r\n      vault.close();\r\n    } else {\r\n      vault.enableRefunds();\r\n    }\r\n  }\r\n\r\n  // @return true if the transaction can buy tokens\r\n  function validPurchase() internal view returns (bool) {\r\n    bool withinPeriod = hasStarted() && !hasEnded();\r\n    bool validContribution = msg.value >= minContribution;\r\n    bool passKyc = picopsCertifier.certified(msg.sender);\r\n    //check if contributor can possibly go over anonymous contibution limit\r\n    bool anonymousAllowed = contributed[msg.sender].add(msg.value) < maxAnonymousContribution;\r\n    bool allowedKyc = passKyc || anonymousAllowed;\r\n    return withinPeriod && validContribution && allowedKyc;\r\n  }\r\n\r\n  // ability to set new certifier even after the sale started\r\n  function setPicopsCertifier(address _picopsCertifier) onlyOwner public  {\r\n    require(_picopsCertifier != address(picopsCertifier));\r\n    emit PicopsCertifierUpdated(address(picopsCertifier), _picopsCertifier);\r\n    picopsCertifier = PICOPSCertifier(_picopsCertifier);\r\n  }\r\n\r\n  function passedKYC(address _wallet) view public returns (bool) {\r\n    return picopsCertifier.certified(_wallet);\r\n  }\r\n\r\n  // ability to add to whitelist even after the sale started\r\n  function addToWhitelist(address[] _wallets) public onlyOwner {\r\n    for (uint i = 0; i < _wallets.length; i++) {\r\n      whitelist[_wallets[i]] = true;\r\n      emit AddedToWhitelist(_wallets[i]);\r\n    }\r\n  }\r\n\r\n  // ability to remove from whitelist even after the sale started\r\n  function removeFromWhitelist(address[] _wallets) public onlyOwner {\r\n    for (uint i = 0; i < _wallets.length; i++) {\r\n      whitelist[_wallets[i]] = false;\r\n      emit RemovedFromWhitelist(_wallets[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Allows to transfer out the ether balance that was forced into this contract, e.g with `selfdestruct`\r\n   */\r\n  function withdrawEther() onlyOwner public {\r\n    require(hasEnded());\r\n    uint256 totalBalance = address(this).balance;\r\n    require(totalBalance > 0);\r\n    owner.transfer(totalBalance);\r\n    emit WithdrawnEther(owner, totalBalance);\r\n  }\r\n  \r\n  /**\r\n   * @dev Allows to transfer out the balance of arbitrary ERC20 tokens from the contract.\r\n   * @param _token The contract address of the ERC20 token.\r\n   */\r\n  function withdrawERC20Tokens(CutdownToken _token) onlyOwner public {\r\n    require(hasEnded());\r\n    uint256 totalBalance = _token.balanceOf(address(this));\r\n    require(totalBalance > 0);\r\n    _token.transfer(owner, totalBalance);\r\n    emit WithdrawnERC20Tokens(address(_token), owner, totalBalance);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"softCapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAnonymousContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawERC20Tokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallets\",\"type\":\"address[]\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"picopsCertifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallets\",\"type\":\"address[]\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"passedKYC\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_picopsCertifier\",\"type\":\"address\"}],\"name\":\"setPicopsCertifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_durationInDays\",\"type\":\"uint256\"},{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_picops\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldCertifier\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newCertifier\",\"type\":\"address\"}],\"name\":\"PicopsCertifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"WithdrawnERC20Tokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"WithdrawnEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DigitizeCoinPresale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005ac75330000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000002086ac351052600000000000000000000000000000b1ca059d80de5acacc75874489ffdfeb3b849b49000000000000000000000000664e6db4044f23c95de63ec299aaa9b39c59328d0000000000000000000000001e2f058c43ac8965938f6e9ca286685a3e63f24e","Library":"","SwarmSource":"bzzr://0b9b1dac5e71bef17eb0e57e21de9544a7a215f852caaf0b25b3716f30c13adf"}]}