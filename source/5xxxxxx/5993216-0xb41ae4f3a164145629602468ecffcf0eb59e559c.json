{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/**\r\n * title Eliptic curve signature operations\r\n *\r\n * \r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * Recover signer address from a message by using his signature\r\n   * param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) constant returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      /* prefix might be needed for geth only\r\n      * https://github.com/ethereum/go-ethereum/issues/3731\r\n      */\r\n      bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n      hash = sha3(prefix, hash);\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * title SafeMath\r\n * Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * title Ownable\r\n * The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * Allows the current owner to transfer control of the contract to a newOwner.\r\n   * param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Контракт центральной логики\r\n */\r\n\r\ncontract MemeCore is Ownable {\r\n    using SafeMath for uint;\r\n    using ECRecovery for bytes32;\r\n\r\n    /* Мапа адрес получателя - nonce, нужно для того, чтобы нельзя было повторно запросить withdraw */\r\n    mapping (address => uint) withdrawalsNonce;\r\n\r\n    event Withdraw(address receiver, uint weiAmount);\r\n    event WithdrawCanceled(address receiver);\r\n\r\n    function() payable {\r\n        require(msg.value != 0);\r\n    }\r\n\r\n    /* Запрос на выплату от пользователя, используется в случае, если клиент делает withdraw */\r\n    function _withdraw(address toAddress, uint weiAmount) private {\r\n        // Делаем перевод получателю\r\n        toAddress.transfer(weiAmount);\r\n\r\n        Withdraw(toAddress, weiAmount);\r\n    }\r\n\r\n\r\n    /* Запрос на выплату от пользователя, используется в случае, если клиент делает withdraw */\r\n    function withdraw(uint weiAmount, bytes signedData) external {\r\n        uint256 nonce = withdrawalsNonce[msg.sender] + 1;\r\n\r\n        bytes32 validatingHash = keccak256(msg.sender, weiAmount, nonce);\r\n\r\n        // Подписывать все транзакции должен owner\r\n        address addressRecovered = validatingHash.recover(signedData);\r\n\r\n        require(addressRecovered == owner);\r\n\r\n        // Делаем перевод получателю\r\n        _withdraw(msg.sender, weiAmount);\r\n\r\n        withdrawalsNonce[msg.sender] = nonce;\r\n    }\r\n\r\n    /* Отмена withdraw */\r\n    function cancelWithdraw(){\r\n        withdrawalsNonce[msg.sender]++;\r\n\r\n        WithdrawCanceled(msg.sender);\r\n    }\r\n\r\n    /* Доступна только owner'у, используется в случае, если бэкенд делает withdraw */\r\n    function backendWithdraw(address toAddress, uint weiAmount) external onlyOwner {\r\n        require(toAddress != 0);\r\n\r\n        // Делаем перевод получателю\r\n        _withdraw(toAddress, weiAmount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"signedData\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"backendWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"WithdrawCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MemeCore","CompilerVersion":"v0.4.17+commit.bdeb9e52","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"ECRecovery:81267674b732cd1e11a017e2fe0027176b73ab53","SwarmSource":"bzzr://59214af017bcfef4d61a9500f9691a9d89c09e051af4acc6610203c5107cb71f"}]}