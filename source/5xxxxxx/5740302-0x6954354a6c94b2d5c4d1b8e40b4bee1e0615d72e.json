{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n * @title ERC721 interface\r\n * @dev see https://github.com/ethereum/eips/issues/721\r\n */\r\n\r\n/* solium-disable zeppelin/missing-natspec-comments */\r\ncontract ERC721 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n  function transfer(address _to, uint256 _tokenId) external;\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) external;\r\n  function setApprovalForAll(address _to, bool _approved) external;\r\n  function getApproved(uint256 _tokenId) public view returns (address);\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\nlibrary Strings {\r\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n      bytes memory _ba = bytes(_a);\r\n      bytes memory _bb = bytes(_b);\r\n      bytes memory _bc = bytes(_c);\r\n      bytes memory _bd = bytes(_d);\r\n      bytes memory _be = bytes(_e);\r\n      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n      bytes memory babcde = bytes(abcde);\r\n      uint k = 0;\r\n      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n      for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n      for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n      for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n      for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n      return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\ncontract ERC721SlimToken is Ownable, ERC721, ERC165, ERC721Metadata {\r\n  using SafeMath for uint256;\r\n\r\n  string public constant NAME = \"EtherLoot\";\r\n  string public constant SYMBOL = \"ETLT\";\r\n  string public tokenMetadataBaseURI = \"http://api.etherloot.moonshadowgames.com/tokenmetadata/\";\r\n\r\n  struct AddressAndTokenIndex {\r\n    address owner;\r\n    uint32 tokenIndex;\r\n  }\r\n\r\n  mapping (uint256 => AddressAndTokenIndex) private tokenOwnerAndTokensIndex;\r\n\r\n  mapping (address => uint256[]) private ownedTokens;\r\n\r\n  mapping (uint256 => address) private tokenApprovals;\r\n\r\n  mapping (address => mapping (address => bool)) private operatorApprovals;\r\n\r\n  mapping (address => bool) private approvedContractAddresses;\r\n\r\n  bool approvedContractsFinalized = false;\r\n\r\n  function implementsERC721() external pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n  function supportsInterface(\r\n    bytes4 interfaceID)\r\n    external view returns (bool)\r\n  {\r\n    return\r\n      interfaceID == this.supportsInterface.selector || // ERC165\r\n      interfaceID == 0x5b5e139f || // ERC721Metadata\r\n      interfaceID == 0x6466353c; // ERC-721\r\n  }\r\n\r\n  function name() external pure returns (string) {\r\n    return NAME;\r\n  }\r\n\r\n  function symbol() external pure returns (string) {\r\n    return SYMBOL;\r\n  }\r\n\r\n  function setTokenMetadataBaseURI(string _tokenMetadataBaseURI) external onlyOwner {\r\n    tokenMetadataBaseURI = _tokenMetadataBaseURI;\r\n  }\r\n\r\n  function tokenURI(uint256 tokenId)\r\n    external\r\n    view\r\n    returns (string infoUrl)\r\n  {\r\n    return Strings.strConcat(\r\n      tokenMetadataBaseURI,\r\n      Strings.uint2str(tokenId));\r\n  }\r\n\r\n  /**\r\n  * @notice Guarantees msg.sender is owner of the given token\r\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n  */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender, \"not owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the balance of the specified address\r\n  * @param _owner address to query the balance of\r\n  * @return uint256 representing the amount owned by the passed address\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0), \"null owner\");\r\n    return ownedTokens[_owner].length;\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the list of tokens owned by a given address\r\n  * @param _owner address to query the tokens of\r\n  * @return uint256[] representing the list of tokens owned by the passed address\r\n  */\r\n  function tokensOf(address _owner) public view returns (uint256[]) {\r\n    return ownedTokens[_owner];\r\n  }\r\n\r\n  /**\r\n  * @notice Enumerate NFTs assigned to an owner\r\n  * @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  *  `_owner` is the zero address, representing invalid NFTs.\r\n  * @param _owner An address where we are interested in NFTs owned by them\r\n  * @param _index A counter less than `balanceOf(_owner)`\r\n  * @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n    external\r\n    view\r\n    returns (uint256 _tokenId)\r\n  {\r\n    require(_index < balanceOf(_owner), \"invalid index\");\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the owner of the specified token ID\r\n  * @param _tokenId uint256 ID of the token to query the owner of\r\n  * @return owner address currently marked as the owner of the given token ID\r\n  */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\r\n    require(_owner != address(0), \"invalid owner\");\r\n    return _owner;\r\n  }\r\n\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\r\n    return (_owner != address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the approved address to take ownership of a given token ID\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved to take ownership of the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\r\n   * Checks both for specific approval and operator approval\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether transfer by msg.sender is approved for the given token ID or not\r\n   */\r\n  function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {\r\n    return\r\n      ownerOf(_tokenId) == msg.sender ||\r\n      isSpecificallyApprovedFor(msg.sender, _tokenId) ||\r\n      isApprovedForAll(ownerOf(_tokenId), msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether the msg.sender is approved for the given token ID or not\r\n   * @param _asker address of asking for approval\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether the msg.sender is approved for the given token ID or not\r\n   */\r\n  function isSpecificallyApprovedFor(address _asker, uint256 _tokenId) internal view returns (bool) {\r\n    return getApproved(_tokenId) == _asker;\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\r\n  {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n  * @notice Transfers the ownership of a given token ID to another address\r\n  * @param _to address to receive the ownership of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transfer(address _to, uint256 _tokenId)\r\n    external\r\n    onlyOwnerOf(_tokenId)\r\n  {\r\n    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Approves another address to claim for the ownership of the given token ID\r\n  * @param _to address to be approved for the given token ID\r\n  * @param _tokenId uint256 ID of the token to be approved\r\n  */\r\n  function approve(address _to, uint256 _tokenId)\r\n    external\r\n    onlyOwnerOf(_tokenId)\r\n  {\r\n    address _owner = ownerOf(_tokenId);\r\n    require(_to != _owner, \"already owns\");\r\n    if (getApproved(_tokenId) != 0 || _to != 0) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      emit Approval(_owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Enable or disable approval for a third party (\"operator\") to manage all your assets\r\n  * @dev Emits the ApprovalForAll event\r\n  * @param _to Address to add to the set of authorized operators.\r\n  * @param _approved True if the operators is approved, false to revoke approval\r\n  */\r\n  function setApprovalForAll(address _to, bool _approved)\r\n    external\r\n  {\r\n    if(_approved) {\r\n      approveAll(_to);\r\n    } else {\r\n      disapproveAll(_to);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Approves another address to claim for the ownership of any tokens owned by this account\r\n  * @param _to address to be approved for the given token ID\r\n  */\r\n  function approveAll(address _to)\r\n    public\r\n  {\r\n    require(_to != msg.sender, \"cant approve yourself\");\r\n    require(_to != address(0), \"invalid owner\");\r\n    operatorApprovals[msg.sender][_to] = true;\r\n    emit ApprovalForAll(msg.sender, _to, true);\r\n  }\r\n\r\n  /**\r\n  * @notice Removes approval for another address to claim for the ownership of any\r\n  *  tokens owned by this account.\r\n  * @dev Note that this only removes the operator approval and\r\n  *  does not clear any independent, specific approvals of token transfers to this address\r\n  * @param _to address to be disapproved for the given token ID\r\n  */\r\n  function disapproveAll(address _to)\r\n    public\r\n  {\r\n    require(_to != msg.sender, \"cant unapprove yourself\");\r\n    delete operatorApprovals[msg.sender][_to];\r\n    emit ApprovalForAll(msg.sender, _to, false);\r\n  }\r\n\r\n  /**\r\n  * @notice Claims the ownership of a given token ID\r\n  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\r\n  */\r\n  function takeOwnership(uint256 _tokenId)\r\n   external\r\n  {\r\n    require(isSenderApprovedFor(_tokenId), \"not approved\");\r\n    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Transfer a token owned by another address, for which the calling address has\r\n  *  previously been granted transfer approval by the owner.\r\n  * @param _from The address that owns the token\r\n  * @param _to The address that will take ownership of the token. Can be any address, including the caller\r\n  * @param _tokenId The ID of the token to be transferred\r\n  */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n  {\r\n    address tokenOwner = ownerOf(_tokenId);\r\n    require(isSenderApprovedFor(_tokenId) || \r\n      (approvedContractAddresses[msg.sender] && tokenOwner == tx.origin), \"not an approved sender\");\r\n    require(tokenOwner == _from, \"wrong owner\");\r\n    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Transfers the ownership of an NFT from one address to another address\r\n  * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  * operator, or the approved address for this NFT. Throws if `_from` is\r\n  * not the current owner. Throws if `_to` is the zero address. Throws if\r\n  * `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  * `onERC721Received` on `_to` and throws if the return value is not\r\n  * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n  * @param _from The current owner of the NFT\r\n  * @param _to The new owner\r\n  * @param _tokenId The NFT to transfer\r\n  * @param _data Additional data with no specified format, sent in call to `_to`\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n  {\r\n    require(_to != address(0), \"invalid target address\");\r\n    transferFrom(_from, _to, _tokenId);\r\n    if (_isContract(_to)) {\r\n      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\r\n        _from, _tokenId, _data\r\n      );\r\n      require(tokenReceiverResponse == bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")), \"invalid receiver respononse\");\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @notice Transfers the ownership of an NFT from one address to another address\r\n   * @dev This works identically to the other function with an extra data parameter,\r\n   *  except this function just sets data to \"\"\r\n   * @param _from The current owner of the NFT\r\n   * @param _to The new owner\r\n   * @param _tokenId The NFT to transfer\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n  {\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n  * @notice Approve a contract address for minting tokens and transferring tokens, when approved by the owner\r\n  * @param contractAddress The address that will be approved\r\n  */\r\n  function addApprovedContractAddress(address contractAddress) public onlyOwner\r\n  {\r\n    require(!approvedContractsFinalized);\r\n    approvedContractAddresses[contractAddress] = true;\r\n  }\r\n\r\n  /**\r\n  * @notice Unapprove a contract address for minting tokens and transferring tokens\r\n  * @param contractAddress The address that will be unapproved\r\n  */\r\n  function removeApprovedContractAddress(address contractAddress) public onlyOwner\r\n  {\r\n    require(!approvedContractsFinalized);\r\n    approvedContractAddresses[contractAddress] = false;\r\n  }\r\n\r\n  /**\r\n  * @notice Finalize the contract so it will be forever impossible to change the approved contracts list\r\n  */\r\n  function finalizeApprovedContracts() public onlyOwner {\r\n    approvedContractsFinalized = true;\r\n  }\r\n\r\n  /**\r\n  * @notice Mint token function\r\n  * @param _to The address that will own the minted token\r\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n  */\r\n  function mint(address _to, uint256 _tokenId) public {\r\n    require(\r\n      approvedContractAddresses[msg.sender] ||\r\n      msg.sender == owner, \"minter not approved\"\r\n    );\r\n    _mint(_to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Mint token function\r\n  * @param _to The address that will own the minted token\r\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n  */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0), \"invalid target address\");\r\n    require(tokenOwnerAndTokensIndex[_tokenId].owner == address(0), \"token already exists\");\r\n    _addToken(_to, _tokenId);\r\n    emit Transfer(0x0, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\r\n  * @param _from address which you want to send tokens from\r\n  * @param _to address which you want to transfer the token to\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function _clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0), \"invalid target address\");\r\n    require(_to != ownerOf(_tokenId), \"already owns\");\r\n    require(ownerOf(_tokenId) == _from, \"wrong owner\");\r\n\r\n    _clearApproval(_from, _tokenId);\r\n    _removeToken(_from, _tokenId);\r\n    _addToken(_to, _tokenId);\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to clear current approval of a given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function _clearApproval(address _owner, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _owner, \"wrong owner\");\r\n    if (tokenApprovals[_tokenId] != 0) {\r\n      tokenApprovals[_tokenId] = 0;\r\n      emit Approval(_owner, 0, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to add a token ID to the list of a given address\r\n  * @param _to address representing the new owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n  */\r\n  function _addToken(address _to, uint256 _tokenId) private {\r\n    uint256 newTokenIndex = ownedTokens[_to].length;\r\n    ownedTokens[_to].push(_tokenId);\r\n\r\n    // I don't expect anyone to own 4 billion tokens, but just in case...\r\n    require(newTokenIndex == uint256(uint32(newTokenIndex)), \"overflow\");\r\n\r\n    tokenOwnerAndTokensIndex[_tokenId] = AddressAndTokenIndex({owner: _to, tokenIndex: uint32(newTokenIndex)});\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to remove a token ID from the list of a given address\r\n  * @param _from address representing the previous owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n  */\r\n  function _removeToken(address _from, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _from, \"wrong owner\");\r\n\r\n    uint256 tokenIndex = tokenOwnerAndTokensIndex[_tokenId].tokenIndex;\r\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n\r\n    ownedTokens[_from].length--;\r\n    tokenOwnerAndTokensIndex[lastToken] = AddressAndTokenIndex({owner: _from, tokenIndex: uint32(tokenIndex)});\r\n  }\r\n\r\n  function _isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function smax256(int256 a, int256 b) internal pure returns (int256) {\r\n    return a >= b ? a : b;\r\n  }\r\n}\r\n\r\ncontract ContractAccessControl {\r\n\r\n  event ContractUpgrade(address newContract);\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  address public ceoAddress;\r\n\r\n  address public cfoAddress;\r\n\r\n  address public cooAddress;\r\n\r\n  address public withdrawalAddress;\r\n\r\n  bool public paused = false;\r\n\r\n  modifier onlyCEO() {\r\n    require(msg.sender == ceoAddress);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCFO() {\r\n    require(msg.sender == cfoAddress);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCOO() {\r\n    require(msg.sender == cooAddress);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCLevel() {\r\n    require(\r\n      msg.sender == cooAddress ||\r\n      msg.sender == ceoAddress ||\r\n      msg.sender == cfoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyCEOOrCFO() {\r\n    require(\r\n      msg.sender == cfoAddress ||\r\n      msg.sender == ceoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyCEOOrCOO() {\r\n    require(\r\n      msg.sender == cooAddress ||\r\n      msg.sender == ceoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  function setCEO(address _newCEO) external onlyCEO {\r\n    require(_newCEO != address(0));\r\n    ceoAddress = _newCEO;\r\n  }\r\n\r\n  function setCFO(address _newCFO) external onlyCEO {\r\n    require(_newCFO != address(0));\r\n    cfoAddress = _newCFO;\r\n  }\r\n\r\n  function setCOO(address _newCOO) external onlyCEO {\r\n    require(_newCOO != address(0));\r\n    cooAddress = _newCOO;\r\n  }\r\n\r\n  function setWithdrawalAddress(address _newWithdrawalAddress) external onlyCEO {\r\n    require(_newWithdrawalAddress != address(0));\r\n    withdrawalAddress = _newWithdrawalAddress;\r\n  }\r\n\r\n  function withdrawBalance() external onlyCEOOrCFO {\r\n    require(withdrawalAddress != address(0));\r\n    withdrawalAddress.transfer(this.balance);\r\n  }\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() public onlyCLevel whenNotPaused {\r\n    paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  function unpause() public onlyCEO whenPaused {\r\n    paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\ncontract CryptoBoss is ContractAccessControl {\r\n\r\n  address constant tokenContractAddress = 0xe1015a79a7d488f8fecf073b187d38c6f1a77368;\r\n  ERC721SlimToken constant tokenContract = ERC721SlimToken(tokenContractAddress);\r\n\r\n  event Participating(address indexed player, uint encounterId);\r\n  event LootClaimed(address indexed player, uint encounterId);\r\n  event DailyLootClaimed(uint day);\r\n\r\n  struct ParticipantData {\r\n    uint32 damage;\r\n    uint64 cumulativeDamage;\r\n    uint8 forgeWeaponRarity;\r\n    uint8 forgeWeaponDamagePure;\r\n    bool lootClaimed;\r\n    bool consolationPrizeClaimed;\r\n  }\r\n\r\n  struct Encounter {\r\n    mapping (address => ParticipantData) participantData;\r\n    address[] participants;\r\n  }\r\n\r\n  //encounterId is the starting block number / encounterBlockDuration\r\n  mapping (uint => Encounter) encountersById;\r\n\r\n  mapping (uint => address) winnerPerDay;\r\n  mapping (uint => mapping (address => uint)) dayToAddressToScore;\r\n  mapping (uint => bool) dailyLootClaimedPerDay;\r\n\r\n   uint constant encounterBlockDuration = 80;\r\n   uint constant blocksInADay = 5760;\r\n\r\n//   uint constant encounterBlockDuration = 20;\r\n//   uint constant blocksInADay = 60;    // must be a multiple of encounterBlockDuration\r\n\r\n  uint256 gasRefundForClaimLoot = 279032000000000;\r\n  uint256 gasRefundForClaimConsolationPrizeLoot = 279032000000000;\r\n  uint256 gasRefundForClaimLootWithConsolationPrize = 279032000000000;\r\n\r\n  uint participateFee = 0.002 ether;\r\n  uint participateDailyLootContribution = 0.001 ether;\r\n\r\n  constructor() public {\r\n\r\n    paused = false;\r\n\r\n    ceoAddress = msg.sender;\r\n    cooAddress = msg.sender;\r\n    cfoAddress = msg.sender;\r\n    withdrawalAddress = msg.sender;\r\n  }\r\n  \r\n  function setGasRefundForClaimLoot(uint256 _gasRefundForClaimLoot) external onlyCEO {\r\n      gasRefundForClaimLoot = _gasRefundForClaimLoot;\r\n  }\r\n\r\n  function setGasRefundForClaimConsolationPrizeLoot(uint256 _gasRefundForClaimConsolationPrizeLoot) external onlyCEO {\r\n      gasRefundForClaimConsolationPrizeLoot = _gasRefundForClaimConsolationPrizeLoot;\r\n  }\r\n\r\n  function setGasRefundForClaimLootWithConsolationPrize(uint256 _gasRefundForClaimLootWithConsolationPrize) external onlyCEO {\r\n      gasRefundForClaimLootWithConsolationPrize = _gasRefundForClaimLootWithConsolationPrize;\r\n  }\r\n\r\n  function setParticipateFee(uint _participateFee) public onlyCLevel {\r\n    participateFee = _participateFee;\r\n  }\r\n\r\n  function setParticipateDailyLootContribution(uint _participateDailyLootContribution) public onlyCLevel {\r\n    participateDailyLootContribution = _participateDailyLootContribution;\r\n  }\r\n\r\n  function getFirstEncounterIdFromDay(uint day) internal pure returns (uint) {\r\n    return (day * blocksInADay) / encounterBlockDuration;\r\n  }\r\n\r\n  function leaderboardEntries(uint day) public view returns\r\n    (uint etherPot, bool dailyLootClaimed, uint blockDeadline, address[] memory entryAddresses, uint[] memory entryDamages) {    \r\n\r\n    dailyLootClaimed = dailyLootClaimedPerDay[day];\r\n    blockDeadline = (((day+1) * blocksInADay) / encounterBlockDuration) * encounterBlockDuration;\r\n\r\n    uint participantCount = 0;\r\n    etherPot = 0;\r\n\r\n    for (uint encounterId = getFirstEncounterIdFromDay(day); encounterId < getFirstEncounterIdFromDay(day+1); encounterId++)\r\n    {\r\n      address[] storage participants = encountersById[encounterId].participants;\r\n      participantCount += participants.length;\r\n      etherPot += participateDailyLootContribution * participants.length;\r\n    }\r\n\r\n    entryAddresses = new address[](participantCount);\r\n    entryDamages = new uint[](participantCount);\r\n\r\n    participantCount = 0;\r\n\r\n    for (encounterId = getFirstEncounterIdFromDay(day); encounterId < getFirstEncounterIdFromDay(day+1); encounterId++)\r\n    {\r\n      participants = encountersById[encounterId].participants;\r\n      mapping (address => ParticipantData) participantData = encountersById[encounterId].participantData;\r\n      for (uint i = 0; i < participants.length; i++)\r\n      {\r\n        address participant = participants[i];\r\n        entryAddresses[participantCount] = participant;\r\n        entryDamages[participantCount] = participantData[participant].damage;\r\n        participantCount++;\r\n      }\r\n    }\r\n  }\r\n\r\n  function claimDailyLoot(uint day) public {\r\n    require(!dailyLootClaimedPerDay[day]);\r\n    require(winnerPerDay[day] == msg.sender);\r\n\r\n    uint firstEncounterId = day * blocksInADay / encounterBlockDuration;\r\n    uint firstEncounterIdTomorrow = ((day+1) * blocksInADay / encounterBlockDuration);\r\n    uint etherPot = 0;\r\n    for (uint encounterId = firstEncounterId; encounterId < firstEncounterIdTomorrow; encounterId++)\r\n    {\r\n      etherPot += participateDailyLootContribution * encountersById[encounterId].participants.length;\r\n    }\r\n\r\n    dailyLootClaimedPerDay[day] = true;\r\n\r\n    msg.sender.transfer(etherPot);\r\n\r\n    emit DailyLootClaimed(day);\r\n  }\r\n\r\n  function blockBeforeEncounter(uint encounterId) private pure returns (uint) {\r\n    return encounterId*encounterBlockDuration - 1;\r\n  }\r\n\r\n  function getEncounterDetails() public view\r\n    returns (uint encounterId, uint encounterFinishedBlockNumber, bool isParticipating, uint day, uint monsterDna) {\r\n    encounterId = block.number / encounterBlockDuration;\r\n    encounterFinishedBlockNumber = (encounterId+1) * encounterBlockDuration;\r\n    Encounter storage encounter = encountersById[encounterId];\r\n    isParticipating = (encounter.participantData[msg.sender].damage != 0);\r\n    day = (encounterId * encounterBlockDuration) / blocksInADay;\r\n    monsterDna = uint(blockhash(blockBeforeEncounter(encounterId)));\r\n  }\r\n\r\n  function getParticipants(uint encounterId) public view returns (address[]) {\r\n\r\n    Encounter storage encounter = encountersById[encounterId];\r\n    return encounter.participants;\r\n  }\r\n\r\n  function calculateWinner(uint numParticipants, Encounter storage encounter, uint blockToHash) internal view returns\r\n    (address winnerAddress, uint rand, uint totalDamageDealt) {\r\n\r\n    if (numParticipants == 0) {\r\n      return;\r\n    }\r\n\r\n    totalDamageDealt = encounter.participantData[encounter.participants[numParticipants-1]].cumulativeDamage;\r\n\r\n    rand = uint(keccak256(blockhash(blockToHash)));\r\n    uint winnerDamageValue = rand % totalDamageDealt;\r\n\r\n    uint winnerIndex = numParticipants;\r\n\r\n    // binary search for a value winnerIndex where\r\n    // winnerDamageValue < cumulativeDamage[winnerIndex] and \r\n    // winnerDamageValue >= cumulativeDamage[winnerIndex-1]\r\n\r\n    uint min = 0;\r\n    uint max = numParticipants - 1;\r\n    while(max >= min) {\r\n      uint guess = (min+max)/2;\r\n      if (guess > 0 && winnerDamageValue < encounter.participantData[encounter.participants[guess-1]].cumulativeDamage) {\r\n        max = guess-1;\r\n      }\r\n      else if (winnerDamageValue >= encounter.participantData[encounter.participants[guess]].cumulativeDamage) {\r\n        min = guess+1;\r\n      } else {\r\n        winnerIndex = guess;\r\n        break;\r\n      }\r\n\r\n    }\r\n\r\n    require(winnerIndex < numParticipants, \"error in binary search\");\r\n\r\n    winnerAddress = encounter.participants[winnerIndex];\r\n  }\r\n\r\n  function getBlockToHashForResults(uint encounterId) public view returns (uint) {\r\n      \r\n    uint blockToHash = (encounterId+1)*encounterBlockDuration - 1;\r\n    \r\n    require(block.number > blockToHash);\r\n    \r\n    uint diff = block.number - (blockToHash+1);\r\n    if (diff > 255) {\r\n        blockToHash += (diff/256)*256;\r\n    }\r\n    \r\n    return blockToHash;\r\n  }\r\n  \r\n  function getEncounterResults(uint encounterId, address player) public view returns (\r\n    address winnerAddress, uint lootTokenId, uint consolationPrizeTokenId,\r\n    bool lootClaimed, uint damageDealt, uint totalDamageDealt) {\r\n\r\n    uint blockToHash = getBlockToHashForResults(encounterId);\r\n\r\n    Encounter storage encounter = encountersById[encounterId];\r\n    uint numParticipants = encounter.participants.length;\r\n    if (numParticipants == 0) {\r\n      return (address(0), 0, 0, false, 0, 0);\r\n    }\r\n\r\n    damageDealt = encounter.participantData[player].damage;\r\n\r\n    uint rand;\r\n    (winnerAddress, rand, totalDamageDealt) = calculateWinner(numParticipants, encounter, blockToHash);\r\n\r\n    lootTokenId = constructWeaponTokenIdForWinner(rand, numParticipants);\r\n\r\n    lootClaimed = true;\r\n    consolationPrizeTokenId = getConsolationPrizeTokenId(encounterId, player);\r\n\r\n    if (consolationPrizeTokenId != 0) {\r\n        lootClaimed = encounter.participantData[player].consolationPrizeClaimed;\r\n        \r\n        // This way has problems:\r\n    //   lootClaimed = tokenContract.exists(consolationPrizeTokenId);\r\n    }\r\n  }\r\n  \r\n    function getLootClaimed(uint encounterId, address player) external view returns (bool, bool) {\r\n        ParticipantData memory participantData = encountersById[encounterId].participantData[player];\r\n        return (\r\n            participantData.lootClaimed,\r\n            participantData.consolationPrizeClaimed\r\n        );\r\n    }\r\n\r\n  function constructWeaponTokenIdForWinner(uint rand, uint numParticipants) pure internal returns (uint) {\r\n\r\n    uint rarity = 0;\r\n    if (numParticipants > 1) rarity = 1;\r\n    if (numParticipants > 10) rarity = 2;\r\n\r\n    return constructWeaponTokenId(rand, rarity, 0);\r\n  }\r\n\r\n  function getWeaponRarityFromTokenId(uint tokenId) pure internal returns (uint) {\r\n    return tokenId & 0xff;\r\n  }  \r\n\r\n  // damageType: 0=physical 1=magic 2=water 3=earth 4=fire\r\n  function getWeaponDamageFromTokenId(uint tokenId, uint damageType) pure internal returns (uint) {\r\n    return ((tokenId >> (64 + damageType*8)) & 0xff);\r\n  }  \r\n\r\n  function getPureWeaponDamageFromTokenId(uint tokenId) pure internal returns (uint) {\r\n    return ((tokenId >> (56)) & 0xff);\r\n  }  \r\n\r\n  function getMonsterDefenseFromDna(uint monsterDna, uint damageType) pure internal returns (uint) {\r\n    return ((monsterDna >> (64 + damageType*8)) & 0xff);\r\n  }\r\n\r\n\r\n  // constant lookup table\r\n\r\n  bytes10 constant elementsAvailableForCommon =     hex\"01020408100102040810\";   // Each byte has 1 bit set\r\n  bytes10 constant elementsAvailableForRare =       hex\"030506090A0C11121418\";   // Each byte has 2 bits set\r\n  bytes10 constant elementsAvailableForEpic =       hex\"070B0D0E131516191A1C\";   // 3 bits\r\n  bytes10 constant elementsAvailableForLegendary =  hex\"0F171B1D1E0F171B1D1E\";   // 4 bits\r\n\r\n  // rarity 0: common (1 element)\r\n  // rarity 1: rare (2 elements)\r\n  // rarity 2: epic (3 elements)\r\n  // rarity 3: legendary (4 elements)\r\n  // rarity 4: ultimate (all 5 elements)\r\n  function constructWeaponTokenId(uint rand, uint rarity, uint pureDamage) pure internal returns (uint) {\r\n    uint lootTokenId = (rand & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000) + rarity;\r\n\r\n    bytes10[4] memory elementsAvailablePerRarity = [\r\n      elementsAvailableForCommon,\r\n      elementsAvailableForRare,\r\n      elementsAvailableForEpic,\r\n      elementsAvailableForLegendary\r\n      ];\r\n\r\n    bytes10 elementsAvailable = elementsAvailablePerRarity[rarity];\r\n    // Select a random byte in elementsAvailable\r\n    uint8 elementsUsed = uint8(elementsAvailable[((rand >> 104) & 0xffff) % 10]);\r\n    // The bits of elementsUsed represent which elements we will allow this weapon to deal damage for\r\n    // Zero out the other element damages\r\n    for (uint i = 0; i < 5; i++) {\r\n      if ((elementsUsed & (1 << i)) == 0) {\r\n        lootTokenId = lootTokenId & ~(0xff << (64 + i*8));\r\n      }\r\n    }\r\n\r\n    pureDamage = Math.min256(100, pureDamage);\r\n\r\n    lootTokenId = lootTokenId | (pureDamage << 56);\r\n\r\n    return lootTokenId;\r\n  }\r\n\r\n  function weaponTokenIdToDamageForEncounter(uint weaponTokenId, uint encounterId) view internal returns (uint) {\r\n    uint monsterDna = uint(blockhash(encounterId*encounterBlockDuration - 1));\r\n\r\n    uint physicalDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 0)) - int(getMonsterDefenseFromDna(monsterDna, 0))));\r\n    uint fireDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 4)) - int(getMonsterDefenseFromDna(monsterDna, 4))));\r\n    uint earthDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 3)) - int(getMonsterDefenseFromDna(monsterDna, 3))));\r\n    uint waterDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 2)) - int(getMonsterDefenseFromDna(monsterDna, 2))));\r\n    uint magicDamage = uint(Math.smax256(0, int(getWeaponDamageFromTokenId(weaponTokenId, 1)) - int(getMonsterDefenseFromDna(monsterDna, 1))));\r\n    uint pureDamage = getPureWeaponDamageFromTokenId(weaponTokenId);\r\n\r\n    uint damage = physicalDamage + fireDamage + earthDamage + waterDamage + magicDamage + pureDamage;\r\n    damage = Math.max256(1, damage);\r\n\r\n    return damage;\r\n  }\r\n\r\n  function forgeWeaponPureDamage(uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4)\r\n    internal pure returns (uint8) {\r\n    if (sacrificeTokenId1 == 0) {\r\n      return 0;\r\n    }\r\n    return uint8(Math.min256(255,\r\n        getPureWeaponDamageFromTokenId(sacrificeTokenId1) +\r\n        getPureWeaponDamageFromTokenId(sacrificeTokenId2) +\r\n        getPureWeaponDamageFromTokenId(sacrificeTokenId3) +\r\n        getPureWeaponDamageFromTokenId(sacrificeTokenId4)));\r\n  }\r\n\r\n  function forgeWeaponRarity(uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4)\r\n    internal pure returns (uint8) {\r\n    if (sacrificeTokenId1 == 0) {\r\n      return 0;\r\n    }\r\n    uint rarity = getWeaponRarityFromTokenId(sacrificeTokenId1);\r\n    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId2));\r\n    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId3));\r\n    rarity = Math.min256(rarity, getWeaponRarityFromTokenId(sacrificeTokenId4)) + 1;\r\n    require(rarity < 5, \"cant forge an ultimate weapon\");\r\n    return uint8(rarity);\r\n  }\r\n\r\n  function participate(uint encounterId, uint weaponTokenId,\r\n    uint sacrificeTokenId1, uint sacrificeTokenId2, uint sacrificeTokenId3, uint sacrificeTokenId4) public whenNotPaused payable {\r\n    require(msg.value >= participateFee);  // half goes to dev, half goes to ether pot\r\n\r\n    require(encounterId == block.number / encounterBlockDuration, \"a new encounter is available\");\r\n\r\n    Encounter storage encounter = encountersById[encounterId];\r\n\r\n    require(encounter.participantData[msg.sender].damage == 0, \"you are already participating\");\r\n\r\n    uint damage = 1;\r\n    // weaponTokenId of zero means they are using their fists\r\n    if (weaponTokenId != 0) {\r\n      require(tokenContract.ownerOf(weaponTokenId) == msg.sender, \"you dont own that weapon\");\r\n      damage = weaponTokenIdToDamageForEncounter(weaponTokenId, encounterId);\r\n    }\r\n\r\n    uint day = (encounterId * encounterBlockDuration) / blocksInADay;\r\n    uint newScore = dayToAddressToScore[day][msg.sender] + damage;\r\n    dayToAddressToScore[day][msg.sender] = newScore;\r\n\r\n    if (newScore > dayToAddressToScore[day][winnerPerDay[day]] &&\r\n      winnerPerDay[day] != msg.sender) {\r\n      winnerPerDay[day] = msg.sender;\r\n    }\r\n\r\n    uint cumulativeDamage = damage;\r\n    if (encounter.participants.length > 0) {\r\n      cumulativeDamage = cumulativeDamage + encounter.participantData[encounter.participants[encounter.participants.length-1]].cumulativeDamage;\r\n    }\r\n\r\n    if (sacrificeTokenId1 != 0) {\r\n\r\n      // the requires in the transfer functions here will verify\r\n      // that msg.sender owns all of these tokens and they are unique\r\n\r\n      // burn all four input tokens\r\n\r\n      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId1);\r\n      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId2);\r\n      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId3);\r\n      tokenContract.transferFrom(msg.sender, 1, sacrificeTokenId4);\r\n    }\r\n\r\n    encounter.participantData[msg.sender] = ParticipantData(uint32(damage), uint64(cumulativeDamage), \r\n      forgeWeaponRarity(sacrificeTokenId1, sacrificeTokenId2, sacrificeTokenId3, sacrificeTokenId4),\r\n      forgeWeaponPureDamage(sacrificeTokenId1, sacrificeTokenId2, sacrificeTokenId3, sacrificeTokenId4),\r\n      false, false);\r\n    encounter.participants.push(msg.sender);\r\n\r\n    emit Participating(msg.sender, encounterId);\r\n  }\r\n\r\n  function claimLoot(uint encounterId, address player) public whenNotPaused {\r\n    address winnerAddress;\r\n    uint lootTokenId;\r\n    uint consolationPrizeTokenId;\r\n    (winnerAddress, lootTokenId, consolationPrizeTokenId, , ,,) = getEncounterResults(encounterId, player);\r\n    require(winnerAddress == player, \"player is not the winner\");\r\n\r\n    ParticipantData storage participantData = encountersById[encounterId].participantData[player];\r\n\r\n    require(!participantData.lootClaimed, \"loot already claimed\");\r\n\r\n    participantData.lootClaimed = true;\r\n    tokenContract.mint(player, lootTokenId);\r\n\r\n    // The winner also gets a consolation prize\r\n    // It's possible he called claimConsolationPrizeLoot first, so allow that\r\n\r\n    require(consolationPrizeTokenId != 0, \"consolation prize invalid\");\r\n\r\n    if (!participantData.consolationPrizeClaimed) {\r\n        participantData.consolationPrizeClaimed = true;\r\n        // this will throw if the token already exists\r\n        tokenContract.mint(player, consolationPrizeTokenId);\r\n\r\n        // refund gas\r\n        msg.sender.transfer(gasRefundForClaimLootWithConsolationPrize);\r\n    } else {\r\n        \r\n        // refund gas\r\n        msg.sender.transfer(gasRefundForClaimLoot);\r\n    }\r\n\r\n    emit LootClaimed(player, encounterId);\r\n  }\r\n\r\n  function getConsolationPrizeTokenId(uint encounterId, address player) internal view returns (uint) {\r\n\r\n    ParticipantData memory participantData = encountersById[encounterId].participantData[player];\r\n    if (participantData.damage == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint blockToHash = getBlockToHashForResults(encounterId);\r\n\r\n    uint rand = uint(keccak256(uint(blockhash(blockToHash)) ^ uint(player)));\r\n\r\n    if (participantData.forgeWeaponRarity != 0) {\r\n      return constructWeaponTokenId(rand, participantData.forgeWeaponRarity, participantData.forgeWeaponDamagePure);\r\n    }\r\n\r\n    return constructWeaponTokenId(rand, 0, 0);\r\n  }\r\n\r\n  function claimConsolationPrizeLoot(uint encounterId, address player) public whenNotPaused {\r\n    uint lootTokenId = getConsolationPrizeTokenId(encounterId, player);\r\n    require(lootTokenId != 0, \"player didnt participate\");\r\n\r\n    ParticipantData storage participantData = encountersById[encounterId].participantData[player];\r\n    require(!participantData.consolationPrizeClaimed, \"consolation prize already claimed\");\r\n\r\n    participantData.consolationPrizeClaimed = true;\r\n    tokenContract.mint(player, lootTokenId);\r\n\r\n    msg.sender.transfer(gasRefundForClaimConsolationPrizeLoot);\r\n\r\n    emit LootClaimed(player, encounterId);\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return tokenContract.balanceOf(_owner);\r\n  }\r\n\r\n  function tokensOf(address _owner) public view returns (uint256[]) {\r\n    return tokenContract.tokensOf(_owner);\r\n  }\r\n\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n    external\r\n    view\r\n    returns (uint256 _tokenId)\r\n  {\r\n    return tokenContract.tokenOfOwnerByIndex(_owner, _index);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasRefundForClaimLootWithConsolationPrize\",\"type\":\"uint256\"}],\"name\":\"setGasRefundForClaimLootWithConsolationPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasRefundForClaimConsolationPrizeLoot\",\"type\":\"uint256\"}],\"name\":\"setGasRefundForClaimConsolationPrizeLoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"encounterId\",\"type\":\"uint256\"}],\"name\":\"getBlockToHashForResults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWithdrawalAddress\",\"type\":\"address\"}],\"name\":\"setWithdrawalAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"claimDailyLoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"encounterId\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"claimConsolationPrizeLoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participateDailyLootContribution\",\"type\":\"uint256\"}],\"name\":\"setParticipateDailyLootContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"encounterId\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getEncounterResults\",\"outputs\":[{\"name\":\"winnerAddress\",\"type\":\"address\"},{\"name\":\"lootTokenId\",\"type\":\"uint256\"},{\"name\":\"consolationPrizeTokenId\",\"type\":\"uint256\"},{\"name\":\"lootClaimed\",\"type\":\"bool\"},{\"name\":\"damageDealt\",\"type\":\"uint256\"},{\"name\":\"totalDamageDealt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participateFee\",\"type\":\"uint256\"}],\"name\":\"setParticipateFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasRefundForClaimLoot\",\"type\":\"uint256\"}],\"name\":\"setGasRefundForClaimLoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"encounterId\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"claimLoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"encounterId\",\"type\":\"uint256\"},{\"name\":\"weaponTokenId\",\"type\":\"uint256\"},{\"name\":\"sacrificeTokenId1\",\"type\":\"uint256\"},{\"name\":\"sacrificeTokenId2\",\"type\":\"uint256\"},{\"name\":\"sacrificeTokenId3\",\"type\":\"uint256\"},{\"name\":\"sacrificeTokenId4\",\"type\":\"uint256\"}],\"name\":\"participate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"encounterId\",\"type\":\"uint256\"}],\"name\":\"getParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"encounterId\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getLootClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEncounterDetails\",\"outputs\":[{\"name\":\"encounterId\",\"type\":\"uint256\"},{\"name\":\"encounterFinishedBlockNumber\",\"type\":\"uint256\"},{\"name\":\"isParticipating\",\"type\":\"bool\"},{\"name\":\"day\",\"type\":\"uint256\"},{\"name\":\"monsterDna\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"leaderboardEntries\",\"outputs\":[{\"name\":\"etherPot\",\"type\":\"uint256\"},{\"name\":\"dailyLootClaimed\",\"type\":\"bool\"},{\"name\":\"blockDeadline\",\"type\":\"uint256\"},{\"name\":\"entryAddresses\",\"type\":\"address[]\"},{\"name\":\"entryDamages\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"encounterId\",\"type\":\"uint256\"}],\"name\":\"Participating\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"encounterId\",\"type\":\"uint256\"}],\"name\":\"LootClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"DailyLootClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"}]","ContractName":"CryptoBoss","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://33a778ef341459a4ce5d08c09bade27b21c732b3568befa52524b84331a49a28"}]}