{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Admin is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct Tier {\r\n        uint256 amountInCenter;\r\n        uint256 amountInOuter;\r\n        uint256 priceInCenter;\r\n        uint256 priceInOuter;\r\n        uint256 soldInCenter;\r\n        uint256 soldInOuter;\r\n        bool filledInCenter;\r\n        bool filledInOuter;\r\n    }\r\n\r\n    Tier[] public tiers;\r\n\r\n    bool public halted;\r\n    uint256 public logoPrice = 0;\r\n    uint256 public logoId;\r\n    address public platformWallet;\r\n\r\n    uint256 public feeForFirstArtWorkChangeRequest = 0 ether;\r\n    uint256 public feeForArtWorkChangeRequest = 0.2 ether;\r\n    uint256 public minResalePercentage = 15;\r\n\r\n    mapping(address => bool) public globalAdmins;\r\n    mapping(address => bool) public admins;\r\n    mapping(address => bool) public signers;\r\n\r\n    event Halted(bool _halted);\r\n\r\n    modifier onlyAdmin() {\r\n        require(true == admins[msg.sender] || true == globalAdmins[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyGlobalAdmin() {\r\n        require(true == globalAdmins[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier notHalted() {\r\n        require(halted == false);\r\n        _;\r\n    }\r\n\r\n    function addGlobalAdmin(address _address) public onlyOwner() {\r\n        globalAdmins[_address] = true;\r\n    }\r\n\r\n    function removeGlobalAdmin(address _address) public onlyOwner() {\r\n        globalAdmins[_address] = false;\r\n    }\r\n\r\n    function addAdmin(address _address) public onlyGlobalAdmin() {\r\n        admins[_address] = true;\r\n    }\r\n\r\n    function removeAdmin(address _address) public onlyGlobalAdmin() {\r\n        admins[_address] = true;\r\n    }\r\n\r\n    function setSigner(address _address, bool status) public onlyGlobalAdmin() {\r\n        signers[_address] = status;\r\n    }\r\n\r\n    function setLogoPrice(uint256 _price) public onlyGlobalAdmin() {\r\n        logoPrice = _price;\r\n    }\r\n\r\n    function setFeeForFirstArtWorkChangeRequest(uint256 _fee) public onlyGlobalAdmin() {\r\n        feeForFirstArtWorkChangeRequest = _fee;\r\n    }\r\n\r\n    function setFeeForArtWorkChangeRequest(uint256 _fee) public onlyGlobalAdmin() {\r\n        feeForArtWorkChangeRequest = _fee;\r\n    }\r\n\r\n    /// @notice global Admin update tier data\r\n    function setTierData(\r\n        uint256 _index,\r\n        uint256 _priceInCenter,\r\n        uint256 _priceInOuter) public onlyGlobalAdmin() {\r\n        Tier memory tier = tiers[_index];\r\n        tier.priceInCenter = _priceInCenter;\r\n        tier.priceInOuter = _priceInOuter;\r\n        tiers[_index] = tier;\r\n    }\r\n\r\n    function setMinResalePercentage(uint256 _minResalePercentage) public onlyGlobalAdmin() {\r\n        minResalePercentage = _minResalePercentage;\r\n    }\r\n\r\n    function isAdmin(address _address) public view returns (bool isAdmin_) {\r\n        return (true == admins[_address] || true == globalAdmins[_address]);\r\n    }\r\n\r\n    function setHalted(bool _halted) public onlyGlobalAdmin {\r\n        halted = _halted;\r\n\r\n        emit Halted(_halted);\r\n    }\r\n\r\n    function verify(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\r\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\r\n\r\n        return ecrecover(keccak256(abi.encodePacked(prefix, _hash)), _v, _r, _s);\r\n    }\r\n\r\n    function isContract(address addr) public view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    function setPlatformWallet(address _addresss) public onlyGlobalAdmin() {\r\n        platformWallet = _addresss;\r\n    }\r\n}\r\n\r\ncontract BigIoAdSpace is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Token\r\n    struct Token {\r\n        uint256 id;\r\n        uint256 x; // position X on map\r\n        uint256 y; // position Y on map\r\n        uint256 sizeA;\r\n        uint256 sizeB;\r\n        uint256 soldPrice; // price that user paid to buy token\r\n        uint256 actualPrice;\r\n        uint256 timesSold; // how many times token was sold\r\n        uint256 timesUpdated; // how many times artwork has been changed by current owner\r\n        uint256 soldAt; // when token was sold\r\n        uint256 inner;\r\n        uint256 outer;\r\n        uint256 soldNearby;\r\n    }\r\n\r\n    struct MetaData {\r\n        string meta;\r\n    }\r\n\r\n    struct InnerScope {\r\n        uint256 x1; // left top\r\n        uint256 y1;\r\n        uint256 x2; // right top\r\n        uint256 y2;\r\n        uint256 x3; // left bottom\r\n        uint256 y3;\r\n        uint256 x4; // right bottom\r\n        uint256 y4;\r\n    }\r\n\r\n    InnerScope public innerScope;\r\n\r\n    /// @notice mapping for token URIs\r\n    mapping(uint256 => MetaData) public metadata;\r\n\r\n    /// @notice Mapping from token ID to owner\r\n    mapping(uint256 => address) public tokenOwner;\r\n\r\n    mapping(uint256 => mapping(uint256 => bool)) public neighbours;\r\n    mapping(uint256 => uint256[]) public neighboursArea;\r\n\r\n    /// @notice Here different from base class we store the token not an id\r\n    /// Array with all token, used for enumeration\r\n    Token[] public allMinedTokens;\r\n\r\n    /// @notice Mapping from token id to position in the allMinedTokens array\r\n    mapping(uint256 => uint256) public allTokensIndex;\r\n\r\n    // store sold units and not-sold but generated units\r\n//    mapping(uint256 => mapping(uint256 => bool)) public soldUnits;\r\n    mapping(uint256 => mapping(uint256 => uint256)) public soldUnits;\r\n\r\n    address public platform;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event TokenPriceIncreased(uint256 _tokenId, uint256 _newPrice, uint256 _boughtTokenId, uint256 time);\r\n\r\n    constructor () public {\r\n        innerScope = InnerScope(\r\n            12, 11, // left top\r\n            67, 11, // right top\r\n            12, 34, // left bottom\r\n            67, 34\r\n        );\r\n    }\r\n\r\n    modifier onlyPlatform() {\r\n        require(msg.sender == platform);\r\n        _;\r\n    }\r\n\r\n    modifier exists(uint256 _tokenId) {\r\n        address owner = tokenOwner[_tokenId];\r\n        require(owner != address(0));\r\n        _;\r\n    }\r\n\r\n    function setPlatform(address _platform) public onlyOwner() {\r\n        platform = _platform;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return allMinedTokens.length;\r\n    }\r\n\r\n    /// @notice Check whether token is minted\r\n    function tokenExists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /// @notice Check whether exist Unit with same x any y coordinates\r\n    /// and it was sold already\r\n    /// in order to prevent over writing\r\n    function unitExists(uint x, uint y) public view returns (bool) {\r\n        return (soldUnits[x][y] != 0);\r\n    }\r\n\r\n    function getOwner(uint256 _tokenId) public view returns (address) {\r\n        return tokenOwner[_tokenId];\r\n    }\r\n\r\n    /// @return token metadata\r\n    function getMetadata(uint256 _tokenId) public exists(_tokenId) view returns (string) {\r\n        return metadata[_tokenId].meta;\r\n    }\r\n\r\n    /// @notice update metadata for token\r\n    function setTokenMetadata(uint256 _tokenId, string meta) public  onlyPlatform exists(_tokenId) {\r\n        metadata[_tokenId] = MetaData(meta);\r\n    }\r\n\r\n    function increaseUpdateMetadataCounter(uint256 _tokenId) public onlyPlatform {\r\n        allMinedTokens[allTokensIndex[_tokenId]].timesUpdated = allMinedTokens[allTokensIndex[_tokenId]].timesUpdated.add(1);\r\n    }\r\n\r\n    /// @notice remove metadata for token\r\n    function removeTokenMetadata(uint256 _tokenId) public onlyPlatform exists(_tokenId) {\r\n        delete metadata[_tokenId];\r\n    }\r\n\r\n    // @return return the current price\r\n    function getCurrentPriceForToken(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\r\n        return allMinedTokens[allTokensIndex[_tokenId]].actualPrice;\r\n    }\r\n\r\n    /// @return tokenId, x, y, sizeA, sizeB, price, inner, outer\r\n    function getTokenData(uint256 _tokenId) public exists(_tokenId) view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\r\n        return (_tokenId, token.x, token.y, token.sizeA, token.sizeB, token.actualPrice, token.soldPrice, token.inner, token.outer);\r\n    }\r\n\r\n    function getTokenSoldPrice(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\r\n        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\r\n        return token.soldPrice;\r\n    }\r\n\r\n    function getTokenUpdatedCounter(uint256 _tokenId) public exists(_tokenId) view returns (uint256) {\r\n        return allMinedTokens[allTokensIndex[_tokenId]].timesUpdated;\r\n    }\r\n\r\n    // @return return token sizes\r\n    function getTokenSizes(uint256 _tokenId) public exists(_tokenId) view returns (uint256, uint256) {\r\n        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\r\n        return (token.sizeA, token.sizeB);\r\n    }\r\n\r\n    // @return return token scopes\r\n    function getTokenScope(uint256 _tokenId) public exists(_tokenId) view returns (bool, bool) {\r\n        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\r\n        return (token.inner > 0, token.outer > 0);\r\n    }\r\n\r\n    // @return return token scope counters\r\n    function getTokenCounters(uint256 _tokenId) public exists(_tokenId) view returns (uint256, uint256, uint256, uint256) {\r\n        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];\r\n        return (token.inner, token.outer, token.timesSold, token.soldNearby);\r\n    }\r\n\r\n    /// @notice Mint new token, not sell new token\r\n    /// BE sends: owner, x coordinate, y coordinate, price\r\n    /// @param to new owner\r\n    /// @param x coordinate\r\n    /// @param y coordinate\r\n    /// @param totalPrice calculated price for all units + % for siblings\r\n    function mint(\r\n        address to,\r\n        uint x,\r\n        uint y,\r\n        uint sizeA,\r\n        uint sizeB,\r\n        uint256 totalPrice,\r\n        uint256 actualPrice\r\n    ) public onlyPlatform() returns (uint256) {\r\n\r\n        // 1.\r\n        require(to != address(0));\r\n        require(sizeA.mul(sizeB) <= 100);\r\n\r\n        // 2. check area\r\n        uint256 inner;\r\n        uint256 total;\r\n\r\n        (total, inner) = calculateCounters(x, y, sizeA, sizeB);\r\n\r\n        // we avoid zero because we later compare against zero\r\n        uint256 tokenId = (allMinedTokens.length).add(1);\r\n\r\n        // @TODO: ACHTUNG - soldAt equals 0 during minting\r\n        Token memory minted = Token(tokenId, x, y, sizeA, sizeB, totalPrice, actualPrice, 0, 0, 0, inner, total.sub(inner), 0);\r\n\r\n        // 3. copy units and create siblings\r\n        copyToAllUnits(x, y, sizeA, sizeB, tokenId);\r\n\r\n        // 4. update state\r\n        updateInternalState(minted, to);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function updateTokensState(uint256 _tokenId, uint256 newPrice) public onlyPlatform exists(_tokenId) {\r\n        uint256 index = allTokensIndex[_tokenId];\r\n        allMinedTokens[index].timesSold += 1;\r\n        allMinedTokens[index].timesUpdated = 0;\r\n        allMinedTokens[index].soldNearby = 0;\r\n        allMinedTokens[index].soldPrice = newPrice;\r\n        allMinedTokens[index].actualPrice = newPrice;\r\n        allMinedTokens[index].soldAt = now;\r\n    }\r\n\r\n    function updateOwner(uint256 _tokenId, address newOwner, address prevOwner) public onlyPlatform exists(_tokenId) {\r\n        require(newOwner != address(0));\r\n        require(prevOwner != address(0));\r\n        require(prevOwner == tokenOwner[_tokenId]);\r\n\r\n        // update data for new owner\r\n        tokenOwner[_tokenId] = newOwner;\r\n    }\r\n\r\n    function inInnerScope(uint256 x, uint256 y) public view returns (bool) {\r\n        // x should be between left top and right top corner\r\n        // y should be between left top and left bottom corner\r\n        if ((x >= innerScope.x1) && (x <= innerScope.x2) && (y >= innerScope.y1) && (y <= innerScope.y3)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function calculateCounters(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) public view returns (uint256 total, uint256 inner) {\r\n        uint256 upX = x.add(sizeA);\r\n        uint256 upY = y.add(sizeB);\r\n\r\n        // check for boundaries\r\n        require(x >= 1);\r\n        require(y >= 1);\r\n        require(upX <= 79);\r\n        require(upY <= 45);\r\n        require(sizeA > 0);\r\n        require(sizeB > 0);\r\n\r\n        uint256 i;\r\n        uint256 j;\r\n\r\n        for (i = x; i < upX; i++) {\r\n            for (j = y; j < upY; j++) {\r\n                require(soldUnits[i][j] == 0);\r\n\r\n                if (inInnerScope(i, j)) {\r\n                    inner = inner.add(1);\r\n                }\r\n\r\n                total = total.add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function increasePriceForNeighbours(uint256 tokenId) public onlyPlatform {\r\n\r\n        Token memory token = allMinedTokens[allTokensIndex[tokenId]];\r\n\r\n        uint256 upX = token.x.add(token.sizeA);\r\n        uint256 upY = token.y.add(token.sizeB);\r\n\r\n        uint256 i;\r\n        uint256 j;\r\n        uint256 k;\r\n        uint256 _tokenId;\r\n\r\n\r\n        if (neighboursArea[tokenId].length == 0) {\r\n\r\n            for (i = token.x; i < upX; i++) {\r\n                // check neighbors on top of area\r\n                _tokenId = soldUnits[i][token.y - 1];\r\n\r\n                if (_tokenId != 0) {\r\n                    if (!neighbours[tokenId][_tokenId]) {\r\n                        neighbours[tokenId][_tokenId] = true;\r\n                        neighboursArea[tokenId].push(_tokenId);\r\n                    }\r\n                    if (!neighbours[_tokenId][tokenId]) {\r\n                        neighbours[_tokenId][tokenId] = true;\r\n                        neighboursArea[_tokenId].push(tokenId);\r\n                    }\r\n                }\r\n\r\n                // check neighbors on bottom of area\r\n                _tokenId = soldUnits[i][upY];\r\n                if (_tokenId != 0) {\r\n                    if (!neighbours[tokenId][_tokenId]) {\r\n                        neighbours[tokenId][_tokenId] = true;\r\n                        neighboursArea[tokenId].push(_tokenId);\r\n                    }\r\n                    if (!neighbours[_tokenId][tokenId]) {\r\n                        neighbours[_tokenId][tokenId] = true;\r\n                        neighboursArea[_tokenId].push(tokenId);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (j = token.y; j < upY; j++) {\r\n                // check neighbors on left of area of area\r\n                _tokenId = soldUnits[token.x - 1][j];\r\n                if (_tokenId != 0) {\r\n                    if (!neighbours[tokenId][_tokenId]) {\r\n                        neighbours[tokenId][_tokenId] = true;\r\n                        neighboursArea[tokenId].push(_tokenId);\r\n                    }\r\n                    if (!neighbours[_tokenId][tokenId]) {\r\n                        neighbours[_tokenId][tokenId] = true;\r\n                        neighboursArea[_tokenId].push(tokenId);\r\n                    }\r\n                }\r\n\r\n                // check neighbors on right of area of area\r\n                _tokenId = soldUnits[upX][j];\r\n                if (_tokenId != 0) {\r\n                    if (!neighbours[tokenId][_tokenId]) {\r\n                        neighbours[tokenId][_tokenId] = true;\r\n                        neighboursArea[tokenId].push(_tokenId);\r\n                    }\r\n                    if (!neighbours[_tokenId][tokenId]) {\r\n                        neighbours[_tokenId][tokenId] = true;\r\n                        neighboursArea[_tokenId].push(tokenId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // increase price\r\n        for (k = 0; k < neighboursArea[tokenId].length; k++) {\r\n            Token storage _token = allMinedTokens[allTokensIndex[neighboursArea[tokenId][k]]];\r\n            _token.soldNearby = _token.soldNearby.add(1);\r\n            _token.actualPrice = _token.actualPrice.add((_token.actualPrice.div(100)));\r\n            emit TokenPriceIncreased(_token.id, _token.actualPrice, _tokenId, now);\r\n        }\r\n    }\r\n\r\n    // move generated Units to sold array\r\n    // generate siblings and put it there\r\n    function copyToAllUnits(uint256 x, uint256 y, uint256 width, uint256 height, uint256 tokenId) internal {\r\n        uint256 upX = x + width; // 5\r\n        uint256 upY = y + height; // 3\r\n\r\n        uint256 i; // 1\r\n        uint256 j; // 1\r\n\r\n        for (i = x; i < upX; i++) {\r\n            for (j = y; j < upY; j++) {\r\n                soldUnits[i][j] = tokenId;\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateInternalState(Token minted, address _to) internal {\r\n        uint256 lengthT = allMinedTokens.length;\r\n        allMinedTokens.push(minted);\r\n        allTokensIndex[minted.id] = lengthT;\r\n        tokenOwner[minted.id] = _to;\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract BigIOERC20token is StandardToken, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    uint256 public maxSupply;\r\n\r\n    bool public allowedMinting;\r\n\r\n    mapping(address => bool) public mintingAgents;\r\n    mapping(address => bool) public stateChangeAgents;\r\n\r\n    event MintERC20(address indexed _holder, uint256 _tokens);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    modifier onlyMintingAgents () {\r\n        require(mintingAgents[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    constructor (string _name, string _symbol, uint8 _decimals, uint256 _maxSupply) public StandardToken() {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        maxSupply = _maxSupply;\r\n\r\n        allowedMinting = true;\r\n\r\n        mintingAgents[msg.sender] = true;\r\n    }\r\n\r\n    /// @notice update minting agent\r\n    function updateMintingAgent(address _agent, bool _status) public onlyOwner {\r\n        mintingAgents[_agent] = _status;\r\n    }\r\n\r\n    /// @notice allow to mint tokens\r\n    function mint(address _holder, uint256 _tokens) public onlyMintingAgents() {\r\n        require(allowedMinting == true && totalSupply_.add(_tokens) <= maxSupply);\r\n\r\n        totalSupply_ = totalSupply_.add(_tokens);\r\n\r\n        balances[_holder] = balanceOf(_holder).add(_tokens);\r\n\r\n        if (totalSupply_ == maxSupply) {\r\n            allowedMinting = false;\r\n        }\r\n        emit MintERC20(_holder, _tokens);\r\n        emit Transfer(0x0, _holder, _tokens);\r\n    }\r\n\r\n}\r\n\r\ncontract PricingStrategy {\r\n    using SafeMath for uint256;\r\n\r\n    function calculateMinPriceForNextRound(uint256 _tokenPrice, uint256 _minResalePercentage) public pure returns (uint256) {\r\n        return _tokenPrice.add(_tokenPrice.div(100).mul(_minResalePercentage));\r\n    }\r\n\r\n    function calculateSharesInTheRevenue(uint256 _prevTokenPrice, uint256 _newTokenPrice) public pure returns (uint256, uint256) {\r\n        uint256 revenue = _newTokenPrice.sub(_prevTokenPrice);\r\n        uint256 platformShare = revenue.mul(40).div(100);\r\n        uint256 forPrevOwner = revenue.sub(platformShare);\r\n        return (platformShare, forPrevOwner);\r\n    }\r\n}\r\n/// @title Platform\r\n/// @author Applicature\r\n/// @notice It is front contract which is used to sell, re-sell tokens and initiate paying dividends\r\ncontract Platform is Admin {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct Offer {\r\n        uint256 tokenId;\r\n        uint256 offerId;\r\n        address from;\r\n        uint256 offeredPrice;\r\n        uint256 tokenPrice;\r\n        bool accepted;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct ArtWorkChangeRequest {\r\n        address fromUser;\r\n        uint256 tokenId;\r\n        uint256 changeId;\r\n        string meta;\r\n        uint256 timestamp;\r\n        bool isReviewed;\r\n    }\r\n\r\n    BigIoAdSpace public token;\r\n    BigIOERC20token public erc20token;\r\n\r\n    PricingStrategy public pricingStrategy;\r\n    ArtWorkChangeRequest[] public artWorkChangeRequests;\r\n\r\n    bool public isLogoInitied;\r\n\r\n    uint256 public logoX = 35;\r\n    uint256 public logoY = 18;\r\n\r\n    Offer[] public offers;\r\n\r\n    mapping(address => uint256) public pendingReturns;\r\n\r\n    event Minted(address indexed _owner, uint256 _tokenId, uint256 _x, uint256 _y, uint256 _sizeA, uint256 _sizeB, uint256 _price, uint256 _platformTransfer, uint256 _timestamp);\r\n\r\n    event Purchased(address indexed _from, address indexed _to, uint256 _tokenId, uint256 _price, uint256 _prevPrice, uint256 _prevOwnerTransfer, uint256 _platformTransfer, uint256 _timestamp);\r\n\r\n    event OfferMade(address indexed _fromUser, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\r\n\r\n    event OfferApproved(address indexed _owner, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\r\n\r\n    event OfferDeclined(address indexed _fromUser, uint256 _tokenId, uint256 _offerId, uint256 _offeredPrice, uint256 _timestamp);\r\n\r\n    event ArtWorkChangeRequestMade(\r\n        address indexed _fromUser,\r\n        uint256 _tokenId,\r\n        uint256 _changeId,\r\n        string _meta,\r\n        uint256 _platformTransfer,\r\n        uint256 _timestamp);\r\n\r\n    event ArtWorkChangeRequestApproved(\r\n        address indexed _fromUser,\r\n        uint256 _tokenId,\r\n        uint256 _changeId,\r\n        string _meta,\r\n        uint256 _timestamp);\r\n\r\n    event ArtWorkChangeRequestDeclined(\r\n        address indexed _fromUser,\r\n        uint256 _tokenId,\r\n        uint256 _changeId,\r\n        string _meta,\r\n        uint256 _timestamp);\r\n\r\n    event RemovedMetaData(uint256 _tokenId, address _admin, string _meta, uint256 _timestamp);\r\n    event ChangedOwnership(uint256 _tokenId, address _prevOwner, address _newOwner, uint256 _timestamp);\r\n\r\n    constructor(\r\n        address _platformWallet, // owner collects money\r\n        address _token,\r\n        address _erc20token,\r\n        address _pricingStrategy,\r\n        address _signer\r\n    ) public {\r\n\r\n        token = BigIoAdSpace(_token);\r\n        erc20token = BigIOERC20token(_erc20token);\r\n\r\n        platformWallet = _platformWallet;\r\n\r\n        pricingStrategy = PricingStrategy(_pricingStrategy);\r\n\r\n        signers[_signer] = true;\r\n\r\n        // 30%\r\n        tiers.push(\r\n            Tier(\r\n                400, // amountInCenter\r\n                600, // amountInOuter\r\n                1 ether, // priceInCenter\r\n                0.4 ether, // priceInOuter\r\n                0, // soldInCenter\r\n                0, // soldInOuter\r\n                false, // filledInCenter\r\n                false // filledInOuter\r\n            )\r\n        );\r\n        // 30%\r\n        tiers.push(\r\n            Tier(\r\n                400, 600, 1.2 ether, 0.6 ether, 0, 0, false, false\r\n            )\r\n        );\r\n        // 30%\r\n        tiers.push(\r\n            Tier(\r\n                400, 600, 1.4 ether, 0.8 ether, 0, 0, false, false\r\n            )\r\n        );\r\n        // 10%\r\n        tiers.push(\r\n            Tier(\r\n                144, 288, 1.6 ether, 1.0 ether, 0, 0, false, false\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice init logo, call it as soon as possible\r\n    /// call it after setting platform in the token\r\n    /// Logo is BigIOToken which has 10*10 size and position in the center of map\r\n    function initLogo() public onlyOwner {\r\n        require(isLogoInitied == false);\r\n\r\n        isLogoInitied = true;\r\n\r\n        logoId = token.mint(platformWallet, logoX, logoY, 10, 10, 0 ether, 0 ether);\r\n\r\n        token.setTokenMetadata(logoId, \"\");\r\n\r\n        updateTierStatus(100, 0);\r\n\r\n        emit Minted(msg.sender, logoId, logoX, logoY, 10, 10, 0 ether, 0 ether, now);\r\n    }\r\n\r\n    function getPriceFor(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) public view returns(uint256 totalPrice, uint256 inner, uint256 outer) {\r\n        (inner, outer) = preMinting(x, y, sizeA, sizeB);\r\n\r\n        totalPrice = calculateTokenPrice(inner, outer);\r\n\r\n        return (totalPrice, inner, outer);\r\n    }\r\n\r\n    /// @notice sell new tokens during the round 0\r\n    /// all except logo\r\n    function buy(\r\n        uint256 x, // top left coordinates\r\n        uint256 y, // top left coordinates\r\n        uint256 sizeA, // size/width of a square\r\n        uint256 sizeB, // size/height of a square,\r\n        uint8 _v,  // component of signature\r\n        bytes32 _r, // component of signature\r\n        bytes32 _s // component of signature\r\n    ) public notHalted() payable {\r\n        address recoveredSigner = verify(keccak256(msg.sender), _v, _r, _s);\r\n\r\n        require(signers[recoveredSigner] == true);\r\n        require(msg.value > 0);\r\n\r\n        internalBuy(x, y, sizeA, sizeB);\r\n    }\r\n\r\n    function internalBuy(\r\n        uint256 x, // top left coordinates\r\n        uint256 y, // top left coordinates\r\n        uint256 sizeA, // size/width of a square\r\n        uint256 sizeB // size/height of a square,\r\n    ) internal {\r\n        // get and validate current tier\r\n        uint256 inner = 0;\r\n        uint256 outer = 0;\r\n        uint256 totalPrice = 0;\r\n\r\n        (inner, outer) = preMinting(x, y, sizeA, sizeB);\r\n        totalPrice = calculateTokenPrice(inner, outer);\r\n\r\n        require(totalPrice <= msg.value);\r\n\r\n        //         try to mint and update current tier\r\n        updateTierStatus(inner, outer);\r\n\r\n        uint256 actualPrice = inner.mul(tiers[3].priceInCenter).add(outer.mul(tiers[3].priceInOuter));\r\n\r\n        if (msg.value > actualPrice) {\r\n            actualPrice = msg.value;\r\n        }\r\n\r\n        uint256 tokenId = token.mint(msg.sender, x, y, sizeA, sizeB, msg.value, actualPrice);\r\n        erc20token.mint(msg.sender, inner.add(outer));\r\n\r\n        transferEthers(platformWallet, msg.value);\r\n\r\n        emit Minted(msg.sender, tokenId, x, y, sizeA, sizeB, msg.value, msg.value, now);\r\n    }\r\n\r\n    /// @notice allow user to make an offer after initial phase(re-sale)\r\n    /// any offer minResalePercentage is accepted automatically\r\n    function makeOffer(\r\n        uint256 _tokenId,\r\n        uint8 _v,  // component of signature\r\n        bytes32 _r, // component of signature\r\n        bytes32 _s // component of signature\r\n    ) public notHalted() payable {\r\n\r\n        address recoveredSigner = verify(keccak256(msg.sender), _v, _r, _s);\r\n\r\n        require(signers[recoveredSigner] == true);\r\n\r\n        require(msg.sender != address(0));\r\n        require(msg.value > 0);\r\n\r\n        uint256 currentPrice = getTokenPrice(_tokenId);\r\n        require(currentPrice > 0);\r\n\r\n        // special case for first sell of logo\r\n        if (_tokenId == logoId && token.getCurrentPriceForToken(_tokenId) == 0) {\r\n            require(msg.value >= logoPrice);\r\n\r\n            //update token's state\r\n            token.updateTokensState(logoId, msg.value);\r\n\r\n            // mint erc20 tokens\r\n            erc20token.mint(msg.sender, 100);\r\n\r\n            transferEthers(platformWallet, msg.value);\r\n\r\n            emit Purchased(0, msg.sender, _tokenId, msg.value, 0, 0, msg.value, now);\r\n\r\n            return;\r\n        }\r\n\r\n        uint256 minPrice = pricingStrategy.calculateMinPriceForNextRound(currentPrice, minResalePercentage);\r\n\r\n        require(msg.value >= minPrice);\r\n\r\n        uint256 offerCounter = offers.length;\r\n\r\n        offers.push(Offer(_tokenId, offerCounter, msg.sender, msg.value, currentPrice, false, now));\r\n        emit OfferMade(msg.sender, _tokenId, offerCounter, msg.value, now);\r\n\r\n        // 2. check condition for approve and do it\r\n        approve(offerCounter, _tokenId);\r\n    }\r\n\r\n    function getTokenPrice(uint256 _tokenId) public view returns (uint256 price) {\r\n\r\n        uint256 actualPrice = token.getCurrentPriceForToken(_tokenId);\r\n\r\n        // special case for first sell of logo\r\n        if (_tokenId == logoId && actualPrice == 0) {\r\n            require(logoPrice > 0);\r\n\r\n            return logoPrice;\r\n        } else {\r\n            uint256 indexInner = 0;\r\n            uint256 indexOuter = 0;\r\n\r\n            bool hasInner;\r\n            bool hasOuter;\r\n\r\n            (hasInner, hasOuter) = token.getTokenScope(_tokenId);\r\n            (indexInner, indexOuter) = getCurrentTierIndex();\r\n\r\n            if (_tokenId != logoId && hasInner) {\r\n                require(indexInner == 100000);\r\n            }\r\n\r\n            if (hasOuter) {\r\n                require(indexOuter == 100000);\r\n            }\r\n\r\n            return actualPrice;\r\n        }\r\n    }\r\n\r\n    function getArtWorkChangeFee(uint256 _tokenId) public view returns (uint256 fee) {\r\n\r\n        uint256 counter = token.getTokenUpdatedCounter(_tokenId);\r\n\r\n        if (counter > 0) {\r\n            return feeForArtWorkChangeRequest;\r\n        }\r\n\r\n        return feeForFirstArtWorkChangeRequest;\r\n    }\r\n\r\n    /// @notice it allows token owner to create art work change request\r\n    /// first user upload 2 images\r\n    /// then do call this function\r\n    /// admin can reject or approve it\r\n    function artWorkChangeRequest(uint256 _tokenId, string _meta, uint8 _v, bytes32 _r, bytes32 _s)\r\n        public payable returns (uint256)\r\n    {\r\n\r\n        address recoveredSigner = verify(keccak256(_meta), _v, _r, _s);\r\n\r\n        require(signers[recoveredSigner] == true);\r\n\r\n        require(msg.sender == token.getOwner(_tokenId));\r\n\r\n        uint256 fee = getArtWorkChangeFee(_tokenId);\r\n\r\n        require(msg.value >= fee);\r\n\r\n        uint256 changeRequestCounter = artWorkChangeRequests.length;\r\n\r\n        artWorkChangeRequests.push(\r\n            ArtWorkChangeRequest(msg.sender, _tokenId, changeRequestCounter, _meta, now, false)\r\n        );\r\n\r\n        token.increaseUpdateMetadataCounter(_tokenId);\r\n\r\n        transferEthers(platformWallet, msg.value);\r\n\r\n        emit ArtWorkChangeRequestMade(msg.sender, _tokenId, changeRequestCounter, _meta, msg.value, now);\r\n\r\n        return changeRequestCounter;\r\n    }\r\n\r\n    function artWorkChangeApprove(uint256 _index, uint256 _tokenId, bool approve) public onlyAdmin {\r\n        ArtWorkChangeRequest storage request = artWorkChangeRequests[_index];\r\n        require(false == request.isReviewed);\r\n\r\n        require(_tokenId == request.tokenId);\r\n        request.isReviewed = true;\r\n        if (approve) {\r\n            token.setTokenMetadata(_tokenId, request.meta);\r\n            emit ArtWorkChangeRequestApproved(\r\n                request.fromUser,\r\n                request.tokenId,\r\n                request.changeId,\r\n                request.meta,\r\n                now\r\n            );\r\n        } else {\r\n            emit ArtWorkChangeRequestDeclined(\r\n                request.fromUser,\r\n                request.tokenId,\r\n                request.changeId,\r\n                request.meta,\r\n                now\r\n            );\r\n        }\r\n    }\r\n\r\n    function artWorkChangeByAdmin(uint256 _tokenId, string _meta, uint256 _changeId) public onlyAdmin {\r\n        token.setTokenMetadata(_tokenId, _meta);\r\n        emit ArtWorkChangeRequestApproved(\r\n            msg.sender,\r\n            _tokenId,\r\n            _changeId,\r\n            _meta,\r\n            now\r\n        );\r\n    }\r\n\r\n    function changeTokenOwnerByAdmin(uint256 _tokenId, address _newOwner) public onlyAdmin {\r\n        address prevOwner = token.getOwner(_tokenId);\r\n        token.updateOwner(_tokenId, _newOwner, prevOwner);\r\n        emit ChangedOwnership(_tokenId, prevOwner, _newOwner, now);\r\n        string memory meta = token.getMetadata(_tokenId);\r\n        token.removeTokenMetadata(_tokenId);\r\n        emit RemovedMetaData(_tokenId, msg.sender, meta, now);\r\n    }\r\n\r\n    /// @return tokenId, x, y, sizeA, sizeB, price\r\n    function getTokenData(uint256 _tokenId) public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        return token.getTokenData(_tokenId);\r\n    }\r\n\r\n    function getMetaData(uint256 _tokenId) public view returns(string) {\r\n        return token.getMetadata(_tokenId);\r\n    }\r\n\r\n    /// @notice Withdraw a bid that was overbid and platform owner share\r\n    function claim() public returns (bool) {\r\n        return claimInternal(msg.sender);\r\n    }\r\n\r\n    /// @notice Withdraw (for cold storage wallet) a bid that was overbid and platform owner share\r\n    function claimByAddress(address _address) public returns (bool) {\r\n        return claimInternal(_address);\r\n    }\r\n\r\n    function claimInternal(address _address) internal returns (bool) {\r\n        require(_address != address(0));\r\n\r\n        uint256 amount = pendingReturns[_address];\r\n\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        pendingReturns[_address] = 0;\r\n\r\n        _address.transfer(amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @return index of current tiers, if 100000(cannot use -1) then round 0  finished\r\n    /// and we need to move to re-sale\r\n    function getCurrentTierIndex() public view returns (uint256, uint256) {\r\n        // cannot use -1\r\n        // so use not possible value for tiers.length\r\n        uint256 indexInner = 100000;\r\n        uint256 indexOuter = 100000;\r\n\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            if (!tiers[i].filledInCenter) {\r\n                indexInner = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        for (uint256 k = 0; k < tiers.length; k++) {\r\n            if (!tiers[k].filledInOuter) {\r\n                indexOuter = k;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return (indexInner, indexOuter);\r\n    }\r\n\r\n    /// @return current tier stats\r\n    /// index of current tiers, if 100000(cannot use -1) then initial sale is  finished\r\n    /// works only during the initial phase\r\n    function getCurrentTierStats() public view returns (uint256 indexInner, uint256 indexOuter, uint256 availableInner, uint256 availableInOuter, uint256 priceInCenter, uint256 priceInOuter, uint256 nextPriceInCenter, uint256 nextPriceInOuter) {\r\n\r\n        indexInner = 100000;\r\n        indexOuter = 100000;\r\n\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            if (!tiers[i].filledInCenter) {\r\n                indexInner = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        for (uint256 k = 0; k < tiers.length; k++) {\r\n            if (!tiers[k].filledInOuter) {\r\n                indexOuter = k;\r\n                break;\r\n            }\r\n        }\r\n\r\n        Tier storage tier;\r\n\r\n        if (indexInner != 100000) {\r\n            tier = tiers[indexInner];\r\n\r\n            availableInner = tier.amountInCenter.sub(tier.soldInCenter);\r\n\r\n            priceInCenter = tier.priceInCenter;\r\n\r\n            if (indexInner < 3) {\r\n                nextPriceInCenter = tiers[indexInner + 1].priceInCenter;\r\n            }\r\n        }\r\n\r\n        if (indexOuter != 100000) {\r\n            tier = tiers[indexOuter];\r\n\r\n            availableInOuter = tier.amountInOuter.sub(tier.soldInOuter);\r\n\r\n            priceInOuter = tier.priceInOuter;\r\n\r\n            if (indexOuter < 3) {\r\n                nextPriceInOuter = tiers[indexOuter + 1].priceInOuter;\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateAmountOfUnits(uint256 sizeA, uint256 sizeB) public pure returns (uint256) {\r\n        return sizeA.mul(sizeB);\r\n    }\r\n\r\n    /// @notice approve the offer\r\n    function approve(uint256 _index, uint256 _tokenId) internal {\r\n        Offer memory localOffer = offers[_index];\r\n\r\n        address newOwner = localOffer.from;\r\n        address prevOwner = token.getOwner(_tokenId);\r\n\r\n        uint256 platformShare;\r\n        uint256 forPrevOwner;\r\n\r\n        uint256 soldPrice = token.getTokenSoldPrice(_tokenId);\r\n\r\n        (platformShare, forPrevOwner) = pricingStrategy.calculateSharesInTheRevenue(\r\n            soldPrice, localOffer.offeredPrice);\r\n\r\n        //update token's state\r\n        token.updateTokensState(_tokenId, localOffer.offeredPrice);\r\n\r\n        // update owner\r\n        token.updateOwner(_tokenId, newOwner, prevOwner);\r\n        localOffer.accepted = true;\r\n\r\n        transferEthers(platformWallet, platformShare);\r\n        transferEthers(prevOwner, forPrevOwner.add(soldPrice));\r\n\r\n        emit OfferApproved(newOwner, _tokenId, localOffer.offerId, localOffer.offeredPrice, now);\r\n        emit Purchased(prevOwner, newOwner, _tokenId, localOffer.offeredPrice, soldPrice, forPrevOwner.add(soldPrice), platformShare, now);\r\n\r\n        afterApproveAction(_tokenId);\r\n    }\r\n\r\n    function transferEthers(address _address, uint256 _wei) internal {\r\n        if (isContract(_address)) {\r\n            pendingReturns[_address] = pendingReturns[_address].add(_wei);\r\n        }\r\n        else {\r\n            _address.transfer(_wei);\r\n        }\r\n    }\r\n\r\n    function preMinting(uint256 x, uint256 y, uint256 sizeA, uint256 sizeB) internal view returns (uint256, uint256) {\r\n        //  calculate units for token\r\n        uint256 total = 0;\r\n        uint256 inner = 0;\r\n        uint256 outer = 0;\r\n\r\n\r\n        (total, inner) = token.calculateCounters(x, y, sizeA, sizeB);\r\n        outer = total.sub(inner);\r\n\r\n        require(total <= 100);\r\n\r\n        return (inner, outer);\r\n    }\r\n\r\n    function updateTierStatus(uint256 inner, uint256 outer) internal {\r\n        uint256 leftInner = inner;\r\n        uint256 leftOuter = outer;\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            Tier storage tier = tiers[i];\r\n\r\n            if (leftInner > 0 && tier.filledInCenter == false) {\r\n                uint256 availableInner = tier.amountInCenter.sub(tier.soldInCenter);\r\n\r\n                if (availableInner > leftInner) {\r\n                    tier.soldInCenter = tier.soldInCenter.add(leftInner);\r\n\r\n                    leftInner = 0;\r\n                } else {\r\n                    tier.filledInCenter = true;\r\n                    tier.soldInCenter = tier.amountInCenter;\r\n\r\n                    leftInner = leftInner.sub(availableInner);\r\n                }\r\n            }\r\n\r\n            if (leftOuter > 0 && tier.filledInOuter == false) {\r\n                uint256 availableOuter = tier.amountInOuter.sub(tier.soldInOuter);\r\n\r\n                if (availableOuter > leftOuter) {\r\n                    tier.soldInOuter = tier.soldInOuter.add(leftOuter);\r\n\r\n                    leftOuter = 0;\r\n                } else {\r\n                    tier.filledInOuter = true;\r\n                    tier.soldInOuter = tier.amountInOuter;\r\n\r\n                    leftOuter = leftOuter.sub(availableOuter);\r\n                }\r\n            }\r\n        }\r\n\r\n        require(leftInner == 0 && leftOuter == 0);\r\n    }\r\n\r\n    function calculateTokenPrice(uint256 inner, uint256 outer) public view returns (uint256 price) {\r\n        uint256 leftInner = inner;\r\n        uint256 leftOuter = outer;\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            Tier storage tier = tiers[i];\r\n\r\n            if (leftInner > 0 && tier.filledInCenter == false) {\r\n                uint256 availableInner = tier.amountInCenter.sub(tier.soldInCenter);\r\n\r\n                if (availableInner > leftInner) {\r\n                    price = price.add(leftInner.mul(tier.priceInCenter));\r\n                    leftInner = 0;\r\n                } else {\r\n                    price = price.add(availableInner.mul(tier.priceInCenter));\r\n                    leftInner = leftInner.sub(availableInner);\r\n                }\r\n            }\r\n\r\n            if (leftOuter > 0 && tier.filledInOuter == false) {\r\n                uint256 availableOuter = tier.amountInOuter.sub(tier.soldInOuter);\r\n\r\n                if (availableOuter > leftOuter) {\r\n                    price = price.add(leftOuter.mul(tier.priceInOuter));\r\n                    leftOuter = 0;\r\n                } else {\r\n                    price = price.add(availableOuter.mul(tier.priceInOuter));\r\n                    leftOuter = leftOuter.sub(availableOuter);\r\n                }\r\n            }\r\n        }\r\n\r\n        require(leftInner == 0 && leftOuter == 0);\r\n    }\r\n\r\n    function minPriceForNextRound(uint256 _tokenId) public view returns (uint256) {\r\n        if (_tokenId == logoId && token.getCurrentPriceForToken(_tokenId) == 0) {\r\n            return logoPrice;\r\n        } else {\r\n            // @TODO: check if sold-out\r\n\r\n            uint256 currentPrice = getTokenPrice(_tokenId);\r\n            uint256 minPrice = pricingStrategy.calculateMinPriceForNextRound(currentPrice, minResalePercentage);\r\n            return minPrice;\r\n        }\r\n    }\r\n\r\n    function afterApproveAction(uint256 _tokenId) internal {\r\n\r\n        uint256 indexInner = 100000;\r\n        uint256 indexOuter = 100000;\r\n\r\n        bool hasInner;\r\n        bool hasOuter;\r\n\r\n        (hasInner, hasOuter) = token.getTokenScope(_tokenId);\r\n        (indexInner, indexOuter) = getCurrentTierIndex();\r\n\r\n        if (hasInner && hasOuter && indexInner == 100000 && indexOuter == 100000) {\r\n            token.increasePriceForNeighbours(_tokenId);\r\n        } else if (!hasInner && hasOuter && indexOuter == 100000) {\r\n            token.increasePriceForNeighbours(_tokenId);\r\n        } else if (!hasOuter && hasInner && indexInner == 100000) {\r\n            token.increasePriceForNeighbours(_tokenId);\r\n        }\r\n    }\r\n\r\n    function canBuyExistentToken(uint256 _tokenId) public view returns (uint256 _allowed) {\r\n        uint256 indexInner = 0;\r\n        uint256 indexOuter = 0;\r\n\r\n        bool hasInner;\r\n        bool hasOuter;\r\n\r\n        (hasInner, hasOuter) = token.getTokenScope(_tokenId);\r\n        (indexInner, indexOuter) = getCurrentTierIndex();\r\n\r\n        if (token.getCurrentPriceForToken(_tokenId) == 0 && logoPrice == 0) {\r\n            return 4;\r\n        }\r\n\r\n        if (_tokenId != logoId && hasInner && indexInner != 100000) {\r\n            return 2;\r\n        }\r\n\r\n        if (hasOuter && indexOuter != 100000) {\r\n            return 3;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenSizes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"neighboursArea\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"updateTokensState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allTokensIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"removeTokenMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platform\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"increasePriceForNeighbours\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"meta\",\"type\":\"string\"}],\"name\":\"setTokenMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_platform\",\"type\":\"address\"}],\"name\":\"setPlatform\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"increaseUpdateMetadataCounter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"sizeA\",\"type\":\"uint256\"},{\"name\":\"sizeB\",\"type\":\"uint256\"},{\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"name\":\"actualPrice\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenUpdatedCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"unitExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allMinedTokens\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"sizeA\",\"type\":\"uint256\"},{\"name\":\"sizeB\",\"type\":\"uint256\"},{\"name\":\"soldPrice\",\"type\":\"uint256\"},{\"name\":\"actualPrice\",\"type\":\"uint256\"},{\"name\":\"timesSold\",\"type\":\"uint256\"},{\"name\":\"timesUpdated\",\"type\":\"uint256\"},{\"name\":\"soldAt\",\"type\":\"uint256\"},{\"name\":\"inner\",\"type\":\"uint256\"},{\"name\":\"outer\",\"type\":\"uint256\"},{\"name\":\"soldNearby\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenCounters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getMetadata\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"sizeA\",\"type\":\"uint256\"},{\"name\":\"sizeB\",\"type\":\"uint256\"}],\"name\":\"calculateCounters\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"inner\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"soldUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"inInnerScope\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"newOwner\",\"type\":\"address\"},{\"name\":\"prevOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"neighbours\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadata\",\"outputs\":[{\"name\":\"meta\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenScope\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"innerScope\",\"outputs\":[{\"name\":\"x1\",\"type\":\"uint256\"},{\"name\":\"y1\",\"type\":\"uint256\"},{\"name\":\"x2\",\"type\":\"uint256\"},{\"name\":\"y2\",\"type\":\"uint256\"},{\"name\":\"x3\",\"type\":\"uint256\"},{\"name\":\"y3\",\"type\":\"uint256\"},{\"name\":\"x4\",\"type\":\"uint256\"},{\"name\":\"y4\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenSoldPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPriceForToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_boughtTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TokenPriceIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BigIoAdSpace","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7790c3c5b532d017608d8594faab83b84b8d62b304df7de6384df25167af1602"}]}