{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n//\r\n// EtherPiggyBank\r\n// (etherpiggybank.com)\r\n//        \r\n//   <`--'\\>______\r\n//   /. .  `'     \\\r\n//  (`')  ,        @\r\n//   `-._,        /\r\n//      )-)_/--( >  \r\n//     ''''  ''''\r\n//\r\n// Invest Ethereum into a long term stable solution where\r\n// your investment can grow organically as the system expands.\r\n// You will gain +1.5% of your invested Ethereum every day that\r\n// you leave it in the Ether Piggy Bank!\r\n// You can withdraw your investments at any time but it will\r\n// incur a 20% withdrawal fee (~13 days of investing).\r\n// You can also invest your profits back into your account and\r\n// your gains will compound the more you do this!\r\n// \r\n// Big players can compete for the investment positions available,\r\n// every time someone makes a deposit into the Ether Piggy Bank,\r\n// they will receive a percentage of that sale in their\r\n// affiliate commision.\r\n// You can buy this position off anyone and double it's current\r\n// buying price but every 3-7 days (depending on the position),\r\n// the buying price will halve until it reaches 0.125 ether.\r\n// Upon buying, the previous investor gets 75% of the buying price,\r\n// the dev gets 5% and the rest goes into the contract to encourage\r\n// an all round balanced ecosystem!\r\n//\r\n// You will also receive a 5% bonus, which will appear in your\r\n// affiliate commission, by referring another player to the game \r\n// via your referral URL! It's a HYIP on a smart contract, fully\r\n// transparent and you'll never need to worry about an exit scam or\r\n// someone taking all the money and leaving!\r\n\r\n\r\ncontract EtherPiggyBank {\r\n    \r\n    // investment tracking for each address\r\n    mapping (address => uint256) public investedETH;\r\n    mapping (address => uint256) public lastInvest;\r\n    \r\n    // for referrals and investor positions\r\n    mapping (address => uint256) public affiliateCommision;\r\n    uint256 REF_BONUS = 4; // 4% of the ether invested\r\n    // goes into the ref address' affiliate commision\r\n    uint256 DEV_TAX = 1; // 1% of all ether invested\r\n    // goes into the dev address' affiliate commision\r\n    \r\n    uint256 BASE_PRICE = 0.125 ether; // 1/8 ether\r\n    uint256 INHERITANCE_TAX = 75; // 75% will be returned to the\r\n    // investor if their position is purchased, the rest will\r\n    // go to the contract and the dev\r\n    uint256 DEV_TRANSFER_TAX = 5;\r\n    // this means that when purchased the sale will be distrubuted:\r\n    // 75% to the old position owner\r\n    // 5% to the dev\r\n    // and 20% to the contract for all the other investors\r\n    // ^ this will encourage a healthy ecosystem\r\n    struct InvestorPosition {\r\n        address investor;\r\n        uint256 startingLevel;\r\n        uint256 startingTime;\r\n        uint256 halfLife;\r\n        uint256 percentageCut;\r\n    }\r\n\r\n    InvestorPosition[] investorPositions; \r\n    address public dev;\r\n\r\n    // start up the contract!\r\n    function EtherPiggyBank() public {\r\n        \r\n        // set the dev address\r\n        dev = msg.sender;\r\n        \r\n        // make the gold level investor\r\n        investorPositions.push(InvestorPosition({\r\n            investor: dev,\r\n            startingLevel: 5, // 1/8 ether * 2^5 = 4 ether\r\n            startingTime: now,\r\n            halfLife: 7 days, // 7 days until the level decreases\r\n            percentageCut: 5 // with 5% cut of all investments\r\n            }));\r\n\r\n        // make the silver level investor\r\n        investorPositions.push(InvestorPosition({\r\n            investor: 0x6c0cf053076681cecbe31e5e19df8fb97deb5756,\r\n            startingLevel: 4, // 1/8 ether * 2^4 = 2 ether\r\n            startingTime: now,\r\n            halfLife: 5 days, // 5 days until the level decreases\r\n            percentageCut: 3 // with 3% cut of all investments\r\n            }));\r\n\r\n        // make the bronze level investor\r\n        investorPositions.push(InvestorPosition({\r\n            investor: 0x66fe910c6a556173ea664a94f334d005ddc9ce9e,\r\n            startingLevel: 3, // 1/8 ether * 2^3 = 1 ether\r\n            startingTime: now,\r\n            halfLife: 3 days, // 3 days until the level decreases\r\n            percentageCut: 1 // with 1% cut of all investments\r\n            }));\r\n    }\r\n    \r\n    function investETH(address referral) public payable {\r\n        \r\n        require(msg.value >= 0.01 ether);\r\n        \r\n        if (getProfit(msg.sender) > 0) {\r\n            uint256 profit = getProfit(msg.sender);\r\n            lastInvest[msg.sender] = now;\r\n            msg.sender.transfer(profit);\r\n        }\r\n        \r\n        uint256 amount = msg.value;\r\n\r\n        // handle all of our investor positions first\r\n        bool flaggedRef = (referral == msg.sender || referral == dev); // ref cannot be the sender or the dev\r\n        for(uint256 i = 0; i < investorPositions.length; i++) {\r\n            \r\n            InvestorPosition memory position = investorPositions[i];\r\n\r\n            // check that our ref isn't an investor too\r\n            if (position.investor == referral) {\r\n                flaggedRef = true;\r\n            }\r\n            \r\n            // we cannot claim on our own investments\r\n            if (position.investor != msg.sender) {\r\n                uint256 commision = SafeMath.div(SafeMath.mul(amount, position.percentageCut), 100);\r\n                affiliateCommision[position.investor] = SafeMath.add(affiliateCommision[position.investor], commision);\r\n            }\r\n\r\n        }\r\n\r\n        // now for the referral (if we have one)\r\n        if (!flaggedRef && referral != 0x0) {\r\n            uint256 refBonus = SafeMath.div(SafeMath.mul(amount, REF_BONUS), 100); // 4%\r\n            affiliateCommision[referral] = SafeMath.add(affiliateCommision[referral], refBonus);\r\n        }\r\n        \r\n        // hand out the dev tax\r\n        uint256 devTax = SafeMath.div(SafeMath.mul(amount, DEV_TAX), 100); // 1%\r\n        affiliateCommision[dev] = SafeMath.add(affiliateCommision[dev], devTax);\r\n\r\n        \r\n        // now put it in your own piggy bank!\r\n        investedETH[msg.sender] = SafeMath.add(investedETH[msg.sender], amount);\r\n        lastInvest[msg.sender] = now;\r\n\r\n    }\r\n    \r\n    function divestETH() public {\r\n\r\n        uint256 profit = getProfit(msg.sender);\r\n        \r\n        // 20% fee on taking capital out\r\n        uint256 capital = investedETH[msg.sender];\r\n        uint256 fee = SafeMath.div(capital, 5);\r\n        capital = SafeMath.sub(capital, fee);\r\n        \r\n        uint256 total = SafeMath.add(capital, profit);\r\n\r\n        require(total > 0);\r\n        investedETH[msg.sender] = 0;\r\n        lastInvest[msg.sender] = now;\r\n        msg.sender.transfer(total);\r\n\r\n    }\r\n    \r\n    function withdraw() public{\r\n\r\n        uint256 profit = getProfit(msg.sender);\r\n\r\n        require(profit > 0);\r\n        lastInvest[msg.sender] = now;\r\n        msg.sender.transfer(profit);\r\n\r\n    }\r\n\r\n    function withdrawAffiliateCommision() public {\r\n\r\n        require(affiliateCommision[msg.sender] > 0);\r\n        uint256 commision = affiliateCommision[msg.sender];\r\n        affiliateCommision[msg.sender] = 0;\r\n        msg.sender.transfer(commision);\r\n\r\n    }\r\n    \r\n    function reinvestProfit() public {\r\n\r\n        uint256 profit = getProfit(msg.sender);\r\n\r\n        require(profit > 0);\r\n        lastInvest[msg.sender] = now;\r\n        investedETH[msg.sender] = SafeMath.add(investedETH[msg.sender], profit);\r\n\r\n    }\r\n\r\n    function inheritInvestorPosition(uint256 index) public payable {\r\n\r\n        require(investorPositions.length > index);\r\n        require(msg.sender == tx.origin);\r\n\r\n        InvestorPosition storage position = investorPositions[index];\r\n        uint256 currentLevel = getCurrentLevel(position.startingLevel, position.startingTime, position.halfLife);\r\n        uint256 currentPrice = getCurrentPrice(currentLevel);\r\n\r\n        require(msg.value >= currentPrice);\r\n        uint256 purchaseExcess = SafeMath.sub(msg.value, currentPrice);\r\n        position.startingLevel = currentLevel + 1;\r\n        position.startingTime = now;\r\n\r\n        // now do the transfers\r\n        uint256 inheritanceTax = SafeMath.div(SafeMath.mul(currentPrice, INHERITANCE_TAX), 100); // 75%\r\n        position.investor.transfer(inheritanceTax);\r\n        position.investor = msg.sender; // set the new investor address\r\n\r\n        // now the dev transfer tax\r\n        uint256 devTransferTax = SafeMath.div(SafeMath.mul(currentPrice, DEV_TRANSFER_TAX), 100); // 5%\r\n        dev.transfer(devTransferTax);\r\n\r\n        // and finally the excess\r\n        msg.sender.transfer(purchaseExcess);\r\n\r\n        // after this point there will be 20% of currentPrice left in the contract\r\n        // this will be automatically go towards paying for profits and withdrawals\r\n\r\n    }\r\n\r\n    function getInvestorPosition(uint256 index) public view returns(address investor, uint256 currentPrice, uint256 halfLife, uint256 percentageCut) {\r\n        InvestorPosition memory position = investorPositions[index];\r\n        return (position.investor, getCurrentPrice(getCurrentLevel(position.startingLevel, position.startingTime, position.halfLife)), position.halfLife, position.percentageCut);\r\n    }\r\n\r\n    function getCurrentPrice(uint256 currentLevel) internal view returns(uint256) {\r\n        return BASE_PRICE * 2**currentLevel; // ** is exponent, price doubles every level\r\n    }\r\n\r\n    function getCurrentLevel(uint256 startingLevel, uint256 startingTime, uint256 halfLife) internal view returns(uint256) {\r\n        uint256 timePassed = SafeMath.sub(now, startingTime);\r\n        uint256 levelsPassed = SafeMath.div(timePassed, halfLife);\r\n        if (startingLevel < levelsPassed) {\r\n            return 0;\r\n        }\r\n        return SafeMath.sub(startingLevel,levelsPassed);\r\n    }\r\n\r\n    function getProfitFromSender() public view returns(uint256){\r\n        return getProfit(msg.sender);\r\n    }\r\n\r\n    function getProfit(address customer) public view returns(uint256){\r\n        uint256 secondsPassed = SafeMath.sub(now, lastInvest[customer]);\r\n        return SafeMath.div(SafeMath.mul(secondsPassed, investedETH[customer]), 5760000); // = days * amount * 0.015 (+1.5% per day)\r\n    }\r\n    \r\n    function getAffiliateCommision() public view returns(uint256){\r\n        return affiliateCommision[msg.sender];\r\n    }\r\n    \r\n    function getInvested() public view returns(uint256){\r\n        return investedETH[msg.sender];\r\n    }\r\n    \r\n    function getBalance() public view returns(uint256){\r\n        return this.balance;\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"divestETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAffiliateCommision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliateCommision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProfitFromSender\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInvestorPosition\",\"outputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"halfLife\",\"type\":\"uint256\"},{\"name\":\"percentageCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"investETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"customer\",\"type\":\"address\"}],\"name\":\"getProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"inheritInvestorPosition\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvestProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAffiliateCommision\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"EtherPiggyBank","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3e6a11f24b629359d385e224da148555eff648e9c46ee0ecbf672ab7bf666601"}]}