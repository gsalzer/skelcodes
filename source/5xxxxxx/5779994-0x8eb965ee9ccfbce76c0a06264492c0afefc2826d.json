{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract ToorToken is ERC20Basic, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Account {\r\n        uint balance;\r\n        uint lastInterval;\r\n    }\r\n\r\n    mapping(address => Account) public accounts;\r\n    mapping(uint256 => uint256) ratesByYear;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 private rateMultiplier;\r\n\r\n    uint256 initialSupply_;\r\n    uint256 totalSupply_;\r\n    uint256 public maxSupply;\r\n    uint256 public startTime;\r\n    uint256 public pendingRewardsToMint;\r\n\r\n    string public name;\r\n    uint public decimals;\r\n    string public symbol;\r\n\r\n    uint256 private tokenGenInterval; // This defines the frequency at which we calculate rewards\r\n    uint256 private vestingPeriod; // Defines how often tokens vest to team\r\n    uint256 private cliff; // Defines the minimum amount of time required before tokens vest\r\n    uint256 public pendingInstallments; // Defines the number of pending vesting installments for team\r\n    uint256 public paidInstallments; // Defines the number of paid vesting installments for team\r\n    uint256 private totalVestingPool; //  Defines total vesting pool set aside for team\r\n    uint256 public pendingVestingPool; // Defines pending tokens in pool set aside for team\r\n    uint256 public finalIntervalForTokenGen; // The last instance of reward calculation, after which rewards will cease\r\n    uint256 private totalRateWindows; // This specifies the number of rate windows over the total period of time\r\n    uint256 private intervalsPerWindow; // Total number of times we calculate rewards within 1 rate window\r\n\r\n    // Variable to define once reward generation is complete\r\n    bool public rewardGenerationComplete;\r\n\r\n    // Ether addresses of founders and company\r\n    mapping(uint256 => address) public distributionAddresses;\r\n\r\n    // Events section\r\n    event Mint(address indexed to, uint256 amount);\r\n    event Burn(address indexed burner, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function ToorToken() public {\r\n        name = \"ToorCoin\";\r\n        decimals = 18;\r\n        symbol = \"TOOR\";\r\n\r\n        // Setup the token staking reward percentage per year\r\n        rateMultiplier = 10**9;\r\n        ratesByYear[1] = 1.00474436 * 10**9;\r\n        ratesByYear[2] = 1.003278088 * 10**9;\r\n        ratesByYear[3] = 1.002799842 * 10**9;\r\n        ratesByYear[4] = 1.002443535 * 10**9;\r\n        ratesByYear[5] = 1.002167763 * 10**9;\r\n        ratesByYear[6] = 1.001947972 * 10**9;\r\n        ratesByYear[7] = 1.001768676 * 10**9;\r\n        ratesByYear[8] = 1.001619621 * 10**9;\r\n        ratesByYear[9] = 1.001493749 * 10**9;\r\n        ratesByYear[10] = 1.001386038 * 10**9;\r\n        ratesByYear[11] = 1.001292822 * 10**9;\r\n        ratesByYear[12] = 1.001211358 * 10**9;\r\n        ratesByYear[13] = 1.001139554 * 10**9;\r\n        ratesByYear[14] = 1.001075789 * 10**9;\r\n        ratesByYear[15] = 1.001018783 * 10**9;\r\n        ratesByYear[16] = 1.000967516 * 10**9;\r\n        ratesByYear[17] = 1.000921162 * 10**9;\r\n        ratesByYear[18] = 1.000879048 * 10**9;\r\n        ratesByYear[19] = 1.000840616 * 10**9;\r\n        ratesByYear[20] = 1.000805405 * 10**9;\r\n\r\n        totalRateWindows = 20;\r\n        \r\n        maxSupply = 100000000 * 10**18;\r\n        initialSupply_ = 13500000 * 10**18;\r\n        pendingInstallments = 7;\r\n        paidInstallments = 0;\r\n        totalVestingPool = 4500000 * 10**18;\r\n        startTime = now;\r\n\r\n        distributionAddresses[1] = 0x7d3BC9bb69dAB0544d34b7302DED8806bCF715e6; // founder 1\r\n        distributionAddresses[2] = 0x34Cf9afae3f926B9D040CA7A279C411355c5C480; // founder 2\r\n        distributionAddresses[3] = 0x059Cbd8A57b1dD944Da020a0D0a18D8dD7e78E04; // founder 3\r\n        distributionAddresses[4] = 0x4F8bC705827Fb8A781b27B9F02d2491F531f8962; // founder 4\r\n        distributionAddresses[5] = 0x532d370a98a478714625E9148D1205be061Df3bf; // founder 5\r\n        distributionAddresses[6] = 0xDe485bB000fA57e73197eF709960Fb7e32e0380E; // company\r\n        distributionAddresses[7] = 0xd562f635c75D2d7f3BE0005FBd3808a5cfb896bd; // bounty\r\n        \r\n        // This is for 20 years\r\n        tokenGenInterval = 603936;  // This is roughly 1 week in seconds\r\n        uint256 timeToGenAllTokens = 628093440; // This is close to 20 years in seconds\r\n\r\n        rewardGenerationComplete = false;\r\n        \r\n        // Mint initial tokens\r\n        accounts[distributionAddresses[6]].balance = (initialSupply_ * 60) / 100; // 60% of initial balance goes to Company\r\n        accounts[distributionAddresses[6]].lastInterval = 0;\r\n        generateMintEvents(distributionAddresses[6],accounts[distributionAddresses[6]].balance);\r\n        accounts[distributionAddresses[7]].balance = (initialSupply_ * 40) / 100; // 40% of inital balance goes to Bounty\r\n        accounts[distributionAddresses[7]].lastInterval = 0;\r\n        generateMintEvents(distributionAddresses[7],accounts[distributionAddresses[7]].balance);\r\n\r\n        pendingVestingPool = totalVestingPool;\r\n        pendingRewardsToMint = maxSupply - initialSupply_ - totalVestingPool;\r\n        totalSupply_ = initialSupply_;\r\n        vestingPeriod = timeToGenAllTokens / (totalRateWindows * 12); // One vesting period is a month\r\n        cliff = vestingPeriod * 6; // Cliff is six vesting periods aka 6 months roughly\r\n        finalIntervalForTokenGen = timeToGenAllTokens / tokenGenInterval;\r\n        intervalsPerWindow = finalIntervalForTokenGen / totalRateWindows;\r\n    }\r\n\r\n    // This gives the total supply of actual minted coins. Does not take rewards pending minting into consideration\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    // This function is called directly by users who wish to transfer tokens\r\n    function transfer(address _to, uint256 _value) canTransfer(_to) public returns (bool) {\r\n        // Call underlying transfer method and pass in the sender address\r\n        transferBasic(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // This function is called by both transfer and transferFrom\r\n    function transferBasic(address _from, address _to, uint256 _value) internal {\r\n        uint256 tokensOwedSender = 0;\r\n        uint256 tokensOwedReceiver = 0;\r\n        uint256 balSender = balanceOfBasic(_from);\r\n\r\n        // Distribute rewards tokens first\r\n        if (!rewardGenerationComplete) {\r\n            tokensOwedSender = tokensOwed(_from);\r\n            require(_value <= (balSender.add(tokensOwedSender))); // Sender should have the number of tokens they want to send\r\n\r\n            tokensOwedReceiver = tokensOwed(_to);\r\n\r\n            // If there were tokens owed, increase total supply accordingly\r\n            if ((tokensOwedSender.add(tokensOwedReceiver)) > 0) {\r\n                increaseTotalSupply(tokensOwedSender.add(tokensOwedReceiver)); // This will break if total exceeds max cap\r\n                pendingRewardsToMint = pendingRewardsToMint.sub(tokensOwedSender.add(tokensOwedReceiver));\r\n            }\r\n\r\n            // If there were tokens owed, raise mint events for them\r\n            raiseEventIfMinted(_from, tokensOwedSender);\r\n            raiseEventIfMinted(_to, tokensOwedReceiver);\r\n        } else {\r\n            require(_value <= balSender);\r\n        }\r\n        \r\n        // Update balances of sender and receiver\r\n        accounts[_from].balance = (balSender.add(tokensOwedSender)).sub(_value);\r\n        accounts[_to].balance = (accounts[_to].balance.add(tokensOwedReceiver)).add(_value);\r\n\r\n        // Update last intervals for sender and receiver\r\n        uint256 currInt = intervalAtTime(now);\r\n        accounts[_from].lastInterval = currInt;\r\n        accounts[_to].lastInterval = currInt;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    // If you want to transfer tokens to multiple receivers at once\r\n    function batchTransfer(address[] _receivers, uint256 _value) public returns (bool) {\r\n        uint256 cnt = _receivers.length;\r\n        uint256 amount = cnt.mul(_value);\r\n        \r\n        // Check that the value to send is more than 0\r\n        require(_value > 0);\r\n\r\n        // Add pending rewards for sender first\r\n        if (!rewardGenerationComplete) {\r\n            addReward(msg.sender);\r\n        }\r\n\r\n        // Get current balance of sender\r\n        uint256 balSender = balanceOfBasic(msg.sender);\r\n\r\n        // Check that the sender has the required amount\r\n        require(balSender >= amount);\r\n\r\n        // Update balance and lastInterval of sender\r\n        accounts[msg.sender].balance = balSender.sub(amount);\r\n        uint256 currInt = intervalAtTime(now);\r\n        accounts[msg.sender].lastInterval = currInt;\r\n        \r\n        \r\n        for (uint i = 0; i < cnt; i++) {\r\n            // Add pending rewards for receiver first\r\n            if (!rewardGenerationComplete) {\r\n                address receiver = _receivers[i];\r\n                \r\n                addReward(receiver);\r\n            }\r\n\r\n            // Update balance and lastInterval of receiver\r\n            accounts[_receivers[i]].balance = (accounts[_receivers[i]].balance).add(_value);\r\n            accounts[_receivers[i]].lastInterval = currInt;\r\n            emit Transfer(msg.sender, _receivers[i], _value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // This function allows someone to withdraw tokens from someone's address\r\n    // For this to work, the person needs to have been approved by the account owner (via the approve function)\r\n    function transferFrom(address _from, address _to, uint256 _value) canTransfer(_to) public returns (bool)\r\n    {\r\n        // Check that function caller has been approved to withdraw tokens\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        // Call out base transfer method\r\n        transferBasic(_from, _to, _value);\r\n\r\n        // Subtract withdrawn tokens from allowance\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        return true;\r\n    }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n      /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n    function allowance(address _owner, address _spender) public view returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n  \r\n   // Increase the amount of tokens that an owner allowed to a spender.\r\n   // approve should be called when allowed[_spender] == 0. To increment\r\n   // allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n   // Decrease the amount of tokens that an owner allowed to a spender.\r\n   // approve should be called when allowed[_spender] == 0. To decrement\r\n   // allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined)\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool)\r\n    {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function raiseEventIfMinted(address owner, uint256 tokensToReward) private returns (bool) {\r\n        if (tokensToReward > 0) {\r\n            generateMintEvents(owner, tokensToReward);\r\n        }\r\n    }\r\n\r\n    function addReward(address owner) private returns (bool) {\r\n        uint256 tokensToReward = tokensOwed(owner);\r\n\r\n        if (tokensToReward > 0) {\r\n            increaseTotalSupply(tokensToReward); // This will break if total supply exceeds max cap. Should never happen though as tokensOwed checks for this condition\r\n            accounts[owner].balance = accounts[owner].balance.add(tokensToReward);\r\n            accounts[owner].lastInterval = intervalAtTime(now);\r\n            pendingRewardsToMint = pendingRewardsToMint.sub(tokensToReward); // This helps track rounding errors when computing rewards\r\n            generateMintEvents(owner, tokensToReward);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // This function is to vest tokens to the founding team\r\n    // This deliberately doesn't use SafeMath as all the values are controlled without risk of overflow\r\n    function vestTokens() public returns (bool) {\r\n        require(pendingInstallments > 0);\r\n        require(paidInstallments < 7);\r\n        require(pendingVestingPool > 0);\r\n        require(now - startTime > cliff);\r\n\r\n        // If they have rewards pending, allocate those first\r\n        if (!rewardGenerationComplete) {\r\n            for (uint256 i = 1; i <= 5; i++) {\r\n                addReward(distributionAddresses[i]);\r\n            }\r\n        }\r\n\r\n        uint256 currInterval = intervalAtTime(now);\r\n        uint256 tokensToVest = 0;\r\n        uint256 totalTokensToVest = 0;\r\n        uint256 totalPool = totalVestingPool;\r\n\r\n        uint256[2] memory founderCat;\r\n        founderCat[0] = 0;\r\n        founderCat[1] = 0;\r\n\r\n        uint256[5] memory origFounderBal;\r\n        origFounderBal[0] = accounts[distributionAddresses[1]].balance;\r\n        origFounderBal[1] = accounts[distributionAddresses[2]].balance;\r\n        origFounderBal[2] = accounts[distributionAddresses[3]].balance;\r\n        origFounderBal[3] = accounts[distributionAddresses[4]].balance;\r\n        origFounderBal[4] = accounts[distributionAddresses[5]].balance;\r\n\r\n        uint256[2] memory rewardCat;\r\n        rewardCat[0] = 0;\r\n        rewardCat[1] = 0;\r\n\r\n        // Pay out cliff\r\n        if (paidInstallments < 1) {\r\n            uint256 intervalAtCliff = intervalAtTime(cliff + startTime);\r\n            tokensToVest = totalPool / 4;\r\n\r\n            founderCat[0] = tokensToVest / 4;\r\n            founderCat[1] = tokensToVest / 8;\r\n\r\n            // Update vesting pool\r\n            pendingVestingPool -= tokensToVest;\r\n\r\n            // This condition checks if there are any rewards to pay after the cliff\r\n            if (currInterval > intervalAtCliff && !rewardGenerationComplete) {\r\n                rewardCat[0] = tokensOwedByInterval(founderCat[0], intervalAtCliff, currInterval);\r\n                rewardCat[1] = rewardCat[0] / 2;\r\n\r\n                // Add rewards to founder tokens being vested\r\n                founderCat[0] += rewardCat[0];\r\n                founderCat[1] += rewardCat[1];\r\n\r\n                // Increase total amount of tokens to vest\r\n                tokensToVest += ((3 * rewardCat[0]) + (2 * rewardCat[1]));\r\n\r\n                // Reduce pending rewards\r\n                pendingRewardsToMint -= ((3 * rewardCat[0]) + (2 * rewardCat[1]));\r\n            }\r\n\r\n            // Vest tokens for each of the founders, this includes any rewards pending since cliff passed\r\n            accounts[distributionAddresses[1]].balance += founderCat[0];\r\n            accounts[distributionAddresses[2]].balance += founderCat[0];\r\n            accounts[distributionAddresses[3]].balance += founderCat[0];\r\n            accounts[distributionAddresses[4]].balance += founderCat[1];\r\n            accounts[distributionAddresses[5]].balance += founderCat[1];\r\n\r\n            totalTokensToVest = tokensToVest;\r\n\r\n            // Update pending and paid installments\r\n            pendingInstallments -= 1;\r\n            paidInstallments += 1;\r\n        }\r\n\r\n        // Calculate the pending non-cliff installments to pay based on current time\r\n        uint256 installments = ((currInterval * tokenGenInterval) - cliff) / vestingPeriod;\r\n        uint256 installmentsToPay = installments + 1 - paidInstallments;\r\n\r\n        // If there are no installments to pay, skip this\r\n        if (installmentsToPay > 0) {\r\n            if (installmentsToPay > pendingInstallments) {\r\n                installmentsToPay = pendingInstallments;\r\n            }\r\n\r\n            // 12.5% vesting monthly after the cliff\r\n            tokensToVest = (totalPool * 125) / 1000;\r\n\r\n            founderCat[0] = tokensToVest / 4;\r\n            founderCat[1] = tokensToVest / 8;\r\n\r\n            uint256 intervalsAtVest = 0;\r\n\r\n            // Loop through installments to pay, so that we can add token holding rewards as we go along\r\n            for (uint256 installment = paidInstallments; installment < (installmentsToPay + paidInstallments); installment++) {\r\n                intervalsAtVest = intervalAtTime(cliff + (installment * vestingPeriod) + startTime);\r\n\r\n                // This condition checks if there are any rewards to pay after the cliff\r\n                if (currInterval >= intervalsAtVest && !rewardGenerationComplete) {\r\n                    rewardCat[0] = tokensOwedByInterval(founderCat[0], intervalsAtVest, currInterval);\r\n                    rewardCat[1] = rewardCat[0] / 2;\r\n\r\n                    // Increase total amount of tokens to vest\r\n                    totalTokensToVest += tokensToVest;\r\n                    totalTokensToVest += ((3 * rewardCat[0]) + (2 * rewardCat[1]));\r\n\r\n                    // Reduce pending rewards\r\n                    pendingRewardsToMint -= ((3 * rewardCat[0]) + (2 * rewardCat[1]));\r\n\r\n                    // Vest tokens for each of the founders, this includes any rewards pending since vest interval passed\r\n                    accounts[distributionAddresses[1]].balance += (founderCat[0] + rewardCat[0]);\r\n                    accounts[distributionAddresses[2]].balance += (founderCat[0] + rewardCat[0]);\r\n                    accounts[distributionAddresses[3]].balance += (founderCat[0] + rewardCat[0]);\r\n                    accounts[distributionAddresses[4]].balance += (founderCat[1] + rewardCat[1]);\r\n                    accounts[distributionAddresses[5]].balance += (founderCat[1] + rewardCat[1]);\r\n                }\r\n            }\r\n\r\n            // Reduce pendingVestingPool and update pending and paid installments\r\n            pendingVestingPool -= (installmentsToPay * tokensToVest);\r\n            pendingInstallments -= installmentsToPay;\r\n            paidInstallments += installmentsToPay;\r\n        }\r\n\r\n        // Increase total supply by the number of tokens being vested\r\n        increaseTotalSupply(totalTokensToVest);\r\n            \r\n        accounts[distributionAddresses[1]].lastInterval = currInterval;\r\n        accounts[distributionAddresses[2]].lastInterval = currInterval;\r\n        accounts[distributionAddresses[3]].lastInterval = currInterval;\r\n        accounts[distributionAddresses[4]].lastInterval = currInterval;\r\n        accounts[distributionAddresses[5]].lastInterval = currInterval;\r\n\r\n        // Create events for token generation\r\n        generateMintEvents(distributionAddresses[1], (accounts[distributionAddresses[1]].balance - origFounderBal[0]));\r\n        generateMintEvents(distributionAddresses[2], (accounts[distributionAddresses[2]].balance - origFounderBal[1]));\r\n        generateMintEvents(distributionAddresses[3], (accounts[distributionAddresses[3]].balance - origFounderBal[2]));\r\n        generateMintEvents(distributionAddresses[4], (accounts[distributionAddresses[4]].balance - origFounderBal[3]));\r\n        generateMintEvents(distributionAddresses[5], (accounts[distributionAddresses[5]].balance - origFounderBal[4]));\r\n    }\r\n\r\n    function increaseTotalSupply (uint256 tokens) private returns (bool) {\r\n        require ((totalSupply_.add(tokens)) <= maxSupply);\r\n        totalSupply_ = totalSupply_.add(tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    function tokensOwed(address owner) public view returns (uint256) {\r\n        // This array is introduced to circumvent stack depth issues\r\n        uint256 currInterval = intervalAtTime(now);\r\n        uint256 lastInterval = accounts[owner].lastInterval;\r\n        uint256 balance = accounts[owner].balance;\r\n\r\n        return tokensOwedByInterval(balance, lastInterval, currInterval);\r\n    }\r\n\r\n    function tokensOwedByInterval(uint256 balance, uint256 lastInterval, uint256 currInterval) public view returns (uint256) {\r\n        // Once the specified address has received all possible rewards, don't calculate anything\r\n        if (lastInterval >= currInterval || lastInterval >= finalIntervalForTokenGen) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 tokensHeld = balance; //tokensHeld\r\n        uint256 intPerWin = intervalsPerWindow;\r\n        uint256 totalRateWinds = totalRateWindows;\r\n\r\n        // Defines the number of intervals we compute rewards for at a time\r\n        uint256 intPerBatch = 5; // Hardcoded here instead of storing on blockchain to save gas\r\n\r\n        mapping(uint256 => uint256) ratByYear = ratesByYear;\r\n        uint256 ratMultiplier = rateMultiplier;\r\n\r\n        uint256 minRateWindow = (lastInterval / intPerWin).add(1);\r\n        uint256 maxRateWindow = (currInterval / intPerWin).add(1);\r\n        if (maxRateWindow > totalRateWinds) {\r\n            maxRateWindow = totalRateWinds;\r\n        }\r\n\r\n        // Loop through pending periods of rewards, and calculate the total balance user should hold\r\n        for (uint256 rateWindow = minRateWindow; rateWindow <= maxRateWindow; rateWindow++) {\r\n            uint256 intervals = getIntervalsForWindow(rateWindow, lastInterval, currInterval, intPerWin);\r\n\r\n            // This part is to ensure we don't overflow when rewards are pending for a large number of intervals\r\n            // Loop through interval in batches\r\n            while (intervals > 0) {\r\n                if (intervals >= intPerBatch) {\r\n                    tokensHeld = (tokensHeld.mul(ratByYear[rateWindow] ** intPerBatch)) / (ratMultiplier ** intPerBatch);\r\n                    intervals = intervals.sub(intPerBatch);\r\n                } else {\r\n                    tokensHeld = (tokensHeld.mul(ratByYear[rateWindow] ** intervals)) / (ratMultiplier ** intervals);\r\n                    intervals = 0;\r\n                }\r\n            }            \r\n        }\r\n\r\n        // Rewards owed are the total balance that user SHOULD have minus what they currently have\r\n        return (tokensHeld.sub(balance));\r\n    }\r\n\r\n    function intervalAtTime(uint256 time) public view returns (uint256) {\r\n        // Check to see that time passed in is not before contract generation time, as that would cause a negative value in the next step\r\n        if (time <= startTime) {\r\n            return 0;\r\n        }\r\n\r\n        // Based on time passed in, check how many intervals have elapsed\r\n        uint256 interval = (time.sub(startTime)) / tokenGenInterval;\r\n        uint256 finalInt = finalIntervalForTokenGen; // Assign to local to reduce gas\r\n        \r\n        // Return max intervals if it's greater than that time\r\n        if (interval > finalInt) {\r\n            return finalInt;\r\n        } else {\r\n            return interval;\r\n        }\r\n    }\r\n\r\n    // This function checks how many intervals for a given window do we owe tokens to someone for \r\n    function getIntervalsForWindow(uint256 rateWindow, uint256 lastInterval, uint256 currInterval, uint256 intPerWind) public pure returns (uint256) {\r\n        // If lastInterval for holder falls in a window previous to current one, the lastInterval for the window passed into the function would be the window start interval\r\n        if (lastInterval < ((rateWindow.sub(1)).mul(intPerWind))) {\r\n            lastInterval = ((rateWindow.sub(1)).mul(intPerWind));\r\n        }\r\n\r\n        // If currentInterval for holder falls in a window higher than current one, the currentInterval for the window passed into the function would be the window end interval\r\n        if (currInterval > rateWindow.mul(intPerWind)) {\r\n            currInterval = rateWindow.mul(intPerWind);\r\n        }\r\n\r\n        return currInterval.sub(lastInterval);\r\n    }\r\n\r\n    // This function tells the balance of tokens at a particular address\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        if (rewardGenerationComplete) {\r\n            return accounts[_owner].balance;\r\n        } else {\r\n            return (accounts[_owner].balance).add(tokensOwed(_owner));\r\n        }\r\n    }\r\n\r\n    function balanceOfBasic(address _owner) public view returns (uint256 balance) {\r\n        return accounts[_owner].balance;\r\n    }\r\n\r\n    // This functions returns the last time at which rewards were transferred to a particular address\r\n    function lastTimeOf(address _owner) public view returns (uint256 interval, uint256 time) {\r\n        return (accounts[_owner].lastInterval, ((accounts[_owner].lastInterval).mul(tokenGenInterval)).add(startTime));\r\n    }\r\n\r\n    // This function is not meant to be used. It's only written as a fail-safe against potential unforeseen issues\r\n    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {\r\n        // Add pending rewards for recipient of minted tokens\r\n        if (!rewardGenerationComplete) {\r\n            addReward(_to);\r\n        }\r\n\r\n        // Increase total supply by minted amount\r\n        increaseTotalSupply(_amount);\r\n\r\n        // Update balance and last interval\r\n        accounts[_to].lastInterval = intervalAtTime(now);\r\n        accounts[_to].balance = (accounts[_to].balance).add(_amount);\r\n\r\n        generateMintEvents(_to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function generateMintEvents(address _to, uint256 _amount) private returns (bool) {\r\n        emit Mint(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Allows the burning of tokens\r\n    function burn(uint256 _value) public {\r\n        require(_value <= balanceOf(msg.sender));\r\n\r\n        // First add any rewards pending for the person burning tokens\r\n        if (!rewardGenerationComplete) {\r\n            addReward(msg.sender);\r\n        }\r\n\r\n        // Update balance and lastInterval of person burning tokens\r\n        accounts[msg.sender].balance = (accounts[msg.sender].balance).sub(_value);\r\n        accounts[msg.sender].lastInterval = intervalAtTime(now);\r\n\r\n        // Update total supply\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n\r\n        // Raise events\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n    }\r\n\r\n    // These set of functions allow changing of founder and company addresses\r\n    function setFounder(uint256 id, address _to) onlyOwner public returns (bool) {\r\n        require(_to != address(0));\r\n        distributionAddresses[id] = _to;\r\n        return true;\r\n    }\r\n\r\n    // This is a setter for rewardGenerationComplete. It will be used to see if token rewards need to be computed, and can only be set by owner\r\n    function setRewardGenerationComplete(bool _value) onlyOwner public returns (bool) {\r\n        rewardGenerationComplete = _value;\r\n        return true;\r\n    }\r\n\r\n    // This function is added to get a state of where the token is in term of reward generation\r\n    function getNow() public view returns (uint256, uint256, uint256) {\r\n        return (now, block.number, intervalAtTime(now));\r\n    }\r\n\r\n    // This modifier is used on the transfer method and defines where tokens CANNOT be sent\r\n    modifier canTransfer(address _to) {\r\n        require(_to != address(0)); // Transfer should not be allowed to burn tokens\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"intervalAtTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"lastTimeOf\",\"outputs\":[{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"lastInterval\",\"type\":\"uint256\"},{\"name\":\"currInterval\",\"type\":\"uint256\"}],\"name\":\"tokensOwedByInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paidInstallments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingRewardsToMint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"lastInterval\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingVestingPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setFounder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setRewardGenerationComplete\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"vestTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"distributionAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardGenerationComplete\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rateWindow\",\"type\":\"uint256\"},{\"name\":\"lastInterval\",\"type\":\"uint256\"},{\"name\":\"currInterval\",\"type\":\"uint256\"},{\"name\":\"intPerWind\",\"type\":\"uint256\"}],\"name\":\"getIntervalsForWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOfBasic\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingInstallments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalIntervalForTokenGen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"ToorToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://743a4097f06e10351dce172395bc465febd64a21459f5646aa466412fba157c3"}]}