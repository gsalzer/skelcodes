{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\ncontract Dice2Win {\r\n\r\n    /// Constants\r\n\r\n    // Chance to win jackpot - currently 0.1%\r\n    uint256 constant JACKPOT_MODULO = 1000;\r\n\r\n    // Each bet is deducted 2% amount - 1% is house edge, 1% goes to jackpot fund.\r\n    uint256 constant HOUSE_EDGE_PERCENT = 2;\r\n    uint256 constant JACKPOT_FEE_PERCENT = 50;\r\n\r\n    // Minimum supported bet is 0.02 ETH, made possible by optimizing gas costs\r\n    // compared to our competitors.\r\n    uint256 constant MIN_BET = 0.02 ether;\r\n\r\n    // Only bets higher that 0.1 ETH have a chance to win jackpot.\r\n    uint256 constant MIN_JACKPOT_BET = 0.1 ether;\r\n\r\n    // Random number generation is provided by the hashes of future blocks.\r\n    // Two blocks is a good compromise between responsive gameplay and safety from miner attacks.\r\n    uint256 constant BLOCK_DELAY = 2;\r\n\r\n    // Bets made more than 100 blocks ago are considered failed - this has to do\r\n    // with EVM limitations on block hashes that are queryable. Settlement failure\r\n    // is most probably due to croupier bot failure, if you ever end in this situation\r\n    // ask dice2.win support for a refund!\r\n    uint256 constant BET_EXPIRATION_BLOCKS = 100;\r\n\r\n    /// Contract storage.\r\n\r\n    // Changing ownership of the contract safely\r\n    address public owner;\r\n    address public nextOwner;\r\n\r\n    // Max bet limits for coin toss/single dice and double dice respectively.\r\n    // Setting these values to zero effectively disables the respective games.\r\n    uint256 public maxBetCoinDice;\r\n    uint256 public maxBetDoubleDice;\r\n\r\n    // Current jackpot size.\r\n    uint128 public jackpotSize;\r\n\r\n    // Amount locked in ongoing bets - this is to be sure that we do not commit to bets\r\n    // that we cannot fulfill in case of win.\r\n    uint128 public lockedInBets;\r\n\r\n    /// Enum representing games\r\n\r\n    enum GameId {\r\n        CoinFlip,\r\n        SingleDice,\r\n        DoubleDice,\r\n\r\n        MaxGameId\r\n    }\r\n\r\n    uint256 constant MAX_BLOCK_NUMBER = 2 ** 56;\r\n    uint256 constant MAX_BET_MASK = 2 ** 64;\r\n    uint256 constant MAX_AMOUNT = 2 ** 128;\r\n\r\n    // Struct is tightly packed into a single 256-bit by Solidity compiler.\r\n    // This is made to reduce gas costs of placing & settlement transactions.\r\n    struct ActiveBet {\r\n        // A game that was played.\r\n        GameId gameId;\r\n        // Block number in which bet transaction was mined.\r\n        uint56 placeBlockNumber;\r\n        // A binary mask with 1 for each option.\r\n        // For example, if you play dice, the mask ranges from 000001 in binary (betting on one)\r\n        // to 111111 in binary (betting on all dice outcomes at once).\r\n        uint64 mask;\r\n        // Bet amount in wei.\r\n        uint128 amount;\r\n    }\r\n\r\n    mapping (address => ActiveBet) activeBets;\r\n\r\n    // Events that are issued to make statistic recovery easier.\r\n    event FailedPayment(address indexed _beneficiary, uint256 amount);\r\n    event Payment(address indexed _beneficiary, uint256 amount);\r\n    event JackpotPayment(address indexed _beneficiary, uint256 amount);\r\n\r\n    /// Contract governance.\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        // all fields are automatically initialized to zero, which is just what's needed.\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // This is pretty standard ownership change routine.\r\n\r\n    function approveNextOwner(address _nextOwner) public onlyOwner {\r\n        require (_nextOwner != owner);\r\n        nextOwner = _nextOwner;\r\n    }\r\n\r\n    function acceptNextOwner() public {\r\n        require (msg.sender == nextOwner);\r\n        owner = nextOwner;\r\n    }\r\n\r\n    // Contract may be destroyed only when there are no ongoing bets,\r\n    // either settled or refunded. All funds are transferred to contract owner.\r\n\r\n    function kill() public onlyOwner {\r\n        require (lockedInBets == 0);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the bank roll.\r\n    function () public payable {\r\n    }\r\n\r\n    // Helper routines to alter the respective max bet limits.\r\n    function changeMaxBetCoinDice(uint256 newMaxBetCoinDice) public onlyOwner {\r\n        maxBetCoinDice = newMaxBetCoinDice;\r\n    }\r\n\r\n    function changeMaxBetDoubleDice(uint256 newMaxBetDoubleDice) public onlyOwner {\r\n        maxBetDoubleDice = newMaxBetDoubleDice;\r\n    }\r\n\r\n    // Ability to top up jackpot faster than it's natural growth by house fees.\r\n    function increaseJackpot(uint256 increaseAmount) public onlyOwner {\r\n        require (increaseAmount <= address(this).balance);\r\n        require (jackpotSize + lockedInBets + increaseAmount <= address(this).balance);\r\n        jackpotSize += uint128(increaseAmount);\r\n    }\r\n\r\n    // Funds withdrawal to cover costs of dice2.win operation.\r\n    function withdrawFunds(address beneficiary, uint256 withdrawAmount) public onlyOwner {\r\n        require (withdrawAmount <= address(this).balance);\r\n        require (jackpotSize + lockedInBets + withdrawAmount <= address(this).balance);\r\n        sendFunds(beneficiary, withdrawAmount, withdrawAmount);\r\n    }\r\n\r\n    /// Betting logic\r\n\r\n    // Bet transaction - issued by player. Contains the desired game id and betting options\r\n    // mask. Wager is the value in ether attached to the transaction.\r\n    function placeBet(GameId gameId, uint256 betMask) public payable {\r\n        // Check that there is no ongoing bet already - we support one game at a time\r\n        // from single address.\r\n        ActiveBet storage bet = activeBets[msg.sender];\r\n        require (bet.amount == 0);\r\n\r\n        // Check that the values passed fit into respective limits.\r\n        require (gameId < GameId.MaxGameId);\r\n        require (msg.value >= MIN_BET && msg.value <= getMaxBet(gameId));\r\n        require (betMask < MAX_BET_MASK);\r\n\r\n        // Determine roll parameters.\r\n        uint256 rollModulo = getRollModulo(gameId);\r\n        uint256 rollUnder = getRollUnder(rollModulo, betMask);\r\n\r\n        // Check whether contract has enough funds to process this bet.\r\n        uint256 reservedAmount = getDiceWinAmount(msg.value, rollModulo, rollUnder);\r\n        uint256 jackpotFee = getJackpotFee(msg.value);\r\n        require (jackpotSize + lockedInBets + reservedAmount + jackpotFee <= address(this).balance);\r\n\r\n        // Update reserved amounts.\r\n        lockedInBets += uint128(reservedAmount);\r\n        jackpotSize += uint128(jackpotFee);\r\n\r\n        // Store the bet parameters on blockchain.\r\n        bet.gameId = gameId;\r\n        bet.placeBlockNumber = uint56(block.number);\r\n        bet.mask = uint64(betMask);\r\n        bet.amount = uint128(msg.value);\r\n    }\r\n\r\n    // Settlement transaction - can be issued by anyone, but is designed to be handled by the\r\n    // dice2.win croupier bot. However nothing prevents you from issuing it yourself, or anyone\r\n    // issuing the settlement transaction on your behalf - that does not affect the bet outcome and\r\n    // is in fact encouraged in the case the croupier bot malfunctions.\r\n    function settleBet(address gambler) public {\r\n        // Check that there is already a bet for this gambler.\r\n        ActiveBet storage bet = activeBets[gambler];\r\n        require (bet.amount != 0);\r\n\r\n        // Check that the bet is neither too early nor too late.\r\n        require (block.number > bet.placeBlockNumber + BLOCK_DELAY);\r\n        require (block.number <= bet.placeBlockNumber + BET_EXPIRATION_BLOCKS);\r\n\r\n        // The RNG - use hash of the block that is unknown at the time of placing the bet,\r\n        // SHA3 it with gambler address. The latter step is required to make the outcomes of\r\n        // different settlement transactions mined into the same block different.\r\n        bytes32 entropy = keccak256(gambler, blockhash(bet.placeBlockNumber + BLOCK_DELAY));\r\n\r\n        uint256 diceWin = 0;\r\n        uint256 jackpotWin = 0;\r\n\r\n        // Determine roll parameters, do a roll by taking a modulo of entropy.\r\n        uint256 rollModulo = getRollModulo(bet.gameId);\r\n        uint256 dice = uint256(entropy) % rollModulo;\r\n\r\n        uint256 rollUnder = getRollUnder(rollModulo, bet.mask);\r\n        uint256 diceWinAmount = getDiceWinAmount(bet.amount, rollModulo, rollUnder);\r\n\r\n        // Check the roll result against the bet bit mask.\r\n        if ((2 ** dice) & bet.mask != 0) {\r\n            diceWin = diceWinAmount;\r\n        }\r\n\r\n        // Unlock the bet amount, regardless of the outcome.\r\n        lockedInBets -= uint128(diceWinAmount);\r\n\r\n        // Roll for a jackpot (if eligible).\r\n        if (bet.amount >= MIN_JACKPOT_BET) {\r\n            // The second modulo, statistically independent from the \"main\" dice roll.\r\n            // Effectively you are playing two games at once!\r\n            uint256 jackpotRng = (uint256(entropy) / rollModulo) % JACKPOT_MODULO;\r\n\r\n            // Bingo!\r\n            if (jackpotRng == 0) {\r\n                jackpotWin = jackpotSize;\r\n                jackpotSize = 0;\r\n            }\r\n        }\r\n\r\n        // Remove the processed bet from blockchain storage.\r\n        delete activeBets[gambler];\r\n\r\n        // Tally up the win.\r\n        uint256 totalWin = diceWin + jackpotWin;\r\n\r\n        if (totalWin == 0) {\r\n            totalWin = 1 wei;\r\n        }\r\n\r\n        if (jackpotWin > 0) {\r\n            emit JackpotPayment(gambler, jackpotWin);\r\n        }\r\n\r\n        // Send the funds to gambler.\r\n        sendFunds(gambler, totalWin, diceWin);\r\n    }\r\n\r\n    // Refund transaction - return the bet amount of a roll that was not processed\r\n    // in due timeframe (100 Ethereum blocks). Processing such bets is not possible,\r\n    // because EVM does not have access to the hashes further than 256 blocks ago.\r\n    //\r\n    // Like settlement, this transaction may be issued by anyone, but if you ever\r\n    // find yourself in situation like this, just contact the dice2.win support!\r\n    function refundBet(address gambler) public {\r\n        // Check that there is already a bet for this gambler.\r\n        ActiveBet storage bet = activeBets[gambler];\r\n        require (bet.amount != 0);\r\n\r\n        // The bet should be indeed late.\r\n        require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS);\r\n\r\n        // Determine roll parameters to calculate correct amount of funds locked.\r\n        uint256 rollModulo = getRollModulo(bet.gameId);\r\n        uint256 rollUnder = getRollUnder(rollModulo, bet.mask);\r\n\r\n        lockedInBets -= uint128(getDiceWinAmount(bet.amount, rollModulo, rollUnder));\r\n\r\n        // Delete the bet from the blockchain.\r\n        uint256 refundAmount = bet.amount;\r\n        delete activeBets[gambler];\r\n\r\n        // Refund the bet.\r\n        sendFunds(gambler, refundAmount, refundAmount);\r\n    }\r\n\r\n    /// Helper routines.\r\n\r\n    // Number of bet options for specific game.\r\n    function getRollModulo(GameId gameId) pure private returns (uint256) {\r\n        if (gameId == GameId.CoinFlip) {\r\n            // Heads/tails\r\n            return 2;\r\n\r\n        } else if (gameId == GameId.SingleDice) {\r\n            // One through six.\r\n            return 6;\r\n\r\n        } else if (gameId == GameId.DoubleDice) {\r\n            // 6*6=36 possible outcomes.\r\n            return 36;\r\n\r\n        }\r\n    }\r\n\r\n    // Max bet amount for a specific game.\r\n    function getMaxBet(GameId gameId) view private returns (uint256) {\r\n        if (gameId == GameId.CoinFlip) {\r\n            return maxBetCoinDice;\r\n\r\n        } else if (gameId == GameId.SingleDice) {\r\n            return maxBetCoinDice;\r\n\r\n        } else if (gameId == GameId.DoubleDice) {\r\n            return maxBetDoubleDice;\r\n\r\n        }\r\n    }\r\n\r\n    // Count 1 bits in the bet bit mask to find the total number of bet options\r\n    function getRollUnder(uint256 rollModulo, uint256 betMask) pure private returns (uint256) {\r\n        uint256 rollUnder = 0;\r\n        uint256 singleBitMask = 1;\r\n        for (uint256 shift = 0; shift < rollModulo; shift++) {\r\n            if (betMask & singleBitMask != 0) {\r\n                rollUnder++;\r\n            }\r\n\r\n            singleBitMask *= 2;\r\n        }\r\n\r\n        return rollUnder;\r\n    }\r\n\r\n    // Get the expected win amount after house edge is subtracted.\r\n    function getDiceWinAmount(uint256 amount, uint256 rollModulo, uint256 rollUnder) pure private\r\n      returns (uint256) {\r\n        require (0 < rollUnder && rollUnder <= rollModulo);\r\n        return amount * rollModulo / rollUnder * (100 - HOUSE_EDGE_PERCENT) / 100;\r\n    }\r\n\r\n    // Get the portion of bet amount that is to be accumulated in the jackpot.\r\n    function getJackpotFee(uint256 amount) pure private returns (uint256) {\r\n        return amount * HOUSE_EDGE_PERCENT / 100 * JACKPOT_FEE_PERCENT / 100;\r\n    }\r\n\r\n    // Helper routine to process the payment.\r\n    function sendFunds(address beneficiary, uint256 amount, uint256 successLogAmount) private {\r\n        if (beneficiary.send(amount)) {\r\n            emit Payment(beneficiary, successLogAmount);\r\n        } else {\r\n            emit FailedPayment(beneficiary, amount);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newMaxBetCoinDice\",\"type\":\"uint256\"}],\"name\":\"changeMaxBetCoinDice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBetCoinDice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gambler\",\"type\":\"address\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gambler\",\"type\":\"address\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBetDoubleDice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxBetDoubleDice\",\"type\":\"uint256\"}],\"name\":\"changeMaxBetDoubleDice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"increaseAmount\",\"type\":\"uint256\"}],\"name\":\"increaseJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint8\"},{\"name\":\"betMask\",\"type\":\"uint256\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotPayment\",\"type\":\"event\"}]","ContractName":"Dice2Win","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cccff48377d74b829d668e2b08a7da222dc10521a27ae2d2cbb0f5dfe98362c5"}]}