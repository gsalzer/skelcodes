{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Locker\r\n * @notice Locker holds tokens and releases them at a certain time.\r\n */\r\ncontract Locker is Ownable {\r\n  using SafeMath for uint;\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * It is init state only when adding release info is possible.\r\n   * beneficiary only can release tokens when Locker is active.\r\n   * After all tokens are released, locker is drawn.\r\n   */\r\n  enum State { Init, Ready, Active, Drawn }\r\n\r\n  struct Beneficiary {\r\n    uint ratio;             // ratio based on Locker's initial balance.\r\n    uint withdrawAmount;    // accumulated tokens beneficiary released\r\n    bool releaseAllTokens;\r\n  }\r\n\r\n  /**\r\n   * @notice Release has info to release tokens.\r\n   * If lock type is straight, only two release infos is required.\r\n   *\r\n   *     |\r\n   * 100 |                _______________\r\n   *     |              _/\r\n   *  50 |            _/\r\n   *     |         . |\r\n   *     |       .   |\r\n   *     |     .     |\r\n   *     +===+=======+----*----------> time\r\n   *     Locker  First    Last\r\n   *  Activated  Release  Release\r\n   *\r\n   *\r\n   * If lock type is variable, the release graph will be\r\n   *\r\n   *     |\r\n   * 100 |                                 _________\r\n   *     |                                |\r\n   *  70 |                      __________|\r\n   *     |                     |\r\n   *  30 |            _________|\r\n   *     |           |\r\n   *     +===+=======+---------+----------*------> time\r\n   *     Locker   First        Second     Last\r\n   *  Activated   Release      Release    Release\r\n   *\r\n   *\r\n   *\r\n   * For the first straight release graph, parameters would be\r\n   *   coeff: 100\r\n   *   releaseTimes: [\r\n   *     first release time,\r\n   *     second release time\r\n   *   ]\r\n   *   releaseRatios: [\r\n   *     50,\r\n   *     100,\r\n   *   ]\r\n   *\r\n   * For the second variable release graph, parameters would be\r\n   *   coeff: 100\r\n   *   releaseTimes: [\r\n   *     first release time,\r\n   *     second release time,\r\n   *     last release time\r\n   *   ]\r\n   *   releaseRatios: [\r\n   *     30,\r\n   *     70,\r\n   *     100,\r\n   *   ]\r\n   *\r\n   */\r\n  struct Release {\r\n    bool isStraight;        // lock type : straight or variable\r\n    uint[] releaseTimes;    //\r\n    uint[] releaseRatios;   //\r\n  }\r\n\r\n  uint public activeTime;\r\n\r\n  // ERC20 basic token contract being held\r\n  ERC20Basic public token;\r\n\r\n  uint public coeff;\r\n  uint public initialBalance;\r\n  uint public withdrawAmount; // total amount of tokens released\r\n\r\n  mapping (address => Beneficiary) public beneficiaries;\r\n  mapping (address => Release) public releases;  // beneficiary's lock\r\n  mapping (address => bool) public locked; // whether beneficiary's lock is instantiated\r\n\r\n  uint public numBeneficiaries;\r\n  uint public numLocks;\r\n\r\n  State public state;\r\n\r\n  modifier onlyState(State v) {\r\n    require(state == v);\r\n    _;\r\n  }\r\n\r\n  modifier onlyBeneficiary(address _addr) {\r\n    require(beneficiaries[_addr].ratio > 0);\r\n    _;\r\n  }\r\n\r\n  event StateChanged(State _state);\r\n  event Locked(address indexed _beneficiary, bool _isStraight);\r\n  event Released(address indexed _beneficiary, uint256 _amount);\r\n\r\n  function Locker(address _token, uint _coeff, address[] _beneficiaries, uint[] _ratios) public {\r\n    require(_token != address(0));\r\n    require(_beneficiaries.length == _ratios.length);\r\n\r\n    token = ERC20Basic(_token);\r\n    coeff = _coeff;\r\n    numBeneficiaries = _beneficiaries.length;\r\n\r\n    uint accRatio;\r\n\r\n    for(uint i = 0; i < numBeneficiaries; i++) {\r\n      require(_ratios[i] > 0);\r\n      beneficiaries[_beneficiaries[i]].ratio = _ratios[i];\r\n\r\n      accRatio = accRatio.add(_ratios[i]);\r\n    }\r\n\r\n    require(coeff == accRatio);\r\n  }\r\n\r\n  /**\r\n   * @notice beneficiary can release their tokens after activated\r\n   */\r\n  function activate() external onlyOwner onlyState(State.Ready) {\r\n    require(numLocks == numBeneficiaries); // double check : assert all releases are recorded\r\n\r\n    initialBalance = token.balanceOf(this);\r\n    require(initialBalance > 0);\r\n\r\n    activeTime = now; // solium-disable-line security/no-block-members\r\n\r\n    // set locker as active state\r\n    state = State.Active;\r\n    emit StateChanged(state);\r\n  }\r\n\r\n  function getReleaseType(address _beneficiary)\r\n    public\r\n    view\r\n    onlyBeneficiary(_beneficiary)\r\n    returns (bool)\r\n  {\r\n    return releases[_beneficiary].isStraight;\r\n  }\r\n\r\n  function getTotalLockedAmounts(address _beneficiary)\r\n    public\r\n    view\r\n    onlyBeneficiary(_beneficiary)\r\n    returns (uint)\r\n  {\r\n    return getPartialAmount(beneficiaries[_beneficiary].ratio, coeff, initialBalance);\r\n  }\r\n\r\n  function getReleaseTimes(address _beneficiary)\r\n    public\r\n    view\r\n    onlyBeneficiary(_beneficiary)\r\n    returns (uint[])\r\n  {\r\n    return releases[_beneficiary].releaseTimes;\r\n  }\r\n\r\n  function getReleaseRatios(address _beneficiary)\r\n    public\r\n    view\r\n    onlyBeneficiary(_beneficiary)\r\n    returns (uint[])\r\n  {\r\n    return releases[_beneficiary].releaseRatios;\r\n  }\r\n\r\n  /**\r\n   * @notice add new release record for beneficiary\r\n   */\r\n  function lock(address _beneficiary, bool _isStraight, uint[] _releaseTimes, uint[] _releaseRatios)\r\n    external\r\n    onlyOwner\r\n    onlyState(State.Init)\r\n    onlyBeneficiary(_beneficiary)\r\n  {\r\n    require(!locked[_beneficiary]);\r\n    require(_releaseRatios.length != 0);\r\n    require(_releaseRatios.length == _releaseTimes.length);\r\n\r\n    uint i;\r\n    uint len = _releaseRatios.length;\r\n\r\n    // finally should release all tokens\r\n    require(_releaseRatios[len - 1] == coeff);\r\n\r\n    // check two array are ascending sorted\r\n    for(i = 0; i < len - 1; i++) {\r\n      require(_releaseTimes[i] < _releaseTimes[i + 1]);\r\n      require(_releaseRatios[i] < _releaseRatios[i + 1]);\r\n    }\r\n\r\n    // 2 release times for straight locking type\r\n    if (_isStraight) {\r\n      require(len == 2);\r\n    }\r\n\r\n    numLocks = numLocks.add(1);\r\n\r\n    // create Release for the beneficiary\r\n    releases[_beneficiary].isStraight = _isStraight;\r\n\r\n    // copy array of uint\r\n    releases[_beneficiary].releaseTimes = _releaseTimes;\r\n    releases[_beneficiary].releaseRatios = _releaseRatios;\r\n\r\n    // lock beneficiary\r\n    locked[_beneficiary] = true;\r\n    emit Locked(_beneficiary, _isStraight);\r\n\r\n    //  if all beneficiaries locked, change Locker state to change\r\n    if (numLocks == numBeneficiaries) {\r\n      state = State.Ready;\r\n      emit StateChanged(state);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice transfer releasable tokens for beneficiary wrt the release graph\r\n   */\r\n  function release() external onlyState(State.Active) onlyBeneficiary(msg.sender) {\r\n    require(!beneficiaries[msg.sender].releaseAllTokens);\r\n\r\n    uint releasableAmount = getReleasableAmount(msg.sender);\r\n    beneficiaries[msg.sender].withdrawAmount = beneficiaries[msg.sender].withdrawAmount.add(releasableAmount);\r\n\r\n    beneficiaries[msg.sender].releaseAllTokens = beneficiaries[msg.sender].withdrawAmount == getPartialAmount(\r\n      beneficiaries[msg.sender].ratio,\r\n      coeff,\r\n      initialBalance);\r\n\r\n    withdrawAmount = withdrawAmount.add(releasableAmount);\r\n\r\n    if (withdrawAmount == initialBalance) {\r\n      state = State.Drawn;\r\n      emit StateChanged(state);\r\n    }\r\n\r\n    token.transfer(msg.sender, releasableAmount);\r\n    emit Released(msg.sender, releasableAmount);\r\n  }\r\n\r\n  function getReleasableAmount(address _beneficiary) internal view returns (uint) {\r\n    if (releases[_beneficiary].isStraight) {\r\n      return getStraightReleasableAmount(_beneficiary);\r\n    } else {\r\n      return getVariableReleasableAmount(_beneficiary);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice return releaseable amount for beneficiary in case of straight type of release\r\n   */\r\n  function getStraightReleasableAmount(address _beneficiary) internal view returns (uint releasableAmount) {\r\n    Beneficiary memory _b = beneficiaries[_beneficiary];\r\n    Release memory _r = releases[_beneficiary];\r\n\r\n    // total amount of tokens beneficiary can release\r\n    uint totalReleasableAmount = getTotalLockedAmounts(_beneficiary);\r\n\r\n    uint firstTime = _r.releaseTimes[0];\r\n    uint lastTime = _r.releaseTimes[1];\r\n\r\n    // solium-disable security/no-block-members\r\n    require(now >= firstTime); // pass if can release\r\n    // solium-enable security/no-block-members\r\n\r\n    if(now >= lastTime) { // inclusive to reduce calculation\r\n      releasableAmount = totalReleasableAmount;\r\n    } else {\r\n      // releasable amount at first time\r\n      uint firstAmount = getPartialAmount(\r\n        _r.releaseRatios[0],\r\n        coeff,\r\n        totalReleasableAmount);\r\n\r\n      // partial amount without first amount\r\n      releasableAmount = getPartialAmount(\r\n        now.sub(firstTime),\r\n        lastTime.sub(firstTime),\r\n        totalReleasableAmount.sub(firstAmount));\r\n      releasableAmount = releasableAmount.add(firstAmount);\r\n    }\r\n\r\n    // subtract already withdrawn amounts\r\n    releasableAmount = releasableAmount.sub(_b.withdrawAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice return releaseable amount for beneficiary in case of variable type of release\r\n   */\r\n  function getVariableReleasableAmount(address _beneficiary) internal view returns (uint releasableAmount) {\r\n    Beneficiary memory _b = beneficiaries[_beneficiary];\r\n    Release memory _r = releases[_beneficiary];\r\n\r\n    // total amount of tokens beneficiary will receive\r\n    uint totalReleasableAmount = getTotalLockedAmounts(_beneficiary);\r\n\r\n    uint releaseRatio;\r\n\r\n    // reverse order for short curcit\r\n    for(uint i = _r.releaseTimes.length - 1; i >= 0; i--) {\r\n      if (now >= _r.releaseTimes[i]) {\r\n        releaseRatio = _r.releaseRatios[i];\r\n        break;\r\n      }\r\n    }\r\n\r\n    require(releaseRatio > 0);\r\n\r\n    releasableAmount = getPartialAmount(\r\n      releaseRatio,\r\n      coeff,\r\n      totalReleasableAmount);\r\n    releasableAmount = releasableAmount.sub(_b.withdrawAmount);\r\n  }\r\n\r\n  /// https://github.com/0xProject/0x.js/blob/05aae368132a81ddb9fd6a04ac5b0ff1cbb24691/packages/contracts/src/current/protocol/Exchange/Exchange.sol#L497\r\n  /// @notice Calculates partial value given a numerator and denominator.\r\n  /// @param numerator Numerator.\r\n  /// @param denominator Denominator.\r\n  /// @param target Value to calculate partial of.\r\n  /// @return Partial value of target.\r\n  function getPartialAmount(uint numerator, uint denominator, uint target) public pure returns (uint) {\r\n    return numerator.mul(target).div(denominator);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"name\":\"ratio\",\"type\":\"uint256\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"name\":\"releaseAllTokens\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getReleaseRatios\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"releases\",\"outputs\":[{\"name\":\"isStraight\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_isStraight\",\"type\":\"bool\"},{\"name\":\"_releaseTimes\",\"type\":\"uint256[]\"},{\"name\":\"_releaseRatios\",\"type\":\"uint256[]\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coeff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"},{\"name\":\"target\",\"type\":\"uint256\"}],\"name\":\"getPartialAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBeneficiaries\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numLocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getReleaseTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getReleaseType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getTotalLockedAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_coeff\",\"type\":\"uint256\"},{\"name\":\"_beneficiaries\",\"type\":\"address[]\"},{\"name\":\"_ratios\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_isStraight\",\"type\":\"bool\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Locker","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000454b9f249bc1492ee995793bbc3e57b830f1a5e900000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000003221d1f77e05500c5dcaa3fc89ee4acee409fd0c000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003e8","Library":"","SwarmSource":"bzzr://54926738d4e606d8f634c7939f82c8354001ee206fc3631a293c1a4dc102e4b1"}]}