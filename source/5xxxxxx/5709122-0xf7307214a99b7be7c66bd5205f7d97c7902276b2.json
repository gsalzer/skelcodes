{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title BytesTools\r\n * @dev Useful tools for bytes type\r\n */\r\nlibrary BytesTools {\r\n\t\r\n\t/**\r\n\t * @dev Parses n of type bytes to uint256\r\n\t */\r\n\tfunction parseInt(bytes n) internal pure returns (uint256) {\r\n\t\t\r\n\t\tuint256 parsed = 0;\r\n\t\tbool decimals = false;\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < n.length; i++) {\r\n\t\t\tif ( n[i] >= 48 && n[i] <= 57) {\r\n\t\t\t\t\r\n\t\t\t\tif (decimals) break;\r\n\t\t\t\t\r\n\t\t\t\tparsed *= 10;\r\n\t\t\t\tparsed += uint256(n[i]) - 48;\r\n\t\t\t} else if (n[i] == 46) {\r\n\t\t\t\tdecimals = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn parsed;\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\t\r\n\t/**\r\n\t* @dev Multiplies two numbers, throws on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Integer division of two numbers, truncating the quotient.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a / b;\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Powers the first number to the second, throws on overflow.\r\n\t*/\r\n\tfunction pow(uint a, uint b) internal pure returns (uint) {\r\n\t\tif (b == 0) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tuint c = a ** b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Multiplies the given number by 10**decimals\r\n\t */\r\n\tfunction withDecimals(uint number, uint decimals) internal pure returns (uint) {\r\n\t\treturn mul(number, pow(10, decimals));\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n* @title Contract that will work with ERC223 tokens\r\n*/\r\ncontract ERC223Reciever {\r\n\t\r\n\t/**\r\n\t * @dev Standard ERC223 function that will handle incoming token transfers\r\n\t *\r\n\t * @param _from address  Token sender address\r\n\t * @param _value uint256 Amount of tokens\r\n\t * @param _data bytes  Transaction metadata\r\n\t */\r\n\tfunction tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);\r\n\t\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\t\r\n\taddress public owner;\r\n\taddress public potentialOwner;\r\n\t\r\n\t\r\n\tevent OwnershipRemoved(address indexed previousOwner);\r\n\tevent OwnershipTransfer(address indexed previousOwner, address indexed newOwner);\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyPotentialOwner() {\r\n\t\trequire(msg.sender == potentialOwner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address of potential new owner to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransfer(owner, newOwner);\r\n\t\tpotentialOwner = newOwner;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allow the potential owner confirm ownership of the contract.\r\n\t */\r\n\tfunction confirmOwnership() public onlyPotentialOwner {\r\n\t\temit OwnershipTransferred(owner, potentialOwner);\r\n\t\towner = potentialOwner;\r\n\t\tpotentialOwner = address(0);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Remove the contract owner permanently\r\n\t */\r\n\tfunction removeOwnership() public onlyOwner {\r\n\t\temit OwnershipRemoved(owner);\r\n\t\towner = address(0);\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title  UKT Token Voting contract\r\n * @author  Oleg Levshin <levshin@ucoz-team.net>\r\n */\r\ncontract UKTTokenVoting is ERC223Reciever, Ownable {\r\n\t\r\n\tusing SafeMath for uint256;\r\n\tusing BytesTools for bytes;\r\n\t\r\n\tstruct Vote {\r\n\t\tuint256 proposalIdx;\r\n\t\tuint256 tokensValue;\r\n\t\tuint256 weight;\r\n\t\taddress tokenContractAddress;\r\n\t\tuint256 blockNumber;\r\n\t}\r\n\t\r\n\tmapping(address => bool) public acceptedTokens;\r\n\tmapping(address => uint256) public acceptedTokensValues;\r\n\t\r\n\tbytes32[] public proposals;\r\n\tmapping (uint256 => uint256) public proposalsWeights;\r\n\t\r\n\tuint256 public dateStart;\r\n\tuint256 public dateEnd;\r\n\t\r\n\taddress[] public voters;\r\n\tmapping (address => Vote) public votes;\r\n\t\r\n\tbool public isFinalized = false;\r\n\tbool public isFinalizedValidly = false;\r\n\t\r\n\tevent NewVote(address indexed voter, uint256 proposalIdx, uint256 proposalWeight);\r\n\tevent TokensClaimed(address to);\r\n\tevent TokensRefunded(address to);\r\n\t\r\n\t\r\n\tfunction UKTTokenVoting(\r\n\t\tuint256 _dateEnd,\r\n\t\tbytes32[] _proposals,\r\n\t\taddress[] _acceptedTokens,\r\n\t\tuint256[] _acceptedTokensValues\r\n\t) public {\r\n\t\trequire(_dateEnd > now);\r\n\t\trequire(_proposals.length > 1);\r\n\t\trequire(_acceptedTokens.length > 0);\r\n\t\trequire(_acceptedTokensValues.length > 0);\r\n\t\trequire(_acceptedTokens.length == _acceptedTokensValues.length);\r\n\t\t\r\n\t\tdateStart = now;\r\n\t\tdateEnd = _dateEnd;\r\n\t\t\r\n\t\tproposals.push(\"Not valid proposal\");\r\n\t\tproposalsWeights[0] = 0;\r\n\t\tfor(uint256 i = 0; i < _proposals.length; i++) {\r\n\t\t\tproposals.push(_proposals[i]);\r\n\t\t\tproposalsWeights[i+1] = 0;\r\n\t\t}\r\n\t\t\r\n\t\tfor(uint256 j = 0; j < _acceptedTokens.length; j++) {\r\n\t\t\tacceptedTokens[_acceptedTokens[j]] = true;\r\n\t\t\tacceptedTokensValues[_acceptedTokens[j]] = _acceptedTokensValues[j];\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Executes automatically when user transfer his token to this contract address\r\n\t */\r\n\tfunction tokenFallback(\r\n\t\taddress _from,\r\n\t\tuint256 _value,\r\n\t\tbytes _data\r\n\t) external returns (bool) {\r\n\t\t// voting hasn't ended yet\r\n\t\trequire(now < dateEnd);\r\n\t\t\r\n\t\t// executed from contract in acceptedTokens\r\n\t\trequire(acceptedTokens[msg.sender] == true);\r\n\t\t\r\n\t\t// value of tokens is enough for voting\r\n\t\trequire(_value >= acceptedTokensValues[msg.sender]);\r\n\t\t\r\n\t\t// give proposal index is valid\r\n\t\tuint256 proposalIdx = _data.parseInt();\r\n\t\trequire(isValidProposal(proposalIdx));\r\n\t\t\r\n\t\t// user hasn't voted yet\r\n\t\trequire(isAddressNotVoted(_from));\r\n\t\t\r\n\t\tuint256 weight = _value.div(acceptedTokensValues[msg.sender]);\r\n\t\t\r\n\t\tvotes[_from] = Vote(proposalIdx, _value, weight, msg.sender, block.number);\r\n\t\tvoters.push(_from);\r\n\t\t\r\n\t\tproposalsWeights[proposalIdx] = proposalsWeights[proposalIdx].add(weight);\r\n\t\t\r\n\t\temit NewVote(_from, proposalIdx, proposalsWeights[proposalIdx]);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Gets winner tuple after voting is finished\r\n\t */\r\n\tfunction getWinner() external view returns (uint256 winnerIdx, bytes32 winner, uint256 winnerWeight) {\r\n\t\trequire(now >= dateEnd);\r\n\t\t\r\n\t\twinnerIdx = 0;\r\n\t\twinner = proposals[winnerIdx];\r\n\t\twinnerWeight = proposalsWeights[winnerIdx];\r\n\t\t\r\n\t\tfor(uint256 i = 1; i < proposals.length; i++) {\r\n\t\t\tif(proposalsWeights[i] >= winnerWeight) {\r\n\t\t\t\twinnerIdx = i;\r\n\t\t\t\twinner = proposals[winnerIdx];\r\n\t\t\t\twinnerWeight = proposalsWeights[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (winnerIdx > 0) {\r\n\t\t\tfor(uint256 j = 1; j < proposals.length; j++) {\r\n\t\t\t\tif(j != winnerIdx && proposalsWeights[j] == proposalsWeights[winnerIdx]) {\r\n\t\t\t\t\treturn (0, proposals[0], proposalsWeights[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn (winnerIdx, winner, winnerWeight);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Finalizes voting\r\n\t */\r\n\tfunction finalize(bool _isFinalizedValidly) external onlyOwner {\r\n\t\trequire(now >= dateEnd && ! isFinalized);\r\n\t\t\r\n\t\tisFinalized = true;\r\n\t\tisFinalizedValidly = _isFinalizedValidly;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allows voter to claim his tokens back to address\r\n\t */\r\n\tfunction claimTokens() public returns (bool) {\r\n\t\trequire(isAddressVoted(msg.sender));\r\n\t\t\r\n\t\trequire(transferTokens(msg.sender));\r\n\t\temit TokensClaimed(msg.sender);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Refunds tokens for all voters\r\n\t */\r\n\tfunction refundTokens(address to) public onlyOwner returns (bool) {\r\n\t\tif(to != address(0)) {\r\n\t\t\treturn _refundTokens(to);\r\n\t\t}\r\n\t\t\r\n\t\tfor(uint256 i = 0; i < voters.length; i++) {\r\n\t\t\t_refundTokens(voters[i]);\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Checks proposal index for validity\r\n\t */\r\n\tfunction isValidProposal(uint256 proposalIdx) private view returns (bool) {\r\n\t\treturn (\r\n\t\t\tproposalIdx > 0 &&\r\n\t\t\tproposals[proposalIdx].length > 0\r\n\t\t);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Return true if address not voted yet\r\n\t */\r\n\tfunction isAddressNotVoted(address _address) private view returns (bool) {\r\n\t\t// solium-disable-next-line operator-whitespace\r\n\t\treturn (\r\n\t\t\t// solium-disable-next-line operator-whitespace\r\n\t\t\tvotes[_address].proposalIdx == 0 &&\r\n\t\t\tvotes[_address].tokensValue == 0 &&\r\n\t\t\tvotes[_address].weight == 0 &&\r\n\t\t\tvotes[_address].tokenContractAddress == address(0) &&\r\n\t\t\tvotes[_address].blockNumber == 0\r\n\t\t);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Return true if address already voted\r\n\t */\r\n\tfunction isAddressVoted(address _address) private view returns (bool) {\r\n\t\treturn ! isAddressNotVoted(_address);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Trasnfer tokens to voter\r\n\t */\r\n\tfunction transferTokens(address to) private returns (bool) {\r\n\t\t\r\n\t\tVote memory vote = votes[to];\r\n\t\t\r\n\t\tif(vote.tokensValue == 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tvotes[to].tokensValue = 0;\r\n\t\t\r\n\t\tif ( ! isFinalized) {\r\n\t\t\tvotes[to] = Vote(0, 0, 0, address(0), 0);\r\n\t\t\tproposalsWeights[vote.proposalIdx] = proposalsWeights[vote.proposalIdx].sub(vote.weight);\r\n\t\t}\r\n\t\t\r\n\t\treturn vote.tokenContractAddress.call(bytes4(keccak256(\"transfer(address,uint256)\")), to, vote.tokensValue);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Refunds tokens to particular address\r\n\t */\r\n\tfunction _refundTokens(address to) private returns (bool) {\r\n\t\trequire(transferTokens(to));\r\n\t\temit TokensRefunded(to);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title  UKT Token Voting Factory contract\r\n * @author  Oleg Levshin <levshin@ucoz-team.net>\r\n */\r\ncontract UKTTokenVotingFactory is Ownable {\r\n\t\r\n\taddress[] public votings;\r\n\tmapping(address => int256) public votingsWinners;\r\n\t\r\n\tevent VotingCreated(address indexed votingAddress, uint256 dateEnd, bytes32[] proposals, address[] acceptedTokens, uint256[] acceptedTokensValues);\r\n\tevent WinnerSetted(address indexed votingAddress, uint256 winnerIdx, bytes32 winner, uint256 winnerWeight);\r\n\tevent VotingFinalized(address indexed votingAddress, bool isFinalizedValidly);\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Checks voting contract address for validity\r\n\t */\r\n\tfunction isValidVoting(address votingAddress) private view returns (bool) {\r\n\t\tfor (uint256 i = 0; i < votings.length; i++) {\r\n\t\t\tif (votings[i] == votingAddress) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Creates new instance of UKTTokenVoting contract with given params\r\n\t */\r\n\tfunction getNewVoting(\r\n\t\tuint256 dateEnd,\r\n\t\tbytes32[] proposals,\r\n\t\taddress[] acceptedTokens,\r\n\t\tuint256[] acceptedTokensValues\r\n\t) public onlyOwner returns (address votingAddress) {\r\n\t\t\r\n\t\tvotingAddress = address(new UKTTokenVoting(dateEnd, proposals, acceptedTokens, acceptedTokensValues));\r\n\t\t\r\n\t\temit VotingCreated(votingAddress, dateEnd, proposals, acceptedTokens, acceptedTokensValues);\r\n\t\t\r\n\t\tvotings.push(votingAddress);\r\n\t\tvotingsWinners[votingAddress] = -1;\r\n\t\t\r\n\t\treturn votingAddress;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Refunds tokens for all voters\r\n\t */\r\n\tfunction refundVotingTokens(address votingAddress, address to) public onlyOwner returns (bool) {\r\n\t\trequire(isValidVoting(votingAddress));\r\n\t\t\r\n\t\treturn UKTTokenVoting(votingAddress).refundTokens(to);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Sets calculated proposalIdx as voting winner\r\n\t */\r\n\tfunction setVotingWinner(address votingAddress) public onlyOwner {\r\n\t\trequire(votingsWinners[votingAddress] == -1);\r\n\t\t\r\n\t\tuint256 winnerIdx;\r\n\t\tbytes32 winner;\r\n\t\tuint256 winnerWeight;\r\n\t\t\r\n\t\t(winnerIdx, winner, winnerWeight) = UKTTokenVoting(votingAddress).getWinner();\r\n\t\t\r\n\t\tbool isFinalizedValidly = winnerIdx > 0;\r\n\t\t\r\n\t\tUKTTokenVoting(votingAddress).finalize(isFinalizedValidly);\r\n\t\t\r\n\t\temit VotingFinalized(votingAddress, isFinalizedValidly);\r\n\t\t\r\n\t\tvotingsWinners[votingAddress] = int256(winnerIdx);\r\n\t\t\r\n\t\temit WinnerSetted(votingAddress, winnerIdx, winner, winnerWeight);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Gets voting winner\r\n\t */\r\n\tfunction getVotingWinner(address votingAddress) public view returns (bytes32) {\r\n\t\trequire(votingsWinners[votingAddress] > -1);\r\n\t\t\r\n\t\treturn UKTTokenVoting(votingAddress).proposals(uint256(votingsWinners[votingAddress]));\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"votingAddress\",\"type\":\"address\"}],\"name\":\"setVotingWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"votingAddress\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"refundVotingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"name\":\"proposals\",\"type\":\"bytes32[]\"},{\"name\":\"acceptedTokens\",\"type\":\"address[]\"},{\"name\":\"acceptedTokensValues\",\"type\":\"uint256[]\"}],\"name\":\"getNewVoting\",\"outputs\":[{\"name\":\"votingAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potentialOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votingsWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votings\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"votingAddress\",\"type\":\"address\"}],\"name\":\"getVotingWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"votingAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proposals\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"acceptedTokens\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"acceptedTokensValues\",\"type\":\"uint256[]\"}],\"name\":\"VotingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"votingAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"winnerWeight\",\"type\":\"uint256\"}],\"name\":\"WinnerSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"votingAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isFinalizedValidly\",\"type\":\"bool\"}],\"name\":\"VotingFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UKTTokenVotingFactory","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0d239fffe334ed409c0ebf61edbd4c09be8e1c0870295135ce97cc0ebc56cb58"}]}