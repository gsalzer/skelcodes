{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Governable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    address public governor;\r\n    bool public paused = false;\r\n\r\n    constructor() public {\r\n        governor = msg.sender;\r\n    }\r\n\r\n    function setGovernor(address _gov) public onlyGovernor {\r\n        governor = _gov;\r\n    }\r\n\r\n    modifier onlyGovernor {\r\n        require(msg.sender == governor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyGovernor whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyGovernor whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    \r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract CardBase is Governable {\r\n\r\n\r\n    struct Card {\r\n        uint16 proto;\r\n        uint16 purity;\r\n    }\r\n\r\n    function getCard(uint id) public view returns (uint16 proto, uint16 purity) {\r\n        Card memory card = cards[id];\r\n        return (card.proto, card.purity);\r\n    }\r\n\r\n    function getShine(uint16 purity) public pure returns (uint8) {\r\n        return uint8(purity / 1000);\r\n    }\r\n\r\n    Card[] public cards;\r\n    \r\n}\r\n\r\ncontract CardProto is CardBase {\r\n\r\n    event NewProtoCard(\r\n        uint16 id, uint8 season, uint8 god, \r\n        Rarity rarity, uint8 mana, uint8 attack, \r\n        uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    );\r\n\r\n    struct Limit {\r\n        uint64 limit;\r\n        bool exists;\r\n    }\r\n\r\n    // limits for mythic cards\r\n    mapping(uint16 => Limit) public limits;\r\n\r\n    // can only set limits once\r\n    function setLimit(uint16 id, uint64 limit) public onlyGovernor {\r\n        Limit memory l = limits[id];\r\n        require(!l.exists);\r\n        limits[id] = Limit({\r\n            limit: limit,\r\n            exists: true\r\n        });\r\n    }\r\n\r\n    function getLimit(uint16 id) public view returns (uint64 limit, bool set) {\r\n        Limit memory l = limits[id];\r\n        return (l.limit, l.exists);\r\n    }\r\n\r\n    // could make these arrays to save gas\r\n    // not really necessary - will be update a very limited no of times\r\n    mapping(uint8 => bool) public seasonTradable;\r\n    mapping(uint8 => bool) public seasonTradabilityLocked;\r\n    uint8 public currentSeason;\r\n\r\n    function makeTradable(uint8 season) public onlyGovernor {\r\n        seasonTradable[season] = true;\r\n    }\r\n\r\n    function makeUntradable(uint8 season) public onlyGovernor {\r\n        require(!seasonTradabilityLocked[season]);\r\n        seasonTradable[season] = false;\r\n    }\r\n\r\n    function makePermanantlyTradable(uint8 season) public onlyGovernor {\r\n        require(seasonTradable[season]);\r\n        seasonTradabilityLocked[season] = true;\r\n    }\r\n\r\n    function isTradable(uint16 proto) public view returns (bool) {\r\n        return seasonTradable[protos[proto].season];\r\n    }\r\n\r\n    function nextSeason() public onlyGovernor {\r\n        //Seasons shouldn't go to 0 if there is more than the uint8 should hold, the governor should know this ¯\\_(ツ)_/¯ -M\r\n        require(currentSeason <= 255); \r\n\r\n        currentSeason++;\r\n        mythic.length = 0;\r\n        legendary.length = 0;\r\n        epic.length = 0;\r\n        rare.length = 0;\r\n        common.length = 0;\r\n    }\r\n\r\n    enum Rarity {\r\n        Common,\r\n        Rare,\r\n        Epic,\r\n        Legendary, \r\n        Mythic\r\n    }\r\n\r\n    uint8 constant SPELL = 1;\r\n    uint8 constant MINION = 2;\r\n    uint8 constant WEAPON = 3;\r\n    uint8 constant HERO = 4;\r\n\r\n    struct ProtoCard {\r\n        bool exists;\r\n        uint8 god;\r\n        uint8 season;\r\n        uint8 cardType;\r\n        Rarity rarity;\r\n        uint8 mana;\r\n        uint8 attack;\r\n        uint8 health;\r\n        uint8 tribe;\r\n    }\r\n\r\n    // there is a particular design decision driving this:\r\n    // need to be able to iterate over mythics only for card generation\r\n    // don't store 5 different arrays: have to use 2 ids\r\n    // better to bear this cost (2 bytes per proto card)\r\n    // rather than 1 byte per instance\r\n\r\n    uint16 public protoCount;\r\n    \r\n    mapping(uint16 => ProtoCard) protos;\r\n\r\n    uint16[] public mythic;\r\n    uint16[] public legendary;\r\n    uint16[] public epic;\r\n    uint16[] public rare;\r\n    uint16[] public common;\r\n\r\n    function addProtos(\r\n        uint16[] externalIDs, uint8[] gods, Rarity[] rarities, uint8[] manas, uint8[] attacks, \r\n        uint8[] healths, uint8[] cardTypes, uint8[] tribes, bool[] packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        for (uint i = 0; i < externalIDs.length; i++) {\r\n\r\n            ProtoCard memory card = ProtoCard({\r\n                exists: true,\r\n                god: gods[i],\r\n                season: currentSeason,\r\n                cardType: cardTypes[i],\r\n                rarity: rarities[i],\r\n                mana: manas[i],\r\n                attack: attacks[i],\r\n                health: healths[i],\r\n                tribe: tribes[i]\r\n            });\r\n\r\n            _addProto(externalIDs[i], card, packable[i]);\r\n        }\r\n        \r\n    }\r\n\r\n    function addProto(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: cardType,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addWeapon(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 durability, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: WEAPON,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: durability,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addSpell(uint16 externalID, uint8 god, Rarity rarity, uint8 mana, bool packable) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: SPELL,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: 0,\r\n            health: 0,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addMinion(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: MINION,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function _addProto(uint16 externalID, ProtoCard memory card, bool packable) internal {\r\n\r\n        require(!protos[externalID].exists);\r\n\r\n        card.exists = true;\r\n\r\n        protos[externalID] = card;\r\n\r\n        protoCount++;\r\n\r\n        emit NewProtoCard(\r\n            externalID, currentSeason, card.god, \r\n            card.rarity, card.mana, card.attack, \r\n            card.health, card.cardType, card.tribe, packable\r\n        );\r\n\r\n        if (packable) {\r\n            Rarity rarity = card.rarity;\r\n            if (rarity == Rarity.Common) {\r\n                common.push(externalID);\r\n            } else if (rarity == Rarity.Rare) {\r\n                rare.push(externalID);\r\n            } else if (rarity == Rarity.Epic) {\r\n                epic.push(externalID);\r\n            } else if (rarity == Rarity.Legendary) {\r\n                legendary.push(externalID);\r\n            } else if (rarity == Rarity.Mythic) {\r\n                mythic.push(externalID);\r\n            } else {\r\n                require(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getProto(uint16 id) public view returns(\r\n        bool exists, uint8 god, uint8 season, uint8 cardType, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) {\r\n        ProtoCard memory proto = protos[id];\r\n        return (\r\n            proto.exists,\r\n            proto.god,\r\n            proto.season,\r\n            proto.cardType,\r\n            proto.rarity,\r\n            proto.mana,\r\n            proto.attack,\r\n            proto.health,\r\n            proto.tribe\r\n        );\r\n    }\r\n\r\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16) {\r\n        // modulo bias is fine - creates rarity tiers etc\r\n        // will obviously revert is there are no cards of that type: this is expected - should never happen\r\n        if (rarity == Rarity.Common) {\r\n            return common[random % common.length];\r\n        } else if (rarity == Rarity.Rare) {\r\n            return rare[random % rare.length];\r\n        } else if (rarity == Rarity.Epic) {\r\n            return epic[random % epic.length];\r\n        } else if (rarity == Rarity.Legendary) {\r\n            return legendary[random % legendary.length];\r\n        } else if (rarity == Rarity.Mythic) {\r\n            // make sure a mythic is available\r\n            uint16 id;\r\n            uint64 limit;\r\n            bool set;\r\n            for (uint i = 0; i < mythic.length; i++) {\r\n                id = mythic[(random + i) % mythic.length];\r\n                (limit, set) = getLimit(id);\r\n                if (set && limit > 0){\r\n                    return id;\r\n                }\r\n            }\r\n            // if not, they get a legendary :(\r\n            return legendary[random % legendary.length];\r\n        }\r\n        require(false);\r\n        return 0;\r\n    }\r\n\r\n    // can never adjust tradable cards\r\n    // each season gets a 'balancing beta'\r\n    // totally immutable: season, rarity\r\n    function replaceProto(\r\n        uint16 index, uint8 god, uint8 cardType, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) public onlyGovernor {\r\n        ProtoCard memory pc = protos[index];\r\n        require(!seasonTradable[pc.season]);\r\n        protos[index] = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: pc.season,\r\n            cardType: cardType,\r\n            rarity: pc.rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n    }\r\n\r\n}\r\n\r\ncontract MigrationInterface {\r\n\r\n    function createCard(address user, uint16 proto, uint16 purity) public returns (uint);\r\n\r\n    function getRandomCard(CardProto.Rarity rarity, uint16 random) public view returns (uint16);\r\n\r\n    function migrate(uint id) public;\r\n\r\n}\r\n\r\ncontract FirstPheonix is Pausable {\r\n\r\n    MigrationInterface core;\r\n\r\n    constructor(MigrationInterface _core) public {\r\n        core = _core;\r\n    }\r\n\r\n    address[] public approved;\r\n\r\n    uint16 PHEONIX_PROTO = 380;\r\n\r\n    mapping(address => bool) public claimed;\r\n\r\n    function approvePack(address toApprove) public onlyOwner {\r\n        approved.push(toApprove);\r\n    }\r\n\r\n    function isApproved(address test) public view returns (bool) {\r\n        for (uint i = 0; i < approved.length; i++) {\r\n            if (approved[i] == test) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // pause once cards become tradable\r\n    function claimPheonix(address user) public returns (bool){\r\n\r\n        require(isApproved(msg.sender));\r\n\r\n        if (claimed[user] || paused){\r\n            return false;\r\n        }\r\n\r\n        claimed[user] = true;\r\n\r\n        core.createCard(user, PHEONIX_PROTO, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toApprove\",\"type\":\"address\"}],\"name\":\"approvePack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"test\",\"type\":\"address\"}],\"name\":\"isApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimPheonix\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_core\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"FirstPheonix","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006ebeaf8e8e946f0716e6533a6f2cefc83f60e8ab","Library":"","SwarmSource":"bzzr://1e0d74eb229a1d347e7b2dc466de659e40a2e8511ae308141fbc0c92ed6190ab"}]}