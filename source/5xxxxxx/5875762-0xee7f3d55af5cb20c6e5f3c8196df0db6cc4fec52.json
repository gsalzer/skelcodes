{"status":"1","message":"OK","result":[{"SourceCode":"///File: giveth-common-contracts/contracts/ERC20.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n * @title ERC20\r\n * @dev A standard interface for tokens.\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n  \r\n    /// @dev Returns the total token supply\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @dev Returns the account balance of the account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @dev Transfers _value number of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Transfers _value number of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\n///File: giveth-common-contracts/contracts/Owned.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/// @title Owned\r\n/// @author Adrià Massanet <adria@codecontext.io>\r\n/// @notice The Owned contract has an owner address, and provides basic \r\n///  authorization control functions, this simplifies & the implementation of\r\n///  user permissions; this contract has three work flows for a change in\r\n///  ownership, the first requires the new owner to validate that they have the\r\n///  ability to accept ownership, the second allows the ownership to be\r\n///  directly transfered without requiring acceptance, and the third allows for\r\n///  the ownership to be removed to allow for decentralization \r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed by, address indexed to);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event OwnershipRemoved();\r\n\r\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must\r\n    ///  be called first by the current `owner` then `acceptOwnership()` must be\r\n    ///  called by the `newOwnerCandidate`\r\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\r\n    ///  new owner\r\n    /// @param _newOwnerCandidate The address being proposed as the new owner\r\n    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\r\n    ///  transfer of ownership\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwnerCandidate);\r\n\r\n        address oldOwner = owner;\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the `newOwner`\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner\r\n    function changeOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != 0x0);\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the 0x0 address;\r\n    ///  it requires a 0xdece be input as a parameter to prevent accidental use\r\n    /// @notice Decentralizes the contract, this operation cannot be undone \r\n    /// @param _dac `0xdac` has to be entered for this function to work\r\n    function removeOwnership(address _dac) public onlyOwner {\r\n        require(_dac == 0xdac);\r\n        owner = 0x0;\r\n        newOwnerCandidate = 0x0;\r\n        OwnershipRemoved();     \r\n    }\r\n} \r\n\r\n\r\n///File: giveth-common-contracts/contracts/Escapable.sol\r\n\r\npragma solidity ^0.4.19;\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    Contributor: Adrià Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/// @dev `Escapable` is a base level contract built off of the `Owned`\r\n///  contract; it creates an escape hatch function that can be called in an\r\n///  emergency that will allow designated addresses to send any ether or tokens\r\n///  held in the contract to an `escapeHatchDestination` as long as they were\r\n///  not blacklisted\r\ncontract Escapable is Owned {\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\r\n    ///  `escapeHatchCaller`\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract\r\n    ///  to call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract; if a neutral address\r\n    ///  is required, the WHG Multisig is an option:\r\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \r\n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\r\n    ///  are the only addresses that can call a function with this modifier\r\n    modifier onlyEscapeHatchCallerOrOwner {\r\n        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\r\n        _;\r\n    }\r\n\r\n    /// @notice Creates the blacklist of tokens that are not able to be taken\r\n    ///  out of the contract; can only be done at the deployment, and the logic\r\n    ///  to add to the blacklist will be in the constructor of a child contract\r\n    /// @param _token the token contract address that is to be blacklisted \r\n    function blacklistEscapeToken(address _token) internal {\r\n        escapeBlacklist[_token] = true;\r\n        EscapeHatchBlackistedToken(_token);\r\n    }\r\n\r\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\r\n    /// @param _token the token address being queried\r\n    /// @return False if `_token` is in the blacklist and can't be taken out of\r\n    ///  the contract via the `escapeHatch()`\r\n    function isTokenEscapable(address _token) view public returns (bool) {\r\n        return !escapeBlacklist[_token];\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    /// @param _token to transfer, use 0x0 for ether\r\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \r\n        require(escapeBlacklist[_token]==false);\r\n\r\n        uint256 balance;\r\n\r\n        /// @dev Logic for ether\r\n        if (_token == 0x0) {\r\n            balance = this.balance;\r\n            escapeHatchDestination.transfer(balance);\r\n            EscapeHatchCalled(_token, balance);\r\n            return;\r\n        }\r\n        /// @dev Logic for tokens\r\n        ERC20 token = ERC20(_token);\r\n        balance = token.balanceOf(this);\r\n        require(token.transfer(escapeHatchDestination, balance));\r\n        EscapeHatchCalled(_token, balance);\r\n    }\r\n\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or\r\n    ///  contract to call `escapeHatch()` to send the value in this contract to\r\n    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n    }\r\n\r\n    event EscapeHatchBlackistedToken(address token);\r\n    event EscapeHatchCalled(address token, uint amount);\r\n}\r\n\r\n\r\n///File: ./contracts/lib/Pausable.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Owned {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n///File: ./contracts/lib/Vault.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n/*\r\n    Copyright 2018, Jordi Baylina, RJ Ewing\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n/// @title Vault Contract\r\n/// @author Jordi Baylina, RJ Ewing\r\n/// @notice This contract holds funds for Campaigns and automates payments. For\r\n///  this iteration the funds will come straight from the Giveth Multisig as a\r\n///  safety precaution, but once fully tested and optimized this contract will\r\n///  be a safe place to store funds equipped with optional variable time delays\r\n///  to allow for an optional escape hatch\r\n\r\n\r\n\r\n\r\n/// @dev `Vault` is a higher level contract built off of the `Escapable`\r\n///  contract that holds funds for Campaigns and automates payments.\r\ncontract Vault is Escapable, Pausable {\r\n\r\n    /// @dev `Payment` is a public structure that describes the details of\r\n    ///  each payment making it easy to track the movement of funds\r\n    ///  transparently\r\n    struct Payment {\r\n        string name;              // What is the purpose of this payment\r\n        bytes32 reference;        // Reference of the payment.\r\n        address spender;          // Who is sending the funds\r\n        uint earliestPayTime;     // The earliest a payment can be made (Unix Time)\r\n        bool canceled;            // If True then the payment has been canceled\r\n        bool paid;                // If True then the payment has been paid\r\n        address recipient;        // Who is receiving the funds\r\n        address token;            // Token this payment represents\r\n        uint amount;              // The amount of wei sent in the payment\r\n        uint securityGuardDelay;  // The seconds `securityGuard` can delay payment\r\n    }\r\n\r\n    Payment[] public authorizedPayments;\r\n\r\n    address public securityGuard;\r\n    uint public absoluteMinTimeLock;\r\n    uint public timeLock;\r\n    uint public maxSecurityGuardDelay;\r\n    bool public allowDisbursePaymentWhenPaused;\r\n\r\n    /// @dev The white list of approved addresses allowed to set up && receive\r\n    ///  payments from this vault\r\n    mapping (address => bool) public allowedSpenders;\r\n\r\n    // @dev Events to make the payment movements easy to find on the blockchain\r\n    event PaymentAuthorized(uint indexed idPayment, address indexed recipient, uint amount, address token, bytes32 reference);\r\n    event PaymentExecuted(uint indexed idPayment, address indexed recipient, uint amount, address token);\r\n    event PaymentCanceled(uint indexed idPayment);\r\n    event SpenderAuthorization(address indexed spender, bool authorized);\r\n\r\n    /// @dev The address assigned the role of `securityGuard` is the only\r\n    ///  addresses that can call a function with this modifier\r\n    modifier onlySecurityGuard { \r\n        require(msg.sender == securityGuard);\r\n        _;\r\n    }\r\n\r\n    /// By default, we dis-allow payment disburements if the contract is paused.\r\n    /// However, to facilitate a migration of the bridge, we can allow\r\n    /// disbursements when paused if explicitly set\r\n    modifier disbursementsAllowed {\r\n        require(!paused || allowDisbursePaymentWhenPaused);\r\n        _;\r\n    }\r\n\r\n    /// @notice The Constructor creates the Vault on the blockchain\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\r\n    ///  call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal if `escapeHatchCaller` cannot move\r\n    ///  funds out of `escapeHatchDestination`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract in an emergency\r\n    /// @param _absoluteMinTimeLock The minimum number of seconds `timelock` can\r\n    ///  be set to, if set to 0 the `owner` can remove the `timeLock` completely\r\n    /// @param _timeLock Initial number of seconds that payments are delayed\r\n    ///  after they are authorized (a security precaution)\r\n    /// @param _securityGuard Address that will be able to delay the payments\r\n    ///  beyond the initial timelock requirements; can be set to 0x0 to remove\r\n    ///  the `securityGuard` functionality\r\n    /// @param _maxSecurityGuardDelay The maximum number of seconds in total\r\n    ///   that `securityGuard` can delay a payment so that the owner can cancel\r\n    ///   the payment if needed\r\n    function Vault(\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination,\r\n        uint _absoluteMinTimeLock,\r\n        uint _timeLock,\r\n        address _securityGuard,\r\n        uint _maxSecurityGuardDelay\r\n    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public\r\n    {\r\n        absoluteMinTimeLock = _absoluteMinTimeLock;\r\n        timeLock = _timeLock;\r\n        securityGuard = _securityGuard;\r\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\r\n    }\r\n\r\n/////////\r\n// Helper functions\r\n/////////\r\n\r\n    /// @notice States the total number of authorized payments in this contract\r\n    /// @return The number of payments ever authorized even if they were canceled\r\n    function numberOfAuthorizedPayments() public view returns (uint) {\r\n        return authorizedPayments.length;\r\n    }\r\n\r\n////////\r\n// Spender Interface\r\n////////\r\n\r\n    /// @notice only `allowedSpenders[]` Creates a new `Payment`\r\n    /// @param _name Brief description of the payment that is authorized\r\n    /// @param _reference External reference of the payment\r\n    /// @param _recipient Destination of the payment\r\n    /// @param _amount Amount to be paid in wei\r\n    /// @param _paymentDelay Number of seconds the payment is to be delayed, if\r\n    ///  this value is below `timeLock` then the `timeLock` determines the delay\r\n    /// @return The Payment ID number for the new authorized payment\r\n    function authorizePayment(\r\n        string _name,\r\n        bytes32 _reference,\r\n        address _recipient,\r\n        address _token,\r\n        uint _amount,\r\n        uint _paymentDelay\r\n    ) whenNotPaused external returns(uint) {\r\n\r\n        // Fail if you arent on the `allowedSpenders` white list\r\n        require(allowedSpenders[msg.sender]);\r\n        uint idPayment = authorizedPayments.length;       // Unique Payment ID\r\n        authorizedPayments.length++;\r\n\r\n        // The following lines fill out the payment struct\r\n        Payment storage p = authorizedPayments[idPayment];\r\n        p.spender = msg.sender;\r\n\r\n        // Overflow protection\r\n        require(_paymentDelay <= 10**18);\r\n\r\n        // Determines the earliest the recipient can receive payment (Unix time)\r\n        p.earliestPayTime = _paymentDelay >= timeLock ?\r\n                                _getTime() + _paymentDelay :\r\n                                _getTime() + timeLock;\r\n        p.recipient = _recipient;\r\n        p.amount = _amount;\r\n        p.name = _name;\r\n        p.reference = _reference;\r\n        p.token = _token;\r\n        emit PaymentAuthorized(idPayment, p.recipient, p.amount, p.token, p.reference);\r\n        return idPayment;\r\n    }\r\n\r\n    /// Anyone can call this function to disburse the payment to \r\n    ///  the recipient after `earliestPayTime` has passed\r\n    /// @param _idPayment The payment ID to be executed\r\n    function disburseAuthorizedPayment(uint _idPayment) disbursementsAllowed public {\r\n        // Check that the `_idPayment` has been added to the payments struct\r\n        require(_idPayment < authorizedPayments.length);\r\n\r\n        Payment storage p = authorizedPayments[_idPayment];\r\n\r\n        // Checking for reasons not to execute the payment\r\n        require(allowedSpenders[p.spender]);\r\n        require(_getTime() >= p.earliestPayTime);\r\n        require(!p.canceled);\r\n        require(!p.paid);\r\n\r\n        p.paid = true; // Set the payment to being paid\r\n\r\n        // Make the payment\r\n        if (p.token == 0) {\r\n            p.recipient.transfer(p.amount);\r\n        } else {\r\n            require(ERC20(p.token).transfer(p.recipient, p.amount));\r\n        }\r\n\r\n        emit PaymentExecuted(_idPayment, p.recipient, p.amount, p.token);\r\n    }\r\n\r\n    /// convience function to disburse multiple payments in a single tx\r\n    function disburseAuthorizedPayments(uint[] _idPayments) public {\r\n        for (uint i = 0; i < _idPayments.length; i++) {\r\n            uint _idPayment = _idPayments[i];\r\n            disburseAuthorizedPayment(_idPayment);\r\n        }\r\n    }\r\n\r\n/////////\r\n// SecurityGuard Interface\r\n/////////\r\n\r\n    /// @notice `onlySecurityGuard` Delays a payment for a set number of seconds\r\n    /// @param _idPayment ID of the payment to be delayed\r\n    /// @param _delay The number of seconds to delay the payment\r\n    function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard external {\r\n        require(_idPayment < authorizedPayments.length);\r\n\r\n        // Overflow test\r\n        require(_delay <= 10**18);\r\n\r\n        Payment storage p = authorizedPayments[_idPayment];\r\n\r\n        require(p.securityGuardDelay + _delay <= maxSecurityGuardDelay);\r\n        require(!p.paid);\r\n        require(!p.canceled);\r\n\r\n        p.securityGuardDelay += _delay;\r\n        p.earliestPayTime += _delay;\r\n    }\r\n\r\n////////\r\n// Owner Interface\r\n///////\r\n\r\n    /// @notice `onlyOwner` Cancel a payment all together\r\n    /// @param _idPayment ID of the payment to be canceled.\r\n    function cancelPayment(uint _idPayment) onlyOwner external {\r\n        require(_idPayment < authorizedPayments.length);\r\n\r\n        Payment storage p = authorizedPayments[_idPayment];\r\n\r\n        require(!p.canceled);\r\n        require(!p.paid);\r\n\r\n        p.canceled = true;\r\n        emit PaymentCanceled(_idPayment);\r\n    }\r\n\r\n    /// @notice `onlyOwner` Adds a spender to the `allowedSpenders[]` white list\r\n    /// @param _spender The address of the contract being authorized/unauthorized\r\n    /// @param _authorize `true` if authorizing and `false` if unauthorizing\r\n    function authorizeSpender(address _spender, bool _authorize) onlyOwner external {\r\n        allowedSpenders[_spender] = _authorize;\r\n        emit SpenderAuthorization(_spender, _authorize);\r\n    }\r\n\r\n    /// @notice `onlyOwner` Sets the address of `securityGuard`\r\n    /// @param _newSecurityGuard Address of the new security guard\r\n    function setSecurityGuard(address _newSecurityGuard) onlyOwner external {\r\n        securityGuard = _newSecurityGuard;\r\n    }\r\n\r\n    /// @notice `onlyOwner` Changes `timeLock`; the new `timeLock` cannot be\r\n    ///  lower than `absoluteMinTimeLock`\r\n    /// @param _newTimeLock Sets the new minimum default `timeLock` in seconds;\r\n    ///  pending payments maintain their `earliestPayTime`\r\n    function setTimelock(uint _newTimeLock) onlyOwner external {\r\n        require(_newTimeLock >= absoluteMinTimeLock);\r\n        timeLock = _newTimeLock;\r\n    }\r\n\r\n    /// @notice `onlyOwner` Changes the maximum number of seconds\r\n    /// `securityGuard` can delay a payment\r\n    /// @param _maxSecurityGuardDelay The new maximum delay in seconds that\r\n    ///  `securityGuard` can delay the payment's execution in total\r\n    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) onlyOwner external {\r\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\r\n    }\r\n\r\n    /// @dev called by the owner to pause the contract. Triggers a stopped state \r\n    ///  and resets allowDisbursePaymentWhenPaused to false\r\n    function pause() onlyOwner whenNotPaused public {\r\n        allowDisbursePaymentWhenPaused = false;\r\n        super.pause();\r\n    }\r\n\r\n    /// Owner can allow payment disbursement when the contract is paused. This is so the\r\n    /// bridge can be upgraded without having to migrate any existing authorizedPayments\r\n    /// @dev only callable whenPaused b/c pausing the contract will reset `allowDisbursePaymentWhenPaused` to false\r\n    /// @param allowed `true` if allowing payments to be disbursed when paused, otherwise 'false'\r\n    function setAllowDisbursePaymentWhenPaused(bool allowed) onlyOwner whenPaused public {\r\n        allowDisbursePaymentWhenPaused = allowed;\r\n    }\r\n\r\n    // for overidding during testing\r\n    function _getTime() internal view returns (uint) {\r\n        return now;\r\n    }\r\n\r\n}\r\n\r\n///File: ./contracts/lib/FailClosedVault.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n/*\r\n    Copyright 2018, RJ Ewing\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n\r\n/**\r\n* @dev `FailClosedVault` is a version of the vault that requires\r\n*  the securityGuard to \"see\" each payment before it can be collected\r\n*/\r\ncontract FailClosedVault is Vault {\r\n    uint public securityGuardLastCheckin;\r\n\r\n    /**\r\n    * @param _absoluteMinTimeLock For this version of the vault, it is recommended\r\n    *   that this value is > 24hrs. If not, it will require the securityGuard to checkIn\r\n    *   multiple times a day. Also consider that `securityGuardLastCheckin >= payment.earliestPayTime - timelock + 30mins);`\r\n    *   is the condition to allow payments to be payed. The additional 30 mins is to reduce (not eliminate)\r\n    *   the risk of front-running\r\n    */\r\n    function FailClosedVault(\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination,\r\n        uint _absoluteMinTimeLock,\r\n        uint _timeLock,\r\n        address _securityGuard,\r\n        uint _maxSecurityGuardDelay\r\n    ) Vault(\r\n        _escapeHatchCaller,\r\n        _escapeHatchDestination, \r\n        _absoluteMinTimeLock,\r\n        _timeLock,\r\n        _securityGuard,\r\n        _maxSecurityGuardDelay\r\n    ) public {\r\n    }\r\n\r\n/////////////////////\r\n// Spender Interface\r\n/////////////////////\r\n\r\n    /**\r\n    * Disburse an authorizedPayment to the recipient if all checks pass.\r\n    *\r\n    * @param _idPayment The payment ID to be disbursed\r\n    */\r\n    function disburseAuthorizedPayment(uint _idPayment) disbursementsAllowed public {\r\n        // Check that the `_idPayment` has been added to the payments struct\r\n        require(_idPayment < authorizedPayments.length);\r\n\r\n        Payment storage p = authorizedPayments[_idPayment];\r\n        // The current minimum delay for a payment is `timeLock`. Thus the following ensuress\r\n        // that the `securityGuard` has checked in after the payment was created\r\n        // @notice earliestPayTime is updated when a payment is delayed. Which may require\r\n        // another checkIn before the payment can be collected.\r\n        // @notice We add 30 mins to this to reduce (not eliminate) the risk of front-running\r\n        require(securityGuardLastCheckin >= p.earliestPayTime - timeLock + 30 minutes);\r\n\r\n        super.disburseAuthorizedPayment(_idPayment);\r\n    }\r\n\r\n///////////////////////////\r\n// SecurityGuard Interface\r\n///////////////////////////\r\n\r\n    /**\r\n    * @notice `onlySecurityGuard` can checkin. If they fail to checkin,\r\n    * payments will not be allowed to be disbursed, unless the payment has\r\n    * an `earliestPayTime` <= `securityGuardLastCheckin`.\r\n    * @notice To reduce the risk of a front-running attack on payments, it\r\n    * is important that this is called with a resonable gasPrice set for the\r\n    * current network congestion. If this tx is not mined, within 30 mins\r\n    * of being sent, it is possible that a payment can be authorized w/o the\r\n    * securityGuard's knowledge\r\n    */\r\n    function checkIn() onlySecurityGuard external {\r\n        securityGuardLastCheckin = _getTime();\r\n    }\r\n}\r\n\r\n///File: ./contracts/GivethBridge.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n/*\r\n    Copyright 2017, RJ Ewing <perissology@protonmail.com>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @notice It is not recommened to call this function outside of the giveth dapp (giveth.io)\r\n* this function is bridged to a side chain. If for some reason the sidechain tx fails, the donation\r\n* will end up in the givers control inside LiquidPledging contract. If you do not use the dapp, there\r\n* will be no way of notifying the sender/giver that the giver has to take action (withdraw/donate) in\r\n* the dapp\r\n*/\r\ncontract GivethBridge is FailClosedVault {\r\n\r\n    mapping(address => bool) tokenWhitelist;\r\n\r\n    event Donate(uint64 giverId, uint64 receiverId, address token, uint amount);\r\n    event DonateAndCreateGiver(address giver, uint64 receiverId, address token, uint amount);\r\n    event EscapeFundsCalled(address token, uint amount);\r\n\r\n    //== constructor\r\n\r\n    /**\r\n    * @param _escapeHatchCaller The address of a trusted account or contract to\r\n    *  call `escapeHatch()` to send the ether in this contract to the\r\n    *  `escapeHatchDestination` in the case on an emergency. it would be ideal \r\n    *  if `escapeHatchCaller` cannot move funds out of `escapeHatchDestination`\r\n    * @param _escapeHatchDestination The address of a safe location (usually a\r\n    *  Multisig) to send the ether held in this contract in the case of an emergency\r\n    * @param _absoluteMinTimeLock The minimum number of seconds `timelock` can\r\n    *  be set to, if set to 0 the `owner` can remove the `timeLock` completely\r\n    * @param _timeLock Minimum number of seconds that payments are delayed\r\n    *  after they are authorized (a security precaution)\r\n    * @param _securityGuard Address that will be able to delay the payments\r\n    *  beyond the initial timelock requirements; can be set to 0x0 to remove\r\n    *  the `securityGuard` functionality\r\n    * @param _maxSecurityGuardDelay The maximum number of seconds in total\r\n    *   that `securityGuard` can delay a payment so that the owner can cancel\r\n    *   the payment if needed\r\n    */\r\n    function GivethBridge(\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination,\r\n        uint _absoluteMinTimeLock,\r\n        uint _timeLock,\r\n        address _securityGuard,\r\n        uint _maxSecurityGuardDelay\r\n    ) FailClosedVault(\r\n        _escapeHatchCaller,\r\n        _escapeHatchDestination,\r\n        _absoluteMinTimeLock,\r\n        _timeLock,\r\n        _securityGuard,\r\n        _maxSecurityGuardDelay\r\n    ) public\r\n    {\r\n        tokenWhitelist[0] = true; // enable eth transfers\r\n    }\r\n\r\n    //== public methods\r\n\r\n    /**\r\n    * @notice It is not recommened to call this function outside of the giveth dapp (giveth.io)\r\n    * this function is bridged to a side chain. If for some reason the sidechain tx fails, the donation\r\n    * will end up in the givers control inside LiquidPledging contract. If you do not use the dapp, there\r\n    * will be no way of notifying the sender/giver that the giver has to take action (withdraw/donate) in\r\n    * the dapp\r\n    *\r\n    * @param giver The address to create a 'giver' pledge admin for in the liquidPledging contract\r\n    * @param receiverId The adminId of the liquidPledging pledge admin receiving the donation\r\n    */\r\n    function donateAndCreateGiver(address giver, uint64 receiverId) payable external {\r\n        donateAndCreateGiver(giver, receiverId, 0, 0);\r\n    }\r\n\r\n    /**\r\n    * @notice It is not recommened to call this function outside of the giveth dapp (giveth.io)\r\n    * this function is bridged to a side chain. If for some reason the sidechain tx fails, the donation\r\n    * will end up in the givers control inside LiquidPledging contract. If you do not use the dapp, there\r\n    * will be no way of notifying the sender/giver that the giver has to take action (withdraw/donate) in\r\n    * the dapp\r\n    *\r\n    * @param giver The address to create a 'giver' pledge admin for in the liquidPledging contract\r\n    * @param receiverId The adminId of the liquidPledging pledge admin receiving the donation\r\n    * @param token The token to donate. If donating ETH, then 0x0. Note: the token must be whitelisted\r\n    * @param _amount The amount of the token to donate. If donating ETH, then 0x0 as the msg.value will be used instead.\r\n    */\r\n    function donateAndCreateGiver(address giver, uint64 receiverId, address token, uint _amount) whenNotPaused payable public {\r\n        require(giver != 0);\r\n        require(receiverId != 0);\r\n        uint amount = _receiveDonation(token, _amount);\r\n        emit DonateAndCreateGiver(giver, receiverId, token, amount);\r\n    }\r\n\r\n    /**\r\n    * @notice It is not recommened to call this function outside of the giveth dapp (giveth.io)\r\n    * this function is bridged to a side chain. If for some reason the sidechain tx fails, the donation\r\n    * will end up in the givers control inside LiquidPledging contract. If you do not use the dapp, there\r\n    * will be no way of notifying the sender/giver that the giver has to take action (withdraw/donate) in\r\n    * the dapp\r\n    *\r\n    * @param giverId The adminId of the liquidPledging pledge admin who is donating\r\n    * @param receiverId The adminId of the liquidPledging pledge admin receiving the donation\r\n    */\r\n    function donate(uint64 giverId, uint64 receiverId) payable external {\r\n        donate(giverId, receiverId, 0, 0);\r\n    }\r\n\r\n    /**\r\n    * @notice It is not recommened to call this function outside of the giveth dapp (giveth.io)\r\n    * this function is bridged to a side chain. If for some reason the sidechain tx fails, the donation\r\n    * will end up in the givers control inside LiquidPledging contract. If you do not use the dapp, there\r\n    * will be no way of notifying the sender/giver that the giver has to take action (withdraw/donate) in\r\n    * the dapp\r\n    *\r\n    * @param giverId The adminId of the liquidPledging pledge admin who is donating\r\n    * @param receiverId The adminId of the liquidPledging pledge admin receiving the donation\r\n    * @param token The token to donate. If donating ETH, then 0x0. Note: the token must be whitelisted\r\n    * @param _amount The amount of the token to donate. If donating ETH, then 0x0 as the msg.value will be used instead.\r\n    */\r\n    function donate(uint64 giverId, uint64 receiverId, address token, uint _amount) whenNotPaused payable public {\r\n        require(giverId != 0);\r\n        require(receiverId != 0);\r\n        uint amount = _receiveDonation(token, _amount);\r\n        emit Donate(giverId, receiverId, token, amount);\r\n    }\r\n\r\n    /**\r\n    * The `owner` can call this function to add/remove a token from the whitelist\r\n    *\r\n    * @param token The address of the token to update\r\n    * @param accepted Wether or not to accept this token for donations\r\n    */\r\n    function whitelistToken(address token, bool accepted) whenNotPaused onlyOwner external {\r\n        tokenWhitelist[token] = accepted;\r\n    }\r\n\r\n    /**\r\n    * Transfer tokens/eth to the escapeHatchDestination.\r\n    * Used as a safety mechanism to prevent the bridge from holding too much value\r\n    *\r\n    * before being thoroughly battle-tested.\r\n    * @param _token the token to transfer. 0x0 for ETH\r\n    * @param _amount the amount to transfer\r\n    */\r\n    function escapeFunds(address _token, uint _amount) external onlyEscapeHatchCallerOrOwner {\r\n        // @dev Logic for ether\r\n        if (_token == 0) {\r\n            escapeHatchDestination.transfer(_amount);\r\n        // @dev Logic for tokens\r\n        } else {\r\n            ERC20 token = ERC20(_token);\r\n            require(token.transfer(escapeHatchDestination, _amount));\r\n        }\r\n        emit EscapeFundsCalled(_token, _amount);\r\n    }\r\n\r\n    //== internal methods\r\n\r\n    /**\r\n    * @dev used to actually receive the donation. Will transfer the token to to this contract\r\n    */\r\n    function _receiveDonation(address token, uint _amount) internal returns(uint amount) {\r\n        require(tokenWhitelist[token]);\r\n        amount = _amount;\r\n\r\n        // eth donation\r\n        if (token == 0) {\r\n            amount = msg.value;\r\n        }\r\n\r\n        require(amount > 0);\r\n\r\n        if (token != 0) {\r\n            require(ERC20(token).transferFrom(msg.sender, this, amount));\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maxSecurityGuardDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"accepted\",\"type\":\"bool\"}],\"name\":\"whitelistToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"giver\",\"type\":\"address\"},{\"name\":\"receiverId\",\"type\":\"uint64\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"donateAndCreateGiver\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"escapeFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTimeLock\",\"type\":\"uint256\"}],\"name\":\"setTimelock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityGuardLastCheckin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"giverId\",\"type\":\"uint64\"},{\"name\":\"receiverId\",\"type\":\"uint64\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayment\",\"type\":\"uint256\"}],\"name\":\"disburseAuthorizedPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dac\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setAllowDisbursePaymentWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfAuthorizedPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_authorize\",\"type\":\"bool\"}],\"name\":\"authorizeSpender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayment\",\"type\":\"uint256\"}],\"name\":\"cancelPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayment\",\"type\":\"uint256\"},{\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"delayPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowDisbursePaymentWhenPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idPayments\",\"type\":\"uint256[]\"}],\"name\":\"disburseAuthorizedPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenEscapable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"giver\",\"type\":\"address\"},{\"name\":\"receiverId\",\"type\":\"uint64\"}],\"name\":\"donateAndCreateGiver\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorizedPayments\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"reference\",\"type\":\"bytes32\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"earliestPayTime\",\"type\":\"uint256\"},{\"name\":\"canceled\",\"type\":\"bool\"},{\"name\":\"paid\",\"type\":\"bool\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"securityGuardDelay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityGuard\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSecurityGuard\",\"type\":\"address\"}],\"name\":\"setSecurityGuard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"giverId\",\"type\":\"uint64\"},{\"name\":\"receiverId\",\"type\":\"uint64\"}],\"name\":\"donate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeHatchEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedSpenders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxSecurityGuardDelay\",\"type\":\"uint256\"}],\"name\":\"setMaxSecurityGuardDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"absoluteMinTimeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_reference\",\"type\":\"bytes32\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_paymentDelay\",\"type\":\"uint256\"}],\"name\":\"authorizePayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"},{\"name\":\"_absoluteMinTimeLock\",\"type\":\"uint256\"},{\"name\":\"_timeLock\",\"type\":\"uint256\"},{\"name\":\"_securityGuard\",\"type\":\"address\"},{\"name\":\"_maxSecurityGuardDelay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"giverId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"receiverId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Donate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"giver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"receiverId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonateAndCreateGiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeFundsCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reference\",\"type\":\"bytes32\"}],\"name\":\"PaymentAuthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"PaymentExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idPayment\",\"type\":\"uint256\"}],\"name\":\"PaymentCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"SpenderAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EscapeHatchBlackistedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRemoved\",\"type\":\"event\"}]","ContractName":"GivethBridge","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001e9f6746147e937e8e1c29180e15af0bd5fd64bb00000000000000000000000016fda2fcc887dd7ac65c46be144473067cff86540000000000000000000000000000000000000000000000000000000000015f90000000000000000000000000000000000000000000000000000000000002a300000000000000000000000000daa172456f5815256831aee19c8a370a835228710000000000000000000000000000000000000000000000000000000000278d00","Library":"","SwarmSource":"bzzr://3ba22886c60036ed35be37f7fbfa475c2c50042ebe76cb8123648f41a18b4bf9"}]}