{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n// File: contracts/interfaces/IAuctions.sol\r\n\r\ncontract IAuctions {\r\n\r\n    function currentPrice(uint _tokenId) public constant returns (uint256);\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration) public;\r\n    function createReleaseAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _startedAt,\r\n        uint _duration) public;\r\n    function cancelAuction(uint256 _tokenId) external;\r\n    function cancelAuctionWhenPaused(uint256 _tokenId) external;\r\n    function bid(uint256 _tokenId, address _owner) external payable;\r\n    function market() public constant returns (\r\n        uint[] tokens,\r\n        address[] sellers,\r\n        uint8[] generations,\r\n        uint8[] speeds,\r\n        uint[] prices\r\n    );\r\n    function auctionsOf(address _of) public constant returns (\r\n        uint[] tokens,\r\n        uint[] prices\r\n    );\r\n    function signature() external constant returns (uint _signature);\r\n}\r\n\r\n// File: contracts/interfaces/IStorage.sol\r\n\r\ncontract IStorage {\r\n    function isOwner(address _address) public constant returns (bool);\r\n\r\n    function isAllowed(address _address) external constant returns (bool);\r\n    function developer() public constant returns (address);\r\n    function setDeveloper(address _address) public;\r\n    function addAdmin(address _address) public;\r\n    function isAdmin(address _address) public constant returns (bool);\r\n    function removeAdmin(address _address) public;\r\n    function contracts(uint _signature) public returns (address _address);\r\n\r\n    function exists(uint _tokenId) external constant returns (bool);\r\n    function paintingsCount() public constant returns (uint);\r\n    function increaseOwnershipTokenCount(address _address) public;\r\n    function decreaseOwnershipTokenCount(address _address) public;\r\n    function setOwnership(uint _tokenId, address _address) public;\r\n    function getPainting(uint _tokenId)\r\n        external constant returns (address, uint, uint, uint, uint8, uint8);\r\n    function createPainting(\r\n        address _owner,\r\n        uint _tokenId,\r\n        uint _parentId,\r\n        uint8 _generation,\r\n        uint8 _speed,\r\n        uint _artistId,\r\n        uint _releasedAt) public;\r\n    function approve(uint _tokenId, address _claimant) external;\r\n    function isApprovedFor(uint _tokenId, address _claimant)\r\n        external constant returns (bool);\r\n    function createEditionMeta(uint _tokenId) public;\r\n    function getPaintingOwner(uint _tokenId)\r\n        external constant returns (address);\r\n    function getPaintingGeneration(uint _tokenId)\r\n        public constant returns (uint8);\r\n    function getPaintingSpeed(uint _tokenId)\r\n        external constant returns (uint8);\r\n    function getPaintingArtistId(uint _tokenId)\r\n        public constant returns (uint artistId);\r\n    function getOwnershipTokenCount(address _address)\r\n        external constant returns (uint);\r\n    function isReady(uint _tokenId) public constant returns (bool);\r\n    function getPaintingIdAtIndex(uint _index) public constant returns (uint);\r\n    function lastEditionOf(uint _index) public constant returns (uint);\r\n    function getPaintingOriginal(uint _tokenId)\r\n        external constant returns (uint);\r\n    function canBeBidden(uint _tokenId) public constant returns (bool _can);\r\n\r\n    function addAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _duration,\r\n        address _seller) public;\r\n    function addReleaseAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _startedAt,\r\n        uint _duration) public;\r\n    function initAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _startedAt,\r\n        uint _duration,\r\n        address _seller,\r\n        bool _byTeam) public;\r\n    function _isOnAuction(uint _tokenId) internal constant returns (bool);\r\n    function isOnAuction(uint _tokenId) external constant returns (bool);\r\n    function removeAuction(uint _tokenId) public;\r\n    function getAuction(uint256 _tokenId)\r\n        external constant returns (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt);\r\n    function getAuctionSeller(uint256 _tokenId)\r\n        public constant returns (address);\r\n    function getAuctionEnd(uint _tokenId)\r\n        public constant returns (uint);\r\n    function canBeCanceled(uint _tokenId) external constant returns (bool);\r\n    function getAuctionsCount() public constant returns (uint);\r\n    function getTokensOnAuction() public constant returns (uint[]);\r\n    function getTokenIdAtIndex(uint _index) public constant returns (uint);\r\n    function getAuctionStartedAt(uint256 _tokenId) public constant returns (uint);\r\n\r\n    function getOffsetIndex() public constant returns (uint);\r\n    function nextOffsetIndex() public returns (uint);\r\n    function canCreateEdition(uint _tokenId, uint8 _generation)\r\n        public constant returns (bool);\r\n    function isValidGeneration(uint8 _generation)\r\n        public constant returns (bool);\r\n    function increaseGenerationCount(uint _tokenId, uint8 _generation) public;\r\n    function getEditionsCount(uint _tokenId) external constant returns (uint8[3]);\r\n    function setLastEditionOf(uint _tokenId, uint _editionId) public;\r\n    function setEditionLimits(uint _tokenId, uint8 _gen1, uint8 _gen2, uint8 _gen3) public;\r\n    function getEditionLimits(uint _tokenId) external constant returns (uint8[3]);\r\n\r\n    function hasEditionInProgress(uint _tokenId) external constant returns (bool);\r\n    function hasEmptyEditionSlots(uint _tokenId) external constant returns (bool);\r\n\r\n    function setPaintingName(uint _tokenId, string _name) public;\r\n    function setPaintingArtist(uint _tokenId, string _name) public;\r\n    function purgeInformation(uint _tokenId) public;\r\n    function resetEditionLimits(uint _tokenId) public;\r\n    function resetPainting(uint _tokenId) public;\r\n    function decreaseSpeed(uint _tokenId) public;\r\n    function isCanceled(uint _tokenId) public constant returns (bool _is);\r\n    function totalPaintingsCount() public constant returns (uint _total);\r\n    function isSecondary(uint _tokenId) public constant returns (bool _is);\r\n    function secondarySaleCut() public constant returns (uint8 _cut);\r\n    function sealForChanges(uint _tokenId) public;\r\n    function canBeChanged(uint _tokenId) public constant returns (bool _can);\r\n\r\n    function getPaintingName(uint _tokenId) public constant returns (string);\r\n    function getPaintingArtist(uint _tokenId) public constant returns (string);\r\n\r\n    function signature() external constant returns (bytes4);\r\n}\r\n\r\n// File: contracts/libs/Ownable.sol\r\n\r\n/**\r\n* @title Ownable\r\n* @dev Manages ownership of the contracts\r\n*/\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function isOwner(address _address) public constant returns (bool) {\r\n        return _address == owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/libs/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @dev modifier to allow actions only when the contract IS paused\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to allow actions only when the contract IS NOT paused\r\n    */\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function _pause() internal whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function _unpause() internal whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n// File: contracts/libs/BitpaintingBase.sol\r\n\r\ncontract BitpaintingBase is Pausable {\r\n    /*** EVENTS ***/\r\n    event Create(uint _tokenId,\r\n        address _owner,\r\n        uint _parentId,\r\n        uint8 _generation,\r\n        uint _createdAt,\r\n        uint _completedAt);\r\n\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    IStorage public bitpaintingStorage;\r\n\r\n    modifier canPauseUnpause() {\r\n        require(msg.sender == owner || msg.sender == bitpaintingStorage.developer());\r\n        _;\r\n    }\r\n\r\n    function setBitpaintingStorage(address _address) public onlyOwner {\r\n        require(_address != address(0));\r\n        bitpaintingStorage = IStorage(_address);\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public canPauseUnpause whenNotPaused {\r\n        super._pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external canPauseUnpause whenPaused {\r\n        super._unpause();\r\n    }\r\n\r\n    function canUserReleaseArtwork(address _address)\r\n        public constant returns (bool _can) {\r\n        return (bitpaintingStorage.isOwner(_address)\r\n            || bitpaintingStorage.isAdmin(_address)\r\n            || bitpaintingStorage.isAllowed(_address));\r\n    }\r\n\r\n    function canUserCancelArtwork(address _address)\r\n        public constant returns (bool _can) {\r\n        return (bitpaintingStorage.isOwner(_address)\r\n            || bitpaintingStorage.isAdmin(_address));\r\n    }\r\n\r\n    modifier canReleaseArtwork() {\r\n        require(canUserReleaseArtwork(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier canCancelArtwork() {\r\n        require(canUserCancelArtwork(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns ownership of a specific Painting to an address.\r\n    function _transfer(address _from, address _to, uint256 _tokenId)\r\n        internal {\r\n        bitpaintingStorage.setOwnership(_tokenId, _to);\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _createOriginalPainting(uint _tokenId, uint _artistId, uint _releasedAt) internal {\r\n        address _owner = owner;\r\n        uint _parentId = 0;\r\n        uint8 _generation = 0;\r\n        uint8 _speed = 10;\r\n        _createPainting(_owner, _tokenId, _parentId, _generation, _speed, _artistId, _releasedAt);\r\n    }\r\n\r\n    function _createPainting(\r\n        address _owner,\r\n        uint _tokenId,\r\n        uint _parentId,\r\n        uint8 _generation,\r\n        uint8 _speed,\r\n        uint _artistId,\r\n        uint _releasedAt\r\n    )\r\n        internal\r\n    {\r\n        require(_tokenId == uint256(uint32(_tokenId)));\r\n        require(_parentId == uint256(uint32(_parentId)));\r\n        require(_generation == uint256(uint8(_generation)));\r\n\r\n        bitpaintingStorage.createPainting(\r\n            _owner, _tokenId, _parentId, _generation, _speed, _artistId, _releasedAt);\r\n\r\n        uint _createdAt;\r\n        uint _completedAt;\r\n        (,,_createdAt, _completedAt,,) = bitpaintingStorage.getPainting(_tokenId);\r\n\r\n        // emit the create event\r\n        Create(\r\n            _tokenId,\r\n            _owner,\r\n            _parentId,\r\n            _generation,\r\n            _createdAt,\r\n            _completedAt\r\n        );\r\n\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(0, _owner, _tokenId);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/libs/ERC721.sol\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public constant returns (uint256 total);\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external constant returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external constant returns (bool);\r\n}\r\n\r\n// File: contracts/libs/ERC721Metadata.sol\r\n\r\n/// @title The external contract that is responsible for generating metadata for the kitties,\r\n///  it has one function that will return the data as bytes.\r\ncontract ERC721Metadata {\r\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\r\n    function getMetadata(uint256 _tokenId, string) public constant returns (bytes32[4] buffer, uint256 count) {\r\n        if (_tokenId == 1) {\r\n            buffer[0] = \"Hello World! :D\";\r\n            count = 15;\r\n        } else if (_tokenId == 2) {\r\n            buffer[0] = \"I would definitely choose a medi\";\r\n            buffer[1] = \"um length string.\";\r\n            count = 49;\r\n        } else if (_tokenId == 3) {\r\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\r\n            buffer[2] = \" tristique vestibulum id, libero\";\r\n            buffer[3] = \" suscipit varius sapien aliquam.\";\r\n            count = 128;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libs/PaintingOwnership.sol\r\n\r\ncontract PaintingOwnership is BitpaintingBase, ERC721 {\r\n\r\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant name = \"BitPaintings\";\r\n    string public constant symbol = \"BP\";\r\n\r\n    ERC721Metadata public erc721Metadata;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('transfer(address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('tokensOfOwner(address)')) ^\r\n        bytes4(keccak256('tokenMetadata(uint256,string)'));\r\n\r\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\r\n    ///  ERC-165 (obviously!) and ERC-721.\r\n    function supportsInterface(bytes4 _interfaceID) external constant returns (bool)\r\n    {\r\n        // DEBUG ONLY\r\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\r\n\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    /// @dev Set the address of the sibling contract that tracks metadata.\r\n    ///  CEO only.\r\n    function setMetadataAddress(address _contractAddress) public onlyOwner {\r\n        erc721Metadata = ERC721Metadata(_contractAddress);\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal constant returns (bool) {\r\n        return bitpaintingStorage.getPaintingOwner(_tokenId) == _claimant;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 count) {\r\n        return bitpaintingStorage.getOwnershipTokenCount(_owner);\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        bitpaintingStorage.approve(_tokenId, _approved);\r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _tokenId)\r\n        internal constant returns (bool) {\r\n        return bitpaintingStorage.isApprovedFor(_tokenId, _claimant);\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function approve(\r\n      address _to,\r\n      uint256 _tokenId\r\n    )\r\n      external\r\n      whenNotPaused\r\n    {\r\n      require(_owns(msg.sender, _tokenId));\r\n      _approve(_tokenId, _to);\r\n\r\n      Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(\r\n      address _from,\r\n      address _to,\r\n      uint256 _tokenId\r\n    )\r\n        external whenNotPaused {\r\n        _transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _transferFrom(\r\n      address _from,\r\n      address _to,\r\n      uint256 _tokenId\r\n    )\r\n        internal\r\n        whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint) {\r\n      return bitpaintingStorage.paintingsCount();\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external constant returns (address) {\r\n        return _ownerOf(_tokenId);\r\n    }\r\n\r\n    function _ownerOf(uint256 _tokenId)\r\n        internal constant returns (address) {\r\n        return bitpaintingStorage.getPaintingOwner(_tokenId);\r\n    }\r\n\r\n    function tokensOfOwner(address _owner)\r\n        external constant returns(uint256[]) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n          return new uint256[](0);\r\n        }\r\n\r\n        uint256[] memory result = new uint256[](tokenCount);\r\n        uint256 totalCats = totalSupply();\r\n        uint256 resultIndex = 0;\r\n\r\n        uint256 paintingId;\r\n\r\n        for (paintingId = 1; paintingId <= totalCats; paintingId++) {\r\n            if (bitpaintingStorage.getPaintingOwner(paintingId) == _owner) {\r\n                result[resultIndex] = paintingId;\r\n                resultIndex++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _memcpy(uint _dest, uint _src, uint _len) private constant {\r\n      // Copy word-length chunks while possible\r\n      for(; _len >= 32; _len -= 32) {\r\n          assembly {\r\n              mstore(_dest, mload(_src))\r\n          }\r\n          _dest += 32;\r\n          _src += 32;\r\n      }\r\n\r\n      // Copy remaining bytes\r\n      uint256 mask = 256 ** (32 - _len) - 1;\r\n      assembly {\r\n          let srcpart := and(mload(_src), not(mask))\r\n          let destpart := and(mload(_dest), mask)\r\n          mstore(_dest, or(destpart, srcpart))\r\n      }\r\n    }\r\n\r\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private constant returns (string) {\r\n      var outputString = new string(_stringLength);\r\n      uint256 outputPtr;\r\n      uint256 bytesPtr;\r\n\r\n      assembly {\r\n          outputPtr := add(outputString, 32)\r\n          bytesPtr := _rawBytes\r\n      }\r\n\r\n      _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n      return outputString;\r\n    }\r\n\r\n    /// @notice Returns a URI pointing to a metadata package for this token conforming to\r\n    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\r\n    /// @param _tokenId The ID number of the Kitty whose metadata should be returned.\r\n    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external constant returns (string infoUrl) {\r\n      require(erc721Metadata != address(0));\r\n      bytes32[4] memory buffer;\r\n      uint256 count;\r\n      (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\r\n\r\n      return _toString(buffer, count);\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        owner.transfer(this.balance);\r\n    }\r\n}\r\n\r\n// File: contracts/BitpaintingAuctions.sol\r\n\r\ncontract BitpaintingAuctions is PaintingOwnership, IAuctions {\r\n\r\n    event AuctionCreated(\r\n        uint tokenId,\r\n        address seller,\r\n        uint startingPrice,\r\n        uint endingPrice,\r\n        uint duration);\r\n    event AuctionCancelled(uint tokenId, address seller);\r\n    event AuctionSuccessful(uint tokenId, uint totalPrice, address winner);\r\n\r\n    function currentPrice(uint _tokenId)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        require(bitpaintingStorage.isOnAuction(_tokenId));\r\n        uint secondsPassed = 0;\r\n        address seller;\r\n        uint startingPrice;\r\n        uint endingPrice;\r\n        uint duration;\r\n        uint startedAt;\r\n        (seller, startingPrice, endingPrice, duration, startedAt)\r\n            = bitpaintingStorage.getAuction(_tokenId);\r\n\r\n        // move that as class/contract member\r\n        uint weis_in_gwei = 1000000000;\r\n        if (now < startedAt) {\r\n            return (startingPrice / weis_in_gwei);\r\n        }\r\n\r\n        if (now > startedAt) {\r\n            secondsPassed = now - startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            startingPrice,\r\n            endingPrice,\r\n            duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    /// returns the price in gwei instead of wei\r\n    function _computeCurrentPrice(\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _duration,\r\n        uint _secondsPassed\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint)\r\n    {\r\n        uint weis_in_gwei = 1000000000;\r\n        if (_secondsPassed >= _duration) {\r\n            return _endingPrice / weis_in_gwei;\r\n        }\r\n\r\n        int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n        int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n        int256 _currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n        return uint(_currentPrice) / weis_in_gwei;\r\n    }\r\n\r\n    function _bid(uint _tokenId, uint _amount) private {\r\n        require(bitpaintingStorage.isOnAuction(_tokenId));\r\n        require(bitpaintingStorage.canBeBidden(_tokenId));\r\n\r\n        uint weis_in_gwei = 1000000000;\r\n        address seller = bitpaintingStorage.getAuctionSeller(_tokenId);\r\n        uint price = currentPrice(_tokenId) * weis_in_gwei;\r\n        require(_amount >= price);\r\n\r\n        if (bitpaintingStorage.isSecondary(_tokenId)) {\r\n            uint8 cut = bitpaintingStorage.secondarySaleCut();\r\n            uint forSeller = ((100 - cut) * _amount) / 100;\r\n            seller.transfer(forSeller);\r\n        }\r\n        bitpaintingStorage.removeAuction(_tokenId);\r\n        bitpaintingStorage.increaseOwnershipTokenCount(msg.sender);\r\n        bitpaintingStorage.decreaseOwnershipTokenCount(seller);\r\n        bitpaintingStorage.sealForChanges(_tokenId);\r\n\r\n        AuctionSuccessful(_tokenId, price, msg.sender);\r\n    }\r\n\r\n    function _escrow(address _owner, uint _tokenId) internal {\r\n        _transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(uint _tokenId) internal {\r\n        bitpaintingStorage.removeAuction(_tokenId);\r\n        AuctionCancelled(_tokenId, msg.sender);\r\n    }\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of time to move between starting\r\n    ///  price and ending price (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function _createAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _duration,\r\n        address _seller\r\n    )\r\n        public\r\n        whenNotPaused\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint(uint128(_startingPrice)));\r\n        require(_endingPrice == uint(uint128(_endingPrice)));\r\n        require(_duration == uint(uint64(_duration)));\r\n\r\n        bitpaintingStorage.addAuction(_tokenId, _startingPrice, _endingPrice, _duration, _seller);\r\n\r\n        AuctionCreated(\r\n            uint(_tokenId),\r\n            _seller,\r\n            uint(_startingPrice),\r\n            uint(_endingPrice),\r\n            uint(_duration)\r\n        );\r\n    }\r\n\r\n    function _createReleaseAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _startedAt,\r\n        uint _duration\r\n    ) internal {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint(uint128(_startingPrice)));\r\n        require(_endingPrice == uint(uint128(_endingPrice)));\r\n        require(_duration == uint(uint64(_duration)));\r\n\r\n        bitpaintingStorage.addReleaseAuction(\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _startedAt,\r\n            _duration);\r\n    }\r\n\r\n    /// @dev Put a painting up for auction.\r\n    ///  Does some ownership trickery to create auctions in one tx.\r\n    function createReleaseAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _startedAt,\r\n        uint _duration\r\n    ) public whenNotPaused canReleaseArtwork {\r\n        require(_startingPrice > _endingPrice);\r\n        _createReleaseAuction(\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _startedAt,\r\n            _duration\r\n        );\r\n    }\r\n\r\n    /// @dev Put a painting up for auction.\r\n    ///  Does some ownership trickery to create auctions in one tx.\r\n    function createAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _duration\r\n    )\r\n        public\r\n        whenNotPaused\r\n    {\r\n        require(bitpaintingStorage.getPaintingOwner(_tokenId) == msg.sender);\r\n        require(!bitpaintingStorage.hasEditionInProgress(_tokenId));\r\n        require(bitpaintingStorage.isReady(_tokenId));\r\n        require(!bitpaintingStorage.isOnAuction(_tokenId));\r\n        require(_startingPrice > _endingPrice);\r\n\r\n        _approve(_tokenId, msg.sender);\r\n        _createAuction(\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function cancelAuction(uint _tokenId) external whenNotPaused {\r\n        require(bitpaintingStorage.isOnAuction(_tokenId));\r\n        address seller = bitpaintingStorage.getAuctionSeller(_tokenId);\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenId);\r\n    }\r\n\r\n    function cancelAuctionWhenPaused(uint _tokenId)\r\n        external whenPaused onlyOwner {\r\n        require(bitpaintingStorage.isOnAuction(_tokenId));\r\n        address seller = bitpaintingStorage.getAuctionSeller(_tokenId);\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenId);\r\n    }\r\n\r\n    function bid(uint _tokenId, address _owner) external payable whenNotPaused {\r\n        address seller = bitpaintingStorage.getAuctionSeller(_tokenId);\r\n        require(seller == _owner);\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(seller, msg.sender, _tokenId);\r\n    }\r\n\r\n    function market() public constant returns (\r\n        uint[] tokens,\r\n        address[] sellers,\r\n        uint8[] generations,\r\n        uint8[] speeds,\r\n        uint[] prices\r\n        ) {\r\n        uint length = bitpaintingStorage.totalPaintingsCount();\r\n        uint count = bitpaintingStorage.getAuctionsCount();\r\n        tokens = new uint[](count);\r\n        generations = new uint8[](count);\r\n        sellers = new address[](count);\r\n        speeds = new uint8[](count);\r\n        prices = new uint[](count);\r\n        uint pointer = 0;\r\n\r\n        for(uint index = 0; index < length; index++) {\r\n            uint tokenId = bitpaintingStorage.getPaintingIdAtIndex(index);\r\n\r\n            if (bitpaintingStorage.isCanceled(tokenId)) {\r\n                continue;\r\n            }\r\n\r\n            if (!bitpaintingStorage.isOnAuction(tokenId)) {\r\n                continue;\r\n            }\r\n\r\n            tokens[pointer] = tokenId;\r\n            generations[pointer] = bitpaintingStorage.getPaintingGeneration(tokenId);\r\n            sellers[pointer] = _ownerOf(tokenId);\r\n            speeds[pointer] = bitpaintingStorage.getPaintingSpeed(tokenId);\r\n            prices[pointer] = currentPrice(tokenId);\r\n            pointer++;\r\n        }\r\n    }\r\n\r\n    function auctionsOf(address _of) public constant returns (\r\n            uint[] tokens,\r\n            uint[] prices\r\n        ) {\r\n\r\n        uint tokenCount = totalSupply();\r\n        uint length = balanceOf(_of);\r\n        uint pointer;\r\n\r\n        tokens = new uint[](length);\r\n        prices = new uint[](length);\r\n\r\n        for(uint index = 0; index < tokenCount; index++) {\r\n            uint tokenId = bitpaintingStorage.getPaintingIdAtIndex(index);\r\n\r\n            if (_ownerOf(tokenId) != _of) {\r\n                continue;\r\n            }\r\n\r\n            if (!bitpaintingStorage.isReady(tokenId)) {\r\n                continue;\r\n            }\r\n\r\n            if (!bitpaintingStorage.isOnAuction(tokenId)) {\r\n                continue;\r\n            }\r\n\r\n            tokens[pointer] = tokenId;\r\n            prices[pointer] = currentPrice(tokenId);\r\n            pointer++;\r\n        }\r\n    }\r\n\r\n    function signature() external constant returns (uint _signature) {\r\n        return uint(keccak256(\"auctions\"));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bitpaintingStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"canUserCancelArtwork\",\"outputs\":[{\"name\":\"_can\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setBitpaintingStorage\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signature\",\"outputs\":[{\"name\":\"_signature\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"_createAuction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"name\":\"sellers\",\"type\":\"address[]\"},{\"name\":\"generations\",\"type\":\"uint8[]\"},{\"name\":\"speeds\",\"type\":\"uint8[]\"},{\"name\":\"prices\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"canUserReleaseArtwork\",\"outputs\":[{\"name\":\"_can\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"auctionsOf\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"name\":\"prices\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_startedAt\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createReleaseAuction\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_parentId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_generation\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_createdAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_completedAt\",\"type\":\"uint256\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"BitpaintingAuctions","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://824a11c55ad5b1bf19e88544dbb48543ff2dd8cecf8e395235e9ebe0073caa00"}]}