{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// If you are reading this...\r\n// This is a \"backup\" - deploying to the same address on mainnet and testnet\r\n// Just in case someone accidentally sends Ether into ether\r\n// Here is the Ropsten (testnet, monopoly money) address: https://ropsten.etherscan.io/address/0x6c1c2fd38fccc0b010f75b2ece535cf57543ddcd#code\r\n// Learning stuff, heavily investing in skills and education\r\n// If you can - hire me - https://genesis.re\r\n// One disclaimer though - cannot handle bullshit jobs - only true leaders, only meaningful projects please :)\r\n\r\n// File: contracts/Auction.sol\r\n\r\ncontract Auction {\r\n  \r\n  string public description;\r\n  string public instructions; // will be used for delivery address or email\r\n  uint public price;\r\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\r\n  uint public timestampEnd;\r\n  address public beneficiary;\r\n  bool public finalized = false;\r\n\r\n  address public owner;\r\n  address public winner;\r\n  mapping(address => uint) public bids;\r\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\r\n  function getAccountListLenght() public constant returns(uint) { return accountsList.length; } // lenght is not accessible from DApp, exposing convenience method: https://stackoverflow.com/questions/43016011/getting-the-length-of-public-array-variable-getter\r\n\r\n  // THINK: should be (an optional) constructor parameter?\r\n  // For now if you want to change - simply modify the code\r\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\r\n  uint public increaseTimeBy = 24 * 60 * 60;\r\n  \r\n\r\n  event BidEvent(address indexed bidder, uint value, uint timestamp); // cannot have event and struct with the same name\r\n  event Refund(address indexed bidder, uint value, uint timestamp);\r\n\r\n  \r\n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\r\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\r\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\r\n\r\n\r\n  function setDescription(string _description) public onlyOwner() {\r\n    description = _description;\r\n  }\r\n\r\n  // TODO: Override this method in the derived functions, think about on-chain / off-chain communication mechanism\r\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\r\n    instructions = _instructions;\r\n  }\r\n\r\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\r\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\r\n    owner = msg.sender;\r\n    price = _price;\r\n    description = _description;\r\n    timestampEnd = _timestampEnd;\r\n    beneficiary = _beneficiary;\r\n  }\r\n\r\n  // Same for all the derived contract, it's the implementation of refund() and bid() that differs\r\n  function() public payable {\r\n    if (msg.value == 0) {\r\n      refund();\r\n    } else {\r\n      bid();\r\n    }  \r\n  }\r\n\r\n  function bid() public payable {\r\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\r\n\r\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\r\n      bids[msg.sender] += msg.value;\r\n    } else {\r\n      bids[msg.sender] = msg.value;\r\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \r\n    }\r\n\r\n    if (initialPrice) {\r\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\r\n    } else {\r\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\r\n    }\r\n    \r\n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\r\n      timestampEnd = now + increaseTimeBy;\r\n    }\r\n\r\n    initialPrice = false;\r\n    price = bids[msg.sender];\r\n    winner = msg.sender;\r\n    emit BidEvent(winner, msg.value, now); // THINK: I prefer sharing the value of the current transaction, the total value can be retrieved from the array\r\n  }\r\n\r\n  function finalize() public ended() onlyOwner() {\r\n    require(finalized == false, \"can withdraw only once\");\r\n    require(initialPrice == false, \"can withdraw only if there were bids\");\r\n\r\n    finalized = true;\r\n    beneficiary.transfer(price);\r\n  }\r\n\r\n  function refund(address addr) private {\r\n    require(addr != winner, \"winner cannot refund\");\r\n    require(bids[addr] > 0, \"refunds only allowed if you sent something\");\r\n\r\n    uint refundValue = bids[addr];\r\n    bids[addr] = 0; // reentrancy fix, setting to zero first\r\n    addr.transfer(refundValue);\r\n    \r\n    emit Refund(addr, refundValue, now);\r\n  }\r\n\r\n  function refund() public {\r\n    refund(msg.sender);\r\n  }\r\n\r\n  function refundOnBehalf(address addr) public onlyOwner() {\r\n    refund(addr);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/AuctionMultiple.sol\r\n\r\n// 1, \"something\", 1539659548, \"0xca35b7d915458ef540ade6068dfe2f44e8fa733c\", 3\r\n// 1, \"something\", 1539659548, \"0x315f80C7cAaCBE7Fb1c14E65A634db89A33A9637\", 3\r\n\r\ncontract AuctionMultiple is Auction {\r\n\r\n  uint public constant LIMIT = 2000; // due to gas restrictions we limit the number of participants in the auction (no Burning Man tickets yet)\r\n  uint public constant HEAD = 120000000 * 1e18; // uint(-1); // really big number\r\n  uint public constant TAIL = 0;\r\n  uint public lastBidID = 0;  \r\n  uint public howMany; // number of items to sell, for isntance 40k tickets to a concert\r\n\r\n  struct Bid {\r\n    uint prev;            // bidID of the previous element.\r\n    uint next;            // bidID of the next element.\r\n    uint value;\r\n    address contributor;  // The contributor who placed the bid.\r\n  }    \r\n\r\n  mapping (uint => Bid) public bids; // map bidID to actual Bid structure\r\n  mapping (address => uint) public contributors; // map address to bidID\r\n  \r\n  event LogNumber(uint number);\r\n  event LogText(string text);\r\n  event LogAddress(address addr);\r\n  \r\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary, uint _howMany) Auction(_price, _description, _timestampEnd, _beneficiary) public {\r\n    require(_howMany > 1, \"This auction is suited to multiple items. With 1 item only - use different code. Or remove this 'require' - you've been warned\");\r\n    howMany = _howMany;\r\n\r\n    bids[HEAD] = Bid({\r\n        prev: TAIL,\r\n        next: TAIL,\r\n        value: HEAD,\r\n        contributor: address(0)\r\n    });\r\n    bids[TAIL] = Bid({\r\n        prev: HEAD,\r\n        next: HEAD,\r\n        value: TAIL,\r\n        contributor: address(0)\r\n    });    \r\n  }\r\n\r\n  function bid() public payable {\r\n    require(now < timestampEnd, \"cannot bid after the auction ends\");\r\n\r\n    uint myBidId = contributors[msg.sender];\r\n    uint insertionBidId;\r\n    \r\n    if (myBidId > 0) { // sender has already placed bid, we increase the existing one\r\n        \r\n      Bid storage existingBid = bids[myBidId];\r\n      existingBid.value = existingBid.value + msg.value;\r\n      if (existingBid.value > bids[existingBid.next].value) { // else do nothing (we are lower than the next one)\r\n        insertionBidId = searchInsertionPoint(existingBid.value, existingBid.next);\r\n\r\n        bids[existingBid.prev].next = existingBid.next;\r\n        bids[existingBid.next].prev = existingBid.prev;\r\n\r\n        existingBid.prev = insertionBidId;\r\n        existingBid.next = bids[insertionBidId].next;\r\n\r\n        bids[ bids[insertionBidId].next ].prev = myBidId;\r\n        bids[insertionBidId].next = myBidId;\r\n      } \r\n\r\n    } else { // bid from this guy does not exist, create a new one\r\n      require(msg.value >= price, \"Not much sense sending less than the price, likely an error\"); // but it is OK to bid below the cut off bid, some guys may withdraw\r\n      require(lastBidID < LIMIT, \"Due to blockGas limit we limit number of people in the auction to 4000 - round arbitrary number - check test gasLimit folder for more info\");\r\n\r\n      lastBidID++;\r\n\r\n      insertionBidId = searchInsertionPoint(msg.value, TAIL);\r\n\r\n      contributors[msg.sender] = lastBidID;\r\n      accountsList.push(msg.sender);\r\n\r\n      bids[lastBidID] = Bid({\r\n        prev: insertionBidId,\r\n        next: bids[insertionBidId].next,\r\n        value: msg.value,\r\n        contributor: msg.sender\r\n      });\r\n\r\n      bids[ bids[insertionBidId].next ].prev = lastBidID;\r\n      bids[insertionBidId].next = lastBidID;\r\n    }\r\n\r\n    emit BidEvent(msg.sender, msg.value, now);\r\n  }\r\n\r\n  function refund(address addr) private {\r\n    uint bidId = contributors[addr];\r\n    require(bidId > 0, \"the guy with this address does not exist, makes no sense to witdraw\");\r\n    uint position = getPosition(addr);\r\n    require(position > howMany, \"only the non-winning bids can be withdrawn\");\r\n\r\n    Bid memory thisBid = bids[ bidId ];\r\n    bids[ thisBid.prev ].next = thisBid.next;\r\n    bids[ thisBid.next ].prev = thisBid.prev;\r\n\r\n    delete bids[ bidId ]; // clearning storage\r\n    delete contributors[ msg.sender ]; // clearning storage\r\n    // cannot delete from accountsList - cannot shrink an array in place without spending shitloads of gas\r\n\r\n    addr.transfer(thisBid.value);\r\n    emit Refund(addr, thisBid.value, now);\r\n  }\r\n\r\n  function finalize() public ended() onlyOwner() {\r\n    require(finalized == false, \"auction already finalized, can withdraw only once\");\r\n    finalized = true;\r\n\r\n    uint sumContributions = 0;\r\n    uint counter = 0;\r\n    Bid memory currentBid = bids[HEAD];\r\n    while(counter++ < howMany && currentBid.prev != TAIL) {\r\n      currentBid = bids[ currentBid.prev ];\r\n      sumContributions += currentBid.value;\r\n    }\r\n\r\n    beneficiary.transfer(sumContributions);\r\n  }\r\n\r\n  // We are  starting from TAIL and going upwards\r\n  // This is to simplify the case of increasing bids (can go upwards, cannot go lower)\r\n  // NOTE: blockSize gas limit in case of so many bids (wishful thinking)\r\n  function searchInsertionPoint(uint _contribution, uint _startSearch) view public returns (uint) {\r\n    require(_contribution > bids[_startSearch].value, \"your contribution and _startSearch does not make sense, it will search in a wrong direction\");\r\n\r\n    Bid memory lowerBid = bids[_startSearch];\r\n    Bid memory higherBid;\r\n\r\n    while(true) { // it is guaranteed to stop as we set the HEAD bid with very high maximum valuation\r\n      higherBid = bids[lowerBid.next];\r\n\r\n      if (_contribution < higherBid.value) {\r\n        return higherBid.prev;\r\n      } else {\r\n        lowerBid = higherBid;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getPosition(address addr) view public returns(uint) {\r\n    uint bidId = contributors[addr];\r\n    require(bidId != 0, \"cannot ask for a position of a guy who is not on the list\");\r\n    uint position = 1;\r\n\r\n    Bid memory currentBid = bids[HEAD];\r\n\r\n    while (currentBid.prev != bidId) { // BIG LOOP WARNING, that why we have LIMIT\r\n      currentBid = bids[currentBid.prev];\r\n      position++;\r\n    }\r\n    return position;\r\n  }\r\n\r\n  function getPosition() view public returns(uint) { // shorthand for calling without parameters\r\n    return getPosition(msg.sender);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/AuctionMultipleGuaranteed.sol\r\n\r\n// 100000000000000000, \"membership in Casa Crypto\", 1546300799, \"0x8855Ef4b740Fc23D822dC8e1cb44782e52c07e87\", 20, 5, 5000000000000000000\r\n// 100000000000000000, \"membership in Casa Crypto\", 1546300799, \"0x85A363699C6864248a6FfCA66e4a1A5cCf9f5567\", 2, 1, 5000000000000000000\r\n\r\n// For instance: effering limited \"Early Bird\" tickets that are guaranteed\r\ncontract AuctionMultipleGuaranteed is AuctionMultiple {\r\n\r\n  uint public howManyGuaranteed; // after guaranteed slots are used, we decrease the number of slots available (in the parent contract)\r\n  uint public priceGuaranteed;\r\n  address[] public guaranteedContributors; // cannot iterate mapping, keeping addresses in an array\r\n  mapping (address => uint) public guaranteedContributions;\r\n  function getGuaranteedContributorsLenght() public constant returns(uint) { return guaranteedContributors.length; } // lenght is not accessible from DApp, exposing convenience method: https://stackoverflow.com/questions/43016011/getting-the-length-of-public-array-variable-getter\r\n\r\n  event GuaranteedBid(address indexed bidder, uint value, uint timestamp);\r\n  \r\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary, uint _howMany, uint _howManyGuaranteed, uint _priceGuaranteed) AuctionMultiple(_price, _description, _timestampEnd, _beneficiary, _howMany) public {\r\n    require(_howMany >= _howManyGuaranteed, \"The number of guaranteed items should be less or equal than total items. If equal = fixed price sell, kind of OK with me\");\r\n    require(_priceGuaranteed > 0, \"Guranteed price must be greated than zero\");\r\n\r\n    howManyGuaranteed = _howManyGuaranteed;\r\n    priceGuaranteed = _priceGuaranteed;\r\n  }\r\n\r\n  function bid() public payable {\r\n    require(now < timestampEnd, \"cannot bid after the auction ends\");\r\n    require(guaranteedContributions[msg.sender] == 0, \"already a guranteed contributor, cannot more than once\");\r\n\r\n    if (msg.value >= priceGuaranteed && howManyGuaranteed > 0) {\r\n      guaranteedContributors.push(msg.sender);\r\n      guaranteedContributions[msg.sender] = msg.value;\r\n      howManyGuaranteed--;\r\n      howMany--;\r\n      emit GuaranteedBid(msg.sender, msg.value, now);\r\n    } else {\r\n      super.bid(); // https://ethereum.stackexchange.com/questions/25046/inheritance-and-function-overwriting-who-can-call-the-parent-function\r\n    }\r\n  }\r\n\r\n  function finalize() public ended() onlyOwner() {\r\n    require(finalized == false, \"auction already finalized, can withdraw only once\");\r\n    finalized = true;\r\n\r\n    uint sumContributions = 0;\r\n    uint counter = 0;\r\n    Bid memory currentBid = bids[HEAD];\r\n    while(counter++ < howMany && currentBid.prev != TAIL) {\r\n      currentBid = bids[ currentBid.prev ];\r\n      sumContributions += currentBid.value;\r\n    }\r\n\r\n    // At all times we are aware of gas limits - that's why we limit auction to 2000 participants, see also `test-gasLimit` folder\r\n    for (uint i=0; i<guaranteedContributors.length; i++) {\r\n      sumContributions += guaranteedContributions[ guaranteedContributors[i] ];\r\n    }\r\n\r\n    beneficiary.transfer(sumContributions);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"timestampEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howManyGuaranteed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HEAD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"instructions\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"prev\",\"type\":\"uint256\"},{\"name\":\"next\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"contributor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGuaranteedContributorsLenght\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"refundOnBehalf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBidID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howMany\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"guaranteedContributors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"increaseTimeIfBidBeforeEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"setDescription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contribution\",\"type\":\"uint256\"},{\"name\":\"_startSearch\",\"type\":\"uint256\"}],\"name\":\"searchInsertionPoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceGuaranteed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccountListLenght\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TAIL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"increaseTimeBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accountsList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"guaranteedContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_instructions\",\"type\":\"string\"}],\"name\":\"setInstructions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_timestampEnd\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_howMany\",\"type\":\"uint256\"},{\"name\":\"_howManyGuaranteed\",\"type\":\"uint256\"},{\"name\":\"_priceGuaranteed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"GuaranteedBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"LogNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"LogText\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BidEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"AuctionMultipleGuaranteed","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000005bb1637f00000000000000000000000009b25f7627a8d509e5fac01cb7692fdbc26a2663000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000196d656d6265727368697020696e20436173612043727970746f00000000000000","Library":"","SwarmSource":"bzzr://7989b752b0e4bf021ccb1908a9735b0999d234ff065748620fa8afe9fb87c522"}]}