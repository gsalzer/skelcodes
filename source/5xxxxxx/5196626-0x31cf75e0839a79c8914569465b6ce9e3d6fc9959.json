{"status":"1","message":"OK","result":[{"SourceCode":"// EtherGen Contract: \r\n\r\n// Base Minting Contract\r\n\r\ncontract CardMintingFacilitator {\r\n    CardConfig schema = CardConfig(0x08584271df3d0249c2c06ac1bc1237a1dd30cb9a); \r\n    EtherGenCore storageContract = EtherGenCore(0x677aa1dc08b9429c595efd4425b2d218cc22fd6e);\r\n    address public owner = 0x08F4aE96b647B30177cc15B21195960625BA4163;\r\n    \r\n    function generateRandomCard(uint32 randomSeed) internal constant returns (uint8[14]) {\r\n        uint8[14] memory cardDetails;\r\n       \r\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n        cardDetails[0] = schema.getType(randomSeed);\r\n\r\n        if (cardDetails[0] == uint8(CardConfig.Type.Monster)) {\r\n            generateRandomMonster(cardDetails, randomSeed);\r\n        } else {\r\n            generateRandomSpell(cardDetails, randomSeed);\r\n        }\r\n        \r\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n        if (randomSeed % 200 == 13) { // Lucky number 13\r\n            cardDetails[12] = 1; // Secret golden attribute\r\n        }\r\n        \r\n        return cardDetails;\r\n    }\r\n    \r\n    function generateRandomMonster(uint8[14] cardDetails, uint32 randomSeed) internal constant {\r\n        uint24 totalCost;\r\n        \r\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n        cardDetails[1] = schema.getRace(randomSeed);\r\n        totalCost += schema.getCostForRace(cardDetails[1]);\r\n\r\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n        cardDetails[2] = schema.getTrait(randomSeed);\r\n        totalCost += schema.getCostForTrait(cardDetails[2]);\r\n\r\n        uint8 newMutation;\r\n        uint24 newMutationCost;\r\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n        \r\n        uint8 numMutations = uint8(randomSeed % 12); // 0 = 0 mutations, 1 = 1 mutation, 2-5 = 2 mutations, 6-11 = 3 mutations \r\n        if (numMutations > 5) {\r\n            numMutations = 3;\r\n        } else if (numMutations > 2) {\r\n            numMutations = 2;\r\n        }\r\n        \r\n        for (uint8 i = 0; i < numMutations; i++) {\r\n            randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n            if (bool(randomSeed % 3 == 0)) { // 0: Race; 1-2: Neutral\r\n                randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n\r\n                // Horribly add new mutations (rather than looping for a fresh one) this is cheaper\r\n                (newMutationCost, newMutation) = schema.getMutationForRace(CardConfig.Race(cardDetails[1]), randomSeed);\r\n                if (totalCost + newMutationCost < 290000) {\r\n                    if (cardDetails[6] == 0) {\r\n                        cardDetails[6] = newMutation;\r\n                        totalCost += newMutationCost;\r\n                    } else if (cardDetails[6] > 0 && cardDetails[7] == 0 && cardDetails[6] != newMutation) {\r\n                        cardDetails[7] = newMutation;\r\n                        totalCost += newMutationCost;\r\n                    } else if  (cardDetails[6] > 0 && cardDetails[7] > 0 && cardDetails[8] == 0 && cardDetails[6] != newMutation && cardDetails[7] != newMutation) {\r\n                        cardDetails[8] = newMutation;\r\n                        totalCost += newMutationCost;\r\n                    }\r\n                }\r\n            } else {\r\n                randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n\r\n                // Horribly add new mutations (rather than looping for a fresh one) this is cheaper\r\n                (newMutationCost, newMutation) = schema.getNeutralMutation(randomSeed);\r\n                if (totalCost + newMutationCost < 290000) {\r\n                    if (cardDetails[9] == 0) {\r\n                        cardDetails[9] = newMutation;\r\n                        totalCost += newMutationCost;\r\n                    } else if (cardDetails[9] > 0 && cardDetails[10] == 0 && cardDetails[9] != newMutation) {\r\n                        cardDetails[10] = newMutation;\r\n                        totalCost += newMutationCost;\r\n                    } else if (cardDetails[9] > 0 && cardDetails[10] > 0 && cardDetails[11] == 0 && cardDetails[9] != newMutation && cardDetails[10] != newMutation) {\r\n                        cardDetails[11] = newMutation;\r\n                        totalCost += newMutationCost;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // For attack & health distribution\r\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n        uint24 powerCost = schema.getCostForHealth(1) + uint24(randomSeed % (301000 - (totalCost + schema.getCostForHealth(1)))); // % upto 300999 will allow 30 cost cards\r\n\r\n        if (totalCost + powerCost < 100000) { // Cards should cost at least 10 crystals (10*10000 exponant)\r\n            powerCost = 100000 - totalCost;\r\n        }\r\n        \r\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n        cardDetails[5] = 1 + uint8(schema.getHealthForCost(randomSeed % powerCost)); // should be (1 + powerCost - schema.getCostForHealth(1))\r\n        totalCost += schema.getCostForHealth(cardDetails[5]);\r\n        \r\n        powerCost = powerCost - schema.getCostForHealth(cardDetails[5]); // Power left for attack\r\n        cardDetails[4] = uint8(schema.getAttackForCost(powerCost));\r\n        totalCost += schema.getCostForAttack(cardDetails[4]);\r\n       \r\n        // Remove exponent to get total card cost [10-30]\r\n        cardDetails[3] = uint8(totalCost / 10000);\r\n    }\r\n    \r\n    \r\n    function generateRandomSpell(uint8[14] cardDetails, uint32 randomSeed) internal constant {\r\n        uint24 totalCost;\r\n        \r\n        uint8 newAbility;\r\n        uint24 newAbilityCost;\r\n        randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n        \r\n        uint8 numAbilities = uint8(randomSeed % 16); // 0 = 1 ability, 1-8 = 2 abilities, 9-15 = 3 abilities \r\n        if (numAbilities > 8) {\r\n            numAbilities = 3;\r\n        } else if (numAbilities > 0) {\r\n            numAbilities = 2;\r\n        } else {\r\n            numAbilities = 1;\r\n        }\r\n        \r\n        for (uint8 i = 0; i < numAbilities; i++) {\r\n            randomSeed = uint32(sha3(block.blockhash(block.number), randomSeed));\r\n\r\n            // Horribly add new spell abilities (rather than looping for a fresh one) this is cheaper\r\n            (newAbilityCost, newAbility) = schema.getSpellAbility(randomSeed);\r\n            if (totalCost + newAbilityCost <= 300000) {\r\n                if (cardDetails[9] == 0) {\r\n                    cardDetails[9] = newAbility;\r\n                    totalCost += newAbilityCost;\r\n                } else if (cardDetails[9] > 0 && cardDetails[10] == 0 && cardDetails[9] != newAbility) {\r\n                    cardDetails[10] = newAbility;\r\n                    totalCost += newAbilityCost;\r\n                } else if (cardDetails[9] > 0 && cardDetails[10] > 0 && cardDetails[11] == 0 && cardDetails[9] != newAbility && cardDetails[10] != newAbility) {\r\n                    cardDetails[11] = newAbility;\r\n                    totalCost += newAbilityCost;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Remove exponent to get total card cost [10-30]\r\n        cardDetails[3] = uint8(totalCost / 10000);\r\n    }\r\n    \r\n    \r\n    function generateCostFromAttributes(uint8[14] cardDetails) internal constant returns (uint8 cost) {\r\n        uint24 exponentCost = 0;\r\n        if (cardDetails[0] == 1) { // Spell\r\n            exponentCost += schema.getSpellAbilityCost(cardDetails[9]);\r\n            exponentCost += schema.getSpellAbilityCost(cardDetails[10]);\r\n            exponentCost += schema.getSpellAbilityCost(cardDetails[11]);\r\n        } else {\r\n            exponentCost += schema.getCostForRace(cardDetails[1]);\r\n            exponentCost += schema.getCostForTrait(cardDetails[2]);\r\n            exponentCost += schema.getCostForAttack(cardDetails[4]);\r\n            exponentCost += schema.getCostForHealth(cardDetails[5]);\r\n            exponentCost += schema.getRaceMutationCost(CardConfig.Race(cardDetails[1]), cardDetails[6]);\r\n            exponentCost += schema.getRaceMutationCost(CardConfig.Race(cardDetails[1]), cardDetails[7]);\r\n            exponentCost += schema.getRaceMutationCost(CardConfig.Race(cardDetails[1]), cardDetails[8]);\r\n            exponentCost += schema.getNeutralMutationCost(cardDetails[9]);\r\n            exponentCost += schema.getNeutralMutationCost(cardDetails[10]);\r\n            exponentCost += schema.getNeutralMutationCost(cardDetails[11]);\r\n        }\r\n        return uint8(exponentCost / 10000); // Everything is factor 10000 for ease of autonomous Workshop cost-tuning\r\n    }\r\n    \r\n    // Allows future extensibility (New card mutations + Workshop updates)\r\n    function upgradeCardConfig(address newCardConfig) external {\r\n        require(msg.sender == owner);\r\n        schema = CardConfig(newCardConfig);\r\n    }\r\n    \r\n    function updateStorageContract(address newStorage) external {\r\n        require(msg.sender == owner);\r\n        storageContract = EtherGenCore(newStorage);\r\n    }\r\n    \r\n    function updateOwner(address newOwner) external {\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//// Card Promotion + Referrals\r\n\r\ncontract NewUserBonusDistributor is CardMintingFacilitator {\r\n    mapping(address => bool) private claimedAddresses; // You only get one free card for 'signing up'\r\n    bool public newUserBonusCardTradable = true; // If people abuse new user bonus they will be made untradable (but unlocked via battle)\r\n    \r\n    address[] public referals; // Array to store all unpaid referal cards\r\n    \r\n    function claimFreeFirstCard(address referer) external {\r\n        require(!claimedAddresses[msg.sender]);\r\n        \r\n        uint8[14] memory newCard = generateRandomCard(uint32(msg.sender));\r\n        if (!newUserBonusCardTradable) {\r\n            newCard[13] = 1;\r\n        }\r\n        claimedAddresses[msg.sender] = true;\r\n        storageContract.mintCard(msg.sender, newCard);\r\n        allocateReferalBonus(referer);\r\n    }\r\n    \r\n    function hasAlreadyClaimed() external constant returns (bool) {\r\n        return claimedAddresses[msg.sender];\r\n    }\r\n    \r\n    function allocateReferalBonus(address referer) internal {\r\n        // To save new players gas, referals will be async and payed out manually by our team\r\n        if (referer != address(0) && referer != msg.sender) {\r\n            referals.push(referer);\r\n            referals.push(msg.sender);\r\n        }\r\n    }\r\n    \r\n    function awardReferalBonus() external {\r\n        // To save new players gas, referals are payed out below manually (by our team + kind gas donors)\r\n        require(referals.length > 0);\r\n        address recipient = referals[referals.length - 1];\r\n        uint8[14] memory newCard = generateRandomCard(uint32(storageContract.totalSupply() * now));\r\n        newCard[13] = 1; // Referal cards untradable to prevent abuse (unlocked via battle)\r\n        \r\n        delete referals[referals.length - 1];\r\n        referals.length--;\r\n        storageContract.mintCard(recipient, newCard);\r\n    }\r\n    \r\n    function setNewUserBonusCardTradable(bool tradable) external {\r\n        require(msg.sender == owner);\r\n        newUserBonusCardTradable = tradable;\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\ncontract ERC721 {\r\n\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 cards);\r\n    function balanceOf(address player) public view returns (uint256 balance);\r\n    function ownerOf(uint256 cardId) external view returns (address owner);\r\n    function approve(address to, uint256 cardId) external;\r\n    function transfer(address to, uint256 cardId) external;\r\n    function transferFrom(address from, address to, uint256 cardId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 cardId);\r\n    event Approval(address owner, address approved, uint256 cardId);\r\n\r\n    // Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant name = \"EtherGen\";\r\n    string public constant symbol = \"ETG\";\r\n\r\n    // Optional methods\r\n    function tokensOfOwner(address player) external view returns (uint64[] cardIds);\r\n}\r\n\r\n\r\n// Base Storage for EtherGen\r\ncontract PlayersCollectionStorage {\r\n    \r\n    mapping(address => PlayersCollection) internal playersCollections;\r\n    mapping(uint64 => Card) internal cardIdMapping;\r\n\r\n    struct PlayersCollection {\r\n        uint64[] cardIds;\r\n        bool referalCardsUnlocked;\r\n    }\r\n\r\n    struct Card {\r\n        uint64 id;\r\n        uint64 collectionPointer; // Index in player's collection\r\n        address owner;\r\n        \r\n        uint8 cardType;\r\n        uint8 race;\r\n        uint8 trait;\r\n\r\n        uint8 cost; // [10-30]\r\n        uint8 attack; // [0-99]\r\n        uint8 health; // [1-99]\r\n\r\n        uint8 raceMutation0; // Super ugly but dynamic length arrays are currently a no-go across contracts\r\n        uint8 raceMutation1; // + very expensive gas since cards are in nested structs (collection of cards)\r\n        uint8 raceMutation2;\r\n\r\n        uint8 neutralMutation0;\r\n        uint8 neutralMutation1;\r\n        uint8 neutralMutation2;\r\n\r\n        /**\r\n         * Initally referal (free) cards will be untradable (to stop abuse) however EtherGenCore has\r\n         * unlockUntradeableCards() to make them tradeable -triggered once player hits certain battle/game milestone\r\n         */\r\n        bool isReferalReward;\r\n        bool isGolden; // Top secret Q2 animated art\r\n    }\r\n    \r\n    function getPlayersCollection(address player) public constant returns (uint64[], uint8[14][]) {\r\n        uint8[14][] memory cardDetails = new uint8[14][](playersCollections[player].cardIds.length);\r\n        uint64[] memory cardIds = new uint64[](playersCollections[player].cardIds.length);\r\n\r\n        for (uint32 i = 0; i < playersCollections[player].cardIds.length; i++) {\r\n            Card memory card = cardIdMapping[playersCollections[player].cardIds[i]];\r\n            cardDetails[i][0] = card.cardType;\r\n            cardDetails[i][1] = card.race;\r\n            cardDetails[i][2] = card.trait;\r\n            cardDetails[i][3] = card.cost;\r\n            cardDetails[i][4] = card.attack;\r\n            cardDetails[i][5] = card.health;\r\n            cardDetails[i][6] = card.raceMutation0;\r\n            cardDetails[i][7] = card.raceMutation1;\r\n            cardDetails[i][8] = card.raceMutation2;\r\n            cardDetails[i][9] = card.neutralMutation0;\r\n            cardDetails[i][10] = card.neutralMutation1;\r\n            cardDetails[i][11] = card.neutralMutation2;\r\n\r\n            cardDetails[i][12] = card.isGolden ? 1 : 0; // Not ideal but web3.js didn't like returning multiple 2d arrays\r\n            cardDetails[i][13] = isCardTradeable(card) ? 1 : 0;\r\n            \r\n            cardIds[i] = card.id;\r\n        }\r\n        return (cardIds, cardDetails);\r\n    }\r\n    \r\n    function getCard(uint64 cardId) public constant returns (uint8[14]) {\r\n        Card memory card = cardIdMapping[cardId];\r\n        return ([card.cardType, card.race, card.trait, card.cost, card.attack, card.health,\r\n                 card.raceMutation0, card.raceMutation1, card.raceMutation2,\r\n                 card.neutralMutation0, card.neutralMutation1, card.neutralMutation2,\r\n                 card.isGolden ? 1 : 0, \r\n                 isCardTradeable(card) ? 1 : 0]);\r\n    }\r\n    \r\n    function isCardTradeable(Card card) internal constant returns(bool) {\r\n        return (playersCollections[card.owner].referalCardsUnlocked || !card.isReferalReward);\r\n    }\r\n    \r\n    function isCardTradeable(uint64 cardId) external constant returns(bool) {\r\n        return isCardTradeable(cardIdMapping[cardId]);\r\n    }\r\n}\r\n\r\n\r\n\r\n// Extensibility of storage + ERCness\r\ncontract EtherGenCore is PlayersCollectionStorage, ERC721 {\r\n    \r\n    mapping(address => bool) private privilegedTransferModules; // Marketplace ( + future features)\r\n    mapping(address => bool) private privilegedMintingModules; // Referals, Fusing, Workshop etc. ( + future features)\r\n    \r\n    mapping(uint64 => address) private cardIdApproveds; // Approval list (ERC721 transfers)\r\n    uint64 private totalCardSupply; // Also used for cardId incrementation\r\n    \r\n    TransferRestrictionVerifier transferRestrictionVerifier = TransferRestrictionVerifier(0xd9861d9a6111bfbb9235a71151f654d0fe7ed954); \r\n    address public owner = 0x08F4aE96b647B30177cc15B21195960625BA4163;\r\n    bool public paused = false;\r\n    \r\n    function totalSupply() public view returns (uint256 cards) {\r\n        return totalCardSupply;\r\n    }\r\n    \r\n    function ownerOf(uint256 cardId) external view returns (address cardOwner) {\r\n        return cardIdMapping[uint64(cardId)].owner;\r\n    }\r\n    \r\n    function balanceOf(address player) public view returns (uint256 balance) {\r\n        return playersCollections[player].cardIds.length;\r\n    }\r\n    \r\n    function tokensOfOwner(address player) external view returns (uint64[] cardIds) {\r\n        return playersCollections[player].cardIds;\r\n    }\r\n    \r\n    function transfer(address newOwner, uint256 cardId) external {\r\n        uint64 castCardId = uint64(cardId);\r\n        require(cardIdMapping[castCardId].owner == msg.sender);\r\n        require(isCardTradeable(cardIdMapping[castCardId]));\r\n        require(transferRestrictionVerifier.isAvailableForTransfer(castCardId));\r\n        require(!paused);\r\n        \r\n        removeCardOwner(castCardId);\r\n        assignCardOwner(newOwner, castCardId);\r\n        Transfer(msg.sender, newOwner, castCardId); // Emit Event\r\n    }\r\n    \r\n    function transferFrom(address currentOwner, address newOwner, uint256 cardId) external {\r\n        uint64 castCardId = uint64(cardId);\r\n        require(cardIdMapping[castCardId].owner == currentOwner);\r\n        require(isApprovedTransferer(msg.sender, castCardId));\r\n        require(isCardTradeable(cardIdMapping[castCardId]));\r\n        require(transferRestrictionVerifier.isAvailableForTransfer(castCardId));\r\n        require(!paused);\r\n        \r\n        removeCardOwner(castCardId);\r\n        assignCardOwner(newOwner, castCardId);\r\n        Transfer(currentOwner, newOwner, castCardId); // Emit Event\r\n    }\r\n    \r\n    function approve(address approved, uint256 cardId) external {\r\n        uint64 castCardId = uint64(cardId);\r\n        require(cardIdMapping[castCardId].owner == msg.sender);\r\n        \r\n        cardIdApproveds[castCardId] = approved; // Register approval (replacing previous)\r\n        Approval(msg.sender, approved, castCardId); // Emit Event\r\n    }\r\n    \r\n    function isApprovedTransferer(address approvee, uint64 cardId) internal constant returns (bool) {\r\n        // Will only return true if approvee (msg.sender) is a privileged transfer address (Marketplace) or santioned by card's owner using ERC721's approve()\r\n        return privilegedTransferModules[approvee] || cardIdApproveds[cardId] == approvee;\r\n    }\r\n    \r\n    function removeCardOwner(uint64 cardId) internal {\r\n        address cardOwner = cardIdMapping[cardId].owner;\r\n\r\n        if (playersCollections[cardOwner].cardIds.length > 1) {\r\n            uint64 rowToDelete = cardIdMapping[cardId].collectionPointer;\r\n            uint64 cardIdToMove = playersCollections[cardOwner].cardIds[playersCollections[cardOwner].cardIds.length - 1];\r\n            playersCollections[cardOwner].cardIds[rowToDelete] = cardIdToMove;\r\n            cardIdMapping[cardIdToMove].collectionPointer = rowToDelete;\r\n        }\r\n        \r\n        playersCollections[cardOwner].cardIds.length--;\r\n        cardIdMapping[cardId].owner = 0;\r\n    }\r\n    \r\n    function assignCardOwner(address newOwner, uint64 cardId) internal {\r\n        if (newOwner != address(0)) {\r\n            cardIdMapping[cardId].owner = newOwner;\r\n            cardIdMapping[cardId].collectionPointer = uint64(playersCollections[newOwner].cardIds.push(cardId) - 1);\r\n        }\r\n    }\r\n    \r\n    function mintCard(address recipient, uint8[14] cardDetails) external {\r\n        require(privilegedMintingModules[msg.sender]);\r\n        require(!paused);\r\n        \r\n        Card memory card;\r\n        card.owner = recipient;\r\n        \r\n        card.cardType = cardDetails[0];\r\n        card.race = cardDetails[1];\r\n        card.trait = cardDetails[2];\r\n        card.cost = cardDetails[3];\r\n        card.attack = cardDetails[4];\r\n        card.health = cardDetails[5];\r\n        card.raceMutation0 = cardDetails[6];\r\n        card.raceMutation1 = cardDetails[7];\r\n        card.raceMutation2 = cardDetails[8];\r\n        card.neutralMutation0 = cardDetails[9];\r\n        card.neutralMutation1 = cardDetails[10];\r\n        card.neutralMutation2 = cardDetails[11];\r\n        card.isGolden = cardDetails[12] == 1;\r\n        card.isReferalReward = cardDetails[13] == 1;\r\n        \r\n        card.id = totalCardSupply;\r\n        totalCardSupply++;\r\n\r\n        cardIdMapping[card.id] = card;\r\n        cardIdMapping[card.id].collectionPointer = uint64(playersCollections[recipient].cardIds.push(card.id) - 1);\r\n    }\r\n    \r\n    // Management functions to facilitate future contract extensibility, unlocking of (untradable) referal bonus cards and contract ownership\r\n    \r\n    function unlockUntradeableCards(address player) external {\r\n        require(privilegedTransferModules[msg.sender]);\r\n        playersCollections[player].referalCardsUnlocked = true;\r\n    }\r\n    \r\n    function manageApprovedTransferModule(address moduleAddress, bool isApproved) external {\r\n        require(msg.sender == owner);\r\n        privilegedTransferModules[moduleAddress] = isApproved; \r\n    }\r\n    \r\n     function manageApprovedMintingModule(address moduleAddress, bool isApproved) external {\r\n        require(msg.sender == owner);\r\n        privilegedMintingModules[moduleAddress] = isApproved; \r\n    }\r\n    \r\n    function updateTransferRestrictionVerifier(address newTransferRestrictionVerifier) external {\r\n        require(msg.sender == owner);\r\n        transferRestrictionVerifier = TransferRestrictionVerifier(newTransferRestrictionVerifier);\r\n    }\r\n    \r\n    function setPaused(bool shouldPause) external {\r\n        require(msg.sender == owner);\r\n        paused = shouldPause;\r\n    }\r\n    \r\n    function updateOwner(address newOwner) external {\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n\r\ncontract CardConfig {\r\n    enum Type {Monster, Spell} // More could come!\r\n\r\n    enum Race {Dragon, Spiderling, Demon, Humanoid, Beast, Undead, Elemental, Vampire, Serpent, Mech, Golem, Parasite}\r\n    uint16 constant numRaces = 12;\r\n\r\n    enum Trait {Normal, Fire, Poison, Lightning, Ice, Divine, Shadow, Arcane, Cursed, Void}\r\n    uint16 constant numTraits = 10;\r\n\r\n    function getType(uint32 randomSeed) public constant returns (uint8) {\r\n        if (randomSeed % 5 > 0) { // 80% chance for monster (spells are less fun so make up for it in rarity)\r\n            return uint8(Type.Monster);\r\n        } else {\r\n            return uint8(Type.Spell);\r\n        }\r\n    }\r\n    \r\n    function getRace(uint32 randomSeed) public constant returns (uint8) {\r\n        return uint8(Race(randomSeed % numRaces));\r\n    }\r\n\r\n    function getTrait(uint32 randomSeed) public constant returns (uint8) {\r\n        return uint8(Trait(randomSeed % numTraits));\r\n    }\r\n\r\n    SpellAbilities spellAbilities = new SpellAbilities();\r\n    SharedNeutralMutations neutralMutations = new SharedNeutralMutations();\r\n    DragonMutations dragonMutations = new DragonMutations();\r\n    SpiderlingMutations spiderlingMutations = new SpiderlingMutations();\r\n    DemonMutations demonMutations = new DemonMutations();\r\n    HumanoidMutations humanoidMutations = new HumanoidMutations();\r\n    BeastMutations beastMutations = new BeastMutations();\r\n    UndeadMutations undeadMutations = new UndeadMutations();\r\n    ElementalMutations elementalMutations = new ElementalMutations();\r\n    VampireMutations vampireMutations = new VampireMutations();\r\n    SerpentMutations serpentMutations = new SerpentMutations();\r\n    MechMutations mechMutations = new MechMutations();\r\n    GolemMutations golemMutations = new GolemMutations();\r\n    ParasiteMutations parasiteMutations = new ParasiteMutations();\r\n    \r\n\r\n    // The powerful schema that will allow the Workshop (crystal) prices to fluctuate based on performance, keeping the game fresh & evolve over time!\r\n    \r\n    function getCostForRace(uint8 race) public constant returns (uint8 cost) {\r\n        return 0; // born equal (under current config)\r\n    }\r\n    \r\n    function getCostForTrait(uint8 trait) public constant returns (uint24 cost) {\r\n        if (trait == uint8(CardConfig.Trait.Normal)) {\r\n            return 0;\r\n        }\r\n        return 40000;\r\n    }\r\n    \r\n    function getSpellAbility(uint32 randomSeed) public constant returns (uint24 cost, uint8 spell) {\r\n        spell = uint8(spellAbilities.getSpell(randomSeed)) + 1;\r\n        return (getSpellAbilityCost(spell), spell);\r\n    }\r\n    \r\n    function getSpellAbilityCost(uint8 spell) public constant returns (uint24 cost) {\r\n        return 100000;\r\n    }\r\n\r\n    function getNeutralMutation(uint32 randomSeed) public constant returns (uint24 cost, uint8 mutation) {\r\n        mutation = uint8(neutralMutations.getMutation(randomSeed)) + 1;\r\n        return (getNeutralMutationCost(mutation), mutation);\r\n    }\r\n    \r\n    function getNeutralMutationCost(uint8 mutation) public constant returns (uint24 cost) {\r\n        if (mutation == 0) {\r\n            return 0;   \r\n        }\r\n        return 40000;\r\n    }\r\n\r\n    function getMutationForRace(Race race, uint32 randomSeed) public constant returns (uint24 cost, uint8 mutation) {\r\n        if (race == Race.Dragon) {\r\n            mutation = uint8(dragonMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Spiderling) {\r\n            mutation = uint8(spiderlingMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Demon) {\r\n            mutation = uint8(demonMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Humanoid) {\r\n            mutation = uint8(humanoidMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Beast) {\r\n            mutation = uint8(beastMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Undead) {\r\n            mutation = uint8(undeadMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Elemental) {\r\n            mutation = uint8(elementalMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Vampire) {\r\n            mutation = uint8(vampireMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Serpent) {\r\n            mutation = uint8(serpentMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Mech) {\r\n            mutation = uint8(mechMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Golem) {\r\n            mutation = uint8(golemMutations.getRaceMutation(randomSeed)) + 1;\r\n        } else if (race == Race.Parasite) {\r\n            mutation = uint8(parasiteMutations.getRaceMutation(randomSeed)) + 1;\r\n        }\r\n        return (getRaceMutationCost(race, mutation), mutation);\r\n    }\r\n    \r\n    function getRaceMutationCost(Race race, uint8 mutation) public constant returns (uint24 cost) {\r\n        if (mutation == 0) {\r\n            return 0;   \r\n        }\r\n        return 40000;\r\n    }\r\n    \r\n    function getCostForHealth(uint8 health) public constant returns (uint24 cost) {\r\n        return health * uint24(2000);\r\n    }\r\n    \r\n    function getHealthForCost(uint32 cost) public constant returns (uint32 health) {\r\n        health = cost / 2000;\r\n        if (health > 98) { // 1+[0-98] (gotta have [1-99] health)\r\n            health = 98;\r\n        }\r\n        return health;\r\n    }\r\n    \r\n    function getCostForAttack(uint8 attack) public constant returns (uint24 cost) {\r\n        return attack * uint24(2000);\r\n    }\r\n    \r\n    function getAttackForCost(uint32 cost) public constant returns (uint32 attack) {\r\n       attack = cost / 2000;\r\n        if (attack > 99) {\r\n            attack = 99;\r\n        }\r\n        return attack;\r\n    }\r\n    \r\n}\r\n\r\ncontract SpellAbilities {\r\n    enum Spells {LavaBlast, FlameNova, Purify, IceBlast, FlashFrost, SnowStorm, FrostFlurry, ChargeFoward, DeepFreeze, ThawTarget,\r\n                 FlashOfLight, LightBeacon, BlackHole, Earthquake, EnchantArmor, EnchantWeapon, CallReinforcements, ParalysisPotion,\r\n                 InflictFear, ArcaneVision, KillShot, DragonsBreath, GlacialShard, BlackArrow, DivineKnowledge, LightningVortex,\r\n                 SolarFlare, PrimalBurst, RagingStorm, GiantCyclone, UnleashDarkness, ChargedOrb, UnholyMight, PowerShield, HallowedMist,\r\n                 EmbraceLight, AcidRain, BoneFlurry, Rejuvenation, DeathGrip, SummonSwarm, MagicalCharm, EnchantedSilence, SolemnStrike,\r\n                 ImpendingDoom, SpreadingFlames, ShadowLance, HauntedCurse, LightningShock, PowerSurge}\r\n    uint16 constant numSpells = 50;\r\n\r\n    function getSpell(uint32 randomSeed) public constant returns (Spells spell) {\r\n        return Spells(randomSeed % numSpells);\r\n    }\r\n}\r\n\r\n\r\ncontract SharedNeutralMutations {\r\n    enum Mutations {Frontline, CallReinforcements, ArmorPiercing, Battlecry, HealAlly, LevelUp, SecondWind, ChargingStrike, SpellShield, AugmentMagic, CrystalSiphon, \r\n                    ManipulateCrystals, DeadlyDemise, FlameResistance, IceResistance, LightningResistance, PoisonResistance, CurseResistance, DragonSlayer, SpiderlingSlayer,\r\n                    VampireSlayer, DemonSlayer, HumanoidSlayer, BeastSlayer, UndeadSlayer, SerpentSlayer, MechSlayer, GolemSlayer, ElementalSlayer, ParasiteSlayer}\r\n    uint16 constant numMutations = 30;\r\n\r\n    function getMutation(uint32 randomSeed) public constant returns (Mutations mutation) {\r\n        return Mutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\n\r\ncontract DragonMutations {\r\n    enum RaceMutations {FireBreath, HornedTail, BloodMagic, BarbedScales, WingedFlight, EggSpawn, Chronoshift, PhoenixFeathers}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract SpiderlingMutations {\r\n    enum RaceMutations {CripplingBite, BurrowTrap, SkitteringFrenzy, EggSpawn, CritterRush, WebCocoon, SummonBroodmother, TremorSense}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract VampireMutations {\r\n    enum RaceMutations {Bloodlink, LifeLeech, Bloodlust, DiamondSkin, TwilightVision, Regeneration, PiercingFangs, Shadowstrike}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract DemonMutations {\r\n    enum RaceMutations {PyreScales, ShadowRealm, MenacingGaze, Hellfire, RaiseAsh, TailLash, ReapSouls, BladedTalons}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract HumanoidMutations {\r\n    enum RaceMutations {Garrison, Entrench, Flagbearer, LegionCommander, ScoutAhead, Vengeance, EnchantedBlade, HorseRider}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract BeastMutations {\r\n    enum RaceMutations {FeralRoar, FelineClaws, PrimitiveTusks, ArcticFur, PackHunter, FeignDeath, RavenousBite, NightProwl}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract UndeadMutations {\r\n    enum RaceMutations {Reconstruct, AnimateDead, Pestilence, CrystalSkull, PsychicScreech, RavageSwipe, SpiritForm, BoneSpikes}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract SerpentMutations {\r\n    enum RaceMutations {Constrict, BurrowingStrike, PetrifyingGaze, EggSpawn, ShedScales, StoneBasilisk, EngulfPrey, SprayVenom}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract MechMutations {\r\n    enum RaceMutations {WhirlingBlade, RocketBoosters, SelfDestruct, EMPScramble, SpareParts, Deconstruct, TwinCannons, PowerShield}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract GolemMutations {\r\n    enum RaceMutations {StoneSentinel, ShatteringSmash, AnimateMud, MoltenCore, TremorGround, VineSprouts, ElementalRoar, FossilArmy}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract ElementalMutations {\r\n    enum RaceMutations {Sandstorm, SolarFlare, ElectricSurge, AquaRush, SpiritChannel, PhaseShift, CosmicAura, NaturesWrath}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\ncontract ParasiteMutations {\r\n    enum RaceMutations {Infestation, BloodLeech, Corruption, ProtectiveShell, TailSwipe, ExposeWound, StingingTentacles, EruptiveGut}\r\n    uint16 constant numMutations = 8;\r\n\r\n    function getRaceMutation(uint32 randomSeed) public constant returns (RaceMutations mutation) {\r\n        return RaceMutations(randomSeed % numMutations);\r\n    }\r\n}\r\n\r\n// Pulling checks like this into secondary contract allows for more extensibility in future (LoanMarketplace and so forth.)\r\ncontract TransferRestrictionVerifier {\r\n    MappedMarketplace marketplaceContract = MappedMarketplace(0xc3d2736b3e4f0f78457d75b3b5f0191a14e8bd57);\r\n    \r\n    function isAvailableForTransfer(uint64 cardId) external constant returns(bool) {\r\n        return !marketplaceContract.isListed(cardId);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract MappedMarketplace {\r\n    EtherGenCore storageContract; // Main card storage and ERC721 transfer functionality\r\n    TransferRestrictionVerifier transferRestrictionVerifier; // Allows future stuff (loan marketplace etc.) to restrict listing same card twice\r\n    \r\n    uint24 private constant removalDuration = 14 days; // Listings can be pruned from market after 14 days\r\n    uint8 private constant marketCut = 100; // 1% (not 100% as it is divided)\r\n    address public owner = 0x08F4aE96b647B30177cc15B21195960625BA4163;\r\n    bool public paused = false;\r\n\r\n    mapping(uint64 => Listing) private listings;\r\n    mapping(address => bool) private whitelistedContracts;\r\n    uint64[] private listedCardIds;\r\n\r\n    struct Listing {\r\n        uint64 listingPointer; // Index in the Market's listings\r\n        \r\n        uint64 cardId;\r\n        uint64 listTime; // Seconds\r\n        uint128 startPrice;\r\n        uint128 endPrice;\r\n        uint24 priceChangeDuration; // Seconds\r\n    }\r\n    \r\n    function isListed(uint64 cardId) public constant returns(bool) {\r\n        if (listedCardIds.length == 0) return false;\r\n        return (listings[cardId].listTime > 0);\r\n    }\r\n    \r\n    function getMarketSize() external constant returns(uint) {\r\n        return listedCardIds.length;\r\n    }\r\n    \r\n    function listCard(uint64 cardId, uint128 startPrice, uint128 endPrice, uint24 priceChangeDuration) external {\r\n        require(storageContract.ownerOf(cardId) == msg.sender);\r\n        require(storageContract.isCardTradeable(cardId));\r\n        require(transferRestrictionVerifier.isAvailableForTransfer(cardId));\r\n        require(isWhitelisted(msg.sender));\r\n        require(!paused);\r\n        require(startPrice > 99 szabo && startPrice <= 10 ether);\r\n        require(endPrice > 99 szabo && endPrice <= 10 ether);\r\n        require(priceChangeDuration > 21599 && priceChangeDuration < 259201); // 6-72 Hours\r\n       \r\n        listings[cardId] = Listing(0, cardId, uint64(now), startPrice, endPrice, priceChangeDuration);\r\n        listings[cardId].listingPointer = uint64(listedCardIds.push(cardId) - 1);\r\n    }\r\n    \r\n    \r\n    function purchaseCard(uint64 cardId) payable external {\r\n        require(isListed(cardId));\r\n        require(!paused);\r\n\r\n        uint256 price = getCurrentPrice(listings[cardId].startPrice, listings[cardId].endPrice, listings[cardId].priceChangeDuration, (uint64(now) - listings[cardId].listTime));\r\n        require(msg.value >= price);\r\n        \r\n        address seller = storageContract.ownerOf(cardId);\r\n        uint256 sellerProceeds = price - (price / marketCut); // 1% cut\r\n        \r\n        removeListingInternal(cardId);\r\n        seller.transfer(sellerProceeds);\r\n        \r\n        uint256 bidExcess = msg.value - price;\r\n        if (bidExcess > 1 szabo) { // Little point otherwise they'll just pay more in gas\r\n            msg.sender.transfer(bidExcess);\r\n        }\r\n        \r\n        storageContract.transferFrom(seller, msg.sender, cardId);\r\n    }\r\n    \r\n    function getCurrentPrice(uint128 startPrice, uint128 endPrice, uint24 priceChangeDuration, uint64 secondsSinceListing) public constant returns (uint256) {\r\n        if (secondsSinceListing >= priceChangeDuration) {\r\n            return endPrice;\r\n        } else {\r\n            int256 totalPriceChange = int256(endPrice) - int256(startPrice); // Can be negative\r\n            int256 currentPriceChange = totalPriceChange * int256(secondsSinceListing) / int256(priceChangeDuration);\r\n            return uint256(int256(startPrice) + currentPriceChange);\r\n        }\r\n    }\r\n    \r\n    function removeListing(uint64 cardId) external {\r\n        require(isListed(cardId));\r\n        require(!paused);\r\n        require(storageContract.ownerOf(cardId) == msg.sender || (now - listings[cardId].listTime) > removalDuration);\r\n        removeListingInternal(cardId);\r\n    }\r\n    \r\n    function removeListingInternal(uint64 cardId) internal {\r\n        if (listedCardIds.length > 1) {\r\n            uint64 rowToDelete = listings[cardId].listingPointer;\r\n            uint64 keyToMove = listedCardIds[listedCardIds.length - 1];\r\n            \r\n            listedCardIds[rowToDelete] = keyToMove;\r\n            listings[keyToMove].listingPointer = rowToDelete;\r\n        }\r\n        \r\n        listedCardIds.length--;\r\n        delete listings[cardId];\r\n    }\r\n    \r\n    \r\n    function getListings() external constant returns (uint64[], address[], uint64[], uint128[], uint128[], uint24[], uint8[14][]) {\r\n        uint64[] memory cardIds = new uint64[](listedCardIds.length); // Not ideal but web3.js didn't like returning multiple 2d arrays\r\n        address[] memory cardOwners = new address[](listedCardIds.length);\r\n        uint64[] memory listTimes = new uint64[](listedCardIds.length);\r\n        uint128[] memory startPrices = new uint128[](listedCardIds.length);\r\n        uint128[] memory endPrices = new uint128[](listedCardIds.length);\r\n        uint24[] memory priceChangeDurations = new uint24[](listedCardIds.length);\r\n        uint8[14][] memory cardDetails = new uint8[14][](listedCardIds.length);\r\n        \r\n        for (uint64 i = 0; i < listedCardIds.length; i++) {\r\n            Listing memory listing = listings[listedCardIds[i]];\r\n            cardDetails[i] = storageContract.getCard(listing.cardId);\r\n            cardOwners[i] = storageContract.ownerOf(listing.cardId);\r\n            cardIds[i] = listing.cardId;\r\n            listTimes[i] = listing.listTime;\r\n            startPrices[i] = listing.startPrice;\r\n            endPrices[i] = listing.endPrice;\r\n            priceChangeDurations[i] = listing.priceChangeDuration;\r\n        }\r\n        return (cardIds, cardOwners, listTimes, startPrices, endPrices, priceChangeDurations, cardDetails);\r\n    }\r\n    \r\n    function getListingAtPosition(uint64 i) external constant returns (uint128[5]) {\r\n        Listing memory listing = listings[listedCardIds[i]];\r\n        return ([listing.cardId, listing.listTime, listing.startPrice, listing.endPrice, listing.priceChangeDuration]);\r\n    }\r\n    \r\n    function getListing(uint64 cardId) external constant returns (uint128[5]) {\r\n        Listing memory listing = listings[cardId];\r\n        return ([listing.cardId, listing.listTime, listing.startPrice, listing.endPrice, listing.priceChangeDuration]);\r\n    }\r\n    \r\n    // Contracts can't list cards without contacting us (wallet addresses are unaffected)\r\n    function isWhitelisted(address seller) internal constant returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(seller) }\r\n        return size == 0 || whitelistedContracts[seller];\r\n    }\r\n    \r\n    function whitelistContract(address seller, bool whitelisted) external {\r\n        require(msg.sender == owner);\r\n        whitelistedContracts[seller] = whitelisted;\r\n    }\r\n    \r\n    function updateStorageContract(address newStorage) external {\r\n        require(msg.sender == owner);\r\n        storageContract = EtherGenCore(newStorage);\r\n    }\r\n    \r\n    function updateTransferRestrictionVerifier(address newTransferRestrictionVerifier) external {\r\n        require(msg.sender == owner);\r\n        transferRestrictionVerifier = TransferRestrictionVerifier(newTransferRestrictionVerifier);\r\n    }\r\n    \r\n    function setPaused(bool shouldPause) external {\r\n        require(msg.sender == owner);\r\n        paused = shouldPause;\r\n    }\r\n    \r\n    function updateOwner(address newOwner) external {\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function withdrawBalance() external {\r\n        require(msg.sender == owner);\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hasAlreadyClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradable\",\"type\":\"bool\"}],\"name\":\"setNewUserBonusCardTradable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"awardReferalBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newUserBonusCardTradable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCardConfig\",\"type\":\"address\"}],\"name\":\"upgradeCardConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStorage\",\"type\":\"address\"}],\"name\":\"updateStorageContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referer\",\"type\":\"address\"}],\"name\":\"claimFreeFirstCard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NewUserBonusDistributor","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4431adfa5a5a8e34afeb69f33c88d24d4989d943e76d88f8fdfcf20fb957a3b3"}]}