{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts\\configs\\FabricTokenConfig.sol\r\n\r\n/**\r\n * @title FabricTokenConfig\r\n *\r\n * @dev The static configuration for the Fabric Token.\r\n */\r\ncontract FabricTokenConfig {\r\n    // The name of the token.\r\n    string constant NAME = \"Fabric Token\";\r\n\r\n    // The symbol of the token.\r\n    string constant SYMBOL = \"FT\";\r\n\r\n    // The number of decimals for the token.\r\n    uint8 constant DECIMALS = 18;  // Same as ethers.\r\n\r\n    // Decimal factor for multiplication purposes.\r\n    uint constant DECIMALS_FACTOR = 10 ** uint(DECIMALS);\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC20TokenInterface.sol\r\n\r\n/**\r\n * @dev The standard ERC20 Token interface.\r\n */\r\ncontract ERC20TokenInterface {\r\n    uint public totalSupply;  /* shorthand for public function and a property */\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    function balanceOf(address _owner) public constant returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\n/**\r\n * @dev Library that helps prevent integer overflows and underflows,\r\n * inspired by https://github.com/OpenZeppelin/zeppelin-solidity\r\n */\r\nlibrary SafeMath {\r\n    function plus(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function minus(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        \r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\ERC20Token.sol\r\n\r\n/**\r\n * @title ERC20Token\r\n *\r\n * @dev Implements the operations declared in the `ERC20TokenInterface`.\r\n */\r\ncontract ERC20Token is ERC20TokenInterface {\r\n    using SafeMath for uint;\r\n\r\n    // Token account balances.\r\n    mapping (address => uint) balances;\r\n\r\n    // Delegated number of tokens to transfer.\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    /**\r\n     * @dev Checks the balance of a certain address.\r\n     *\r\n     * @param _account The address which's balance will be checked.\r\n     *\r\n     * @return Returns the balance of the `_account` address.\r\n     */\r\n    function balanceOf(address _account) public constant returns (uint balance) {\r\n        return balances[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from one address to another.\r\n     *\r\n     * @param _to The target address to which the `_value` number of tokens will be sent.\r\n     * @param _value The number of tokens to send.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        if (balances[msg.sender] < _value || _value == 0) {\r\n\r\n            return false;\r\n        }\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] = balances[_to].plus(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\r\n     *\r\n     * @param _from The address of the sender.\r\n     * @param _to The address of the recipient.\r\n     * @param _value The number of tokens to be transferred.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        if (balances[_from] < _value || allowed[_from][msg.sender] < _value || _value == 0) {\r\n            return false;\r\n        }\r\n\r\n        balances[_to] = balances[_to].plus(_value);\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows another contract to spend some tokens on your behalf.\r\n     *\r\n     * @param _spender The address of the account which will be approved for transfer of tokens.\r\n     * @param _value The number of tokens to be approved for transfer.\r\n     *\r\n     * @return Whether the approval was successful or not.\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Shows the number of tokens approved by `_owner` that are allowed to be transferred by `_spender`.\r\n     *\r\n     * @param _owner The account which allowed the transfer.\r\n     * @param _spender The account which will spend the tokens.\r\n     *\r\n     * @return The number of tokens to be transferred.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }    \r\n}\r\n\r\n// File: contracts\\traits\\HasOwner.sol\r\n\r\n/**\r\n * @title HasOwner\r\n *\r\n * @dev Allows for exclusive access to certain functionality.\r\n */\r\ncontract HasOwner {\r\n    // Current owner.\r\n    address public owner;\r\n\r\n    // Conditionally the new owner.\r\n    address public newOwner;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _owner The address of the owner.\r\n     */\r\n    function HasOwner(address _owner) internal {\r\n        owner = _owner;\r\n    }\r\n\r\n    /** \r\n     * @dev Access control modifier that allows only the current owner to call the function.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The event is fired when the current owner is changed.\r\n     *\r\n     * @param _oldOwner The address of the previous owner.\r\n     * @param _newOwner The address of the new owner.\r\n     */\r\n    event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);\r\n\r\n    /**\r\n     * @dev Transfering the ownership is a two-step process, as we prepare\r\n     * for the transfer by setting `newOwner` and requiring `newOwner` to accept\r\n     * the transfer. This prevents accidental lock-out if something goes wrong\r\n     * when passing the `newOwner` address.\r\n     *\r\n     * @param _newOwner The address of the proposed new owner.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n \r\n    /**\r\n     * @dev The `newOwner` finishes the ownership transfer process by accepting the\r\n     * ownership.\r\n     */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n\r\n        OwnershipTransfer(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\Freezable.sol\r\n\r\n/**\r\n * @title Freezable\r\n * @dev This trait allows to freeze the transactions in a Token\r\n */\r\ncontract Freezable is HasOwner {\r\n  bool public frozen = false;\r\n\r\n  /**\r\n   * @dev Modifier makes methods callable only when the contract is not frozen.\r\n   */\r\n  modifier requireNotFrozen() {\r\n    require(!frozen);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the owner to \"freeze\" the contract.\r\n   */\r\n  function freeze() onlyOwner public {\r\n    frozen = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the owner to \"unfreeze\" the contract.\r\n   */\r\n  function unfreeze() onlyOwner public {\r\n    frozen = false;\r\n  }\r\n}\r\n\r\n// File: contracts\\traits\\FreezableERC20Token.sol\r\n\r\n/**\r\n * @title FreezableERC20Token\r\n *\r\n * @dev Extends ERC20Token and adds ability to freeze all transfers of tokens.\r\n */\r\ncontract FreezableERC20Token is ERC20Token, Freezable {\r\n    /**\r\n     * @dev Overrides the original ERC20Token implementation by adding whenNotFrozen modifier.\r\n     *\r\n     * @param _to The target address to which the `_value` number of tokens will be sent.\r\n     * @param _value The number of tokens to send.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transfer(address _to, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\r\n     *\r\n     * @param _from The address of the sender.\r\n     * @param _to The address of the recipient.\r\n     * @param _value The number of tokens to be transferred.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows another contract to spend some tokens on your behalf.\r\n     *\r\n     * @param _spender The address of the account which will be approved for transfer of tokens.\r\n     * @param _value The number of tokens to be approved for transfer.\r\n     *\r\n     * @return Whether the approval was successful or not.\r\n     */\r\n    function approve(address _spender, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\FabricToken.sol\r\n\r\n/**\r\n * @title Fabric Token\r\n *\r\n * @dev A standard token implementation of the ERC20 token standard with added\r\n *      HasOwner trait and initialized using the configuration constants.\r\n */\r\ncontract FabricToken is FabricTokenConfig, HasOwner, FreezableERC20Token {\r\n    // The name of the token.\r\n    string public name;\r\n\r\n    // The symbol for the token.\r\n    string public symbol;\r\n\r\n    // The decimals of the token.\r\n    uint8 public decimals;\r\n\r\n    /**\r\n     * @dev The constructor. Initially sets `totalSupply` and the balance of the\r\n     *      `owner` address according to the initialization parameter.\r\n     */\r\n    function FabricToken(uint _totalSupply) public\r\n        HasOwner(msg.sender)\r\n    {\r\n        name = NAME;\r\n        symbol = SYMBOL;\r\n        decimals = DECIMALS;\r\n        totalSupply = _totalSupply;\r\n        balances[owner] = _totalSupply;\r\n    }\r\n}\r\n\r\n// File: contracts\\configs\\FabricTokenFundraiserConfig.sol\r\n\r\n/**\r\n * @title FabricTokenFundraiserConfig\r\n *\r\n * @dev The static configuration for the Fabric Token fundraiser.\r\n */\r\ncontract FabricTokenFundraiserConfig is FabricTokenConfig {\r\n    // The number of FT per 1 ETH.\r\n    uint constant CONVERSION_RATE = 9000;\r\n\r\n    // The public sale hard cap of the fundraiser.\r\n    uint constant TOKENS_HARD_CAP = 71250 * (10**3) * DECIMALS_FACTOR;\r\n\r\n    // The start date of the fundraiser: Thursday, 2018-02-15 10:00:00 UTC.\r\n    uint constant START_DATE = 1518688800;\r\n\r\n    // The end date of the fundraiser: Sunday, 2018-04-01 10:00:00 UTC (45 days after `START_DATE`).\r\n    uint constant END_DATE = 1522576800;\r\n    \r\n    // Total number of tokens locked for the FT core team.\r\n    uint constant TOKENS_LOCKED_CORE_TEAM = 12 * (10**6) * DECIMALS_FACTOR;\r\n\r\n    // Total number of tokens locked for FT advisors.\r\n    uint constant TOKENS_LOCKED_ADVISORS = 7 * (10**6) * DECIMALS_FACTOR;\r\n\r\n    // The release date for tokens locked for the FT core team.\r\n    uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = START_DATE + 1 years;\r\n\r\n    // The release date for tokens locked for FT advisors.\r\n    uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = START_DATE + 180 days;\r\n\r\n    // Total number of tokens locked for bounty program.\r\n    uint constant TOKENS_BOUNTY_PROGRAM = 1 * (10**6) * DECIMALS_FACTOR;\r\n\r\n    // Maximum gas price limit\r\n    uint constant MAX_GAS_PRICE = 50000000000 wei; // 50 gwei/shanon\r\n\r\n    // Minimum individual contribution\r\n    uint constant MIN_CONTRIBUTION =  0.1 ether;\r\n\r\n    // Individual limit in ether\r\n    uint constant INDIVIDUAL_ETHER_LIMIT =  9 ether;\r\n}\r\n\r\n// File: contracts\\traits\\TokenSafe.sol\r\n\r\n/**\r\n * @title TokenSafe\r\n *\r\n * @dev A multi-bundle token safe contract that contains locked tokens released after a date for the specific bundle type.\r\n */\r\ncontract TokenSafe {\r\n    using SafeMath for uint;\r\n\r\n    struct AccountsBundle {\r\n        // The total number of tokens locked.\r\n        uint lockedTokens;\r\n        // The release date for the locked tokens\r\n        // Note: Unix timestamp fits uint32, however block.timestamp is uint\r\n        uint releaseDate;\r\n        // The balances for the FT locked token accounts.\r\n        mapping (address => uint) balances;\r\n    }\r\n\r\n    // The account bundles of locked tokens grouped by release date\r\n    mapping (uint8 => AccountsBundle) public bundles;\r\n\r\n    // The `ERC20TokenInterface` contract.\r\n    ERC20TokenInterface token;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _token The address of the Fabric Token (fundraiser) contract.\r\n     */\r\n    function TokenSafe(address _token) public {\r\n        token = ERC20TokenInterface(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev The function initializes the bundle of accounts with a release date.\r\n     *\r\n     * @param _type Bundle type.\r\n     * @param _releaseDate Unix timestamp of the time after which the tokens can be released\r\n     */\r\n    function initBundle(uint8 _type, uint _releaseDate) internal {\r\n        bundles[_type].releaseDate = _releaseDate;\r\n    }\r\n\r\n    /**\r\n     * @dev Add new account with locked token balance to the specified bundle type.\r\n     *\r\n     * @param _type Bundle type.\r\n     * @param _account The address of the account to be added.\r\n     * @param _balance The number of tokens to be locked.\r\n     */\r\n    function addLockedAccount(uint8 _type, address _account, uint _balance) internal {\r\n        var bundle = bundles[_type];\r\n        bundle.balances[_account] = bundle.balances[_account].plus(_balance);\r\n        bundle.lockedTokens = bundle.lockedTokens.plus(_balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows an account to be released if it meets the time constraints.\r\n     *\r\n     * @param _type Bundle type.\r\n     * @param _account The address of the account to be released.\r\n     */\r\n    function releaseAccount(uint8 _type, address _account) internal {\r\n        var bundle = bundles[_type];\r\n        require(now >= bundle.releaseDate);\r\n        uint tokens = bundle.balances[_account];\r\n        require(tokens > 0);\r\n        bundle.balances[_account] = 0;\r\n        bundle.lockedTokens = bundle.lockedTokens.minus(tokens);\r\n        if (!token.transfer(_account, tokens)) {\r\n            revert();\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\FabricTokenSafe.sol\r\n\r\n/**\r\n * @title FabricTokenSafe\r\n *\r\n * @dev The Fabric Token safe containing all details about locked tokens.\r\n */\r\ncontract FabricTokenSafe is TokenSafe, FabricTokenFundraiserConfig {\r\n    // Bundle type constants\r\n    uint8 constant CORE_TEAM = 0;\r\n    uint8 constant ADVISORS = 1;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _token The address of the Fabric Token (fundraiser) contract.\r\n     */\r\n    function FabricTokenSafe(address _token) public\r\n        TokenSafe(_token)\r\n    {\r\n        token = ERC20TokenInterface(_token);\r\n\r\n        /// Core team.\r\n        initBundle(CORE_TEAM,\r\n            TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE\r\n        );\r\n\r\n        // Accounts with tokens locked for the FT core team.\r\n        addLockedAccount(CORE_TEAM, 0xB494096548aA049C066289A083204E923cBf4413, 4 * (10**6) * DECIMALS_FACTOR);\r\n        addLockedAccount(CORE_TEAM, 0xE3506B01Bee377829ee3CffD8bae650e990c5d68, 4 * (10**6) * DECIMALS_FACTOR);\r\n        addLockedAccount(CORE_TEAM, 0x3d13219dc1B8913E019BeCf0772C2a54318e5718, 4 * (10**6) * DECIMALS_FACTOR);\r\n\r\n        // Verify that the tokens add up to the constant in the configuration.\r\n        assert(bundles[CORE_TEAM].lockedTokens == TOKENS_LOCKED_CORE_TEAM);\r\n\r\n        /// Advisors.\r\n        initBundle(ADVISORS,\r\n            TOKENS_LOCKED_ADVISORS_RELEASE_DATE\r\n        );\r\n\r\n        // Accounts with FT tokens locked for advisors.\r\n        addLockedAccount(ADVISORS, 0x4647Da07dAAb17464278B988CDE59A4b911EBe44, 2 * (10**6) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0x3eA2caac5A0A4a55f9e304AcD09b3CEe6cD4Bc39, 1 * (10**6) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0xd5f791EC3ED79f79a401b12f7625E1a972382437, 1 * (10**6) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0xcaeae3CD1a5d3E6E950424C994e14348ac3Ec5dA, 1 * (10**6) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0xb6EA6193058F3c8A4A413d176891d173D62E00bE, 1 * (10**6) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0x8b3E184Cf5C3bFDaB1C4D0F30713D30314FcfF7c, 1 * (10**6) * DECIMALS_FACTOR);\r\n\r\n        // Verify that the tokens add up to the constant in the configuration.\r\n        assert(bundles[ADVISORS].lockedTokens == TOKENS_LOCKED_ADVISORS);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total locked tokens. This function is called by the fundraiser to determine number of tokens to create upon finalization.\r\n     *\r\n     * @return The current total number of locked Fabric Tokens.\r\n     */\r\n    function totalTokensLocked() public constant returns (uint) {\r\n        return bundles[CORE_TEAM].lockedTokens.plus(bundles[ADVISORS].lockedTokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows core team account FT tokens to be released.\r\n     */\r\n    function releaseCoreTeamAccount() public {\r\n        releaseAccount(CORE_TEAM, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows advisors account FT tokens to be released.\r\n     */\r\n    function releaseAdvisorsAccount() public {\r\n        releaseAccount(ADVISORS, msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\Whitelist.sol\r\n\r\ncontract Whitelist is HasOwner\r\n{\r\n    // Whitelist mapping\r\n    mapping(address => bool) public whitelist;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     */\r\n    function Whitelist(address _owner) public\r\n        HasOwner(_owner)\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Access control modifier that allows only whitelisted address to call the method.\r\n     */\r\n    modifier onlyWhitelisted {\r\n        require(whitelist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that sets whitelist status in batch.\r\n     *\r\n     * @param _entries An array with the entries to be updated\r\n     * @param _status The new status to apply\r\n     */\r\n    function setWhitelistEntries(address[] _entries, bool _status) internal {\r\n        for (uint32 i = 0; i < _entries.length; ++i) {\r\n            whitelist[_entries[i]] = _status;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Public function that allows the owner to whitelist multiple entries\r\n     *\r\n     * @param _entries An array with the entries to be whitelisted\r\n     */\r\n    function whitelistAddresses(address[] _entries) public onlyOwner {\r\n        setWhitelistEntries(_entries, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Public function that allows the owner to blacklist multiple entries\r\n     *\r\n     * @param _entries An array with the entries to be blacklist\r\n     */\r\n    function blacklistAddresses(address[] _entries) public onlyOwner {\r\n        setWhitelistEntries(_entries, false);\r\n    }\r\n}\r\n\r\n// File: contracts\\FabricTokenFundraiser.sol\r\n\r\n/**\r\n * @title FabricTokenFundraiser\r\n *\r\n * @dev The Fabric Token fundraiser contract.\r\n */\r\ncontract FabricTokenFundraiser is FabricToken, FabricTokenFundraiserConfig, Whitelist {\r\n    // Indicates whether the fundraiser has ended or not.\r\n    bool public finalized = false;\r\n\r\n    // The address of the account which will receive the funds gathered by the fundraiser.\r\n    address public beneficiary;\r\n\r\n    // The number of FT participants will receive per 1 ETH.\r\n    uint public conversionRate;\r\n\r\n    // Fundraiser start date.\r\n    uint public startDate;\r\n\r\n    // Fundraiser end date.\r\n    uint public endDate;\r\n\r\n    // Fundraiser tokens hard cap.\r\n    uint public hardCap;\r\n\r\n    // The `FabricTokenSafe` contract.\r\n    FabricTokenSafe public fabricTokenSafe;\r\n\r\n    // The minimum amount of ether allowed in the public sale\r\n    uint internal minimumContribution;\r\n\r\n    // The maximum amount of ether allowed per address\r\n    uint internal individualLimit;\r\n\r\n    // Number of tokens sold during the fundraiser.\r\n    uint private tokensSold;\r\n\r\n    // Indicates whether the tokens are claimed by the partners\r\n    bool private partnerTokensClaimed = false;\r\n\r\n    /**\r\n     * @dev The event fires every time a new buyer enters the fundraiser.\r\n     *\r\n     * @param _address The address of the buyer.\r\n     * @param _ethers The number of ethers sent.\r\n     * @param _tokens The number of tokens received by the buyer.\r\n     * @param _newTotalSupply The updated total number of tokens currently in circulation.\r\n     * @param _conversionRate The conversion rate at which the tokens were bought.\r\n     */\r\n    event FundsReceived(address indexed _address, uint _ethers, uint _tokens, uint _newTotalSupply, uint _conversionRate);\r\n\r\n    /**\r\n     * @dev The event fires when the beneficiary of the fundraiser is changed.\r\n     *\r\n     * @param _beneficiary The address of the new beneficiary.\r\n     */\r\n    event BeneficiaryChange(address _beneficiary);\r\n\r\n    /**\r\n     * @dev The event fires when the number of FT per 1 ETH is changed.\r\n     *\r\n     * @param _conversionRate The new number of FT per 1 ETH.\r\n     */\r\n    event ConversionRateChange(uint _conversionRate);\r\n\r\n    /**\r\n     * @dev The event fires when the fundraiser is successfully finalized.\r\n     *\r\n     * @param _beneficiary The address of the beneficiary.\r\n     * @param _ethers The number of ethers transfered to the beneficiary.\r\n     * @param _totalSupply The total number of tokens in circulation.\r\n     */\r\n    event Finalized(address _beneficiary, uint _ethers, uint _totalSupply);\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _beneficiary The address which will receive the funds gathered by the fundraiser.\r\n     */\r\n    function FabricTokenFundraiser(address _beneficiary) public\r\n        FabricToken(0)\r\n        Whitelist(msg.sender)\r\n    {\r\n        require(_beneficiary != 0);\r\n\r\n        beneficiary = _beneficiary;\r\n        conversionRate = CONVERSION_RATE;\r\n        startDate = START_DATE;\r\n        endDate = END_DATE;\r\n        hardCap = TOKENS_HARD_CAP;\r\n        tokensSold = 0;\r\n        minimumContribution = MIN_CONTRIBUTION;\r\n        individualLimit = INDIVIDUAL_ETHER_LIMIT * CONVERSION_RATE;\r\n\r\n        fabricTokenSafe = new FabricTokenSafe(this);\r\n\r\n        // Freeze the transfers for the duration of the fundraiser.\r\n        freeze();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the beneficiary of the fundraiser.\r\n     *\r\n     * @param _beneficiary The address of the new beneficiary.\r\n     */\r\n    function setBeneficiary(address _beneficiary) public onlyOwner {\r\n        require(_beneficiary != 0);\r\n\r\n        beneficiary = _beneficiary;\r\n\r\n        BeneficiaryChange(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets converstion rate of 1 ETH to FT. Can only be changed before the fundraiser starts.\r\n     *\r\n     * @param _conversionRate The new number of Fabric Tokens per 1 ETH.\r\n     */\r\n    function setConversionRate(uint _conversionRate) public onlyOwner {\r\n        require(now < startDate);\r\n        require(_conversionRate > 0);\r\n\r\n        conversionRate = _conversionRate;\r\n        individualLimit = INDIVIDUAL_ETHER_LIMIT * _conversionRate;\r\n\r\n        ConversionRateChange(_conversionRate);\r\n    }\r\n\r\n    /**\r\n     * @dev The default function which will fire every time someone sends ethers to this contract's address.\r\n     */\r\n    function() public payable {\r\n        buyTokens();\r\n    }\r\n\r\n    /**\r\n     * @dev Creates new tokens based on the number of ethers sent and the conversion rate.\r\n     */\r\n    function buyTokens() public payable onlyWhitelisted {\r\n        require(!finalized);\r\n        require(now >= startDate);\r\n        require(now <= endDate);\r\n        require(tx.gasprice <= MAX_GAS_PRICE);  // gas price limit\r\n        require(msg.value >= minimumContribution);  // required minimum contribution\r\n        require(tokensSold <= hardCap);\r\n\r\n        // Calculate the number of tokens the buyer will receive.\r\n        uint tokens = msg.value.mul(conversionRate);\r\n        balances[msg.sender] = balances[msg.sender].plus(tokens);\r\n\r\n        // Ensure that the individual contribution limit has not been reached\r\n        require(balances[msg.sender] <= individualLimit);\r\n\r\n        tokensSold = tokensSold.plus(tokens);\r\n        totalSupply = totalSupply.plus(tokens);\r\n\r\n        Transfer(0x0, msg.sender, tokens);\r\n\r\n        FundsReceived(\r\n            msg.sender,\r\n            msg.value, \r\n            tokens, \r\n            totalSupply, \r\n            conversionRate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Distributes the tokens allocated for the strategic partners.\r\n     */\r\n    function claimPartnerTokens() public {\r\n        require(!partnerTokensClaimed);\r\n        require(now >= startDate);\r\n\r\n        partnerTokensClaimed = true;\r\n\r\n        address partner1 = 0xA6556B9BD0AAbf0d8824374A3C425d315b09b832;\r\n        balances[partner1] = balances[partner1].plus(125 * (10**4) * DECIMALS_FACTOR);\r\n\r\n        address partner2 = 0x783A1cBc37a8ef2F368908490b72BfE801DA1877;\r\n        balances[partner2] = balances[partner2].plus(750 * (10**4) * DECIMALS_FACTOR);\r\n\r\n        totalSupply = totalSupply.plus(875 * (10**4) * DECIMALS_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize the fundraiser if `endDate` has passed or if `hardCap` is reached.\r\n     */\r\n    function finalize() public onlyOwner {\r\n        require((totalSupply >= hardCap) || (now >= endDate));\r\n        require(!finalized);\r\n\r\n        Finalized(beneficiary, this.balance, totalSupply);\r\n\r\n        /// Send the total number of ETH gathered to the beneficiary.\r\n        beneficiary.transfer(this.balance);\r\n\r\n        /// Allocate locked tokens to the `FabricTokenSafe` contract.\r\n        uint totalTokensLocked = fabricTokenSafe.totalTokensLocked();\r\n        balances[address(fabricTokenSafe)] = balances[address(fabricTokenSafe)].plus(totalTokensLocked);\r\n        totalSupply = totalSupply.plus(totalTokensLocked);\r\n\r\n        // Transfer the funds for the bounty program.\r\n        balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM);\r\n        totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM);\r\n\r\n        /// Finalize the fundraiser. Keep in mind that this cannot be undone.\r\n        finalized = true;\r\n\r\n        // Unfreeze transfers\r\n        unfreeze();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"claimPartnerTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entries\",\"type\":\"address[]\"}],\"name\":\"whitelistAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entries\",\"type\":\"address[]\"}],\"name\":\"blacklistAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"setConversionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fabricTokenSafe\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newTotalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"FundsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"ConversionRateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FabricTokenFundraiser","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000d15719e1d47bd37a39dcf30e3725777cf639241","Library":"","SwarmSource":"bzzr://87070590124402b774273f0f3df8450bcf26f6b6fbca17cc2fa63f9b48f6d05a"}]}