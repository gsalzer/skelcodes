{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    \r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    \r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n  \r\n}\r\n\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancy_lock);\r\n    reentrancy_lock = true;\r\n    _;\r\n    reentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n  \r\n}\r\n\r\n\r\n/// @dev Interface to the Core Contract of Ether Dungeon.\r\ncontract EDCoreInterface {\r\n\r\n    /// @dev The external function to get all the game settings in one call.\r\n    function getGameSettings() external view returns (\r\n        uint _recruitHeroFee,\r\n        uint _transportationFeeMultiplier,\r\n        uint _noviceDungeonId,\r\n        uint _consolationRewardsRequiredFaith,\r\n        uint _challengeFeeMultiplier,\r\n        uint _dungeonPreparationTime,\r\n        uint _trainingFeeMultiplier,\r\n        uint _equipmentTrainingFeeMultiplier,\r\n        uint _preparationPeriodTrainingFeeMultiplier,\r\n        uint _preparationPeriodEquipmentTrainingFeeMultiplier\r\n    );\r\n    \r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific player by its address.\r\n     * @param _address The address of the player.\r\n     */\r\n    function getPlayerDetails(address _address) external view returns (\r\n        uint dungeonId, \r\n        uint payment, \r\n        uint dungeonCount, \r\n        uint heroCount, \r\n        uint faith,\r\n        bool firstHeroRecruited\r\n    );\r\n    \r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific dungeon by its ID.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonDetails(uint _id) external view returns (\r\n        uint creationTime, \r\n        uint status, \r\n        uint difficulty, \r\n        uint capacity, \r\n        address owner, \r\n        bool isReady, \r\n        uint playerCount\r\n    );\r\n    \r\n    /**\r\n     * @dev Split floor related details out of getDungeonDetails, just to avoid Stack Too Deep error.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonFloorDetails(uint _id) external view returns (\r\n        uint floorNumber, \r\n        uint floorCreationTime, \r\n        uint rewards, \r\n        uint seedGenes, \r\n        uint floorGenes\r\n    );\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific hero by its ID.\r\n     * @param _id The ID of the hero.\r\n     */\r\n    function getHeroDetails(uint _id) external view returns (\r\n        uint creationTime, \r\n        uint cooldownStartTime, \r\n        uint cooldownIndex, \r\n        uint genes, \r\n        address owner, \r\n        bool isReady, \r\n        uint cooldownRemainingTime\r\n    );\r\n\r\n    /// @dev Get the attributes (equipments + stats) of a hero from its gene.\r\n    function getHeroAttributes(uint _genes) public pure returns (uint[]);\r\n    \r\n    /// @dev Calculate the power of a hero from its gene, it calculates the equipment power, stats power, and super hero boost.\r\n    function getHeroPower(uint _genes, uint _dungeonDifficulty) public pure returns (\r\n        uint totalPower, \r\n        uint equipmentPower, \r\n        uint statsPower, \r\n        bool isSuper, \r\n        uint superRank,\r\n        uint superBoost\r\n    );\r\n    \r\n    /// @dev Calculate the power of a dungeon floor.\r\n    function getDungeonPower(uint _genes) public pure returns (uint);\r\n    \r\n    /**\r\n     * @dev Calculate the sum of top 5 heroes power a player owns.\r\n     *  The gas usage increased with the number of heroes a player owned, roughly 500 x hero count.\r\n     *  This is used in transport function only to calculate the required tranport fee.\r\n     */\r\n    function calculateTop5HeroesPower(address _address, uint _dungeonId) public view returns (uint);\r\n    \r\n}\r\n\r\n\r\n/// @dev Core Contract of \"Enter the Coliseum\" game of the ED (Ether Dungeon) Platform.\r\ncontract EDColiseumAlpha is Pausable, ReentrancyGuard, Destructible {\r\n    \r\n    struct Participant {\r\n        address player;\r\n        uint heroId;\r\n        uint heroPower;\r\n    }\r\n    \r\n    /// @dev The address of the EtherDungeonCore contract.\r\n    EDCoreInterface public edCoreContract = EDCoreInterface(0xf7eD56c1AC4d038e367a987258b86FC883b960a1);\r\n    \r\n    /// @dev Seed for the random number generator used for calculating fighting result.\r\n    uint _seed;\r\n    \r\n    \r\n    /* ======== SETTINGS ======== */\r\n\r\n    /// @dev The required win count to win a jackpot.\r\n    uint public jackpotWinCount = 3;\r\n    \r\n    /// @dev The percentage of jackpot a player get when reaching the jackpotWinCount.\r\n    uint public jackpotWinPercent = 50;\r\n    \r\n    /// @dev The percentage of rewards a player get when being the final winner of a tournament.\r\n    uint public winPercent = 55;\r\n    \r\n    /// @dev The percentage of rewards a player get when being the final loser of a tournament, remaining will add to tournamentJackpot.\r\n    uint public losePercent = 35;\r\n    \r\n    /// @dev Dungeon difficulty to be used when calculating super hero power boost, 1 is no boost.\r\n    uint public dungeonDifficulty = 1;\r\n\r\n    /// @dev The required fee to join a participant\r\n    uint public participationFee = 0.02 ether;\r\n    \r\n    /// @dev The maximum number of participants for a tournament.\r\n    uint public constant maxParticipantCount = 8;\r\n    \r\n    \r\n    /* ======== STATE VARIABLES ======== */\r\n    \r\n    /// @dev The next tournaments round number.\r\n    uint public nextTournamentRound = 1;\r\n\r\n    /// @dev The current accumulated rewards pool.\r\n    uint public tournamentRewards;\r\n\r\n    /// @dev The current accumulated jackpot.\r\n    uint public tournamentJackpot = 0.2 ether;\r\n    \r\n    /// @dev Array of all the participant for next tournament.\r\n    Participant[] public participants;\r\n    \r\n    /// @dev Array of all the participant for the previous tournament.\r\n    Participant[] public previousParticipants;\r\n    \r\n    /// @dev Array to store the participant index all winners / losers for each \"fighting round\" of the previous tournament.\r\n    uint[maxParticipantCount / 2] public firstRoundWinners;\r\n    uint[maxParticipantCount / 4] public secondRoundWinners;\r\n    uint[maxParticipantCount / 2] public firstRoundLosers;\r\n    uint[maxParticipantCount / 4] public secondRoundLosers;\r\n    uint public finalWinner;\r\n    uint public finalLoser;\r\n    \r\n    /// @dev Mapping of hero ID to the hero's last participated tournament round to avoid repeated hero participation.\r\n    mapping(uint => uint) public heroIdToLastRound;\r\n    \r\n    /// @dev Mapping of player ID to the consecutive win counts, used for calculating jackpot.\r\n    mapping(address => uint) public playerToWinCounts;\r\n\r\n    \r\n    /* ======== EVENTS ======== */\r\n    \r\n    /// @dev The PlayerTransported event is fired when user transported to another dungeon.\r\n    event TournamentFinished(uint timestamp, uint tournamentRound, address finalWinner, address finalLoser, uint winnerRewards, uint loserRewards, uint winCount, uint jackpotRewards);\r\n    \r\n    /// @dev Payable constructor to pass in the initial jackpot ethers.\r\n    function EDColiseum() public payable {}\r\n\r\n    \r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n    \r\n    /// @dev The external function to get all the game settings in one call.\r\n    function getGameSettings() external view returns (\r\n        uint _jackpotWinCount,\r\n        uint _jackpotWinPercent,\r\n        uint _winPercent,\r\n        uint _losePercent,\r\n        uint _dungeonDifficulty,\r\n        uint _participationFee,\r\n        uint _maxParticipantCount\r\n    ) {\r\n        _jackpotWinCount = jackpotWinCount;\r\n        _jackpotWinPercent = jackpotWinPercent;\r\n        _winPercent = winPercent;\r\n        _losePercent = losePercent;\r\n        _dungeonDifficulty = dungeonDifficulty;\r\n        _participationFee = participationFee;\r\n        _maxParticipantCount = maxParticipantCount;\r\n    }\r\n    \r\n    /// @dev The external function to get all the game settings in one call.\r\n    function getNextTournamentData() external view returns (\r\n        uint _nextTournamentRound,\r\n        uint _tournamentRewards,\r\n        uint _tournamentJackpot,\r\n        uint _participantCount\r\n    ) {\r\n        _nextTournamentRound = nextTournamentRound;\r\n        _tournamentRewards = tournamentRewards;\r\n        _tournamentJackpot = tournamentJackpot;\r\n        _participantCount = participants.length;\r\n    }\r\n    \r\n    /// @dev The external function to call when joining the next tournament.\r\n    function joinTournament(uint _heroId) whenNotPaused nonReentrant external payable {\r\n        uint genes;\r\n        address owner;\r\n        (,,, genes, owner,,) = edCoreContract.getHeroDetails(_heroId);\r\n        \r\n        // Throws if the hero is not owned by the sender.\r\n        require(msg.sender == owner);\r\n        \r\n        // Throws if the hero is already participated in the next tournament.\r\n        require(heroIdToLastRound[_heroId] != nextTournamentRound);\r\n        \r\n        // Throws if participation count is full.\r\n        require(participants.length < maxParticipantCount);\r\n        \r\n        // Throws if payment not enough, any exceeding funds will be transferred back to the player.\r\n        require(msg.value >= participationFee);\r\n        tournamentRewards += participationFee;\r\n\r\n        if (msg.value > participationFee) {\r\n            msg.sender.transfer(msg.value - participationFee);\r\n        }\r\n        \r\n        // Set the hero participation round.\r\n        heroIdToLastRound[_heroId] = nextTournamentRound;\r\n        \r\n        // Get the hero power and set it to storage.\r\n        uint heroPower;\r\n        (heroPower,,,,) = edCoreContract.getHeroPower(genes, dungeonDifficulty);\r\n        \r\n        // Throw if heroPower is 12 (novice hero).\r\n        require(heroPower > 12);\r\n        \r\n        // Set the participant data to storage.\r\n        participants.push(Participant(msg.sender, _heroId, heroPower));\r\n    }\r\n    \r\n    /// @dev The onlyOwner external function to call when joining the next tournament.\r\n    function startTournament() onlyOwner nonReentrant external {\r\n        // Throws if participation count is not full.\r\n        require(participants.length == maxParticipantCount);\r\n        \r\n        // FIGHT!\r\n        _firstRoundFight();\r\n        _secondRoundWinnersFight();\r\n        _secondRoundLosersFight();\r\n        _finalRoundWinnersFight();\r\n        _finalRoundLosersFight();\r\n        \r\n        // REWARDS!\r\n        uint winnerRewards = tournamentRewards * winPercent / 100;\r\n        uint loserRewards = tournamentRewards * losePercent / 100;\r\n        uint addToJackpot = tournamentRewards - winnerRewards - loserRewards;\r\n        \r\n        address winner = participants[finalWinner].player;\r\n        address loser = participants[finalLoser].player;\r\n        winner.transfer(winnerRewards);\r\n        loser.transfer(loserRewards);\r\n        tournamentJackpot += addToJackpot;\r\n        \r\n        // JACKPOT!\r\n        playerToWinCounts[winner]++;\r\n        \r\n        // Reset other participants' consecutive winCount.\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address participant = participants[i].player;\r\n            \r\n            if (participant != winner && playerToWinCounts[participant] != 0) {\r\n                playerToWinCounts[participant] = 0;\r\n            }\r\n        }\r\n        \r\n        // Detemine if the winner have enough consecutive winnings for jackpot.\r\n        uint jackpotRewards;\r\n        uint winCount = playerToWinCounts[winner];\r\n        if (winCount == jackpotWinCount) {\r\n            // Reset consecutive winCount of winner.\r\n            playerToWinCounts[winner] = 0;\r\n            \r\n            jackpotRewards = tournamentJackpot * jackpotWinPercent / 100;\r\n            tournamentJackpot -= jackpotRewards;\r\n            \r\n            winner.transfer(jackpotRewards);\r\n        }\r\n        \r\n        // Reset tournament data and increment round.\r\n        tournamentRewards = 0;\r\n        previousParticipants = participants;\r\n        participants.length = 0;\r\n        nextTournamentRound++;\r\n        \r\n        // Emit TournamentFinished event.\r\n        TournamentFinished(now, nextTournamentRound - 1, winner, loser, winnerRewards, loserRewards, winCount, jackpotRewards);\r\n    }\r\n    \r\n    /// @dev The onlyOwner external function to call to cancel the next tournament and refunds.\r\n    function cancelTournament() onlyOwner nonReentrant external {\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address participant = participants[i].player;\r\n            \r\n            if (participant != 0x0) {\r\n                participant.transfer(participationFee);\r\n            }\r\n        }\r\n        \r\n        // Reset tournament data and increment round.\r\n        tournamentRewards = 0;\r\n        participants.length = 0;\r\n        nextTournamentRound++;\r\n    }\r\n    \r\n    /// @dev Withdraw all Ether from the contract.\r\n    function withdrawBalance() onlyOwner external {\r\n        // Can only withdraw if no participants joined (i.e. call cancelTournament first.)\r\n        require(participants.length == 0);\r\n        \r\n        msg.sender.transfer(this.balance);\r\n    }\r\n\r\n    /* ======== SETTER FUNCTIONS ======== */\r\n    \r\n    function setEdCoreContract(address _newEdCoreContract) onlyOwner external {\r\n        edCoreContract = EDCoreInterface(_newEdCoreContract);\r\n    }\r\n    \r\n    function setJackpotWinCount(uint _newJackpotWinCount) onlyOwner external {\r\n        jackpotWinCount = _newJackpotWinCount;\r\n    }\r\n    \r\n    function setJackpotWinPercent(uint _newJackpotWinPercent) onlyOwner external {\r\n        jackpotWinPercent = _newJackpotWinPercent;\r\n    }\r\n    \r\n    function setWinPercent(uint _newWinPercent) onlyOwner external {\r\n        winPercent = _newWinPercent;\r\n    }\r\n    \r\n    function setLosePercent(uint _newLosePercent) onlyOwner external {\r\n        losePercent = _newLosePercent;\r\n    }\r\n    \r\n    function setDungeonDifficulty(uint _newDungeonDifficulty) onlyOwner external {\r\n        dungeonDifficulty = _newDungeonDifficulty;\r\n    }\r\n    \r\n    function setParticipationFee(uint _newParticipationFee) onlyOwner external {\r\n        participationFee = _newParticipationFee;\r\n    }\r\n    \r\n    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\r\n    \r\n    /// @dev Compute all winners and losers for the first round.\r\n    function _firstRoundFight() private {\r\n        // Get all hero powers.\r\n        uint heroPower0 = participants[0].heroPower;\r\n        uint heroPower1 = participants[1].heroPower;\r\n        uint heroPower2 = participants[2].heroPower;\r\n        uint heroPower3 = participants[3].heroPower;\r\n        uint heroPower4 = participants[4].heroPower;\r\n        uint heroPower5 = participants[5].heroPower;\r\n        uint heroPower6 = participants[6].heroPower;\r\n        uint heroPower7 = participants[7].heroPower;\r\n        \r\n        // Random number.\r\n        uint rand;\r\n        \r\n        // 0 Vs 1\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower0 > heroPower1 && rand < 60) || \r\n            (heroPower0 == heroPower1 && rand < 50) ||\r\n            (heroPower0 < heroPower1 && rand < 40)\r\n        ) {\r\n            firstRoundWinners[0] = 0;\r\n            firstRoundLosers[0] = 1;\r\n        } else {\r\n            firstRoundWinners[0] = 1;\r\n            firstRoundLosers[0] = 0;\r\n        }\r\n        \r\n        // 2 Vs 3\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower2 > heroPower3 && rand < 60) || \r\n            (heroPower2 == heroPower3 && rand < 50) ||\r\n            (heroPower2 < heroPower3 && rand < 40)\r\n        ) {\r\n            firstRoundWinners[1] = 2;\r\n            firstRoundLosers[1] = 3;\r\n        } else {\r\n            firstRoundWinners[1] = 3;\r\n            firstRoundLosers[1] = 2;\r\n        }\r\n        \r\n        // 4 Vs 5\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower4 > heroPower5 && rand < 60) || \r\n            (heroPower4 == heroPower5 && rand < 50) ||\r\n            (heroPower4 < heroPower5 && rand < 40)\r\n        ) {\r\n            firstRoundWinners[2] = 4;\r\n            firstRoundLosers[2] = 5;\r\n        } else {\r\n            firstRoundWinners[2] = 5;\r\n            firstRoundLosers[2] = 4;\r\n        }\r\n        \r\n        // 6 Vs 7\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower6 > heroPower7 && rand < 60) || \r\n            (heroPower6 == heroPower7 && rand < 50) ||\r\n            (heroPower6 < heroPower7 && rand < 40)\r\n        ) {\r\n            firstRoundWinners[3] = 6;\r\n            firstRoundLosers[3] = 7;\r\n        } else {\r\n            firstRoundWinners[3] = 7;\r\n            firstRoundLosers[3] = 6;\r\n        }\r\n    }\r\n    \r\n    /// @dev Compute all second winners of all first round winners.\r\n    function _secondRoundWinnersFight() private {\r\n        // Get all hero powers of all first round winners.\r\n        uint winner0 = firstRoundWinners[0];\r\n        uint winner1 = firstRoundWinners[1];\r\n        uint winner2 = firstRoundWinners[2];\r\n        uint winner3 = firstRoundWinners[3];\r\n        uint heroPower0 = participants[winner0].heroPower;\r\n        uint heroPower1 = participants[winner1].heroPower;\r\n        uint heroPower2 = participants[winner2].heroPower;\r\n        uint heroPower3 = participants[winner3].heroPower;\r\n        \r\n        // Random number.\r\n        uint rand;\r\n        \r\n        // 0 Vs 1\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower0 > heroPower1 && rand < 60) || \r\n            (heroPower0 == heroPower1 && rand < 50) ||\r\n            (heroPower0 < heroPower1 && rand < 40)\r\n        ) {\r\n            secondRoundWinners[0] = winner0;\r\n        } else {\r\n            secondRoundWinners[0] = winner1;\r\n        }\r\n        \r\n        // 2 Vs 3\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower2 > heroPower3 && rand < 60) || \r\n            (heroPower2 == heroPower3 && rand < 50) ||\r\n            (heroPower2 < heroPower3 && rand < 40)\r\n        ) {\r\n            secondRoundWinners[1] = winner2;\r\n        } else {\r\n            secondRoundWinners[1] = winner3;\r\n        }\r\n    }\r\n    \r\n    /// @dev Compute all second losers of all first round losers.\r\n    function _secondRoundLosersFight() private {\r\n        // Get all hero powers of all first round losers.\r\n        uint loser0 = firstRoundLosers[0];\r\n        uint loser1 = firstRoundLosers[1];\r\n        uint loser2 = firstRoundLosers[2];\r\n        uint loser3 = firstRoundLosers[3];\r\n        uint heroPower0 = participants[loser0].heroPower;\r\n        uint heroPower1 = participants[loser1].heroPower;\r\n        uint heroPower2 = participants[loser2].heroPower;\r\n        uint heroPower3 = participants[loser3].heroPower;\r\n        \r\n        // Random number.\r\n        uint rand;\r\n        \r\n        // 0 Vs 1\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower0 > heroPower1 && rand < 60) || \r\n            (heroPower0 == heroPower1 && rand < 50) ||\r\n            (heroPower0 < heroPower1 && rand < 40)\r\n        ) {\r\n            secondRoundLosers[0] = loser1;\r\n        } else {\r\n            secondRoundLosers[0] = loser0;\r\n        }\r\n        \r\n        // 2 Vs 3\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower2 > heroPower3 && rand < 60) || \r\n            (heroPower2 == heroPower3 && rand < 50) ||\r\n            (heroPower2 < heroPower3 && rand < 40)\r\n        ) {\r\n            secondRoundLosers[1] = loser3;\r\n        } else {\r\n            secondRoundLosers[1] = loser2;\r\n        }\r\n    }\r\n    \r\n    /// @dev Compute the final winner.\r\n    function _finalRoundWinnersFight() private {\r\n        // Get all hero powers of all first round winners.\r\n        uint winner0 = secondRoundWinners[0];\r\n        uint winner1 = secondRoundWinners[1];\r\n        uint heroPower0 = participants[winner0].heroPower;\r\n        uint heroPower1 = participants[winner1].heroPower;\r\n        \r\n        // Random number.\r\n        uint rand;\r\n        \r\n        // 0 Vs 1\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower0 > heroPower1 && rand < 60) || \r\n            (heroPower0 == heroPower1 && rand < 50) ||\r\n            (heroPower0 < heroPower1 && rand < 40)\r\n        ) {\r\n            finalWinner = winner0;\r\n        } else {\r\n            finalWinner = winner1;\r\n        }\r\n    }\r\n    \r\n    /// @dev Compute the final loser.\r\n    function _finalRoundLosersFight() private {\r\n        // Get all hero powers of all first round winners.\r\n        uint loser0 = secondRoundLosers[0];\r\n        uint loser1 = secondRoundLosers[1];\r\n        uint heroPower0 = participants[loser0].heroPower;\r\n        uint heroPower1 = participants[loser1].heroPower;\r\n        \r\n        // Random number.\r\n        uint rand;\r\n        \r\n        // 0 Vs 1\r\n        rand = _getRandomNumber(100);\r\n        if (\r\n            (heroPower0 > heroPower1 && rand < 60) || \r\n            (heroPower0 == heroPower1 && rand < 50) ||\r\n            (heroPower0 < heroPower1 && rand < 40)\r\n        ) {\r\n            finalLoser = loser1;\r\n        } else {\r\n            finalLoser = loser0;\r\n        }\r\n    }\r\n    \r\n    // @dev Return a pseudo random uint smaller than lower bounds.\r\n    function _getRandomNumber(uint _upper) private returns (uint) {\r\n        _seed = uint(keccak256(\r\n            _seed,\r\n            block.blockhash(block.number - 1),\r\n            block.coinbase,\r\n            block.difficulty\r\n        ));\r\n        \r\n        return _seed % _upper;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newWinPercent\",\"type\":\"uint256\"}],\"name\":\"setWinPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"secondRoundLosers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalLoser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dungeonDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"edCoreContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"heroId\",\"type\":\"uint256\"},{\"name\":\"heroPower\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameSettings\",\"outputs\":[{\"name\":\"_jackpotWinCount\",\"type\":\"uint256\"},{\"name\":\"_jackpotWinPercent\",\"type\":\"uint256\"},{\"name\":\"_winPercent\",\"type\":\"uint256\"},{\"name\":\"_losePercent\",\"type\":\"uint256\"},{\"name\":\"_dungeonDifficulty\",\"type\":\"uint256\"},{\"name\":\"_participationFee\",\"type\":\"uint256\"},{\"name\":\"_maxParticipantCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"firstRoundLosers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"heroIdToLastRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextTournamentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotWinCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"losePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"EDColiseum\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDungeonDifficulty\",\"type\":\"uint256\"}],\"name\":\"setDungeonDifficulty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newJackpotWinPercent\",\"type\":\"uint256\"}],\"name\":\"setJackpotWinPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextTournamentData\",\"outputs\":[{\"name\":\"_nextTournamentRound\",\"type\":\"uint256\"},{\"name\":\"_tournamentRewards\",\"type\":\"uint256\"},{\"name\":\"_tournamentJackpot\",\"type\":\"uint256\"},{\"name\":\"_participantCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participationFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"firstRoundWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournamentRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLosePercent\",\"type\":\"uint256\"}],\"name\":\"setLosePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxParticipantCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newParticipationFee\",\"type\":\"uint256\"}],\"name\":\"setParticipationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEdCoreContract\",\"type\":\"address\"}],\"name\":\"setEdCoreContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerToWinCounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"joinTournament\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"secondRoundWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"previousParticipants\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"heroId\",\"type\":\"uint256\"},{\"name\":\"heroPower\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotWinPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newJackpotWinCount\",\"type\":\"uint256\"}],\"name\":\"setJackpotWinCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tournamentRound\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finalWinner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"finalLoser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"loserRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"jackpotRewards\",\"type\":\"uint256\"}],\"name\":\"TournamentFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EDColiseumAlpha","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://71f5bdc27c2dd1030c41676c7bf01c77845e1c51b9a7969c6a2dc4d6294de3b7"}]}