{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title Interface to communicate with ICO token contract\r\n */\r\n // FRACTAL PRE REALEASE \"IOU\" TOKEN - FPRT \r\n \r\ncontract IToken {\r\n   \r\n  function balanceOf(address _address) constant returns (uint balance);\r\n  function transferFromOwner(address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\n/**\r\n * @title Presale token contract\r\n */\r\ncontract TokenEscrow {\r\n\t// Token-related properties/description to display in Wallet client / UI\r\n\tstring public standard = 'FractalPreRelease 1.0';\r\n\tstring public name = 'FractalPreReleaseToken';\r\n\tstring public symbol = 'FPRT';\r\n\tuint public decimals = 4;\r\n    uint public totalSupply = 50000000000;\r\n   \r\n\t\r\n\tIToken icoToken;\r\n\t\r\n\tevent Converted(address indexed from, uint256 value); // Event to inform about the fact of token burning/destroying\r\n    \tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Error(bytes32 error);\r\n\t\r\n\tmapping (address => uint) balanceFor; // Presale token balance for each of holders\r\n\t\r\n\taddress owner;  // Contract owner\r\n\t\r\n\tuint public exchangeRate; // preICO -> ICO token exchange rate\r\n\r\n\t// Token supply and discount policy structure\r\n\tstruct TokenSupply {\r\n\t\tuint limit;                 // Total amount of tokens\r\n\t\tuint totalSupply;           // Current amount of sold tokens\r\n\t\tuint tokenPriceInWei;  // Number of token per 1 Eth\r\n\t\t\r\n\t}\r\n\t\r\n\tTokenSupply[3] public tokenSupplies;\r\n\r\n\t// Modifiers\r\n\tmodifier owneronly { if (msg.sender == owner) _; }\r\n\r\n\t/**\r\n\t * @dev Set/change contract owner\r\n\t * @param _owner owner address\r\n\t */\r\n\tfunction setOwner(address _owner) owneronly {\r\n\t\towner = _owner;\r\n\t}\r\n\t\r\n\tfunction setRate(uint _exchangeRate) owneronly {\r\n\t\texchangeRate = _exchangeRate;\r\n\t}\r\n\t\r\n\tfunction setToken(address _icoToken) owneronly {\r\n\t\ticoToken = IToken(_icoToken);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Returns balance/token quanity owned by address\r\n\t * @param _address Account address to get balance for\r\n\t * @return balance value / token quantity\r\n\t */\r\n\tfunction balanceOf(address _address) constant returns (uint balance) {\r\n\t\treturn balanceFor[_address];\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Transfers tokens from caller/method invoker/message sender to specified recipient\r\n\t * @param _to Recipient address\r\n\t * @param _value Token quantity to transfer\r\n\t * @return success/failure of transfer\r\n\t */\t\r\n\tfunction transfer(address _to, uint _value) returns (bool success) {\r\n\t\tif(_to != owner) {\r\n\t\t\tif (balanceFor[msg.sender] < _value) return false;           // Check if the sender has enough\r\n\t\t\tif (balanceFor[_to] + _value < balanceFor[_to]) return false; // Check for overflows\r\n\t\t\tif (msg.sender == owner) {\r\n\t\t\t\ttransferByOwner(_value);\r\n\t\t\t}\r\n\t\t\tbalanceFor[msg.sender] -= _value;                     // Subtract from the sender\r\n\t\t\tbalanceFor[_to] += _value;                            // Add the same to the recipient\r\n\t\t\tTransfer(owner,_to,_value);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tfunction transferByOwner(uint _value) private {\r\n\t\tfor (uint discountIndex = 0; discountIndex < tokenSupplies.length; discountIndex++) {\r\n\t\t\tTokenSupply storage tokenSupply = tokenSupplies[discountIndex];\r\n\t\t\tif(tokenSupply.totalSupply < tokenSupply.limit) {\r\n\t\t\t\tif (tokenSupply.totalSupply + _value > tokenSupply.limit) {\r\n\t\t\t\t\t_value -= tokenSupply.limit - tokenSupply.totalSupply;\r\n\t\t\t\t\ttokenSupply.totalSupply = tokenSupply.limit;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokenSupply.totalSupply += _value;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Burns/destroys specified amount of Presale tokens for caller/method invoker/message sender\r\n\t * @return success/failure of transfer\r\n\t */\t\r\n\tfunction convert() returns (bool success) {\r\n\t\tif (balanceFor[msg.sender] == 0) return false;            // Check if the sender has enough\r\n\t\tif (!exchangeToIco(msg.sender)) return false; // Try to exchange preICO tokens to ICO tokens\r\n\t\tConverted(msg.sender, balanceFor[msg.sender]);\r\n\t\tbalanceFor[msg.sender] = 0;                      // Subtract from the sender\r\n\t\treturn true;\r\n\t} \r\n\t\r\n\t/**\r\n\t * @dev Converts/exchanges sold Presale tokens to ICO ones according to provided exchange rate\r\n\t * @param owner address\r\n\t\t */\r\n\tfunction exchangeToIco(address owner) private returns (bool) {\r\n\t    if(icoToken != address(0)) {\r\n\t\t    return icoToken.transferFromOwner(owner, balanceFor[owner] * exchangeRate);\r\n\t    }\r\n\t    return false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Presale contract constructor\r\n\t */\r\n\tfunction TokenEscrow() {\r\n\t\towner = msg.sender;\r\n\t\t\r\n\t\tbalanceFor[msg.sender] = 50000000000; // Give the creator all initial tokens\r\n\t\t\r\n\t\t// Discount policy\r\n\t\ttokenSupplies[0] = TokenSupply(10000000000, 0, 50000000000); // First million of tokens will go 2000 tokens for 1 eth\r\n\t\ttokenSupplies[1] = TokenSupply(20000000000, 0, 50000000000); // Following Two millions of tokens will go 2000 tokens for 1 eth\r\n\t\ttokenSupplies[2] = TokenSupply(20000000000, 0, 50000000000); // Two last millions of tokens will go 2000 tokens for 1 eth\r\n\t    \r\n}\r\n\r\n\r\n\t// Incoming transfer from the Presale token buyer\r\n\tfunction() payable {\r\n\t\t\r\n\t\tuint tokenAmount; // Amount of tokens which is possible to buy for incoming transfer/payment\r\n\t\tuint amountToBePaid; // Amount to be paid\r\n\t\tuint amountTransfered = msg.value; // Cost/price in WEI of incoming transfer/payment\r\n\t\t\r\n\t\t\r\n\t\tif (amountTransfered <= 0) {\r\n\t\t      \tError('no eth was transfered');\r\n              \t\tmsg.sender.transfer(msg.value);\r\n\t\t  \treturn;\r\n\t\t}\r\n\r\n\t\tif(balanceFor[owner] <= 0) {\r\n\t\t      \tError('all tokens sold');\r\n              \t\tmsg.sender.transfer(msg.value);\r\n\t\t      \treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// Determine amount of tokens can be bought according to available supply and discount policy\r\n\t\tfor (uint discountIndex = 0; discountIndex < tokenSupplies.length; discountIndex++) {\r\n\t\t\t// If it's not possible to buy any tokens at all skip the rest of discount policy\r\n\t\t\t\r\n\t\t\tTokenSupply storage tokenSupply = tokenSupplies[discountIndex];\r\n\t\t\t\r\n\t\t\tif(tokenSupply.totalSupply < tokenSupply.limit) {\r\n\t\t\t\r\n\t\t\t\tuint tokensPossibleToBuy = amountTransfered / tokenSupply.tokenPriceInWei;\r\n\r\n                if (tokensPossibleToBuy > balanceFor[owner]) \r\n                    tokensPossibleToBuy = balanceFor[owner];\r\n\r\n\t\t\t\tif (tokenSupply.totalSupply + tokensPossibleToBuy > tokenSupply.limit) {\r\n\t\t\t\t\ttokensPossibleToBuy = tokenSupply.limit - tokenSupply.totalSupply;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttokenSupply.totalSupply += tokensPossibleToBuy;\r\n\t\t\t\ttokenAmount += tokensPossibleToBuy;\r\n\r\n\t\t\t\tuint delta = tokensPossibleToBuy * tokenSupply.tokenPriceInWei;\r\n\r\n\t\t\t\tamountToBePaid += delta;\r\n                \t\tamountTransfered -= delta;\r\n\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Do not waste gas if there is no tokens to buy\r\n\t\tif (tokenAmount == 0) {\r\n\t\t    \tError('no token to buy');\r\n            \t\tmsg.sender.transfer(msg.value);\r\n\t\t\treturn;\r\n        \t}\r\n\t\t\r\n\t\t// Transfer tokens to buyer\r\n\t\ttransferFromOwner(msg.sender, tokenAmount);\r\n\r\n\t\t// Transfer money to seller\r\n\t\towner.transfer(amountToBePaid);\r\n\t\t\r\n\t\t// Refund buyer if overpaid / no tokens to sell\r\n\t\tmsg.sender.transfer(msg.value - amountToBePaid);\r\n\t\t\r\n\t}\r\n  \r\n\t/**\r\n\t * @dev Removes/deletes contract\r\n\t */\r\n\tfunction kill() owneronly {\r\n\t\tselfdestruct(msg.sender);\r\n\t}\r\n\t\r\n  \r\n\t/**\r\n\t * @dev Transfers tokens from owner to specified recipient\r\n\t * @param _to Recipient address\r\n\t * @param _value Token quantity to transfer\r\n\t * @return success/failure of transfer\r\n\t */\r\n\tfunction transferFromOwner(address _to, uint256 _value) private returns (bool success) {\r\n\t\tif (balanceFor[owner] < _value) return false;                 // Check if the owner has enough\r\n\t\tif (balanceFor[_to] + _value < balanceFor[_to]) return false;  // Check for overflows\r\n\t\tbalanceFor[owner] -= _value;                          // Subtract from the owner\r\n\t\tbalanceFor[_to] += _value;                            // Add the same to the recipient\r\n        \tTransfer(owner,_to,_value);\r\n\t\treturn true;\r\n\t}\r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoToken\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"convert\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenSupplies\",\"outputs\":[{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"tokenPriceInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Converted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"error\",\"type\":\"bytes32\"}],\"name\":\"Error\",\"type\":\"event\"}]","ContractName":"TokenEscrow","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b82f9f8bad0d0a9628a115e5205dade475b5e4a12a47a75e40513508d8d5ab7c"}]}