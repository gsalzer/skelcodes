{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/libs/ERC20.sol\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external  view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external  returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/libs/utils.sol\r\n\r\nlibrary Utils {\r\n\r\n    uint  constant PRECISION = (10**18);\r\n    uint  constant MAX_DECIMALS = 18;\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        if( dstDecimals >= srcDecimals ) {\r\n            require((dstDecimals-srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals-srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals-dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals-dstDecimals)));\r\n        }\r\n    }\r\n\r\n    // function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n    //     if( srcDecimals >= dstDecimals ) {\r\n    //         require((srcDecimals-dstDecimals) <= MAX_DECIMALS);\r\n    //         return (PRECISION * dstQty * (10**(srcDecimals - dstDecimals))) / rate;\r\n    //     } else {\r\n    //         require((dstDecimals-srcDecimals) <= MAX_DECIMALS);\r\n    //         return (PRECISION * dstQty) / (rate * (10**(dstDecimals - srcDecimals)));\r\n    //     }\r\n    // }\r\n}\r\n\r\n// File: contracts/libs/Manageable.sol\r\n\r\ncontract Manageable {\r\n    event ProviderUpdated (uint8 name, address hash);\r\n\r\n    // This is used to hold the addresses of the providers\r\n    mapping (uint8 => address) public subContracts;\r\n    modifier onlyOwner() {\r\n        // Make sure that this function can't be used without being overridden\r\n        require(true == false);\r\n        _;\r\n    }\r\n\r\n    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\r\n        require(_providerAddress != address(0));\r\n        subContracts[_id] = _providerAddress;\r\n        emit ProviderUpdated(_id, _providerAddress);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/Provider.sol\r\n\r\nlibrary TypeDefinitions {\r\n\r\n    enum ProviderType {\r\n        Strategy,\r\n        Price,\r\n        Exchange,\r\n        Storage,\r\n        ExtendedStorage,\r\n        Whitelist\r\n    }\r\n\r\n    struct ProviderStatistic {\r\n        uint counter;\r\n        uint amountInEther;\r\n        uint reputation;\r\n    }\r\n\r\n    struct ERC20Token {\r\n        string symbol;\r\n        address tokenAddress;\r\n        uint decimal;\r\n    }\r\n}\r\n\r\ncontract Provider is Manageable {\r\n    string public name;\r\n    TypeDefinitions.ProviderType public providerType;\r\n    string public description;\r\n    mapping(string => bool) internal properties;\r\n    TypeDefinitions.ProviderStatistic public statistics;\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/rbac/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/rbac/RBAC.sol\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n *      Supports unlimited numbers of roles and addresses.\r\n *      See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n *  for you to write your own implementation of this interface using Enums or similar.\r\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\r\n *  to avoid typos.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * A constant role name for indicating admins.\r\n   */\r\n  string public constant ROLE_ADMIN = \"admin\";\r\n\r\n  /**\r\n   * @dev constructor. Sets msg.sender as admin by default\r\n   */\r\n  function RBAC()\r\n    public\r\n  {\r\n    addRole(msg.sender, ROLE_ADMIN);\r\n  }\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminAddRole(address addr, string roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    addRole(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminRemoveRole(address addr, string roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    removeRole(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to admins\r\n   * // reverts\r\n   */\r\n  modifier onlyAdmin()\r\n  {\r\n    checkRole(msg.sender, ROLE_ADMIN);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n// File: contracts/permission/PermissionProviderInterface.sol\r\n\r\ncontract PermissionProviderInterface is Provider, RBAC {\r\n    string public constant ROLE_ADMIN = \"admin\";\r\n    string public constant ROLE_CORE = \"core\";\r\n    string public constant ROLE_STORAGE = \"storage\";\r\n    string public constant ROLE_CORE_OWNER = \"CoreOwner\";\r\n    string public constant ROLE_STRATEGY_OWNER = \"StrategyOwner\";\r\n    string public constant ROLE_PRICE_OWNER = \"PriceOwner\";\r\n    string public constant ROLE_EXCHANGE_OWNER = \"ExchangeOwner\";\r\n    string public constant ROLE_EXCHANGE_ADAPTER_OWNER = \"ExchangeAdapterOwner\";\r\n    string public constant ROLE_STORAGE_OWNER = \"StorageOwner\";\r\n    string public constant ROLE_WHITELIST_OWNER = \"WhitelistOwner\";\r\n\r\n    modifier onlyAdmin()\r\n    {\r\n        checkRole(msg.sender, ROLE_ADMIN);\r\n        _;\r\n    }\r\n\r\n    function changeAdmin(address _newAdmin) onlyAdmin public returns (bool success);\r\n    function adminAdd(address _addr, string _roleName) onlyAdmin public;\r\n    function adminRemove(address _addr, string _roleName) onlyAdmin public;\r\n\r\n    function has(address _addr, string _roleName) public view returns(bool success);\r\n}\r\n\r\n// File: contracts/exchange/ExchangeAdapterBase.sol\r\n\r\ncontract ExchangeAdapterBase {\r\n\r\n    address internal adapterManager;\r\n    address internal exchangeExchange;\r\n\r\n    enum Status {\r\n        ENABLED, \r\n        DISABLED\r\n    }\r\n\r\n    enum OrderStatus {\r\n        Pending,\r\n        Approved,\r\n        PartiallyCompleted,\r\n        Completed,\r\n        Cancelled,\r\n        Errored\r\n    }\r\n\r\n    function ExchangeAdapterBase(address _manager,address _exchange) public {\r\n        adapterManager = _manager;\r\n        exchangeExchange = _exchange;\r\n    }\r\n\r\n    function getExpectAmount(uint eth, uint destDecimals, uint rate) internal pure returns(uint){\r\n        return Utils.calcDstQty(eth, 18, destDecimals, rate);\r\n    }\r\n\r\n    modifier onlyAdaptersManager(){\r\n        require(msg.sender == adapterManager);\r\n        _;\r\n    }\r\n\r\n    modifier onlyExchangeProvider(){\r\n        require(msg.sender == exchangeExchange);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/exchange/ExchangeProviderInterface.sol\r\n\r\ncontract ExchangeProviderInterface {\r\n    function startPlaceOrder(uint orderId, address deposit) external returns(bool);\r\n    function addPlaceOrderItem(uint orderId, ERC20 token, uint amount, uint rate) external returns(bool);\r\n    function endPlaceOrder(uint orderId) external payable returns(bool);\r\n    function getSubOrderStatus(uint orderId, ERC20 token) external view returns (ExchangeAdapterBase.OrderStatus);\r\n    function cancelOrder(uint orderId) external returns (bool success);\r\n    function checkTokenSupported(ERC20 token) external view returns (bool);\r\n}\r\n\r\n// File: contracts/libs/Converter.sol\r\n\r\nlibrary Converter {\r\n    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    function bytes32ToString(bytes32 x) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/price/PriceProviderInterface.sol\r\n\r\ncontract PriceProviderInterface {\r\n\r\n    function updatePrice(address _tokenAddress,bytes32[] _exchanges,uint[] _prices,uint _nonce) public returns(bool success);\r\n    function getNewDefaultPrice(address _tokenAddress) public view returns(uint);\r\n    function getNewCustomPrice(address _provider,address _tokenAddress) public view returns(uint);\r\n\r\n    function getNonce(address providerAddress,address tokenAddress) public view returns(uint);\r\n\r\n    function checkTokenSupported(address tokenAddress)  public view returns(bool success);\r\n    function checkExchangeSupported(bytes32 Exchanges)  public view returns(bool success);\r\n    function checkProviderSupported(address providerAddress,address tokenAddress)  public view returns(bool success);\r\n\r\n    function getRates(address dest, uint srcQty)  public view returns (uint expectedRate, uint slippageRate);\r\n}\r\n\r\n// File: contracts/storage/OlympusStorageExtendedInterface.sol\r\n\r\n/*\r\n * @dev This contract, for now, can be used to store simple bytes32 key pairs.\r\n * These key pairs which are identifiable by their objectId and dataKind\r\n * Such as strategy, order, price, etc.\r\n * The purpose of this interface is that we can store custom data into this contract\r\n * for any changes in the requirements in the future. Each part of the Olympus core\r\n * should have options to add custom data to their respective dataType, by using\r\n * this contract.\r\n * The functions will always be the same, the implementation of the functions might change\r\n * So the implementing contracts should be able to modify the configured address of this contract\r\n * after deployment.\r\n */\r\ncontract OlympusStorageExtendedInterface {\r\n    /*\r\n     * @dev Use this function to set custom extra data for your contract in a key value format\r\n     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\r\n     * @param objectId The id for your kind of data, e.g. the strategyId, the orderId\r\n     * @param key The key which is used to save your data in the key value mapping\r\n     * @param value The value which will be set on the location of the key\r\n     * @return A boolean which returns true if the function executed succesfully\r\n     */\r\n    function setCustomExtraData(bytes32 dataKind, uint objectId, bytes32 key, bytes32 value) external returns(bool success);\r\n    /*\r\n     * @dev Use this function to get custom extra data for your contract by key\r\n     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\r\n     * @param objectId The id for your kind of data, e.g. the strategyId, the orderId\r\n     * @param key The key which is used to lookup your data in the key value mapping\r\n     * @return The result from the key lookup in string format\r\n     */\r\n    function getCustomExtraData(bytes32 dataKind, uint objectId, bytes32 key) external view returns(bytes32 result);\r\n    /*\r\n     * @dev This function is used internally to get the accessor for the kind of data\r\n     * @param dataKind The kind of data, e.g. strategy, order, price, exchange\r\n     * @param id The id for your kind of data, e.g. the strategyId, the orderId\r\n     * @return A concatenation of the dataKind string and id as string, which can be used as lookup\r\n     */\r\n    function getAccessor(bytes32 dataKind, uint id) private pure returns(string accessor);\r\n}\r\n\r\n// File: contracts/storage/StorageDefinitions.sol\r\n\r\nlibrary StorageTypeDefinitions {\r\n    enum OrderStatus {\r\n        New,\r\n        Placed,\r\n        PartiallyCompleted,\r\n        Completed,\r\n        Cancelled,\r\n        Errored\r\n    }\r\n}\r\n\r\n// File: contracts/storage/OlympusStorageInterface.sol\r\n\r\ncontract OlympusStorageInterface {\r\n\r\n    function addTokenDetails(\r\n        uint indexOrderId,\r\n        address[] tokens,\r\n        uint[] weights,\r\n        uint[] totalTokenAmounts,\r\n        uint[] estimatedPrices) external;\r\n\r\n    function addOrderBasicFields(\r\n        uint strategyId,\r\n        address buyer,\r\n        uint amountInWei,\r\n        uint feeInWei,\r\n        bytes32 exchangeId) external returns (uint indexOrderId);\r\n\r\n    function getOrderTokenCompletedAmount(\r\n        uint _orderId,\r\n        address _tokenAddress) external view returns (uint, uint);\r\n\r\n    function getIndexOrder1(uint _orderId) external view returns(\r\n        uint strategyId,\r\n        address buyer,\r\n        StorageTypeDefinitions.OrderStatus status,\r\n        uint dateCreated\r\n        );\r\n\r\n    function getIndexOrder2(uint _orderId) external view returns(\r\n        uint dateCompleted,\r\n        uint amountInWei,\r\n        uint tokensLength,\r\n        bytes32 exchangeId\r\n        );\r\n\r\n    function updateIndexOrderToken(\r\n        uint _orderId,\r\n        uint _tokenIndex,\r\n        uint _actualPrice,\r\n        uint _totalTokenAmount,\r\n        uint _completedQuantity,\r\n        ExchangeAdapterBase.OrderStatus status) external;\r\n\r\n    function getIndexToken(uint _orderId, uint tokenPosition) external view returns (address token);\r\n\r\n    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\r\n        external returns (bool success);\r\n\r\n    function resetOrderIdTo(uint _orderId) external returns(uint);\r\n\r\n    function addCustomField(\r\n        uint _orderId,\r\n        bytes32 key,\r\n        bytes32 value\r\n        ) external returns (bool success);\r\n\r\n    function getCustomField(\r\n        uint _orderId,\r\n        bytes32 key\r\n        ) external view returns (bytes32 result);\r\n}\r\n\r\n// File: contracts/storage/OlympusStorage.sol\r\n\r\ncontract OlympusStorage is Manageable, OlympusStorageInterface {\r\n    using SafeMath for uint256;\r\n\r\n    event IndexOrderUpdated (uint orderId);\r\n    event Log(string message);\r\n\r\n    struct IndexOrder {\r\n        address buyer;\r\n        uint strategyId;\r\n        uint amountInWei;\r\n        uint feeInWei;\r\n        uint dateCreated;\r\n        uint dateCompleted;\r\n        address[] tokens;\r\n        uint[] weights;\r\n        uint[] estimatedPrices;\r\n        uint[] dealtPrices;\r\n        uint[] totalTokenAmounts;\r\n        uint[] completedTokenAmounts;\r\n        ExchangeAdapterBase.OrderStatus[] subStatuses;\r\n        StorageTypeDefinitions.OrderStatus status;\r\n        bytes32 exchangeId;\r\n    }\r\n    mapping(uint => IndexOrder) public orders;\r\n    mapping(uint => mapping(address => uint)) public orderTokenAmounts;\r\n    uint public orderId = 1000000;\r\n    bytes32 constant private dataKind = \"Order\";\r\n    OlympusStorageExtendedInterface internal olympusStorageExtended = OlympusStorageExtendedInterface(address(0xcEb51bD598ABb0caa8d2Da30D4D760f08936547B));\r\n\r\n    modifier onlyOwner() {\r\n        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_STORAGE_OWNER()));\r\n        _;\r\n    }\r\n    modifier onlyCore() {\r\n        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_CORE()));\r\n        _;\r\n    }\r\n    PermissionProviderInterface internal permissionProvider;\r\n    constructor(address _permissionProvider) public {\r\n        permissionProvider = PermissionProviderInterface(_permissionProvider);\r\n    }\r\n\r\n    function addTokenDetails(\r\n        uint indexOrderId,\r\n        address[] tokens,\r\n        uint[] weights,\r\n        uint[] totalTokenAmounts,\r\n        uint[] estimatedPrices\r\n    ) external onlyCore {\r\n        orders[indexOrderId].tokens = tokens;\r\n        orders[indexOrderId].weights = weights;\r\n        orders[indexOrderId].estimatedPrices = estimatedPrices;\r\n        orders[indexOrderId].totalTokenAmounts = totalTokenAmounts;\r\n        uint i;\r\n\r\n        for (i = 0; i < tokens.length; i++ ) {\r\n            orders[indexOrderId].subStatuses.push(ExchangeAdapterBase.OrderStatus.Pending);\r\n            orders[indexOrderId].dealtPrices.push(0);\r\n            orders[indexOrderId].completedTokenAmounts.push(0);\r\n\r\n            orderTokenAmounts[indexOrderId][tokens[i]] = weights[i];\r\n        }\r\n    }\r\n\r\n    function addOrderBasicFields(\r\n        uint strategyId,\r\n        address buyer,\r\n        uint amountInWei,\r\n        uint feeInWei,\r\n        bytes32 exchangeId\r\n        ) external onlyCore returns (uint indexOrderId) {\r\n        indexOrderId = getOrderId();\r\n\r\n        IndexOrder memory order = IndexOrder({\r\n            buyer: buyer,\r\n            strategyId: strategyId,\r\n            amountInWei: amountInWei,\r\n            feeInWei: feeInWei,\r\n            dateCreated: now,\r\n            dateCompleted: 0,\r\n            tokens: new address[](0),\r\n            weights: new uint[](0),\r\n            estimatedPrices: new uint[](0),\r\n            dealtPrices: new uint[](0),\r\n            totalTokenAmounts: new uint[](0),\r\n            completedTokenAmounts: new uint[](0),\r\n            subStatuses: new ExchangeAdapterBase.OrderStatus[](0),\r\n            status: StorageTypeDefinitions.OrderStatus.New,\r\n            exchangeId: exchangeId\r\n        });\r\n\r\n        orders[indexOrderId] = order;\r\n        return indexOrderId;\r\n    }\r\n\r\n    function getIndexOrder1(uint _orderId) external view returns(\r\n        uint strategyId,\r\n        address buyer,\r\n        StorageTypeDefinitions.OrderStatus status,\r\n        uint dateCreated\r\n        ) {\r\n        IndexOrder memory order = orders[_orderId];\r\n        return (\r\n            order.strategyId,\r\n            order.buyer,\r\n            order.status,\r\n            order.dateCreated\r\n        );\r\n    }\r\n    function getIndexOrder2(uint _orderId) external view returns(\r\n        uint dateCompleted,\r\n        uint amountInWei,\r\n        uint tokensLength,\r\n        bytes32 exchangeId\r\n        ) {\r\n        IndexOrder memory order = orders[_orderId];\r\n        return (\r\n            order.dateCompleted,\r\n            order.amountInWei,\r\n            order.tokens.length,\r\n            order.exchangeId\r\n        );\r\n    }\r\n\r\n    function getIndexToken(uint _orderId, uint tokenPosition) external view returns (address token){\r\n        return orders[_orderId].tokens[tokenPosition];\r\n    }\r\n\r\n    function getOrderTokenCompletedAmount(uint _orderId, address _tokenAddress) external view returns (uint, uint){\r\n        IndexOrder memory order = orders[_orderId];\r\n\r\n        int index = -1;\r\n        for(uint i = 0 ; i < order.tokens.length; i++){\r\n            if(order.tokens[i] == _tokenAddress) {\r\n                index = int(i);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(index == -1) {\r\n            // token not found.\r\n            revert();\r\n        }\r\n\r\n        return (order.completedTokenAmounts[uint(index)], uint(index));\r\n\r\n    }\r\n\r\n    function updateIndexOrderToken(\r\n        uint _orderId,\r\n        uint _tokenIndex,\r\n        uint _actualPrice,\r\n        uint _totalTokenAmount,\r\n        uint _completedQuantity,\r\n        ExchangeAdapterBase.OrderStatus _status) external onlyCore {\r\n\r\n        orders[_orderId].totalTokenAmounts[_tokenIndex] = _totalTokenAmount;\r\n        orders[_orderId].dealtPrices[_tokenIndex] = _actualPrice;\r\n        orders[_orderId].completedTokenAmounts[_tokenIndex] = _completedQuantity;\r\n        orders[_orderId].subStatuses[_tokenIndex] = _status;\r\n    }\r\n\r\n    function addCustomField(\r\n        uint _orderId,\r\n        bytes32 key,\r\n        bytes32 value\r\n    ) external onlyCore returns (bool success){\r\n        return olympusStorageExtended.setCustomExtraData(dataKind,_orderId,key,value);\r\n    }\r\n\r\n    function getCustomField(\r\n        uint _orderId,\r\n        bytes32 key\r\n    ) external view returns (bytes32 result){\r\n        return olympusStorageExtended.getCustomExtraData(dataKind,_orderId,key);\r\n    }\r\n\r\n    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\r\n        external onlyCore returns (bool success){\r\n\r\n        orders[_orderId].status = _status;\r\n        return true;\r\n    }\r\n\r\n    function getOrderId() private returns (uint) {\r\n        return orderId++;\r\n    }\r\n\r\n    function resetOrderIdTo(uint _start) external onlyOwner returns (uint) {\r\n        orderId = _start;\r\n        return orderId;\r\n    }\r\n\r\n    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\r\n        bool result = super.setProvider(_id, _providerAddress);\r\n        TypeDefinitions.ProviderType _type = TypeDefinitions.ProviderType(_id);\r\n\r\n        if(_type == TypeDefinitions.ProviderType.ExtendedStorage) {\r\n            emit Log(\"ExtendedStorage\");\r\n            olympusStorageExtended = OlympusStorageExtendedInterface(_providerAddress);\r\n        } else {\r\n            emit Log(\"Unknown provider type supplied.\");\r\n            revert();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n}\r\n\r\n// File: contracts/strategy/StrategyProviderInterface.sol\r\n\r\ncontract StrategyProviderInterface is Provider {\r\n\r\n    struct Combo {\r\n        uint id;\r\n        string name;\r\n        string description;\r\n        string category;\r\n        address[] tokenAddresses;\r\n        uint[] weights;      //total is 100\r\n        uint follower;\r\n        uint amount;\r\n        bytes32 exchangeId;\r\n    }\r\n\r\n    Combo[] public comboHub;\r\n    modifier _checkIndex(uint _index) {\r\n        require(_index < comboHub.length);\r\n        _;\r\n    }\r\n\r\n   // To core smart contract\r\n    function getStrategyCount() public view returns (uint length);\r\n\r\n    function getStrategyTokenCount(uint strategyId) public view returns (uint length);\r\n    function getStrategyTokenByIndex(uint strategyId, uint tokenIndex) public view returns (address token, uint weight);\r\n\r\n    function getStrategy(uint _index) public _checkIndex(_index) view returns (\r\n        uint id,\r\n        string name,\r\n        string description,\r\n        string category,\r\n        address[] memory tokenAddresses,\r\n        uint[] memory weights,\r\n        uint followers,\r\n        uint amount,\r\n        bytes32 exchangeId);\r\n\r\n    function createStrategy(\r\n        string name,\r\n        string description,\r\n        string category,\r\n        address[] tokenAddresses,\r\n        uint[] weights,\r\n        bytes32 exchangeId)\r\n        public returns (uint strategyId);\r\n\r\n    function updateStrategy(\r\n        uint strategyId,\r\n        string name,\r\n        string description,\r\n        string category,\r\n        address[] tokenAddresses,\r\n        uint[] weights,\r\n        bytes32 exchangeId)\r\n        public returns (bool success);\r\n\r\n    // increment statistics\r\n    function incrementStatistics(uint id, uint amountInEther) external returns (bool success);\r\n    function updateFollower(uint id, bool follow) external returns (bool success);\r\n}\r\n\r\n// File: contracts/whitelist/WhitelistProviderInterface.sol\r\n\r\ncontract WhitelistProviderInterface is Provider {\r\n    function isAllowed(address account) external view returns(bool);\r\n}\r\n\r\n// File: contracts/OlympusLabsCore.sol\r\n\r\ncontract OlympusLabsCore is Manageable {\r\n    using SafeMath for uint256;\r\n\r\n    event IndexOrderUpdated (uint orderId);\r\n    event Log(string message);\r\n    event LogNumber(uint number);\r\n    event LogAddress(address message);\r\n    event LogAddresses(address[] message);\r\n    event LogNumbers(uint[] numbers);\r\n    event LOGDEBUG(address);\r\n\r\n    ExchangeProviderInterface internal exchangeProvider =  ExchangeProviderInterface(address(0x0));\r\n    StrategyProviderInterface internal strategyProvider = StrategyProviderInterface(address(0x0));\r\n    PriceProviderInterface internal priceProvider = PriceProviderInterface(address(0x0));\r\n    OlympusStorageInterface internal olympusStorage = OlympusStorageInterface(address(0x0));\r\n    WhitelistProviderInterface internal whitelistProvider;\r\n    ERC20 private constant MOT = ERC20(address(0x263c618480DBe35C300D8d5EcDA19bbB986AcaeD));\r\n    // TODO, update for mainnet: 0x263c618480DBe35C300D8d5EcDA19bbB986AcaeD\r\n\r\n    uint public feePercentage = 100;\r\n    uint public MOTDiscount = 25;\r\n    uint public constant DENOMINATOR = 10000;\r\n\r\n    uint public minimumInWei = 0;\r\n    uint public maximumInWei;\r\n\r\n    modifier allowProviderOnly(TypeDefinitions.ProviderType _type) {\r\n        require(msg.sender == subContracts[uint8(_type)]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(permissionProvider.has(msg.sender, permissionProvider.ROLE_CORE_OWNER()));\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowed(){\r\n        require(address(whitelistProvider) == 0x0 || whitelistProvider.isAllowed(msg.sender));\r\n        _;\r\n    }\r\n\r\n    PermissionProviderInterface internal permissionProvider;\r\n\r\n    function OlympusLabsCore(address _permissionProvider) public {\r\n        permissionProvider = PermissionProviderInterface(_permissionProvider);\r\n    }\r\n\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    function getStrategyCount() public view returns (uint length)\r\n    {\r\n        return strategyProvider.getStrategyCount();\r\n    }\r\n\r\n    function getStrategy(uint strategyId) public view returns (\r\n        string name,\r\n        string description,\r\n        string category,\r\n        address[] memory tokens,\r\n        uint[] memory weights,\r\n        uint followers,\r\n        uint amount,\r\n        string exchangeName)\r\n    {\r\n        bytes32 _exchangeName;\r\n        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\r\n        tokens = new address[](tokenLength);\r\n        weights = new uint[](tokenLength);\r\n\r\n        (,name,description,category,,,followers,amount,_exchangeName) = strategyProvider.getStrategy(strategyId);\r\n        (,,,,tokens,weights,,,) = strategyProvider.getStrategy(strategyId);\r\n        exchangeName = Converter.bytes32ToString(_exchangeName);\r\n    }\r\n\r\n    function getStrategyTokenAndWeightByIndex(uint strategyId, uint index) public view returns (\r\n        address token,\r\n        uint weight\r\n        )\r\n    {\r\n        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\r\n        require(index < tokenLength);\r\n\r\n        (token, weight) = strategyProvider.getStrategyTokenByIndex(strategyId, index);\r\n    }\r\n\r\n    // Forward to Price smart contract.\r\n    function getPrice(address tokenAddress, uint srcQty) public view returns (uint price){\r\n        require(tokenAddress != address(0));\r\n        (, price) = priceProvider.getRates(tokenAddress, srcQty);\r\n        return price;\r\n    }\r\n\r\n    function getStrategyTokenPrice(uint strategyId, uint tokenIndex) public view returns (uint price) {\r\n        uint totalLength;\r\n\r\n        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\r\n        require(tokenIndex <= totalLength);\r\n        address[] memory tokens;\r\n        uint[] memory weights;\r\n        (,,,,tokens,weights,,,) = strategyProvider.getStrategy(strategyId);\r\n\r\n        //Default get the price for one Ether\r\n\r\n        return getPrice(tokens[tokenIndex], 10**18);\r\n    }\r\n\r\n    function setProvider(uint8 _id, address _providerAddress) public onlyOwner returns (bool success) {\r\n        bool result = super.setProvider(_id, _providerAddress);\r\n        TypeDefinitions.ProviderType _type = TypeDefinitions.ProviderType(_id);\r\n\r\n        if(_type == TypeDefinitions.ProviderType.Strategy) {\r\n            emit Log(\"StrategyProvider\");\r\n            strategyProvider = StrategyProviderInterface(_providerAddress);\r\n        } else if(_type == TypeDefinitions.ProviderType.Exchange) {\r\n            emit Log(\"ExchangeProvider\");\r\n            exchangeProvider = ExchangeProviderInterface(_providerAddress);\r\n        } else if(_type == TypeDefinitions.ProviderType.Price) {\r\n            emit Log(\"PriceProvider\");\r\n            priceProvider = PriceProviderInterface(_providerAddress);\r\n        } else if(_type == TypeDefinitions.ProviderType.Storage) {\r\n            emit Log(\"StorageProvider\");\r\n            olympusStorage = OlympusStorageInterface(_providerAddress);\r\n        } else if(_type == TypeDefinitions.ProviderType.Whitelist) {\r\n            emit Log(\"WhitelistProvider\");\r\n            whitelistProvider = WhitelistProviderInterface(_providerAddress);\r\n        } else {\r\n            emit Log(\"Unknown provider type supplied.\");\r\n            revert();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function buyIndex(uint strategyId, address depositAddress, bool feeIsMOT)\r\n    public onlyAllowed payable returns (uint indexOrderId)\r\n    {\r\n        require(msg.value > minimumInWei);\r\n        if(maximumInWei > 0){\r\n            require(msg.value <= maximumInWei);\r\n        }\r\n        uint tokenLength = strategyProvider.getStrategyTokenCount(strategyId);\r\n        // can't buy an index without tokens.\r\n        require(tokenLength > 0);\r\n        address[] memory tokens = new address[](tokenLength);\r\n        uint[] memory weights = new uint[](tokenLength);\r\n        bytes32 exchangeId;\r\n\r\n        (,,,,tokens,weights,,,exchangeId) = strategyProvider.getStrategy(strategyId);\r\n\r\n        uint[3] memory amounts;\r\n        amounts[0] = msg.value; //uint totalAmount\r\n        amounts[1] = getFeeAmount(amounts[0], feeIsMOT); // fee\r\n        amounts[2] = payFee(amounts[0], amounts[1], msg.sender, feeIsMOT);\r\n\r\n        // create order.\r\n        indexOrderId = olympusStorage.addOrderBasicFields(\r\n          strategyId,\r\n          msg.sender,\r\n          amounts[0],\r\n          amounts[1],\r\n          exchangeId\r\n        );\r\n\r\n        uint[][4] memory subOrderTemp;\r\n        // 0: token amounts\r\n        // 1: estimatedPrices\r\n        subOrderTemp[0] = initializeArray(tokenLength);\r\n        subOrderTemp[1] = initializeArray(tokenLength);\r\n\r\n        emit LogNumber(indexOrderId);\r\n\r\n\r\n        require(exchangeProvider.startPlaceOrder(indexOrderId, depositAddress));\r\n\r\n        for (uint i = 0; i < tokenLength; i ++ ) {\r\n\r\n            // ignore those tokens with zero weight.\r\n            if(weights[i] <= 0) {\r\n                continue;\r\n            }\r\n            // token has to be supported by exchange provider.\r\n            if(!exchangeProvider.checkTokenSupported(ERC20(tokens[i]))){\r\n                emit Log(\"Exchange provider doesn't support\");\r\n                revert();\r\n            }\r\n\r\n            // check if price provider supports it.\r\n            if(!priceProvider.checkTokenSupported(tokens[i])){\r\n                emit Log(\"Price provider doesn't support\");\r\n                revert();\r\n            }\r\n\r\n            subOrderTemp[0][i] = amounts[2] * weights[i] / 100;\r\n            subOrderTemp[1][i] = getPrice(tokens[i], subOrderTemp[0][i]);\r\n\r\n            emit LogAddress(tokens[i]);\r\n            emit LogNumber(subOrderTemp[0][i]);\r\n            emit LogNumber(subOrderTemp[1][i]);\r\n            require(exchangeProvider.addPlaceOrderItem(indexOrderId, ERC20(tokens[i]), subOrderTemp[0][i], subOrderTemp[1][i]));\r\n        }\r\n\r\n        olympusStorage.addTokenDetails(\r\n            indexOrderId,\r\n            tokens, weights, subOrderTemp[0], subOrderTemp[1]\r\n        );\r\n\r\n\r\n        emit LogNumber(amounts[2]);\r\n        require((exchangeProvider.endPlaceOrder.value(amounts[2])(indexOrderId)));\r\n\r\n\r\n        strategyProvider.updateFollower(strategyId, true);\r\n\r\n        strategyProvider.incrementStatistics(strategyId, msg.value);\r\n\r\n        return indexOrderId;\r\n    }\r\n\r\n    function initializeArray(uint length) private pure returns (uint[]){\r\n        return new uint[](length);\r\n    }\r\n\r\n    function resetOrderIdTo(uint _start) external onlyOwner returns (uint) {\r\n        return olympusStorage.resetOrderIdTo(_start);\r\n    }\r\n\r\n    // For app/3rd-party clients to check details / status.\r\n    function getIndexOrder(uint _orderId) public view returns\r\n    (uint[])\r\n    {\r\n        // 0 strategyId\r\n        // 1 dateCreated\r\n        // 2 dateCompleted\r\n        // 3 amountInWei\r\n        // 4 tokenLength\r\n        uint[] memory orderPartial = new uint[](5);\r\n        address[] memory buyer = new address[](1);\r\n        bytes32[] memory exchangeId = new bytes32[](1);\r\n        StorageTypeDefinitions.OrderStatus[] memory status = new StorageTypeDefinitions.OrderStatus[](1);\r\n\r\n\r\n        (orderPartial[0], buyer[0], status[0], orderPartial[1]) = olympusStorage.getIndexOrder1(_orderId);\r\n        (orderPartial[2], orderPartial[3], orderPartial[4], exchangeId[0]) = olympusStorage.getIndexOrder2(_orderId);\r\n        address[] memory tokens = new address[](orderPartial[4]);\r\n\r\n        for(uint i = 0; i < orderPartial[4]; i++){\r\n            tokens[i] = olympusStorage.getIndexToken(_orderId, i);\r\n        }\r\n        return (\r\n          orderPartial\r\n        );\r\n    }\r\n\r\n    function updateIndexOrderToken(\r\n        uint _orderId,\r\n        address _tokenAddress,\r\n        uint _actualPrice,\r\n        uint _totalTokenAmount,\r\n        uint _completedQuantity\r\n    ) external allowProviderOnly(TypeDefinitions.ProviderType.Exchange) returns (bool success)\r\n    {\r\n        uint completedTokenAmount;\r\n        uint tokenIndex;\r\n        (completedTokenAmount, tokenIndex) = olympusStorage.getOrderTokenCompletedAmount(_orderId,_tokenAddress);\r\n\r\n        ExchangeAdapterBase.OrderStatus status;\r\n\r\n        if(completedTokenAmount == 0 && _completedQuantity < completedTokenAmount){\r\n            status = ExchangeAdapterBase.OrderStatus.PartiallyCompleted;\r\n        }\r\n\r\n        if(_completedQuantity >= completedTokenAmount){\r\n            status = ExchangeAdapterBase.OrderStatus.Completed;\r\n        }\r\n        olympusStorage.updateIndexOrderToken(_orderId, tokenIndex, _totalTokenAmount, _actualPrice, _completedQuantity, status);\r\n\r\n        return true;\r\n    }\r\n\r\n    function updateOrderStatus(uint _orderId, StorageTypeDefinitions.OrderStatus _status)\r\n        external allowProviderOnly(TypeDefinitions.ProviderType.Exchange)\r\n        returns (bool success)\r\n    {\r\n        olympusStorage.updateOrderStatus(_orderId, _status);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getSubOrderStatus(uint _orderId, address _tokenAddress)\r\n        external view returns (ExchangeAdapterBase.OrderStatus)\r\n    {\r\n        return exchangeProvider.getSubOrderStatus(_orderId, ERC20(_tokenAddress));\r\n    }\r\n\r\n    function adjustFee(uint _newFeePercentage) public onlyOwner returns (bool success) {\r\n        require(_newFeePercentage < DENOMINATOR);\r\n        feePercentage = _newFeePercentage;\r\n        return true;\r\n    }\r\n\r\n    function adjustMOTFeeDiscount(uint _newDiscountPercentage) public onlyOwner returns(bool success) {\r\n        require(_newDiscountPercentage <= 100);\r\n        MOTDiscount = _newDiscountPercentage;\r\n        return true;\r\n    }\r\n\r\n    function adjustTradeRange(uint _minInWei, uint _maxInWei) public onlyOwner returns (bool success) {\r\n        require(_minInWei > 0);\r\n        require(_maxInWei > _minInWei);\r\n        minimumInWei = _minInWei;\r\n        maximumInWei = _maxInWei;\r\n\r\n        return true;\r\n    }\r\n\r\n    function getFeeAmount(uint amountInWei, bool feeIsMOT) private view returns (uint){\r\n        if(feeIsMOT){\r\n            return ((amountInWei * feePercentage / DENOMINATOR) * (100 - MOTDiscount)) / 100;\r\n        } else {\r\n            return amountInWei * feePercentage / DENOMINATOR;\r\n        }\r\n    }\r\n\r\n    function payFee(uint totalValue, uint feeValueInETH, address sender, bool feeIsMOT) private returns (uint){\r\n        if(feeIsMOT){\r\n            // Transfer MOT\r\n            uint MOTPrice;\r\n            uint allowance = MOT.allowance(sender,address(this));\r\n            (MOTPrice,) = priceProvider.getRates(address(MOT), feeValueInETH);\r\n            uint amount = (feeValueInETH * MOTPrice) / 10**18;\r\n            require(allowance >= amount);\r\n            require(MOT.transferFrom(sender,address(this),amount));\r\n            return totalValue; // Use all sent ETH to buy, because fee is paid in MOT\r\n        } else { // We use ETH as fee, so deduct that from the amount of ETH sent\r\n            return totalValue - feeValueInETH;\r\n        }\r\n    }\r\n\r\n    function withdrawERC20(address receiveAddress,address _tokenAddress) public onlyOwner returns(bool success)\r\n    {\r\n        uint _balance = ERC20(_tokenAddress).balanceOf(address(this));\r\n        require(_tokenAddress != 0x0 && receiveAddress != 0x0 && _balance != 0);\r\n        require(ERC20(_tokenAddress).transfer(receiveAddress,_balance));\r\n        return true;\r\n    }\r\n    function withdrawETH(address receiveAddress) public onlyOwner returns(bool success)\r\n    {\r\n        require(receiveAddress != 0x0);\r\n        receiveAddress.transfer(this.balance);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_minInWei\",\"type\":\"uint256\"},{\"name\":\"_maxInWei\",\"type\":\"uint256\"}],\"name\":\"adjustTradeRange\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MOTDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"strategyId\",\"type\":\"uint256\"},{\"name\":\"depositAddress\",\"type\":\"address\"},{\"name\":\"feeIsMOT\",\"type\":\"bool\"}],\"name\":\"buyIndex\",\"outputs\":[{\"name\":\"indexOrderId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderId\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_actualPrice\",\"type\":\"uint256\"},{\"name\":\"_totalTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_completedQuantity\",\"type\":\"uint256\"}],\"name\":\"updateIndexOrderToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderId\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getSubOrderStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStrategyCount\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDiscountPercentage\",\"type\":\"uint256\"}],\"name\":\"adjustMOTFeeDiscount\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"resetOrderIdTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiveAddress\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"strategyId\",\"type\":\"uint256\"},{\"name\":\"tokenIndex\",\"type\":\"uint256\"}],\"name\":\"getStrategyTokenPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiveAddress\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"subContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderId\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"updateOrderStatus\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFeePercentage\",\"type\":\"uint256\"}],\"name\":\"adjustFee\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"strategyId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStrategyTokenAndWeightByIndex\",\"outputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"weight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"getStrategy\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"category\",\"type\":\"string\"},{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"weights\",\"type\":\"uint256[]\"},{\"name\":\"followers\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"exchangeName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"getIndexOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint8\"},{\"name\":\"_providerAddress\",\"type\":\"address\"}],\"name\":\"setProvider\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_permissionProvider\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"IndexOrderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"LogNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"address[]\"}],\"name\":\"LogAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"numbers\",\"type\":\"uint256[]\"}],\"name\":\"LogNumbers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"}],\"name\":\"LOGDEBUG\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"address\"}],\"name\":\"ProviderUpdated\",\"type\":\"event\"}]","ContractName":"OlympusLabsCore","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000545499f0383e7c0506eeb608ea239329be35213c","Library":"","SwarmSource":"bzzr://f9a19968f6cf2b2177c2bac07676fc4e942975284da1015709496a65b534c1c8"}]}