{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 {\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\n\r\ncontract etherdoodleToken is ERC721 {\r\n\r\n    using AddressUtils for address;\r\n    //@dev ERC-721 compliance\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n\r\n//EVENTS\r\n// @dev fired when a pixel's colour is changed\r\n    event ColourChanged(uint pixelId, uint8 colourR, uint8 colourG, uint8 colourB);\r\n\r\n// @dev fired when a pixel's price is changed\r\n    event PriceChanged(uint pixelId, uint oldPrice, uint newPrice);\r\n\r\n// @dev fired when a pixel's text is changed\r\n    event TextChanged(uint pixelId, string textChanged);\r\n\r\n//@dev name for ERC-721\r\n    string constant public name = \"etherdoodle\";\r\n\r\n//@dev symbol for ERC-721\r\n    string constant public symbol = \"etherdoodle\";\r\n\r\n//@dev Starting pixel price\r\n    uint constant public startingPrice = 0.0025 ether;\r\n\r\n//@dev Total number of promo pixels\r\n    uint private constant PROMO_LIMIT = 1000;\r\n\r\n//@dev Switch from 3x to 1.5x per transaction\r\n    uint private constant stepAt = 0.24862 ether;\r\n\r\n//@dev The addresses of the accounts \r\n    address public ceoAddress;\r\n\r\n//@dev number of promo pixels purchased\r\n    uint public promoCount;\r\n\r\n//DATA STRUCTURES\r\n//@dev struct representation of a pixel\r\n    struct Pixel {\r\n        uint32 id;\r\n        uint8 colourR;\r\n        uint8 colourG;\r\n        uint8 colourB;\r\n        string pixelText;\r\n    }\r\n\r\n//@dev array holding all pixels\r\n    Pixel[1000000] public pixels;\r\n\r\n//MAPPINGS\r\n//@dev mapping from a pixel to its owner\r\n    mapping (uint => address) private pixelToOwner;\r\n\r\n//@dev mapping from owner to all of their pixels;\r\n    mapping (address => uint[]) private ownerToPixel;\r\n\r\n//@dev mapping from an address to the count of pixels\r\n    mapping (address => uint) private ownerPixelCount;\r\n\r\n//@dev mapping from a pixelId to the price of that pixel\r\n    mapping (uint => uint ) private pixelToPrice;\r\n\r\n//@dev mapping from a pixel to an approved account for transfer\r\n    mapping(uint => address) public pixelToApproved;\r\n\r\n//@dev mapping from an address to another mapping that determines if an operator is approved\r\n    mapping(address => mapping(address=>bool)) internal operatorApprovals;\r\n\r\n//MODIFIERS\r\n//@dev access modifiers for ceo\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n//@dev used to verify ownership\r\n    modifier onlyOwnerOf(uint _pixelId) {\r\n        require(msg.sender == ownerOf(_pixelId));\r\n        _;\r\n    }\r\n\r\n//@dev used to allow operators to transfer and to manage the pixels\r\n    modifier canManageAndTransfer(uint _pixelId) {\r\n        require(isApprovedOrOwner(msg.sender, _pixelId));\r\n        _;\r\n    }\r\n\r\n//@dev make sure that the recipient address is notNull\r\n    modifier notNull(address _to) {\r\n        require(_to != address(0));\r\n        _;\r\n    }\r\n\r\n//Constructor\r\n    constructor () public {\r\n        ceoAddress = msg.sender;\r\n    }\r\n///////\r\n// External functions\r\n/////\r\n//@dev function to assign a new CEO\r\n    function assignCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n//@Update All a selected pixels details, can be done by the operator, or the owner\r\n    function updateAllPixelDetails(uint _pixelId, uint8 _colourR, uint8 _colourG, uint8 _colourB,uint _price,string _text) \r\n    external canManageAndTransfer(_pixelId) {\r\n        require(_price <= pixelToPrice[_pixelId]);\r\n        require(_price >= 0.0025 ether);\r\n        require(bytes(_text).length < 101);\r\n        bool colourChangedBool = false;\r\n        if(pixelToPrice[_pixelId] != _price){\r\n            pixelToPrice[_pixelId] = _price;\r\n            emit PriceChanged(_pixelId,pixelToPrice[_pixelId],_price);\r\n        }\r\n        if(pixels[_pixelId].colourR != _colourR){\r\n            pixels[_pixelId].colourR = _colourR;\r\n            colourChangedBool = true;\r\n        }\r\n        if(pixels[_pixelId].colourG != _colourG){\r\n            pixels[_pixelId].colourG = _colourG;\r\n            colourChangedBool = true;\r\n        }\r\n        if(pixels[_pixelId].colourB != _colourB){\r\n            pixels[_pixelId].colourB = _colourB;\r\n            colourChangedBool = true;\r\n        }\r\n        if (colourChangedBool){\r\n            emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\r\n        }\r\n        \r\n        if(keccak256(getPixelText(_pixelId)) != keccak256(_text) ){\r\n            pixels[_pixelId].pixelText = _text;\r\n            emit TextChanged(_pixelId,_text);\r\n        }\r\n    }\r\n\r\n//@dev add an address to a pixel's approved list\r\n    function approve(address _to, uint _pixelId) public  {\r\n        address owner = ownerOf(_pixelId);\r\n        require(_to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner,msg.sender));\r\n        if(getApproved(_pixelId) != address(0) || _to != address(0)) {\r\n            pixelToApproved[_pixelId] = _to;\r\n            emit Approval(msg.sender, _to, _pixelId);\r\n        }\r\n        \r\n    }\r\n\r\n//@dev returns approved Addresses\r\n    function getApproved(uint _pixelId) public view returns(address){\r\n        return pixelToApproved[_pixelId];\r\n    }\r\n\r\n//@dev approve all an owner's pixels to be managed by an address\r\n    function setApprovalForAll(address _to,bool _approved) public{\r\n        require(_to != msg.sender);\r\n        operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n \r\n\r\n///////////////////\r\n///Public functions\r\n///////////////////\r\n\r\n//@dev returns if a pixel has already been purchased\r\n    function exists(uint256 _pixelId) public view returns (bool) {\r\n        address owner = pixelToOwner[_pixelId];\r\n        return owner != address(0);\r\n    }\r\n\r\n//@dev returns if an address is approved to manage all another address' pixels\r\n    function isApprovedForAll(address _owner, address _operator) public view returns(bool) {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n//@dev returns the number of pixels an address owns\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return ownerPixelCount[_owner];\r\n    }\r\n\r\n\r\n//@dev returns the owner of a pixel\r\n    function ownerOf(uint _pixelId)  public view returns (address) {\r\n        address owner = pixelToOwner[_pixelId];\r\n        return owner;\r\n    }\r\n\r\n//@dev internal function to determine if its approved or an owner\r\n    function isApprovedOrOwner(address _spender, uint _pixelId)internal view returns (bool) {\r\n        address owner = ownerOf(_pixelId);\r\n        return(_spender == owner || getApproved(_pixelId) == _spender || isApprovedForAll(owner,_spender));\r\n    }\r\n\r\n//@dev internal function to remove approval on a pixel\r\n    function clearApproval(address _owner, uint256 _pixelId) internal {\r\n        require(ownerOf(_pixelId) == _owner);\r\n        if(pixelToApproved[_pixelId] != address(0)) {\r\n            pixelToApproved[_pixelId] = address(0);\r\n            emit Approval(_owner,address(0),_pixelId);\r\n        }\r\n    }\r\n\r\n//@dev returns the total number of pixels generated\r\n    function totalSupply() public view returns (uint) {\r\n        return pixels.length;\r\n    }\r\n\r\n//@dev ERC 721 transfer from\r\n    function transferFrom(address _from, address _to, uint _pixelId) public \r\n    canManageAndTransfer(_pixelId) {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        clearApproval(_from,_pixelId);\r\n        _transfer(_from, _to, _pixelId);\r\n    }\r\n//@dev ERC 721 safeTransfer from functions\r\n    function safeTransferFrom(address _from, address _to, uint _pixelId) public canManageAndTransfer(_pixelId){\r\n        safeTransferFrom(_from,_to,_pixelId,\"\");\r\n    }\r\n\r\n//@dev ERC 721 safeTransferFrom functions\r\n    function safeTransferFrom(address _from, address _to, uint _pixelId,bytes _data) public canManageAndTransfer(_pixelId){\r\n        transferFrom(_from,_to,_pixelId);\r\n        require(checkAndCallSafeTransfer(_from,_to,_pixelId,_data));\r\n    }\r\n\r\n//@dev TRANSFER\r\n    function transfer(address _to, uint _pixelId) public canManageAndTransfer(_pixelId) notNull(_to) {\r\n        _transfer(msg.sender, _to, _pixelId);\r\n    }\r\n\r\n//@dev returns all pixel's data\r\n    function getPixelData(uint _pixelId) public view returns \r\n    (uint32 _id, address _owner, uint8 _colourR, uint8 _colourG, uint8 _colourB, uint _price,string _text) {\r\n        Pixel storage pixel = pixels[_pixelId];\r\n        _id = pixel.id;\r\n        _price = getPixelPrice(_pixelId);\r\n        _owner = pixelToOwner[_pixelId];\r\n        _colourR = pixel.colourR;\r\n        _colourG = pixel.colourG;\r\n        _colourB = pixel.colourB;\r\n        _text = pixel.pixelText;\r\n    }\r\n\r\n//@dev Returns only Text\r\n    function getPixelText(uint _pixelId)public view returns(string) {\r\n        return pixels[_pixelId].pixelText;\r\n    }\r\n\r\n//@dev Returns the priceof a pixel\r\n    function getPixelPrice(uint _pixelId) public view returns(uint) {\r\n        uint price = pixelToPrice[_pixelId];\r\n        if (price != 0) {\r\n            return price;\r\n        } else {\r\n            return 1000000000000000;\r\n            }\r\n        \r\n    } \r\n\r\n    //@dev return the pixels owned by an address\r\n    function getPixelsOwned(address _owner) public view returns(uint[]) {\r\n        return ownerToPixel[_owner];\r\n    }\r\n\r\n    //@dev return number of pixels owned by an address\r\n    function getOwnerPixelCount(address _owner) public view returns(uint) {\r\n        return ownerPixelCount[_owner];\r\n    }\r\n\r\n    //@dev  return colour\r\n    function getPixelColour(uint _pixelId) public view returns (uint _colourR, uint _colourG, uint _colourB) {\r\n        _colourR = pixels[_pixelId].colourR;\r\n        _colourG = pixels[_pixelId].colourG;\r\n        _colourB = pixels[_pixelId].colourB;\r\n    }\r\n\r\n    //@dev payout function to dev\r\n    function payout(address _to) public onlyCEO {\r\n        if (_to == address(0)) {\r\n            ceoAddress.transfer(address(this).balance);\r\n        } else {\r\n            _to.transfer(address(this).balance);\r\n        }  \r\n    }\r\n\r\n    //@dev purchase promo pixels that cost nothing at start\r\n    function promoPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text) public {\r\n        require(ownerOf(_pixelId) == (address(0)));\r\n        require(promoCount<PROMO_LIMIT);\r\n        require(bytes(_text).length < 101);\r\n        _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\r\n        _transfer(address(0),msg.sender,_pixelId);      \r\n        promoCount++;\r\n    }\r\n        \r\n    //@dev purchase multiple pixels at the same time\r\n    function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable {\r\n        require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length);\r\n        require(bytes(_text).length < 101);\r\n        address newOwner = msg.sender;\r\n        uint totalPrice = 0;\r\n        uint excessValue = msg.value;\r\n        \r\n        for(uint i = 0; i < _Id.length; i++){\r\n            address oldOwner = ownerOf(_Id[i]);\r\n            require(ownerOf(_Id[i]) != newOwner);\r\n            require(!isInvulnerableByArea(_Id[i]));\r\n            \r\n            uint tempPrice = getPixelPrice(_Id[i]);\r\n            totalPrice = SafeMath.add(totalPrice,tempPrice);\r\n            excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue);\r\n           \r\n            if(i == _Id.length-1) {\r\n                require(msg.value >= totalPrice);\r\n                msg.sender.transfer(excessValue);\r\n                }   \r\n        }\r\n        \r\n    } \r\n\r\n    //@dev helper function for processing multiple purchases\r\n    function processMultiPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text, // solium-disable-line\r\n        address _oldOwner,address _newOwner,uint value) private returns (uint excess) {\r\n        uint payment; // payment to previous owner\r\n        uint purchaseExcess; // excess purchase value\r\n        uint sellingPrice = getPixelPrice(_pixelId);\r\n        if(_oldOwner == address(0)) {\r\n            purchaseExcess = uint(SafeMath.sub(value,startingPrice));\r\n            _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\r\n        } else {\r\n            payment = uint(SafeMath.div(SafeMath.mul(sellingPrice,95), 100));\r\n            purchaseExcess = SafeMath.sub(value,sellingPrice);\r\n            if(pixels[_pixelId].colourR != _colourR || pixels[_pixelId].colourG != _colourG || pixels[_pixelId].colourB != _colourB)\r\n                _changeColour(_pixelId,_colourR,_colourG,_colourB);\r\n            if(keccak256(getPixelText(_pixelId)) != keccak256(_text))\r\n                _changeText(_pixelId,_text);\r\n            clearApproval(_oldOwner,_pixelId);\r\n        }\r\n        if(sellingPrice < stepAt) {\r\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,300),95);\r\n        } else {\r\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,150),95);\r\n        }\r\n        _transfer(_oldOwner, _newOwner,_pixelId);\r\n     \r\n        if(_oldOwner != address(this)) {\r\n            _oldOwner.transfer(payment); \r\n        }\r\n        return purchaseExcess;\r\n    }\r\n    \r\n    function _changeColour(uint _pixelId,uint8 _colourR,uint8 _colourG, uint8 _colourB) private {\r\n        pixels[_pixelId].colourR = _colourR;\r\n        pixels[_pixelId].colourG = _colourG;\r\n        pixels[_pixelId].colourB = _colourB;\r\n        emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\r\n    }\r\n    function _changeText(uint _pixelId, string _text) private{\r\n        require(bytes(_text).length < 101);\r\n        pixels[_pixelId].pixelText = _text;\r\n        emit TextChanged(_pixelId,_text);\r\n    }\r\n    \r\n\r\n//@dev Invulnerability logic check \r\n    function isInvulnerableByArea(uint _pixelId) public view returns (bool) {\r\n        require(_pixelId >= 0 && _pixelId <= 999999);\r\n        if (ownerOf(_pixelId) == address(0)) {\r\n            return false;\r\n        }\r\n        uint256 counter = 0;\r\n \r\n        if (_pixelId == 0 || _pixelId == 999 || _pixelId == 999000 || _pixelId == 999999) {\r\n            return false;\r\n        }\r\n\r\n        if (_pixelId < 1000) {\r\n            if (_checkPixelRight(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n            if (_checkPixelLeft(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n            if (_checkPixelUnder(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n            if (_checkPixelUnderRight(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1); \r\n            }\r\n            if (_checkPixelUnderLeft(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n        }\r\n\r\n        if (_pixelId > 999000) {\r\n            if (_checkPixelRight(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n            if (_checkPixelLeft(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n            if (_checkPixelAbove(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n            if (_checkPixelAboveRight(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n            if (_checkPixelAboveLeft(_pixelId)) {\r\n                counter = SafeMath.add(counter, 1);\r\n            }\r\n        }\r\n\r\n        if (_pixelId > 999 && _pixelId < 999000) {\r\n            if (_pixelId%1000 == 0 || _pixelId%1000 == 999) {\r\n                if (_pixelId%1000 == 0) {\r\n                    if (_checkPixelAbove(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                    if (_checkPixelAboveRight(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                    if (_checkPixelRight(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                    if (_checkPixelUnder(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                    if (_checkPixelUnderRight(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                } else {\r\n                    if (_checkPixelAbove(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                    if (_checkPixelAboveLeft(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                    if (_checkPixelLeft(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                    if (_checkPixelUnder(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                    if (_checkPixelUnderLeft(_pixelId)) {\r\n                        counter = SafeMath.add(counter, 1);\r\n                    }\r\n                }\r\n            } else {\r\n                if (_checkPixelAbove(_pixelId)) {\r\n                    counter = SafeMath.add(counter, 1);\r\n                }\r\n                if (_checkPixelAboveLeft(_pixelId)) {\r\n                    counter = SafeMath.add(counter, 1);\r\n                }\r\n                if (_checkPixelAboveRight(_pixelId)) {\r\n                    counter = SafeMath.add(counter, 1);\r\n                }\r\n                if (_checkPixelUnder(_pixelId)) {\r\n                    counter = SafeMath.add(counter, 1);\r\n                }\r\n                if (_checkPixelUnderRight(_pixelId)) {\r\n                    counter = SafeMath.add(counter, 1);\r\n                }\r\n                if (_checkPixelUnderLeft(_pixelId)) {\r\n                    counter = SafeMath.add(counter, 1);\r\n                }\r\n                if (_checkPixelRight(_pixelId)) {\r\n                    counter = SafeMath.add(counter, 1);\r\n                }\r\n                if (_checkPixelLeft(_pixelId)) {\r\n                    counter = SafeMath.add(counter, 1);\r\n                }\r\n            }\r\n        }\r\n        return counter >= 5;\r\n    }\r\n\r\n   \r\n\r\n   \r\n\r\n////////////////////\r\n///Private functions\r\n////////////////////\r\n//@dev create a pixel\r\n    function _createPixel (uint32 _id, uint8 _colourR, uint8 _colourG, uint8 _colourB, string _pixelText) private returns(uint) {\r\n        pixels[_id] = Pixel(_id, _colourR, _colourG, _colourB, _pixelText);\r\n        pixelToPrice[_id] = startingPrice;\r\n        emit ColourChanged(_id, _colourR, _colourG, _colourB);\r\n        return _id;\r\n    }\r\n\r\n//@dev private function to transfer a pixel from an old address to a new one\r\n    function _transfer(address _from, address _to, uint _pixelId) private {\r\n  //increment new owner pixel count and decrement old owner count and add a pixel to the owners array\r\n        ownerPixelCount[_to] = SafeMath.add(ownerPixelCount[_to], 1);\r\n        ownerToPixel[_to].push(_pixelId);\r\n        if (_from != address(0)) {\r\n            for (uint i = 0; i < ownerToPixel[_from].length; i++) {\r\n                if (ownerToPixel[_from][i] == _pixelId) {\r\n                    ownerToPixel[_from][i] = ownerToPixel[_from][ownerToPixel[_from].length-1];\r\n                    delete ownerToPixel[_from][ownerToPixel[_from].length-1];\r\n                }\r\n            }\r\n            ownerPixelCount[_from] = SafeMath.sub(ownerPixelCount[_from], 1);\r\n        }\r\n        pixelToOwner[_pixelId] = _to;\r\n        emit Transfer(_from, _to, _pixelId);\r\n    }\r\n\r\n//@dev helper functions to check for if a pixel purchase is valid\r\n    function _checkPixelAbove(uint _pixelId) private view returns (bool) {\r\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function _checkPixelUnder(uint _pixelId) private view returns (bool) {\r\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1000)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _checkPixelRight(uint _pixelId) private view returns (bool) {\r\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _checkPixelLeft(uint _pixelId) private view returns (bool) {\r\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _checkPixelAboveLeft(uint _pixelId) private view returns (bool) {\r\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1001)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _checkPixelUnderLeft(uint _pixelId) private view returns (bool) {\r\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+999)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _checkPixelAboveRight(uint _pixelId) private view returns (bool) {\r\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-999)) {\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function _checkPixelUnderRight(uint _pixelId) private view returns (bool) {\r\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1001)) {\r\n            return true;\r\n        } else {  \r\n            return false; \r\n        }\r\n    }\r\n\r\n//@dev ERC721 compliance to check what address it is being sent to\r\n    function checkAndCallSafeTransfer(address _from, address _to, uint256 _pixelId, bytes _data)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        if (!_to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n        _from, _pixelId, _data);\r\n        return (retval == ERC721_RECEIVED);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint32\"},{\"name\":\"_colourR\",\"type\":\"uint8\"},{\"name\":\"_colourG\",\"type\":\"uint8\"},{\"name\":\"_colourB\",\"type\":\"uint8\"},{\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"promoPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promoCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pixelToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"assignCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"getPixelData\",\"outputs\":[{\"name\":\"_id\",\"type\":\"uint32\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_colourR\",\"type\":\"uint8\"},{\"name\":\"_colourG\",\"type\":\"uint8\"},{\"name\":\"_colourB\",\"type\":\"uint8\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_text\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getPixelsOwned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"getPixelColour\",\"outputs\":[{\"name\":\"_colourR\",\"type\":\"uint256\"},{\"name\":\"_colourG\",\"type\":\"uint256\"},{\"name\":\"_colourB\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"isInvulnerableByArea\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"},{\"name\":\"_colourR\",\"type\":\"uint8\"},{\"name\":\"_colourG\",\"type\":\"uint8\"},{\"name\":\"_colourB\",\"type\":\"uint8\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"updateAllPixelDetails\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pixels\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint32\"},{\"name\":\"colourR\",\"type\":\"uint8\"},{\"name\":\"colourG\",\"type\":\"uint8\"},{\"name\":\"colourB\",\"type\":\"uint8\"},{\"name\":\"pixelText\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_pixelId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Id\",\"type\":\"uint32[]\"},{\"name\":\"_R\",\"type\":\"uint8[]\"},{\"name\":\"_G\",\"type\":\"uint8[]\"},{\"name\":\"_B\",\"type\":\"uint8[]\"},{\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"multiPurchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"getPixelPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwnerPixelCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pixelId\",\"type\":\"uint256\"}],\"name\":\"getPixelText\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pixelId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"colourR\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"colourG\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"colourB\",\"type\":\"uint8\"}],\"name\":\"ColourChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pixelId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pixelId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"textChanged\",\"type\":\"string\"}],\"name\":\"TextChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"etherdoodleToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://da27c76242f84dc44d5907d3bb80539379c4bbc3af425ecfde64d7e337cf09fd"}]}