{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\ncontract Owned {\r\n    \r\n    address public owner;\r\n    mapping(address => bool) public owners;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n        owners[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyOwners{\r\n        address sen = msg.sender;\r\n        require(owners[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrigin{\r\n        require(tx.origin == owner);\r\n        _;\r\n    }\r\n\r\n    function addOwner(address newOwner) public onlyOwners{\r\n        owners[newOwner] = true;\r\n    }\r\n\r\n    function removeOwner() public onlyOwners{\r\n        owners[msg.sender] = false;\r\n    }\r\n\r\n    function removeOwner(address newOwner) public onlyOwner{\r\n        owners[newOwner] = false;\r\n    }\r\n\r\n    function isOwner(address o) public view returns(bool){\r\n        return owners[o] == true;\r\n    }\r\n}\r\n\r\n//Can be used by other contracts to get approval to spend tokens\r\ninterface TokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\r\n}\r\n\r\n\r\ncontract TokenERC20 is Owned {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    function TokenERC20(uint256 initialSupply,\r\n\t\tstring tokenName,\r\n\t\tstring tokenSymbol,\r\n\t\tuint8 dec) public {\r\n        // totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n        totalSupply = initialSupply; // Update total supply with the decimal amount\r\n        balanceOf[this] = totalSupply; // Give the creator all initial tokens\r\n        name = tokenName; // Set the name for display purposes\r\n        symbol = tokenSymbol; // Set the symbol for display purposes\r\n        decimals = dec;\r\n    }\r\n\r\n\r\n    function transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public {\r\n        transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success){\r\n        require(_value <= allowance[_from][msg.sender]); // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns(bool success){\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public\r\n\treturns(bool success){\r\n        TokenRecipient spender = TokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function burn(uint256 _value) public returns(bool success){\r\n        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n        totalSupply -= _value; // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _value) public returns(bool success){\r\n        require(balanceOf[_from] >= _value); // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]); // Check allowance\r\n        balanceOf[_from] -= _value; // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance\r\n        totalSupply -= _value; // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract MifflinToken is Owned, TokenERC20 {\r\n    \r\n    uint8 public tokenId;\r\n    uint256 ethDolRate = 1000;\r\n    uint256 weiRate = 1000000000000000000;\r\n    address exchange;\r\n    uint256 public buyPrice;\r\n    uint256 public totalContribution = 0;\r\n    uint256 public highestContribution = 0;\r\n    uint256 public lowestContribution = 2 ** 256 - 1;\r\n    uint256 public totalBought = 0;\r\n    mapping(address => bool) public frozenAccount;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    function MifflinToken(address exad,\r\n\t\tuint8 tid,\r\n\t\tuint256 issue,\r\n\t\tstring tokenName,\r\n\t\tstring tokenSymbol,\r\n\t\tuint8 dec)\r\n\t\tTokenERC20(issue * 10 ** uint256(dec), tokenName, tokenSymbol, dec) public {\r\n        tokenId = tid;\r\n        MifflinMarket e = MifflinMarket(exad);\r\n        e.setToken(tokenId,this);\r\n        exchange = exad;\r\n        addOwner(exchange);\r\n    }\r\n\r\n    function buy(uint _value) internal {\r\n        transfer(this, msg.sender, _value);\r\n        totalBought += _value;\r\n    }\r\n\r\n    function transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(balanceOf[_from] >= _value); // Check if the sender has enough\r\n        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\r\n        require(!frozenAccount[_from]); // Check if sender is frozen\r\n        require(!frozenAccount[_to]); // Check if recipient is frozen\r\n        balanceOf[_from] -= _value; // Subtract from the sender\r\n        balanceOf[_to] += _value; // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    // public methods to give and take that only owners can call\r\n    function give(address _to, uint256 _value) public onlyOwners returns(bool success){\r\n        transfer(this, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function take(address _from, uint256 _value) public onlyOwners returns(bool success){\r\n        transfer(_from, this, _value);\r\n        return true;\r\n    }\r\n\r\n    // / @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n    // / @param target Address to be frozen\r\n    // / @param freeze either to freeze it or not\r\n    function freezeAccount(address target, bool freeze) public onlyOwners{\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\r\n    // / @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\r\n    // / @param newBuyPrice Price users can buy from the contract\r\n    function setBuyPrice(uint256 newBuyPrice) public onlyOwners{\r\n        buyPrice = newBuyPrice;\r\n    }\r\n\r\n    // RULE we always lower the price any time there is a new high contribution!\r\n    function contribution(uint256 amount)internal returns(int highlow){\r\n        owner.transfer(msg.value);\r\n        totalContribution += msg.value;\r\n        if (amount > highestContribution) {\r\n            uint256 oneper = buyPrice * 99 / 100; // lower by 1%*\r\n            uint256 fullper = buyPrice *  highestContribution / amount; // lower by how much you beat the prior contribution\r\n            if(fullper > oneper) buyPrice = fullper;\r\n            else buyPrice = oneper;\r\n            highestContribution = amount;\r\n            // give reward\r\n            MifflinMarket(exchange).highContributionAward(msg.sender);\r\n            return 1;\r\n        } else if(amount < lowestContribution){\r\n            MifflinMarket(exchange).lowContributionAward(msg.sender);\r\n            lowestContribution = amount;\r\n            return -1;\r\n        } else return 0;\r\n    }\r\n\r\n    // sell tokens back to sender using owners ether\r\n    function sell(uint256 amount) public {\r\n        transfer(msg.sender, this, amount); // makes the transfers\r\n    }\r\n}\r\n\r\n\r\n/******************************************/\r\n/*       CUSTOM MIFFLIN TOKENS       */\r\n/******************************************/\r\n\r\ncontract BeetBuck is Owned, MifflinToken {\r\n    function BeetBuck(address exchange)MifflinToken(exchange, 2, 2000000, \"Beet Buck\", \"BEET\", 8) public {\r\n        buyPrice = weiRate / ethDolRate / uint(10) ** decimals; // 1d\r\n    }\r\n\r\n    function () payable public {\r\n        contribution(msg.value);\r\n        uint256 amountToGive = 0;\r\n        uint256 price = buyPrice;\r\n        if (totalBought < 10000) {\r\n            price -= price * 15 / 100;\r\n        } else if (totalBought < 50000) {\r\n            price -= price / 10;\r\n        } else if (totalBought < 100000) {\r\n            price -= price / 20;\r\n        } else if (totalBought < 200000) {\r\n            price -= price / 100;\r\n        }\r\n        amountToGive += msg.value / price;\r\n        buy(amountToGive);\r\n    }\r\n}\r\n\r\n\r\ncontract NapNickel is Owned, MifflinToken {\r\n\r\n    function NapNickel(address exchange)\r\n\tMifflinToken(exchange, 3, 1000000000, \"Nap Nickel\", \"NAPP\", 8) public {\r\n        buyPrice = weiRate / ethDolRate /  uint(10) ** decimals / 20; // 5c\r\n    }\r\n\r\n    function () payable public {\r\n        contribution(msg.value);\r\n        uint256 price = buyPrice;\r\n        uint256 estTime = block.timestamp - 5 * 60 * 60;\r\n        uint8 month;\r\n        uint8 day;\r\n        uint8 hour;\r\n        uint8 weekday;\r\n        (, month,day,hour,,,weekday) = parseTimestampParts(estTime);\r\n        if (month == 4 && day == 26) {\r\n            // its pretzel day\r\n            price += buyPrice / 5;\r\n        } else if (weekday == 0 || weekday == 6) {\r\n            // buying during weekend, get off my property\r\n            price += buyPrice * 15 / 100;\r\n        } else if (hour < 9 || hour >= 17) {\r\n            // buying outside of work hours, im in my hot tub\r\n            price += buyPrice / 10;\r\n        } else if (hour > 12 && hour < 13) {\r\n            // buying during lunch, leave me alone dammit\r\n            price += buyPrice / 20;\r\n        }\r\n        uint256 amountToGive = 0;\r\n        amountToGive += msg.value / price;\r\n        buy(amountToGive);\r\n    }\r\n    \r\n    struct _DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) public pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) public pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n        \r\n        function parseTimestampParts(uint timestamp) public pure returns (uint16 year,uint8 month,uint8 day, uint8 hour,uint8 minute,uint8 second,uint8 weekday) {\r\n            _DateTime memory dt = parseTimestamp(timestamp);\r\n            return (dt.year,dt.month,dt.day,dt.hour,dt.minute,dt.second,dt.weekday);\r\n        }\r\n\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n\r\n                // Minute\r\n                dt.minute = getMinute(timestamp);\r\n\r\n                // Second\r\n                dt.second = getSecond(timestamp);\r\n\r\n                // Day of week.\r\n                dt.weekday = getWeekday(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n\r\n        function getMinute(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60) % 60);\r\n        }\r\n\r\n        function getSecond(uint timestamp) public pure returns (uint8) {\r\n                return uint8(timestamp % 60);\r\n        }\r\n\r\n        function getWeekday(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n        }\r\n\r\n}\r\n\r\n\r\ncontract QuabityQuarter is Owned, MifflinToken {\r\n    uint lastContributionTime = 0;\r\n\r\n    function QuabityQuarter(address exchange)\r\n\tMifflinToken(exchange, 4, 420000000, \"Quabity Quarter\", \"QUAB\", 8) public {\r\n        buyPrice = weiRate / ethDolRate / uint(10) ** decimals / 4; // 25c\r\n    }\r\n\r\n    function () payable public {\r\n        contribution(msg.value);\r\n        uint256 amountToGive = 0;\r\n        amountToGive += msg.value / buyPrice;\r\n        uint256 time = block.timestamp;\r\n        uint256 diff = time - lastContributionTime / 60 / 60;\r\n        uint256 chance = 0;\r\n        if (diff > 96)\r\n\t\t\tchance = 50;\r\n        if (diff > 48)\r\n\t\t\tchance = 40;\r\n        else if (diff > 24)\r\n\t\t\tchance = 30;\r\n        else if (diff > 12)\r\n\t\t\tchance = 20;\r\n        else if (diff > 1)\r\n\t\t\tchance = 10;\r\n        else chance = 5;\r\n        if (chance > 0) {\r\n            uint256 lastBlockHash = uint256(keccak256(block.blockhash(block.number - 1), uint8(0)));\r\n            if (lastBlockHash % 100 < chance) {\r\n                // stole 10% extra!\r\n                amountToGive += amountToGive / 10;\r\n            }}\r\n        buy(amountToGive);\r\n    }\r\n}\r\n\r\n\r\ncontract KelevinKoin is Owned, MifflinToken {\r\n    \r\n    function KelevinKoin(address exchange)\r\n\tMifflinToken(exchange, 5, 69000000, \"Kelevin Koin\", \"KLEV\", 8) public {\r\n        buyPrice = weiRate / ethDolRate / uint(10) ** decimals / 50; // 2c\r\n    }\r\n\r\n    function () payable public {\r\n        contribution(msg.value);\r\n        // have to balance the books!\r\n        uint256 lastBlockHash = uint256(keccak256(block.blockhash(block.number - 1), uint8(0)));\r\n        uint256 newPrice = buyPrice + ((lastBlockHash % (buyPrice * 69 / 1000)) - (buyPrice * 69 * 2 / 1000));\r\n        buyPrice = newPrice;\r\n        uint256 amountToGive = msg.value / buyPrice;\r\n        if (buyPrice % msg.value == 0)\r\n\t\t\tamountToGive += amountToGive * 69 / 1000; // add 6.9%\r\n        buy(amountToGive);\r\n    }\r\n}\r\n\r\n\r\ncontract NnexNote is Owned, MifflinToken {\r\n    \r\n    function NnexNote(address exchange) \r\n\tMifflinToken(exchange, 6, 666000000, \"Nnex Note\", \"NNEX\", 8) public {\r\n        buyPrice = weiRate / ethDolRate / uint(10) ** decimals / 100; // 1c\r\n    }\r\n\r\n    // Do you really want a Nnex Note?\r\n    function () payable public {\r\n        // this is the only place I have human contact, so the more the better\r\n        contribution(msg.value);\r\n        // you can get up to a 50% discount\r\n        uint maxDiscountRange = buyPrice * 100;\r\n        uint discountPercent;\r\n        if(msg.value >= maxDiscountRange) discountPercent = 100;\r\n        else discountPercent = msg.value / maxDiscountRange * 100;\r\n        uint price = buyPrice - (buyPrice / 2) * (discountPercent / 100);\r\n        uint amountToGive = msg.value / price;\r\n        buy(amountToGive);\r\n    }\r\n}\r\n\r\n\r\ncontract DundieDollar is Owned, MifflinToken {\r\n    mapping(uint8 => string) public awards;\r\n    uint8 public awardsCount;\r\n    mapping(address => mapping(uint8 => uint256)) public awardsOf;\r\n\r\n    function DundieDollar(address exchange)\r\n\tMifflinToken(exchange, 1, 1725000000, \"Dundie Dollar\", \"DUND\", 0) public {\r\n        buyPrice = weiRate / ethDolRate * 10; // 10d\r\n        awards[0] = \"Best Dad Award\";\r\n        awards[1] = \"Best Mom Award\";\r\n        awards[2] = \"Hottest in the Office Award\";\r\n        awards[3] = \"Diabetes Award\";\r\n        awards[4] = \"Promising Assistant Manager Award\";\r\n        awards[5] = \"Cutest Redhead in the Office Award\";\r\n        awards[6] = \"Best Host Award\";\r\n        awards[7] = \"Doobie Doobie Pothead Stoner of the Year Award\";\r\n        awards[8] = \"Extreme Repulsiveness Award\";\r\n        awards[9] = \"Redefining Beauty Award\";\r\n        awards[10] = \"Kind of A Bitch Award\";\r\n        awards[11] = \"Moving On Up Award\";\r\n        awards[12] = \"Worst Salesman of the Year\";\r\n        awards[13] = \"Busiest Beaver Award\";\r\n        awards[14] = \"Tight-Ass Award\";\r\n        awards[15] = \"Spicy Curry Award\";\r\n        awards[16] = \"Don't Go in There After Me\";\r\n        awards[17] = \"Fine Work Award\";\r\n        awards[18] = \"Whitest Sneakers Award\";\r\n        awards[19] = \"Great Work Award\";\r\n        awards[20] = \"Longest Engagement Award\";\r\n        awards[21] = \"Show Me the Money Award\";\r\n        awards[22] = \"Best Boss Award\";\r\n        awards[23] = \"Grace Under Fire Award\";\r\n        awardsCount = 24;\r\n    }\r\n\r\n    function addAward(string name) public onlyOwners{\r\n        awards[awardsCount] = name;\r\n        awardsCount++;\r\n    }\r\n\r\n    function () payable public {\r\n        contribution(msg.value);\r\n        uint256 amountToGive = msg.value / buyPrice;\r\n        buy(amountToGive);\r\n    }\r\n\r\n    function transfer(address _from, address _to, uint _value) internal {\r\n        super.transfer(_from,_to,_value);\r\n        transferAwards(_from,_to,_value);\r\n    }\r\n\r\n\t//This should only be called from the above function\r\n    function transferAwards(address _from, address _to, uint _value) internal {\r\n        uint256 lastBlockHash = uint256(keccak256(block.blockhash(block.number - 1), uint8(0))) + _value;\r\n        uint8 award = uint8(lastBlockHash % awardsCount);\r\n        if(_from == address(this)) {\r\n            //dont need to loop through awards\r\n            transferAwards(_from,_to,award,_value);\r\n\r\n        } else { // only take awards that they have\r\n            uint left = _value;\r\n      \r\n      \t\tfor (uint8 i = 0; i < awardsCount; i++) {\r\n                uint256 bal = awardBalanceOf(_from,award);\r\n                if(bal > 0){\r\n                    if(bal < left) {\r\n                        transferAwards(_from,_to,award,bal);\r\n                        left -= bal;\r\n                    } else {\r\n                    \ttransferAwards(_from,_to,award,left);\r\n                        left = 0;\r\n                    }\r\n                }\r\n                if(left == 0) break;\r\n                award ++;\r\n                if(award == awardsCount - 1) award = 0; // reset\r\n            }\r\n        }\r\n    }\r\n    \r\n    function transferAwards(address from, address to, uint8 award , uint value) internal {\r\n        //dont try to take specific awards from the contract\r\n        if(from != address(this)) {\r\n            require(awardBalanceOf(from,award) >= value );\r\n            awardsOf[from][award] -= value;\r\n        }\r\n        //dont try to send specific awards to the contract\r\n        if(to != address(this)) awardsOf[to][award] += value;\r\n    }\r\n    \r\n\r\n    function awardBalanceOf(address addy,uint8 award) view public returns(uint){\r\n        return awardsOf[addy][award];\r\n    }\r\n    \r\n    function awardName(uint8 id) view public returns(string) {\r\n        return awards[id];\r\n    }\r\n}\r\n\r\n\r\ncontract MifflinMarket is Owned {\r\n    mapping(uint8 => address) public tokenIds;\r\n    //mapping(uint8 => mapping(uint8 => uint256)) exchangeRates;\r\n    mapping(uint8 => mapping(uint8 => int256)) public totalExchanged;\r\n    uint8 rewardTokenId = 1;\r\n    bool active;\r\n    \r\n     function MifflinMarket() public {\r\n         active = true;\r\n     }\r\n    \r\n     modifier onlyTokens {\r\n        MifflinToken mt = MifflinToken(msg.sender);\r\n        // make sure sender is a token contract\r\n        require(tokenIds[mt.tokenId()] == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function setToken(uint8 tid,address addy) public onlyOwnerOrigin { // Only add tokens that were created by exchange owner\r\n        tokenIds[tid] = addy;\r\n    }\r\n\r\n    function removeToken(uint8 id) public onlyOwner { // Only add tokens that were created by owner\r\n        tokenIds[id] = 0;\r\n    }\r\n    \r\n    function setActive(bool act) public onlyOwner {\r\n        active = act;\r\n    }\r\n\r\n    function getRewardToken() public view returns(MifflinToken){\r\n        return getTokenById(rewardTokenId);\r\n    }\r\n\r\n    function getTokenById(uint8 id) public view returns(MifflinToken){\r\n        require(tokenIds[id] > 0);\r\n        return MifflinToken(tokenIds[id]);\r\n    }\r\n    \r\n    function getTokenByAddress(address addy) public view returns(MifflinToken){\r\n        MifflinToken token = MifflinToken(addy);\r\n        uint8 tokenId = token.tokenId();\r\n        require(tokenIds[tokenId] == addy);\r\n        return token;\r\n    }\r\n\r\n    function exchangeTokensByAddress(uint256 fromAmount, address from, address to) public {\r\n        require(active);\r\n        uint256 takeAmount = fromAmount;\r\n        MifflinToken fromToken = getTokenByAddress(from);\r\n        MifflinToken toToken = getTokenByAddress(to);\r\n        uint8 fromId = fromToken.tokenId();\r\n        uint8 toId = toToken.tokenId();\r\n        uint256 fromPrice = fromToken.buyPrice();\r\n        uint256 toPrice = toToken.buyPrice();\r\n        uint256 toAmount = fromAmount * fromPrice / toPrice;\r\n        takeAmount = toAmount * toPrice / fromPrice;\r\n        // take fromTokens back to contract\r\n        fromToken.take(msg.sender, takeAmount);\r\n        // give toTokens out from contract\r\n        toToken.give(msg.sender, toAmount);\r\n        // update some stats\r\n        totalExchanged[fromId][toId] += int(toAmount);\r\n        totalExchanged[toId][fromId] -= int(takeAmount);\r\n    }\r\n\r\n    // most basic exchange - just calculates price ratio\r\n    function exchangeTokensById(uint256 fromAmount, uint8 from, uint8 to) public {\r\n        address fromAddress = tokenIds[from];\r\n        address toAddress = tokenIds[to];\r\n        exchangeTokensByAddress(fromAmount,fromAddress,toAddress);\r\n\t    //adjust price?\r\n    }\r\n\r\n    function highContributionAward(address to) public onlyTokens {\r\n        MifflinToken reward = getRewardToken();\r\n        //dont throw an error if there are no more tokens\r\n        if(reward.balanceOf(reward) > 0){\r\n            reward.give(to, 1);\r\n        }\r\n    }\r\n\r\n    function lowContributionAward(address to) public onlyTokens {\r\n        MifflinToken reward = getRewardToken();\r\n        //dont throw an error here since this is just sugar\r\n        if(reward.balanceOf(to) > 0){\r\n            reward.take(to, 1);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"o\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getHour\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getWeekday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"take\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBuyPrice\",\"type\":\"uint256\"}],\"name\":\"setBuyPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getSecond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highestContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"isLeapYear\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint256\"}],\"name\":\"leapYearsBefore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"getDaysInMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"parseTimestampParts\",\"outputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"},{\"name\":\"minute\",\"type\":\"uint8\"},{\"name\":\"second\",\"type\":\"uint8\"},{\"name\":\"weekday\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowestContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"give\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"exchange\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"NapNickel","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001c20e48cc90ac605d8d32c1998fdb1dd55f7f59f","Library":"","SwarmSource":"bzzr://6a0b29b370f571a5a6e9a8eb048d08fce9aab429201f1cf5d78f411e3700594e"}]}