{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n *  @title Smart City Crowdsale contract http://www.smartcitycoin.io\r\n */\r\n\r\ncontract SmartCityToken {\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {}\r\n    \r\n    function setTokenStart(uint256 _newStartTime) public {}\r\n\r\n    function burn() public {}\r\n}\r\n\r\ncontract SmartCityCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    // State\r\n\r\n    struct Account {\r\n        uint256 accounted;   // received amount and bonus\r\n        uint256 received;    // received amount\r\n    }\r\n\r\n    /// Crowdsale participants\r\n    mapping (address => Account) public buyins;\r\n\r\n    /// Balances of Fixed Price sale participants.\r\n    mapping(address => uint256) public purchases;\r\n\r\n    /// Total amount of ether received.\r\n    uint256 public totalReceived = 0;\r\n\r\n    /// Total amount of ether accounted.\r\n    uint256 public totalAccounted = 0;\r\n\r\n    /// Total tokens purchased during Phase 2.\r\n    uint256 public tokensPurchased = 0;\r\n\r\n    /// Total amount of ether which has been finalised.\r\n    uint256 public totalFinalised = 0;\r\n    \r\n    /// Phase 1 end time.\r\n    uint256 public firstPhaseEndTime;\r\n    \r\n    /// Phase 2 start time.\r\n    uint256 public secondPhaseStartTime;\r\n    \r\n    /// Campaign end time.\r\n    uint256 public endTime;\r\n\r\n    /// The price per token aftre Phase 1. Works also as an effective price in Phase 2 for Phase 1 participants.\r\n    uint256 public auctionEndPrice;\r\n    \r\n    /// The price for token within Phase 2 which is effective for those who did not participate in Phase 1\r\n    uint256 public fixedPrice;\r\n\r\n    /// The current percentage of bonus.\r\n    uint256 public currentBonus = 15;\r\n\r\n    /// Bonus that will be applied to purchases if Target is reached in Phase 1. Initially zero.\r\n    uint256 public auctionSuccessBonus = 0;\r\n    \r\n    /// Must be false for any public function to be called.\r\n    bool public paused = false;\r\n    \r\n    /// Campaign is ended\r\n    bool public campaignEnded = false;\r\n\r\n    // Constants after constructor:\r\n\r\n    /// CITY token contract.\r\n    SmartCityToken public tokenContract;\r\n\r\n    /// The owner address.\r\n    address public owner;\r\n\r\n    /// The wallet address.\r\n    address public wallet;\r\n\r\n    /// Sale start time.\r\n    uint256 public startTime;\r\n\r\n    /// Amount of tokens allocated for Phase 1.\r\n    /// Once totalAccounted / currentPrice is greater than this value, Phase 1 ends.\r\n    uint256 public tokenCapPhaseOne;\r\n    \r\n    /// Amount of tokens allocated for Phase 2\r\n    uint256 public tokenCapPhaseTwo;\r\n\r\n\r\n    // Static constants:\r\n\r\n    /// Target\r\n    uint256 constant public FUNDING_GOAL = 109573 ether;\r\n    \r\n    /// Minimum token price after Phase 1 for Phase 2 to be started.\r\n    uint256 constant public TOKEN_MIN_PRICE_THRESHOLD = 100000000; // 0,00001 ETH per 1 CITY\r\n    \r\n    /// Maximum duration of Phase 1\r\n    uint256 constant public FIRST_PHASE_MAX_SPAN = 21 days;\r\n    \r\n    /// Maximum duration of Phase 2\r\n    uint256 constant public SECOND_PHASE_MAX_SPAN = 33 days;\r\n    \r\n    /// Minimum investment amount\r\n    uint256 constant public DUST_LIMIT = 5 finney;\r\n\r\n    /// Number of days from Phase 1 beginning when bonus is available. Bonus percentage drops by 1 percent a day.\r\n    uint256 constant public BONUS_DURATION = 15;\r\n    \r\n    /// Percentage of bonus that will be applied to all purchases if Target is reached in Phase 1\r\n    uint256 constant public SUCCESS_BONUS = 15;\r\n    \r\n    /// token price in Phase 2 is by 20 % higher when resulting auction price\r\n    /// for those who did not participate in auction\r\n    uint256 constant public SECOND_PHASE_PRICE_FACTOR = 20;\r\n\r\n    /// 1e15\r\n    uint256 constant public FACTOR = 1 finney;\r\n\r\n    /// Divisor of the token.\r\n    uint256 constant public DIVISOR = 100000;\r\n\r\n    // Events\r\n\r\n    /// Buyin event.\r\n    event Buyin(address indexed receiver, uint256 accounted, uint256 received, uint256 price);\r\n\r\n    /// Phase 1 just ended.\r\n    event PhaseOneEnded(uint256 price);\r\n    \r\n    /// Phase 2 is engagaed.\r\n    event PhaseTwoStared(uint256 fixedPrice);\r\n\r\n    /// Investement event.\r\n    event Invested(address indexed receiver, uint256 received, uint256 tokens);\r\n\r\n    /// The campaign just ended.\r\n    event Ended(bool goalReached);\r\n\r\n    /// Finalised the purchase for receiver.\r\n    event Finalised(address indexed receiver, uint256 tokens);\r\n\r\n    /// Campaign is over. All accounts finalised.\r\n    event Retired();\r\n    \r\n    // Modifiers\r\n    \r\n    /// Ensure the sale is ended.\r\n    modifier when_ended { require (now >= endTime); _; }\r\n\r\n    /// Ensure sale is not paused.\r\n    modifier when_not_halted { require (!paused); _; }\r\n\r\n    /// Ensure `_receiver` is a participant.\r\n    modifier only_investors(address _receiver) { require (buyins[_receiver].accounted != 0 || purchases[_receiver] != 0); _; }\r\n\r\n    /// Ensure sender is owner.\r\n    modifier only_owner { require (msg.sender == owner); _; }\r\n    \r\n    /// Ensure sale is in progress.\r\n    modifier when_active { require (!campaignEnded); _;}\r\n\r\n    /// Ensure phase 1 is in progress\r\n    modifier only_in_phase_1 { require (now >= startTime && now < firstPhaseEndTime); _; }\r\n    \r\n    /// Ensure phase 1 is over\r\n    modifier after_phase_1 { require (now >= firstPhaseEndTime); _; }\r\n\r\n    /// Ensure phase 2 is in progress\r\n    modifier only_in_phase_2 { require (now >= secondPhaseStartTime && now < endTime); _; }\r\n\r\n    /// Ensure the value sent is above threshold.\r\n    modifier reject_dust { require ( msg.value >= DUST_LIMIT ); _; }\r\n\r\n    // Constructor\r\n\r\n    function SmartCityCrowdsale(\r\n        address _tokenAddress,\r\n        address _owner,\r\n        address _walletAddress,\r\n        uint256 _startTime,\r\n        uint256 _tokenCapPhaseOne,\r\n        uint256 _tokenCapPhaseTwo\r\n    )\r\n        public\r\n    {\r\n        tokenContract = SmartCityToken(_tokenAddress);\r\n        wallet = _walletAddress;\r\n        owner = _owner;\r\n        startTime = _startTime;\r\n        firstPhaseEndTime = startTime.add(FIRST_PHASE_MAX_SPAN);\r\n        secondPhaseStartTime = 253402300799; // initialise by setting to 9999/12/31\r\n        endTime = secondPhaseStartTime.add(SECOND_PHASE_MAX_SPAN);\r\n        tokenCapPhaseOne = _tokenCapPhaseOne;\r\n        tokenCapPhaseTwo = _tokenCapPhaseTwo;\r\n    }\r\n\r\n    /// The default fallback function\r\n    /// Calls buyin or invest function depending on current campaign phase\r\n    /// Throws if campaign has already ended\r\n    function()\r\n        public\r\n        payable\r\n        when_not_halted\r\n        when_active\r\n    {\r\n        if (now >= startTime && now < firstPhaseEndTime) { // phase 1 is ongoing\r\n            _buyin(msg.sender, msg.value);\r\n        }\r\n        else {\r\n            _invest(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    // Phase 1 functions\r\n\r\n    /// buyin function.\r\n    function buyin()\r\n        public\r\n        payable\r\n        when_not_halted\r\n        when_active\r\n        only_in_phase_1\r\n        reject_dust\r\n    {\r\n        _buyin(msg.sender, msg.value);\r\n    }\r\n    \r\n    ///  buyinAs function. takes the receiver address as an argument\r\n    function buyinAs(address _receiver)\r\n        public\r\n        payable\r\n        when_not_halted\r\n        when_active\r\n        only_in_phase_1\r\n        reject_dust\r\n    {\r\n        require (_receiver != address(0));\r\n        _buyin(_receiver, msg.value);\r\n    }\r\n    \r\n    /// internal buyin functionality\r\n    function _buyin(address _receiver, uint256 _value)\r\n        internal\r\n    {\r\n        if (currentBonus > 0) {\r\n            uint256 daysSinceStart = (now.sub(startTime)).div(86400); // # of days\r\n\r\n            if (daysSinceStart < BONUS_DURATION &&\r\n                BONUS_DURATION.sub(daysSinceStart) != currentBonus) {\r\n                currentBonus = BONUS_DURATION.sub(daysSinceStart);\r\n            }\r\n            if (daysSinceStart >= BONUS_DURATION) {\r\n                currentBonus = 0;\r\n            }\r\n        }\r\n\r\n        uint256 accounted;\r\n        bool refund;\r\n        uint256 price;\r\n\r\n        (accounted, refund, price) = theDeal(_value);\r\n\r\n        // effective cap should not be exceeded, throw\r\n        require (!refund);\r\n\r\n        // change state\r\n        buyins[_receiver].accounted = buyins[_receiver].accounted.add(accounted);\r\n        buyins[_receiver].received = buyins[_receiver].received.add(_value);\r\n        totalAccounted = totalAccounted.add(accounted);\r\n        totalReceived = totalReceived.add(_value);\r\n        firstPhaseEndTime = calculateEndTime();\r\n\r\n        Buyin(_receiver, accounted, _value, price);\r\n\r\n        // send to wallet\r\n        wallet.transfer(_value);\r\n    }\r\n\r\n    /// The current end time of the sale assuming that nobody else buys in.\r\n    function calculateEndTime()\r\n        public\r\n        constant\r\n        when_active\r\n        only_in_phase_1\r\n        returns (uint256)\r\n    {\r\n        uint256 res = (FACTOR.mul(240000).div(DIVISOR.mul(totalAccounted.div(tokenCapPhaseOne)).add(FACTOR.mul(4).div(100)))).add(startTime).sub(4848);\r\n\r\n        if (res >= firstPhaseEndTime) {\r\n            return firstPhaseEndTime;\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    }\r\n    \r\n\r\n    /// The current price for a token\r\n    function currentPrice()\r\n        public\r\n        constant\r\n        when_active\r\n        only_in_phase_1\r\n        returns (uint256 weiPerIndivisibleTokenPart)\r\n    {\r\n        return ((FACTOR.mul(240000).div(now.sub(startTime).add(4848))).sub(FACTOR.mul(4).div(100))).div(DIVISOR);\r\n    }\r\n\r\n    /// Returns the total tokens which can be purchased right now.\r\n    function tokensAvailable()\r\n        public\r\n        constant\r\n        when_active\r\n        only_in_phase_1\r\n        returns (uint256 tokens)\r\n    {\r\n        uint256 _currentCap = totalAccounted.div(currentPrice());\r\n        if (_currentCap >= tokenCapPhaseOne) {\r\n            return 0;\r\n        }\r\n        return tokenCapPhaseOne.sub(_currentCap);\r\n    }\r\n\r\n    /// The largest purchase than can be done right now. For informational puproses only\r\n    function maxPurchase()\r\n        public\r\n        constant\r\n        when_active\r\n        only_in_phase_1\r\n        returns (uint256 spend)\r\n    {\r\n        return tokenCapPhaseOne.mul(currentPrice()).sub(totalAccounted);\r\n    }\r\n\r\n    /// Returns the number of tokens available per given price.\r\n    /// If this number exceeds tokens being currently available, returns refund = true\r\n    function theDeal(uint256 _value)\r\n        public\r\n        constant\r\n        when_active\r\n        only_in_phase_1\r\n        returns (uint256 accounted, bool refund, uint256 price)\r\n    {\r\n        uint256 _bonus = auctionBonus(_value);\r\n\r\n        price = currentPrice();\r\n        accounted = _value.add(_bonus);\r\n\r\n        uint256 available = tokensAvailable();\r\n        uint256 tokens = accounted.div(price);\r\n        refund = (tokens > available);\r\n    }\r\n\r\n    /// Returns bonus for given amount\r\n    function auctionBonus(uint256 _value)\r\n        public\r\n        constant\r\n        when_active\r\n        only_in_phase_1\r\n        returns (uint256 extra)\r\n    {\r\n        return _value.mul(currentBonus).div(100);\r\n    }\r\n\r\n    // After Phase 1\r\n    \r\n    /// Checks the results of the first phase\r\n    /// Changes state only once\r\n    function finaliseFirstPhase()\r\n        public\r\n        when_not_halted\r\n        when_active\r\n        after_phase_1\r\n        returns(uint256)\r\n    {\r\n        if (auctionEndPrice == 0) {\r\n            auctionEndPrice = totalAccounted.div(tokenCapPhaseOne);\r\n            PhaseOneEnded(auctionEndPrice);\r\n\r\n            // check if second phase should be engaged\r\n            if (totalAccounted >= FUNDING_GOAL ) {\r\n                // funding goal is reached: phase 2 is not engaged, all auction participants receive additional bonus, campaign is ended\r\n                auctionSuccessBonus = SUCCESS_BONUS;\r\n                endTime = firstPhaseEndTime;\r\n                campaignEnded = true;\r\n                \r\n                tokenContract.setTokenStart(endTime);\r\n\r\n                Ended(true);\r\n            }\r\n            \r\n            else if (auctionEndPrice >= TOKEN_MIN_PRICE_THRESHOLD) {\r\n                // funding goal is not reached, auctionEndPrice is above or equal to threshold value: engage phase 2\r\n                fixedPrice = auctionEndPrice.add(auctionEndPrice.mul(SECOND_PHASE_PRICE_FACTOR).div(100));\r\n                secondPhaseStartTime = now;\r\n                endTime = secondPhaseStartTime.add(SECOND_PHASE_MAX_SPAN);\r\n\r\n                PhaseTwoStared(fixedPrice);\r\n            }\r\n            else if (auctionEndPrice < TOKEN_MIN_PRICE_THRESHOLD && auctionEndPrice > 0){\r\n                // funding goal is not reached, auctionEndPrice is below threshold value: phase 2 is not engaged, campaign is ended\r\n                endTime = firstPhaseEndTime;\r\n                campaignEnded = true;\r\n\r\n                tokenContract.setTokenStart(endTime);\r\n\r\n                Ended(false);\r\n            }\r\n            else { // no one came, we are all alone in this world :(\r\n                auctionEndPrice = 1 wei;\r\n                endTime = firstPhaseEndTime;\r\n                campaignEnded = true;\r\n\r\n                tokenContract.setTokenStart(endTime);\r\n\r\n                Ended(false);\r\n\r\n                Retired();\r\n            }\r\n        }\r\n        \r\n        return auctionEndPrice;\r\n    }\r\n\r\n    // Phase 2 functions\r\n\r\n    /// Make an investment during second phase\r\n    function invest()\r\n        public\r\n        payable\r\n        when_not_halted\r\n        when_active\r\n        only_in_phase_2\r\n        reject_dust\r\n    {\r\n        _invest(msg.sender, msg.value);\r\n    }\r\n    \r\n    ///\r\n    function investAs(address _receiver)\r\n        public\r\n        payable\r\n        when_not_halted\r\n        when_active\r\n        only_in_phase_2\r\n        reject_dust\r\n    {\r\n        require (_receiver != address(0));\r\n        _invest(_receiver, msg.value);\r\n    }\r\n    \r\n    /// internal invest functionality\r\n    function _invest(address _receiver, uint256 _value)\r\n        internal\r\n    {\r\n        uint256 tokensCnt = getTokens(_receiver, _value); \r\n\r\n        require(tokensCnt > 0);\r\n        require(tokensPurchased.add(tokensCnt) <= tokenCapPhaseTwo); // should not exceed available tokens\r\n        require(_value <= maxTokenPurchase(_receiver)); // should not go above target\r\n\r\n        purchases[_receiver] = purchases[_receiver].add(_value);\r\n        totalReceived = totalReceived.add(_value);\r\n        totalAccounted = totalAccounted.add(_value);\r\n        tokensPurchased = tokensPurchased.add(tokensCnt);\r\n\r\n        Invested(_receiver, _value, tokensCnt);\r\n        \r\n        // send to wallet\r\n        wallet.transfer(_value);\r\n\r\n        // check if we've reached the target\r\n        if (totalAccounted >= FUNDING_GOAL) {\r\n            endTime = now;\r\n            campaignEnded = true;\r\n            \r\n            tokenContract.setTokenStart(endTime);\r\n            \r\n            Ended(true);\r\n        }\r\n    }\r\n    \r\n    /// Tokens currently available for purchase in Phase 2\r\n    function getTokens(address _receiver, uint256 _value)\r\n        public\r\n        constant\r\n        when_active\r\n        only_in_phase_2\r\n        returns(uint256 tokensCnt)\r\n    {\r\n        // auction participants have better price in second phase\r\n        if (buyins[_receiver].received > 0) {\r\n            tokensCnt = _value.div(auctionEndPrice);\r\n        }\r\n        else {\r\n            tokensCnt = _value.div(fixedPrice);\r\n        }\r\n\r\n    }\r\n    \r\n    /// Maximum current purchase amount in Phase 2\r\n    function maxTokenPurchase(address _receiver)\r\n        public\r\n        constant\r\n        when_active\r\n        only_in_phase_2\r\n        returns(uint256 spend)\r\n    {\r\n        uint256 availableTokens = tokenCapPhaseTwo.sub(tokensPurchased);\r\n        uint256 fundingGoalOffset = FUNDING_GOAL.sub(totalReceived);\r\n        uint256 maxInvestment;\r\n        \r\n        if (buyins[_receiver].received > 0) {\r\n            maxInvestment = availableTokens.mul(auctionEndPrice);\r\n        }\r\n        else {\r\n            maxInvestment = availableTokens.mul(fixedPrice);\r\n        }\r\n\r\n        if (maxInvestment > fundingGoalOffset) {\r\n            return fundingGoalOffset;\r\n        }\r\n        else {\r\n            return maxInvestment;\r\n        }\r\n    }\r\n\r\n    // After sale end\r\n    \r\n    /// Finalise purchase: transfers the tokens to caller address\r\n    function finalise()\r\n        public\r\n        when_not_halted\r\n        when_ended\r\n        only_investors(msg.sender)\r\n    {\r\n        finaliseAs(msg.sender);\r\n    }\r\n\r\n    /// Finalise purchase for address provided: transfers the tokens purchased by given participant to their address\r\n    function finaliseAs(address _receiver)\r\n        public\r\n        when_not_halted\r\n        when_ended\r\n        only_investors(_receiver)\r\n    {\r\n        bool auctionParticipant;\r\n        uint256 total;\r\n        uint256 tokens;\r\n        uint256 bonus;\r\n        uint256 totalFixed;\r\n        uint256 tokensFixed;\r\n\r\n        // first time calling finalise after phase 2 has ended but target was not reached\r\n        if (!campaignEnded) {\r\n            campaignEnded = true;\r\n            \r\n            tokenContract.setTokenStart(endTime);\r\n            \r\n            Ended(false);\r\n        }\r\n\r\n        if (buyins[_receiver].accounted != 0) {\r\n            auctionParticipant = true;\r\n\r\n            total = buyins[_receiver].accounted;\r\n            tokens = total.div(auctionEndPrice);\r\n            \r\n            if (auctionSuccessBonus > 0) {\r\n                bonus = tokens.mul(auctionSuccessBonus).div(100);\r\n            }\r\n            totalFinalised = totalFinalised.add(total);\r\n            delete buyins[_receiver];\r\n        }\r\n        \r\n        if (purchases[_receiver] != 0) {\r\n            totalFixed = purchases[_receiver];\r\n            \r\n            if (auctionParticipant) {\r\n                tokensFixed = totalFixed.div(auctionEndPrice);\r\n            }\r\n            else {\r\n                tokensFixed = totalFixed.div(fixedPrice);\r\n            }\r\n            totalFinalised = totalFinalised.add(totalFixed);\r\n            delete purchases[_receiver];\r\n        }\r\n\r\n        tokens = tokens.add(bonus).add(tokensFixed);\r\n\r\n        require (tokenContract.transferFrom(owner, _receiver, tokens));\r\n\r\n        Finalised(_receiver, tokens);\r\n\r\n        if (totalFinalised == totalAccounted) {\r\n            tokenContract.burn(); // burn all unsold tokens\r\n            Retired();\r\n        }\r\n    }\r\n\r\n    // Owner functions\r\n\r\n    /// Emergency function to pause buy-in and finalisation.\r\n    function setPaused(bool _paused) public only_owner { paused = _paused; }\r\n\r\n    /// Emergency function to drain the contract of any funds.\r\n    function drain() public only_owner { wallet.transfer(this.balance); }\r\n    \r\n    /// Returns true if the campaign is in progress.\r\n    function isActive() public constant returns (bool) { return now >= startTime && now < endTime; }\r\n\r\n    /// Returns true if all purchases are finished.\r\n    function allFinalised() public constant returns (bool) { return now >= endTime && totalAccounted == totalFinalised; }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n    /**\r\n    *            CITY token by www.SmartCityCoin.io\r\n    * \r\n    *          .ossssss:                      `+sssss`      \r\n    *         ` +ssssss+` `.://++++++//:.`  .osssss+       \r\n    *            /sssssssssssssssssssssssss+ssssso`        \r\n    *             -sssssssssssssssssssssssssssss+`         \r\n    *            .+sssssssss+:--....--:/ossssssss+.        \r\n    *          `/ssssssssssso`         .sssssssssss/`      \r\n    *         .ossssss+sssssss-       :sssss+:ossssso.     \r\n    *        `ossssso. .ossssss:    `/sssss/  `/ssssss.    \r\n    *        ossssso`   `+ssssss+` .osssss:     /ssssss`   \r\n    *       :ssssss`      /sssssso:ssssso.       +o+/:-`   \r\n    *       osssss+        -sssssssssss+`                  \r\n    *       ssssss:         .ossssssss/                    \r\n    *       osssss/          `+ssssss-                     \r\n    *       /ssssso           :ssssss                      \r\n    *       .ssssss-          :ssssss                      \r\n    *        :ssssss-         :ssssss          `           \r\n    *         /ssssss/`       :ssssss        `/s+:`        \r\n    *          :sssssso:.     :ssssss      ./ssssss+`      \r\n    *           .+ssssssso/-.`:ssssss``.-/osssssss+.       \r\n    *             .+ssssssssssssssssssssssssssss+-         \r\n    *               `:+ssssssssssssssssssssss+:`           \r\n    *                  `.:+osssssssssssso+:.`              \r\n    *                        `/ssssss.`                    \r\n    *                         :ssssss                      \r\n    */","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"SECOND_PHASE_MAX_SPAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"maxTokenPurchase\",\"outputs\":[{\"name\":\"spend\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fixedPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAccounted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getTokens\",\"outputs\":[{\"name\":\"tokensCnt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"campaignEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyins\",\"outputs\":[{\"name\":\"accounted\",\"type\":\"uint256\"},{\"name\":\"received\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondPhaseStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DUST_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FUNDING_GOAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"auctionBonus\",\"outputs\":[{\"name\":\"extra\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionSuccessBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFinalised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstPhaseEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIRST_PHASE_MAX_SPAN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCapPhaseOne\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAvailable\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyin\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_MIN_PRICE_THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SUCCESS_BONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"finaliseAs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPurchase\",\"outputs\":[{\"name\":\"spend\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"weiPerIndivisibleTokenPart\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionEndPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalise\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"theDeal\",\"outputs\":[{\"name\":\"accounted\",\"type\":\"uint256\"},{\"name\":\"refund\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"buyinAs\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCapPhaseTwo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPurchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finaliseFirstPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"investAs\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allFinalised\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SECOND_PHASE_PRICE_FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_walletAddress\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_tokenCapPhaseOne\",\"type\":\"uint256\"},{\"name\":\"_tokenCapPhaseTwo\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"accounted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"received\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Buyin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PhaseOneEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fixedPrice\",\"type\":\"uint256\"}],\"name\":\"PhaseTwoStared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"received\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"goalReached\",\"type\":\"bool\"}],\"name\":\"Ended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Finalised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Retired\",\"type\":\"event\"}]","ContractName":"SmartCityCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008528f649a00ab9afc53b14787ea35705172c244e0000000000000000000000001676ce8401236f40058dc93fabea4cb093f1686a00000000000000000000000051a363281fb1c6cc8d5f587b2db7d415c6f3da41000000000000000000000000000000000000000000000000000000005afa230000000000000000000000000000000000000000000000000000004abe215d3c0000000000000000000000000000000000000000000000000000004abe215ec2a0","Library":"","SwarmSource":"bzzr://809ed358506f16fb30faf43a27fad27a6aaa644bfb228e05313feb91215d1ebd"}]}