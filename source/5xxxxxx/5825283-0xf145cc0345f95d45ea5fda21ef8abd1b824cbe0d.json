{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * ERC721 interface\r\n *\r\n * @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n * @author Yumin.yang\r\n */\r\ncontract ERC721 {\r\n  // Required methods\r\n  function totalSupply() public view returns (uint256 total);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  //function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n  //function approve(address _to, uint256 _tokenId) external;\r\n  function transfer(address _to, uint256 _tokenId) external;\r\n  //function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n  // Events\r\n  event Transfer(address from, address to, uint256 tokenId);\r\n  // event Approval(address owner, address approved, uint256 tokenId);\r\n}\r\n\r\n/**\r\n * First Commons Forum\r\n *\r\n * @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n * @author Yumin.yang\r\n */\r\ncontract DivisibleFirstCommonsForumToken is ERC721 {\r\n\r\n  //This contract's owner\r\n  address private contractOwner;\r\n\r\n  //Participation token storage.\r\n  mapping(uint => ParticipationToken) participationStorage;\r\n\r\n  // Total supply of this token.\r\n  uint public totalSupply = 19;\r\n  bool public tradable = false;\r\n  uint firstCommonsForumId = 1;\r\n\r\n  // Divisibility of ownership over a token\r\n  mapping(address => mapping(uint => uint)) ownerToTokenShare;\r\n\r\n  // How much owners have of a token\r\n  mapping(uint => mapping(address => uint)) tokenToOwnersHoldings;\r\n\r\n  // If First Commons Forum has been created\r\n  mapping(uint => bool) firstCommonsForumCreated;\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals = 0;\r\n  string public version = \"1.0\";\r\n\r\n  // Special participation token\r\n  struct ParticipationToken {\r\n    uint256 participationId;\r\n  }\r\n\r\n  // @dev Constructor\r\n  function DivisibleFirstCommonsForumToken() public {\r\n    contractOwner = msg.sender;\r\n    name = \"FirstCommonsForum\";\r\n    symbol = \"FCFT\";\r\n\r\n    // Create First Commons Forum\r\n    ParticipationToken memory newParticipation = ParticipationToken({ participationId: firstCommonsForumId });\r\n    participationStorage[firstCommonsForumId] = newParticipation;\r\n\r\n    firstCommonsForumCreated[firstCommonsForumId] = true;\r\n    _addNewOwnerHoldingsToToken(contractOwner, firstCommonsForumId, totalSupply);\r\n    _addShareToNewOwner(contractOwner, firstCommonsForumId, totalSupply);\r\n  }\r\n\r\n  // Fallback funciton\r\n  function() public {\r\n    revert();\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256 total) {\r\n    return totalSupply;\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return ownerToTokenShare[_owner][firstCommonsForumId];\r\n  }\r\n\r\n  // We use parameter '_tokenId' as the divisibility\r\n  function transfer(address _to, uint256 _tokenId) external {\r\n\r\n    // Requiring this contract be tradable\r\n    require(tradable == true);\r\n    require(_to != address(0));\r\n    require(msg.sender != _to);\r\n\r\n    // Take _tokenId as divisibility\r\n    uint256 _divisibility = _tokenId;\r\n\r\n    // Requiring msg.sender has Holdings of First Commons Forum\r\n    require(tokenToOwnersHoldings[firstCommonsForumId][msg.sender] >= _divisibility);\r\n\r\n    // Remove divisibilitys from old owner\r\n    _removeShareFromLastOwner(msg.sender, firstCommonsForumId, _divisibility);\r\n    _removeLastOwnerHoldingsFromToken(msg.sender, firstCommonsForumId, _divisibility);\r\n\r\n    // Add divisibilitys to new owner\r\n    _addNewOwnerHoldingsToToken(_to, firstCommonsForumId, _divisibility);\r\n    _addShareToNewOwner(_to, firstCommonsForumId, _divisibility);\r\n\r\n    // Trigger Ethereum Event\r\n    Transfer(msg.sender, _to, firstCommonsForumId);\r\n  }\r\n\r\n  // Transfer participation to a new owner.\r\n  function assignSharedOwnership(address _to, uint256 _divisibility) onlyOwner external returns (bool success) {\r\n\r\n    require(_to != address(0));\r\n    require(msg.sender != _to);\r\n    require(_to != address(this));\r\n\r\n    // Requiring msg.sender has Holdings of First Commons Forum\r\n    require(tokenToOwnersHoldings[firstCommonsForumId][msg.sender] >= _divisibility);\r\n\r\n    // Remove ownership from oldOwner(msg.sender)\r\n    _removeLastOwnerHoldingsFromToken(msg.sender, firstCommonsForumId, _divisibility);\r\n    _removeShareFromLastOwner(msg.sender, firstCommonsForumId, _divisibility);\r\n\r\n    // Add ownership to NewOwner(address _to)\r\n    _addShareToNewOwner(_to, firstCommonsForumId, _divisibility);\r\n    _addNewOwnerHoldingsToToken(_to, firstCommonsForumId, _divisibility);\r\n\r\n    // Trigger Ethereum Event\r\n    Transfer(msg.sender, _to, firstCommonsForumId);\r\n\r\n    return true;\r\n  }\r\n\r\n  function getFirstCommonsForum() public view returns(uint256 _firstCommonsForumId) {\r\n    return participationStorage[firstCommonsForumId].participationId;\r\n  }\r\n\r\n  // Turn on this contract to be tradable, so owners can transfer their token\r\n  function turnOnTradable() public onlyOwner {\r\n    tradable = true;\r\n  }\r\n\r\n  // -------------------- Helper functions (internal functions) --------------------\r\n\r\n  // Add divisibility to new owner\r\n  function _addShareToNewOwner(address _owner, uint _tokenId, uint _units) internal {\r\n    ownerToTokenShare[_owner][_tokenId] += _units;\r\n  }\r\n\r\n  // Add the divisibility to new owner\r\n  function _addNewOwnerHoldingsToToken(address _owner, uint _tokenId, uint _units) internal {\r\n    tokenToOwnersHoldings[_tokenId][_owner] += _units;\r\n  }\r\n\r\n  // Remove divisibility from last owner\r\n  function _removeShareFromLastOwner(address _owner, uint _tokenId, uint _units) internal {\r\n    ownerToTokenShare[_owner][_tokenId] -= _units;\r\n  }\r\n\r\n  // Remove divisibility from last owner\r\n  function _removeLastOwnerHoldingsFromToken(address _owner, uint _tokenId, uint _units) internal {\r\n    tokenToOwnersHoldings[_tokenId][_owner] -= _units;\r\n  }\r\n\r\n  // Withdraw Ether from this contract to Multi sigin wallet\r\n  function withdrawEther() onlyOwner public returns(bool) {\r\n    return contractOwner.send(this.balance);\r\n  }\r\n\r\n  // -------------------- Modifier --------------------\r\n\r\n  modifier onlyExistentToken(uint _tokenId) {\r\n    require(firstCommonsForumCreated[_tokenId] == true);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner(){\r\n    require(msg.sender == contractOwner);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * MultiSig Wallet\r\n *\r\n * @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n * @author Stefan George - <stefan.george@consensys.net>\r\n */\r\ncontract MultiSigWallet {\r\n\r\n  uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n  event Confirmation(address indexed sender, uint indexed transactionId);\r\n  event Revocation(address indexed sender, uint indexed transactionId);\r\n  event Submission(uint indexed transactionId);\r\n  event Execution(uint indexed transactionId);\r\n  event ExecutionFailure(uint indexed transactionId);\r\n  event Deposit(address indexed sender, uint value);\r\n  event OwnerAddition(address indexed owner);\r\n  event OwnerRemoval(address indexed owner);\r\n  event RequirementChange(uint required);\r\n  event CoinCreation(address coin);\r\n\r\n  mapping (uint => Transaction) public transactions;\r\n  mapping (uint => mapping (address => bool)) public confirmations;\r\n  mapping (address => bool) public isOwner;\r\n  address[] public owners;\r\n  uint public required;\r\n  uint public transactionCount;\r\n  bool flag = true;\r\n\r\n  struct Transaction {\r\n    address destination;\r\n    uint value;\r\n    bytes data;\r\n    bool executed;\r\n  }\r\n\r\n  modifier onlyWallet() {\r\n    if (msg.sender != address(this))\r\n    revert();\r\n    _;\r\n  }\r\n\r\n  modifier ownerDoesNotExist(address owner) {\r\n    if (isOwner[owner])\r\n    revert();\r\n    _;\r\n  }\r\n\r\n  modifier ownerExists(address owner) {\r\n    if (!isOwner[owner])\r\n    revert();\r\n    _;\r\n  }\r\n\r\n  modifier transactionExists(uint transactionId) {\r\n    if (transactions[transactionId].destination == 0)\r\n    revert();\r\n    _;\r\n  }\r\n\r\n  modifier confirmed(uint transactionId, address owner) {\r\n    if (!confirmations[transactionId][owner])\r\n    revert();\r\n    _;\r\n  }\r\n\r\n  modifier notConfirmed(uint transactionId, address owner) {\r\n    if (confirmations[transactionId][owner])\r\n    revert();\r\n    _;\r\n  }\r\n\r\n  modifier notExecuted(uint transactionId) {\r\n    if (transactions[transactionId].executed)\r\n    revert();\r\n    _;\r\n  }\r\n\r\n  modifier notNull(address _address) {\r\n    if (_address == 0)\r\n    revert();\r\n    _;\r\n  }\r\n\r\n  modifier validRequirement(uint ownerCount, uint _required) {\r\n    if (ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0)\r\n      revert();\r\n      _;\r\n  }\r\n\r\n  /**\r\n   * @dev Fallback function allows to deposit ether.\r\n   */\r\n  function() payable {\r\n    if (msg.value > 0)\r\n    Deposit(msg.sender, msg.value);\r\n  }\r\n\r\n  /*\r\n   * Public functions\r\n   *\r\n   * @dev Contract constructor sets initial owners and required number of confirmations.\r\n   * @param _owners List of initial owners.\r\n   * @param _required Number of required confirmations.\r\n   */\r\n  function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) {\r\n    for (uint i=0; i<_owners.length; i++) {\r\n      if (isOwner[_owners[i]] || _owners[i] == 0)\r\n      revert();\r\n      isOwner[_owners[i]] = true;\r\n    }\r\n    owners = _owners;\r\n    required = _required;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n   * @param owner Address of new owner.\r\n   */\r\n  function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) {\r\n    isOwner[owner] = true;\r\n    owners.push(owner);\r\n    OwnerAddition(owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n   * @param owner Address of owner.\r\n   */\r\n  function removeOwner(address owner) public onlyWallet ownerExists(owner) {\r\n    isOwner[owner] = false;\r\n    for (uint i=0; i<owners.length - 1; i++)\r\n\r\n    if (owners[i] == owner) {\r\n      owners[i] = owners[owners.length - 1];\r\n      break;\r\n    }\r\n    owners.length -= 1;\r\n\r\n    if (required > owners.length)\r\n    changeRequirement(owners.length);\r\n    OwnerRemoval(owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n   * @param owner Address of owner to be replaced.\r\n   * @param owner Address of new owner.\r\n   */\r\n  function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) {\r\n    for (uint i=0; i<owners.length; i++)\r\n    if (owners[i] == owner) {\r\n      owners[i] = newOwner;\r\n      break;\r\n    }\r\n    isOwner[owner] = false;\r\n    isOwner[newOwner] = true;\r\n    OwnerRemoval(owner);\r\n    OwnerAddition(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n   * @param _required Number of required confirmations.\r\n   */\r\n  function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) {\r\n    required = _required;\r\n    RequirementChange(_required);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an owner to submit and confirm a transaction.\r\n   * @param destination Transaction target address.\r\n   * @param value Transaction ether value.\r\n   * @param data Transaction data payload.\r\n   * @return Returns transaction ID.\r\n   */\r\n  function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) {\r\n    transactionId = addTransaction(destination, value, data);\r\n    confirmTransaction(transactionId);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an owner to confirm a transaction.\r\n   * @param transactionId Transaction ID.\r\n   */\r\n  function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {\r\n    confirmations[transactionId][msg.sender] = true;\r\n    Confirmation(msg.sender, transactionId);\r\n    executeTransaction(transactionId);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an owner to revoke a confirmation for a transaction.\r\n   * @param transactionId Transaction ID.\r\n   */\r\n  function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {\r\n    confirmations[transactionId][msg.sender] = false;\r\n    Revocation(msg.sender, transactionId);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows anyone to execute a confirmed transaction.\r\n   * @param transactionId Transaction ID.\r\n   */\r\n  function executeTransaction(uint transactionId) public notExecuted(transactionId) {\r\n    if (isConfirmed(transactionId)) {\r\n      Transaction tx = transactions[transactionId];\r\n      tx.executed = true;\r\n      if (tx.destination.call.value(tx.value)(tx.data))\r\n      Execution(transactionId);\r\n      else {\r\n        ExecutionFailure(transactionId);\r\n        tx.executed = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the confirmation status of a transaction.\r\n   * @param transactionId Transaction ID.\r\n   * @return Confirmation status.\r\n   */\r\n  function isConfirmed(uint transactionId) public constant returns (bool) {\r\n    uint count = 0;\r\n    for (uint i=0; i<owners.length; i++) {\r\n      if (confirmations[transactionId][owners[i]])\r\n      count += 1;\r\n      if (count == required)\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal functions\r\n   *\r\n   * @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n   * @param destination Transaction target address.\r\n   * @param value Transaction ether value.\r\n   * @param data Transaction data payload.\r\n   * @return Returns transaction ID.\r\n   */\r\n  function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) {\r\n    transactionId = transactionCount;\r\n    transactions[transactionId] = Transaction({\r\n      destination: destination,\r\n      value: value,\r\n      data: data,\r\n      executed: false\r\n    });\r\n    transactionCount += 1;\r\n    Submission(transactionId);\r\n  }\r\n\r\n  /**\r\n   * Web3 call functions\r\n   *\r\n   * @dev Returns number of confirmations of a transaction.\r\n   * @param transactionId Transaction ID.\r\n   * @return Number of confirmations.\r\n   */\r\n  function getConfirmationCount(uint transactionId) public constant returns (uint count) {\r\n    for (uint i=0; i<owners.length; i++)\r\n    if (confirmations[transactionId][owners[i]])\r\n    count += 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns total number of transactions after filers are applied.\r\n   * @param pending Include pending transactions.\r\n   * @param executed Include executed transactions.\r\n   * @return Total number of transactions after filters are applied.\r\n   */\r\n  function getTransactionCount(bool pending, bool executed) public constant returns (uint count) {\r\n    for (uint i=0; i<transactionCount; i++)\r\n    if (   pending && !transactions[i].executed || executed && transactions[i].executed)\r\n      count += 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns list of owners.\r\n   * @return List of owner addresses.\r\n   */\r\n  function getOwners() public constant returns (address[]) {\r\n    return owners;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns array with owner addresses, which confirmed transaction.\r\n   * @param transactionId Transaction ID.\r\n   * @return Returns array of owner addresses.\r\n   */\r\n  function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) {\r\n    address[] memory confirmationsTemp = new address[](owners.length);\r\n    uint count = 0;\r\n    uint i;\r\n    for (i=0; i<owners.length; i++)\r\n    if (confirmations[transactionId][owners[i]]) {\r\n      confirmationsTemp[count] = owners[i];\r\n      count += 1;\r\n    }\r\n    _confirmations = new address[](count);\r\n    for (i=0; i<count; i++)\r\n    _confirmations[i] = confirmationsTemp[i];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns list of transaction IDs in defined range.\r\n   * @param from Index start position of transaction array.\r\n   * @param to Index end position of transaction array.\r\n   * @param pending Include pending transactions.\r\n   * @param executed Include executed transactions.\r\n   * @return Returns array of transaction IDs.\r\n   */\r\n  function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) {\r\n    uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n    uint count = 0;\r\n    uint i;\r\n    for (i=0; i<transactionCount; i++)\r\n    if (pending && !transactions[i].executed || executed && transactions[i].executed) {\r\n        transactionIdsTemp[count] = i;\r\n        count += 1;\r\n    }\r\n      _transactionIds = new uint[](to - from);\r\n      for (i=from; i<to; i++)\r\n      _transactionIds[i - from] = transactionIdsTemp[i];\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner[msg.sender] == true);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Create new first commons forum.\r\n   */\r\n  function createFirstCommonsForum() external onlyWallet {\r\n    require(flag == true);\r\n    CoinCreation(new DivisibleFirstCommonsForumToken());\r\n    flag = false;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_divisibility\",\"type\":\"uint256\"}],\"name\":\"assignSharedOwnership\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"turnOnTradable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstCommonsForum\",\"outputs\":[{\"name\":\"_firstCommonsForumId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"DivisibleFirstCommonsForumToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://76e82435f2f5a27ba5b3f5b261b0e23075300dc4fa5be771fb9437e6d44f5532"}]}