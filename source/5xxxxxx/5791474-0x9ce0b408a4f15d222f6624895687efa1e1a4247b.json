{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**0\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath32\r\n * @dev SafeMath library implemented for uint32\r\n */\r\nlibrary SafeMath32 {\r\n\r\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint32 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath16\r\n * @dev SafeMath library implemented for uint16\r\n */\r\nlibrary SafeMath16 {\r\n\r\n  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint16 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint16 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n    uint16 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ETHERKUN {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n function ETHERKUN() public {\r\n    owner = msg.sender;\r\n }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n    \r\n    using SafeMath for uint256;\r\n    uint cooldownTime = 10 minutes;\r\n    \r\n    struct kun {\r\n        uint price;\r\n        uint atk;\r\n        uint readyTime;\r\n    }\r\n    \r\n    kun[] public kuns;\r\n    \r\n    mapping (uint => address) public kunToOwner;\r\n    \r\n    function getKun() external {\r\n        uint id = kuns.push(kun(0, 0, now)) - 1;\r\n        kunToOwner[id] = msg.sender;\r\n    }\r\n    \r\n    //查询拥有的kun\r\n  function getKunsByOwner(address _owner) external view returns(uint[]) {\r\n    uint[] memory result = new uint[](kuns.length);\r\n    uint counter = 0;\r\n    for (uint i = 0; i < kuns.length; i++) {\r\n      if (kunToOwner[i] == _owner) {\r\n        result[counter] = i;\r\n        counter++;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  \r\n  function getKunsNum() external view returns(uint) {\r\n    return kuns.length;\r\n  }\r\n  \r\n  //\r\n  function getBattleKuns(uint _price) external view returns(uint[]) {\r\n    uint[] memory result = new uint[](kuns.length);\r\n    uint counter = 0;\r\n    for (uint i = 0; i < kuns.length; i++) {\r\n      if (kuns[i].price > _price && kunToOwner[i] != msg.sender) {\r\n        result[counter] = i;\r\n        counter++;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  \r\n  uint randNonce = 0;\r\n    //Evolution price\r\n    uint public testFee = 0.001 ether;\r\n  \r\n  event Evolution(address indexed owner, uint kunId,uint newAtk, uint oldAtk);\r\n  event KunSell(address indexed owner, uint kunId,uint price);\r\n  \r\n  function randMod() internal returns(uint) {\r\n    randNonce = randNonce.add(1);\r\n    return uint(keccak256(now, randNonce, block.blockhash(block.number - 1), block.coinbase)) % 100;\r\n  }\r\n  \r\n  //owner可以调整费率\r\n  function setTestFee(uint _fee) external onlyOwner {\r\n    testFee = _fee;\r\n  }\r\n  //检查必须是拥有者\r\n  modifier onlyOwnerOf(uint _kunId) {\r\n    require(msg.sender == kunToOwner[_kunId]);\r\n    _;\r\n  }\r\n  \r\n    //进入冷却 change to uint\r\n  function _triggerCooldown(kun storage _kun) internal {\r\n    _kun.readyTime = uint(now + cooldownTime);\r\n  }\r\n\r\n  //test逻辑\r\n  function feed1(uint _kunId) external onlyOwnerOf(_kunId) payable {\r\n    require(msg.value == testFee);\r\n    kun storage mykun = kuns[_kunId];\r\n    uint oldAtk = mykun.atk;\r\n    uint random = randMod();\r\n    if (random < 20) {\r\n        mykun.atk = mykun.atk.add(50);\r\n    } else if (random < 70) {\r\n        mykun.atk = mykun.atk.add(100);\r\n    } else if (random < 90) {\r\n        mykun.atk = mykun.atk.add(200);\r\n    } else {\r\n         mykun.atk = mykun.atk.add(500);\r\n    }\r\n    mykun.price = mykun.price.add(msg.value);\r\n    _triggerCooldown(mykun);\r\n    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\r\n  }\r\n  \r\n  function feed10(uint _kunId) external onlyOwnerOf(_kunId) payable {\r\n    require(msg.value == testFee * 10);\r\n    kun storage mykun = kuns[_kunId];\r\n    uint oldAtk = mykun.atk;\r\n    uint random = randMod();\r\n    if (random < 20) {\r\n        mykun.atk = mykun.atk.add(550);\r\n    } else if (random < 70) {\r\n        mykun.atk = mykun.atk.add(1100);\r\n    } else if (random < 90) {\r\n        mykun.atk = mykun.atk.add(2200);\r\n    } else {\r\n         mykun.atk = mykun.atk.add(5500);\r\n    }\r\n    mykun.price = mykun.price.add(msg.value);\r\n    _triggerCooldown(mykun);\r\n    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\r\n  }\r\n  \r\n  function feed50(uint _kunId) external onlyOwnerOf(_kunId) payable {\r\n    require(msg.value == testFee * 50);\r\n    kun storage mykun = kuns[_kunId];\r\n    uint oldAtk = mykun.atk;\r\n    uint random = randMod();\r\n    if (random < 20) {\r\n        mykun.atk = mykun.atk.add(2750);\r\n    } else if (random < 70) {\r\n        mykun.atk = mykun.atk.add(5500);\r\n    } else if (random < 90) {\r\n        mykun.atk = mykun.atk.add(11000);\r\n    } else {\r\n         mykun.atk = mykun.atk.add(27500);\r\n    }\r\n    mykun.price = mykun.price.add(msg.value);\r\n    _triggerCooldown(mykun);\r\n    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\r\n  }\r\n  \r\n  function feed100(uint _kunId) external onlyOwnerOf(_kunId) payable {\r\n    require(msg.value == testFee * 100);\r\n    kun storage mykun = kuns[_kunId];\r\n    uint oldAtk = mykun.atk;\r\n    uint random = randMod();\r\n    if (random < 20) {\r\n        mykun.atk = mykun.atk.add(6000);\r\n    } else if (random < 70) {\r\n        mykun.atk = mykun.atk.add(12000);\r\n    } else if (random < 90) {\r\n        mykun.atk = mykun.atk.add(24000);\r\n    } else {\r\n         mykun.atk = mykun.atk.add(60000);\r\n    }\r\n    mykun.price = mykun.price.add(msg.value);\r\n    _triggerCooldown(mykun);\r\n    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\r\n  }\r\n  \r\n  function feed100AndPay(uint _kunId) external onlyOwnerOf(_kunId) payable {\r\n    require(msg.value == testFee * 110);\r\n    kun storage mykun = kuns[_kunId];\r\n    uint oldAtk = mykun.atk;\r\n    mykun.atk = mykun.atk.add(60000);\r\n    mykun.price = mykun.price.add(testFee * 100);\r\n    owner.transfer(testFee * 10);\r\n    _triggerCooldown(mykun);\r\n    Evolution(msg.sender, _kunId, mykun.atk, oldAtk);\r\n  }\r\n    \r\n    //sellKun\r\n    function sellKun(uint _kunId) external onlyOwnerOf(_kunId) {\r\n        kun storage mykun = kuns[_kunId];\r\n        if(now > mykun.readyTime) {\r\n            msg.sender.transfer(mykun.price);\r\n             KunSell( msg.sender, _kunId, mykun.price);\r\n        } else{\r\n            uint award = mykun.price * 19 / 20;\r\n            msg.sender.transfer(award);\r\n            owner.transfer(mykun.price - award);\r\n             KunSell( msg.sender, _kunId, mykun.price * 19 / 20);\r\n        }\r\n        mykun.price = 0;\r\n        mykun.atk = 0;\r\n        kunToOwner[_kunId] = 0;\r\n    }\r\n    \r\n    event kunAttackResult(address indexed _from,uint atk1, address _to, uint atk2, uint random, uint price);\r\n  \r\n  //判断是否ready\r\n  function _isReady(kun storage _kun) internal view returns (bool) {\r\n      return (_kun.readyTime <= now);\r\n  }\r\n  \r\n  //attack\r\n  function attack(uint _kunId, uint _targetId) external onlyOwnerOf(_kunId) {\r\n    kun storage mykun = kuns[_kunId];\r\n    kun storage enemykun = kuns[_targetId]; \r\n    require(_isReady(enemykun));\r\n    require(enemykun.atk > 299 && mykun.atk > 0);\r\n    uint rand = randMod();\r\n    uint probability = mykun.atk * 100 /(mykun.atk + enemykun.atk) ;\r\n    \r\n    if (rand < probability) {\r\n        //win\r\n        msg.sender.transfer(enemykun.price);\r\n        kunAttackResult(msg.sender, mykun.atk, kunToOwner[_targetId], enemykun.atk, rand, enemykun.price);\r\n        enemykun.price = 0;\r\n        enemykun.atk = 0;\r\n        mykun.readyTime = now;\r\n    } else {\r\n        //loss\r\n        uint award1 = mykun.price*9/10;\r\n        kunToOwner[_targetId].transfer(award1);\r\n        owner.transfer(mykun.price - award1);\r\n        kunAttackResult(msg.sender, mykun.atk, kunToOwner[_targetId], enemykun.atk, rand, mykun.price*9/10);\r\n        mykun.price = 0;\r\n        mykun.atk = 0;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_kunId\",\"type\":\"uint256\"}],\"name\":\"feed100AndPay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kunId\",\"type\":\"uint256\"}],\"name\":\"feed50\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setTestFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getKun\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kunId\",\"type\":\"uint256\"}],\"name\":\"feed10\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"getBattleKuns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"testFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKunsNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kuns\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"atk\",\"type\":\"uint256\"},{\"name\":\"readyTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getKunsByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kunToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kunId\",\"type\":\"uint256\"}],\"name\":\"feed100\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kunId\",\"type\":\"uint256\"}],\"name\":\"feed1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kunId\",\"type\":\"uint256\"},{\"name\":\"_targetId\",\"type\":\"uint256\"}],\"name\":\"attack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kunId\",\"type\":\"uint256\"}],\"name\":\"sellKun\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"kunId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newAtk\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldAtk\",\"type\":\"uint256\"}],\"name\":\"Evolution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"kunId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"KunSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"atk1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"atk2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"random\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"kunAttackResult\",\"type\":\"event\"}]","ContractName":"ETHERKUN","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://23cc1979e6151a498e50b347f7a2a5d66e50a5e94f28af5c2f0b5388c530f3cb"}]}