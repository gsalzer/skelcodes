{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title JointOwnable\r\n * @dev Extension for the Ownable contract, where the owner can assign at most 2 other addresses\r\n *  to manage some functions of the contract, using the eitherOwner modifier.\r\n *  Note that onlyOwner modifier would still be accessible only for the original owner.\r\n */\r\ncontract JointOwnable is Ownable {\r\n\r\n  event AnotherOwnerAssigned(address indexed anotherOwner);\r\n\r\n  address public anotherOwner1;\r\n  address public anotherOwner2;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner or anotherOwner.\r\n   */\r\n  modifier eitherOwner() {\r\n    require(msg.sender == owner || msg.sender == anotherOwner1 || msg.sender == anotherOwner2);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to assign another owner.\r\n   * @param _anotherOwner The address to another owner.\r\n   */\r\n  function assignAnotherOwner1(address _anotherOwner) onlyOwner public {\r\n    require(_anotherOwner != 0);\r\n    AnotherOwnerAssigned(_anotherOwner);\r\n    anotherOwner1 = _anotherOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to assign another owner.\r\n   * @param _anotherOwner The address to another owner.\r\n   */\r\n  function assignAnotherOwner2(address _anotherOwner) onlyOwner public {\r\n    require(_anotherOwner != 0);\r\n    AnotherOwnerAssigned(_anotherOwner);\r\n    anotherOwner2 = _anotherOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens.\r\n */\r\ncontract ERC721 {\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint indexed tokenId);\r\n\r\n    // ERC20 compatible functions.\r\n    // function name() public constant returns (string);\r\n    // function symbol() public constant returns (string);\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n    // Functions that define ownership.\r\n    function ownerOf(uint _tokenId) external view returns (address);\r\n    function transfer(address _to, uint _tokenId) external;\r\n\r\n    // Approval related functions, mainly used in auction contracts.\r\n    function approve(address _to, uint _tokenId) external;\r\n    function approvedFor(uint _tokenId) external view returns (address);\r\n    function transferFrom(address _from, address _to, uint _tokenId) external;\r\n\r\n    /**\r\n     * @dev Each non-fungible token owner can own more than one token at one time.\r\n     * Because each token is referenced by its unique ID, however,\r\n     * it can get difficult to keep track of the individual tokens that a user may own.\r\n     * To do this, the contract keeps a record of the IDs of each token that each user owns.\r\n     */\r\n    mapping(address => uint[]) public ownerTokens;\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title The ERC-721 compliance token contract.\r\n */\r\ncontract ERC721Token is ERC721, Pausable {\r\n\r\n    /* ======== STATE VARIABLES ======== */\r\n\r\n    /**\r\n     * @dev A mapping from token IDs to the address that owns them.\r\n     */\r\n    mapping(uint => address) tokenIdToOwner;\r\n\r\n    /**\r\n     * @dev A mapping from token ids to an address that has been approved to call\r\n     *  transferFrom(). Each token can only have one approved address for transfer\r\n     *  at any time. A zero value means no approval is outstanding.\r\n     */\r\n    mapping (uint => address) tokenIdToApproved;\r\n\r\n    /**\r\n     * @dev A mapping from token ID to index of the ownerTokens' tokens list.\r\n     */\r\n    mapping(uint => uint) tokenIdToOwnerTokensIndex;\r\n\r\n\r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Returns the number of tokens owned by a specific address.\r\n     * @param _owner The owner address to check.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return ownerTokens[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address currently assigned ownership of a given token.\r\n     */\r\n    function ownerOf(uint _tokenId) external view returns (address) {\r\n        require(tokenIdToOwner[_tokenId] != address(0));\r\n\r\n        return tokenIdToOwner[_tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the approved address of a given token.\r\n    */\r\n    function approvedFor(uint _tokenId) external view returns (address) {\r\n        return tokenIdToApproved[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get an array of IDs of each token that an user owns.\r\n     */\r\n    function getOwnerTokens(address _owner) external view returns(uint[]) {\r\n        return ownerTokens[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev External function to transfers a token to another address.\r\n     * @param _to The address of the recipient, can be a user or contract.\r\n     * @param _tokenId The ID of the token to transfer.\r\n     */\r\n    function transfer(address _to, uint _tokenId) whenNotPaused external {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n\r\n        // You can only send your own token.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Grant another address the right to transfer a specific Kitty via\r\n     *  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\r\n     * @param _to The address to be granted transfer approval. Pass address(0) to\r\n     *  clear all approvals.\r\n     * @param _tokenId The ID of the Kitty that can be transferred if this call succeeds.\r\n     */\r\n    function approve(address _to, uint _tokenId) whenNotPaused external {\r\n        // Only an owner can grant transfer approval.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Register the approval (replacing any previous approval).\r\n        _approve(_tokenId, _to);\r\n\r\n        // Emit approval event.\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer a Kitty owned by another address, for which the calling address\r\n     *  has previously been granted transfer approval by the owner.\r\n     * @param _from The address that owns the Kitty to be transfered.\r\n     * @param _to The address that should take ownership of the Kitty. Can be any address,\r\n     *  including the caller.\r\n     * @param _tokenId The ID of the Kitty to be transferred.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _tokenId) whenNotPaused external {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n\r\n        // Check for approval and valid ownership\r\n        require(tokenIdToApproved[_tokenId] == msg.sender);\r\n        require(_owns(_from, _tokenId));\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n\r\n    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Assigns ownership of a specific token to an address.\r\n     */\r\n    function _transfer(address _from, address _to, uint _tokenId) internal {\r\n        // Step 1: Remove token from _form address.\r\n        // When creating new token, _from is 0x0.\r\n        if (_from != address(0)) {\r\n            uint[] storage fromTokens = ownerTokens[_from];\r\n            uint tokenIndex = tokenIdToOwnerTokensIndex[_tokenId];\r\n\r\n            // Put the last token to the transferred token index and update its index in ownerTokensIndexes.\r\n            uint lastTokenId = fromTokens[fromTokens.length - 1];\r\n\r\n            // Do nothing if the transferring token is the last item.\r\n            if (_tokenId != lastTokenId) {\r\n                fromTokens[tokenIndex] = lastTokenId;\r\n                tokenIdToOwnerTokensIndex[lastTokenId] = tokenIndex;\r\n            }\r\n\r\n            fromTokens.length--;\r\n        }\r\n\r\n        // Step 2: Add token to _to address.\r\n        // Transfer ownership.\r\n        tokenIdToOwner[_tokenId] = _to;\r\n\r\n        // Add the _tokenId to ownerTokens[_to] and remember the index in ownerTokensIndexes.\r\n        tokenIdToOwnerTokensIndex[_tokenId] = ownerTokens[_to].length;\r\n        ownerTokens[_to].push(_tokenId);\r\n\r\n        // Emit the Transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Marks an address as being approved for transferFrom(), overwriting any previous\r\n     *  approval. Setting _approved to address(0) clears all transfer approval.\r\n     */\r\n    function _approve(uint _tokenId, address _approved) internal {\r\n        tokenIdToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /**\r\n     * @dev Throws if _dungeonId is not created yet.\r\n     */\r\n    modifier tokenExists(uint _tokenId) {\r\n        require(_tokenId < totalSupply());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a given address is the current owner of a particular token.\r\n     * @param _claimant The address we are validating against.\r\n     * @param _tokenId Token ID\r\n     */\r\n    function _owns(address _claimant, uint _tokenId) internal view returns (bool) {\r\n        return tokenIdToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract EDStructs {\r\n\r\n    /**\r\n     * @dev The main Dungeon struct. Every dungeon in the game is represented by this structure.\r\n     * A dungeon is consists of an unlimited number of floors for your heroes to challenge,\r\n     * the power level of a dungeon is encoded in the floorGenes. Some dungeons are in fact more \"challenging\" than others,\r\n     * the secret formula for that is left for user to find out.\r\n     *\r\n     * Each dungeon also has a \"training area\", heroes can perform trainings and upgrade their stat,\r\n     * and some dungeons are more effective in the training, which is also a secret formula!\r\n     *\r\n     * When player challenge or do training in a dungeon, the fee will be collected as the dungeon rewards,\r\n     * which will be rewarded to the player who successfully challenged the current floor.\r\n     *\r\n     * Each dungeon fits in fits into three 256-bit words.\r\n     */\r\n    struct Dungeon {\r\n\r\n        // Each dungeon has an ID which is the index in the storage array.\r\n\r\n        // The timestamp of the block when this dungeon is created.\r\n        uint32 creationTime;\r\n\r\n        // The status of the dungeon, each dungeon can have 5 status, namely:\r\n        // 0: Active | 1: Transport Only | 2: Challenge Only | 3: Train Only | 4: InActive\r\n        uint8 status;\r\n\r\n        // The dungeon's difficulty, the higher the difficulty,\r\n        // normally, the \"rarer\" the seedGenes, the higher the diffculty,\r\n        // and the higher the contribution fee it is to challenge, train, and transport to the dungeon,\r\n        // the formula for the contribution fee is in DungeonChallenge and DungeonTraining contracts.\r\n        // A dungeon's difficulty never change.\r\n        uint8 difficulty;\r\n\r\n        // The dungeon's capacity, maximum number of players allowed to stay on this dungeon.\r\n        // The capacity of the newbie dungeon (Holyland) is set at 0 (which is infinity).\r\n        // Using 16-bit unsigned integers can have a maximum of 65535 in capacity.\r\n        // A dungeon's capacity never change.\r\n        uint16 capacity;\r\n\r\n        // The current floor number, a dungeon is consists of an umlimited number of floors,\r\n        // when there is heroes successfully challenged a floor, the next floor will be\r\n        // automatically generated. Using 32-bit unsigned integer can have a maximum of 4 billion floors.\r\n        uint32 floorNumber;\r\n\r\n        // The timestamp of the block when the current floor is generated.\r\n        uint32 floorCreationTime;\r\n\r\n        // Current accumulated rewards, successful challenger will get a large proportion of it.\r\n        uint128 rewards;\r\n\r\n        // The seed genes of the dungeon, it is used as the base gene for first floor,\r\n        // some dungeons are rarer and some are more common, the exact details are,\r\n        // of course, top secret of the game!\r\n        // A dungeon's seedGenes never change.\r\n        uint seedGenes;\r\n\r\n        // The genes for current floor, it encodes the difficulty level of the current floor.\r\n        // We considered whether to store the entire array of genes for all floors, but\r\n        // in order to save some precious gas we're willing to sacrifice some functionalities with that.\r\n        uint floorGenes;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev The main Hero struct. Every hero in the game is represented by this structure.\r\n     */\r\n    struct Hero {\r\n\r\n        // Each hero has an ID which is the index in the storage array.\r\n\r\n        // The timestamp of the block when this dungeon is created.\r\n        uint64 creationTime;\r\n\r\n        // The timestamp of the block where a challenge is performed, used to calculate when a hero is allowed to engage in another challenge.\r\n        uint64 cooldownStartTime;\r\n\r\n        // Every time a hero challenge a dungeon, its cooldown index will be incremented by one.\r\n        uint32 cooldownIndex;\r\n\r\n        // The seed of the hero, the gene encodes the power level of the hero.\r\n        // This is another top secret of the game! Hero's gene can be upgraded via\r\n        // training in a dungeon.\r\n        uint genes;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract HeroTokenInterface is ERC721, EDStructs {\r\n\r\n    /**\r\n     * @dev Name of token.\r\n     */\r\n    string public constant name = \"Hero\";\r\n\r\n    /**\r\n     * @dev Symbol of token.\r\n     */\r\n    string public constant symbol = \"HERO\";\r\n\r\n    /**\r\n     * @dev An array containing the Hero struct, which contains all the heroes in existance.\r\n     *  The ID for each hero is the index of this array.\r\n     */\r\n    Hero[] public heroes;\r\n\r\n    /**\r\n     * @dev An external function that creates a new hero and stores it,\r\n     *  only contract owners can create new token.\r\n     *  method doesn't do any checking and should only be called when the\r\n     *  input data is known to be valid.\r\n     * @param _genes The gene of the new hero.\r\n     * @param _owner The inital owner of this hero.\r\n     * @return The hero ID of the new hero.\r\n     */\r\n    function createHero(uint _genes, address _owner) external returns (uint);\r\n\r\n    /**\r\n     * @dev The external function to set the hero genes by its ID,\r\n     *  only contract owners can alter hero state.\r\n     */\r\n    function setHeroGenes(uint _id, uint _newGenes) external;\r\n\r\n    /**\r\n     * @dev Set the cooldownStartTime for the given hero. Also increments the cooldownIndex.\r\n     */\r\n    function triggerCooldown(uint _id) external;\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title The ERC-721 compliance token contract for the Hero tokens.\r\n * @dev See the DungeonStructs contract to see the details of the Hero token data structure.\r\n */\r\ncontract HeroToken is HeroTokenInterface, ERC721Token, JointOwnable {\r\n\r\n\r\n    /* ======== EVENTS ======== */\r\n\r\n    /**\r\n     * @dev The Mint event is fired whenever a new hero is created.\r\n     */\r\n    event Mint(address indexed owner, uint newTokenId, uint genes);\r\n\r\n\r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens currently in existence.\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return heroes.length;\r\n    }\r\n\r\n    /**\r\n     * @dev An external function that creates a new hero and stores it,\r\n     *  only contract owners can create new token.\r\n     *  method doesn't do any checking and should only be called when the\r\n     *  input data is known to be valid.\r\n     * @param _genes The gene of the new hero.\r\n     * @param _owner The inital owner of this hero.\r\n     * @return The hero ID of the new hero.\r\n     */\r\n    function createHero(uint _genes, address _owner) eitherOwner external returns (uint) {\r\n        return _createHero(_genes, _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to set the hero genes by its ID,\r\n     *  only contract owners can alter hero state.\r\n     */\r\n    function setHeroGenes(uint _id, uint _newGenes) eitherOwner tokenExists(_id) external {\r\n        heroes[_id].genes = _newGenes;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the cooldownStartTime for the given hero. Also increments the cooldownIndex.\r\n     */\r\n    function triggerCooldown(uint _id) eitherOwner tokenExists(_id) external {\r\n        Hero storage hero = heroes[_id];\r\n\r\n        hero.cooldownStartTime = uint64(now);\r\n        hero.cooldownIndex++;\r\n    }\r\n\r\n\r\n    /* ======== PRIVATE/INTERNAL FUNCTIONS ======== */\r\n\r\n    function _createHero(uint _genes, address _owner) private returns (uint) {\r\n        // ** STORAGE UPDATE **\r\n        // Create a new hero.\r\n        heroes.push(Hero(uint64(now), 0, 0, _genes));\r\n\r\n        // Token id is the index in the storage array.\r\n        uint newTokenId = heroes.length - 1;\r\n\r\n        // Emit the token mint event.\r\n        Mint(_owner, newTokenId, _genes);\r\n\r\n        // This will assign ownership, and also emit the Transfer event.\r\n        _transfer(0, _owner, newTokenId);\r\n\r\n        return newTokenId;\r\n    }\r\n\r\n\r\n    /* ======== MIGRATION FUNCTIONS ======== */\r\n\r\n\r\n    /**\r\n     * @dev Since the HeroToken contract is re-deployed due to optimization.\r\n     *  We need to migrate all heroes from Beta token contract to Version 1.\r\n     */\r\n    function migrateHero(uint _genes, address _owner) external {\r\n        // Migration will be finished before maintenance period ends, tx.origin is used within a short period only.\r\n        require(now < 1520694000 && tx.origin == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);\r\n\r\n        _createHero(_genes, _owner);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721DutchAuction\r\n * @dev Dutch auction / Decreasing clock auction for ERC721 tokens.\r\n */\r\ncontract ERC721DutchAuction is Ownable, Pausable {\r\n\r\n    /* ======== STRUCTS/ENUMS ======== */\r\n\r\n    // Represents an auction of an ERC721 token.\r\n    struct Auction {\r\n\r\n        // Current owner of the ERC721 token.\r\n        address seller;\r\n\r\n        // Price (in wei) at beginning of auction.\r\n        uint128 startingPrice;\r\n\r\n        // Price (in wei) at end of auction.\r\n        uint128 endingPrice;\r\n\r\n        // Duration (in seconds) of auction.\r\n        uint64 duration;\r\n\r\n        // Time when auction started.\r\n        // NOTE: 0 if this auction has been concluded.\r\n        uint64 startedAt;\r\n\r\n    }\r\n\r\n\r\n    /* ======== CONTRACTS ======== */\r\n\r\n    // Reference to contract tracking ERC721 token ownership.\r\n    ERC721 public nonFungibleContract;\r\n\r\n\r\n    /* ======== STATE VARIABLES ======== */\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint public ownerCut;\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping (uint => Auction) tokenIdToAuction;\r\n\r\n\r\n    /* ======== EVENTS ======== */\r\n\r\n    event AuctionCreated(uint timestamp, address indexed seller, uint indexed tokenId, uint startingPrice, uint endingPrice, uint duration);\r\n    event AuctionSuccessful(uint timestamp, address indexed seller, uint indexed tokenId, uint totalPrice, address winner);\r\n    event AuctionCancelled(uint timestamp, address indexed seller, uint indexed tokenId);\r\n\r\n    /**\r\n     * @dev Constructor creates a reference to the ERC721 token ownership contract and verifies the owner cut is in the valid range.\r\n     * @param _tokenAddress - address of a deployed contract implementing the Nonfungible Interface.\r\n     * @param _ownerCut - percent cut the owner takes on each auction, must be between 0-10,000.\r\n     */\r\n    function ERC721DutchAuction(address _tokenAddress, uint _ownerCut) public {\r\n        require(_ownerCut <= 10000);\r\n\r\n        nonFungibleContract = ERC721(_tokenAddress);\r\n        ownerCut = _ownerCut;\r\n    }\r\n\r\n\r\n    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Bids on an open auction, completing the auction and transferring\r\n     *  ownership of the token if enough Ether is supplied.\r\n     * @param _tokenId - ID of token to bid on.\r\n     */\r\n    function bid(uint _tokenId) whenNotPaused external payable {\r\n        // _bid will throw if the bid or funds transfer fails.\r\n        _bid(_tokenId, msg.value);\r\n\r\n        // Transfers the token owned by this contract to another address. It will throw if transfer fails.\r\n        nonFungibleContract.transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels an auction that hasn't been won yet. Returns the token to original owner.\r\n     * @notice This is a state-modifying function that can be called while the contract is paused.\r\n     * @param _tokenId - ID of token on auction\r\n     */\r\n    function cancelAuction(uint _tokenId) external {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels an auction when the contract is paused.\r\n     *  Only the owner may do this, and tokens are returned to\r\n     *  the seller. This should only be used in emergencies.\r\n     * @param _tokenId - ID of the token on auction to cancel.\r\n     */\r\n    function cancelAuctionWhenPaused(uint _tokenId) whenPaused onlyOwner external {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove all Ether from the contract, which is the owner's cuts\r\n     *  as well as any Ether sent directly to the contract address.\r\n     */\r\n    function withdrawBalance() onlyOwner external {\r\n        msg.sender.transfer(this.balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns auction info for an token on auction.\r\n     * @param _tokenId - ID of token on auction.\r\n     */\r\n    function getAuction(uint _tokenId) external view returns (\r\n        address seller,\r\n        uint startingPrice,\r\n        uint endingPrice,\r\n        uint duration,\r\n        uint startedAt\r\n    ) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n\r\n        return (\r\n            auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current price of an auction.\r\n     * @param _tokenId - ID of the token price we are checking.\r\n     */\r\n    function getCurrentPrice(uint _tokenId) external view returns (uint) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n\r\n        return _computeCurrentPrice(auction);\r\n    }\r\n\r\n\r\n    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Creates and begins a new auction. Perform all the checkings necessary.\r\n     * @param _tokenId - ID of token to auction, sender must be owner.\r\n     * @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n     * @param _endingPrice - Price of item (in wei) at end of auction.\r\n     * @param _duration - Length of time to move between starting\r\n     *  price and ending price (in seconds).\r\n     * @param _seller - Seller, if not the message sender\r\n     */\r\n    function _createAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _duration,\r\n        address _seller\r\n    ) internal {\r\n        // Sanity check that no inputs overflow how many bits we've allocated to store them in the auction struct.\r\n        require(_startingPrice == uint(uint128(_startingPrice)));\r\n        require(_endingPrice == uint(uint128(_endingPrice)));\r\n        require(_duration == uint(uint64(_duration)));\r\n\r\n        // If the token is already on any auction, this will throw\r\n        // because it will be owned by the auction contract.\r\n        require(nonFungibleContract.ownerOf(_tokenId) == msg.sender);\r\n\r\n        // Throw if the _endingPrice is larger than _startingPrice.\r\n        require(_startingPrice >= _endingPrice);\r\n\r\n        // Require that all auctions have a duration of at least one minute.\r\n        require(_duration >= 1 minutes);\r\n\r\n        // Transfer the token from its owner to this contract. It will throw if transfer fails.\r\n        nonFungibleContract.transferFrom(msg.sender, this, _tokenId);\r\n\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds an auction to the list of open auctions. Also fires the\r\n     *  AuctionCreated event.\r\n     * @param _tokenId The ID of the token to be put on auction.\r\n     * @param _auction Auction to add.\r\n     */\r\n    function _addAuction(uint _tokenId, Auction _auction) internal {\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        AuctionCreated(\r\n            now,\r\n            _auction.seller,\r\n            _tokenId,\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the price and transfers winnings.\r\n     *  Does NOT transfer ownership of token.\r\n     */\r\n    function _bid(uint _tokenId, uint _bidAmount) internal returns (uint) {\r\n        // Get a reference to the auction struct\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n        // Explicitly check that this auction is currently live.\r\n        // (Because of how Ethereum mappings work, we can't just count\r\n        // on the lookup above failing. An invalid _tokenId will just\r\n        // return an auction object that is all zeros.)\r\n        require(_isOnAuction(auction));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint price = _computeCurrentPrice(auction);\r\n        require(_bidAmount >= price);\r\n\r\n        // Grab a reference to the seller before the auction struct\r\n        // gets deleted.\r\n        address seller = auction.seller;\r\n\r\n        // The bid is good! Remove the auction before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        _removeAuction(_tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the auctioneer's cut.\r\n            uint auctioneerCut = price * ownerCut / 10000;\r\n            uint sellerProceeds = price - auctioneerCut;\r\n\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint bidExcess = _bidAmount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the auction is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        AuctionSuccessful(now, seller, _tokenId, price, msg.sender);\r\n\r\n        return price;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels an auction unconditionally.\r\n     */\r\n    function _cancelAuction(uint _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n\r\n        // Transfers the token owned by this contract to its original owner. It will throw if transfer fails.\r\n        nonFungibleContract.transfer(_seller, _tokenId);\r\n\r\n        AuctionCancelled(now, _seller, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an auction from the list of open auctions.\r\n     * @param _tokenId - ID of token on auction.\r\n     */\r\n    function _removeAuction(uint _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns current price of an token on auction. Broken into two\r\n     *  functions (this one, that computes the duration from the auction\r\n     *  structure, and the other that does the price computation) so we\r\n     *  can easily test that the price computation works correctly.\r\n     */\r\n    function _computeCurrentPrice(Auction storage _auction) internal view returns (uint) {\r\n        uint secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarnatees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        if (secondsPassed >= _auction.duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the auction, just return the end price.\r\n            return _auction.endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int totalPriceChange = int(_auction.endingPrice) - int(_auction.startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int currentPriceChange = totalPriceChange * int(secondsPassed) / int(_auction.duration);\r\n\r\n            // currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that startingPrice. Thus, this result will always end up positive.\r\n            int currentPrice = int(_auction.startingPrice) + currentPriceChange;\r\n\r\n            return uint(currentPrice);\r\n        }\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /**\r\n     * @dev Returns true if the token is on auction.\r\n     * @param _auction - Auction to check.\r\n     */\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract HeroTokenAuction is HeroToken, ERC721DutchAuction {\r\n\r\n    function HeroTokenAuction(uint _ownerCut) ERC721DutchAuction(this, _ownerCut) public { }\r\n\r\n    /**\r\n     * @dev Creates and begins a new auction.\r\n     * @param _tokenId - ID of token to auction, sender must be owner.\r\n     * @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n     * @param _endingPrice - Price of item (in wei) at end of auction.\r\n     * @param _duration - Length of time to move between starting price and ending price (in seconds).\r\n     */\r\n    function createAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _duration\r\n    ) whenNotPaused external {\r\n        _approve(_tokenId, this);\r\n\r\n        // This will perform all the checkings necessary.\r\n        _createAuction(_tokenId, _startingPrice, _endingPrice, _duration, msg.sender);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createHero\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_newGenes\",\"type\":\"uint256\"}],\"name\":\"setHeroGenes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anotherOwner1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approvedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_anotherOwner\",\"type\":\"address\"}],\"name\":\"assignAnotherOwner2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"triggerCooldown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"heroes\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint64\"},{\"name\":\"cooldownStartTime\",\"type\":\"uint64\"},{\"name\":\"cooldownIndex\",\"type\":\"uint32\"},{\"name\":\"genes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"migrateHero\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anotherOwner2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwnerTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_anotherOwner\",\"type\":\"address\"}],\"name\":\"assignAnotherOwner1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genes\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"anotherOwner\",\"type\":\"address\"}],\"name\":\"AnotherOwnerAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"HeroTokenAuction","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000b4","Library":"","SwarmSource":"bzzr://7e9038a0e73d7e2e17db249b8952cbc756a8f062d3c8f0b138e3ee5375b166ef"}]}