{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface AssetInterface {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    // Events\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n\r\n    //ERC 223\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\r\n\r\n    // ERC 20\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    // PUBLIC VIEW METHODS\r\n    function balanceOf(address _owner) view public returns (uint balance);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n}\r\n\r\ninterface ERC223Interface {\r\n    function balanceOf(address who) constant returns (uint);\r\n    function transfer(address to, uint value) returns (bool);\r\n    function transfer(address to, uint value, bytes data) returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\ncontract Asset is DSMath, AssetInterface, ERC223Interface {\r\n\r\n    // DATA STRUCTURES\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint codeLength;\r\n        bytes memory empty;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n \r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        // if (codeLength > 0) {\r\n        //     ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n        //     receiver.tokenFallback(msg.sender, _value, empty);\r\n        // }\r\n        Transfer(msg.sender, _to, _value, empty);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender` and trigger tokenFallback if sender is a contract\r\n     * @dev Function that is called when a user or contract wants to transfer funds\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @param _data Data to be sent to tokenFallback\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value, bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        // if (codeLength > 0) {\r\n        //     ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n        //     receiver.tokenFallback(msg.sender, _value, _data);\r\n        // }\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    /// @notice Restriction: An account can only use this function to send to itself\r\n    /// @dev Allows for an approved third party to transfer tokens from one\r\n    /// address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_from != 0x0);\r\n        require(_to != 0x0);\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n        // require(_to == msg.sender); // can only use transferFrom to send to self\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(_spender != 0x0);\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        // allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        // already 0 to mitigate the race condition described here:\r\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        // require(_value == 0 || allowed[msg.sender][_spender] == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @dev Returns number of allowed tokens that a spender can transfer on\r\n    /// behalf of a token owner.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    /// @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by the given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns balance of owner.\r\n    function balanceOf(address _owner) constant public returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\ninterface ERC223ReceivingContract {\r\n\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param _from Transaction initiator, analogue of msg.sender\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @param _data Data containing a function signature and/or parameters\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) public;\r\n}\r\n\r\ncontract SimpleAdapter {\r\n\r\n    // CONSTANT FIELDS\r\n\r\n    bool public constant approveOnly = false; // If the exchange implementation requires asset approve instead of transfer on make orders\r\n\r\n    // EVENTS\r\n\r\n    event OrderUpdated(uint id);\r\n\r\n    // VIEW METHODS\r\n\r\n    function isApproveOnly()\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return approveOnly;\r\n    }\r\n\r\n    function getLastOrderId(address onExchange)\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return SimpleMarket(onExchange).last_offer_id();\r\n    }\r\n\r\n    function isActive(address onExchange, uint id)\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return SimpleMarket(onExchange).isActive(id);\r\n    }\r\n\r\n    function getOwner(address onExchange, uint id)\r\n        constant\r\n        returns (address)\r\n    {\r\n        return SimpleMarket(onExchange).getOwner(id);\r\n    }\r\n\r\n    function getOrder(address onExchange, uint id)\r\n        constant\r\n        returns (address, address, uint, uint)\r\n    {\r\n        var (\r\n            sellQuantity,\r\n            sellAsset,\r\n            buyQuantity,\r\n            buyAsset\r\n        ) = SimpleMarket(onExchange).getOffer(id);\r\n        return (\r\n            address(sellAsset),\r\n            address(buyAsset),\r\n            sellQuantity,\r\n            buyQuantity\r\n        );\r\n    }\r\n\r\n    function getTimestamp(address onExchange, uint id)\r\n        constant\r\n        returns (uint)\r\n    {\r\n        var (, , , , , , timestamp) = SimpleMarket(onExchange).offers(id);\r\n        return timestamp;\r\n    }\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    /// @notice Makes an order on the given exchange\r\n    /// @dev Only use this in context of a delegatecall, as spending of sellAsset need to be approved first\r\n    /// @param onExchange Address of the exchange\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return id Order ID\r\n    function makeOrder(\r\n        address onExchange,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        returns (uint id)\r\n    {\r\n        id = SimpleMarket(onExchange).offer(\r\n            sellQuantity,\r\n            Asset(sellAsset),\r\n            buyQuantity,\r\n            Asset(buyAsset)\r\n        );\r\n        OrderUpdated(id);\r\n    }\r\n\r\n    /// @notice Takes an order on the given exchange\r\n    /// @dev For this subset of adapter no immediate settlement can be expected\r\n    /// @param onExchange Address of the exchange\r\n    /// @param id Order id\r\n    /// @param quantity Quantity of order to be executed (For partial taking)\r\n    /// @return success Whether the takeOrder is successfully executed\r\n    function takeOrder(\r\n        address onExchange,\r\n        uint id,\r\n        uint quantity\r\n    )\r\n        returns (bool success)\r\n    {\r\n        success = SimpleMarket(onExchange).buy(id, quantity);\r\n        OrderUpdated(id);\r\n    }\r\n\r\n    /// @notice Cancels an order on the given exchange\r\n    /// @dev Only use this in context of a delegatecall, as spending of sellAsset need to be approved first\r\n    /// @param onExchange Address of the exchange\r\n    /// @param id Order id\r\n    /// @return success Whether the order is successfully cancelled\r\n    function cancelOrder(\r\n        address onExchange,\r\n        uint id\r\n    )\r\n        returns (bool success)\r\n    {\r\n        success = SimpleMarket(onExchange).cancel(id);\r\n        OrderUpdated(id);\r\n    }\r\n}\r\n\r\ncontract EventfulMarket {\r\n    event LogItemUpdate(uint id);\r\n    event LogTrade(uint pay_amt, address indexed pay_gem,\r\n                   uint buy_amt, address indexed buy_gem);\r\n\r\n    event LogMake(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        Asset             pay_gem,\r\n        Asset             buy_gem,\r\n        uint128           pay_amt,\r\n        uint128           buy_amt,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogBump(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        Asset             pay_gem,\r\n        Asset             buy_gem,\r\n        uint128           pay_amt,\r\n        uint128           buy_amt,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogTake(\r\n        bytes32           id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        Asset             pay_gem,\r\n        Asset             buy_gem,\r\n        address  indexed  taker,\r\n        uint128           take_amt,\r\n        uint128           give_amt,\r\n        uint64            timestamp\r\n    );\r\n\r\n    event LogKill(\r\n        bytes32  indexed  id,\r\n        bytes32  indexed  pair,\r\n        address  indexed  maker,\r\n        Asset             pay_gem,\r\n        Asset             buy_gem,\r\n        uint128           pay_amt,\r\n        uint128           buy_amt,\r\n        uint64            timestamp\r\n    );\r\n}\r\n\r\ncontract SimpleMarket is EventfulMarket, DSMath {\r\n\r\n    uint public last_offer_id;\r\n\r\n    mapping (uint => OfferInfo) public offers;\r\n\r\n    bool locked;\r\n\r\n    struct OfferInfo {\r\n        uint     pay_amt;\r\n        Asset    pay_gem;\r\n        uint     buy_amt;\r\n        Asset    buy_gem;\r\n        address  owner;\r\n        bool     active;\r\n        uint64   timestamp;\r\n    }\r\n\r\n    modifier can_buy(uint id) {\r\n        require(isActive(id));\r\n        _;\r\n    }\r\n\r\n    modifier can_cancel(uint id) {\r\n        require(isActive(id));\r\n        require(getOwner(id) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _;\r\n    }\r\n\r\n    modifier synchronized {\r\n        assert(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function isActive(uint id) constant returns (bool active) {\r\n        return offers[id].active;\r\n    }\r\n\r\n    function getOwner(uint id) constant returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n\r\n    function getOffer(uint id) constant returns (uint, Asset, uint, Asset) {\r\n      var offer = offers[id];\r\n      return (offer.pay_amt, offer.pay_gem,\r\n              offer.buy_amt, offer.buy_gem);\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    function bump(bytes32 id_)\r\n        can_buy(uint256(id_))\r\n    {\r\n        var id = uint256(id_);\r\n        LogBump(\r\n            id_,\r\n            keccak256(offers[id].pay_gem, offers[id].buy_gem),\r\n            offers[id].owner,\r\n            offers[id].pay_gem,\r\n            offers[id].buy_gem,\r\n            uint128(offers[id].pay_amt),\r\n            uint128(offers[id].buy_amt),\r\n            offers[id].timestamp\r\n        );\r\n    }\r\n\r\n    // Accept given `quantity` of an offer. Transfers funds from caller to\r\n    // offer maker, and from market to caller.\r\n    function buy(uint id, uint quantity)\r\n        can_buy(id)\r\n        synchronized\r\n        returns (bool)\r\n    {\r\n        OfferInfo memory offer = offers[id];\r\n        uint spend = mul(quantity, offer.buy_amt) / offer.pay_amt;\r\n\r\n        require(uint128(spend) == spend);\r\n        require(uint128(quantity) == quantity);\r\n\r\n        // For backwards semantic compatibility.\r\n        if (quantity == 0 || spend == 0 ||\r\n            quantity > offer.pay_amt || spend > offer.buy_amt)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        offers[id].pay_amt = sub(offer.pay_amt, quantity);\r\n        offers[id].buy_amt = sub(offer.buy_amt, spend);\r\n        assert( offer.buy_gem.transferFrom(msg.sender, this, spend) );\r\n        assert( offer.buy_gem.transfer(offer.owner, spend) );\r\n        assert( offer.pay_gem.transfer(msg.sender, quantity) );\r\n\r\n        LogItemUpdate(id);\r\n        LogTake(\r\n            bytes32(id),\r\n            keccak256(offer.pay_gem, offer.buy_gem),\r\n            offer.owner,\r\n            offer.pay_gem,\r\n            offer.buy_gem,\r\n            msg.sender,\r\n            uint128(quantity),\r\n            uint128(spend),\r\n            uint64(now)\r\n        );\r\n        LogTrade(quantity, offer.pay_gem, spend, offer.buy_gem);\r\n\r\n        if (offers[id].pay_amt == 0) {\r\n            delete offers[id];\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel(uint id)\r\n        can_cancel(id)\r\n        synchronized\r\n        returns (bool success)\r\n    {\r\n        // read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        assert( offer.pay_gem.transfer(offer.owner, offer.pay_amt) );\r\n\r\n        LogItemUpdate(id);\r\n        LogKill(\r\n            bytes32(id),\r\n            keccak256(offer.pay_gem, offer.buy_gem),\r\n            offer.owner,\r\n            offer.pay_gem,\r\n            offer.buy_gem,\r\n            uint128(offer.pay_amt),\r\n            uint128(offer.buy_amt),\r\n            uint64(now)\r\n        );\r\n\r\n        success = true;\r\n    }\r\n\r\n    function kill(bytes32 id) {\r\n        assert(cancel(uint256(id)));\r\n    }\r\n\r\n    function make(\r\n        Asset    pay_gem,\r\n        Asset    buy_gem,\r\n        uint128  pay_amt,\r\n        uint128  buy_amt\r\n    ) returns (bytes32 id) {\r\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer(uint pay_amt, Asset pay_gem, uint buy_amt, Asset buy_gem)\r\n        can_offer\r\n        synchronized\r\n        returns (uint id)\r\n    {\r\n        require(uint128(pay_amt) == pay_amt);\r\n        require(uint128(buy_amt) == buy_amt);\r\n        require(pay_amt > 0);\r\n        require(pay_gem != Asset(0x0));\r\n        require(buy_amt > 0);\r\n        require(buy_gem != Asset(0x0));\r\n        require(pay_gem != buy_gem);\r\n\r\n        OfferInfo memory info;\r\n        info.pay_amt = pay_amt;\r\n        info.pay_gem = pay_gem;\r\n        info.buy_amt = buy_amt;\r\n        info.buy_gem = buy_gem;\r\n        info.owner = msg.sender;\r\n        info.active = true;\r\n        info.timestamp = uint64(now);\r\n        id = _next_id();\r\n        offers[id] = info;\r\n\r\n        assert( pay_gem.transferFrom(msg.sender, this, pay_amt) );\r\n\r\n        LogItemUpdate(id);\r\n        LogMake(\r\n            bytes32(id),\r\n            keccak256(pay_gem, buy_gem),\r\n            msg.sender,\r\n            pay_gem,\r\n            buy_gem,\r\n            uint128(pay_amt),\r\n            uint128(buy_amt),\r\n            uint64(now)\r\n        );\r\n    }\r\n\r\n    function take(bytes32 id, uint128 maxTakeAmount) {\r\n        assert(buy(uint256(id), maxTakeAmount));\r\n    }\r\n\r\n    function _next_id() internal returns (uint) {\r\n        last_offer_id++; return last_offer_id;\r\n    }\r\n\r\n    function tokenFallback(address ofSender, uint tokenAmount, bytes metadata) {\r\n        return;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"onExchange\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"onExchange\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approveOnly\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onExchange\",\"type\":\"address\"},{\"name\":\"sellAsset\",\"type\":\"address\"},{\"name\":\"buyAsset\",\"type\":\"address\"},{\"name\":\"sellQuantity\",\"type\":\"uint256\"},{\"name\":\"buyQuantity\",\"type\":\"uint256\"}],\"name\":\"makeOrder\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onExchange\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onExchange\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"takeOrder\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"onExchange\",\"type\":\"address\"}],\"name\":\"getLastOrderId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"onExchange\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isApproveOnly\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"onExchange\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OrderUpdated\",\"type\":\"event\"}]","ContractName":"SimpleAdapter","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0dc1ad549cc2353ef0fdd4450e2b77ab2513665be482bfdcc885c7475515eb33"}]}