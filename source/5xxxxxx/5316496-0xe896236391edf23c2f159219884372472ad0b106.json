{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Safe Math Smart Contract.  Copyright © 2016–2017 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.4.16;\r\n\r\n/**\r\n * ERC-20 standard token interface, as defined\r\n * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>.\r\n */\r\ncontract Token {\r\n    /**\r\n     * Get total number of tokens in circulation.\r\n     *\r\n     * @return total number of tokens in circulation\r\n     */\r\n    function totalSupply () constant returns (uint256 supply);\r\n\r\n    /**\r\n     * Get number of tokens currently belonging to given owner.\r\n     *\r\n     * @param _owner address to get number of tokens currently belonging to the\r\n     *        owner of\r\n     * @return number of tokens currently belonging to the owner of given address\r\n     */\r\n    function balanceOf (address _owner) constant returns (uint256 balance);\r\n\r\n    /**\r\n     * Transfer given number of tokens from message sender to given recipient.\r\n     *\r\n     * @param _to address to transfer tokens to the owner of\r\n     * @param _value number of tokens to transfer to the owner of given address\r\n     * @return true if tokens were transferred successfully, false otherwise\r\n     */\r\n    function transfer (address _to, uint256 _value) returns (bool success);\r\n\r\n    /**\r\n     * Transfer given number of tokens from given owner to given recipient.\r\n     *\r\n     * @param _from address to transfer tokens from the owner of\r\n     * @param _to address to transfer tokens to the owner of\r\n     * @param _value number of tokens to transfer from given owner to given\r\n     *        recipient\r\n     * @return true if tokens were transferred successfully, false otherwise\r\n     */\r\n    function transferFrom (address _from, address _to, uint256 _value)\r\n    returns (bool success);\r\n\r\n    /**\r\n     * Allow given spender to transfer given number of tokens from message sender.\r\n     *\r\n     * @param _spender address to allow the owner of to transfer tokens from\r\n     *        message sender\r\n     * @param _value number of tokens to allow to transfer\r\n     * @return true if token transfer was successfully approved, false otherwise\r\n     */\r\n    function approve (address _spender, uint256 _value) returns (bool success);\r\n\r\n    /**\r\n     * Tell how many tokens given spender is currently allowed to transfer from\r\n     * given owner.\r\n     *\r\n     * @param _owner address to get number of tokens allowed to be transferred\r\n     *        from the owner of\r\n     * @param _spender address to get number of tokens allowed to be transferred\r\n     *        by the owner of\r\n     * @return number of tokens given spender is currently allowed to transfer\r\n     *         from given owner\r\n     */\r\n    function allowance (address _owner, address _spender) constant\r\n    returns (uint256 remaining);\r\n\r\n    /**\r\n     * Logged when tokens were transferred from one owner to another.\r\n     *\r\n     * @param _from address of the owner, tokens were transferred from\r\n     * @param _to address of the owner, tokens were transferred to\r\n     * @param _value number of tokens transferred\r\n     */\r\n    event Transfer (address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n     * Logged when owner approved his tokens to be transferred by some spender.\r\n     *\r\n     * @param _owner owner who approved his tokens to be transferred\r\n     * @param _spender spender who were allowed to transfer the tokens belonging\r\n     *        to the owner\r\n     * @param _value number of tokens belonging to the owner, approved to be\r\n     *        transferred by the spender\r\n     */\r\n    event Approval (\r\n        address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n * Provides methods to safely add, subtract and multiply uint256 numbers.\r\n */\r\ncontract SafeMath {\r\n    uint256 constant private MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * Add two uint256 values, throw in case of overflow.\r\n     *\r\n     * @param x first value to add\r\n     * @param y second value to add\r\n     * @return x + y\r\n     */\r\n    function safeAdd (uint256 x, uint256 y)\r\n    constant internal\r\n    returns (uint256 z) {\r\n        assert (x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }\r\n\r\n    /**\r\n     * Subtract one uint256 value from another, throw in case of underflow.\r\n     *\r\n     * @param x value to subtract from\r\n     * @param y value to subtract\r\n     * @return x - y\r\n     */\r\n    function safeSub (uint256 x, uint256 y)\r\n    constant internal\r\n    returns (uint256 z) {\r\n        assert (x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    /**\r\n     * Multiply two uint256 values, throw in case of overflow.\r\n     *\r\n     * @param x first value to multiply\r\n     * @param y second value to multiply\r\n     * @return x * y\r\n     */\r\n    function safeMul (uint256 x, uint256 y)\r\n    constant internal\r\n    returns (uint256 z) {\r\n        if (y == 0) return 0; // Prevent division by zero at the next line\r\n        assert (x <= MAX_UINT256 / y);\r\n        return x * y;\r\n    }\r\n}\r\n\r\n/**\r\n * Math Utilities smart contract.\r\n */\r\ncontract Math is SafeMath {\r\n    /**\r\n     * 2^127.\r\n     */\r\n    uint128 internal constant TWO127 = 0x80000000000000000000000000000000;\r\n\r\n    /**\r\n     * 2^128 - 1.\r\n     */\r\n    uint128 internal constant TWO128_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * 2^128.\r\n     */\r\n    uint256 internal constant TWO128 = 0x100000000000000000000000000000000;\r\n\r\n    /**\r\n     * 2^256 - 1.\r\n     */\r\n    uint256 internal constant TWO256_1 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * 2^255.\r\n     */\r\n    uint256 internal constant TWO255 =\r\n    0x8000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * -2^255.\r\n     */\r\n    int256 internal constant MINUS_TWO255 =\r\n    -0x8000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * 2^255 - 1.\r\n     */\r\n    int256 internal constant TWO255_1 =\r\n    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * ln(2) * 2^128.\r\n     */\r\n    uint128 internal constant LN2 = 0xb17217f7d1cf79abc9e3b39803f2f6af;\r\n\r\n    /**\r\n     * Return index of most significant non-zero bit in given non-zero 256-bit\r\n     * unsigned integer value.\r\n     *\r\n     * @param x value to get index of most significant non-zero bit in\r\n     * @return index of most significant non-zero bit in given number\r\n     */\r\n    function mostSignificantBit (uint256 x) pure internal returns (uint8) {\r\n        require (x > 0);\r\n\r\n        uint8 l = 0;\r\n        uint8 h = 255;\r\n\r\n        while (h > l) {\r\n            uint8 m = uint8 ((uint16 (l) + uint16 (h)) >> 1);\r\n            uint256 t = x >> m;\r\n            if (t == 0) h = m - 1;\r\n            else if (t > 1) l = m + 1;\r\n            else return m;\r\n        }\r\n\r\n        return h;\r\n    }\r\n\r\n    /**\r\n     * Calculate log_2 (x / 2^128) * 2^128.\r\n     *\r\n     * @param x parameter value\r\n     * @return log_2 (x / 2^128) * 2^128\r\n     */\r\n    function log_2 (uint256 x) pure internal returns (int256) {\r\n        require (x > 0);\r\n\r\n        uint8 msb = mostSignificantBit (x);\r\n\r\n        if (msb > 128) x >>= msb - 128;\r\n        else if (msb < 128) x <<= 128 - msb;\r\n\r\n        x &= TWO128_1;\r\n\r\n        int256 result = (int256 (msb) - 128) << 128; // Integer part of log_2\r\n\r\n        int256 bit = TWO127;\r\n        for (uint8 i = 0; i < 128 && x > 0; i++) {\r\n            x = (x << 1) + ((x * x + TWO127) >> 128);\r\n            if (x > TWO128_1) {\r\n                result |= bit;\r\n                x = (x >> 1) - TWO127;\r\n            }\r\n            bit >>= 1;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calculate ln (x / 2^128) * 2^128.\r\n     *\r\n     * @param x parameter value\r\n     * @return ln (x / 2^128) * 2^128\r\n     */\r\n    function ln (uint256 x) pure internal returns (int256) {\r\n        require (x > 0);\r\n\r\n        int256 l2 = log_2 (x);\r\n        if (l2 == 0) return 0;\r\n        else {\r\n            uint256 al2 = uint256 (l2 > 0 ? l2 : -l2);\r\n            uint8 msb = mostSignificantBit (al2);\r\n            if (msb > 127) al2 >>= msb - 127;\r\n            al2 = (al2 * LN2 + TWO127) >> 128;\r\n            if (msb > 127) al2 <<= msb - 127;\r\n\r\n            return int256 (l2 >= 0 ? al2 : -al2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y / 2^128.\r\n     *\r\n     * @param x parameter x\r\n     * @param y parameter y\r\n     * @return x * y / 2^128\r\n     */\r\n    function fpMul (uint256 x, uint256 y) pure internal returns (uint256) {\r\n        uint256 xh = x >> 128;\r\n        uint256 xl = x & TWO128_1;\r\n        uint256 yh = y >> 128;\r\n        uint256 yl = y & TWO128_1;\r\n\r\n        uint256 result = xh * yh;\r\n        require (result <= TWO128_1);\r\n        result <<= 128;\r\n\r\n        result = safeAdd (result, xh * yl);\r\n        result = safeAdd (result, xl * yh);\r\n        result = safeAdd (result, (xl * yl) >> 128);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y.\r\n     *\r\n     * @param x parameter x\r\n     * @param y parameter y\r\n     * @return high and low words of x * y\r\n     */\r\n    function longMul (uint256 x, uint256 y)\r\n    pure internal returns (uint256 h, uint256 l) {\r\n        uint256 xh = x >> 128;\r\n        uint256 xl = x & TWO128_1;\r\n        uint256 yh = y >> 128;\r\n        uint256 yl = y & TWO128_1;\r\n\r\n        h = xh * yh;\r\n        l = xl * yl;\r\n\r\n        uint256 m1 = xh * yl;\r\n        uint256 m2 = xl * yh;\r\n\r\n        h += m1 >> 128;\r\n        h += m2 >> 128;\r\n\r\n        m1 <<= 128;\r\n        m2 <<= 128;\r\n\r\n        if (l > TWO256_1 - m1) h += 1;\r\n        l += m1;\r\n\r\n        if (l > TWO256_1 - m2) h += 1;\r\n        l += m2;\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y / 2^128.\r\n     *\r\n     * @param x parameter x\r\n     * @param y parameter y\r\n     * @return x * y / 2^128\r\n     */\r\n    function fpMulI (int256 x, int256 y) pure internal returns (int256) {\r\n        bool negative = (x ^ y) < 0; // Whether result is negative\r\n\r\n        uint256 result = fpMul (\r\n            x < 0 ? uint256 (-1 - x) + 1 : uint256 (x),\r\n            y < 0 ? uint256 (-1 - y) + 1 : uint256 (y));\r\n\r\n        if (negative) {\r\n            require (result <= TWO255);\r\n            return result == 0 ? 0 : -1 - int256 (result - 1);\r\n        } else {\r\n            require (result < TWO255);\r\n            return int256 (result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x + y, throw in case of over-/underflow.\r\n     *\r\n     * @param x parameter x\r\n     * @param y parameter y\r\n     * @return x + y\r\n     */\r\n    function safeAddI (int256 x, int256 y) pure internal returns (int256) {\r\n        if (x < 0 && y < 0)\r\n            assert (x >= MINUS_TWO255 - y);\r\n\r\n        if (x > 0 && y > 0)\r\n            assert (x <= TWO255_1 - y);\r\n\r\n        return x + y;\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y * 2^128.\r\n     *\r\n     * @param x parameter x\r\n     * @param y parameter y\r\n     * @return  x / y * 2^128\r\n     */\r\n    function fpDiv (uint256 x, uint256 y) pure internal returns (uint256) {\r\n        require (y > 0); // Division by zero is forbidden\r\n\r\n        uint8 maxShiftY = mostSignificantBit (y);\r\n        if (maxShiftY >= 128) maxShiftY -= 127;\r\n        else maxShiftY = 0;\r\n\r\n        uint256 result = 0;\r\n\r\n        while (true) {\r\n            uint256 rh = x >> 128;\r\n            uint256 rl = x << 128;\r\n\r\n            uint256 ph;\r\n            uint256 pl;\r\n\r\n            (ph, pl) = longMul (result, y);\r\n            if (rl < pl) {\r\n                ph = safeAdd (ph, 1);\r\n            }\r\n\r\n            rl -= pl;\r\n            rh -= ph;\r\n\r\n            if (rh == 0) {\r\n                result = safeAdd (result, rl / y);\r\n                break;\r\n            } else {\r\n                uint256 reminder = (rh << 128) + (rl >> 128);\r\n\r\n                // How many bits to shift reminder left\r\n                uint8 shiftReminder = 255 - mostSignificantBit (reminder);\r\n                if (shiftReminder > 128) shiftReminder = 128;\r\n\r\n                // How many bits to shift result left\r\n                uint8 shiftResult = 128 - shiftReminder;\r\n\r\n                // How many bits to shift Y right\r\n                uint8 shiftY = maxShiftY;\r\n                if (shiftY > shiftResult) shiftY = shiftResult;\r\n\r\n                shiftResult -= shiftY;\r\n\r\n                uint256 r = (reminder << shiftReminder) / (((y - 1) >> shiftY) + 1);\r\n\r\n                uint8 msbR = mostSignificantBit (r);\r\n                require (msbR <= 255 - shiftResult);\r\n\r\n                result = safeAdd (result, r << shiftResult);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Continuous Sale Action for selling PAT tokens.\r\n */\r\ncontract PATTokenSale is Math {\r\n    /**\r\n     * Time period when 15% bonus is in force.\r\n     */\r\n    uint256 private constant TRIPLE_BONUS = 1 hours;\r\n\r\n    /**\r\n     * Time period when 10% bonus is in force.\r\n     */\r\n    uint256 private constant DOUBLE_BONUS = 1 days;\r\n\r\n    /**\r\n     * Time period when 5% bonus is in force.\r\n     */\r\n    uint256 private constant SINGLE_BONUS = 1 weeks;\r\n\r\n    /**\r\n     * Create PAT Token Sale smart contract with given sale start time, token\r\n     * contract and central bank address.\r\n     *\r\n     * @param _saleStartTime sale start time\r\n     * @param _saleDuration sale duration\r\n     * @param _token ERC20 smart contract managing tokens to be sold\r\n     * @param _centralBank central bank address to transfer tokens from\r\n     * @param _saleCap maximum amount of ether to collect (in Wei)\r\n     * @param _minimumInvestment minimum investment amount (in Wei)\r\n     * @param _a parameter a of price formula\r\n     * @param _b parameter b of price formula\r\n     * @param _c parameter c of price formula\r\n     */\r\n    function PATTokenSale (\r\n        uint256 _saleStartTime, uint256 _saleDuration,\r\n        Token _token, address _centralBank,\r\n        uint256 _saleCap, uint256 _minimumInvestment,\r\n        int256 _a, int256 _b, int256 _c) {\r\n        saleStartTime = _saleStartTime;\r\n        saleDuration = _saleDuration;\r\n        token = _token;\r\n        centralBank = _centralBank;\r\n        saleCap = _saleCap;\r\n        minimumInvestment = _minimumInvestment;\r\n        a = _a;\r\n        b = _b;\r\n        c = _c;\r\n    }\r\n\r\n    /**\r\n     * Equivalent to buy().\r\n     */\r\n    function () payable public {\r\n        require (msg.data.length == 0);\r\n\r\n        buy ();\r\n    }\r\n\r\n    /**\r\n     * Buy tokens.\r\n     */\r\n    function buy () payable public {\r\n        require (!finished);\r\n        require (now >= saleStartTime);\r\n        require (now < safeAdd (saleStartTime, saleDuration));\r\n\r\n        require (msg.value >= minimumInvestment);\r\n\r\n        if (msg.value > 0) {\r\n            uint256 remainingCap = safeSub (saleCap, totalInvested);\r\n            uint256 toInvest;\r\n            uint256 toRefund;\r\n\r\n            if (msg.value <= remainingCap) {\r\n                toInvest = msg.value;\r\n                toRefund = 0;\r\n            } else {\r\n                toInvest = remainingCap;\r\n                toRefund = safeSub (msg.value, toInvest);\r\n            }\r\n\r\n            Investor storage investor = investors [msg.sender];\r\n            investor.amount = safeAdd (investor.amount, toInvest);\r\n            if (now < safeAdd (saleStartTime, TRIPLE_BONUS))\r\n                investor.bonusAmount = safeAdd (\r\n                    investor.bonusAmount, safeMul (toInvest, 6));\r\n            else if (now < safeAdd (saleStartTime, DOUBLE_BONUS))\r\n                investor.bonusAmount = safeAdd (\r\n                    investor.bonusAmount, safeMul (toInvest, 4));\r\n            else if (now < safeAdd (saleStartTime, SINGLE_BONUS))\r\n                investor.bonusAmount = safeAdd (\r\n                    investor.bonusAmount, safeMul (toInvest, 2));\r\n\r\n            Investment (msg.sender, toInvest);\r\n\r\n            totalInvested = safeAdd (totalInvested, toInvest);\r\n            if (toInvest == remainingCap) {\r\n                finished = true;\r\n                finalPrice = price (now);\r\n\r\n                Finished (finalPrice);\r\n            }\r\n\r\n            if (toRefund > 0)\r\n                msg.sender.transfer (toRefund);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Buy tokens providing referral code.\r\n     *\r\n     * @param _referralCode referral code, actually address of referee\r\n     */\r\n    function buyReferral (address _referralCode) payable public {\r\n        require (msg.sender != _referralCode);\r\n\r\n        Investor storage referee = investors [_referralCode];\r\n\r\n        // Make sure referee actually did invest something\r\n        require (referee.amount > 0);\r\n\r\n        Investor storage referrer = investors [msg.sender];\r\n        uint256 oldAmount = referrer.amount;\r\n\r\n        buy ();\r\n\r\n        uint256 invested = safeSub (referrer.amount, oldAmount);\r\n\r\n        // Make sure referrer actually did invest something\r\n        require (invested > 0);\r\n\r\n        referee.investedByReferrers = safeAdd (\r\n            referee.investedByReferrers, invested);\r\n\r\n        referrer.bonusAmount = safeAdd (\r\n            referrer.bonusAmount,\r\n            min (referee.amount, invested));\r\n    }\r\n\r\n    /**\r\n     * Get number of tokens to be delivered to given investor.\r\n     *\r\n     * @param _investor address of the investor to get number of tokens to be\r\n     *        delivered to\r\n     * @return number of tokens to be delivered to given investor\r\n     */\r\n    function outstandingTokens (address _investor)\r\n    constant public returns (uint256) {\r\n        require (finished);\r\n        assert (finalPrice > 0);\r\n\r\n        Investor storage investor = investors [_investor];\r\n        uint256 bonusAmount = investor.bonusAmount;\r\n        bonusAmount = safeAdd (\r\n            bonusAmount, min (investor.amount, investor.investedByReferrers));\r\n\r\n        uint256 effectiveAmount = safeAdd (\r\n            investor.amount,\r\n            bonusAmount / 40);\r\n\r\n        return fpDiv (effectiveAmount, finalPrice);\r\n    }\r\n\r\n    /**\r\n     * Deliver purchased tokens to given investor.\r\n     *\r\n     * @param _investor investor to deliver purchased tokens to\r\n     */\r\n    function deliver (address _investor) public returns (bool) {\r\n        require (finished);\r\n\r\n        Investor storage investor = investors [_investor];\r\n        require (investor.amount > 0);\r\n\r\n        uint256 value = outstandingTokens (_investor);\r\n        if (value > 0) {\r\n            if (!token.transferFrom (centralBank, _investor, value)) return false;\r\n        }\r\n\r\n        totalInvested = safeSub (totalInvested, investor.amount);\r\n        investor.amount = 0;\r\n        investor.bonusAmount = 0;\r\n        investor.investedByReferrers = 0;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Collect sale revenue.\r\n     */\r\n    function collectRevenue () public {\r\n        require (msg.sender == centralBank);\r\n\r\n        centralBank.transfer (this.balance);\r\n    }\r\n\r\n    /**\r\n     * Return token price at given time in Wei per token natural unit.\r\n     *\r\n     * @param _time time to return price at\r\n     * @return price at given time as 128.128 fixed point number\r\n     */\r\n    function price (uint256 _time) constant public returns (uint256) {\r\n        require (_time >= saleStartTime);\r\n        require (_time <= safeAdd (saleStartTime, saleDuration));\r\n\r\n        require (_time <= TWO128_1);\r\n        uint256 t = _time << 128;\r\n\r\n        uint256 cPlusT = (c >= 0) ?\r\n        safeAdd (t, uint256 (c)) :\r\n        safeSub (t, uint256 (-1 - c) + 1);\r\n        int256 lnCPlusT = ln (cPlusT);\r\n        int256 bLnCPlusT = fpMulI (b, lnCPlusT);\r\n        int256 aPlusBLnCPlusT = safeAddI (a, bLnCPlusT);\r\n\r\n        require (aPlusBLnCPlusT >= 0);\r\n        return uint256 (aPlusBLnCPlusT);\r\n    }\r\n\r\n    /**\r\n     * Finish sale after sale period ended.\r\n     */\r\n    function finishSale () public {\r\n        require (msg.sender == centralBank);\r\n        require (!finished);\r\n        uint256 saleEndTime = safeAdd (saleStartTime, saleDuration);\r\n        require (now >= saleEndTime);\r\n\r\n        finished = true;\r\n        finalPrice = price (saleEndTime);\r\n\r\n        Finished (finalPrice);\r\n    }\r\n\r\n    /**\r\n     * Destroy smart contract.\r\n     */\r\n    function destroy () public {\r\n        require (msg.sender == centralBank);\r\n        require (finished);\r\n        require (now >= safeAdd (saleStartTime, saleDuration));\r\n        require (totalInvested == 0);\r\n        require (this.balance == 0);\r\n\r\n        selfdestruct (centralBank);\r\n    }\r\n\r\n    /**\r\n     * Return minimum of two values.\r\n     *\r\n     * @param x first value\r\n     * @param y second value\r\n     * @return minimum of two values\r\n     */\r\n    function min (uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x < y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * Sale start time.\r\n     */\r\n    uint256 internal saleStartTime;\r\n\r\n    /**\r\n     * Sale duration.\r\n     */\r\n    uint256 internal saleDuration;\r\n\r\n    /**\r\n     * ERC20 token smart contract managing tokens to be sold.\r\n     */\r\n    Token internal token;\r\n\r\n    /**\r\n     * Address of central bank to transfer tokens from.\r\n     */\r\n    address internal centralBank;\r\n\r\n    /**\r\n     * Maximum number of Wei to collect.\r\n     */\r\n    uint256 internal saleCap;\r\n\r\n    /**\r\n     * Minimum investment amount in Wei.\r\n     */\r\n    uint256 internal minimumInvestment;\r\n\r\n    /**\r\n     * Price formula parameters.  Price at given time t is calculated as\r\n     * a / 2^128 + b * ln ((c + t) / 2^128) / 2^128.\r\n     */\r\n    int256 internal a;\r\n    int256 internal b;\r\n    int256 internal c;\r\n\r\n    /**\r\n     * True is sale was finished successfully, false otherwise.\r\n     */\r\n    bool internal finished = false;\r\n\r\n    /**\r\n     * Final price for finished sale.\r\n     */\r\n    uint256 internal finalPrice;\r\n\r\n    /**\r\n     * Maps investor's address to corresponding Investor structure.\r\n     */\r\n    mapping (address => Investor) internal investors;\r\n\r\n    /**\r\n     * Total amount invested in Wei.\r\n     */\r\n    uint256 internal totalInvested = 0;\r\n\r\n    /**\r\n     * Encapsulates information about investor.\r\n     */\r\n    struct Investor {\r\n        /**\r\n         * Total amount invested in Wei.\r\n         */\r\n        uint256 amount;\r\n\r\n        /**\r\n         * Bonus amount in Wei multiplied by 40.\r\n         */\r\n        uint256 bonusAmount;\r\n\r\n        /**\r\n         * Total amount of ether invested by others while referring this address.\r\n         */\r\n        uint256 investedByReferrers;\r\n    }\r\n\r\n    /**\r\n     * Logged when an investment was made.\r\n     *\r\n     * @param investor address of the investor who made the investment\r\n     * @param amount investment amount\r\n     */\r\n    event Investment (address indexed investor, uint256 amount);\r\n\r\n    /**\r\n     * Logged when sale finished successfully.\r\n     *\r\n     * @param finalPrice final price of the sale in Wei per token natural unit as\r\n     *                   128.128 bit fixed point number.\r\n     */\r\n    event Finished (uint256 finalPrice);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referralCode\",\"type\":\"address\"}],\"name\":\"buyReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"deliver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectRevenue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"outstandingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_saleStartTime\",\"type\":\"uint256\"},{\"name\":\"_saleDuration\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_centralBank\",\"type\":\"address\"},{\"name\":\"_saleCap\",\"type\":\"uint256\"},{\"name\":\"_minimumInvestment\",\"type\":\"uint256\"},{\"name\":\"_a\",\"type\":\"int256\"},{\"name\":\"_b\",\"type\":\"int256\"},{\"name\":\"_c\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Investment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"finalPrice\",\"type\":\"uint256\"}],\"name\":\"Finished\",\"type\":\"event\"}]","ContractName":"PATTokenSale","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005ab7b970000000000000000000000000000000000000000000000000000000000028de80000000000000000000000000bb1fa4fdeb3459733bf67ebc6f893003fa976a82000000000000000000000000cde042543307966bc16eff3cdca4d32b23408c4c000000000000000000000000000000000000000000000a5c3709b46ade83550000000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000000000000001e2d0396edd5a2079af8c2caa5577afffffffffffffffffffffffffffffffffffe0c2e3fe2302c3a3f0a593b55528dffffffffffffffffffffffffa54d626000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://f2696cf0688428d51abc5c97fb6074519dfc023e6bf2262db2ba8c06427f9ea5"}]}