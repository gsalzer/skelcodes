{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/libraries/PermissionsLib.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Dharma Labs Inc.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n/**\r\n *  Note(kayvon): these events are emitted by our PermissionsLib, but all contracts that\r\n *  depend on the library must also define the events in order for web3 clients to pick them up.\r\n *  This topic is discussed in greater detail here (under the section \"Events and Libraries\"):\r\n *  https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736\r\n */\r\ncontract PermissionEvents {\r\n    event Authorized(address indexed agent, string callingContext);\r\n    event AuthorizationRevoked(address indexed agent, string callingContext);\r\n}\r\n\r\n\r\nlibrary PermissionsLib {\r\n\r\n    // TODO(kayvon): remove these events and inherit from PermissionEvents when libraries are\r\n    // capable of inheritance.\r\n    // See relevant github issue here: https://github.com/ethereum/solidity/issues/891\r\n    event Authorized(address indexed agent, string callingContext);\r\n    event AuthorizationRevoked(address indexed agent, string callingContext);\r\n\r\n    struct Permissions {\r\n        mapping (address => bool) authorized;\r\n        mapping (address => uint) agentToIndex; // ensures O(1) look-up\r\n        address[] authorizedAgents;\r\n    }\r\n\r\n    function authorize(\r\n        Permissions storage self,\r\n        address agent,\r\n        string callingContext\r\n    )\r\n        internal\r\n    {\r\n        require(isNotAuthorized(self, agent));\r\n\r\n        self.authorized[agent] = true;\r\n        self.authorizedAgents.push(agent);\r\n        self.agentToIndex[agent] = self.authorizedAgents.length - 1;\r\n        Authorized(agent, callingContext);\r\n    }\r\n\r\n    function revokeAuthorization(\r\n        Permissions storage self,\r\n        address agent,\r\n        string callingContext\r\n    )\r\n        internal\r\n    {\r\n        /* We only want to do work in the case where the agent whose\r\n        authorization is being revoked had authorization permissions in the\r\n        first place. */\r\n        require(isAuthorized(self, agent));\r\n\r\n        uint indexOfAgentToRevoke = self.agentToIndex[agent];\r\n        uint indexOfAgentToMove = self.authorizedAgents.length - 1;\r\n        address agentToMove = self.authorizedAgents[indexOfAgentToMove];\r\n\r\n        // Revoke the agent's authorization.\r\n        delete self.authorized[agent];\r\n\r\n        // Remove the agent from our collection of authorized agents.\r\n        self.authorizedAgents[indexOfAgentToRevoke] = agentToMove;\r\n\r\n        // Update our indices to reflect the above changes.\r\n        self.agentToIndex[agentToMove] = indexOfAgentToRevoke;\r\n        delete self.agentToIndex[agent];\r\n\r\n        // Clean up memory that's no longer being used.\r\n        delete self.authorizedAgents[indexOfAgentToMove];\r\n        self.authorizedAgents.length -= 1;\r\n\r\n        AuthorizationRevoked(agent, callingContext);\r\n    }\r\n\r\n    function isAuthorized(Permissions storage self, address agent)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return self.authorized[agent];\r\n    }\r\n\r\n    function isNotAuthorized(Permissions storage self, address agent)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return !isAuthorized(self, agent);\r\n    }\r\n\r\n    function getAuthorizedAgents(Permissions storage self)\r\n        internal\r\n        view\r\n        returns (address[])\r\n    {\r\n        return self.authorizedAgents;\r\n    }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/DebtRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Dharma Labs Inc.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The DebtRegistry stores the parameters and beneficiaries of all debt agreements in\r\n * Dharma protocol.  It authorizes a limited number of agents to\r\n * perform mutations on it -- those agents can be changed at any\r\n * time by the contract's owner.\r\n *\r\n * Author: Nadav Hollander -- Github: nadavhollander\r\n */\r\ncontract DebtRegistry is Pausable, PermissionEvents {\r\n    using SafeMath for uint;\r\n    using PermissionsLib for PermissionsLib.Permissions;\r\n\r\n    struct Entry {\r\n        address version;\r\n        address beneficiary;\r\n        address underwriter;\r\n        uint underwriterRiskRating;\r\n        address termsContract;\r\n        bytes32 termsContractParameters;\r\n        uint issuanceBlockTimestamp;\r\n    }\r\n\r\n    // Primary registry mapping agreement IDs to their corresponding entries\r\n    mapping (bytes32 => Entry) internal registry;\r\n\r\n    // Maps debtor addresses to a list of their debts' agreement IDs\r\n    mapping (address => bytes32[]) internal debtorToDebts;\r\n\r\n    PermissionsLib.Permissions internal entryInsertPermissions;\r\n    PermissionsLib.Permissions internal entryEditPermissions;\r\n\r\n    string public constant INSERT_CONTEXT = \"debt-registry-insert\";\r\n    string public constant EDIT_CONTEXT = \"debt-registry-edit\";\r\n\r\n    event LogInsertEntry(\r\n        bytes32 indexed agreementId,\r\n        address indexed beneficiary,\r\n        address indexed underwriter,\r\n        uint underwriterRiskRating,\r\n        address termsContract,\r\n        bytes32 termsContractParameters\r\n    );\r\n\r\n    event LogModifyEntryBeneficiary(\r\n        bytes32 indexed agreementId,\r\n        address indexed previousBeneficiary,\r\n        address indexed newBeneficiary\r\n    );\r\n\r\n    modifier onlyAuthorizedToInsert() {\r\n        require(entryInsertPermissions.isAuthorized(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedToEdit() {\r\n        require(entryEditPermissions.isAuthorized(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyExtantEntry(bytes32 agreementId) {\r\n        require(doesEntryExist(agreementId));\r\n        _;\r\n    }\r\n\r\n    modifier nonNullBeneficiary(address beneficiary) {\r\n        require(beneficiary != address(0));\r\n        _;\r\n    }\r\n\r\n    /* Ensures an entry with the specified agreement ID exists within the debt registry. */\r\n    function doesEntryExist(bytes32 agreementId)\r\n        public\r\n        view\r\n        returns (bool exists)\r\n    {\r\n        return registry[agreementId].beneficiary != address(0);\r\n    }\r\n\r\n    /**\r\n     * Inserts a new entry into the registry, if the entry is valid and sender is\r\n     * authorized to make 'insert' mutations to the registry.\r\n     */\r\n    function insert(\r\n        address _version,\r\n        address _beneficiary,\r\n        address _debtor,\r\n        address _underwriter,\r\n        uint _underwriterRiskRating,\r\n        address _termsContract,\r\n        bytes32 _termsContractParameters,\r\n        uint _salt\r\n    )\r\n        public\r\n        onlyAuthorizedToInsert\r\n        whenNotPaused\r\n        nonNullBeneficiary(_beneficiary)\r\n        returns (bytes32 _agreementId)\r\n    {\r\n        Entry memory entry = Entry(\r\n            _version,\r\n            _beneficiary,\r\n            _underwriter,\r\n            _underwriterRiskRating,\r\n            _termsContract,\r\n            _termsContractParameters,\r\n            block.timestamp\r\n        );\r\n\r\n        bytes32 agreementId = _getAgreementId(entry, _debtor, _salt);\r\n\r\n        require(registry[agreementId].beneficiary == address(0));\r\n\r\n        registry[agreementId] = entry;\r\n        debtorToDebts[_debtor].push(agreementId);\r\n\r\n        LogInsertEntry(\r\n            agreementId,\r\n            entry.beneficiary,\r\n            entry.underwriter,\r\n            entry.underwriterRiskRating,\r\n            entry.termsContract,\r\n            entry.termsContractParameters\r\n        );\r\n\r\n        return agreementId;\r\n    }\r\n\r\n    /**\r\n     * Modifies the beneficiary of a debt issuance, if the sender\r\n     * is authorized to make 'modifyBeneficiary' mutations to\r\n     * the registry.\r\n     */\r\n    function modifyBeneficiary(bytes32 agreementId, address newBeneficiary)\r\n        public\r\n        onlyAuthorizedToEdit\r\n        whenNotPaused\r\n        onlyExtantEntry(agreementId)\r\n        nonNullBeneficiary(newBeneficiary)\r\n    {\r\n        address previousBeneficiary = registry[agreementId].beneficiary;\r\n\r\n        registry[agreementId].beneficiary = newBeneficiary;\r\n\r\n        LogModifyEntryBeneficiary(\r\n            agreementId,\r\n            previousBeneficiary,\r\n            newBeneficiary\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Adds an address to the list of agents authorized\r\n     * to make 'insert' mutations to the registry.\r\n     */\r\n    function addAuthorizedInsertAgent(address agent)\r\n        public\r\n        onlyOwner\r\n    {\r\n        entryInsertPermissions.authorize(agent, INSERT_CONTEXT);\r\n    }\r\n\r\n    /**\r\n     * Adds an address to the list of agents authorized\r\n     * to make 'modifyBeneficiary' mutations to the registry.\r\n     */\r\n    function addAuthorizedEditAgent(address agent)\r\n        public\r\n        onlyOwner\r\n    {\r\n        entryEditPermissions.authorize(agent, EDIT_CONTEXT);\r\n    }\r\n\r\n    /**\r\n     * Removes an address from the list of agents authorized\r\n     * to make 'insert' mutations to the registry.\r\n     */\r\n    function revokeInsertAgentAuthorization(address agent)\r\n        public\r\n        onlyOwner\r\n    {\r\n        entryInsertPermissions.revokeAuthorization(agent, INSERT_CONTEXT);\r\n    }\r\n\r\n    /**\r\n     * Removes an address from the list of agents authorized\r\n     * to make 'modifyBeneficiary' mutations to the registry.\r\n     */\r\n    function revokeEditAgentAuthorization(address agent)\r\n        public\r\n        onlyOwner\r\n    {\r\n        entryEditPermissions.revokeAuthorization(agent, EDIT_CONTEXT);\r\n    }\r\n\r\n    /**\r\n     * Returns the parameters of a debt issuance in the registry.\r\n     *\r\n     * TODO(kayvon): protect this function with our `onlyExtantEntry` modifier once the restriction\r\n     * on the size of the call stack has been addressed.\r\n     */\r\n    function get(bytes32 agreementId)\r\n        public\r\n        view\r\n        returns(address, address, address, uint, address, bytes32, uint)\r\n    {\r\n        return (\r\n            registry[agreementId].version,\r\n            registry[agreementId].beneficiary,\r\n            registry[agreementId].underwriter,\r\n            registry[agreementId].underwriterRiskRating,\r\n            registry[agreementId].termsContract,\r\n            registry[agreementId].termsContractParameters,\r\n            registry[agreementId].issuanceBlockTimestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the beneficiary of a given issuance\r\n     */\r\n    function getBeneficiary(bytes32 agreementId)\r\n        public\r\n        view\r\n        onlyExtantEntry(agreementId)\r\n        returns(address)\r\n    {\r\n        return registry[agreementId].beneficiary;\r\n    }\r\n\r\n    /**\r\n     * Returns the terms contract address of a given issuance\r\n     */\r\n    function getTermsContract(bytes32 agreementId)\r\n        public\r\n        view\r\n        onlyExtantEntry(agreementId)\r\n        returns (address)\r\n    {\r\n        return registry[agreementId].termsContract;\r\n    }\r\n\r\n    /**\r\n     * Returns the terms contract parameters of a given issuance\r\n     */\r\n    function getTermsContractParameters(bytes32 agreementId)\r\n        public\r\n        view\r\n        onlyExtantEntry(agreementId)\r\n        returns (bytes32)\r\n    {\r\n        return registry[agreementId].termsContractParameters;\r\n    }\r\n\r\n    /**\r\n     * Returns a tuple of the terms contract and its associated parameters\r\n     * for a given issuance\r\n     */\r\n    function getTerms(bytes32 agreementId)\r\n        public\r\n        view\r\n        onlyExtantEntry(agreementId)\r\n        returns(address, bytes32)\r\n    {\r\n        return (\r\n            registry[agreementId].termsContract,\r\n            registry[agreementId].termsContractParameters\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the timestamp of the block at which a debt agreement was issued.\r\n     */\r\n    function getIssuanceBlockTimestamp(bytes32 agreementId)\r\n        public\r\n        view\r\n        onlyExtantEntry(agreementId)\r\n        returns (uint timestamp)\r\n    {\r\n        return registry[agreementId].issuanceBlockTimestamp;\r\n    }\r\n\r\n    /**\r\n     * Returns the list of agents authorized to make 'insert' mutations\r\n     */\r\n    function getAuthorizedInsertAgents()\r\n        public\r\n        view\r\n        returns(address[])\r\n    {\r\n        return entryInsertPermissions.getAuthorizedAgents();\r\n    }\r\n\r\n    /**\r\n     * Returns the list of agents authorized to make 'modifyBeneficiary' mutations\r\n     */\r\n    function getAuthorizedEditAgents()\r\n        public\r\n        view\r\n        returns(address[])\r\n    {\r\n        return entryEditPermissions.getAuthorizedAgents();\r\n    }\r\n\r\n    /**\r\n     * Returns the list of debt agreements a debtor is party to,\r\n     * with each debt agreement listed by agreement ID.\r\n     */\r\n    function getDebtorsDebts(address debtor)\r\n        public\r\n        view\r\n        returns(bytes32[])\r\n    {\r\n        return debtorToDebts[debtor];\r\n    }\r\n\r\n    /**\r\n     * Helper function for computing the hash of a given issuance,\r\n     * and, in turn, its agreementId\r\n     */\r\n    function _getAgreementId(Entry _entry, address _debtor, uint _salt)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        return keccak256(\r\n            _entry.version,\r\n            _debtor,\r\n            _entry.underwriter,\r\n            _entry.underwriterRiskRating,\r\n            _entry.termsContract,\r\n            _entry.termsContractParameters,\r\n            _salt\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"EDIT_CONTEXT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"getTermsContractParameters\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"addAuthorizedEditAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"},{\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"modifyBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuthorizedInsertAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"getTerms\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"debtor\",\"type\":\"address\"}],\"name\":\"getDebtorsDebts\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INSERT_CONTEXT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"get\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"revokeEditAgentAuthorization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"doesEntryExist\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"addAuthorizedInsertAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"getBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"revokeInsertAgentAuthorization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_version\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_debtor\",\"type\":\"address\"},{\"name\":\"_underwriter\",\"type\":\"address\"},{\"name\":\"_underwriterRiskRating\",\"type\":\"uint256\"},{\"name\":\"_termsContract\",\"type\":\"address\"},{\"name\":\"_termsContractParameters\",\"type\":\"bytes32\"},{\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"insert\",\"outputs\":[{\"name\":\"_agreementId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"getIssuanceBlockTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementId\",\"type\":\"bytes32\"}],\"name\":\"getTermsContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuthorizedEditAgents\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agreementId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"underwriter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"underwriterRiskRating\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"termsContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"termsContractParameters\",\"type\":\"bytes32\"}],\"name\":\"LogInsertEntry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agreementId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"previousBeneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"LogModifyEntryBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"callingContext\",\"type\":\"string\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"callingContext\",\"type\":\"string\"}],\"name\":\"AuthorizationRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DebtRegistry","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://332fefdfdb6d32a7ac541b71d84d6aa3ea1468020217fe03036078cc5d39e949"}]}