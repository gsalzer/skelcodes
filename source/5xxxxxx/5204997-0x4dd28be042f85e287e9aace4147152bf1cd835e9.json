{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// DELEGATION SC v1.1\r\n// (c) SecureVote 2018\r\n// Author: Max Kaye <max@secure.vote>\r\n// Released under MIT licence\r\n\r\n// the most up-to-date version of the contract lives at delegate.secvote.eth\r\n\r\n\r\n// Main delegation contract v1.1\r\ncontract SVDelegationV0101 {\r\n\r\n    address public owner;\r\n\r\n    // in the last version we didn't include enough data - this makes it trivial to traverse off-chain\r\n    struct Delegation {\r\n        uint64 thisDelegationId;\r\n        uint64 prevDelegationId;\r\n        uint64 setAtBlock;\r\n        address delegatee;\r\n        address delegator;\r\n        address tokenContract;\r\n    }\r\n\r\n    // easy lookups\r\n    mapping (address => mapping (address => Delegation)) tokenDlgts;\r\n    mapping (address => Delegation) globalDlgts;\r\n\r\n    // track which token contracts we know about for easy traversal + backwards compatibility\r\n    mapping (address => bool) knownTokenContracts;\r\n    address[] logTokenContracts;\r\n\r\n    // track all delegations via an indexed map\r\n    mapping (uint64 => Delegation) historicalDelegations;\r\n    uint64 public totalDelegations = 0;\r\n\r\n    // reference to v1.0 of contract\r\n    SVDelegation prevSVDelegation;\r\n\r\n    // pretty straight forward - events\r\n    event SetGlobalDelegation(address voter, address delegate);\r\n    event SetTokenDelegation(address voter, address tokenContract, address delegate);\r\n\r\n    // main constructor - requires the prevDelegationSC address\r\n    function SVDelegationV0101(address prevDelegationSC) public {\r\n        owner = msg.sender;\r\n\r\n        prevSVDelegation = SVDelegation(prevDelegationSC);\r\n\r\n        // commit the genesis historical delegation to history (like genesis block) - somewhere to point back to\r\n        createDelegation(address(0), 0, address(0));\r\n    }\r\n\r\n    // internal function to handle inserting delegates into state\r\n    function createDelegation(address dlgtAddress, uint64 prevDelegationId, address tokenContract) internal returns(Delegation) {\r\n        // use this to log known tokenContracts\r\n        if (!knownTokenContracts[tokenContract]) {\r\n            logTokenContracts.push(tokenContract);\r\n            knownTokenContracts[tokenContract] = true;\r\n        }\r\n\r\n        uint64 myDelegationId = totalDelegations;\r\n        historicalDelegations[myDelegationId] = Delegation(myDelegationId, prevDelegationId, uint64(block.number), dlgtAddress, msg.sender, tokenContract);\r\n        totalDelegations += 1;\r\n\r\n        return historicalDelegations[myDelegationId];\r\n    }\r\n\r\n    // get previous delegation, create new delegation via function and then commit to globalDlgts\r\n    function setGlobalDelegation(address dlgtAddress) public {\r\n        uint64 prevDelegationId = globalDlgts[msg.sender].thisDelegationId;\r\n        globalDlgts[msg.sender] = createDelegation(dlgtAddress, prevDelegationId, address(0));\r\n        SetGlobalDelegation(msg.sender, dlgtAddress);\r\n    }\r\n\r\n    // get previous delegation, create new delegation via function and then commit to tokenDlgts\r\n    function setTokenDelegation(address tokenContract, address dlgtAddress) public {\r\n        uint64 prevDelegationId = tokenDlgts[tokenContract][msg.sender].thisDelegationId;\r\n        tokenDlgts[tokenContract][msg.sender] = createDelegation(dlgtAddress, prevDelegationId, tokenContract);\r\n        SetTokenDelegation(msg.sender, tokenContract, dlgtAddress);\r\n    }\r\n\r\n    // given some voter and token address, get the delegation id - failover to global on 0 address\r\n    function getDelegationID(address voter, address tokenContract) public constant returns(uint64) {\r\n        // default to token resolution but use global if no delegation\r\n        Delegation memory _tokenDlgt = tokenDlgts[tokenContract][voter];\r\n        if (tokenContract == address(0)) {\r\n            _tokenDlgt = globalDlgts[voter];\r\n        }\r\n\r\n        // default to 0 if we don't have a valid delegation\r\n        if (_validDelegation(_tokenDlgt)) {\r\n            return _tokenDlgt.thisDelegationId;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function resolveDelegation(address voter, address tokenContract) public constant returns(uint64, uint64, uint64, address, address, address) {\r\n        Delegation memory _tokenDlgt = tokenDlgts[tokenContract][voter];\r\n\r\n        // if we have a delegation in this contract return it\r\n        if (_validDelegation(_tokenDlgt)) {\r\n            return _dlgtRet(_tokenDlgt);\r\n        }\r\n\r\n        // otherwise try the global delegation\r\n        Delegation memory _globalDlgt = globalDlgts[voter];\r\n        if (_validDelegation(_globalDlgt)) {\r\n            return _dlgtRet(_globalDlgt);\r\n        }\r\n\r\n        // but if we don't have a delegation in this contract then resolve according the prev contract\r\n        address _dlgt;\r\n        uint256 meh;\r\n        (meh, _dlgt, meh, meh) = prevSVDelegation.resolveDelegation(voter, tokenContract);\r\n        return (0, 0, 0, _dlgt, voter, tokenContract);\r\n    }\r\n\r\n    // returns 2 lists: first of voter addresses, second of token contracts\r\n    function findPossibleDelegatorsOf(address delegate) public view returns(address[] memory, address[] memory) {\r\n        // not meant to be run on-chain, but off-chain via API, mostly convenience\r\n        address[] memory voters;\r\n        address[] memory tokenContracts;\r\n        Delegation memory _delegation;\r\n\r\n        // all the senders who participated in v1.0 of the contract prior to block 5203500\r\n        address[43] memory oldSenders =\r\n            [ 0xE8193Bc3D5F3F482406706F843A5f161563F37Bf\r\n            , 0x7A933c8a0Eb99e8Bdb07E1b42Aa10872845394B7\r\n            , 0x88341191EfA40Cd031F46138817830A5D3545Ba9\r\n            , 0xB6dc48E8583C8C6e320DaF918CAdef65f2d85B46\r\n            , 0xF02d417c8c6736Dbc7Eb089DC6738b950c2F444e\r\n            , 0xF66fE29Ad1E87104A8816AD1A8427976d83CB033\r\n            , 0xfd5955bf412B7537873CBB77eB1E39871e20e142\r\n            , 0xe83Efc57d9C487ACc55a7B62896dA43928E64C3E\r\n            , 0xd0c41588b27E64576ddA4e6a08452c59F5A2B2dD\r\n            , 0x640370126072f6B890d4Ca2E893103e9363DbE8B\r\n            , 0x887dbaCD9a0e58B46065F93cc1f82a52DEfDb979\r\n            , 0xe223771699665bCB0AAf7930277C35d3deC573aF\r\n            , 0x364B503B0e86b20B7aC1484c247DE50f10DfD8cf\r\n            , 0x4512F5867d91D6B0131427b89Bdb7b460fF30397\r\n            , 0xF5fBff477F5Bf5a950F661B70F6b5364875A1bD7\r\n            , 0x9EbB758483Da174DC3d411386B75afd093CEfCf1\r\n            , 0x499B36A6B92F91524A6B5b8Ff321740e84a2B57e\r\n            , 0x05D6e87fd6326F977a2d8c67b9F3EcC030527261\r\n            , 0x7f679053a1679dE7913885F0Db1278e91e8927Ca\r\n            , 0xF9CD08d36e972Bb070bBD2C1598D21045259AB0D\r\n            , 0xa5617800B8FD754fB81F47A65dc49A60acCc3432\r\n            , 0xa9F6238B83fcb65EcA3c3189a0dce8689e275D57\r\n            , 0xa30F92F9cc478562e0dde73665f1B7ADddDC2dCd\r\n            , 0x70278C15A29f0Ef62A845e1ac31AE41988F24C10\r\n            , 0xd42622471946CCFf9F7b9246e8D786c74410bFcC\r\n            , 0xd65955EF0f8890D7996f5a7b7b5b05B80605C06a\r\n            , 0xB46F4eBDD6404686D785EDACE37D66f815ED7cF8\r\n            , 0xf4d3aa8091D23f97706177CDD94b8dF4c7e4C2FB\r\n            , 0x4Fe584FFc9C755BF6Aa9354323e97166958475c9\r\n            , 0xB4802f497Bf6238A29e043103EE6eeae1331BFde\r\n            , 0x3EeE0f8Fadc1C29bFB782E70067a8D91B4ddeD56\r\n            , 0x46381F606014C5D68B38aD5C7e8f9401149FAa75\r\n            , 0xC81Be3496d053364255f9cb052F81Ca9e84A9cF3\r\n            , 0xa632837B095d8fa2ef46a22099F91Fe10B3F0538\r\n            , 0x19FA94aEbD4bC694802B566Ae65aEd8F07B992f7\r\n            , 0xE9Ef7664d36191Ad7aB001b9BB0aAfAcD260277F\r\n            , 0x17DAB6BB606f32447aff568c1D0eEDC3649C101C\r\n            , 0xaBA96c77E3dd7EEa16cc5EbdAAA05483CDD0FF89\r\n            , 0x57d36B0B5f5E333818b1ce072A6D84218E734deC\r\n            , 0x59E7612706DFB1105220CcB97aaF3cBF304cD608\r\n            , 0xCf7EC4dcA84b5c8Dc7896c38b4834DC6379BB73D\r\n            , 0x5Ed1Da246EA52F302FFf9391e56ec64b9c14cce1\r\n            , 0x4CabFD1796Ec9EAd77457768e5cA782a1A9e576F\r\n            ];\r\n\r\n        // there were no global delegations in v1.0 of contract\r\n        address oldToken = 0x9e88613418cF03dCa54D6a2cf6Ad934A78C7A17A;\r\n\r\n        // first loop through delegations in this contract\r\n        uint64 i;\r\n        // start at 1 because the first delegation is a \"genesis\" delegation in constructor\r\n        for (i = 1; i < totalDelegations; i++) {\r\n            _delegation = historicalDelegations[i];\r\n            if (_delegation.delegatee == delegate) {\r\n                // since `.push` isn't available on memory arrays, use their length as the next index location\r\n                voters = _appendMemArray(voters, _delegation.delegator);\r\n                tokenContracts = _appendMemArray(tokenContracts, _delegation.tokenContract);\r\n            }\r\n        }\r\n\r\n        // then loop through delegations in the previous contract\r\n        for (i = 0; i < oldSenders.length; i++) {\r\n            uint256 _oldId;\r\n            address _oldDlgt;\r\n            uint256 _oldSetAtBlock;\r\n            uint256 _oldPrevId;\r\n            (_oldId, _oldDlgt, _oldSetAtBlock, _oldPrevId) = prevSVDelegation.resolveDelegation(oldSenders[i], oldToken);\r\n            if (_oldDlgt == delegate && _oldSetAtBlock != 0) {\r\n                voters = _appendMemArray(voters, oldSenders[i]);\r\n                tokenContracts = _appendMemArray(tokenContracts, oldToken);\r\n            }\r\n        }\r\n\r\n        return (voters, tokenContracts);\r\n    }\r\n\r\n    // give access to historicalDelegations\r\n    function getHistoricalDelegation(uint64 delegationId) public constant returns(uint64, uint64, uint64, address, address, address) {\r\n        return _dlgtRet(historicalDelegations[delegationId]);\r\n    }\r\n\r\n    // access the globalDelegation map\r\n    function _rawGetGlobalDelegation(address _voter) public constant returns(uint64, uint64, uint64, address, address, address) {\r\n        return _dlgtRet(globalDlgts[_voter]);\r\n    }\r\n\r\n    // access the tokenDelegation map\r\n    function _rawGetTokenDelegation(address _voter, address _tokenContract) public constant returns(uint64, uint64, uint64, address, address, address) {\r\n        return _dlgtRet(tokenDlgts[_tokenContract][_voter]);\r\n    }\r\n\r\n    // access our log list of token contracts\r\n    function _getLogTokenContract(uint256 i) public constant returns(address) {\r\n        return logTokenContracts[i];\r\n    }\r\n\r\n    // convenience function to turn Delegations into a returnable structure\r\n    function _dlgtRet(Delegation d) internal pure returns(uint64, uint64, uint64, address, address, address) {\r\n        return (d.thisDelegationId, d.prevDelegationId, d.setAtBlock, d.delegatee, d.delegator, d.tokenContract);\r\n    }\r\n\r\n    // internal function to test if a delegation is valid or revoked / nonexistent\r\n    function _validDelegation(Delegation d) internal pure returns(bool) {\r\n        // probs simplest test to check if we have a valid delegation - important to check if delegation is set to 0x00\r\n        // to avoid counting a revocation (which is done by delegating to 0x00)\r\n        return d.setAtBlock > 0 && d.delegatee != address(0);\r\n    }\r\n\r\n    function _appendMemArray(address[] memory arr, address toAppend) internal pure returns(address[] memory arr2) {\r\n        arr2 = new address[](arr.length + 1);\r\n\r\n        for (uint k = 0; k < arr.length; k++) {\r\n            arr2[k] = arr[k];\r\n        }\r\n\r\n        arr2[arr.length] = toAppend;\r\n    }\r\n}\r\n\r\n\r\n\r\n// Minimal interface for delegation needs\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Interface {\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) constant public returns (uint256 balance);\r\n}\r\n\r\n\r\n\r\n// Include previous contract in this one so we can access the various components. Not all things needed are accessible\r\n// through functions - e.g. `historicalDelegations` mapping.\r\ncontract SVDelegation {\r\n\r\n    address public owner;\r\n\r\n    struct Delegation {\r\n        uint256 thisDelegationId;\r\n        address dlgt;\r\n        uint256 setAtBlock;\r\n        uint256 prevDelegation;\r\n    }\r\n\r\n    mapping (address => mapping (address => Delegation)) tokenDlgts;\r\n    mapping (address => Delegation) globalDlgts;\r\n\r\n    mapping (uint256 => Delegation) public historicalDelegations;\r\n    uint256 public totalDelegations = 0;\r\n\r\n    event SetGlobalDelegation(address voter, address delegate);\r\n    event SetTokenDelegation(address voter, address tokenContract, address delegate);\r\n\r\n    function SVDelegation() public {\r\n        owner = msg.sender;\r\n\r\n        // commit the genesis historical delegation to history (like genesis block)\r\n        createDelegation(address(0), 0);\r\n    }\r\n\r\n    function createDelegation(address dlgtAddress, uint256 prevDelegationId) internal returns(Delegation) {\r\n        uint256 myDelegationId = totalDelegations;\r\n        historicalDelegations[myDelegationId] = Delegation(myDelegationId, dlgtAddress, block.number, prevDelegationId);\r\n        totalDelegations += 1;\r\n\r\n        return historicalDelegations[myDelegationId];\r\n    }\r\n\r\n    // get previous delegation, create new delegation via function and then commit to globalDlgts\r\n    function setGlobalDelegation(address dlgtAddress) public {\r\n        uint256 prevDelegationId = globalDlgts[msg.sender].thisDelegationId;\r\n        globalDlgts[msg.sender] = createDelegation(dlgtAddress, prevDelegationId);\r\n        SetGlobalDelegation(msg.sender, dlgtAddress);\r\n    }\r\n\r\n    // get previous delegation, create new delegation via function and then commit to tokenDlgts\r\n    function setTokenDelegation(address tokenContract, address dlgtAddress) public {\r\n        uint256 prevDelegationId = tokenDlgts[tokenContract][msg.sender].thisDelegationId;\r\n        tokenDlgts[tokenContract][msg.sender] = createDelegation(dlgtAddress, prevDelegationId);\r\n        SetTokenDelegation(msg.sender, tokenContract, dlgtAddress);\r\n    }\r\n\r\n    function resolveDelegation(address voter, address tokenContract) public constant returns(uint256, address, uint256, uint256) {\r\n        Delegation memory _tokenDlgt = tokenDlgts[tokenContract][voter];\r\n\r\n        // probs simplest test to check if we have a valid delegation\r\n        if (_tokenDlgt.setAtBlock > 0) {\r\n            return _dlgtRet(_tokenDlgt);\r\n        } else {\r\n            return _dlgtRet(globalDlgts[voter]);\r\n        }\r\n    }\r\n\r\n    function _rawGetGlobalDelegation(address _voter) public constant returns(uint256, address, uint256, uint256) {\r\n        return _dlgtRet(globalDlgts[_voter]);\r\n    }\r\n\r\n    function _rawGetTokenDelegation(address _voter, address _tokenContract) public constant returns(uint256, address, uint256, uint256) {\r\n        return _dlgtRet(tokenDlgts[_tokenContract][_voter]);\r\n    }\r\n\r\n    function _dlgtRet(Delegation d) internal pure returns(uint256, address, uint256, uint256) {\r\n        return (d.thisDelegationId, d.dlgt, d.setAtBlock, d.prevDelegation);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalDelegations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"delegationId\",\"type\":\"uint64\"}],\"name\":\"getHistoricalDelegation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"},{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"_rawGetTokenDelegation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"resolveDelegation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dlgtAddress\",\"type\":\"address\"}],\"name\":\"setGlobalDelegation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"getDelegationID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"findPossibleDelegatorsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"_getLogTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"dlgtAddress\",\"type\":\"address\"}],\"name\":\"setTokenDelegation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"_rawGetGlobalDelegation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"prevDelegationSC\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"SetGlobalDelegation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"SetTokenDelegation\",\"type\":\"event\"}]","ContractName":"SVDelegationV0101","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d78d4beabfd3054390d10aeb4258dc2d867f5e17","Library":"","SwarmSource":"bzzr://1c080e492d2b5154da88b259df7db87ce8f4daa8416450c1a03cc1560365fa3f"}]}