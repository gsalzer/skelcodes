{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ninterface tokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\r\n}\r\n\r\n\r\ncontract ParsecTokenERC20 {\r\n    // Public variables of the token\r\n    string public constant name = \"Parsec Credits\";\r\n    string public constant symbol = \"PRSC\";\r\n    uint8 public decimals = 6;\r\n    uint256 public initialSupply = 30856775800;\r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    /**\r\n     * Constrctor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function ParsecTokenERC20() public {\r\n        // Update total supply with the decimal amount\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);\r\n\r\n        // Give the creator all initial tokens\r\n        balanceOf[msg.sender] = totalSupply;\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        // Check allowance\r\n        require(_value <= allowance[_from][msg.sender]);\r\n\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        // Check if the sender has enough\r\n        require(balanceOf[msg.sender] >= _value);\r\n\r\n        // Subtract from the sender\r\n        balanceOf[msg.sender] -= _value;\r\n\r\n        // Updates totalSupply\r\n        totalSupply -= _value;\r\n\r\n        // Notify clients about burned tokens\r\n        Burn(msg.sender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        // Check if the targeted balance is enough\r\n        require(balanceOf[_from] >= _value);\r\n\r\n        // Check allowance\r\n        require(_value <= allowance[_from][msg.sender]);\r\n\r\n        // Subtract from the targeted balance\r\n        balanceOf[_from] -= _value;\r\n\r\n        // Subtract from the sender's allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n\r\n        // Update totalSupply\r\n        totalSupply -= _value;\r\n\r\n        // Notify clients about burned tokens\r\n        Burn(_from, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract ParsecCrowdsale is owned {\r\n    /// @notice Use OpenZeppelin's SafeMath\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Define KYC states\r\n    enum KycState {\r\n        Undefined,  // 0\r\n        Pending,    // 1\r\n        Accepted,   // 2\r\n        Declined    // 3\r\n    }\r\n\r\n    // -------------------------\r\n    // --- General constants ---\r\n    // -------------------------\r\n\r\n    /// @notice Minimum ETH amount per transaction\r\n    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 0.1 ether;\r\n\r\n    /// @notice Base rate of parsec credits per 1 ETH\r\n    uint256 public constant PARSECS_PER_ETHER_BASE = 1300000000000;      // 1,300,000.000000 PRSC\r\n\r\n    /// @notice Crowdsale hard cap in Parsecs\r\n    uint256 public constant PARSECS_TOTAL_AMOUNT = 16103862002000000;    // 16,103,862,002.000000 PRSC\r\n\r\n    // ----------------------------\r\n    // --- Bonus tier constants ---\r\n    // ----------------------------\r\n    \r\n    uint256 public constant BONUS_TIER_1_LIMIT = 715 ether;     // 30.0 % bonus Parsecs\r\n    uint256 public constant BONUS_TIER_2_LIMIT = 1443 ether;    // 27.5 % bonus Parsecs\r\n    uint256 public constant BONUS_TIER_3_LIMIT = 2434 ether;    // 25.0 % bonus Parsecs\r\n    uint256 public constant BONUS_TIER_4_LIMIT = 3446 ether;    // 22.5 % bonus Parsecs\r\n    uint256 public constant BONUS_TIER_5_LIMIT = 4478 ether;    // 20.0 % bonus Parsecs\r\n    uint256 public constant BONUS_TIER_6_LIMIT = 5532 ether;    // 17.5 % bonus Parsecs\r\n    uint256 public constant BONUS_TIER_7_LIMIT = 6609 ether;    // 15.0 % bonus Parsecs\r\n    uint256 public constant BONUS_TIER_8_LIMIT = 7735 ether;    // 10.0 % bonus Parsecs\r\n    uint256 public constant BONUS_TIER_9_LIMIT = 9210 ether;    // 5.00 % bonus Parsecs\r\n\r\n    // ------------------------\r\n    // --- Input parameters ---\r\n    // ------------------------\r\n\r\n    /// @notice Parsec ERC20 token address (from previously deployed contract)\r\n    ParsecTokenERC20 private parsecToken;\r\n\r\n    // @notice Multisig account address to collect accepted ETH\r\n    address public multisigAddress;\r\n\r\n    // @notice Auditor account address to perform KYC accepts and declines\r\n    address public auditorAddress;\r\n\r\n    // ---------------------------\r\n    // --- Power-up parameters ---\r\n    // ---------------------------\r\n\r\n    /// @notice Keep track if contract is powered up (has enough Parsecs)\r\n    bool public contractPoweredUp = false;\r\n\r\n    /// @notice Keep track if contract has enough ETH to perform refunds\r\n    bool public refundPoweredUp = false;\r\n\r\n    // ---------------------------\r\n    // --- State parameters ---\r\n    // ---------------------------\r\n\r\n    /// @notice Keep track if contract is started (permanently, works if contract is powered up) \r\n    bool public contractStarted = false;\r\n\r\n    /// @notice Keep track if contract is finished (permanently, works if contract is started) \r\n    bool public contractFinished = false;\r\n\r\n    /// @notice Keep track if contract is paused (transiently, works if contract started and not finished) \r\n    bool public contractPaused = false;\r\n\r\n    /// @notice Keep track if contract is failed (permanently, works if contract started and not finished) \r\n    bool public contractFailed = false;\r\n\r\n    /// @notice Keep track if contract refund is started\r\n    bool public contractRefundStarted = false;\r\n\r\n    /// @notice Keep track if contract refund is finished\r\n    bool public contractRefundFinished = false;\r\n\r\n    // ------------------------\r\n    // --- Funding tracking ---\r\n    // ------------------------\r\n\r\n    /// @notice Keep track of total amount of funding raised and passed KYC\r\n    uint256 public raisedFunding;\r\n       \r\n    /// @notice Keep track of funding amount pending KYC check\r\n    uint256 public pendingFunding;\r\n\r\n    /// @notice Keep track of refunded funding\r\n    uint256 public refundedFunding;\r\n\r\n    // ------------------------\r\n    // --- Parsecs tracking ---\r\n    // ------------------------\r\n\r\n    /// @notice Keep track of spent Parsecs amount (transferred to participants)\r\n    uint256 public spentParsecs;\r\n    \r\n    /// @notice Keep track of pending Parsecs amount (participant pending KYC)\r\n    uint256 public pendingParsecs;\r\n\r\n    // ----------------\r\n    // --- Balances ---\r\n    // ----------------\r\n\r\n    /// @notice Keep track of all contributions per account passed KYC\r\n    mapping (address => uint256) public contributionOf;\r\n\r\n    /// @notice Keep track of all Parsecs granted to participants after they passed KYC\r\n    mapping (address => uint256) public parsecsOf;\r\n\r\n    /// @notice Keep track of all contributions pending KYC\r\n    mapping (address => uint256) public pendingContributionOf;\r\n\r\n    /// @notice Keep track of all Parsecs' rewards pending KYC\r\n    mapping (address => uint256) public pendingParsecsOf;\r\n\r\n    /// @notice Keep track of all refunds per account\r\n    mapping (address => uint256) public refundOf;\r\n\r\n    // -----------------------------------------\r\n    // --- KYC (Know-Your-Customer) tracking ---\r\n    // -----------------------------------------\r\n\r\n    /// @notice Keep track of participants' KYC status\r\n    mapping (address => KycState) public kycStatus;\r\n\r\n    // --------------\r\n    // --- Events ---\r\n    // --------------\r\n\r\n    /// @notice Log an event for each KYC accept\r\n    event LogKycAccept(address indexed sender, uint256 value, uint256 timestamp);\r\n\r\n    /// @notice Log an event for each KYC decline\r\n    event LogKycDecline(address indexed sender, uint256 value, uint256 timestamp);\r\n\r\n    /// @notice Log an event for each contributed amount passed KYC\r\n    event LogContribution(address indexed sender, uint256 ethValue, uint256 parsecValue, uint256 timestamp);\r\n\r\n    /**\r\n     * Constructor function\r\n     *\r\n     * Initializes smart contract\r\n     *\r\n     * @param _tokenAddress The address of the previously deployed ParsecTokenERC20 contract\r\n     * @param _multisigAddress The address of the Multisig wallet to redirect payments to\r\n     * @param _auditorAddress The address of the Auditor account which will accept or decline investors' KYC\r\n     */\r\n    function ParsecCrowdsale (address _tokenAddress, address _multisigAddress, address _auditorAddress) public {\r\n        // Get Parsec ERC20 token instance\r\n        parsecToken = ParsecTokenERC20(_tokenAddress);\r\n\r\n        // Store Multisig wallet and Auditor addresses\r\n        multisigAddress = _multisigAddress;\r\n        auditorAddress = _auditorAddress;\r\n    }\r\n\r\n    /// @notice Allows only contract owner or Multisig to proceed\r\n    modifier onlyOwnerOrMultisig {\r\n        require(msg.sender == owner || msg.sender == multisigAddress);\r\n        _;\r\n    }\r\n\r\n    /// @notice Allows only contract owner or Auditor to proceed\r\n    modifier onlyOwnerOrAuditor {\r\n        require(msg.sender == owner || msg.sender == auditorAddress);\r\n        _;\r\n    }\r\n\r\n    /// @notice A participant sends a contribution to the contract's address\r\n    ///         when contract is active, not failed and not paused \r\n    /// @notice Only contributions above the MINIMUM_PARTICIPATION_AMOUNT are\r\n    ///         accepted. Otherwise the transaction is rejected and contributed\r\n    ///         amount is returned to the participant's account\r\n    /// @notice A participant's contribution will be rejected if it exceeds\r\n    ///         the hard cap\r\n    /// @notice A participant's contribution will be rejected if the hard\r\n    ///         cap is reached\r\n    function () public payable {\r\n        // Contract should be powered up\r\n        require(contractPoweredUp);\r\n\r\n        // Сontract should BE started\r\n        require(contractStarted);\r\n\r\n        // Сontract should NOT BE finished\r\n        require(!contractFinished);\r\n\r\n        // Сontract should NOT BE paused\r\n        require(!contractPaused);\r\n\r\n        // Сontract should NOT BE failed\r\n        require(!contractFailed);\r\n\r\n        // A participant cannot send less than the minimum amount\r\n        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT);\r\n\r\n        // Calculate amount of Parsecs to reward\r\n        uint256 parsecValue = calculateReward(msg.value);\r\n\r\n        // Calculate maximum amount of Parsecs smart contract can provide\r\n        uint256 maxAcceptableParsecs = PARSECS_TOTAL_AMOUNT.sub(spentParsecs);\r\n        maxAcceptableParsecs = maxAcceptableParsecs.sub(pendingParsecs);\r\n\r\n        // A participant cannot receive more Parsecs than contract has to offer\r\n        require(parsecValue <= maxAcceptableParsecs);\r\n\r\n        // Check if participant's KYC state is Undefined and set it to Pending\r\n        if (kycStatus[msg.sender] == KycState.Undefined) {\r\n            kycStatus[msg.sender] = KycState.Pending;\r\n        }\r\n\r\n        if (kycStatus[msg.sender] == KycState.Pending) {\r\n            // KYC is Pending: register pending contribution\r\n            addPendingContribution(msg.sender, msg.value, parsecValue);\r\n        } else if (kycStatus[msg.sender] == KycState.Accepted) {\r\n            // KYC is Accepted: register accepted contribution\r\n            addAcceptedContribution(msg.sender, msg.value, parsecValue);\r\n        } else {\r\n            // KYC is Declined: revert transaction\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /// @notice Contract owner or Multisig can withdraw Parsecs anytime in case of emergency\r\n    function emergencyWithdrawParsecs(uint256 value) external onlyOwnerOrMultisig {\r\n        // Amount of Parsecs to withdraw should not exceed current balance\r\n        require(value > 0);\r\n        require(value <= parsecToken.balanceOf(this));\r\n\r\n        // Transfer parsecs\r\n        parsecToken.transfer(msg.sender, value);\r\n    }\r\n\r\n    /// @notice Contract owner or Multisig can refund contract with ETH in case of failed Crowdsale\r\n    function emergencyRefundContract() external payable onlyOwnerOrMultisig {\r\n        // Contract should be failed previously\r\n        require(contractFailed);\r\n        \r\n        // Amount of ETH should be positive\r\n        require(msg.value > 0);\r\n    }\r\n\r\n    /// @notice Contract owner or Multisig can clawback ether after refund period is finished\r\n    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {\r\n        // Contract should be failed previously\r\n        require(contractFailed);\r\n\r\n        // Contract refund should be started and finished previously\r\n        require(contractRefundStarted);\r\n        require(contractRefundFinished);\r\n        \r\n        // Amount of ETH should be positive and not exceed current contract balance\r\n        require(value > 0);\r\n        require(value <= address(this).balance);\r\n\r\n        // Transfer ETH to Multisig\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    /// @notice Set Auditor account address to a new value\r\n    function ownerSetAuditor(address _auditorAddress) external onlyOwner {\r\n        // Auditor address cannot be zero\r\n        require(_auditorAddress != 0x0);\r\n\r\n        // Change Auditor account address\r\n        auditorAddress = _auditorAddress;\r\n    }\r\n\r\n    /// @notice Check if contract has enough Parsecs to cover hard cap\r\n    function ownerPowerUpContract() external onlyOwner {\r\n        // Contract should not be powered up previously\r\n        require(!contractPoweredUp);\r\n\r\n        // Contract should have enough Parsec credits\r\n        require(parsecToken.balanceOf(this) >= PARSECS_TOTAL_AMOUNT);\r\n\r\n        // Raise contract power-up flag\r\n        contractPoweredUp = true;\r\n    }\r\n\r\n    /// @notice Start contract (permanently)\r\n    function ownerStartContract() external onlyOwner {\r\n        // Contract should be powered up previously\r\n        require(contractPoweredUp);\r\n\r\n        // Contract should not be started previously\r\n        require(!contractStarted);\r\n\r\n        // Raise contract started flag\r\n        contractStarted = true;\r\n    }\r\n\r\n    /// @notice Finish contract (permanently)\r\n    function ownerFinishContract() external onlyOwner {\r\n        // Contract should be started previously\r\n        require(contractStarted);\r\n\r\n        // Contract should not be finished previously\r\n        require(!contractFinished);\r\n\r\n        // Raise contract finished flag\r\n        contractFinished = true;\r\n    }\r\n\r\n    /// @notice Pause contract (transiently)\r\n    function ownerPauseContract() external onlyOwner {\r\n        // Contract should be started previously\r\n        require(contractStarted);\r\n\r\n        // Contract should not be finished previously\r\n        require(!contractFinished);\r\n\r\n        // Contract should not be paused previously\r\n        require(!contractPaused);\r\n\r\n        // Raise contract paused flag\r\n        contractPaused = true;\r\n    }\r\n\r\n    /// @notice Resume contract (transiently)\r\n    function ownerResumeContract() external onlyOwner {\r\n        // Contract should be paused previously\r\n        require(contractPaused);\r\n\r\n        // Unset contract paused flag\r\n        contractPaused = false;\r\n    }\r\n\r\n    /// @notice Declare Crowdsale failure (no more ETH are accepted from participants)\r\n    function ownerDeclareFailure() external onlyOwner {\r\n        // Contract should NOT BE failed previously\r\n        require(!contractFailed);\r\n\r\n        // Raise contract failed flag\r\n        contractFailed = true;\r\n    }\r\n\r\n    /// @notice Declare Crowdsale refund start\r\n    function ownerDeclareRefundStart() external onlyOwner {\r\n        // Contract should BE failed previously\r\n        require(contractFailed);\r\n\r\n        // Contract refund should NOT BE started previously\r\n        require(!contractRefundStarted);\r\n\r\n        // Contract should NOT have any pending KYC requests\r\n        require(pendingFunding == 0x0);\r\n\r\n        // Contract should have enough ETH to perform refunds\r\n        require(address(this).balance >= raisedFunding);\r\n\r\n        // Raise contract refund started flag\r\n        contractRefundStarted = true;\r\n    }\r\n\r\n    /// @notice Declare Crowdsale refund finish\r\n    function ownerDeclareRefundFinish() external onlyOwner {\r\n        // Contract should BE failed previously\r\n        require(contractFailed);\r\n\r\n        // Contract refund should BE started previously\r\n        require(contractRefundStarted);\r\n\r\n        // Contract refund should NOT BE finished previously\r\n        require(!contractRefundFinished);\r\n\r\n        // Raise contract refund finished flag\r\n        contractRefundFinished = true;\r\n    }\r\n\r\n    /// @notice Owner can withdraw Parsecs only after contract is finished\r\n    function ownerWithdrawParsecs(uint256 value) external onlyOwner {\r\n        // Contract should be finished before any Parsecs could be withdrawn\r\n        require(contractFinished);\r\n\r\n        // Get smart contract balance in Parsecs\r\n        uint256 parsecBalance = parsecToken.balanceOf(this);\r\n\r\n        // Calculate maximal amount to withdraw\r\n        uint256 maxAmountToWithdraw = parsecBalance.sub(pendingParsecs);\r\n\r\n        // Maximal amount to withdraw should be greater than zero and not greater than total balance\r\n        require(maxAmountToWithdraw > 0);\r\n        require(maxAmountToWithdraw <= parsecBalance);\r\n\r\n        // Amount of Parsecs to withdraw should not exceed maxAmountToWithdraw\r\n        require(value > 0);\r\n        require(value <= maxAmountToWithdraw);\r\n\r\n        // Transfer parsecs\r\n        parsecToken.transfer(owner, value);\r\n    }\r\n \r\n    /// @dev Accept participant's KYC\r\n    function acceptKyc(address participant) external onlyOwnerOrAuditor {\r\n        // Set participant's KYC status to Accepted\r\n        kycStatus[participant] = KycState.Accepted;\r\n\r\n        // Get pending amounts in ETH and Parsecs\r\n        uint256 pendingAmountOfEth = pendingContributionOf[participant];\r\n        uint256 pendingAmountOfParsecs = pendingParsecsOf[participant];\r\n\r\n        // Log an event of the participant's KYC accept\r\n        LogKycAccept(participant, pendingAmountOfEth, now);\r\n\r\n        if (pendingAmountOfEth > 0 || pendingAmountOfParsecs > 0) {\r\n            // Reset pending contribution\r\n            resetPendingContribution(participant);\r\n\r\n            // Add accepted contribution\r\n            addAcceptedContribution(participant, pendingAmountOfEth, pendingAmountOfParsecs);\r\n        }\r\n    }\r\n\r\n    /// @dev Decline participant's KYC\r\n    function declineKyc(address participant) external onlyOwnerOrAuditor {\r\n        // Set participant's KYC status to Declined\r\n        kycStatus[participant] = KycState.Declined;\r\n\r\n        // Log an event of the participant's KYC decline\r\n        LogKycDecline(participant, pendingAmountOfEth, now);\r\n\r\n        // Get pending ETH amount\r\n        uint256 pendingAmountOfEth = pendingContributionOf[participant];\r\n\r\n        if (pendingAmountOfEth > 0) {\r\n            // Reset pending contribution\r\n            resetPendingContribution(participant);\r\n\r\n            // Transfer ETH back to participant\r\n            participant.transfer(pendingAmountOfEth);\r\n        }\r\n    }\r\n\r\n    /// @dev Allow participants to clawback ETH in case of Crowdsale failure\r\n    function participantClawbackEther(uint256 value) external {\r\n        // Participant cannot withdraw ETH if refund is not started or after it is finished\r\n        require(contractRefundStarted);\r\n        require(!contractRefundFinished);\r\n\r\n        // Get total contribution of participant\r\n        uint256 totalContribution = contributionOf[msg.sender];\r\n\r\n        // Get already refunded amount\r\n        uint256 alreadyRefunded = refundOf[msg.sender];\r\n\r\n        // Calculate maximal withdrawal amount\r\n        uint256 maxWithdrawalAmount = totalContribution.sub(alreadyRefunded);\r\n\r\n        // Maximal withdrawal amount should not be zero\r\n        require(maxWithdrawalAmount > 0);\r\n\r\n        // Requested value should not exceed maximal withdrawal amount\r\n        require(value > 0);\r\n        require(value <= maxWithdrawalAmount);\r\n\r\n        // Participant's refundOf is increased by the claimed amount\r\n        refundOf[msg.sender] = alreadyRefunded.add(value);\r\n\r\n        // Total refound amount is increased\r\n        refundedFunding = refundedFunding.add(value);\r\n\r\n        // Send ethers back to the participant's account\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    /// @dev Register pending contribution\r\n    function addPendingContribution(address participant, uint256 ethValue, uint256 parsecValue) private {\r\n        // Participant's pending contribution is increased by ethValue\r\n        pendingContributionOf[participant] = pendingContributionOf[participant].add(ethValue);\r\n\r\n        // Parsecs pending to participant increased by parsecValue\r\n        pendingParsecsOf[participant] = pendingParsecsOf[participant].add(parsecValue);\r\n\r\n        // Increase pending funding by ethValue\r\n        pendingFunding = pendingFunding.add(ethValue);\r\n\r\n        // Increase pending Parsecs by parsecValue\r\n        pendingParsecs = pendingParsecs.add(parsecValue);\r\n    }\r\n\r\n    /// @dev Register accepted contribution\r\n    function addAcceptedContribution(address participant, uint256 ethValue, uint256 parsecValue) private {\r\n        // Participant's contribution is increased by ethValue\r\n        contributionOf[participant] = contributionOf[participant].add(ethValue);\r\n\r\n        // Parsecs rewarded to participant increased by parsecValue\r\n        parsecsOf[participant] = parsecsOf[participant].add(parsecValue);\r\n\r\n        // Increase total raised funding by ethValue\r\n        raisedFunding = raisedFunding.add(ethValue);\r\n\r\n        // Increase spent Parsecs by parsecValue\r\n        spentParsecs = spentParsecs.add(parsecValue);\r\n\r\n        // Log an event of the participant's contribution\r\n        LogContribution(participant, ethValue, parsecValue, now);\r\n\r\n        // Transfer ETH to Multisig\r\n        multisigAddress.transfer(ethValue);\r\n\r\n        // Transfer Parsecs to participant\r\n        parsecToken.transfer(participant, parsecValue);\r\n    }\r\n\r\n    /// @dev Reset pending contribution\r\n    function resetPendingContribution(address participant) private {\r\n        // Get amounts of pending ETH and Parsecs\r\n        uint256 pendingAmountOfEth = pendingContributionOf[participant];\r\n        uint256 pendingAmountOfParsecs = pendingParsecsOf[participant];\r\n\r\n        // Decrease pending contribution by pendingAmountOfEth\r\n        pendingContributionOf[participant] = pendingContributionOf[participant].sub(pendingAmountOfEth);\r\n\r\n        // Decrease pending Parsecs reward by pendingAmountOfParsecs\r\n        pendingParsecsOf[participant] = pendingParsecsOf[participant].sub(pendingAmountOfParsecs);\r\n\r\n        // Decrease pendingFunding by pendingAmountOfEth\r\n        pendingFunding = pendingFunding.sub(pendingAmountOfEth);\r\n\r\n        // Decrease pendingParsecs by pendingAmountOfParsecs\r\n        pendingParsecs = pendingParsecs.sub(pendingAmountOfParsecs);\r\n    }\r\n\r\n    /// @dev Calculate amount of Parsecs to grant for ETH contribution\r\n    function calculateReward(uint256 ethValue) private view returns (uint256 amount) {\r\n        // Define base quotient\r\n        uint256 baseQuotient = 1000;\r\n\r\n        // Calculate actual quotient according to current bonus tier\r\n        uint256 actualQuotient = baseQuotient.add(calculateBonusTierQuotient());\r\n\r\n        // Calculate reward amount\r\n        uint256 reward = ethValue.mul(PARSECS_PER_ETHER_BASE);\r\n        reward = reward.mul(actualQuotient);\r\n        reward = reward.div(baseQuotient);\r\n        return reward.div(1 ether);\r\n    }\r\n\r\n    /// @dev Calculate current bonus tier quotient\r\n    function calculateBonusTierQuotient() private view returns (uint256 quotient) {\r\n        uint256 funding = raisedFunding.add(pendingFunding);\r\n\r\n        if (funding < BONUS_TIER_1_LIMIT) {\r\n            return 300;     // 30.0 % bonus Parsecs\r\n        } else if (funding < BONUS_TIER_2_LIMIT) {\r\n            return 275;     // 27.5 % bonus Parsecs\r\n        } else if (funding < BONUS_TIER_3_LIMIT) {\r\n            return 250;     // 25.0 % bonus Parsecs\r\n        } else if (funding < BONUS_TIER_4_LIMIT) {\r\n            return 225;     // 22.5 % bonus Parsecs\r\n        } else if (funding < BONUS_TIER_5_LIMIT) {\r\n            return 200;     // 20.0 % bonus Parsecs\r\n        } else if (funding < BONUS_TIER_6_LIMIT) {\r\n            return 175;     // 17.5 % bonus Parsecs\r\n        } else if (funding < BONUS_TIER_7_LIMIT) {\r\n            return 150;     // 15.0 % bonus Parsecs\r\n        } else if (funding < BONUS_TIER_8_LIMIT) {\r\n            return 100;     // 10.0 % bonus Parsecs\r\n        } else if (funding < BONUS_TIER_9_LIMIT) {\r\n            return 50;      // 5.00 % bonus Parsecs\r\n        } else {\r\n            return 0;       // 0.00 % bonus Parsecs\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"participantClawbackEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerStartContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refundOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_5_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_7_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"parsecsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerFinishContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"declineKyc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerDeclareRefundFinish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PARSECS_TOTAL_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_PARTICIPATION_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_2_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"acceptKyc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"kycStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raisedFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractFailed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawParsecs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractRefundStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingParsecs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerPowerUpContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_8_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerPauseContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerDeclareRefundStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_9_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auditorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_1_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerDeclareFailure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_4_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_3_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerResumeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractPoweredUp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"emergencyClawbackEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PARSECS_PER_ETHER_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spentParsecs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractRefundFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundPoweredUp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyRefundContract\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingParsecsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributionOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingContributionOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TIER_6_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_auditorAddress\",\"type\":\"address\"}],\"name\":\"ownerSetAuditor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ownerWithdrawParsecs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundedFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_multisigAddress\",\"type\":\"address\"},{\"name\":\"_auditorAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LogKycAccept\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LogKycDecline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"parsecValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LogContribution\",\"type\":\"event\"}]","ContractName":"ParsecCrowdsale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004373d59176891da98ca6faaa86bd387fc9e12b6e0000000000000000000000003fd9aba22521d9ee3202a43bb132816a17973d4300000000000000000000000093f200ab988991e63255066d632d66a01f902dae","Library":"","SwarmSource":"bzzr://9d302897806b77192fb87a583ac2f10ad7b04a5d30e4bdf0e609f4ccec6b30a1"}]}