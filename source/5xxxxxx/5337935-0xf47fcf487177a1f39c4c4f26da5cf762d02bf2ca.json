{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract CrowdsaleParameters {\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Production Config\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    // ICO period timestamps:\r\n    // 1524182400 = April 20, 2018.\r\n    // 1529452800 = June 20, 2018.\r\n\r\n    uint256 public constant generalSaleStartDate = 1524182400;\r\n    uint256 public constant generalSaleEndDate = 1529452800;\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // QA Config\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Configuration Independent Parameters\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    struct AddressTokenAllocation {\r\n        address addr;\r\n        uint256 amount;\r\n    }\r\n\r\n    AddressTokenAllocation internal generalSaleWallet = AddressTokenAllocation(0x5aCdaeF4fa410F38bC26003d0F441d99BB19265A, 22800000);\r\n    AddressTokenAllocation internal bounty = AddressTokenAllocation(0xc1C77Ff863bdE913DD53fD6cfE2c68Dfd5AE4f7F, 2000000);\r\n    AddressTokenAllocation internal partners = AddressTokenAllocation(0x307744026f34015111B04ea4D3A8dB9FdA2650bb, 3200000);\r\n    AddressTokenAllocation internal team = AddressTokenAllocation(0xCC4271d219a2c33a92aAcB4C8D010e9FBf664D1c, 12000000);\r\n    AddressTokenAllocation internal featureDevelopment = AddressTokenAllocation(0x06281A31e1FfaC1d3877b29150bdBE93073E043B, 0);\r\n}\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Sets contract owner to address of constructor caller\r\n    */\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  Change Owner\r\n    *\r\n    *  Changes ownership of this contract. Only owner can call this method.\r\n    *\r\n    * @param newOwner - new owner's address\r\n    */\r\n    function changeOwner(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        require(newOwner != owner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract SBIToken is Owned, CrowdsaleParameters {\r\n    using SafeMath for uint256;\r\n    /* Public variables of the token */\r\n    string public standard = 'ERC20/SBI';\r\n    string public name = 'Subsoil Blockchain Investitions';\r\n    string public symbol = 'SBI';\r\n    uint8 public decimals = 18;\r\n\r\n    /* Arrays of all balances */\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    mapping (address => mapping (address => bool)) private allowanceUsed;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Issuance(uint256 _amount); // triggered when the total supply is increased\r\n    event Destruction(uint256 _amount); // triggered when the total supply is decreased\r\n\r\n    event NewSBIToken(address _token);\r\n\r\n    /* Miscellaneous */\r\n    uint256 public totalSupply = 0; // 40000000;\r\n    bool public transfersEnabled = true;\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Initializes contract with initial supply tokens to the creator of the contract\r\n    */\r\n\r\n    function SBIToken() public {\r\n        owner = msg.sender;\r\n        mintToken(generalSaleWallet);\r\n        mintToken(bounty);\r\n        mintToken(partners);\r\n        mintToken(team);\r\n        NewSBIToken(address(this));\r\n    }\r\n\r\n    modifier transfersAllowed {\r\n        require(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  1. Associate crowdsale contract address with this Token\r\n    *  2. Allocate general sale amount\r\n    *\r\n    * @param _crowdsaleAddress - crowdsale contract address\r\n    */\r\n    function approveCrowdsale(address _crowdsaleAddress) external onlyOwner {\r\n        approveAllocation(generalSaleWallet, _crowdsaleAddress);\r\n    }\r\n\r\n    function approveAllocation(AddressTokenAllocation tokenAllocation, address _crowdsaleAddress) internal {\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint amount = tokenAllocation.amount * exponent;\r\n\r\n        allowed[tokenAllocation.addr][_crowdsaleAddress] = amount;\r\n        Approval(tokenAllocation.addr, _crowdsaleAddress, amount);\r\n    }\r\n\r\n    /**\r\n    *  Get token balance of an address\r\n    *\r\n    * @param _address - address to query\r\n    * @return Token balance of _address\r\n    */\r\n    function balanceOf(address _address) public constant returns (uint256 balance) {\r\n        return balances[_address];\r\n    }\r\n\r\n    /**\r\n    *  Get token amount allocated for a transaction from _owner to _spender addresses\r\n    *\r\n    * @param _owner - owner address, i.e. address to transfer from\r\n    * @param _spender - spender address, i.e. address to transfer to\r\n    * @return Remaining amount allowed to be transferred\r\n    */\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    *  Send coins from sender's address to address specified in parameters\r\n    *\r\n    * @param _to - address to send to\r\n    * @param _value - amount to send in Wei\r\n    */\r\n\r\n    function transfer(address _to, uint256 _value) public transfersAllowed onlyPayloadSize(2*32) returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Create token and credit it to target address\r\n    *  Created tokens need to vest\r\n    *\r\n    */\r\n    function mintToken(AddressTokenAllocation tokenAllocation) internal {\r\n\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint mintedAmount = tokenAllocation.amount * exponent;\r\n\r\n        // Mint happens right here: Balance becomes non-zero from zero\r\n        balances[tokenAllocation.addr] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n\r\n        // Emit Issue and Transfer events\r\n        Issuance(mintedAmount);\r\n        Transfer(address(this), tokenAllocation.addr, mintedAmount);\r\n    }\r\n\r\n    /**\r\n    *  Allow another contract to spend some tokens on your behalf\r\n    *\r\n    * @param _spender - address to allocate tokens for\r\n    * @param _value - number of tokens to allocate\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\r\n        require(_value == 0 || allowanceUsed[msg.sender][_spender] == false);\r\n        allowed[msg.sender][_spender] = _value;\r\n        allowanceUsed[msg.sender][_spender] = false;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  A contract attempts to get the coins. Tokens should be previously allocated\r\n    *\r\n    * @param _to - address to transfer tokens to\r\n    * @param _from - address to transfer tokens from\r\n    * @param _value - number of tokens to transfer\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed onlyPayloadSize(3*32) returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Default method\r\n    *\r\n    *  This unnamed function is called whenever someone tries to send ether to\r\n    *  it. Just revert transaction because there is nothing that Token can do\r\n    *  with incoming ether.\r\n    *\r\n    *  Missing payable modifier prevents accidental sending of ether\r\n    */\r\n    function() public {}\r\n\r\n    /**\r\n    *  Enable or disable transfers\r\n    *\r\n    * @param _enable - True = enable, False = disable\r\n    */\r\n    function toggleTransfers(bool _enable) external onlyOwner {\r\n        transfersEnabled = _enable;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalSaleEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"name\":\"approveCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"toggleTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalSaleStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"NewSBIToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SBIToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fbf20ca15fda6c24ad611862ef47dccd3ca14dc2b5decdef2aee09f5aee44601"}]}