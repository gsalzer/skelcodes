{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DBC {\r\n\r\n    // MODIFIERS\r\n\r\n    modifier pre_cond(bool condition) {\r\n        require(condition);\r\n        _;\r\n    }\r\n\r\n    modifier post_cond(bool condition) {\r\n        _;\r\n        assert(condition);\r\n    }\r\n\r\n    modifier invariant(bool condition) {\r\n        require(condition);\r\n        _;\r\n        assert(condition);\r\n    }\r\n}\r\n\r\ncontract Owned is DBC {\r\n\r\n    // FIELDS\r\n\r\n    address public owner;\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    function isOwner() internal returns (bool) { return msg.sender == owner; }\r\n\r\n}\r\n\r\ncontract AssetRegistrar is DBC, Owned {\r\n\r\n    // TYPES\r\n\r\n    struct Asset {\r\n        address breakIn; // Break in contract on destination chain\r\n        address breakOut; // Break out contract on this chain; A way to leave\r\n        bytes32 chainId; // On which chain this asset resides\r\n        uint decimal; // Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\r\n        bool exists; // Is this asset registered\r\n        string ipfsHash; // Same as url but for ipfs\r\n        string name; // Human-readable name of the Asset as in ERC223 token standard\r\n        uint price; // Price of asset quoted against `QUOTE_ASSET` * 10 ** decimals\r\n        string symbol; // Human-readable symbol of the Asset as in ERC223 token standard\r\n        uint timestamp; // Timestamp of last price update of this asset\r\n        string url; // URL for additional information of Asset\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // Methods fields\r\n    mapping (address => Asset) public information;\r\n\r\n    // METHODS\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @notice Registers an Asset residing in a chain\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofAsset is registered\r\n    /// @param ofAsset Address of asset to be registered\r\n    /// @param name Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param symbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param decimal Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param url Url for extended information of the asset\r\n    /// @param ipfsHash Same as url but for ipfs\r\n    /// @param chainId Chain where the asset resides\r\n    /// @param breakIn Address of break in contract on destination chain\r\n    /// @param breakOut Address of break out contract on this chain\r\n    function register(\r\n        address ofAsset,\r\n        string name,\r\n        string symbol,\r\n        uint decimal,\r\n        string url,\r\n        string ipfsHash,\r\n        bytes32 chainId,\r\n        address breakIn,\r\n        address breakOut\r\n    )\r\n        pre_cond(isOwner())\r\n        pre_cond(!information[ofAsset].exists)\r\n    {\r\n        Asset asset = information[ofAsset];\r\n        asset.name = name;\r\n        asset.symbol = symbol;\r\n        asset.decimal = decimal;\r\n        asset.url = url;\r\n        asset.ipfsHash = ipfsHash;\r\n        asset.breakIn = breakIn;\r\n        asset.breakOut = breakOut;\r\n        asset.exists = true;\r\n        assert(information[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Updates description information of a registered Asset\r\n    /// @dev Pre: Owner can change an existing entry\r\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\r\n    /// @param ofAsset Address of the asset to be updated\r\n    /// @param name Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param symbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param url Url for extended information of the asset\r\n    /// @param ipfsHash Same as url but for ipfs\r\n    function updateDescriptiveInformation(\r\n        address ofAsset,\r\n        string name,\r\n        string symbol,\r\n        string url,\r\n        string ipfsHash\r\n    )\r\n        pre_cond(isOwner())\r\n        pre_cond(information[ofAsset].exists)\r\n    {\r\n        Asset asset = information[ofAsset];\r\n        asset.name = name;\r\n        asset.symbol = symbol;\r\n        asset.url = url;\r\n        asset.ipfsHash = ipfsHash;\r\n    }\r\n\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofAsset address for which specific information is requested\r\n    function remove(\r\n        address ofAsset\r\n    )\r\n        pre_cond(isOwner())\r\n        pre_cond(information[ofAsset].exists)\r\n    {\r\n        delete information[ofAsset]; // Sets exists boolean to false\r\n        assert(!information[ofAsset].exists);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get asset specific information\r\n    function getName(address ofAsset) view returns (string) { return information[ofAsset].name; }\r\n    function getSymbol(address ofAsset) view returns (string) { return information[ofAsset].symbol; }\r\n    function getDecimals(address ofAsset) view returns (uint) { return information[ofAsset].decimal; }\r\n\r\n}\r\n\r\ninterface PriceFeedInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PriceUpdated(uint timestamp);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function update(address[] ofAssets, uint[] newPrices);\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get asset specific information\r\n    function getName(address ofAsset) view returns (string);\r\n    function getSymbol(address ofAsset) view returns (string);\r\n    function getDecimals(address ofAsset) view returns (uint);\r\n    // Get price feed operation specific information\r\n    function getQuoteAsset() view returns (address);\r\n    function getInterval() view returns (uint);\r\n    function getValidity() view returns (uint);\r\n    function getLastUpdateId() view returns (uint);\r\n    // Get asset specific information as updated in price feed\r\n    function hasRecentPrice(address ofAsset) view returns (bool isRecent);\r\n    function hasRecentPrices(address[] ofAssets) view returns (bool areRecent);\r\n    function getPrice(address ofAsset) view returns (bool isRecent, uint price, uint decimal);\r\n    function getPrices(address[] ofAssets) view returns (bool areRecent, uint[] prices, uint[] decimals);\r\n    function getInvertedPrice(address ofAsset) view returns (bool isRecent, uint invertedPrice, uint decimal);\r\n    function getReferencePrice(address ofBase, address ofQuote) view returns (bool isRecent, uint referencePrice, uint decimal);\r\n    function getOrderPrice(\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (uint orderPrice);\r\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset) view returns (bool isExistent);\r\n}\r\n\r\ncontract PriceFeed is PriceFeedInterface, AssetRegistrar, DSMath {\r\n\r\n    // FIELDS\r\n\r\n    // Constructor fields\r\n    address public QUOTE_ASSET; // Asset of a portfolio against which all other assets are priced\r\n    /// Note: Interval is purely self imposed and for information purposes only\r\n    uint public INTERVAL; // Frequency of updates in seconds\r\n    uint public VALIDITY; // Time in seconds for which data is considered recent\r\n    uint updateId;        // Update counter for this pricefeed; used as a check during investment\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Define and register a quote asset against which all prices are measured/based against\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param quoteAssetName Name of quote asset\r\n    /// @param quoteAssetSymbol Symbol for quote asset\r\n    /// @param quoteAssetDecimals Decimal places for quote asset\r\n    /// @param quoteAssetUrl URL related to quote asset\r\n    /// @param quoteAssetIpfsHash IPFS hash associated with quote asset\r\n    /// @param quoteAssetChainId Chain ID associated with quote asset (e.g. \"1\" for main Ethereum network)\r\n    /// @param quoteAssetBreakIn Break-in address for the quote asset\r\n    /// @param quoteAssetBreakOut Break-out address for the quote asset\r\n    /// @param interval Number of seconds between pricefeed updates (this interval is not enforced on-chain, but should be followed by the datafeed maintainer)\r\n    /// @param validity Number of seconds that datafeed update information is valid for\r\n    function PriceFeed(\r\n        address ofQuoteAsset, // Inital entry in asset registrar contract is Melon (QUOTE_ASSET)\r\n        string quoteAssetName,\r\n        string quoteAssetSymbol,\r\n        uint quoteAssetDecimals,\r\n        string quoteAssetUrl,\r\n        string quoteAssetIpfsHash,\r\n        bytes32 quoteAssetChainId,\r\n        address quoteAssetBreakIn,\r\n        address quoteAssetBreakOut,\r\n        uint interval,\r\n        uint validity\r\n    ) {\r\n        QUOTE_ASSET = ofQuoteAsset;\r\n        register(\r\n            QUOTE_ASSET,\r\n            quoteAssetName,\r\n            quoteAssetSymbol,\r\n            quoteAssetDecimals,\r\n            quoteAssetUrl,\r\n            quoteAssetIpfsHash,\r\n            quoteAssetChainId,\r\n            quoteAssetBreakIn,\r\n            quoteAssetBreakOut\r\n        );\r\n        INTERVAL = interval;\r\n        VALIDITY = validity;\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    /// @param newPrices list of prices for each of the assets\r\n    function update(address[] ofAssets, uint[] newPrices)\r\n        pre_cond(isOwner())\r\n        pre_cond(ofAssets.length == newPrices.length)\r\n    {\r\n        updateId += 1;\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            require(information[ofAssets[i]].timestamp != now); // prevent two updates in one block\r\n            require(information[ofAssets[i]].exists);\r\n            information[ofAssets[i]].timestamp = now;\r\n            information[ofAssets[i]].price = newPrices[i];\r\n        }\r\n        PriceUpdated(now);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get pricefeed specific information\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getInterval() view returns (uint) { return INTERVAL; }\r\n    function getValidity() view returns (uint) { return VALIDITY; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    /// @notice Whether price of asset has been updated less than VALIDITY seconds ago\r\n    /// @param ofAsset Existend asset in AssetRegistrar\r\n    /// @return isRecent Price information ofAsset is recent\r\n    function hasRecentPrice(address ofAsset)\r\n        view\r\n        pre_cond(information[ofAsset].exists)\r\n        returns (bool isRecent)\r\n    {\r\n        return sub(now, information[ofAsset].timestamp) <= VALIDITY;\r\n    }\r\n\r\n    /// @notice Whether prices of assets have been updated less than VALIDITY seconds ago\r\n    /// @param ofAssets All asstes existend in AssetRegistrar\r\n    /// @return isRecent Price information ofAssets array is recent\r\n    function hasRecentPrices(address[] ofAssets)\r\n        view\r\n        returns (bool areRecent)\r\n    {\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            if (!hasRecentPrice(ofAssets[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\r\n    @dev Asset has been registered\r\n    @param ofAsset Asset for which price should be returned\r\n    @return {\r\n      \"isRecent\": \"Whether the returned price is valid (as defined by VALIDITY)\",\r\n      \"price\": \"Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers\",\r\n      \"decimal\": \"Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\",\r\n    }\r\n    */\r\n    function getPrice(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint price, uint decimal)\r\n    {\r\n        return (\r\n            hasRecentPrice(ofAsset),\r\n            information[ofAsset].price,\r\n            information[ofAsset].decimal\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice Price of a registered asset in format (bool areRecent, uint[] prices, uint[] decimals)\r\n    @dev Convention for price formatting: mul(price, 10 ** decimal), to avoid floating numbers\r\n    @param ofAssets Assets for which prices should be returned\r\n    @return {\r\n        \"areRecent\":    \"Whether all of the prices are fresh, given VALIDITY interval\",\r\n        \"prices\":       \"Array of prices\",\r\n        \"decimals\":     \"Array of decimal places for returned assets\"\r\n    }\r\n    */\r\n    function getPrices(address[] ofAssets)\r\n        view\r\n        returns (bool areRecent, uint[] prices, uint[] decimals)\r\n    {\r\n        areRecent = true;\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            var (isRecent, price, decimal) = getPrice(ofAssets[i]);\r\n            if (!isRecent) {\r\n                areRecent = false;\r\n            }\r\n            prices[i] = price;\r\n            decimals[i] = decimal;\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Gets inverted price of an asset\r\n    @dev Asset has been initialised and its price is non-zero\r\n    @dev Existing price ofAssets quoted in QUOTE_ASSET (convention)\r\n    @param ofAsset Asset for which inverted price should be return\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"invertedPrice\": \"Price based (instead of quoted) against QUOTE_ASSET\",\r\n        \"decimal\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getInvertedPrice(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint invertedPrice, uint decimal)\r\n    {\r\n        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        var (isInvertedRecent, inputPrice, assetDecimal) = getPrice(ofAsset);\r\n\r\n        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\r\n        uint quoteDecimal = getDecimals(QUOTE_ASSET);\r\n\r\n        return (\r\n            isInvertedRecent,\r\n            mul(10 ** uint(quoteDecimal), 10 ** uint(assetDecimal)) / inputPrice,\r\n            quoteDecimal\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice Gets reference price of an asset pair\r\n    @dev One of the address is equal to quote asset\r\n    @dev either ofBase == QUOTE_ASSET or ofQuote == QUOTE_ASSET\r\n    @param ofBase Address of base asset\r\n    @param ofQuote Address of quote asset\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"referencePrice\": \"Reference price\",\r\n        \"decimal\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getReferencePrice(address ofBase, address ofQuote)\r\n        view\r\n        returns (bool isRecent, uint referencePrice, uint decimal)\r\n    {\r\n        if (getQuoteAsset() == ofQuote) {\r\n            (isRecent, referencePrice, decimal) = getPrice(ofBase);\r\n        } else if (getQuoteAsset() == ofBase) {\r\n            (isRecent, referencePrice, decimal) = getInvertedPrice(ofQuote);\r\n        } else {\r\n            revert(); // no suitable reference price available\r\n        }\r\n    }\r\n\r\n    /// @notice Gets price of Order\r\n    /// @param sellAsset Address of the asset to be sold\r\n    /// @param buyAsset Address of the asset to be bought\r\n    /// @param sellQuantity Quantity in base units being sold of sellAsset\r\n    /// @param buyQuantity Quantity in base units being bought of buyAsset\r\n    /// @return orderPrice Price as determined by an order\r\n    function getOrderPrice(\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        view\r\n        returns (uint orderPrice)\r\n    {\r\n        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\r\n    }\r\n\r\n    /// @notice Checks whether data exists for a given asset pair\r\n    /// @dev Prices are only upated against QUOTE_ASSET\r\n    /// @param sellAsset Asset for which check to be done if data exists\r\n    /// @param buyAsset Asset for which check to be done if data exists\r\n    /// @return Whether assets exist for given asset pair\r\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\r\n        view\r\n        returns (bool isExistent)\r\n    {\r\n        return\r\n            hasRecentPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            hasRecentPrice(buyAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) && // One asset must be QUOTE_ASSET\r\n            (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET); // Pair must consists of diffrent assets\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"sellAsset\",\"type\":\"address\"},{\"name\":\"buyAsset\",\"type\":\"address\"},{\"name\":\"sellQuantity\",\"type\":\"uint256\"},{\"name\":\"buyQuantity\",\"type\":\"uint256\"}],\"name\":\"getOrderPrice\",\"outputs\":[{\"name\":\"orderPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAssets\",\"type\":\"address[]\"}],\"name\":\"hasRecentPrices\",\"outputs\":[{\"name\":\"areRecent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getInvertedPrice\",\"outputs\":[{\"name\":\"isRecent\",\"type\":\"bool\"},{\"name\":\"invertedPrice\",\"type\":\"uint256\"},{\"name\":\"decimal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastUpdateId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAssets\",\"type\":\"address[]\"},{\"name\":\"newPrices\",\"type\":\"uint256[]\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VALIDITY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"isRecent\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"decimal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAssets\",\"type\":\"address[]\"}],\"name\":\"getPrices\",\"outputs\":[{\"name\":\"areRecent\",\"type\":\"bool\"},{\"name\":\"prices\",\"type\":\"uint256[]\"},{\"name\":\"decimals\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"ipfsHash\",\"type\":\"string\"}],\"name\":\"updateDescriptiveInformation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"information\",\"outputs\":[{\"name\":\"breakIn\",\"type\":\"address\"},{\"name\":\"breakOut\",\"type\":\"address\"},{\"name\":\"chainId\",\"type\":\"bytes32\"},{\"name\":\"decimal\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"ipfsHash\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofNewOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofBase\",\"type\":\"address\"},{\"name\":\"ofQuote\",\"type\":\"address\"}],\"name\":\"getReferencePrice\",\"outputs\":[{\"name\":\"isRecent\",\"type\":\"bool\"},{\"name\":\"referencePrice\",\"type\":\"uint256\"},{\"name\":\"decimal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"hasRecentPrice\",\"outputs\":[{\"name\":\"isRecent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getSymbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQuoteAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimal\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"ipfsHash\",\"type\":\"string\"},{\"name\":\"chainId\",\"type\":\"bytes32\"},{\"name\":\"breakIn\",\"type\":\"address\"},{\"name\":\"breakOut\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellAsset\",\"type\":\"address\"},{\"name\":\"buyAsset\",\"type\":\"address\"}],\"name\":\"existsPriceOnAssetPair\",\"outputs\":[{\"name\":\"isExistent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUOTE_ASSET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ofQuoteAsset\",\"type\":\"address\"},{\"name\":\"quoteAssetName\",\"type\":\"string\"},{\"name\":\"quoteAssetSymbol\",\"type\":\"string\"},{\"name\":\"quoteAssetDecimals\",\"type\":\"uint256\"},{\"name\":\"quoteAssetUrl\",\"type\":\"string\"},{\"name\":\"quoteAssetIpfsHash\",\"type\":\"string\"},{\"name\":\"quoteAssetChainId\",\"type\":\"bytes32\"},{\"name\":\"quoteAssetBreakIn\",\"type\":\"address\"},{\"name\":\"quoteAssetBreakOut\",\"type\":\"address\"},{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"validity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"}]","ContractName":"PriceFeed","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000beb9ef514a379b997e0798fdcc901ee474b6d9a1000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000022086b5eed81db5f691c36cc83eb58cb5205bd2090bf3763a19f0c5bf2f074dd84b000000000000000000000000083c41ea13af6c2d5aaddf6e73142eb9a7b00183000000000000000000000000083c41ea13af6c2d5aaddf6e73142eb9a7b001830000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000000000b4d656c6f6e20546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034d4c4e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d6d656c6f6e706f72742e636f6d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042307838366235656564383164623566363931633336636338336562353863623532303562643230393062663337363361313966306335626632663037346464383462000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://3465ce9240eb7d223821199fb13a191d92e2f3908ad16b74941d1847eca274b1"}]}