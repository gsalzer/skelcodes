{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n /// @title Ownable contract - base contract with an owner\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n}\r\n\r\n /// @title SafeMath contract - math operations with safety checks\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal pure  returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal pure returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n /// @title ERC20 interface see https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint);\r\n  function allowance(address owner, address spender) public constant returns (uint);  \r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n  function approve(address spender, uint value) public returns (bool ok);\r\n  function decimals() public constant returns (uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SilentNotaryTokenStorage is SafeMath, Ownable {\r\n\r\n  /// Information about frozen portion of tokens\r\n  struct FrozenPortion {\r\n    /// Earliest time when this portion will become available\r\n    uint unfreezeTime;\r\n\r\n    /// Frozen balance portion, in percents\r\n    uint portionPercent;\r\n\r\n    /// Frozen token amount\r\n    uint portionAmount;\r\n\r\n    /// Is this portion unfrozen (withdrawn) after freeze period has finished\r\n    bool isUnfrozen;\r\n  }\r\n\r\n  /// Specified amount of tokens was unfrozen\r\n  event Unfrozen(uint tokenAmount);\r\n\r\n  /// SilentNotary token contract\r\n  ERC20 public token;\r\n\r\n  /// All frozen portions of the contract token balance\r\n  FrozenPortion[] public frozenPortions;\r\n\r\n  /// Team wallet to withdraw unfrozen tokens\r\n  address public teamWallet;\r\n\r\n  /// Deployment time of this contract, which is also the start point to count freeze periods\r\n  uint public deployedTime;\r\n\r\n  /// Is current token amount fixed (must be to unfreeze)\r\n  bool public amountFixed;\r\n\r\n  /// @dev Constructor\r\n  /// @param _token SilentNotary token contract address\r\n  /// @param _teamWallet Wallet address to withdraw unfrozen tokens\r\n  /// @param _freezePeriods Ordered array of freeze periods\r\n  /// @param _freezePortions Ordered array of balance portions to freeze, in percents\r\n  function SilentNotaryTokenStorage (address _token, address _teamWallet, uint[] _freezePeriods, uint[] _freezePortions) public {\r\n    require(_token > 0);\r\n    require(_teamWallet > 0);\r\n    require(_freezePeriods.length > 0);\r\n    require(_freezePeriods.length == _freezePortions.length);\r\n\r\n    token = ERC20(_token);\r\n    teamWallet = _teamWallet;\r\n    deployedTime = now;\r\n\r\n    var cumulativeTime = deployedTime;\r\n    uint cumulativePercent = 0;\r\n    for (uint i = 0; i < _freezePeriods.length; i++) {\r\n      require(_freezePortions[i] > 0 && _freezePortions[i] <= 100);\r\n      cumulativePercent = safeAdd(cumulativePercent, _freezePortions[i]);\r\n      cumulativeTime = safeAdd(cumulativeTime, _freezePeriods[i]);\r\n      frozenPortions.push(FrozenPortion({\r\n        portionPercent: _freezePortions[i],\r\n        unfreezeTime: cumulativeTime,\r\n        portionAmount: 0,\r\n        isUnfrozen: false}));\r\n    }\r\n    assert(cumulativePercent == 100);\r\n  }\r\n\r\n  /// @dev Unfreeze currently available amount of tokens\r\n  function unfreeze() public onlyOwner {\r\n    require(amountFixed);\r\n\r\n    uint unfrozenTokens = 0;\r\n    for (uint i = 0; i < frozenPortions.length; i++) {\r\n      var portion = frozenPortions[i];\r\n      if (portion.isUnfrozen)\r\n        continue;\r\n      if (portion.unfreezeTime < now) {\r\n        unfrozenTokens = safeAdd(unfrozenTokens, portion.portionAmount);\r\n        portion.isUnfrozen = true;\r\n      }\r\n      else\r\n        break;\r\n    }\r\n    transferTokens(unfrozenTokens);\r\n  }\r\n\r\n  /// @dev Fix current token amount (calculate absolute values of every portion)\r\n  function fixAmount() public onlyOwner {\r\n    require(!amountFixed);\r\n    amountFixed = true;\r\n\r\n    uint currentBalance = token.balanceOf(this);\r\n    for (uint i = 0; i < frozenPortions.length; i++) {\r\n      var portion = frozenPortions[i];\r\n      portion.portionAmount = safeDiv(safeMul(currentBalance, portion.portionPercent), 100);\r\n    }\r\n  }\r\n\r\n  /// @dev Withdraw remaining tokens after all freeze periods are over (in case there were additional token transfers)\r\n  function withdrawRemainder() public onlyOwner {\r\n    for (uint i = 0; i < frozenPortions.length; i++) {\r\n      if (!frozenPortions[i].isUnfrozen)\r\n        revert();\r\n    }\r\n    transferTokens(token.balanceOf(this));\r\n  }\r\n\r\n  function transferTokens(uint tokenAmount) private {\r\n    require(tokenAmount > 0);\r\n    var transferSuccess = token.transfer(teamWallet, tokenAmount);\r\n    assert(transferSuccess);\r\n    Unfrozen(tokenAmount);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"frozenPortions\",\"outputs\":[{\"name\":\"unfreezeTime\",\"type\":\"uint256\"},{\"name\":\"portionPercent\",\"type\":\"uint256\"},{\"name\":\"portionAmount\",\"type\":\"uint256\"},{\"name\":\"isUnfrozen\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fixAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountFixed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_teamWallet\",\"type\":\"address\"},{\"name\":\"_freezePeriods\",\"type\":\"uint256[]\"},{\"name\":\"_freezePortions\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Unfrozen\",\"type\":\"event\"}]","ContractName":"SilentNotaryTokenStorage","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002859021ee7f2cb10162e67f33af2d22764b31aff00000000000000000000000000b43d3faa03fa867d0da9dd5907c785b47d5dfa000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000005bbfb9d0000000000000000000000000000000000000000000000000000000005cafaad0000000000000000000000000000000000000000000000000000000005e922fd0000000000000000000000000000000000000000000000000000000006073635000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000001900000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000019","Library":"","SwarmSource":"bzzr://246565be6e2eaf034326748590c26e9d43dc898878036f8d7432329524434fb5"}]}