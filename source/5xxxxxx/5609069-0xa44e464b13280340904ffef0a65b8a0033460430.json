{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address internal contractOwner;\r\n\r\n  constructor () internal {\r\n    if(contractOwner == address(0)){\r\n      contractOwner = msg.sender;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == contractOwner);\r\n    _;\r\n  }\r\n  \r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    contractOwner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  bool private paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to allow actions only when the contract IS paused\r\n     @dev If is paused msg.value is send back\r\n   */\r\n  modifier whenNotPaused() {\r\n    if(paused == true && msg.value > 0){\r\n      msg.sender.transfer(msg.value);\r\n    }\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Called by the owner to pause, triggers stopped state\r\n   */\r\n  function triggerPause() onlyOwner external {\r\n    paused = !paused;\r\n  }\r\n\r\n}\r\n\r\n\r\n/// @title A contract for creating new champs and making withdrawals\r\ncontract ChampFactory is Pausable{\r\n\r\n    event NewChamp(uint256 champID, address owner);\r\n\r\n    using SafeMath for uint; //SafeMath for overflow prevention\r\n\r\n    /*\r\n     * Variables\r\n     */\r\n    struct Champ {\r\n        uint256 id; //same as position in Champ[]\r\n        uint256 attackPower;\r\n        uint256 defencePower;\r\n        uint256 cooldownTime; //how long does it take to be ready attack again\r\n        uint256 readyTime; //if is smaller than block.timestamp champ is ready to fight\r\n        uint256 winCount;\r\n        uint256 lossCount;\r\n        uint256 position; //position in leaderboard. subtract 1 and you got position in leaderboard[]\r\n        uint256 price; //selling price\r\n        uint256 withdrawCooldown; //if you one of the 800 best champs and withdrawCooldown is less as block.timestamp then you get ETH reward\r\n        uint256 eq_sword; \r\n        uint256 eq_shield; \r\n        uint256 eq_helmet; \r\n        bool forSale; //is champ for sale?\r\n    }\r\n    \r\n    struct AddressInfo {\r\n        uint256 withdrawal;\r\n        uint256 champsCount;\r\n        uint256 itemsCount;\r\n        string name;\r\n    }\r\n\r\n    //Item struct\r\n    struct Item {\r\n        uint8 itemType; // 1 - Sword | 2 - Shield | 3 - Helmet\r\n        uint8 itemRarity; // 1 - Common | 2 - Uncommon | 3 - Rare | 4 - Epic | 5 - Legendery | 6 - Forged\r\n        uint256 attackPower;\r\n        uint256 defencePower;\r\n        uint256 cooldownReduction;\r\n        uint256 price;\r\n        uint256 onChampId; //can not be used to decide if item is on champ, because champ's id can be 0, 'bool onChamp' solves it.\r\n        bool onChamp; \r\n        bool forSale; //is item for sale?\r\n    }\r\n    \r\n    mapping (address => AddressInfo) public addressInfo;\r\n    mapping (uint256 => address) public champToOwner;\r\n    mapping (uint256 => address) public itemToOwner;\r\n    mapping (uint256 => string) public champToName;\r\n    \r\n    Champ[] public champs;\r\n    Item[] public items;\r\n    uint256[] public leaderboard;\r\n    \r\n    uint256 internal createChampFee = 5 finney;\r\n    uint256 internal lootboxFee = 5 finney;\r\n    uint256 internal pendingWithdrawal = 0;\r\n    uint256 private randNonce = 0; //being used in generating random numbers\r\n    uint256 public champsForSaleCount;\r\n    uint256 public itemsForSaleCount;\r\n    \r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n    /// @dev Checks if msg.sender is owner of champ\r\n    modifier onlyOwnerOfChamp(uint256 _champId) {\r\n        require(msg.sender == champToOwner[_champId]);\r\n        _;\r\n    }\r\n    \r\n\r\n    /// @dev Checks if msg.sender is NOT owner of champ\r\n    modifier onlyNotOwnerOfChamp(uint256 _champId) {\r\n        require(msg.sender != champToOwner[_champId]);\r\n        _;\r\n    }\r\n    \r\n\r\n    /// @notice Checks if amount was sent\r\n    modifier isPaid(uint256 _price){\r\n        require(msg.value >= _price);\r\n        _;\r\n    }\r\n\r\n\r\n    /// @notice People are allowed to withdraw only if min. balance (0.01 gwei) is reached\r\n    modifier contractMinBalanceReached(){\r\n        require( (address(this).balance).sub(pendingWithdrawal) > 1000000 );\r\n        _;\r\n    }\r\n\r\n\r\n    /// @notice Checks if withdraw cooldown passed \r\n    modifier isChampWithdrawReady(uint256 _id){\r\n        require(champs[_id].withdrawCooldown < block.timestamp);\r\n        _;\r\n    }\r\n\r\n\r\n    /// @notice Distribute input funds between contract owner and players\r\n    modifier distributeInput(address _affiliateAddress){\r\n\r\n        //contract owner\r\n        uint256 contractOwnerWithdrawal = (msg.value / 100) * 50; // 50%\r\n        addressInfo[contractOwner].withdrawal += contractOwnerWithdrawal;\r\n        pendingWithdrawal += contractOwnerWithdrawal;\r\n\r\n        //affiliate\r\n        //checks if _affiliateAddress is set & if affiliate address is not buying player\r\n        if(_affiliateAddress != address(0) && _affiliateAddress != msg.sender){\r\n            uint256 affiliateBonus = (msg.value / 100) * 25; //provision is 25%\r\n            addressInfo[_affiliateAddress].withdrawal += affiliateBonus;\r\n            pendingWithdrawal += affiliateBonus;\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /*\r\n     * View\r\n     */\r\n    /// @notice Gets champs by address\r\n    /// @param _owner Owner address\r\n    function getChampsByOwner(address _owner) external view returns(uint256[]) {\r\n        uint256[] memory result = new uint256[](addressInfo[_owner].champsCount);\r\n        uint256 counter = 0;\r\n        for (uint256 i = 0; i < champs.length; i++) {\r\n            if (champToOwner[i] == _owner) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    /// @notice Gets total champs count\r\n    function getChampsCount() external view returns(uint256){\r\n        return champs.length;\r\n    }\r\n    \r\n\r\n    /// @notice Gets champ's reward in wei\r\n    function getChampReward(uint256 _position) public view returns(uint256) {\r\n        if(_position <= 800){\r\n            //percentageMultipier = 10,000\r\n            //maxReward = 2000 = .2% * percentageMultipier\r\n            //subtractPerPosition = 2 = .0002% * percentageMultipier\r\n            //2000 - (2 * (_position - 1))\r\n            uint256 rewardPercentage = uint256(2000).sub(2 * (_position - 1));\r\n\r\n            //available funds are all funds - already pending\r\n            uint256 availableWithdrawal = address(this).balance.sub(pendingWithdrawal);\r\n\r\n            //calculate reward for champ's position\r\n            //1000000 = percentageMultipier * 100\r\n            return availableWithdrawal / 1000000 * rewardPercentage;\r\n        }else{\r\n            return uint256(0);\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Internal\r\n     */\r\n    /// @notice Generates random modulus\r\n    /// @param _modulus Max random modulus\r\n    function randMod(uint256 _modulus) internal returns(uint256) {\r\n        randNonce++;\r\n        return uint256(keccak256(randNonce, blockhash(block.number - 1))) % _modulus;\r\n    }\r\n    \r\n\r\n\r\n    /*\r\n     * External\r\n     */\r\n    /// @notice Creates new champ\r\n    /// @param _affiliateAddress Affiliate address (optional)\r\n    function createChamp(address _affiliateAddress) external payable \r\n    whenNotPaused\r\n    isPaid(createChampFee) \r\n    distributeInput(_affiliateAddress) \r\n    {\r\n\r\n        /* \r\n        Champ memory champ = Champ({\r\n             id: 0,\r\n             attackPower: 2 + randMod(4),\r\n             defencePower: 1 + randMod(4),\r\n             cooldownTime: uint256(1 days) - uint256(randMod(9) * 1 hours),\r\n             readyTime: 0,\r\n             winCount: 0,\r\n             lossCount: 0,\r\n             position: leaderboard.length + 1, //Last place in leaderboard is new champ's position. Used in new champ struct bellow. +1 to avoid zero position.\r\n             price: 0,\r\n             withdrawCooldown: uint256(block.timestamp), \r\n             eq_sword: 0,\r\n             eq_shield: 0, \r\n             eq_helmet: 0, \r\n             forSale: false \r\n        });   \r\n        */\r\n\r\n        // This line bellow is about 30k gas cheaper than lines above. They are the same. Lines above are just more readable.\r\n        uint256 id = champs.push(Champ(0, 2 + randMod(4), 1 + randMod(4), uint256(1 days)  - uint256(randMod(9) * 1 hours), 0, 0, 0, leaderboard.length + 1, 0, uint256(block.timestamp), 0,0,0, false)) - 1;     \r\n        \r\n        \r\n        champs[id].id = id; //sets id in Champ struct  \r\n        leaderboard.push(id); //push champ on the last place in leaderboard  \r\n        champToOwner[id] = msg.sender; //sets owner of this champ - msg.sender\r\n        addressInfo[msg.sender].champsCount++;\r\n\r\n        emit NewChamp(id, msg.sender);\r\n\r\n    }\r\n\r\n\r\n    /// @notice Change \"CreateChampFee\". If ETH price will grow up it can expensive to create new champ.\r\n    /// @param _fee New \"CreateChampFee\"\r\n    /// @dev Only owner of contract can change \"CreateChampFee\"\r\n    function setCreateChampFee(uint256 _fee) external onlyOwner {\r\n        createChampFee = _fee;\r\n    }\r\n    \r\n\r\n    /// @notice Change champ's name\r\n    function changeChampsName(uint _champId, string _name) external \r\n    onlyOwnerOfChamp(_champId){\r\n        champToName[_champId] = _name;\r\n    }\r\n\r\n\r\n    /// @notice Change players's name\r\n    function changePlayersName(string _name) external {\r\n        addressInfo[msg.sender].name = _name;\r\n    }\r\n\r\n\r\n    /// @notice Withdraw champ's reward\r\n    /// @param _id Champ id\r\n    /// @dev Move champ reward to pending withdrawal to his wallet. \r\n    function withdrawChamp(uint _id) external \r\n    onlyOwnerOfChamp(_id) \r\n    contractMinBalanceReached  \r\n    isChampWithdrawReady(_id) \r\n    whenNotPaused {\r\n        Champ storage champ = champs[_id];\r\n        require(champ.position <= 800);\r\n\r\n        champ.withdrawCooldown = block.timestamp + 1 days; //one withdrawal 1 per day\r\n\r\n        uint256 withdrawal = getChampReward(champ.position);\r\n        addressInfo[msg.sender].withdrawal += withdrawal;\r\n        pendingWithdrawal += withdrawal;\r\n    }\r\n    \r\n\r\n    /// @dev Send all pending funds of caller's address\r\n    function withdrawToAddress(address _address) external \r\n    whenNotPaused {\r\n        address playerAddress = _address;\r\n        if(playerAddress == address(0)){ playerAddress = msg.sender; }\r\n        uint256 share = addressInfo[playerAddress].withdrawal; //gets pending funds\r\n        require(share > 0); //is it more than 0?\r\n\r\n        //first sets players withdrawal pending to 0 and subtract amount from playerWithdrawals then transfer funds to avoid reentrancy\r\n        addressInfo[playerAddress].withdrawal = 0; //set player's withdrawal pendings to 0 \r\n        pendingWithdrawal = pendingWithdrawal.sub(share); //subtract share from total pendings \r\n        \r\n        playerAddress.transfer(share); //transfer\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n/// @title  Moderates items and creates new ones\r\ncontract Items is ChampFactory {\r\n\r\n    event NewItem(uint256 itemID, address owner);\r\n\r\n    constructor () internal {\r\n        //item -> nothing\r\n        items.push(Item(0, 0, 0, 0, 0, 0, 0, false, false));\r\n    }\r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n    /// @notice Checks if sender is owner of item\r\n    modifier onlyOwnerOfItem(uint256 _itemId) {\r\n        require(_itemId != 0);\r\n        require(msg.sender == itemToOwner[_itemId]);\r\n        _;\r\n    }\r\n    \r\n\r\n    /// @notice Checks if sender is NOT owner of item\r\n    modifier onlyNotOwnerOfItem(uint256 _itemId) {\r\n        require(msg.sender != itemToOwner[_itemId]);\r\n        _;\r\n    }\r\n\r\n\r\n    /*\r\n     * View\r\n     */\r\n    ///@notice Check if champ has something on\r\n    ///@param _type Sword, shield or helmet\r\n    function hasChampSomethingOn(uint _champId, uint8 _type) internal view returns(bool){\r\n        Champ storage champ = champs[_champId];\r\n        if(_type == 1){\r\n            return (champ.eq_sword == 0) ? false : true;\r\n        }\r\n        if(_type == 2){\r\n            return (champ.eq_shield == 0) ? false : true;\r\n        }\r\n        if(_type == 3){\r\n            return (champ.eq_helmet == 0) ? false : true;\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Gets items by address\r\n    /// @param _owner Owner address\r\n    function getItemsByOwner(address _owner) external view returns(uint256[]) {\r\n        uint256[] memory result = new uint256[](addressInfo[_owner].itemsCount);\r\n        uint256 counter = 0;\r\n        for (uint256 i = 0; i < items.length; i++) {\r\n            if (itemToOwner[i] == _owner) {\r\n                result[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    /*\r\n     * Public\r\n     */\r\n    ///@notice Takes item off champ\r\n    function takeOffItem(uint _champId, uint8 _type) public \r\n        onlyOwnerOfChamp(_champId) {\r\n            uint256 itemId;\r\n            Champ storage champ = champs[_champId];\r\n            if(_type == 1){\r\n                itemId = champ.eq_sword; //Get item ID\r\n                if (itemId > 0) { //0 = nothing\r\n                    champ.eq_sword = 0; //take off sword\r\n                }\r\n            }\r\n            if(_type == 2){\r\n                itemId = champ.eq_shield; //Get item ID\r\n                if(itemId > 0) {//0 = nothing\r\n                    champ.eq_shield = 0; //take off shield\r\n                }\r\n            }\r\n            if(_type == 3){\r\n                itemId = champ.eq_helmet; //Get item ID\r\n                if(itemId > 0) { //0 = nothing\r\n                    champ.eq_helmet = 0; //take off \r\n                }\r\n            }\r\n            if(itemId > 0){\r\n                items[itemId].onChamp = false; //item is free to use, is not on champ\r\n            }\r\n    }\r\n\r\n\r\n\r\n    /*\r\n     * External\r\n     */\r\n    ///@notice Puts item on champ\r\n    function putOn(uint256 _champId, uint256 _itemId) external \r\n        onlyOwnerOfChamp(_champId) \r\n        onlyOwnerOfItem(_itemId) {\r\n            Champ storage champ = champs[_champId];\r\n            Item storage item = items[_itemId];\r\n\r\n            //checks if items is on some other champ\r\n            if(item.onChamp){\r\n                takeOffItem(item.onChampId, item.itemType); //take off from champ\r\n            }\r\n\r\n            item.onChamp = true; //item is on champ\r\n            item.onChampId = _champId; //champ's id\r\n\r\n            //put on\r\n            if(item.itemType == 1){\r\n                //take off actual sword \r\n                if(champ.eq_sword > 0){\r\n                    takeOffItem(champ.id, 1);\r\n                }\r\n                champ.eq_sword = _itemId; //put on sword\r\n            }\r\n            if(item.itemType == 2){\r\n                //take off actual shield \r\n                if(champ.eq_shield > 0){\r\n                    takeOffItem(champ.id, 2);\r\n                }\r\n                champ.eq_shield = _itemId; //put on shield\r\n            }\r\n            if(item.itemType == 3){\r\n                //take off actual helmet \r\n                if(champ.eq_helmet > 0){\r\n                    takeOffItem(champ.id, 3);\r\n                }\r\n                champ.eq_helmet = _itemId; //put on helmet\r\n            }\r\n    }\r\n\r\n\r\n\r\n    /// @notice Opens loot box and generates new item\r\n    function openLootbox(address _affiliateAddress) external payable \r\n    whenNotPaused\r\n    isPaid(lootboxFee) \r\n    distributeInput(_affiliateAddress) {\r\n\r\n        uint256 pointToCooldownReduction;\r\n        uint256 randNum = randMod(1001); //random number <= 1000\r\n        uint256 pointsToShare; //total points given\r\n        uint256 itemID;\r\n\r\n        //sets up item\r\n        Item memory item = Item({\r\n            itemType: uint8(uint256(randMod(3) + 1)), //generates item type - max num is 2 -> 0 + 1 SWORD | 1 + 1 SHIELD | 2 + 1 HELMET;\r\n            itemRarity: uint8(0),\r\n            attackPower: 0,\r\n            defencePower: 0,\r\n            cooldownReduction: 0,\r\n            price: 0,\r\n            onChampId: 0,\r\n            onChamp: false,\r\n            forSale: false\r\n        });\r\n        \r\n        // Gets Rarity of item\r\n        // 45% common\r\n        // 27% uncommon\r\n        // 19% rare\r\n        // 7%  epic\r\n        // 2%  legendary\r\n        if(450 > randNum){\r\n            pointsToShare = 25 + randMod(9); //25 basic + random number max to 8\r\n            item.itemRarity = uint8(1);\r\n        }else if(720 > randNum){\r\n            pointsToShare = 42 + randMod(17); //42 basic + random number max to 16\r\n            item.itemRarity = uint8(2);\r\n        }else if(910 > randNum){\r\n            pointsToShare = 71 + randMod(25); //71 basic + random number max to 24\r\n            item.itemRarity = uint8(3);\r\n        }else if(980 > randNum){\r\n            pointsToShare = 119 + randMod(33); //119 basic + random number max to 32\r\n            item.itemRarity = uint8(4);\r\n        }else{\r\n            pointsToShare = 235 + randMod(41); //235 basic + random number max to 40\r\n            item.itemRarity = uint8(5);\r\n        }\r\n        \r\n\r\n        //Gets type of item\r\n        if(item.itemType == uint8(1)){ //ITEM IS SWORDS\r\n            item.attackPower = pointsToShare / 10 * 7; //70% attackPower\r\n            pointsToShare -= item.attackPower; //points left;\r\n                \r\n            item.defencePower = pointsToShare / 10 * randMod(6); //up to 15% defencePower\r\n            pointsToShare -= item.defencePower; //points left;\r\n                \r\n            item.cooldownReduction = pointsToShare * uint256(1 minutes); //rest of points is cooldown reduction\r\n            item.itemType = uint8(1);\r\n        }\r\n        \r\n        if(item.itemType == uint8(2)){ //ITEM IS SHIELD\r\n            item.defencePower = pointsToShare / 10 * 7; //70% defencePower\r\n            pointsToShare -= item.defencePower; //points left;\r\n                \r\n            item.attackPower = pointsToShare / 10 * randMod(6); //up to 15% attackPowerPower\r\n            pointsToShare -= item.attackPower; //points left;\r\n                \r\n            item.cooldownReduction = pointsToShare * uint256(1 minutes); //rest of points is cooldown reduction\r\n            item.itemType = uint8(2);\r\n        }\r\n        \r\n        if(item.itemType == uint8(3)){ //ITEM IS HELMET\r\n            pointToCooldownReduction = pointsToShare / 10 * 7; //70% cooldown reduction\r\n            item.cooldownReduction = pointToCooldownReduction * uint256(1 minutes); //points to time\r\n            pointsToShare -= pointToCooldownReduction; //points left;\r\n                \r\n            item.attackPower = pointsToShare / 10 * randMod(6); //up to 15% attackPower\r\n            pointsToShare -= item.attackPower; //points left;\r\n                \r\n            item.defencePower = pointsToShare; //rest of points is defencePower\r\n            item.itemType = uint8(3);\r\n        }\r\n\r\n        itemID = items.push(item) - 1;\r\n        \r\n        itemToOwner[itemID] = msg.sender; //sets owner of this item - msg.sender\r\n        addressInfo[msg.sender].itemsCount++; //every address has count of items    \r\n\r\n        emit NewItem(itemID, msg.sender);    \r\n\r\n    }\r\n\r\n    /// @notice Change \"lootboxFee\". \r\n    /// @param _fee New \"lootboxFee\"\r\n    /// @dev Only owner of contract can change \"lootboxFee\"\r\n    function setLootboxFee(uint _fee) external onlyOwner {\r\n        lootboxFee = _fee;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Moderates buying and selling items\r\ncontract ItemMarket is Items {\r\n\r\n    event TransferItem(address from, address to, uint256 itemID);\r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n    ///@notice Checks if item is for sale\r\n    modifier itemIsForSale(uint256 _id){\r\n        require(items[_id].forSale);\r\n        _;\r\n    }\r\n\r\n    ///@notice Checks if item is NOT for sale\r\n    modifier itemIsNotForSale(uint256 _id){\r\n        require(items[_id].forSale == false);\r\n        _;\r\n    }\r\n\r\n    ///@notice If item is for sale then cancel sale\r\n    modifier ifItemForSaleThenCancelSale(uint256 _itemID){\r\n      Item storage item = items[_itemID];\r\n      if(item.forSale){\r\n          _cancelItemSale(item);\r\n      }\r\n      _;\r\n    }\r\n\r\n\r\n    ///@notice Distribute sale eth input\r\n    modifier distributeSaleInput(address _owner) { \r\n        uint256 contractOwnerCommision; //1%\r\n        uint256 playerShare; //99%\r\n        \r\n        if(msg.value > 100){\r\n            contractOwnerCommision = (msg.value / 100);\r\n            playerShare = msg.value - contractOwnerCommision;\r\n        }else{\r\n            contractOwnerCommision = 0;\r\n            playerShare = msg.value;\r\n        }\r\n\r\n        addressInfo[_owner].withdrawal += playerShare;\r\n        addressInfo[contractOwner].withdrawal += contractOwnerCommision;\r\n        pendingWithdrawal += playerShare + contractOwnerCommision;\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /*\r\n     * View\r\n     */\r\n    function getItemsForSale() view external returns(uint256[]){\r\n        uint256[] memory result = new uint256[](itemsForSaleCount);\r\n        if(itemsForSaleCount > 0){\r\n            uint256 counter = 0;\r\n            for (uint256 i = 0; i < items.length; i++) {\r\n                if (items[i].forSale == true) {\r\n                    result[counter]=i;\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n     /*\r\n     * Private\r\n     */\r\n    ///@notice Cancel sale. Should not be called without checking if item is really for sale.\r\n    function _cancelItemSale(Item storage item) private {\r\n      //No need to overwrite item's price\r\n      item.forSale = false;\r\n      itemsForSaleCount--;\r\n    }\r\n\r\n\r\n    /*\r\n     * Internal\r\n     */\r\n    /// @notice Transfer item\r\n    function transferItem(address _from, address _to, uint256 _itemID) internal \r\n      ifItemForSaleThenCancelSale(_itemID) {\r\n        Item storage item = items[_itemID];\r\n\r\n        //take off      \r\n        if(item.onChamp && _to != champToOwner[item.onChampId]){\r\n          takeOffItem(item.onChampId, item.itemType);\r\n        }\r\n\r\n        addressInfo[_to].itemsCount++;\r\n        addressInfo[_from].itemsCount--;\r\n        itemToOwner[_itemID] = _to;\r\n\r\n        emit TransferItem(_from, _to, _itemID);\r\n    }\r\n\r\n\r\n\r\n    /*\r\n     * Public\r\n     */\r\n    /// @notice Calls transfer item\r\n    /// @notice Address _from is msg.sender. Cannot be used is market, bc msg.sender is buyer\r\n    function giveItem(address _to, uint256 _itemID) public \r\n      onlyOwnerOfItem(_itemID) {\r\n        transferItem(msg.sender, _to, _itemID);\r\n    }\r\n    \r\n\r\n    /// @notice Calcels item's sale\r\n    function cancelItemSale(uint256 _id) public \r\n    itemIsForSale(_id) \r\n    onlyOwnerOfItem(_id){\r\n      Item storage item = items[_id];\r\n       _cancelItemSale(item);\r\n    }\r\n\r\n\r\n    /*\r\n     * External\r\n     */\r\n    /// @notice Sets item for sale\r\n    function setItemForSale(uint256 _id, uint256 _price) external \r\n      onlyOwnerOfItem(_id) \r\n      itemIsNotForSale(_id) {\r\n        Item storage item = items[_id];\r\n        item.forSale = true;\r\n        item.price = _price;\r\n        itemsForSaleCount++;\r\n    }\r\n    \r\n    \r\n    /// @notice Buys item\r\n    function buyItem(uint256 _id) external payable \r\n      whenNotPaused \r\n      onlyNotOwnerOfItem(_id) \r\n      itemIsForSale(_id) \r\n      isPaid(items[_id].price) \r\n      distributeSaleInput(itemToOwner[_id]) \r\n      {\r\n        transferItem(itemToOwner[_id], msg.sender, _id);\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n/// @title Manages forging\r\ncontract ItemForge is ItemMarket {\r\n\r\n\tevent Forge(uint256 forgedItemID);\r\n\r\n\t///@notice Forge items together\r\n\tfunction forgeItems(uint256 _parentItemID, uint256 _childItemID) external \r\n\tonlyOwnerOfItem(_parentItemID) \r\n\tonlyOwnerOfItem(_childItemID) \r\n\tifItemForSaleThenCancelSale(_parentItemID) \r\n\tifItemForSaleThenCancelSale(_childItemID) {\r\n\r\n\t\t//checks if items are not the same\r\n        require(_parentItemID != _childItemID);\r\n        \r\n\t\tItem storage parentItem = items[_parentItemID];\r\n\t\tItem storage childItem = items[_childItemID];\r\n\r\n\t\t//take child item off, because child item will be burned\r\n\t\tif(childItem.onChamp){\r\n\t\t\ttakeOffItem(childItem.onChampId, childItem.itemType);\r\n\t\t}\r\n\r\n\t\t//update parent item\r\n\t\tparentItem.attackPower = (parentItem.attackPower > childItem.attackPower) ? parentItem.attackPower : childItem.attackPower;\r\n\t\tparentItem.defencePower = (parentItem.defencePower > childItem.defencePower) ? parentItem.defencePower : childItem.defencePower;\r\n\t\tparentItem.cooldownReduction = (parentItem.cooldownReduction > childItem.cooldownReduction) ? parentItem.cooldownReduction : childItem.cooldownReduction;\r\n\t\tparentItem.itemRarity = uint8(6);\r\n\r\n\t\t//burn child item\r\n\t\ttransferItem(msg.sender, address(0), _childItemID);\r\n\r\n\t\temit Forge(_parentItemID);\r\n\t}\r\n\r\n}\r\n\r\n\r\n/// @title Manages attacks in game\r\ncontract ChampAttack is ItemForge {\r\n    \r\n    event Attack(uint256 winnerChampID, uint256 defeatedChampID, bool didAttackerWin);\r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n     /// @notice Is champ ready to fight again?\r\n    modifier isChampReady(uint256 _champId) {\r\n      require (champs[_champId].readyTime <= block.timestamp);\r\n      _;\r\n    }\r\n\r\n\r\n    /// @notice Prevents from self-attack\r\n    modifier notSelfAttack(uint256 _champId, uint256 _targetId) {\r\n        require(_champId != _targetId); \r\n        _;\r\n    }\r\n\r\n\r\n    /// @notice Checks if champ does exist\r\n    modifier targetExists(uint256 _targetId){\r\n        require(champToOwner[_targetId] != address(0)); \r\n        _;\r\n    }\r\n\r\n\r\n    /*\r\n     * View\r\n     */\r\n    /// @notice Gets champ's attack power, defence power and cooldown reduction with items on\r\n    function getChampStats(uint256 _champId) public view returns(uint256,uint256,uint256){\r\n        Champ storage champ = champs[_champId];\r\n        Item storage sword = items[champ.eq_sword];\r\n        Item storage shield = items[champ.eq_shield];\r\n        Item storage helmet = items[champ.eq_helmet];\r\n\r\n        //AP\r\n        uint256 totalAttackPower = champ.attackPower + sword.attackPower + shield.attackPower + helmet.attackPower; //Gets champs AP\r\n\r\n        //DP\r\n        uint256 totalDefencePower = champ.defencePower + sword.defencePower + shield.defencePower + helmet.defencePower; //Gets champs  DP\r\n\r\n        //CR\r\n        uint256 totalCooldownReduction = sword.cooldownReduction + shield.cooldownReduction + helmet.cooldownReduction; //Gets  CR\r\n\r\n        return (totalAttackPower, totalDefencePower, totalCooldownReduction);\r\n    }\r\n\r\n\r\n    /*\r\n     * Pure\r\n     */\r\n    /// @notice Subtracts ability points. Helps to not cross minimal attack ability points -> 2\r\n    /// @param _playerAttackPoints Actual player's attack points\r\n    /// @param _x Amount to subtract \r\n    function subAttack(uint256 _playerAttackPoints, uint256 _x) internal pure returns (uint256) {\r\n        return (_playerAttackPoints <= _x + 2) ? 2 : _playerAttackPoints - _x;\r\n    }\r\n    \r\n\r\n    /// @notice Subtracts ability points. Helps to not cross minimal defence ability points -> 1\r\n    /// @param _playerDefencePoints Actual player's defence points\r\n    /// @param _x Amount to subtract \r\n    function subDefence(uint256 _playerDefencePoints, uint256 _x) internal pure returns (uint256) {\r\n        return (_playerDefencePoints <= _x) ? 1 : _playerDefencePoints - _x;\r\n    }\r\n    \r\n\r\n    /*\r\n     * Private\r\n     */\r\n    /// @dev Is called from from Attack function after the winner is already chosen\r\n    /// @dev Updates abilities, champ's stats and swaps positions\r\n    function _attackCompleted(Champ storage _winnerChamp, Champ storage _defeatedChamp, uint256 _pointsGiven, uint256 _pointsToAttackPower) private {\r\n        /*\r\n         * Updates abilities after fight\r\n         */\r\n        //winner abilities update\r\n        _winnerChamp.attackPower += _pointsToAttackPower; //increase attack power\r\n        _winnerChamp.defencePower += _pointsGiven - _pointsToAttackPower; //max point that was given - already given to AP\r\n                \r\n        //defeated champ's abilities update\r\n        //checks for not cross minimal AP & DP points\r\n        _defeatedChamp.attackPower = subAttack(_defeatedChamp.attackPower, _pointsToAttackPower); //decrease attack power\r\n        _defeatedChamp.defencePower = subDefence(_defeatedChamp.defencePower, _pointsGiven - _pointsToAttackPower); // decrease defence power\r\n\r\n\r\n\r\n        /*\r\n         * Update champs' wins and losses\r\n         */\r\n        _winnerChamp.winCount++;\r\n        _defeatedChamp.lossCount++;\r\n            \r\n\r\n\r\n        /*\r\n         * Swap positions\r\n         */\r\n        if(_winnerChamp.position > _defeatedChamp.position) { //require loser to has better (lower) postion than attacker\r\n            uint256 winnerPosition = _winnerChamp.position;\r\n            uint256 loserPosition = _defeatedChamp.position;\r\n        \r\n            _defeatedChamp.position = winnerPosition;\r\n            _winnerChamp.position = loserPosition;\r\n        \r\n            //position in champ struct is always one point bigger than in leaderboard array\r\n            leaderboard[winnerPosition - 1] = _defeatedChamp.id;\r\n            leaderboard[loserPosition - 1] = _winnerChamp.id;\r\n        }\r\n    }\r\n    \r\n    \r\n    /// @dev Gets pointsGiven and pointsToAttackPower\r\n    function _getPoints(uint256 _pointsGiven) private returns (uint256 pointsGiven, uint256 pointsToAttackPower){\r\n        return (_pointsGiven, randMod(_pointsGiven+1));\r\n    }\r\n\r\n\r\n\r\n    /*\r\n     * External\r\n     */\r\n    /// @notice Attack function\r\n    /// @param _champId Attacker champ\r\n    /// @param _targetId Target champ\r\n    function attack(uint256 _champId, uint256 _targetId) external \r\n    onlyOwnerOfChamp(_champId) \r\n    isChampReady(_champId) \r\n    notSelfAttack(_champId, _targetId) \r\n    targetExists(_targetId) {\r\n        Champ storage myChamp = champs[_champId]; \r\n        Champ storage enemyChamp = champs[_targetId]; \r\n        uint256 pointsGiven; //total points that will be divided between AP and DP\r\n        uint256 pointsToAttackPower; //part of points that will be added to attack power, the rest of points go to defence power\r\n        uint256 myChampAttackPower;  \r\n        uint256 enemyChampDefencePower; \r\n        uint256 myChampCooldownReduction;\r\n        \r\n        (myChampAttackPower,,myChampCooldownReduction) = getChampStats(_champId);\r\n        (,enemyChampDefencePower,) = getChampStats(_targetId);\r\n\r\n\r\n        //if attacker's AP is more than target's DP then attacker wins\r\n        if (myChampAttackPower > enemyChampDefencePower) {\r\n            \r\n            //this should demotivate players from farming on way weaker champs than they are\r\n            //the bigger difference between AP & DP is, the reward is smaller\r\n            if(myChampAttackPower - enemyChampDefencePower < 5){\r\n                \r\n                //big experience - 3 ability points\r\n                (pointsGiven, pointsToAttackPower) = _getPoints(3);\r\n                \r\n                \r\n            }else if(myChampAttackPower - enemyChampDefencePower < 10){\r\n                \r\n                //medium experience - 2 ability points\r\n                (pointsGiven, pointsToAttackPower) = _getPoints(2);\r\n                \r\n            }else{\r\n                \r\n                //small experience - 1 ability point to random ability (attack power or defence power)\r\n                (pointsGiven, pointsToAttackPower) = _getPoints(1);\r\n                \r\n            }\r\n            \r\n            _attackCompleted(myChamp, enemyChamp, pointsGiven, pointsToAttackPower);\r\n\r\n            emit Attack(myChamp.id, enemyChamp.id, true);\r\n\r\n        } else {\r\n            \r\n            //1 ability point to random ability (attack power or defence power)\r\n            (pointsGiven, pointsToAttackPower) = _getPoints(1);\r\n\r\n            _attackCompleted(enemyChamp, myChamp, pointsGiven, pointsToAttackPower);\r\n\r\n            emit Attack(enemyChamp.id, myChamp.id, false);\r\n             \r\n        }\r\n        \r\n        //Trigger cooldown for attacker\r\n        myChamp.readyTime = uint256(block.timestamp + myChamp.cooldownTime - myChampCooldownReduction);\r\n\r\n    }\r\n    \r\n}\r\n\r\n\r\n/// @title Moderates buying and selling champs\r\ncontract ChampMarket is ChampAttack {\r\n\r\n    event TransferChamp(address from, address to, uint256 champID);\r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n    ///@notice Require champ to be sale\r\n    modifier champIsForSale(uint256 _id){\r\n        require(champs[_id].forSale);\r\n        _;\r\n    }\r\n    \r\n\r\n    ///@notice Require champ NOT to be for sale\r\n    modifier champIsNotForSale(uint256 _id){\r\n        require(champs[_id].forSale == false);\r\n        _;\r\n    }\r\n    \r\n\r\n    ///@notice If champ is for sale then cancel sale\r\n    modifier ifChampForSaleThenCancelSale(uint256 _champID){\r\n      Champ storage champ = champs[_champID];\r\n      if(champ.forSale){\r\n          _cancelChampSale(champ);\r\n      }\r\n      _;\r\n    }\r\n    \r\n\r\n    /*\r\n     * View\r\n     */\r\n    ///@notice Gets all champs for sale\r\n    function getChampsForSale() view external returns(uint256[]){\r\n        uint256[] memory result = new uint256[](champsForSaleCount);\r\n        if(champsForSaleCount > 0){\r\n            uint256 counter = 0;\r\n            for (uint256 i = 0; i < champs.length; i++) {\r\n                if (champs[i].forSale == true) {\r\n                    result[counter]=i;\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    \r\n    /*\r\n     * Private\r\n     */\r\n     ///@dev Cancel sale. Should not be called without checking if champ is really for sale.\r\n     function _cancelChampSale(Champ storage champ) private {\r\n        //cancel champ's sale\r\n        //no need waste gas to overwrite his price.\r\n        champ.forSale = false;\r\n        champsForSaleCount--;\r\n     }\r\n     \r\n\r\n    /*\r\n     * Internal\r\n     */\r\n    /// @notice Transfer champ\r\n    function transferChamp(address _from, address _to, uint256 _champId) internal ifChampForSaleThenCancelSale(_champId){\r\n        Champ storage champ = champs[_champId];\r\n\r\n        //transfer champ\r\n        addressInfo[_to].champsCount++;\r\n        addressInfo[_from].champsCount--;\r\n        champToOwner[_champId] = _to;\r\n\r\n        //transfer items\r\n        if(champ.eq_sword != 0) { transferItem(_from, _to, champ.eq_sword); }\r\n        if(champ.eq_shield != 0) { transferItem(_from, _to, champ.eq_shield); }\r\n        if(champ.eq_helmet != 0) { transferItem(_from, _to, champ.eq_helmet); }\r\n\r\n        emit TransferChamp(_from, _to, _champId);\r\n    }\r\n\r\n\r\n\r\n    /*\r\n     * Public\r\n     */\r\n    /// @notice Champ is no more for sale\r\n    function cancelChampSale(uint256 _id) public \r\n      champIsForSale(_id) \r\n      onlyOwnerOfChamp(_id) {\r\n        Champ storage champ = champs[_id];\r\n        _cancelChampSale(champ);\r\n    }\r\n\r\n\r\n    /*\r\n     * External\r\n     */\r\n    /// @notice Gift champ\r\n    /// @dev Address _from is msg.sender\r\n    function giveChamp(address _to, uint256 _champId) external \r\n      onlyOwnerOfChamp(_champId) {\r\n        transferChamp(msg.sender, _to, _champId);\r\n    }\r\n\r\n\r\n    /// @notice Sets champ for sale\r\n    function setChampForSale(uint256 _id, uint256 _price) external \r\n      onlyOwnerOfChamp(_id) \r\n      champIsNotForSale(_id) {\r\n        Champ storage champ = champs[_id];\r\n        champ.forSale = true;\r\n        champ.price = _price;\r\n        champsForSaleCount++;\r\n    }\r\n    \r\n    \r\n    /// @notice Buys champ\r\n    function buyChamp(uint256 _id) external payable \r\n      whenNotPaused \r\n      onlyNotOwnerOfChamp(_id) \r\n      champIsForSale(_id) \r\n      isPaid(champs[_id].price) \r\n      distributeSaleInput(champToOwner[_id]) {\r\n        transferChamp(champToOwner[_id], msg.sender, _id);\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n/// @title Only used for deploying all contracts\r\ncontract MyCryptoChampCore is ChampMarket {\r\n\t/* \r\n\t\t© Copyright 2018 - Patrik Mojzis\r\n\t\tRedistributing and modifying is prohibited.\r\n\t\t\r\n\t\thttps://mycryptochamp.io/\r\n\r\n\t\tWhat is MyCryptoChamp?\r\n\t\t- Blockchain game about upgrading champs by fighting, getting better items,\r\n\t\t  trading them and the best 800 champs are daily rewarded by real Ether.\r\n\r\n\t\tFeel free to ask any questions\r\n\t\thello@mycryptochamp.io\r\n\t*/\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getItemsForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"itemsForSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"champsForSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressInfo\",\"outputs\":[{\"name\":\"withdrawal\",\"type\":\"uint256\"},{\"name\":\"champsCount\",\"type\":\"uint256\"},{\"name\":\"itemsCount\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getItemsByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChampsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affiliateAddress\",\"type\":\"address\"}],\"name\":\"openLootbox\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdrawChamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentItemID\",\"type\":\"uint256\"},{\"name\":\"_childItemID\",\"type\":\"uint256\"}],\"name\":\"forgeItems\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"}],\"name\":\"getChampStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"},{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"putOn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChampsForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"cancelChampSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"buyChamp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"changePlayersName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_champId\",\"type\":\"uint256\"}],\"name\":\"giveChamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"champToName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affiliateAddress\",\"type\":\"address\"}],\"name\":\"createChamp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"getChampReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"withdrawToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setItemForSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"changeChampsName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leaderboard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"items\",\"outputs\":[{\"name\":\"itemType\",\"type\":\"uint8\"},{\"name\":\"itemRarity\",\"type\":\"uint8\"},{\"name\":\"attackPower\",\"type\":\"uint256\"},{\"name\":\"defencePower\",\"type\":\"uint256\"},{\"name\":\"cooldownReduction\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"onChampId\",\"type\":\"uint256\"},{\"name\":\"onChamp\",\"type\":\"bool\"},{\"name\":\"forSale\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"cancelItemSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"champs\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"attackPower\",\"type\":\"uint256\"},{\"name\":\"defencePower\",\"type\":\"uint256\"},{\"name\":\"cooldownTime\",\"type\":\"uint256\"},{\"name\":\"readyTime\",\"type\":\"uint256\"},{\"name\":\"winCount\",\"type\":\"uint256\"},{\"name\":\"lossCount\",\"type\":\"uint256\"},{\"name\":\"position\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"withdrawCooldown\",\"type\":\"uint256\"},{\"name\":\"eq_sword\",\"type\":\"uint256\"},{\"name\":\"eq_shield\",\"type\":\"uint256\"},{\"name\":\"eq_helmet\",\"type\":\"uint256\"},{\"name\":\"forSale\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setCreateChampFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_itemID\",\"type\":\"uint256\"}],\"name\":\"giveItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"takeOffItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setLootboxFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"},{\"name\":\"_targetId\",\"type\":\"uint256\"}],\"name\":\"attack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"buyItem\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setChampForSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getChampsByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"champToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"champID\",\"type\":\"uint256\"}],\"name\":\"TransferChamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winnerChampID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"defeatedChampID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"didAttackerWin\",\"type\":\"bool\"}],\"name\":\"Attack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"forgedItemID\",\"type\":\"uint256\"}],\"name\":\"Forge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"itemID\",\"type\":\"uint256\"}],\"name\":\"TransferItem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"itemID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewItem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"champID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewChamp\",\"type\":\"event\"}]","ContractName":"MyCryptoChampCore","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b40dade8f6c0f614133fbc9a2d5060fc8b354bf797f111499f7c4e0652842dec"}]}