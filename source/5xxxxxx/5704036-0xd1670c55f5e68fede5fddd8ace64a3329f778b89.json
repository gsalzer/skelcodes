{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/*\r\n * Contract accepting reservations for ATS tokens.\r\n * The actual tokens are not yet created and distributed due to non-technical reasons.\r\n * This contract is used to collect funds for the ATS token sale and to transparently document that on a blockchain.\r\n * It is tailored to allow a simple user journey while keeping complexity minimal.\r\n * Once the privileged \"state controller\" sets the state to \"Open\", anybody can send Ether to the contract.\r\n * Only Ether sent from whitelisted addresses is accepted for future ATS token conversion.\r\n * The whitelisting is done by a dedicated whitelist controller.\r\n * Whitelisting can take place asynchronously - that is, participants don't need to wait for the whitelisting to\r\n * succeed before sending funds. This is a technical detail which allows for a smoother user journey.\r\n * The state controller can switch to synchronous whitelisting (no Ether accepted from accounts not whitelisted before).\r\n * Participants can trigger refunding during the Open state by making a transfer of 0 Ether.\r\n * Funds of those not whitelisted (not accepted) are never locked, they can trigger refund beyond Open state.\r\n * Only in Over state can whitelisted Ether deposits be fetched from the contract.\r\n *\r\n * When setting the state to Open, the state controller specifies a minimal timeframe for this state.\r\n * Transition to the next state (Locked) is not possible (enforced by the contract).\r\n * This gives participants the guarantee that they can get their full deposits refunded anytime and independently\r\n * of the will of anybody else during that timeframe.\r\n * (Note that this is true only as long as the whole process takes place before the date specified by FALLBACK_FETCH_FUNDS_TS)\r\n *\r\n * Ideally, there's no funds left in the contract once the state is set to Over and the accepted deposits were fetched.\r\n * Since this can't really be foreseen, there's a fallback which allows to fetch all remaining Ether\r\n * to a pre-specified address after a pre-specified date.\r\n *\r\n * Static analysis: block.timestamp is not used in a way which gives miners leeway for taking advantage.\r\n *\r\n * see https://code.lab10.io/graz/04-artis/artis/issues/364 for task evolution\r\n */\r\ncontract ATSTokenReservation {\r\n\r\n    // ################### DATA STRUCTURES ###################\r\n\r\n    enum States {\r\n        Init, // initial state. Contract is deployed, but deposits not yet accepted\r\n        Open, // open for token reservations. Refunds possible for all\r\n        Locked, // open for token reservations. Refunds locked for accepted deposits\r\n        Over // contract has done its duty. Funds payout can be triggered by state controller\r\n    }\r\n\r\n    // ################### CONSTANTS ###################\r\n\r\n    // 1. Oct 2018\r\n    uint32 FALLBACK_PAYOUT_TS = 1538352000;\r\n\r\n    // ################### STATE VARIABLES ###################\r\n\r\n    States public state = States.Init;\r\n\r\n    // privileged account: switch contract state, change config, whitelisting, trigger payout, ...\r\n    address public stateController;\r\n\r\n    // privileged account: whitelisting\r\n    address public whitelistController;\r\n\r\n    // Collected funds can be transferred only to this address. Is set in constructor.\r\n    address public payoutAddress;\r\n\r\n    // accepted deposits (received from whitelisted accounts)\r\n    uint256 public cumAcceptedDeposits = 0;\r\n    // not (yet) accepted deposits (received from non-whitelisted accounts)\r\n    uint256 public cumAlienDeposits = 0;\r\n\r\n    // cap for how much we accept (since the amount of tokens sold is also capped)\r\n    uint256 public maxCumAcceptedDeposits = 1E9 * 1E18; // pre-set to effectively unlimited (> existing ETH)\r\n\r\n    uint256 public minDeposit = 0.1 * 1E18; // lower bound per participant (can be a kind of spam protection)\r\n\r\n    uint256 minLockingTs; // earliest possible start of \"locked\" phase\r\n\r\n    // whitelisted addresses (those having \"accepted\" deposits)\r\n    mapping (address => bool) public whitelist;\r\n\r\n    // the state controller can set this in order to disallow deposits from addresses not whitelisted before\r\n    bool public requireWhitelistingBeforeDeposit = false;\r\n\r\n    // tracks accepted deposits (whitelisted accounts)\r\n    mapping (address => uint256) public acceptedDeposits;\r\n\r\n    // tracks alien (not yet accepted) deposits (non-whitelisted accounts)\r\n    mapping (address => uint256) public alienDeposits;\r\n\r\n    // ################### EVENTS ###################\r\n\r\n    // emitted events transparently document the open funding activities.\r\n    // only deposits made by whitelisted accounts (and not followed by a refund) count.\r\n\r\n    event StateTransition(States oldState, States newState);\r\n    event Whitelisted(address addr);\r\n    event Deposit(address addr, uint256 amount);\r\n    event Refund(address addr, uint256 amount);\r\n\r\n    // emitted when the accepted deposits are fetched to an account controlled by the ATS token provider\r\n    event FetchedDeposits(uint256 amount);\r\n\r\n    // ################### MODIFIERS ###################\r\n\r\n    modifier onlyStateControl() { require(msg.sender == stateController, \"no permission\"); _; }\r\n\r\n    modifier onlyWhitelistControl()\t{\r\n        require(msg.sender == stateController || msg.sender == whitelistController, \"no permission\");\r\n        _;\r\n    }\r\n\r\n    modifier requireState(States _requiredState) { require(state == _requiredState, \"wrong state\"); _; }\r\n\r\n    // ################### CONSTRUCTOR ###################\r\n\r\n    // the contract creator is set as stateController\r\n    constructor(address _whitelistController, address _payoutAddress) public {\r\n        whitelistController = _whitelistController;\r\n        payoutAddress = _payoutAddress;\r\n        stateController = msg.sender;\r\n    }\r\n\r\n    // ################### FALLBACK FUNCTION ###################\r\n\r\n    // implements the deposit and refund actions.\r\n    function () payable public {\r\n        if(msg.value > 0) {\r\n            require(state == States.Open || state == States.Locked);\r\n            if(requireWhitelistingBeforeDeposit) {\r\n                require(whitelist[msg.sender] == true, \"not whitelisted\");\r\n            }\r\n            tryDeposit();\r\n        } else {\r\n            tryRefund();\r\n        }\r\n    }\r\n\r\n    // ################### PUBLIC FUNCTIONS ###################\r\n\r\n    function stateSetOpen(uint32 _minLockingTs) public\r\n        onlyStateControl\r\n        requireState(States.Init)\r\n    {\r\n        minLockingTs = _minLockingTs;\r\n        setState(States.Open);\r\n    }\r\n\r\n    function stateSetLocked() public\r\n        onlyStateControl\r\n        requireState(States.Open)\r\n    {\r\n        require(block.timestamp >= minLockingTs);\r\n        setState(States.Locked);\r\n    }\r\n\r\n    function stateSetOver() public\r\n        onlyStateControl\r\n        requireState(States.Locked)\r\n    {\r\n        setState(States.Over);\r\n    }\r\n\r\n    // state controller can change the cap. Reducing possible only if not below current deposits\r\n    function updateMaxAcceptedDeposits(uint256 _newMaxDeposits) public onlyStateControl {\r\n        require(cumAcceptedDeposits <= _newMaxDeposits);\r\n        maxCumAcceptedDeposits = _newMaxDeposits;\r\n    }\r\n\r\n    // new limit to be enforced for future deposits\r\n    function updateMinDeposit(uint256 _newMinDeposit) public onlyStateControl {\r\n        minDeposit = _newMinDeposit;\r\n    }\r\n\r\n    // option to switch between async and sync whitelisting\r\n    function setRequireWhitelistingBeforeDeposit(bool _newState) public onlyStateControl {\r\n        requireWhitelistingBeforeDeposit = _newState;\r\n    }\r\n\r\n    // Since whitelisting can occur asynchronously, an account to be whitelisted may already have deposited Ether.\r\n    // In this case the deposit is converted form alien to accepted.\r\n    // Since the deposit logic depends on the whitelisting status and since transactions are processed sequentially,\r\n    // it's ensured that at any time an account can have either (XOR) no or alien or accepted deposits and that\r\n    // the whitelisting status corresponds to the deposit status (not_whitelisted <-> alien | whitelisted <-> accepted).\r\n    // This function is idempotent.\r\n    function addToWhitelist(address _addr) public onlyWhitelistControl {\r\n        if(whitelist[_addr] != true) {\r\n            // if address has alien deposit: convert it to accepted\r\n            if(alienDeposits[_addr] > 0) {\r\n                cumAcceptedDeposits += alienDeposits[_addr];\r\n                acceptedDeposits[_addr] += alienDeposits[_addr];\r\n                cumAlienDeposits -= alienDeposits[_addr];\r\n                delete alienDeposits[_addr]; // needs to be the last statement in this block!\r\n            }\r\n            whitelist[_addr] = true;\r\n            emit Whitelisted(_addr);\r\n        }\r\n    }\r\n\r\n    // Option for batched whitelisting (for times with crowded chain).\r\n    // caller is responsible to not blow gas limit with too many addresses at once\r\n    function batchAddToWhitelist(address[] _addresses) public onlyWhitelistControl {\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            addToWhitelist(_addresses[i]);\r\n        }\r\n    }\r\n\r\n\r\n    // transfers an alien deposit back to the sender\r\n    function refundAlienDeposit(address _addr) public onlyWhitelistControl {\r\n        // Note: this implementation requires that alienDeposits has a primitive value type.\r\n        // With a complex type, this code would produce a dangling reference.\r\n        uint256 withdrawAmount = alienDeposits[_addr];\r\n        require(withdrawAmount > 0);\r\n        delete alienDeposits[_addr]; // implies setting the value to 0\r\n        cumAlienDeposits -= withdrawAmount;\r\n        emit Refund(_addr, withdrawAmount);\r\n        _addr.transfer(withdrawAmount); // throws on failure\r\n    }\r\n\r\n    // payout of the accepted deposits to the pre-designated address, available once it's all over\r\n    function payout() public\r\n        onlyStateControl\r\n        requireState(States.Over)\r\n    {\r\n        uint256 amount = cumAcceptedDeposits;\r\n        cumAcceptedDeposits = 0;\r\n        emit FetchedDeposits(amount);\r\n        payoutAddress.transfer(amount);\r\n        // not idempotent, but multiple invocation would just trigger zero-transfers\r\n    }\r\n\r\n    // After the specified date, any of the privileged/special accounts can trigger payment of remaining funds\r\n    // to the payoutAddress. This is a safety net to minimize the risk of funds remaining stuck.\r\n    // It's not yet clear what we can / should / are allowed to do with alien deposits which aren't reclaimed.\r\n    // With this fallback in place, we have for example the option to donate them at some point.\r\n    function fallbackPayout() public {\r\n        require(msg.sender == stateController || msg.sender == whitelistController || msg.sender == payoutAddress);\r\n        require(block.timestamp > FALLBACK_PAYOUT_TS);\r\n        payoutAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    // ################### INTERNAL FUNCTIONS ###################\r\n\r\n    // rule enforcement and book-keeping for incoming deposits\r\n    function tryDeposit() internal {\r\n        require(cumAcceptedDeposits + msg.value <= maxCumAcceptedDeposits);\r\n        if(whitelist[msg.sender] == true) {\r\n            require(acceptedDeposits[msg.sender] + msg.value >= minDeposit);\r\n            acceptedDeposits[msg.sender] += msg.value;\r\n            cumAcceptedDeposits += msg.value;\r\n        } else {\r\n            require(alienDeposits[msg.sender] + msg.value >= minDeposit);\r\n            alienDeposits[msg.sender] += msg.value;\r\n            cumAlienDeposits += msg.value;\r\n        }\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    // rule enforcement and book-keeping for refunding requests\r\n    function tryRefund() internal {\r\n        // Note: this implementation requires that acceptedDeposits and alienDeposits have a primitive value type.\r\n        // With a complex type, this code would produce dangling references.\r\n        uint256 withdrawAmount;\r\n        if(whitelist[msg.sender] == true) {\r\n            require(state == States.Open);\r\n            withdrawAmount = acceptedDeposits[msg.sender];\r\n            require(withdrawAmount > 0);\r\n            delete acceptedDeposits[msg.sender]; // implies setting the value to 0\r\n            cumAcceptedDeposits -= withdrawAmount;\r\n        } else {\r\n            // alien deposits can be withdrawn anytime (we prefer to not touch them)\r\n            withdrawAmount = alienDeposits[msg.sender];\r\n            require(withdrawAmount > 0);\r\n            delete alienDeposits[msg.sender]; // implies setting the value to 0\r\n            cumAlienDeposits -= withdrawAmount;\r\n        }\r\n        emit Refund(msg.sender, withdrawAmount);\r\n        // do the actual transfer last as recommended since the DAO incident (Checks-Effects-Interaction pattern)\r\n        msg.sender.transfer(withdrawAmount); // throws on failure\r\n    }\r\n\r\n    function setState(States _newState) internal {\r\n        state = _newState;\r\n        emit StateTransition(state, _newState);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"refundAlienDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requireWhitelistingBeforeDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cumAlienDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"batchAddToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cumAcceptedDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCumAcceptedDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newState\",\"type\":\"bool\"}],\"name\":\"setRequireWhitelistingBeforeDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinDeposit\",\"type\":\"uint256\"}],\"name\":\"updateMinDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"acceptedDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stateController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minLockingTs\",\"type\":\"uint32\"}],\"name\":\"stateSetOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMaxDeposits\",\"type\":\"uint256\"}],\"name\":\"updateMaxAcceptedDeposits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fallbackPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stateSetOver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stateSetLocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"alienDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_whitelistController\",\"type\":\"address\"},{\"name\":\"_payoutAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FetchedDeposits\",\"type\":\"event\"}]","ContractName":"ATSTokenReservation","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000126479017ef69aed88ce5b33fa8b37ffda2b3efc0000000000000000000000003eee4ad7a36b35888823975d8124a714dff22523","Library":"","SwarmSource":"bzzr://3a3998be2566bff4cdd32d60ae846f994290ff88601e3514a80becf298901fde"}]}