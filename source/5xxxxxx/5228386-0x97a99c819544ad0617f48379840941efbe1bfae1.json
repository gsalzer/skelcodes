{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\ncontract SupportedContract {\r\n  // Members can call any contract that exposes a `theCyberMessage` method.\r\n  function theCyberMessage(string) public;\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n  // We want to be able to recover & donate any tokens sent to the contract.\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n}\r\n\r\n\r\ncontract theCyber {\r\n  // theCyber is a decentralized club. It does not support equity memberships,\r\n  // payment of dues, or payouts to the members. Instead, it is meant to enable\r\n  // dapps that allow members to communicate with one another or that provide\r\n  // arbitrary incentives or special access to the club's members. To become a\r\n  // member of theCyber, you must be added by an existing member. Furthermore,\r\n  // existing memberships can be revoked if a given member becomes inactive for\r\n  // too long. Total membership is capped and unique addresses are required.\r\n\r\n  event NewMember(uint8 indexed memberId, bytes32 memberName, address indexed memberAddress);\r\n  event NewMemberName(uint8 indexed memberId, bytes32 newMemberName);\r\n  event NewMemberKey(uint8 indexed memberId, string newMemberKey);\r\n  event MembershipTransferred(uint8 indexed memberId, address newMemberAddress);\r\n  event MemberProclaimedInactive(uint8 indexed memberId, uint8 indexed proclaimingMemberId);\r\n  event MemberHeartbeated(uint8 indexed memberId);\r\n  event MembershipRevoked(uint8 indexed memberId, uint8 indexed revokingMemberId);\r\n  event BroadcastMessage(uint8 indexed memberId, string message);\r\n  event DirectMessage(uint8 indexed memberId, uint8 indexed toMemberId, string message);\r\n  event Call(uint8 indexed memberId, address indexed contractAddress, string message);\r\n  event FundsDonated(uint8 indexed memberId, uint256 value);\r\n  event TokensDonated(uint8 indexed memberId, address tokenContractAddress, uint256 value);\r\n\r\n  // There can only be 256 members (member number 0 to 255) in theCyber.\r\n  uint16 private constant MAXMEMBERS_ = 256;\r\n\r\n  // A membership that has been marked as inactive for 90 days may be revoked.\r\n  uint64 private constant INACTIVITYTIMEOUT_ = 90 days;\r\n\r\n  // Set the ethereum tip jar (ethereumfoundation.eth) as the donation address.\r\n  address private constant DONATIONADDRESS_ = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;\r\n\r\n  // A member has a name, a public key, a date they joined, and a date they were\r\n  // marked as inactive (which is equial to 0 if they are currently active).\r\n  struct Member {\r\n    bool member;\r\n    bytes32 name;\r\n    string pubkey;\r\n    uint64 memberSince;\r\n    uint64 inactiveSince;\r\n  }\r\n\r\n  // Set up a fixed array of members indexed by member id.\r\n  Member[MAXMEMBERS_] internal members_;\r\n\r\n  // Map addresses to booleans designating that they control the membership.\r\n  mapping (address => bool) internal addressIsMember_;\r\n\r\n  // Map addresses to member ids.\r\n  mapping (address => uint8) internal addressToMember_;\r\n\r\n  // Map member ids to addresses that own the membership.\r\n  mapping (uint => address) internal memberToAddress_;\r\n\r\n  // Most methods of the contract, like adding new members or revoking existing\r\n  // inactive members, can only be called by a valid member.\r\n  modifier membersOnly() {\r\n    // Only allow transactions originating from a designated member address.\r\n    require(addressIsMember_[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  // In the constructor function, set up the contract creator as the first\r\n  // member so that other new members can be added.\r\n  function theCyber() public {\r\n    // Log the addition of the first member (contract creator).\r\n    NewMember(0, \"\", msg.sender);\r\n\r\n    // Set up the member: status, name, key, member since & inactive since.\r\n    members_[0] = Member(true, bytes32(\"\"), \"\", uint64(now), 0);\r\n    \r\n    // Set up the address associated with the member.\r\n    memberToAddress_[0] = msg.sender;\r\n\r\n    // Point the address to member's id.\r\n    addressToMember_[msg.sender] = 0;\r\n\r\n    // Grant members-only access to the new member.\r\n    addressIsMember_[msg.sender] = true;\r\n  }\r\n\r\n  // Existing members can designate new users by specifying an unused member id\r\n  // and address. The new member's initial member name should also be supplied.\r\n  function newMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public membersOnly {\r\n    // Members need a non-null address.\r\n    require(_memberAddress != address(0));\r\n\r\n    // Existing members (that have not fallen inactive) cannot be replaced.\r\n    require (!members_[_memberId].member);\r\n\r\n    // One address cannot hold more than one membership.\r\n    require (!addressIsMember_[_memberAddress]);\r\n\r\n    // Log the addition of a new member: (member id, name, address).\r\n    NewMember(_memberId, _memberName, _memberAddress);\r\n\r\n    // Set up the member: status, name, `member since` & `inactive since`.\r\n    members_[_memberId] = Member(true, _memberName, \"\", uint64(now), 0);\r\n    \r\n    // Set up the address associated with the member id.\r\n    memberToAddress_[_memberId] = _memberAddress;\r\n\r\n    // Point the address to the member id.\r\n    addressToMember_[_memberAddress] = _memberId;\r\n\r\n    // Grant members-only access to the new member.\r\n    addressIsMember_[_memberAddress] = true;\r\n  }\r\n\r\n  // Members can set a name (encoded as a hex value) that will be associated\r\n  // with their membership.\r\n  function changeName(bytes32 _newMemberName) public membersOnly {\r\n    // Log the member's name change: (member id, new name).\r\n    NewMemberName(addressToMember_[msg.sender], _newMemberName);\r\n\r\n    // Change the member's name.\r\n    members_[addressToMember_[msg.sender]].name = _newMemberName;\r\n  }\r\n\r\n  // Members can set a public key that will be used for verifying signed\r\n  // messages from the member or encrypting messages intended for the member.\r\n  function changeKey(string _newMemberKey) public membersOnly {\r\n    // Log the member's key change: (member id, new member key).\r\n    NewMemberKey(addressToMember_[msg.sender], _newMemberKey);\r\n\r\n    // Change the member's public key.\r\n    members_[addressToMember_[msg.sender]].pubkey = _newMemberKey;\r\n  }\r\n\r\n  // Members can transfer their membership to a new address; when they do, the\r\n  // fields on the membership are all reset.\r\n  function transferMembership(address _newMemberAddress) public membersOnly {\r\n    // Members need a non-null address.\r\n    require(_newMemberAddress != address(0));\r\n\r\n    // Memberships cannot be transferred to existing members.\r\n    require (!addressIsMember_[_newMemberAddress]);\r\n\r\n    // Log transfer of membership: (member id, new address).\r\n    MembershipTransferred(addressToMember_[msg.sender], _newMemberAddress);\r\n    \r\n    // Revoke members-only access for the old member.\r\n    delete addressIsMember_[msg.sender];\r\n    \r\n    // Reset fields on the membership.\r\n    members_[addressToMember_[msg.sender]].memberSince = uint64(now);\r\n    members_[addressToMember_[msg.sender]].inactiveSince = 0;\r\n    members_[addressToMember_[msg.sender]].name = bytes32(\"\");\r\n    members_[addressToMember_[msg.sender]].pubkey = \"\";\r\n    \r\n    // Replace the address associated with the member id.\r\n    memberToAddress_[addressToMember_[msg.sender]] = _newMemberAddress;\r\n\r\n    // Point the new address to the member id and clean up the old pointer.\r\n    addressToMember_[_newMemberAddress] = addressToMember_[msg.sender];\r\n    delete addressToMember_[msg.sender];\r\n\r\n    // Grant members-only access to the new member.\r\n    addressIsMember_[_newMemberAddress] = true;\r\n  }\r\n\r\n  // As a mechanism to remove members that are no longer active due to lost keys\r\n  // or a lack of engagement, other members may proclaim them as inactive.\r\n  function proclaimInactive(uint8 _memberId) public membersOnly {\r\n    // Members must exist and be currently active to proclaim inactivity.\r\n    require(members_[_memberId].member);\r\n    require(memberIsActive(_memberId));\r\n    \r\n    // Members cannot proclaim themselves as inactive (safety measure).\r\n    require(addressToMember_[msg.sender] != _memberId);\r\n\r\n    // Log proclamation of inactivity: (inactive member id, member id, time).\r\n    MemberProclaimedInactive(_memberId, addressToMember_[msg.sender]);\r\n    \r\n    // Set the `inactiveSince` field on the inactive member.\r\n    members_[_memberId].inactiveSince = uint64(now);\r\n  }\r\n\r\n  // Members that have erroneously been marked as inactive may send a heartbeat\r\n  // to prove that they are still active, voiding the `inactiveSince` property.\r\n  function heartbeat() public membersOnly {\r\n    // Log that the member has heartbeated and is still active.\r\n    MemberHeartbeated(addressToMember_[msg.sender]);\r\n\r\n    // Designate member as active by voiding their `inactiveSince` field.\r\n    members_[addressToMember_[msg.sender]].inactiveSince = 0;\r\n  }\r\n\r\n  // If a member has been marked inactive for the duration of the inactivity\r\n  // timeout, another member may revoke their membership and delete them.\r\n  function revokeMembership(uint8 _memberId) public membersOnly {\r\n    // Members must exist in order to be revoked.\r\n    require(members_[_memberId].member);\r\n\r\n    // Members must be designated as inactive.\r\n    require(!memberIsActive(_memberId));\r\n\r\n    // Members cannot revoke themselves (safety measure).\r\n    require(addressToMember_[msg.sender] != _memberId);\r\n\r\n    // Members must be inactive for the duration of the inactivity timeout.\r\n    require(now >= members_[_memberId].inactiveSince + INACTIVITYTIMEOUT_);\r\n\r\n    // Log that the membership has been revoked.\r\n    MembershipRevoked(_memberId, addressToMember_[msg.sender]);\r\n\r\n    // Revoke members-only access for the member.\r\n    delete addressIsMember_[memberToAddress_[_memberId]];\r\n\r\n    // Delete the pointer linking the address to the member id.\r\n    delete addressToMember_[memberToAddress_[_memberId]];\r\n    \r\n    // Delete the address associated with the member id.\r\n    delete memberToAddress_[_memberId];\r\n\r\n    // Finally, delete the member.\r\n    delete members_[_memberId];\r\n  }\r\n\r\n  // While most messaging is intended to occur off-chain using supplied keys,\r\n  // members can also broadcast a message as an on-chain event.\r\n  function broadcastMessage(string _message) public membersOnly {\r\n    // Log the message.\r\n    BroadcastMessage(addressToMember_[msg.sender], _message);\r\n  }\r\n\r\n  // In addition, members can send direct messagees as an on-chain event. These\r\n  // messages are intended to be encrypted using the recipient's public key.\r\n  function directMessage(uint8 _toMemberId, string _message) public membersOnly {\r\n    // Log the message.\r\n    DirectMessage(addressToMember_[msg.sender], _toMemberId, _message);\r\n  }\r\n\r\n  // Members can also pass a message to any contract that supports it (via the\r\n  // `theCyberMessage(string)` function), designated by the contract address.\r\n  function passMessage(address _contractAddress, string _message) public membersOnly {\r\n    // Log that another contract has been called and passed a message.\r\n    Call(addressToMember_[msg.sender], _contractAddress, _message);\r\n\r\n    // call the method of the target contract and pass in the message.\r\n    SupportedContract(_contractAddress).theCyberMessage(_message);\r\n  }\r\n\r\n  // The contract is not payable by design, but could end up with a balance as\r\n  // a recipient of a selfdestruct / coinbase of a mined block.\r\n  function donateFunds() public membersOnly {\r\n    // Log the donation of any funds that have made their way into the contract.\r\n    FundsDonated(addressToMember_[msg.sender], this.balance);\r\n\r\n    // Send all available funds to the donation address.\r\n    DONATIONADDRESS_.transfer(this.balance);\r\n  }\r\n\r\n  // We also want to be able to access any tokens that are sent to the contract.\r\n  function donateTokens(address _tokenContractAddress) public membersOnly {\r\n    // Make sure that we didn't pass in the current contract address by mistake.\r\n    require(_tokenContractAddress != address(this));\r\n\r\n    // Log the donation of any tokens that have been sent into the contract.\r\n    TokensDonated(addressToMember_[msg.sender], _tokenContractAddress, ERC20(_tokenContractAddress).balanceOf(this));\r\n\r\n    // Send all available tokens at the given contract to the donation address.\r\n    ERC20(_tokenContractAddress).transfer(DONATIONADDRESS_, ERC20(_tokenContractAddress).balanceOf(this));\r\n  }\r\n\r\n  function getMembershipStatus(address _memberAddress) public view returns (bool member, uint8 memberId) {\r\n    return (\r\n      addressIsMember_[_memberAddress],\r\n      addressToMember_[_memberAddress]\r\n    );\r\n  }\r\n\r\n  function getMemberInformation(uint8 _memberId) public view returns (bytes32 memberName, string memberKey, uint64 memberSince, uint64 inactiveSince, address memberAddress) {\r\n    return (\r\n      members_[_memberId].name,\r\n      members_[_memberId].pubkey,\r\n      members_[_memberId].memberSince,\r\n      members_[_memberId].inactiveSince,\r\n      memberToAddress_[_memberId]\r\n    );\r\n  }\r\n\r\n  function maxMembers() public pure returns(uint16) {\r\n    return MAXMEMBERS_;\r\n  }\r\n\r\n  function inactivityTimeout() public pure returns(uint64) {\r\n    return INACTIVITYTIMEOUT_;\r\n  }\r\n\r\n  function donationAddress() public pure returns(address) {\r\n    return DONATIONADDRESS_;\r\n  }\r\n\r\n  function memberIsActive(uint8 _memberId) internal view returns (bool) {\r\n    return (members_[_memberId].inactiveSince == 0);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"donateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"broadcastMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"passMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"heartbeat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inactivityTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMemberAddress\",\"type\":\"address\"}],\"name\":\"transferMembership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMemberName\",\"type\":\"bytes32\"}],\"name\":\"changeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_memberId\",\"type\":\"uint8\"},{\"name\":\"_memberName\",\"type\":\"bytes32\"},{\"name\":\"_memberAddress\",\"type\":\"address\"}],\"name\":\"newMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_memberAddress\",\"type\":\"address\"}],\"name\":\"getMembershipStatus\",\"outputs\":[{\"name\":\"member\",\"type\":\"bool\"},{\"name\":\"memberId\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_memberId\",\"type\":\"uint8\"}],\"name\":\"getMemberInformation\",\"outputs\":[{\"name\":\"memberName\",\"type\":\"bytes32\"},{\"name\":\"memberKey\",\"type\":\"string\"},{\"name\":\"memberSince\",\"type\":\"uint64\"},{\"name\":\"inactiveSince\",\"type\":\"uint64\"},{\"name\":\"memberAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_memberId\",\"type\":\"uint8\"}],\"name\":\"revokeMembership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMemberKey\",\"type\":\"string\"}],\"name\":\"changeKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_memberId\",\"type\":\"uint8\"}],\"name\":\"proclaimInactive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toMemberId\",\"type\":\"uint8\"},{\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"directMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"memberName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"NewMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newMemberName\",\"type\":\"bytes32\"}],\"name\":\"NewMemberName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newMemberKey\",\"type\":\"string\"}],\"name\":\"NewMemberKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newMemberAddress\",\"type\":\"address\"}],\"name\":\"MembershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"proclaimingMemberId\",\"type\":\"uint8\"}],\"name\":\"MemberProclaimedInactive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"}],\"name\":\"MemberHeartbeated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"revokingMemberId\",\"type\":\"uint8\"}],\"name\":\"MembershipRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"BroadcastMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"toMemberId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"DirectMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Call\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FundsDonated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokensDonated\",\"type\":\"event\"}]","ContractName":"theCyber","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b8dd0934a8336cde74967073024baa3e108f790f55d91fb6710682c25cc66039"}]}