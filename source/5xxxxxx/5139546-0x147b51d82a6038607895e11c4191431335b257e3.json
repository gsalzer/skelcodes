{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/*\r\n    2018 Proxycard\r\n*/\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ninterface ERC20Token {\r\n\t/// @param _owner The address from which the balance will be retrieved\r\n\t/// @return The balance\r\n\tfunction balanceOf(address _owner) public view returns (uint256);\r\n\r\n\t/// @notice send `_value` token to `_to` from `msg.sender`\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return Whether the transfer was successful or not\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n\t/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n\t/// @param _from The address of the sender\r\n\t/// @param _to The address of the recipient\r\n\t/// @param _value The amount of token to be transferred\r\n\t/// @return Whether the transfer was successful or not\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n\t/// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @param _value The amount of tokens to be approved for transfer\r\n\t/// @return Whether the approval was successful or not\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n\t/// @param _owner The address of the account owning tokens\r\n\t/// @param _spender The address of the account able to transfer the tokens\r\n\t/// @return Amount of remaining tokens allowed to spent\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\r\n\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Owned {\r\n    /// @notice The address of the owner is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyOwner { require(msg.sender == owner); _; }\r\n\r\n    address public owner;\r\n\r\n    function Owned() public { owner = msg.sender;}\r\n\r\n    /// @notice Changes the owner of the contract\r\n    /// @param _newOwner The new owner of the contract\r\n    function changeOwner(address _newOwner) onlyOwner public {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMathMod {// Partial SafeMath Library\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) < a);\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) > a);\r\n    }\r\n}\r\n\r\ncontract EPRX is Owned, ERC20Token  {\r\n    using SafeMathMod for uint256;\r\n\r\n    /**\r\n    * @constant name The name of the token\r\n    * @constant symbol  The symbol used to display the currency\r\n    * @constant decimals  The number of decimals used to display a balance\r\n    * @constant totalSupply The total number of tokens times 10^ of the number of decimals\r\n    * @constant MAX_UINT256 Magic number for unlimited allowance\r\n    * @storage balanceOf Holds the balances of all token holders\r\n    * @storage allowed Holds the allowable balance to be transferable by another address.\r\n    */\r\n\r\n    string constant public name = \"eProxy\";\r\n\r\n    string constant public symbol = \"ePRX\";\r\n\r\n    uint8 constant public decimals = 8;\r\n\r\n    uint256 constant public totalSupply = 50000000e8;\r\n\t\r\n\taddress public issuingTokenOwner;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n\t////////////////\r\n\t// Events\r\n\t////////////////\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event TransferFrom(address indexed _spender, address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\t\r\n    event ClaimedTokens(address indexed _token, address indexed _Owner, uint256 _amount);\r\n    event SwappedTokens(address indexed _owner, uint256 _amountOffered, uint256 _amountReceived);\r\n \r\n \t////////////////\r\n\t// Constructor\r\n\t////////////////   \r\n    function EPRX() public { \r\n\t\tissuingTokenOwner = msg.sender;\r\n        balanceOf[issuingTokenOwner] = totalSupply; \r\n        transfersEnabled = true;\r\n    }\r\n\r\n\t///////////////////\r\n\t// ERC20 Methods\r\n\t///////////////////\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        if (msg.sender != owner) {\r\n            require(transfersEnabled);\r\n        }\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) public returns (bool success) {\r\n\r\n        // The owner of this contract can move tokens around at will,\r\n        //  this is important to recognize! Confirm that you trust the\r\n        //  owner of this contract\r\n        if (msg.sender != owner) {\r\n            require(transfersEnabled);\r\n\r\n            // The standard ERC20 transferFrom functionality\r\n            // require(allowed[_from][msg.sender] >= _amount);\r\n\t\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        }\r\n\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n\t\r\n\t\tif(_amount == 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Do not allow transfer to 0x0 or the token contract itself\r\n\t\trequire((_to != 0) && (_to != address(this)));\r\n\r\n\t\t/* SafeMathMOd.sub will throw if there is not enough balance\r\n\t\t   and if the transfer value is 0. */\r\n\t\tbalanceOf[_from] = balanceOf[_from].sub(_amount);\r\n\t\tbalanceOf[_to] = balanceOf[_to].add(_amount);\r\n\r\n\t\t// An event to make the transfer easy to find on the blockchain\r\n\t\tTransfer(_from, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balanceOf[_owner];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) public returns (bool) {\r\n        require(transfersEnabled);\r\n\r\n        /* Ensures address \"0x0\" is not assigned allowance. */\r\n        require(_spender != address(0));\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n\t\t\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender\r\n    ) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\t////////////////\r\n\t// Enable tokens transfers\r\n\t////////////////\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) onlyOwner public {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n\t//////////\r\n\t// Safety Methods\r\n\t//////////\r\n\r\n    /// @notice This method can be used by the owner to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyOwner public {\r\n        // Transfer ether\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n    /// @notice This method can be used by users holding old proxy tokens\r\n    ///  to swap for new tokens at the ratio of 1 : 2.\r\n    function swapProxyTokens() public {\r\n        ERC20Token oldToken = ERC20Token(0x81BE91c7E74Ad0957B4156F782263e7B0B88cF7b);\r\n        uint256 oldTokenBalance = oldToken.balanceOf(msg.sender);\r\n\r\n        require(oldTokenBalance > 0);\r\n\r\n        // User must first approve address(this) as a spender by calling the below\r\n        // approve(<address of this contract>, oldTokenBalance);\r\n\t\t\r\n        // Convert old proxy token to new token for any user authorizing the transfer\r\n        if(oldToken.transferFrom(msg.sender, issuingTokenOwner, oldTokenBalance)) {\r\n            require(oldToken.balanceOf(msg.sender) == 0);\r\n\t\t\t\r\n            // Transfer new token to user\r\n\t\t\tuint256 newTokenAmount = 200 * oldTokenBalance;\r\n            doTransfer(issuingTokenOwner, msg.sender, newTokenAmount);\r\n\r\n            SwappedTokens(msg.sender, oldTokenBalance, newTokenAmount);\r\n        }\r\n        \r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"swapProxyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuingTokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transfersEnabled\",\"type\":\"bool\"}],\"name\":\"enableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_Owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountOffered\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountReceived\",\"type\":\"uint256\"}],\"name\":\"SwappedTokens\",\"type\":\"event\"}]","ContractName":"EPRX","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://aff8ce37eee802fc1b9d975f3b15bac2bb54a9bd4e010c4993792f1080a5921b"}]}