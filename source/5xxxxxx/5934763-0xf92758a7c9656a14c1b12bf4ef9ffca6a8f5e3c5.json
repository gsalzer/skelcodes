{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface itoken {\r\n    function freezeAccount(address _target, bool _freeze) external;\r\n    function freezeAccountPartialy(address _target, uint256 _value) external;\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    // function totalSupply() external view returns (uint256);\r\n    // function transferOwnership(address newOwner) external;\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function initialCongress(address _congress) external;\r\n    function mint(address _to, uint256 _amount) external returns (bool);\r\n    function finishMinting() external returns (bool);\r\n    function pause() external;\r\n    function unpause() external;\r\n}\r\n\r\nlibrary StringUtils {\r\n  /// @dev Does a byte-by-byte lexicographical comparison of two strings.\r\n  /// @return a negative number if `_a` is smaller, zero if they are equal\r\n  /// and a positive numbe if `_b` is smaller.\r\n  function compare(string _a, string _b) public pure returns (int) {\r\n    bytes memory a = bytes(_a);\r\n    bytes memory b = bytes(_b);\r\n    uint minLength = a.length;\r\n    if (b.length < minLength) minLength = b.length;\r\n    //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\r\n    for (uint i = 0; i < minLength; i ++)\r\n      if (a[i] < b[i])\r\n        return -1;\r\n      else if (a[i] > b[i])\r\n        return 1;\r\n    if (a.length < b.length)\r\n      return -1;\r\n    else if (a.length > b.length)\r\n      return 1;\r\n    else\r\n      return 0;\r\n  }\r\n  /// @dev Compares two strings and returns true iff they are equal.\r\n  function equal(string _a, string _b) public pure returns (bool) {\r\n    return compare(_a, _b) == 0;\r\n  }\r\n  /// @dev Finds the index of the first occurrence of _needle in _haystack\r\n  function indexOf(string _haystack, string _needle) public pure returns (int) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n      return -1;\r\n    else if(h.length > (2**128 -1)) // since we have to be able to return -1 (if the char isn't found or input error), this function must return an \"int\" type with a max length of (2^128 - 1)\r\n      return -1;\r\n    else {\r\n      uint subindex = 0;\r\n      for (uint i = 0; i < h.length; i ++) {\r\n        if (h[i] == n[0]) { // found the first char of b\r\n          subindex = 1;\r\n          while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) {// search until the chars don't match or until we reach the end of a or b\r\n                subindex++;\r\n          }\r\n          if(subindex == n.length)\r\n                return int(i);\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\ncontract DelayedClaimable is Claimable {\r\n\r\n  uint256 public end;\r\n  uint256 public start;\r\n\r\n  /**\r\n   * @dev Used to specify the time period during which a pending\r\n   * owner can claim ownership.\r\n   * @param _start The earliest time ownership can be claimed.\r\n   * @param _end The latest time ownership can be claimed.\r\n   */\r\n  function setLimits(uint256 _start, uint256 _end) onlyOwner public {\r\n    require(_start <= _end);\r\n    end = _end;\r\n    start = _start;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer, as long as it is called within\r\n   * the specified start and end time.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    require((block.number <= end) && (block.number >= start));\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n    end = 0;\r\n  }\r\n\r\n}\r\n\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\ncontract MultiOwners is DelayedClaimable, RBAC {\r\n  using SafeMath for uint256;\r\n  using StringUtils for string;\r\n\r\n  mapping (string => uint256) private authorizations;\r\n  mapping (address => string) private ownerOfSides;\r\n//   mapping (string => mapping (string => bool)) private voteResults;\r\n  mapping (string => uint256) private sideExist;\r\n  mapping (string => mapping (string => address[])) private sideVoters;\r\n  address[] public owners;\r\n  string[] private authTypes;\r\n//   string[] private ownerSides;\r\n  uint256 public multiOwnerSides;\r\n  uint256 ownerSidesLimit = 5;\r\n//   uint256 authRate = 75;\r\n  bool initAdd = true;\r\n\r\n  event OwnerAdded(address addr, string side);\r\n  event OwnerRemoved(address addr);\r\n  event InitialFinished();\r\n\r\n  string public constant ROLE_MULTIOWNER = \"multiOwner\";\r\n  string public constant AUTH_ADDOWNER = \"addOwner\";\r\n  string public constant AUTH_REMOVEOWNER = \"removeOwner\";\r\n//   string public constant AUTH_SETAUTHRATE = \"setAuthRate\";\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not multiOwners.\r\n   */\r\n  modifier onlyMultiOwners() {\r\n    checkRole(msg.sender, ROLE_MULTIOWNER);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if not in initializing stage.\r\n   */\r\n  modifier canInitial() {\r\n    require(initAdd);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev the msg.sender will authorize a type of event.\r\n   * @param _authType the event type need to be authorized\r\n   */\r\n  function authorize(string _authType) onlyMultiOwners public {\r\n    string memory side = ownerOfSides[msg.sender];\r\n    address[] storage voters = sideVoters[side][_authType];\r\n\r\n    if (voters.length == 0) {\r\n      // if the first time to authorize this type of event\r\n      authorizations[_authType] = authorizations[_authType].add(1);\r\n    //   voteResults[side][_authType] = true;\r\n    }\r\n\r\n    // add voters of one side\r\n    uint j = 0;\r\n    for (; j < voters.length; j = j.add(1)) {\r\n      if (voters[j] == msg.sender) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (j >= voters.length) {\r\n      voters.push(msg.sender);\r\n    }\r\n\r\n    // add the authType for clearing auth\r\n    uint i = 0;\r\n    for (; i < authTypes.length; i = i.add(1)) {\r\n      if (authTypes[i].equal(_authType)) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (i >= authTypes.length) {\r\n      authTypes.push(_authType);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev the msg.sender will clear the authorization he has given for the event.\r\n   * @param _authType the event type need to be authorized\r\n   */\r\n  function deAuthorize(string _authType) onlyMultiOwners public {\r\n    string memory side = ownerOfSides[msg.sender];\r\n    address[] storage voters = sideVoters[side][_authType];\r\n\r\n    for (uint j = 0; j < voters.length; j = j.add(1)) {\r\n      if (voters[j] == msg.sender) {\r\n        delete voters[j];\r\n        break;\r\n      }\r\n    }\r\n\r\n    // if the sender has authorized this type of event, will remove its vote\r\n    if (j < voters.length) {\r\n      for (uint jj = j; jj < voters.length.sub(1); jj = jj.add(1)) {\r\n        voters[jj] = voters[jj.add(1)];\r\n      }\r\n\r\n      delete voters[voters.length.sub(1)];\r\n      voters.length = voters.length.sub(1);\r\n\r\n      // if there is no votes of one side, the authorization need to be decreased\r\n      if (voters.length == 0) {\r\n        authorizations[_authType] = authorizations[_authType].sub(1);\r\n      //   voteResults[side][_authType] = true;\r\n      }\r\n\r\n      // if there is no authorization on this type of event,\r\n      // this event need to be removed from the list\r\n      if (authorizations[_authType] == 0) {\r\n        for (uint i = 0; i < authTypes.length; i = i.add(1)) {\r\n          if (authTypes[i].equal(_authType)) {\r\n            delete authTypes[i];\r\n            break;\r\n          }\r\n        }\r\n        for (uint ii = i; ii < authTypes.length.sub(1); ii = ii.add(1)) {\r\n          authTypes[ii] = authTypes[ii.add(1)];\r\n        }\r\n\r\n        delete authTypes[authTypes.length.sub(1)];\r\n        authTypes.length = authTypes.length.sub(1);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev judge if the event has already been authorized.\r\n   * @param _authType the event type need to be authorized\r\n   */\r\n  function hasAuth(string _authType) public view returns (bool) {\r\n    require(multiOwnerSides > 1); // at least 2 sides have authorized\r\n\r\n    // uint256 rate = authorizations[_authType].mul(100).div(multiOwnerNumber)\r\n    return (authorizations[_authType] == multiOwnerSides);\r\n  }\r\n\r\n  /**\r\n   * @dev clear all the authorizations that have been given for a type of event.\r\n   * @param _authType the event type need to be authorized\r\n   */\r\n  function clearAuth(string _authType) internal {\r\n    authorizations[_authType] = 0; // clear authorizations\r\n    for (uint i = 0; i < owners.length; i = i.add(1)) {\r\n      string memory side = ownerOfSides[owners[i]];\r\n      address[] storage voters = sideVoters[side][_authType];\r\n      for (uint j = 0; j < voters.length; j = j.add(1)) {\r\n        delete voters[j]; // clear votes of one side\r\n      }\r\n      voters.length = 0;\r\n    }\r\n\r\n    // clear this type of event\r\n    for (uint k = 0; k < authTypes.length; k = k.add(1)) {\r\n      if (authTypes[k].equal(_authType)) {\r\n        delete authTypes[k];\r\n        break;\r\n      }\r\n    }\r\n    for (uint kk = k; kk < authTypes.length.sub(1); kk = kk.add(1)) {\r\n      authTypes[kk] = authTypes[kk.add(1)];\r\n    }\r\n\r\n    delete authTypes[authTypes.length.sub(1)];\r\n    authTypes.length = authTypes.length.sub(1);\r\n  }\r\n\r\n  /**\r\n   * @dev add an address as one of the multiOwners.\r\n   * @param _addr the account address used as a multiOwner\r\n   */\r\n  function addAddress(address _addr, string _side) internal {\r\n    require(multiOwnerSides < ownerSidesLimit);\r\n    require(_addr != address(0));\r\n    require(ownerOfSides[_addr].equal(\"\")); // not allow duplicated adding\r\n\r\n    // uint i = 0;\r\n    // for (; i < owners.length; i = i.add(1)) {\r\n    //   if (owners[i] == _addr) {\r\n    //     break;\r\n    //   }\r\n    // }\r\n\r\n    // if (i >= owners.length) {\r\n    owners.push(_addr); // for not allowing duplicated adding, so each addr should be new\r\n\r\n    addRole(_addr, ROLE_MULTIOWNER);\r\n    ownerOfSides[_addr] = _side;\r\n    // }\r\n\r\n    if (sideExist[_side] == 0) {\r\n      multiOwnerSides = multiOwnerSides.add(1);\r\n    }\r\n\r\n    sideExist[_side] = sideExist[_side].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param _addr address will be one of the multiOwner\r\n   * @param _side the side name of the multiOwner\r\n   * @return true if the address was added to the multiOwners list,\r\n   *         false if the address was already in the multiOwners list\r\n   */\r\n  function initAddressAsMultiOwner(address _addr, string _side)\r\n    onlyOwner\r\n    canInitial\r\n    public\r\n  {\r\n    // require(initAdd);\r\n    addAddress(_addr, _side);\r\n\r\n    // initAdd = false;\r\n    emit OwnerAdded(_addr, _side);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop initial stage.\r\n   */\r\n  function finishInitOwners() onlyOwner canInitial public {\r\n    initAdd = false;\r\n    emit InitialFinished();\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param _addr address\r\n   * @param _side the side name of the multiOwner\r\n   * @return true if the address was added to the multiOwners list,\r\n   *         false if the address was already in the multiOwners list\r\n   */\r\n  function addAddressAsMultiOwner(address _addr, string _side)\r\n    onlyMultiOwners\r\n    public\r\n  {\r\n    require(hasAuth(AUTH_ADDOWNER));\r\n\r\n    addAddress(_addr, _side);\r\n\r\n    clearAuth(AUTH_ADDOWNER);\r\n    emit OwnerAdded(_addr, _side);\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in multiOwner list\r\n   */\r\n  function isMultiOwner(address _addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return hasRole(_addr, ROLE_MULTIOWNER);\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param _addr address\r\n   * @return true if the address was removed from the multiOwner list,\r\n   *         false if the address wasn't in the multiOwner list\r\n   */\r\n  function removeAddressFromOwners(address _addr)\r\n    onlyMultiOwners\r\n    public\r\n  {\r\n    require(hasAuth(AUTH_REMOVEOWNER));\r\n\r\n    removeRole(_addr, ROLE_MULTIOWNER);\r\n\r\n    // first remove the owner\r\n    uint j = 0;\r\n    for (; j < owners.length; j = j.add(1)) {\r\n      if (owners[j] == _addr) {\r\n        delete owners[j];\r\n        break;\r\n      }\r\n    }\r\n    if (j < owners.length) {\r\n      for (uint jj = j; jj < owners.length.sub(1); jj = jj.add(1)) {\r\n        owners[jj] = owners[jj.add(1)];\r\n      }\r\n\r\n      delete owners[owners.length.sub(1)];\r\n      owners.length = owners.length.sub(1);\r\n    }\r\n\r\n    string memory side = ownerOfSides[_addr];\r\n    // if (sideExist[side] > 0) {\r\n    sideExist[side] = sideExist[side].sub(1);\r\n    if (sideExist[side] == 0) {\r\n      require(multiOwnerSides > 2); // not allow only left 1 side\r\n      multiOwnerSides = multiOwnerSides.sub(1); // this side has been removed\r\n    }\r\n\r\n    // for every event type, if this owner has voted the event, then need to remove\r\n    for (uint i = 0; i < authTypes.length; ) {\r\n      address[] storage voters = sideVoters[side][authTypes[i]];\r\n      for (uint m = 0; m < voters.length; m = m.add(1)) {\r\n        if (voters[m] == _addr) {\r\n          delete voters[m];\r\n          break;\r\n        }\r\n      }\r\n      if (m < voters.length) {\r\n        for (uint n = m; n < voters.length.sub(1); n = n.add(1)) {\r\n          voters[n] = voters[n.add(1)];\r\n        }\r\n\r\n        delete voters[voters.length.sub(1)];\r\n        voters.length = voters.length.sub(1);\r\n\r\n        // if this side only have this 1 voter, the authorization of this event need to be decreased\r\n        if (voters.length == 0) {\r\n          authorizations[authTypes[i]] = authorizations[authTypes[i]].sub(1);\r\n        }\r\n\r\n        // if there is no authorization of this event, the event need to be removed\r\n        if (authorizations[authTypes[i]] == 0) {\r\n          delete authTypes[i];\r\n\r\n          for (uint kk = i; kk < authTypes.length.sub(1); kk = kk.add(1)) {\r\n            authTypes[kk] = authTypes[kk.add(1)];\r\n          }\r\n\r\n          delete authTypes[authTypes.length.sub(1)];\r\n          authTypes.length = authTypes.length.sub(1);\r\n        } else {\r\n          i = i.add(1);\r\n        }\r\n      } else {\r\n        i = i.add(1);\r\n      }\r\n    }\r\n//   }\r\n\r\n    delete ownerOfSides[_addr];\r\n\r\n    clearAuth(AUTH_REMOVEOWNER);\r\n    emit OwnerRemoved(_addr);\r\n  }\r\n\r\n}\r\n\r\ncontract MultiOwnerContract is MultiOwners {\r\n    Claimable public ownedContract;\r\n    address public pendingOwnedOwner;\r\n    // address internal origOwner;\r\n\r\n    string public constant AUTH_CHANGEOWNEDOWNER = \"transferOwnerOfOwnedContract\";\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    // modifier onlyPendingOwnedOwner() {\r\n    //     require(msg.sender == pendingOwnedOwner);\r\n    //     _;\r\n    // }\r\n\r\n    /**\r\n     * @dev bind a contract as its owner\r\n     *\r\n     * @param _contract the contract address that will be binded by this Owner Contract\r\n     */\r\n    function bindContract(address _contract) onlyOwner public returns (bool) {\r\n        require(_contract != address(0));\r\n        ownedContract = Claimable(_contract);\r\n        // origOwner = ownedContract.owner();\r\n\r\n        // take ownership of the owned contract\r\n        ownedContract.claimOwnership();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev change the owner of the contract from this contract address to the original one.\r\n     *\r\n     */\r\n    // function transferOwnershipBack() onlyOwner public {\r\n    //     ownedContract.transferOwnership(origOwner);\r\n    //     ownedContract = Claimable(address(0));\r\n    //     origOwner = address(0);\r\n    // }\r\n\r\n    /**\r\n     * @dev change the owner of the contract from this contract address to another one.\r\n     *\r\n     * @param _nextOwner the contract address that will be next Owner of the original Contract\r\n     */\r\n    function changeOwnedOwnershipto(address _nextOwner) onlyMultiOwners public {\r\n        require(ownedContract != address(0));\r\n        require(hasAuth(AUTH_CHANGEOWNEDOWNER));\r\n\r\n        if (ownedContract.owner() != pendingOwnedOwner) {\r\n            ownedContract.transferOwnership(_nextOwner);\r\n            pendingOwnedOwner = _nextOwner;\r\n            // ownedContract = Claimable(address(0));\r\n            // origOwner = address(0);\r\n        } else {\r\n            // the pending owner has already taken the ownership\r\n            ownedContract = Claimable(address(0));\r\n            pendingOwnedOwner = address(0);\r\n        }\r\n\r\n        clearAuth(AUTH_CHANGEOWNEDOWNER);\r\n    }\r\n\r\n    function ownedOwnershipTransferred() onlyOwner public returns (bool) {\r\n        require(ownedContract != address(0));\r\n        if (ownedContract.owner() == pendingOwnedOwner) {\r\n            // the pending owner has already taken the ownership\r\n            ownedContract = Claimable(address(0));\r\n            pendingOwnedOwner = address(0);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract DRCTOwner is MultiOwnerContract {\r\n    string public constant AUTH_INITCONGRESS = \"initCongress\";\r\n    string public constant AUTH_CANMINT = \"canMint\";\r\n    string public constant AUTH_SETMINTAMOUNT = \"setMintAmount\";\r\n    string public constant AUTH_FREEZEACCOUNT = \"freezeAccount\";\r\n\r\n    bool congressInit = false;\r\n    // bool paramsInit = false;\r\n    // iParams public params;\r\n    uint256 onceMintAmount;\r\n\r\n\r\n    // function initParams(address _params) onlyOwner public {\r\n    //     require(!paramsInit);\r\n    //     require(_params != address(0));\r\n\r\n    //     params = _params;\r\n    //     paramsInit = false;\r\n    // }\r\n\r\n    /**\r\n     * @dev Function to set mint token amount\r\n     * @param _value The mint value.\r\n     */\r\n    function setOnceMintAmount(uint256 _value) onlyMultiOwners public {\r\n        require(hasAuth(AUTH_SETMINTAMOUNT));\r\n        require(_value > 0);\r\n        onceMintAmount = _value;\r\n\r\n        clearAuth(AUTH_SETMINTAMOUNT);\r\n    }\r\n\r\n    /**\r\n     * @dev change the owner of the contract from this contract address to another one.\r\n     *\r\n     * @param _congress the contract address that will be next Owner of the original Contract\r\n     */\r\n    function initCongress(address _congress) onlyMultiOwners public {\r\n        require(hasAuth(AUTH_INITCONGRESS));\r\n        require(!congressInit);\r\n\r\n        itoken tk = itoken(address(ownedContract));\r\n        tk.initialCongress(_congress);\r\n\r\n        clearAuth(AUTH_INITCONGRESS);\r\n        congressInit = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address _to) onlyMultiOwners public returns (bool) {\r\n        require(hasAuth(AUTH_CANMINT));\r\n\r\n        itoken tk = itoken(address(ownedContract));\r\n        bool res = tk.mint(_to, onceMintAmount);\r\n\r\n        clearAuth(AUTH_CANMINT);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to stop minting new tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function finishMinting() onlyMultiOwners public returns (bool) {\r\n        require(hasAuth(AUTH_CANMINT));\r\n\r\n        itoken tk = itoken(address(ownedContract));\r\n        bool res = tk.finishMinting();\r\n\r\n        clearAuth(AUTH_CANMINT);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @dev freeze the account's balance under urgent situation\r\n     *\r\n     * by default all the accounts will not be frozen until set freeze value as true.\r\n     *\r\n     * @param _target address the account should be frozen\r\n     * @param _freeze bool if true, the account will be frozen\r\n     */\r\n    function freezeAccountDirect(address _target, bool _freeze) onlyMultiOwners public {\r\n        require(hasAuth(AUTH_FREEZEACCOUNT));\r\n\r\n        require(_target != address(0));\r\n        itoken tk = itoken(address(ownedContract));\r\n        tk.freezeAccount(_target, _freeze);\r\n\r\n        clearAuth(AUTH_FREEZEACCOUNT);\r\n    }\r\n\r\n    /**\r\n     * @dev freeze the account's balance\r\n     *\r\n     * by default all the accounts will not be frozen until set freeze value as true.\r\n     *\r\n     * @param _target address the account should be frozen\r\n     * @param _freeze bool if true, the account will be frozen\r\n     */\r\n    function freezeAccount(address _target, bool _freeze) onlyOwner public {\r\n        require(_target != address(0));\r\n        itoken tk = itoken(address(ownedContract));\r\n        if (_freeze) {\r\n            require(tk.allowance(_target, this) == tk.balanceOf(_target));\r\n        }\r\n\r\n        tk.freezeAccount(_target, _freeze);\r\n    }\r\n\r\n    /**\r\n     * @dev freeze the account's balance\r\n     *\r\n     * @param _target address the account should be frozen\r\n     * @param _value uint256 the amount of tokens that will be frozen\r\n     */\r\n    function freezeAccountPartialy(address _target, uint256 _value) onlyOwner public {\r\n        require(_target != address(0));\r\n        itoken tk = itoken(address(ownedContract));\r\n        require(tk.allowance(_target, this) == _value);\r\n\r\n        tk.freezeAccountPartialy(_target, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner public {\r\n        itoken tk = itoken(address(ownedContract));\r\n        tk.pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner public {\r\n        itoken tk = itoken(address(ownedContract));\r\n        tk.unpause();\r\n    }\r\n\r\n}\r\n\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_side\",\"type\":\"string\"}],\"name\":\"initAddressAsMultiOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authType\",\"type\":\"string\"}],\"name\":\"deAuthorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTH_REMOVEOWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_authType\",\"type\":\"string\"}],\"name\":\"hasAuth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiOwnerSides\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwnedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"freezeAccountPartialy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authType\",\"type\":\"string\"}],\"name\":\"authorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"changeOwnedOwnershipto\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTH_CHANGEOWNEDOWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTH_FREEZEACCOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_side\",\"type\":\"string\"}],\"name\":\"addAddressAsMultiOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"bindContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTH_INITCONGRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTH_ADDOWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_MULTIOWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setOnceMintAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isMultiOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTH_SETMINTAMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishInitOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownedContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTH_CANMINT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccountDirect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_congress\",\"type\":\"address\"}],\"name\":\"initCongress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownedOwnershipTransferred\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"side\",\"type\":\"string\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitialFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DRCTOwner","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"StringUtils:2Ca3E5Fc099bb49E46Ca6EC78CA647DAd915c18C","SwarmSource":"bzzr://fe5a3911f9b89c381eb38c0afdcdc7fc13a7624bb6a29d5ce747850c76d6f2f5"}]}