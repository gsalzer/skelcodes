{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/** ************************************************************************ **/\r\n/** ************************ Abstract CK Core ****************************** **/\r\n/** ************************************************************************ **/\r\n\r\n/**\r\n * @dev This can be exchanged for any ERC721 contract if we don't want to rely on CK.\r\n**/\r\ncontract KittyCore {\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/** ************************************************************************ **/\r\n/** *************************** Cuddle Data ******************************** **/ \r\n/** ************************************************************************ **/\r\n    \r\n/**\r\n * @dev Holds the data for all kitty actions and all kitty effects.\r\n * @notice TO-DO: Haven't fully converted this to a format where effects are actions!\r\n**/\r\ncontract CuddleData is Ownable {\r\n    // Action/Effect Id => struct for actions and for effects.\r\n    mapping (uint256 => Action) public actions;\r\n    // Actions specific to personality types.\r\n    mapping (uint256 => uint256[]) typeActions;\r\n    // Actions that any personality can have.\r\n    uint256[] anyActions;\r\n\r\n    // This struct used for all moves a kitty may have.\r\n    struct Action {\r\n        uint256 energy;\r\n        uint8[6] basePets; // Each owner is an index that has a base amount of pets.\r\n        uint8[6] petsAddition; // Special effects may give extra pets.\r\n        uint16[6] critChance; // Special effects may increase (or decrease?) crit chance.\r\n        uint8[6] missChance; // Special effects may decrease (or increase?) miss chance.\r\n        uint256 turnsAffected; // If an effect occurrs\r\n    }\r\n    \r\n/** ************************** EXTERNAL VIEW ******************************* **/\r\n    \r\n    /**\r\n     * @dev Used by CuddleScience to get relevant info for a sequence of moves.\r\n     * @param _actions The 8 length array of the move sequence.\r\n     * @param _cuddleOwner The owner Id that we need info for.\r\n    **/\r\n    function returnActions(uint256[8] _actions, uint256 _cuddleOwner)\r\n      external\r\n      view\r\n    returns (uint256[8] energy, uint256[8] basePets, uint256[8] petsAddition,\r\n             uint256[8] critChance, uint256[8] missChance, uint256[8] turnsAffected)\r\n    {\r\n        for (uint256 i = 0; i < 8; i++) {\r\n            if (_actions[i] == 0) break;\r\n            \r\n            Action memory action = actions[_actions[i]];\r\n            energy[i] = action.energy;\r\n            basePets[i] = action.basePets[_cuddleOwner];\r\n            petsAddition[i] = action.petsAddition[_cuddleOwner];\r\n            critChance[i] = action.critChance[_cuddleOwner];\r\n            missChance[i] = action.missChance[_cuddleOwner];\r\n            turnsAffected[i] = action.turnsAffected;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @NOTICE This is hardcoded for announcement until launch.\r\n     * No point in adding actions now that are just going to be changed.\r\n    **/\r\n    \r\n    /**\r\n     * @dev Returns the amount of kitty actions available.\r\n     * @param _personality If we want personality actions, this is the personality index\r\n    **/\r\n    function getActionCount(uint256 _personality)\r\n      external\r\n      view\r\n    returns (uint256 totalActions)\r\n    {\r\n        //if (_personality > 0) totalActions = typeActions[_personality].length;\r\n        //else totalActions = anyActions.length;\r\n        if (_personality == 0) return 10;\r\n        else return 5;\r\n    }\r\n    \r\n/** ******************************* ONLY OWNER ***************************** **/\r\n    \r\n    /**\r\n     * @dev Used by the owner to create/edit a new action that kitties may learn.\r\n     * @param _actionId The given ID of this action.\r\n     * @param _newEnergy The amount of energy the action will cost.\r\n     * @param _newPets The amount of base pets each owner will give to this action.\r\n     * @param _petAdditions The amount of additional pets each owner will give.\r\n     * @param _critChance The crit chance this move has against each owner.\r\n     * @param _missChance The miss chance this move has against each owner.\r\n     * @param _turnsAffected The amount of turns an effect, if any, will be applied.\r\n     * @param _personality The type/personality this move is specific to (0 for any).\r\n    **/\r\n    function addAction(uint256 _actionId, uint256 _newEnergy, uint8[6] _newPets, uint8[6] _petAdditions,\r\n            uint16[6] _critChance, uint8[6] _missChance, uint256 _turnsAffected, uint256 _personality)\r\n      public // This is called in prepActions down below.\r\n      onlyOwner\r\n    {\r\n        Action memory newAction = Action(_newEnergy, _newPets, _petAdditions, _critChance, _missChance, _turnsAffected);\r\n        actions[_actionId] = newAction;\r\n        \r\n        if (_personality > 0) typeActions[_personality].push(_actionId);\r\n        else anyActions.push(_actionId);\r\n    }\r\n    \r\n}\r\n\r\n/** ************************************************************************* **/\r\n/** **************************** Kitty Data ********************************* **/\r\n/** ************************************************************************* **/\r\n\r\n/**\r\n * @dev Kitty data holds the core of all data for kitties. This is the most permanent\r\n * @dev of all contracts in the CryptoCuddles system. As simple as possible because of that.\r\n**/\r\ncontract KittyData is Ownable {\r\n    address public gymContract; // Address of the gym contract.\r\n    address public specialContract; // Address of the contract used to train special kitties.\r\n    address public arenaContract; // Address of the arena contract.\r\n    \r\n    // Mapping of all kitties by CK kitty Id\r\n    mapping (uint256 => Kitty) public kitties;\r\n    \r\n    // All trained kitties\r\n    struct Kitty {\r\n        uint8[2] kittyType; // Personality/type of the kitty.\r\n        uint32[12] actionsArray; // Array of all moves.\r\n        uint16 level; // Current level of the kitty.\r\n        uint16 totalBattles; // Total battles that the kitty has \"fought\".\r\n    }\r\n    \r\n/** ******************************* DEFAULT ******************************** **/\r\n    \r\n    /**\r\n     * @param _arenaContract The address of the Arena so that it may level up kitties.\r\n     * @param _gymContract The address of the KittyGym so that it may train kitties.\r\n     * @param _specialContract The address of the SpecialGym so it may train specials.\r\n    **/\r\n    function KittyData(address _arenaContract, address _gymContract, address _specialContract)\r\n      public\r\n    {\r\n        arenaContract = _arenaContract;\r\n        gymContract = _gymContract;\r\n        specialContract = _specialContract;\r\n    }\r\n    \r\n/** ***************************** ONLY VERIFIED **************************** **/\r\n    \r\n    /**\r\n     * @dev Used by KittyGym to initially add a kitty.\r\n     * @param _kittyId Unique CK Id of kitty to be added.\r\n     * @param _kittyType The personality type of this kitty.\r\n     * @param _actions Array of all actions to be added to kitty.\r\n    **/\r\n    function addKitty(uint256 _kittyId, uint256 _kittyType, uint256[5] _actions)\r\n      external\r\n      onlyVerified\r\n    returns (bool success)\r\n    {\r\n        delete kitties[_kittyId]; // Wipe this kitty if it's already trained.\r\n        \r\n        kitties[_kittyId].kittyType[0] = uint8(_kittyType);\r\n        for (uint256 i = 0; i < 5; i++) { \r\n            addAction(_kittyId, _actions[i], i);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Give this learned kitty with a wealthy owner a degree and new graduate-specific actions.\r\n     * @param _kittyId The unique CK Id of the kitty to graduate.\r\n     * @param _specialId The Id of the special type that is being trained.\r\n     * @param _actions The graduate-specific actions that are being given to this kitty.\r\n     * @param _slots The array indices where the new actions will go.\r\n    **/\r\n    function trainSpecial(uint256 _kittyId, uint256 _specialId, uint256[2] _actions, uint256[2] _slots)\r\n      external\r\n      onlyVerified\r\n    returns (bool success)\r\n    {\r\n        kitties[_kittyId].kittyType[1] = uint8(_specialId);\r\n        addAction(_kittyId, _actions[0], _slots[0]);\r\n        addAction(_kittyId, _actions[1], _slots[1]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Used internally and externally to add an action or replace an action.\r\n     * @param _kittyId The unique CK Id of the learning kitty.\r\n     * @param _newAction The new action to learn.\r\n     * @param _moveSlot The kitty's actionsArray index where the move shall go.\r\n    **/\r\n    function addAction(uint256 _kittyId, uint256 _newAction, uint256 _moveSlot)\r\n      public\r\n      onlyVerified\r\n    returns (bool success)\r\n    {\r\n        kitties[_kittyId].actionsArray[_moveSlot] = uint32(_newAction);\r\n        return true;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Arena contract uses this on either a win or lose.\r\n     * @param _kittyId The unique CK Id for the kitty being edited.\r\n     * @param _won Whether or not the kitty won the battle.\r\n    **/\r\n    function incrementBattles(uint256 _kittyId, bool _won)\r\n      external\r\n      onlyVerified\r\n    returns (bool success)\r\n    {\r\n        if (_won) kitties[_kittyId].level++;\r\n        kitties[_kittyId].totalBattles++;\r\n        return true;\r\n    }\r\n    \r\n/** ****************************** CONSTANT ******************************** **/\r\n    \r\n    /**\r\n     * @dev Used on KittyGym when rerolling a move to ensure validity.\r\n     * @param _kittyId Unique CK Id of the kitty.\r\n     * @param _moveSlot The index of the kitty's actionsArray to check.\r\n     * @return The move that occupies the _moveSlot.\r\n    **/\r\n    function fetchSlot(uint256 _kittyId, uint256 _moveSlot)\r\n      external\r\n      view\r\n    returns (uint32)\r\n    {\r\n        return kitties[_kittyId].actionsArray[_moveSlot];\r\n    }\r\n    \r\n    /**\r\n     * @dev Used by frontend to get data for a kitty.\r\n     * @param _kittyId The unique CK Id we're querying for.\r\n    **/\r\n    function returnKitty(uint256 _kittyId)\r\n      external\r\n      view\r\n    returns (uint8[2] kittyType, uint32[12] actionsArray, uint16 level, uint16 totalBattles)\r\n    {\r\n        Kitty memory kitty = kitties[_kittyId];\r\n        kittyType = kitty.kittyType;\r\n        actionsArray = kitty.actionsArray;\r\n        level = kitty.level;\r\n        totalBattles = kitty.totalBattles;\r\n    }\r\n    \r\n/** ***************************** ONLY OWNER ******************************* **/\r\n    \r\n    /**\r\n     * @dev Owner of this contract may change the addresses of associated contracts.\r\n     * @param _gymContract The address of the new KittyGym contract.\r\n     * @param _arenaContract The address of the new Arena contract.\r\n     * @param _specialContract The address of the new SpecialGym contract.\r\n    **/\r\n    function changeContracts(address _gymContract, address _specialContract, address _arenaContract)\r\n      external\r\n      onlyOwner\r\n    {\r\n        if (_gymContract != 0) gymContract = _gymContract;\r\n        if (_specialContract != 0) specialContract = _specialContract;\r\n        if (_arenaContract != 0) arenaContract = _arenaContract;\r\n    }\r\n    \r\n/** ***************************** MODIFIERS ******************************** **/\r\n    \r\n    /**\r\n     * @dev Only the KittyGym and Arena contracts may make changes to KittyData!\r\n    **/\r\n    modifier onlyVerified()\r\n    {\r\n        require(msg.sender == gymContract || msg.sender == specialContract || \r\n                msg.sender == arenaContract);\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\n/** ************************************************************************ **/\r\n/** **************************** Kitty Gym ********************************* **/\r\n/** ************************************************************************ **/\r\n\r\n/**\r\n * @dev Allows players to train kitties, reroll the training, or reroll specific moves.\r\n * @dev Also holds all specific kitty data such as their available actions (but not action data!)\r\n**/\r\ncontract KittyGym is Ownable {\r\n    KittyCore public core;\r\n    CuddleData public cuddleData;\r\n    CuddleCoin public token;\r\n    KittyData public kittyData;\r\n    address public specialGym;\r\n\r\n    uint256 public totalKitties = 1; // Total amount of trained kitties.\r\n    uint256 public personalityTypes; // Number of personality types for randomization.\r\n\r\n    uint256 public trainFee; // In wei\r\n    uint256 public learnFee; // In CuddleCoin wei\r\n    uint256 public rerollFee; // In CuddleCoin wei\r\n    \r\n    // Unique CK Id => action Id => true if the kitty knows the action.\r\n    mapping (uint256 => mapping (uint256 => bool)) public kittyActions;\r\n\r\n    event KittyTrained(uint256 indexed kittyId, uint256 indexed kittyNumber,\r\n            uint256 indexed personality, uint256[5] learnedActions);\r\n    event MoveLearned(uint256 indexed kittyId, uint256 indexed actionId);\r\n    event MoveRerolled(uint256 indexed kittyId, uint256 indexed oldActionId,\r\n                        uint256 indexed newActionId);\r\n\r\n    /**\r\n     * @dev Initialize contract.\r\n    **/\r\n    function KittyGym(address _kittyCore, address _cuddleData, address _cuddleCoin, \r\n                    address _specialGym, address _kittyData)\r\n      public \r\n    {\r\n        core = KittyCore(_kittyCore);\r\n        cuddleData = CuddleData(_cuddleData);\r\n        token = CuddleCoin(_cuddleCoin);\r\n        kittyData = KittyData(_kittyData);\r\n        specialGym = _specialGym;\r\n        \r\n        trainFee = 0;\r\n        learnFee = 1;\r\n        rerollFee = 1;\r\n        personalityTypes = 5;\r\n    }\r\n\r\n/** ***************************** EXTERNAL ********************************* **/\r\n\r\n    /**\r\n     * @dev The owner of a kitty may train or retrain (reset everything) a kitty here.\r\n     * @param _kittyId ID of Kitty to train or retrain.\r\n    **/\r\n    function trainKitty(uint256 _kittyId)\r\n      external\r\n      payable\r\n      isNotContract\r\n    {\r\n        // Make sure trainer owns this kitty\r\n        require(core.ownerOf(_kittyId) == msg.sender);\r\n        require(msg.value == trainFee);\r\n        \r\n        // Make sure we delete all actions if the kitty has already been trained.\r\n        if (kittyData.fetchSlot(_kittyId, 0) > 0) {\r\n            var (,actionsArray,,) = kittyData.returnKitty(_kittyId);\r\n            deleteActions(_kittyId, actionsArray); // A special kitty will be thrown here.\r\n        }\r\n\r\n        uint256 newType = random(totalKitties * 11, 1, personalityTypes); // upper is inclusive here\r\n        kittyActions[_kittyId][(newType * 1000) + 1] = true;\r\n        \r\n        uint256[2] memory newTypeActions = randomizeActions(newType, _kittyId);\r\n        uint256[2] memory newAnyActions = randomizeActions(0, _kittyId);\r\n\r\n        uint256[5] memory newActions;\r\n        newActions[0] = (newType * 1000) + 1;\r\n        newActions[1] = newTypeActions[0];\r\n        newActions[2] = newTypeActions[1];\r\n        newActions[3] = newAnyActions[0];\r\n        newActions[4] = newAnyActions[1];\r\n        \r\n        kittyActions[_kittyId][newActions[1]] = true;\r\n        kittyActions[_kittyId][newActions[2]] = true;\r\n        kittyActions[_kittyId][newActions[3]] = true;\r\n        kittyActions[_kittyId][newActions[4]] = true;\r\n \r\n        assert(kittyData.addKitty(_kittyId, newType, newActions));\r\n        KittyTrained(_kittyId, totalKitties, newType, newActions);\r\n        totalKitties++;\r\n        \r\n        owner.transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev May teach your kitty a new random move for a fee.\r\n     * @param _kittyId The ID of the kitty who shall get a move added.\r\n     * @param _moveSlot The array index that the move shall be placed in.\r\n    **/\r\n    function learnMove(uint256 _kittyId, uint256 _moveSlot)\r\n      external\r\n      isNotContract\r\n    {\r\n        require(msg.sender == core.ownerOf(_kittyId));\r\n        // Burn the learning fee from the trainer's balance\r\n        assert(token.burn(msg.sender, learnFee));\r\n        require(kittyData.fetchSlot(_kittyId, 0) > 0); // Cannot learn without training.\r\n        require(kittyData.fetchSlot(_kittyId, _moveSlot) == 0); // Must be put in blank spot.\r\n        \r\n        uint256 upper = cuddleData.getActionCount(0);\r\n        uint256 actionId = unduplicate(_kittyId * 11, 999, upper, 0); // * 11 and 99...are arbitrary\r\n        \r\n        assert(!kittyActions[_kittyId][actionId]); // Throw if a new move still wasn't found.\r\n        kittyActions[_kittyId][actionId] = true;\r\n        \r\n        assert(kittyData.addAction(_kittyId, actionId, _moveSlot));\r\n        MoveLearned(_kittyId, actionId);\r\n    }\r\n\r\n    /**\r\n     * @dev May reroll one kitty move. Cheaper than buying a new one.\r\n     * @param _kittyId The kitty who needs to retrain a move slot.\r\n     * @param _moveSlot The index of the kitty's actionsArray to replace.\r\n     * @param _typeId The personality Id of the kity.\r\n    **/\r\n    function reRollMove(uint256 _kittyId, uint256 _moveSlot, uint256 _typeId)\r\n      external\r\n      isNotContract\r\n    {\r\n        require(msg.sender == core.ownerOf(_kittyId));\r\n        \r\n        // Make sure the old action exists and is of the correct type (purposeful underflow).\r\n        uint256 oldAction = kittyData.fetchSlot(_kittyId, _moveSlot);\r\n        require(oldAction > 0);\r\n        require(oldAction - (_typeId * 1000) < 1000);\r\n        \r\n        // Burn the rerolling fee from the trainer's balance\r\n        assert(token.burn(msg.sender, rerollFee));\r\n\r\n        uint256 upper = cuddleData.getActionCount(_typeId);\r\n        uint256 actionId = unduplicate(_kittyId, oldAction, upper, _typeId);\r\n\r\n        assert(!kittyActions[_kittyId][actionId]); \r\n        kittyActions[_kittyId][oldAction] = false;\r\n        kittyActions[_kittyId][actionId] = true;\r\n        \r\n        assert(kittyData.addAction(_kittyId, actionId, _moveSlot));\r\n        MoveRerolled(_kittyId, oldAction, actionId);\r\n    }\r\n    \r\n/** ******************************* INTERNAL ******************************** **/\r\n    \r\n    /**\r\n     * @dev Return two actions for training or hybridizing a kitty using the given type.\r\n     * @param _actionType The type of actions that shall be learned. 0 for \"any\" actions.\r\n     * @param _kittyId The unique CK Id of the kitty.\r\n    **/ \r\n    function randomizeActions(uint256 _actionType, uint256 _kittyId)\r\n      internal\r\n      view\r\n    returns (uint256[2])\r\n    {\r\n        uint256 upper = cuddleData.getActionCount(_actionType);\r\n        uint256 action1 = unduplicate(_kittyId, 999, upper, _actionType);\r\n        uint256 action2 = unduplicate(_kittyId, action1, upper, _actionType);\r\n        return [action1,action2];\r\n    }\r\n    \r\n    /**\r\n     * @dev Used when a new action is chosen but the kitty already knows it.\r\n     * @dev If no unique actions can be found, unduplicate throws.\r\n     * @param _kittyId The unique CK Id of the kitty.\r\n     * @param _action1 The action that is already known.\r\n     * @param _upper The amount of actions that can be tried.\r\n     * @param _type The type of action that these actions are.\r\n     * @return The new action that is not a duplicate.\r\n    **/\r\n    function unduplicate(uint256 _kittyId, uint256 _action1, uint256 _upper, uint256 _type)\r\n      internal\r\n      view\r\n    returns (uint256 newAction)\r\n    {\r\n        uint256 typeBase = _type * 1000; // The base thousand for this move's type.\r\n\r\n        for (uint256 i = 1; i < 11; i++) {\r\n            newAction = random(i * 666, 1, _upper) + typeBase;\r\n            if (newAction != _action1 && !kittyActions[_kittyId][newAction]) break;\r\n        }\r\n        \r\n        // If the kitty still knows the move, increment till we find one it doesn't.\r\n        if (newAction == _action1 || kittyActions[_kittyId][newAction]) {\r\n            for (uint256 j = 1; j < _upper + 1; j++) {\r\n                uint256 incAction = ((newAction + j) % _upper) + 1;\r\n\r\n                incAction += typeBase;\r\n                if (incAction != _action1 && !kittyActions[_kittyId][incAction]) {\r\n                    newAction = incAction;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Create a random number.\r\n     * @param _rnd Seed to help randomize.\r\n     * @param _lower The lower bound of the random number (inclusive).\r\n     * @param _upper The upper bound of the random number (exclusive).\r\n    **/ \r\n    function random(uint256 _rnd, uint256 _lower, uint256 _upper) \r\n      internal\r\n      view\r\n    returns (uint256) \r\n    {\r\n        uint256 _seed = uint256(keccak256(keccak256(_rnd, _seed), now));\r\n        return (_seed % _upper) + _lower;\r\n    }\r\n    \r\n    /**\r\n     * @dev Used by trainKitty to delete mapping values if the kitty has already been trained.\r\n     * @param _kittyId The unique CK Id of the kitty.\r\n     * @param _actions The list of all actions the kitty currently has.\r\n    **/\r\n    function deleteActions(uint256 _kittyId, uint32[12] _actions)\r\n      internal\r\n    {\r\n        for (uint256 i = 0; i < _actions.length; i++) {\r\n            // Make sure a special kitty isn't retrained. Purposeful underflow.\r\n            require(uint256(_actions[i]) - 50000 > 10000000);\r\n            \r\n            delete kittyActions[_kittyId][uint256(_actions[i])];\r\n        }\r\n    }\r\n    \r\n/** ************************* EXTERNAL CONSTANT **************************** **/\r\n    \r\n    /**\r\n     * @dev Confirms whether a kitty has chosen actions.\r\n     * @param _kittyId The id of the kitty whose actions need to be checked.\r\n     * @param _kittyActions The actions to be checked.\r\n    **/\r\n    function confirmKittyActions(uint256 _kittyId, uint256[8] _kittyActions) \r\n      external \r\n      view\r\n    returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < 8; i++) {\r\n            if (!kittyActions[_kittyId][_kittyActions[i]]) return false; \r\n        }\r\n        return true;\r\n    }\r\n    \r\n/** ************************* ONLY VERIFIED/OWNER ************************** **/\r\n    \r\n    /**\r\n     * @dev Used by the SpecialGym contract when a kitty learns new special moves.\r\n     * @param _kittyId The Id of the now special kitty!\r\n     * @param _moves A 2-length array with the new special moves.\r\n    **/\r\n    function addMoves(uint256 _kittyId, uint256[2] _moves)\r\n      external\r\n      onlyVerified\r\n    returns (bool success)\r\n    {\r\n        kittyActions[_kittyId][_moves[0]] = true;\r\n        kittyActions[_kittyId][_moves[1]] = true;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Used by owner to change all fees on KittyGym.\r\n     * @param _trainFee The new cost (IN ETHER WEI) of training a new cat.\r\n     * @param _learnFee The new cost (IN TOKEN WEI) of learning a new move.\r\n     * @param _rerollFee The new cost (IN TOKEN WEI) of rerolling a move.\r\n    **/\r\n    function changeFees(uint256 _trainFee, uint256 _learnFee, uint256 _rerollFee)\r\n      external\r\n      onlyOwner\r\n    {\r\n        trainFee = _trainFee;\r\n        learnFee = _learnFee;\r\n        rerollFee = _rerollFee;\r\n    }\r\n\r\n    /**\r\n     * @dev Used by owner to change the amount of actions there are.\r\n     * @param _newTypeCount The new number of personalities there are.\r\n    **/\r\n    function changeVariables(uint256 _newTypeCount)\r\n      external\r\n      onlyOwner\r\n    {\r\n        if (_newTypeCount != 0) personalityTypes = _newTypeCount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Owner may use to change any/every connected contract address.\r\n     * @dev Owner may leave params as null and nothing will happen to that variable.\r\n     * @param _newData The address of the new cuddle data contract if desired.\r\n     * @param _newCore The address of the new CK core contract if desired.\r\n     * @param _newToken The address of the new cuddle token if desired.\r\n     * @param _newKittyData The address of the new KittyData contract.\r\n     * @param _newSpecialGym The address of the new SpecialGym contract.\r\n    **/\r\n    function changeContracts(address _newData, address _newCore, address _newToken, address _newKittyData,\r\n                            address _newSpecialGym)\r\n      external\r\n      onlyOwner\r\n    {\r\n        if (_newData != 0) cuddleData = CuddleData(_newData);\r\n        if (_newCore != 0) core = KittyCore(_newCore);\r\n        if (_newToken != 0) token = CuddleCoin(_newToken);\r\n        if (_newKittyData != 0) kittyData = KittyData(_newKittyData);\r\n        if (_newSpecialGym != 0) specialGym = _newSpecialGym;\r\n    }\r\n    \r\n/** ***************************** MODIFIERS ******************************** **/\r\n    \r\n    /**\r\n    * @dev Ensure only the arena contract can call pet count.\r\n    **/\r\n    modifier onlyVerified()\r\n    {\r\n        require(msg.sender == specialGym);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Ensure the sender is not a contract. This removes most of \r\n     * @dev the possibility of abuse of our timestamp/blockhash randomizers.\r\n    **/ \r\n    modifier isNotContract() {\r\n        uint size;\r\n        address addr = msg.sender;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size == 0);\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\n/** ************************************************************************ **/\r\n/** **************************** Special Gym ******************************* **/\r\n/** ************************************************************************ **/\r\n\r\n/**\r\n * @dev Special Gym is used to train kitties with special\r\n * @dev personality types such as graduates.\r\n**/\r\ncontract SpecialGym is Ownable {\r\n    KittyCore public core;\r\n    KittyData public kittyData;\r\n    CuddleData public cuddleData;\r\n    KittyGym public kittyGym;\r\n    \r\n    // Unique CK Id => true if they already have a special.\r\n    mapping (uint256 => bool) public specialKitties;\r\n    \r\n    // Special personality Id => number left that may train. Graduates are Id 50.\r\n    mapping (uint256 => SpecialPersonality) public specialInfo;\r\n    \r\n    struct SpecialPersonality {\r\n        uint16 population; // Total amount of this special ever available.\r\n        uint16 amountLeft; // The number of special personalities available to buy.\r\n        uint256 price; // Price of this special.\r\n    }\r\n    \r\n    event SpecialTrained(uint256 indexed kittyId, uint256 indexed specialId, \r\n        uint256 indexed specialRank, uint256[2] specialMoves);\r\n    \r\n    function SpecialGym(address _kittyCore, address _kittyData, address _cuddleData, address _kittyGym)\r\n      public\r\n    {\r\n        core = KittyCore(_kittyCore);\r\n        kittyData = KittyData(_kittyData);\r\n        cuddleData = CuddleData(_cuddleData);\r\n        kittyGym = KittyGym(_kittyGym);\r\n    }\r\n    \r\n    /**\r\n     * @dev Used to buy an exclusive special personality such as graduate.\r\n     * @param _kittyId The unique CK Id of the kitty to train.\r\n     * @param _specialId The Id of the special personality being trained.\r\n     * @param _slots The two move slots where the kitty wants their new moves.\r\n    **/\r\n    function trainSpecial(uint256 _kittyId, uint256 _specialId, uint256[2] _slots)\r\n      external\r\n      payable\r\n      isNotContract\r\n    {\r\n        SpecialPersonality storage special = specialInfo[_specialId];\r\n        \r\n        require(msg.sender == core.ownerOf(_kittyId));\r\n        require(kittyData.fetchSlot(_kittyId, 0) > 0); // Require kitty has been trained.\r\n        require(!specialKitties[_kittyId]);\r\n        require(msg.value == special.price);\r\n        require(special.amountLeft > 0);\r\n\r\n        // Get two new random special moves.\r\n        uint256[2] memory randomMoves = randomizeActions(_specialId);\r\n        \r\n        assert(kittyData.trainSpecial(_kittyId, _specialId, randomMoves, _slots));\r\n        assert(kittyGym.addMoves(_kittyId, randomMoves));\r\n        \r\n        uint256 specialRank = special.population - special.amountLeft + 1;\r\n        SpecialTrained(_kittyId, _specialId, specialRank, randomMoves);\r\n    \r\n        special.amountLeft--;\r\n        specialKitties[_kittyId] = true;\r\n        owner.transfer(msg.value);\r\n    }\r\n    \r\n/** ******************************* INTERNAL ******************************* **/\r\n    \r\n    /**\r\n     * @dev Return two actions for training or hybridizing a kitty using the given type.\r\n     * @param _specialType The type of actions that shall be learned. 0 for \"any\" actions.\r\n     * @return Two new special moves.\r\n    **/ \r\n    function randomizeActions(uint256 _specialType)\r\n      internal\r\n      view\r\n    returns (uint256[2])\r\n    {\r\n        uint256 upper = cuddleData.getActionCount(_specialType);\r\n        \r\n        uint256 action1 = random(_specialType, 1, upper);\r\n        uint256 action2 = random(action1 + 1, 1, upper);\r\n        if (action1 == action2) {\r\n            action2 = unduplicate(action1, upper);\r\n        }\r\n\r\n        uint256 typeBase = 1000 * _specialType;\r\n        return [action1 + typeBase, action2 + typeBase];\r\n    }\r\n    \r\n    /**\r\n     * @dev Used to make sure the kitty doesn't learn two of the same move.\r\n     * @dev If no unique actions can be found, unduplicate throws.\r\n     * @param _action1 The action that is already known.\r\n     * @param _upper The amount of actions that can be tried.\r\n     * @return The new action that is not a duplicate.\r\n    **/\r\n    function unduplicate(uint256 _action1, uint256 _upper)\r\n      internal\r\n      view\r\n    returns (uint256)\r\n    {\r\n        uint256 action2;\r\n        for (uint256 i = 1; i < 10; i++) { // Start at 1 to make sure _rnd is never 1.\r\n            action2 = random(action2 + i, 1, _upper);\r\n            if (action2 != _action1) break;\r\n        }\r\n        \r\n        // If the kitty still knows the move, simply increment.\r\n        if (action2 == _action1) {\r\n            action2 = (_action1 % _upper) + 1;\r\n        }\r\n            \r\n        return action2;\r\n    }\r\n    \r\n    /**\r\n     * @dev Create a random number.\r\n     * @param _rnd Seed to help randomize.\r\n     * @param _lower The lower bound of the random number (inclusive).\r\n     * @param _upper The upper bound of the random number (exclusive).\r\n     * @return Returns a fairly random number.\r\n    **/ \r\n    function random(uint256 _rnd, uint256 _lower, uint256 _upper) \r\n      internal\r\n      view\r\n    returns (uint256) \r\n    {\r\n        uint256 _seed = uint256(keccak256(keccak256(_rnd, _seed), now));\r\n        return (_seed % _upper) + _lower;\r\n    }\r\n    \r\n/** ******************************* CONSTANT ****************************** **/\r\n    \r\n    /**\r\n     * @dev Used by frontend to get information on a special.\r\n     * @param _specialId The unique identifier of the special personality.\r\n    **/\r\n    function specialsInfo(uint256 _specialId) \r\n      external \r\n      view \r\n    returns(uint256, uint256) \r\n    { \r\n        require(_specialId > 0); \r\n        return (specialInfo[_specialId].amountLeft, specialInfo[_specialId].price); \r\n    }\r\n    \r\n/** ****************************** ONLY OWNER ****************************** **/\r\n    \r\n    /**\r\n     * @dev Used by owner to create and populate a new special personality.\r\n     * @param _specialId The special's personality Id--starts at 50\r\n     * @param _amountAvailable The maximum amount of this special that will ever be available.\r\n     * @param _price The price that the special will be sold for.\r\n    **/\r\n    function addSpecial(uint256 _specialId, uint256 _amountAvailable, uint256 _price)\r\n      external\r\n      onlyOwner\r\n    {\r\n        SpecialPersonality storage special = specialInfo[_specialId];\r\n        require(special.price == 0);\r\n        \r\n        special.population = uint16(_amountAvailable);\r\n        special.amountLeft = uint16(_amountAvailable);\r\n        special.price = _price; \r\n    }\r\n    \r\n    /**\r\n     * @dev Used by owner to change price of a special kitty or lower available population.\r\n     * @dev Owner may NOT increase available population to ensure their rarity to players.\r\n     * @param _specialId The unique Id of the special to edit (graduate is 50).\r\n     * @param _newPrice The desired new price of the special.\r\n     * @param _amountToDestroy The amount of this special that we want to lower supply for.\r\n    **/\r\n    function editSpecial(uint256 _specialId, uint256 _newPrice, uint16 _amountToDestroy)\r\n      external\r\n      onlyOwner\r\n    {\r\n        SpecialPersonality storage special = specialInfo[_specialId];\r\n        \r\n        if (_newPrice != 0) special.price = _newPrice;\r\n        if (_amountToDestroy != 0) {\r\n            require(_amountToDestroy <= special.population && _amountToDestroy <= special.amountLeft);\r\n            special.population -= _amountToDestroy;\r\n            special.amountLeft -= _amountToDestroy;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Owner may use to change any/every connected contract address.\r\n     * @dev Owner may leave params as null and nothing will happen to that variable.\r\n     * @param _newData The address of the new cuddle data contract if desired.\r\n     * @param _newCore The address of the new CK core contract if desired.\r\n     * @param _newKittyGym The address of the new KittyGym if desired.\r\n     * @param _newKittyData The address of the new KittyData contract.\r\n    **/\r\n    function changeContracts(address _newData, address _newCore, address _newKittyData, address _newKittyGym)\r\n      external\r\n      onlyOwner\r\n    {\r\n        if (_newData != 0) cuddleData = CuddleData(_newData);\r\n        if (_newCore != 0) core = KittyCore(_newCore);\r\n        if (_newKittyData != 0) kittyData = KittyData(_newKittyData);\r\n        if (_newKittyGym != 0) kittyGym = KittyGym(_newKittyGym);\r\n    }\r\n    \r\n/** ****************************** MODIFIERS ******************************* **/\r\n\r\n    /**\r\n     * @dev Ensure the sender is not a contract. This removes most of \r\n     * @dev the possibility of abuse of our timestamp/blockhash randomizers.\r\n    **/ \r\n    modifier isNotContract() {\r\n        uint size;\r\n        address addr = msg.sender;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size == 0);\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * @title Cuddle Coin\r\n * @dev A very straightforward ERC20 contract that also has minting abilities\r\n * @dev for people to be able to win coins and purchase coins. EFFECTIVELY CENTRALIZED!\r\n**/\r\n\r\ncontract CuddleCoin is Ownable {\r\n    string public constant symbol = \"CDL\";\r\n    string public constant name = \"CuddleCoin\";\r\n\r\n    address arenaContract; // Needed for minting.\r\n    address vendingMachine; // Needed for minting and burning.\r\n    address kittyGym; // Needed for burning.\r\n    \r\n    // Storing small numbers is cheaper.\r\n    uint8 public constant decimals = 18;\r\n    uint256 _totalSupply = 1000000 * (10 ** 18);\r\n\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _amount);\r\n    event Approval(address indexed _from, address indexed _spender, uint256 indexed _amount);\r\n    event Mint(address indexed _to, uint256 indexed _amount);\r\n    event Burn(address indexed _from, uint256 indexed _amount);\r\n\r\n    /**\r\n     * @dev Set owner and beginning balance.\r\n    **/\r\n    function CuddleCoin(address _arenaContract, address _vendingMachine)\r\n      public\r\n    {\r\n        balances[msg.sender] = _totalSupply;\r\n        arenaContract = _arenaContract;\r\n        vendingMachine = _vendingMachine;\r\n    }\r\n\r\n    /**\r\n     * @dev Return total supply of token\r\n    **/\r\n    function totalSupply() \r\n      external\r\n      constant \r\n     returns (uint256) \r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Return balance of a certain address.\r\n     * @param _owner The address whose balance we want to check.\r\n    **/\r\n    function balanceOf(address _owner)\r\n      external\r\n      constant \r\n    returns (uint256) \r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers coins from one address to another.\r\n     * @param _to The recipient of the transfer amount.\r\n     * @param _amount The amount of tokens to transfer.\r\n    **/\r\n    function transfer(address _to, uint256 _amount) \r\n      external\r\n    returns (bool success)\r\n    {\r\n        // Throw if insufficient balance\r\n        require(balances[msg.sender] >= _amount);\r\n\r\n        balances[msg.sender] -= _amount;\r\n        balances[_to] += _amount;\r\n\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev An allowed address can transfer tokens from another's address.\r\n     * @param _from The owner of the tokens to be transferred.\r\n     * @param _to The address to which the tokens will be transferred.\r\n     * @param _amount The amount of tokens to be transferred.\r\n    **/\r\n    function transferFrom(address _from, address _to, uint _amount)\r\n      external\r\n    returns (bool success)\r\n    {\r\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);\r\n\r\n        allowed[_from][msg.sender] -= _amount;\r\n        balances[_from] -= _amount;\r\n        balances[_to] += _amount;\r\n        \r\n        Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves a wallet to transfer tokens on one's behalf.\r\n     * @param _spender The wallet approved to spend tokens.\r\n     * @param _amount The amount of tokens approved to spend.\r\n    **/\r\n    function approve(address _spender, uint256 _amount) \r\n      external\r\n    {\r\n        require(_amount == 0 || allowed[msg.sender][_spender] == 0);\r\n        require(balances[msg.sender] >= _amount);\r\n        \r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Allowed amount for a user to spend of another's tokens.\r\n     * @param _owner The owner of the tokens approved to spend.\r\n     * @param _spender The address of the user allowed to spend the tokens.\r\n    **/\r\n    function allowance(address _owner, address _spender) \r\n      external\r\n      constant \r\n    returns (uint256) \r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    /**\r\n     * @dev Used only be vending machine and arena contract to mint to\r\n     * @dev token purchases and cuddlers in a battle.\r\n     * @param _to The address to which coins will be minted.\r\n     * @param _amount The amount of coins to be minted to that address.\r\n    **/\r\n    function mint(address _to, uint256 _amount)\r\n      external\r\n      onlyMinter\r\n    returns (bool success)\r\n    {\r\n        balances[_to] += _amount;\r\n        \r\n        Mint(_to, _amount);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Used by kitty gym and vending machine to take coins from users.\r\n     * @param _from The address that will have coins burned.\r\n     * @param _amount The amount of coins that will be burned.\r\n    **/\r\n    function burn(address _from, uint256 _amount)\r\n      external\r\n      onlyMinter\r\n    returns (bool success)\r\n    {\r\n        require(balances[_from] >= _amount);\r\n        \r\n        balances[_from] -= _amount;\r\n        Burn(_from, _amount);\r\n        return true;\r\n    }\r\n      \r\n    /**\r\n     * @dev Owner my change the contracts allowed to mint.\r\n     * @dev This gives owner full control over these tokens but since they are\r\n     * @dev not a normal cryptocurrency, centralization is not a problem.\r\n     * @param _arenaContract The first contract allowed to mint coins.\r\n     * @param _vendingMachine The second contract allowed to mint coins.\r\n    **/\r\n    function changeMinters(address _arenaContract, address _vendingMachine, address _kittyGym)\r\n      external\r\n      onlyOwner\r\n    returns (bool success)\r\n    {\r\n        if (_arenaContract != 0) arenaContract = _arenaContract;\r\n        if (_vendingMachine != 0) vendingMachine = _vendingMachine;\r\n        if (_kittyGym != 0) kittyGym = _kittyGym;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Arena contract and vending machine contract must be able to mint coins.\r\n     * @dev This modifier ensures no other contract may be able to mint.\r\n     * @dev Owner can change these permissions.\r\n    **/\r\n    modifier onlyMinter()\r\n    {\r\n        require(msg.sender == arenaContract || msg.sender == vendingMachine || msg.sender == kittyGym);\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"}],\"name\":\"returnKitty\",\"outputs\":[{\"name\":\"kittyType\",\"type\":\"uint8[2]\"},{\"name\":\"actionsArray\",\"type\":\"uint32[12]\"},{\"name\":\"level\",\"type\":\"uint16\"},{\"name\":\"totalBattles\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"},{\"name\":\"_moveSlot\",\"type\":\"uint256\"}],\"name\":\"fetchSlot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arenaContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"},{\"name\":\"_kittyType\",\"type\":\"uint256\"},{\"name\":\"_actions\",\"type\":\"uint256[5]\"}],\"name\":\"addKitty\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"},{\"name\":\"_newAction\",\"type\":\"uint256\"},{\"name\":\"_moveSlot\",\"type\":\"uint256\"}],\"name\":\"addAction\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"},{\"name\":\"_won\",\"type\":\"bool\"}],\"name\":\"incrementBattles\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kitties\",\"outputs\":[{\"name\":\"level\",\"type\":\"uint16\"},{\"name\":\"totalBattles\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"},{\"name\":\"_specialId\",\"type\":\"uint256\"},{\"name\":\"_actions\",\"type\":\"uint256[2]\"},{\"name\":\"_slots\",\"type\":\"uint256[2]\"}],\"name\":\"trainSpecial\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"specialContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gymContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gymContract\",\"type\":\"address\"},{\"name\":\"_specialContract\",\"type\":\"address\"},{\"name\":\"_arenaContract\",\"type\":\"address\"}],\"name\":\"changeContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_arenaContract\",\"type\":\"address\"},{\"name\":\"_gymContract\",\"type\":\"address\"},{\"name\":\"_specialContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"KittyData","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://a4f964ef02d6e4416d2ba952d3877bbee7654dfb49fa1fb03e35274faa513c62"}]}