{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract StorageBase is Ownable {\r\n\r\n    function withdrawBalance() external onlyOwner returns (bool) {\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = msg.sender.send(address(this).balance);\r\n        return res;\r\n    }\r\n}\r\n\r\ncontract ClockAuctionStorage is StorageBase {\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) at beginning of auction\r\n        uint128 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint128 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint64 duration;\r\n        // Time when auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n    function addAuction(\r\n        uint256 _tokenId,\r\n        address _seller,\r\n        uint128 _startingPrice,\r\n        uint128 _endingPrice,\r\n        uint64 _duration,\r\n        uint64 _startedAt\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        tokenIdToAuction[_tokenId] = Auction(\r\n            _seller,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            _startedAt\r\n        );\r\n    }\r\n\r\n    function removeAuction(uint256 _tokenId) public onlyOwner {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            address seller,\r\n            uint128 startingPrice,\r\n            uint128 endingPrice,\r\n            uint64 duration,\r\n            uint64 startedAt\r\n        )\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        return (\r\n            auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    function isOnAuction(uint256 _tokenId) external view returns (bool) {\r\n        return (tokenIdToAuction[_tokenId].startedAt > 0);\r\n    }\r\n\r\n    function getSeller(uint256 _tokenId) external view returns (address) {\r\n        return tokenIdToAuction[_tokenId].seller;\r\n    }\r\n\r\n    function transfer(ERC721 _nonFungibleContract, address _receiver, uint256 _tokenId) external onlyOwner {\r\n        // it will throw if transfer fails\r\n        _nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n}\r\n\r\ncontract SaleClockAuctionStorage is ClockAuctionStorage {\r\n    bool public isSaleClockAuctionStorage = true;\r\n\r\n    // total accumulate sold count\r\n    uint256 public totalSoldCount;\r\n\r\n    // last 3 sale price\r\n    uint256[3] public lastSoldPrices;\r\n\r\n    // current on sale auction count from system\r\n    uint256 public systemOnSaleCount;\r\n\r\n    // map of on sale token ids from system\r\n    mapping (uint256 => bool) systemOnSaleTokens;\r\n\r\n    function removeAuction(uint256 _tokenId) public onlyOwner {\r\n        // first remove auction from state variable\r\n        super.removeAuction(_tokenId);\r\n\r\n        // update system on sale record\r\n        if (systemOnSaleTokens[_tokenId]) {\r\n            delete systemOnSaleTokens[_tokenId];\r\n            \r\n            if (systemOnSaleCount > 0) {\r\n                systemOnSaleCount--;\r\n            }\r\n        }\r\n    }\r\n\r\n    function recordSystemOnSaleToken(uint256 _tokenId) external onlyOwner {\r\n        if (!systemOnSaleTokens[_tokenId]) {\r\n            systemOnSaleTokens[_tokenId] = true;\r\n            systemOnSaleCount++;\r\n        }\r\n    }\r\n\r\n    function recordSoldPrice(uint256 _price) external onlyOwner {\r\n        lastSoldPrices[totalSoldCount % 3] = _price;\r\n        totalSoldCount++;\r\n    }\r\n\r\n    function averageSoldPrice() external view returns (uint256) {\r\n        if (totalSoldCount == 0) return 0;\r\n        \r\n        uint256 sum = 0;\r\n        uint256 len = (totalSoldCount < 3 ? totalSoldCount : 3);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            sum += lastSoldPrices[i];\r\n        }\r\n        return sum / len;\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract HasNoContracts is Pausable {\r\n\r\n    function reclaimContract(address _contractAddr) external onlyOwner whenPaused {\r\n        Ownable contractInst = Ownable(_contractAddr);\r\n        contractInst.transferOwnership(owner);\r\n    }\r\n}\r\n\r\ncontract LogicBase is HasNoContracts {\r\n\r\n    /// The ERC-165 interface signature for ERC-721.\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\r\n    bytes4 constant InterfaceSignature_NFC = bytes4(0x9f40b779);\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    ERC721 public nonFungibleContract;\r\n\r\n    // Reference to storage contract\r\n    StorageBase public storageContract;\r\n\r\n    function LogicBase(address _nftAddress, address _storageAddress) public {\r\n        // paused by default\r\n        paused = true;\r\n\r\n        setNFTAddress(_nftAddress);\r\n\r\n        require(_storageAddress != address(0));\r\n        storageContract = StorageBase(_storageAddress);\r\n    }\r\n\r\n    // Very dangerous action, only when new contract has been proved working\r\n    // Requires storageContract already transferOwnership to the new contract\r\n    // This method is only used to transfer the balance to owner\r\n    function destroy() external onlyOwner whenPaused {\r\n        address storageOwner = storageContract.owner();\r\n        // owner of storageContract must not be the current contract otherwise the storageContract will forever not accessible\r\n        require(storageOwner != address(this));\r\n        // Transfers the current balance to the owner and terminates the contract\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // Very dangerous action, only when new contract has been proved working\r\n    // Requires storageContract already transferOwnership to the new contract\r\n    // This method is only used to transfer the balance to the new contract\r\n    function destroyAndSendToStorageOwner() external onlyOwner whenPaused {\r\n        address storageOwner = storageContract.owner();\r\n        // owner of storageContract must not be the current contract otherwise the storageContract will forever not accessible\r\n        require(storageOwner != address(this));\r\n        // Transfers the current balance to the new owner of the storage contract and terminates the contract\r\n        selfdestruct(storageOwner);\r\n    }\r\n\r\n    // override to make sure everything is initialized before the unpause\r\n    function unpause() public onlyOwner whenPaused {\r\n        // can not unpause when the logic contract is not initialzed\r\n        require(nonFungibleContract != address(0));\r\n        require(storageContract != address(0));\r\n        // can not unpause when ownership of storage contract is not the current contract\r\n        require(storageContract.owner() == address(this));\r\n\r\n        super.unpause();\r\n    }\r\n\r\n    function setNFTAddress(address _nftAddress) public onlyOwner {\r\n        require(_nftAddress != address(0));\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        require(candidateContract.supportsInterface(InterfaceSignature_NFC));\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    // Withdraw balance to the Core Contract\r\n    function withdrawBalance() external returns (bool) {\r\n        address nftAddress = address(nonFungibleContract);\r\n        // either Owner or Core Contract can trigger the withdraw\r\n        require(msg.sender == owner || msg.sender == nftAddress);\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = nftAddress.send(address(this).balance);\r\n        return res;\r\n    }\r\n\r\n    function withdrawBalanceFromStorageContract() external returns (bool) {\r\n        address nftAddress = address(nonFungibleContract);\r\n        // either Owner or Core Contract can trigger the withdraw\r\n        require(msg.sender == owner || msg.sender == nftAddress);\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = storageContract.withdrawBalance();\r\n        return res;\r\n    }\r\n}\r\n\r\ncontract ClockAuction is LogicBase {\r\n    \r\n    // Reference to contract tracking auction state variables\r\n    ClockAuctionStorage public clockAuctionStorage;\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    // Minimum cut value on each auction (in WEI)\r\n    uint256 public minCutValue;\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner, address seller, uint256 sellerProceeds);\r\n    event AuctionCancelled(uint256 tokenId);\r\n\r\n    function ClockAuction(address _nftAddress, address _storageAddress, uint256 _cut, uint256 _minCutValue) \r\n        LogicBase(_nftAddress, _storageAddress) public\r\n    {\r\n        setOwnerCut(_cut);\r\n        setMinCutValue(_minCutValue);\r\n\r\n        clockAuctionStorage = ClockAuctionStorage(_storageAddress);\r\n    }\r\n\r\n    function setOwnerCut(uint256 _cut) public onlyOwner {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n    }\r\n\r\n    function setMinCutValue(uint256 _minCutValue) public onlyOwner {\r\n        minCutValue = _minCutValue;\r\n    }\r\n\r\n    function getMinPrice() public view returns (uint256) {\r\n        // return ownerCut > 0 ? (minCutValue / ownerCut * 10000) : 0;\r\n        // use minCutValue directly, when the price == minCutValue seller will get no profit\r\n        return minCutValue;\r\n    }\r\n\r\n    // Only auction from none system user need to verify the price\r\n    // System auction can set any price\r\n    function isValidPrice(uint256 _startingPrice, uint256 _endingPrice) public view returns (bool) {\r\n        return (_startingPrice < _endingPrice ? _startingPrice : _endingPrice) >= getMinPrice();\r\n    }\r\n\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        public\r\n        whenNotPaused\r\n    {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        \r\n        // assigning ownership to this clockAuctionStorage when in auction\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transferFrom(_seller, address(clockAuctionStorage), _tokenId);\r\n\r\n        // Require that all auctions have a duration of at least one minute.\r\n        require(_duration >= 1 minutes);\r\n\r\n        clockAuctionStorage.addAuction(\r\n            _tokenId,\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n\r\n        emit AuctionCreated(_tokenId, _startingPrice, _endingPrice, _duration);\r\n    }\r\n\r\n    function cancelAuction(uint256 _tokenId) external {\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n        address seller = clockAuctionStorage.getSeller(_tokenId);\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    function cancelAuctionWhenPaused(uint256 _tokenId) external whenPaused onlyOwner {\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n        address seller = clockAuctionStorage.getSeller(_tokenId);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    function getAuction(uint256 _tokenId)\r\n        public\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n        return clockAuctionStorage.getAuction(_tokenId);\r\n    }\r\n\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n        return _currentPrice(_tokenId);\r\n    }\r\n\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        clockAuctionStorage.removeAuction(_tokenId);\r\n        clockAuctionStorage.transfer(nonFungibleContract, _seller, _tokenId);\r\n        emit AuctionCancelled(_tokenId);\r\n    }\r\n\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount, address bidder) internal returns (uint256) {\r\n\r\n        require(clockAuctionStorage.isOnAuction(_tokenId));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(_tokenId);\r\n        require(_bidAmount >= price);\r\n\r\n        address seller = clockAuctionStorage.getSeller(_tokenId);\r\n        uint256 sellerProceeds = 0;\r\n\r\n        // Remove the auction before sending the fees to the sender so we can't have a reentrancy attack\r\n        clockAuctionStorage.removeAuction(_tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the auctioneer's cut, so this subtraction can't go negative\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            sellerProceeds = price - auctioneerCut;\r\n\r\n            // transfer the sellerProceeds\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid\r\n        // transfer it back to bidder.\r\n        // this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n        bidder.transfer(bidExcess);\r\n\r\n        emit AuctionSuccessful(_tokenId, price, bidder, seller, sellerProceeds);\r\n\r\n        return price;\r\n    }\r\n\r\n    function _currentPrice(uint256 _tokenId) internal view returns (uint256) {\r\n\r\n        uint256 secondsPassed = 0;\r\n\r\n        address seller;\r\n        uint128 startingPrice;\r\n        uint128 endingPrice;\r\n        uint64 duration;\r\n        uint64 startedAt;\r\n        (seller, startingPrice, endingPrice, duration, startedAt) = clockAuctionStorage.getAuction(_tokenId);\r\n\r\n        if (now > startedAt) {\r\n            secondsPassed = now - startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            startingPrice,\r\n            endingPrice,\r\n            duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_secondsPassed >= _duration) {\r\n            return _endingPrice;\r\n        } else {\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        uint256 cutValue = _price * ownerCut / 10000;\r\n        if (_price < minCutValue) return cutValue;\r\n        if (cutValue > minCutValue) return cutValue;\r\n        return minCutValue;\r\n    }\r\n}\r\n\r\ncontract SaleClockAuction is ClockAuction {\r\n\r\n    bool public isSaleClockAuction = true;\r\n\r\n    address public systemSaleAddress;\r\n    uint256 public systemStartingPriceMin = 20 finney;\r\n    uint256 public systemEndingPrice = 0;\r\n    uint256 public systemAuctionDuration = 1 days;\r\n\r\n    function SaleClockAuction(address _nftAddr, address _storageAddress, address _systemSaleAddress, uint256 _cut, uint256 _minCutValue) \r\n        ClockAuction(_nftAddr, _storageAddress, _cut, _minCutValue) public\r\n    {\r\n        require(SaleClockAuctionStorage(_storageAddress).isSaleClockAuctionStorage());\r\n        \r\n        setSystemSaleAddress(_systemSaleAddress);\r\n    }\r\n  \r\n    function bid(uint256 _tokenId) external payable {\r\n        uint256 price = _bid(_tokenId, msg.value, msg.sender);\r\n        \r\n        clockAuctionStorage.transfer(nonFungibleContract, msg.sender, _tokenId);\r\n        \r\n        SaleClockAuctionStorage(clockAuctionStorage).recordSoldPrice(price);\r\n    }\r\n\r\n    function createSystemAuction(uint256 _tokenId) external {\r\n        require(msg.sender == address(nonFungibleContract));\r\n\r\n        createAuction(\r\n            _tokenId,\r\n            computeNextSystemSalePrice(),\r\n            systemEndingPrice,\r\n            systemAuctionDuration,\r\n            systemSaleAddress\r\n        );\r\n\r\n        SaleClockAuctionStorage(clockAuctionStorage).recordSystemOnSaleToken(_tokenId);\r\n    }\r\n\r\n    function setSystemSaleAddress(address _systemSaleAddress) public onlyOwner {\r\n        require(_systemSaleAddress != address(0));\r\n        systemSaleAddress = _systemSaleAddress;\r\n    }\r\n\r\n    function setSystemStartingPriceMin(uint256 _startingPrice) external onlyOwner {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        systemStartingPriceMin = _startingPrice;\r\n    }\r\n\r\n    function setSystemEndingPrice(uint256 _endingPrice) external onlyOwner {\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        systemEndingPrice = _endingPrice;\r\n    }\r\n\r\n    function setSystemAuctionDuration(uint256 _duration) external onlyOwner {\r\n        require(_duration == uint256(uint64(_duration)));\r\n        systemAuctionDuration = _duration;\r\n    }\r\n\r\n    function totalSoldCount() external view returns (uint256) {\r\n        return SaleClockAuctionStorage(clockAuctionStorage).totalSoldCount();\r\n    }\r\n\r\n    function systemOnSaleCount() external view returns (uint256) {\r\n        return SaleClockAuctionStorage(clockAuctionStorage).systemOnSaleCount();\r\n    }\r\n\r\n    function averageSoldPrice() external view returns (uint256) {\r\n        return SaleClockAuctionStorage(clockAuctionStorage).averageSoldPrice();\r\n    }\r\n\r\n    function computeNextSystemSalePrice() public view returns (uint256) {\r\n        uint256 avePrice = SaleClockAuctionStorage(clockAuctionStorage).averageSoldPrice();\r\n\r\n        require(avePrice == uint256(uint128(avePrice)));\r\n\r\n        uint256 nextPrice = avePrice + (avePrice / 2);\r\n\r\n        if (nextPrice < systemStartingPriceMin) {\r\n            nextPrice = systemStartingPriceMin;\r\n        }\r\n\r\n        return nextPrice;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"systemAuctionDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemOnSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"storageContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endingPrice\",\"type\":\"uint256\"}],\"name\":\"setSystemEndingPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemEndingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCutValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clockAuctionStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_systemSaleAddress\",\"type\":\"address\"}],\"name\":\"setSystemSaleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"averageSoldPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"setNFTAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"createSystemAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemStartingPriceMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cut\",\"type\":\"uint256\"}],\"name\":\"setOwnerCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemSaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSaleClockAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"}],\"name\":\"isValidPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyAndSendToStorageOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalanceFromStorageContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minCutValue\",\"type\":\"uint256\"}],\"name\":\"setMinCutValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startingPrice\",\"type\":\"uint256\"}],\"name\":\"setSystemStartingPriceMin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"computeNextSystemSalePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setSystemAuctionDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSoldCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nftAddr\",\"type\":\"address\"},{\"name\":\"_storageAddress\",\"type\":\"address\"},{\"name\":\"_systemSaleAddress\",\"type\":\"address\"},{\"name\":\"_cut\",\"type\":\"uint256\"},{\"name\":\"_minCutValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sellerProceeds\",\"type\":\"uint256\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SaleClockAuction","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a9e3440d5c64e99c77410ec4b15746b835add59e00000000000000000000000067c6a416a0a16f6a06989c43ba1e8e5b1d35da970000000000000000000000000761efe3e147af93b9f5c238913baf3bf241e71b00000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://9f3ad1b9a22a4fd54505f5e71568a206ab0ab37dec1bc59f7bfe6b64cda91429"}]}